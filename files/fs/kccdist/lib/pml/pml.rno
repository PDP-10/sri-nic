-.COMMENT        This file is the runoff header file for the
-.COMMENT	Portable Math Library (PML) documentation.
-.COMMENT
-.COMMENT	The complete RUNOFF source file "PML.RNO" is
-.COMMENT	generated by concatenating three files:
-.COMMENT
-.COMMENT	(1) "PML.HDR", a header file. (This file)
-.COMMENT
-.COMMENT	(2) The output of the DEX (documentation extractor)
-.COMMENT	program when run over the library source files
-.COMMENT	via a command of the form "DEX -m *.C >PML.BOD".
-.COMMENT	The resulting file is "PML.BOD" which is the body
-.COMMENT 	of the library documentation.
-.COMMENT
-.COMMENT	(3) "PML.TRL", a trailer file.
-.COMMENT
-.LAYOUT ,57,8,70
-.HEADER MIXED
-.FLAGS SUBINDEX
-.TAB STOPS 9,17,25,33,41,49,57,65,73
#
-.SKIP 14
-.CENTER;P M L    U S E R S   G U I D E
-.SKIP 2
-.CENTER;P o r t a b l e   M a t h   L i b r a r y
-.SKIP 2
-.CENTER;Version 1.1
-.SKIP 2
-.CENTER;February 10, 1983
-.SKIP 4
-.CENTER;by Fred Fish
-.SKIP 2
-.CENTER;G.A.C.A.
-.TITLE PML --- C Portable Math Library

-.SUBTITLE Introduction
-.PAGE
-.HEADER LEVEL 1 INTRODUCTION
-.INDEX document topics
-.HEADER LEVEL 2 Document structure
-.PARAGRAPH
This document describes the PML library, a
mathematical function library for C programs.
It contains the following major sections:
-.LIST ,o
-.LIST ELEMENT
Introduction to the document (this section).
-.LIST ELEMENT
A module description section which is automagically produced from
documentation in each module's source code by the DEX (Documentation
Extractor) task and "runoff", a text formatting program.
-.LIST ELEMENT
An index also produced from information in the source code.
-.END LIST

-.HEADER LEVEL 2 Design Considerations
-.PARAGRAPH
In writing this library many tradeoffs had to be considered.  The
primary design goal was transportability.  It was desired that
the final library be easily transportable among a wide class
of machines.  As of this release, the library has been used
with only minor modifications on
a DECSYSTEM-20 (a 36 bit machine), a VAX-11/780 under compatibility
mode, and various PDP-11's.

-.PARAGRAPH
This portability was achieved by careful isolation of machine
dependencies and parameterization of the environment (see references).
The only assumption made is that the C compiler can generate proper code for
the four basic operations (+,-,/,*).

-.PARAGRAPH
Even though efficiency
was considered to be of only secondary importance, the final routines
compared favorably with an informal test "race" against the
DECSYSTEM-20 FORTRAN, which has optimized assembly language
library routines.  The PML library routines seldom took
more than twice as long as the FORTRAN library, and many were
close enough to call a draw.

-.PARAGRAPH
There are currently only four highly machine dependent routines in
the Portable Math Library.  When transporting the library to a new machine,
these should be the only ones in which recoding is necessary.
These routines, written in machine targeted C, are:
-.LIST ,o
-.LIST ELEMENT
dscale --- scale a double precision floating point number by a specified
power of two.  Equivalent to multiplication or division
by a power of two, depending upon sign of the scale value.
-.LIST ELEMENT
dxexp --- extract exponent of double precision floating point number and
return it as an integer.
-.LIST ELEMENT
dxmant --- extract mantissa of double precision floating point number and
return it as a double precision floating point number.
-.LIST ELEMENT
dint --- discard fractional part of double precision number, returning
integer part as a double precision floating point
number.
-.END LIST

-.PARAGRAPH
The entire Portable Math Library is built upon six "primitives"
which compute their values from polynomial approximations.  All
others can be defined in terms of the primitives using various
identities.  The primitives are (1) datan, (2) dexp, (3) dln,
(4) dsin, (5) dcos, and (6) dsqrt.  Strictly speaking, only
one of dsin and dcos could be chosen as a primitive and the
other defined with an appropriate identity.  In this implementation
however, dsin and dcos call themselves recursively, and each other,
to perform range reduction.

-.HEADER LEVEL 2 Error Handling
-.PARAGRAPH
No assumptions are made about whether the four basic operations are done by
hardware or software.  Any overflows or underflows in the basic operations
are assumed to be handled by the environment, if at all.  Pathological
cases in the library routines are trapped internally and control
is passed to an error handler routine "pmlerr"
(which may be replaced with
one of the user's choosing) for error recovery.

-.PARAGRAPH
The default error handler is conceptually similar to the one used by DEC for
the FORTRAN compilers.  It contains an internal table which
allows various actions to be taken for each error recognized.
Currently each error has a corresponding flag word with three
bits, each bit assigned as follows:
-.LIST ,o
-.LIST ELEMENT
CONTINUE --- If the bit is set control is returned to the calling
routine after completion of error processing.  Otherwise
the task exits with an error status.
-.LIST ELEMENT
LOG --- If the log bit is set then an error warning message is
written to the standard error output channel prior to exiting
or continuing.  If reset, no message is given.
-.LIST ELEMENT
COUNT --- If the count bit is set then the task's PML
error count (internal to the error handler) is incremented.
If the total error count exceeds the maximum allowed
then the task exits with
error status.  If the count bit is reset then the error
is ignored with respect to the error count and exit on limit.
-.END LIST

-.PARAGRAPH
The default conditions in the error handler for all errors
is that the CONTINUE, LOG, and COUNT bits are all set.  The
error limit is set at 10.  These values can be changed by
suitably editing the header file "pml.h"
and _<pmluser.h_>.

-.PARAGRAPH
The error handler responses can also be changed dynamically
via the following routines:
-.LIST ,o
-.LIST ELEMENT
PMLSFS --- Sets the specified bits in the specified error's
flag word.
For example, "pmlsfs(NEG__DSQRT,CONTINUE | LOG)" sets
the CONTINUE and LOG bits for the "double precision square root
of a negative number" error.  The COUNT bit is not affected.
The manifest constant values are defined in <pmluser.h>.
-.LIST ELEMENT
PMLCFS --- Clears the specified bits in the specified error's
flag word.
For example, "pmlcfs(NEG__DSQRT,CONTINUE | LOG)" clears
the CONTINUE and LOG bits for the "double precision square root
of a negative number" error.  The COUNT bit is not affected.
The manifest constant values are defined in <pmluser.h>.
-.LIST ELEMENT
PMLLIM --- Changes the task's PML error limit to
the specified value and returns the previous value.
-.LIST ELEMENT
PMLCNT --- Returns the current value of the PML error
count and resets it back to zero.
-.END LIST

-.HEADER LEVEL 2 Function Names
-.PARAGRAPH
In general, FORTRAN naming conventions were followed since no
other more obvious convention was apparent.  There is one
strong exception however, and that is the natural
logarithm functions use the generic name "ln" while the
logarithm to the base 10 functions use the name "log".
This is consistent with the normal usage in virtually all
modern mathematical and engineering texts.  How FORTRAN came
to use "log" and "log10" respectively is beyond me.
This usage has bitten many a starting FORTRAN programmer.

-.HEADER LEVEL 2 Installation
-.PARAGRAPH
As part of the installation kit, some simple minded testing programs
are provided.  They are by no means exhaustive tests or ones that
carefully check possible trouble areas.  They are intended to
provide a quick and dirty way of verifying that no gross errors
are inadvertently incorporated in the library as a result of
improvements or bug fixes, and that the installation is successful.
Future releases may incorporate more extensive test routines
and suggestions are solicited.

-.HEADER LEVEL 2 Bugs
-.PARAGRAPH
On the subject of bugs, all exterminators are encouraged
to notify the author of any problems or fixes so that
they can be incorporated into the next release and renegade
versions of the library can be minimized.
Contact:
-.SKIP 2
-.NOFILL
		Fred Fish
		1346 W 10th Place
		Tempe, Arizona 85281
-.SKIP
		(602) 894-6881   (home)
		(602) 932-7000   (work @ GACA)
-.FILL
-.PARAGRAPH
Those users with strong numerical analysis backgrounds or experience
may be able to suggest better methods for some of the library routines.
Many of the higher level routines are simple minded implementations
of identities, and may not be nearly as stable as some more obscure
methods.

-.HEADER LEVEL 2  Transporting To Other Machines
-.PARAGRAPH
To transport the Portable Math Library to a processor other than
the PDP11 or DECSYSTEM-20, do the following:
-.LIST ,o
-.LIST ELEMENT
Define the machine dependent parameters in "pml.h".
-.LIST ELEMENT
implement the four machine dependent modules listed previously,
possibly by using the current versions as a guide.
-.LIST ELEMENT
Compile the rest of the library modules and the testing routines.
Then link and run the testing routines to verify successful installation.
-.LIST ELEMENT
Repeat as required.
-.END LIST

-.SUBTITLE Runtime modules
-.PAGE
-.HEADER LEVEL 1 RUNTIME MODULES

-.PARAGRAPH
The PML modules are documented on the following pages.
All the rest of this section was produced by the DEX (documentation
extractor) utility directly from the source files.  Thus
the information reflects the current state of the runtime
modules.
-.COMMENT Beginning source file CABS.C.11
-.SUBTITLE CABS
-.PAGE
-.HEADER LEVEL 2 Double precision complex absolute value

-.SKIP 3
-.CENTER ;********
-.CENTER ;* CABS *
-.CENTER ;********
-.SKIP 3
-.INDEX  CABS
-.INDEX  complex functions
-.INDEX  machine independent routines
-.INDEX  math libraries
-.SKIP 1 .test page 4
DESCRIPTION:
-.FILL .LEFT MARGIN 9
-.SKIP 1
Computes double precision absolute value of a double
precision complex argument, where "absolute value"
is taken to mean magnitude.  The result replaces the
argument.
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
USAGE:
-.FILL .LEFT MARGIN 9
-.SKIP 1
-.NOFILL
double cabs(z)
COMPLEX *z;
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
PROGRAMMER:
-.FILL .LEFT MARGIN 9
-.SKIP 1
-.NOFILL
Fred Fish
Goodyear Aerospace Corp, Arizona Div.
(602) 932-7000 work
(602) 894-6881 home
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
INTERNALS:
-.FILL .LEFT MARGIN 9
-.SKIP 1
Computes CABS(z) where z _= (x) + j(y) from:
-.SKIP 1
-.NOFILL
	CABS(z) _= DSQRT(x*x + y*y)
-.SKIP 1
-.LEFT MARGIN 0
-.COMMENT Beginning source file CACOS.C.7
-.SUBTITLE CACOS
-.PAGE
-.HEADER LEVEL 2 Complex double precision arc cosine

-.SKIP 3
-.CENTER ;*********
-.CENTER ;* CACOS *
-.CENTER ;*********
-.SKIP 3
-.INDEX  CACOS
-.INDEX  complex functions
-.INDEX  machine independent routines
-.INDEX  math libraries
-.SKIP 1 .test page 4
DESCRIPTION:
-.FILL .LEFT MARGIN 9
-.SKIP 1
Computes double precision complex arc cosine of
a double precision complex argument.
The result replaces the argument.
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
USAGE:
-.FILL .LEFT MARGIN 9
-.SKIP 1
-.NOFILL
cacos(z)
COMPLEX *z;
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
REFERENCES:
-.FILL .LEFT MARGIN 9
-.SKIP 1
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
RESTRICTIONS:
-.FILL .LEFT MARGIN 9
-.SKIP 1
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
PROGRAMMER:
-.FILL .LEFT MARGIN 9
-.SKIP 1
-.NOFILL
Fred Fish
Goodyear Aerospace Corp, Arizona Div.
(602) 932-7000 work
(602) 894-6881 home
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
INTERNALS:
-.FILL .LEFT MARGIN 9
-.SKIP 1
Computes complex arc cosine of Z _= x + j y from:
-.SKIP 1
-.NOFILL
   CACOS(z) _= -j * CLN(z + j * CSQRT(1-z*z))
-.SKIP 1
-.LEFT MARGIN 0
-.COMMENT Beginning source file CADD.C.9
-.SUBTITLE CADD
-.PAGE
-.HEADER LEVEL 2 Double precision complex addition

-.SKIP 3
-.CENTER ;********
-.CENTER ;* CADD *
-.CENTER ;********
-.SKIP 3
-.INDEX  CADD
-.INDEX  complex functions
-.INDEX  machine independent routines
-.INDEX  math libraries
-.SKIP 1 .test page 4
DESCRIPTION:
-.FILL .LEFT MARGIN 9
-.SKIP 1
Computes double precision complex result of addition of
first double precision complex argument with second double
precision complex argument.  The result replaces the
first argument.  Note that the complex addition function is
so simple that it would not normally be called as a function
but simply done "inline".  It is supplied mostly for
completeness.
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
USAGE:
-.FILL .LEFT MARGIN 9
-.SKIP 1
-.NOFILL
double cadd(z1,z2)
COMPLEX *z1;
COMPLEX *z2;
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
PROGRAMMER:
-.FILL .LEFT MARGIN 9
-.SKIP 1
-.NOFILL
Fred Fish
Goodyear Aerospace Corp, Arizona Div.
(602) 932-7000 work
(602) 894-6881 home
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
INTERNALS:
-.FILL .LEFT MARGIN 9
-.SKIP 1
Computes CADD(z1,z2) from:
-.SKIP 1
-.NOFILL
	1.	Let z1 _= a + j b
		Let z2 _= c + j d
-.SKIP 1
	2.	Then CADD(z1,z2) _= (a + c) + j (b + d)
-.SKIP 1
-.LEFT MARGIN 0
-.COMMENT Beginning source file CASIN.C.8
-.SUBTITLE CASIN
-.PAGE
-.HEADER LEVEL 2 Complex double precision arc sine

-.SKIP 3
-.CENTER ;*********
-.CENTER ;* CASIN *
-.CENTER ;*********
-.SKIP 3
-.INDEX  CASIN
-.INDEX  machine independent routines
-.INDEX  complex functions
-.INDEX  math libraries
-.SKIP 1 .test page 4
DESCRIPTION:
-.FILL .LEFT MARGIN 9
-.SKIP 1
Computes double precision complex arc sine of
a double precision complex argument.
The result replaces the argument.
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
USAGE:
-.FILL .LEFT MARGIN 9
-.SKIP 1
-.NOFILL
casin(z)
COMPLEX *z;
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
REFERENCES:
-.FILL .LEFT MARGIN 9
-.SKIP 1
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
RESTRICTIONS:
-.FILL .LEFT MARGIN 9
-.SKIP 1
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
PROGRAMMER:
-.FILL .LEFT MARGIN 9
-.SKIP 1
-.NOFILL
Fred Fish
Goodyear Aerospace Corp, Arizona Div.
(602) 932-7000 work
(602) 894-6881 home
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
INTERNALS:
-.FILL .LEFT MARGIN 9
-.SKIP 1
Computes complex arc sine of Z _= x + j y from:
-.SKIP 1
-.NOFILL
   CASIN(z) _= -j * CLN(CSQRT(1-z*z) + j*z)
-.SKIP 1
-.LEFT MARGIN 0
-.COMMENT Beginning source file CATAN.C.5
-.SUBTITLE CATAN
-.PAGE
-.HEADER LEVEL 2 Complex double precision arc tangent

-.SKIP 3
-.CENTER ;*********
-.CENTER ;* CATAN *
-.CENTER ;*********
-.SKIP 3
-.INDEX  CATAN
-.INDEX  machine independent routines
-.INDEX  complex functions
-.INDEX  math libraries
-.SKIP 1 .test page 4
DESCRIPTION:
-.FILL .LEFT MARGIN 9
-.SKIP 1
Computes double precision complex arc tangent of
a double precision complex argument.
The result replaces the argument.
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
USAGE:
-.FILL .LEFT MARGIN 9
-.SKIP 1
-.NOFILL
catan(z)
COMPLEX *z;
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
REFERENCES:
-.FILL .LEFT MARGIN 9
-.SKIP 1
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
RESTRICTIONS:
-.FILL .LEFT MARGIN 9
-.SKIP 1
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
PROGRAMMER:
-.FILL .LEFT MARGIN 9
-.SKIP 1
-.NOFILL
Fred Fish
Goodyear Aerospace Corp, Arizona Div.
(602) 932-7000 work
(602) 894-6881 home
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
INTERNALS:
-.FILL .LEFT MARGIN 9
-.SKIP 1
Computes complex arc tangent of Z _= x + j y from:
-.SKIP 1
-.NOFILL
   CATAN(z) _= -j/2 * CLN( (j+z) / (j-z) )
-.SKIP 1
-.LEFT MARGIN 0
-.COMMENT Beginning source file CCOS.C.7
-.SUBTITLE CCOS
-.PAGE
-.HEADER LEVEL 2 Complex double precision cosine

-.SKIP 3
-.CENTER ;********
-.CENTER ;* CCOS *
-.CENTER ;********
-.SKIP 3
-.INDEX  CCOS
-.INDEX  complex functions
-.INDEX  machine independent routines
-.INDEX  math libraries
-.SKIP 1 .test page 4
DESCRIPTION:
-.FILL .LEFT MARGIN 9
-.SKIP 1
Computes double precision complex cosine of
a double precision complex argument.
The result replaces the argument.
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
USAGE:
-.FILL .LEFT MARGIN 9
-.SKIP 1
-.NOFILL
ccos(z)
COMPLEX *z;
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
REFERENCES:
-.FILL .LEFT MARGIN 9
-.SKIP 1
Fortran 77 user's guide, Digital Equipment Corp. pp B-12
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
RESTRICTIONS:
-.FILL .LEFT MARGIN 9
-.SKIP 1
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
PROGRAMMER:
-.FILL .LEFT MARGIN 9
-.SKIP 1
-.NOFILL
Fred Fish
Goodyear Aerospace Corp, Arizona Div.
(602) 932-7000 work
(602) 894-6881 home
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
INTERNALS:
-.FILL .LEFT MARGIN 9
-.SKIP 1
Computes complex cosine of Z _= x + j y from:
-.SKIP 1
-.NOFILL
	1.	R__CCOS _= DCOS(x) * DCOSH(y)
-.SKIP 1
	2.	I__CCOS _= -DSIN(x) * DSINH(y)
-.SKIP 1
	Then	CCOS(z) _= R__CCOS + j I__CCOS
-.SKIP 1
-.LEFT MARGIN 0
-.COMMENT Beginning source file CCOSH.C.7
-.SUBTITLE CCOSH
-.PAGE
-.HEADER LEVEL 2 Complex double precision hyperbolic cosine

-.SKIP 3
-.CENTER ;*********
-.CENTER ;* CCOSH *
-.CENTER ;*********
-.SKIP 3
-.INDEX  CCOSH
-.INDEX  machine independent routines
-.INDEX  complex functions
-.INDEX  math libraries
-.SKIP 1 .test page 4
DESCRIPTION:
-.FILL .LEFT MARGIN 9
-.SKIP 1
Computes double precision complex hyperbolic cosine of
a double precision complex argument.
The result replaces the argument.
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
USAGE:
-.FILL .LEFT MARGIN 9
-.SKIP 1
-.NOFILL
ccosh(z)
COMPLEX *z;
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
REFERENCES:
-.FILL .LEFT MARGIN 9
-.SKIP 1
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
RESTRICTIONS:
-.FILL .LEFT MARGIN 9
-.SKIP 1
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
PROGRAMMER:
-.FILL .LEFT MARGIN 9
-.SKIP 1
-.NOFILL
Fred Fish
Goodyear Aerospace Corp, Arizona Div.
(602) 932-7000 work
(602) 894-6881 home
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
INTERNALS:
-.FILL .LEFT MARGIN 9
-.SKIP 1
Computes complex hyperbolic cosine of Z _= x + j y from:
-.SKIP 1
-.NOFILL
   CCOSH(z) _= 0.5 * ( CEXP(z) + CEXP(-z) )
-.SKIP 1
-.LEFT MARGIN 0
-.COMMENT Beginning source file CDIV.C.11
-.SUBTITLE CDIV
-.PAGE
-.HEADER LEVEL 2 Double precision complex division

-.SKIP 3
-.CENTER ;********
-.CENTER ;* CDIV *
-.CENTER ;********
-.SKIP 3
-.INDEX  CDIV
-.INDEX  complex functions
-.INDEX  machine independent routines
-.INDEX  math libraries
-.SKIP 1 .test page 4
DESCRIPTION:
-.FILL .LEFT MARGIN 9
-.SKIP 1
Computes double precision complex result of division of
first double precision complex argument by second double
precision complex argument.  The result replaces the
numerator.
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
USAGE:
-.FILL .LEFT MARGIN 9
-.SKIP 1
-.NOFILL
double cdiv(numerator,denominator)
COMPLEX *numerator;
COMPLEX *denominator;
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
PROGRAMMER:
-.FILL .LEFT MARGIN 9
-.SKIP 1
-.NOFILL
Fred Fish
Goodyear Aerospace Corp, Arizona Div.
(602) 932-7000 work
(602) 894-6881 home
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
INTERNALS:
-.FILL .LEFT MARGIN 9
-.SKIP 1
Computes CDIV(znum,zden) from:
-.SKIP 1
-.NOFILL
	1.	Let znum _= a + j b
		Let zden _= c + j d
-.SKIP 1
	2.	denom _= c*c + d*d
-.SKIP 1
	3.	If denom is zero then log error,
		set r__cdiv _= maximum floating value,
		i__cdiv _= 0, and go to step 5.
-.SKIP 1
	4.	r__cdiv _= (a*c + b*d) / denom
		i__cdiv _= (c*b - a*d) / denom
-.SKIP 1
	5.	Then CDIV(znum,zden) _= r__cdiv + j i__cdiv
-.SKIP 1
-.LEFT MARGIN 0
-.COMMENT Beginning source file CEXP.C.5
-.SUBTITLE CEXP
-.PAGE
-.HEADER LEVEL 2 Complex double precision exponential

-.SKIP 3
-.CENTER ;********
-.CENTER ;* CEXP *
-.CENTER ;********
-.SKIP 3
-.INDEX  CEXP
-.INDEX  complex functions
-.INDEX  machine independent routines
-.INDEX  math libraries
-.SKIP 1 .test page 4
DESCRIPTION:
-.FILL .LEFT MARGIN 9
-.SKIP 1
Computes double precision complex exponential of
a double precision complex argument.
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
USAGE:
-.FILL .LEFT MARGIN 9
-.SKIP 1
-.NOFILL
cexp(z)
COMPLEX *z;
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
REFERENCES:
-.FILL .LEFT MARGIN 9
-.SKIP 1
Fortran 77 user's guide, Digital Equipment Corp. pp B-13
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
RESTRICTIONS:
-.FILL .LEFT MARGIN 9
-.SKIP 1
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
PROGRAMMER:
-.FILL .LEFT MARGIN 9
-.SKIP 1
-.NOFILL
Fred Fish
Goodyear Aerospace Corp, Arizona Div.
(602) 932-7000 work
(602) 894-6881 home
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
INTERNALS:
-.FILL .LEFT MARGIN 9
-.SKIP 1
Computes complex exponential of Z _= x + j y from:
-.SKIP 1
-.NOFILL
	1.	R__CEXP _= DEXP(x) * DCOS(y)
-.SKIP 1
	2.	I__CEXP _= DEXP(x) * DSIN(y)
-.SKIP 1
	Then	CEXP(z) _= R__CEXP + j I__CEXP
-.SKIP 1
-.LEFT MARGIN 0
-.COMMENT Beginning source file CLN.C.8
-.SUBTITLE CLN
-.PAGE
-.HEADER LEVEL 2 Complex double precision natural logarithm

-.SKIP 3
-.CENTER ;*******
-.CENTER ;* CLN *
-.CENTER ;*******
-.SKIP 3
-.INDEX  CLN
-.INDEX  complex functions
-.INDEX  machine independent routines
-.INDEX  math libraries
-.SKIP 1 .test page 4
DESCRIPTION:
-.FILL .LEFT MARGIN 9
-.SKIP 1
Computes double precision complex natural logarithm of
a double precision complex argument.  The result replaces
the argument.
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
USAGE:
-.FILL .LEFT MARGIN 9
-.SKIP 1
-.NOFILL
cln(z)
COMPLEX *z;
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
REFERENCES:
-.FILL .LEFT MARGIN 9
-.SKIP 1
Fortran 77 user's guide, Digital Equipment Corp. pp B-13
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
RESTRICTIONS:
-.FILL .LEFT MARGIN 9
-.SKIP 1
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
PROGRAMMER:
-.FILL .LEFT MARGIN 9
-.SKIP 1
-.NOFILL
Fred Fish
Goodyear Aerospace Corp, Arizona Div.
(602) 932-7000 work
(602) 894-6881 home
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
INTERNALS:
-.FILL .LEFT MARGIN 9
-.SKIP 1
Computes complex natural logarithm of Z _= x + j y from:
-.SKIP 1
-.NOFILL
	1.	R__CLN _= DLN(CABS(z))
-.SKIP 1
	2.	I__CLN _= DATAN2(y,x)
-.SKIP 1
	Then	CLN(z) _= R__CLN + j I__CLN
-.SKIP 1
-.LEFT MARGIN 0
-.COMMENT Beginning source file CMULT.C.13
-.SUBTITLE CMULT
-.PAGE
-.HEADER LEVEL 2 Double precision complex multiplication

-.SKIP 3
-.CENTER ;*********
-.CENTER ;* CMULT *
-.CENTER ;*********
-.SKIP 3
-.INDEX  CMULT
-.INDEX  complex functions
-.INDEX  machine independent routines
-.INDEX  math libraries
-.SKIP 1 .test page 4
DESCRIPTION:
-.FILL .LEFT MARGIN 9
-.SKIP 1
Computes double precision complex result of multiplication of
first double precision complex argument by second double
precision complex argument.  The result replaces the
first argument.
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
USAGE:
-.FILL .LEFT MARGIN 9
-.SKIP 1
-.NOFILL
double cmult(z1,z2)
COMPLEX *z1;
COMPLEX *z2;
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
PROGRAMMER:
-.FILL .LEFT MARGIN 9
-.SKIP 1
-.NOFILL
Fred Fish
Goodyear Aerospace Corp, Arizona Div.
(602) 932-7000 work
(602) 894-6881 home
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
INTERNALS:
-.FILL .LEFT MARGIN 9
-.SKIP 1
Computes CMULT(z1,z2) from:
-.SKIP 1
-.NOFILL
	1.	Let z1 _= a + j b
		Let z2 _= c + j d
-.SKIP 1
	2.	r__cmult _= (a*c - b*d)
		i__cmult _= (a*d + c*b)
-.SKIP 1
	3.	Then CMULT(z1,z2) _= r__cmult + j i__cmult
-.SKIP 1
-.LEFT MARGIN 0
-.COMMENT Beginning source file CPRINT.C.12
-.COMMENT Beginning source file CRCP.C.8
-.SUBTITLE CRCP
-.PAGE
-.HEADER LEVEL 2 complex double precision reciprocal

-.SKIP 3
-.CENTER ;********
-.CENTER ;* CRCP *
-.CENTER ;********
-.SKIP 3
-.INDEX  CRCP
-.INDEX  complex functions
-.INDEX  math libraries
-.SKIP 1 .test page 4
DESCRIPTION:
-.FILL .LEFT MARGIN 9
-.SKIP 1
Computes double precision complex reciprocal of
a double precision complex argument.  The result replaces
the argument.
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
USAGE:
-.FILL .LEFT MARGIN 9
-.SKIP 1
-.NOFILL
crcp(z)
COMPLEX *z;
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
REFERENCES:
-.FILL .LEFT MARGIN 9
-.SKIP 1
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
RESTRICTIONS:
-.FILL .LEFT MARGIN 9
-.SKIP 1
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
PROGRAMMER:
-.FILL .LEFT MARGIN 9
-.SKIP 1
-.NOFILL
Fred Fish
Goodyear Aerospace Corp, Arizona Div.
(602) 932-7000 work
(602) 894-6881 home
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
INTERNALS:
-.FILL .LEFT MARGIN 9
-.SKIP 1
Computes complex reciprocal of Z _= x + j y from:
-.SKIP 1
-.NOFILL
	1.	Compute denom _= x*x + y*y
-.SKIP 1
	2.	If denom _= 0.0 then flag error
		and return MAX__POS__DBLF + j 0.0
-.SKIP 1
	3.	Else CRCP(z) _= (x/denom) + j (-y/denom)
-.SKIP 1
-.LEFT MARGIN 0
-.COMMENT Beginning source file CSIN.C.7
-.SUBTITLE CSIN
-.PAGE
-.HEADER LEVEL 2 Complex double precision sine

-.SKIP 3
-.CENTER ;********
-.CENTER ;* CSIN *
-.CENTER ;********
-.SKIP 3
-.INDEX  CSIN
-.INDEX  complex functions
-.INDEX  machine independent routines
-.INDEX  math libraries
-.SKIP 1 .test page 4
DESCRIPTION:
-.FILL .LEFT MARGIN 9
-.SKIP 1
Computes double precision complex sine of
a double precision complex argument.
The result replaces the argument.
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
USAGE:
-.FILL .LEFT MARGIN 9
-.SKIP 1
-.NOFILL
csin(z)
COMPLEX *z;
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
REFERENCES:
-.FILL .LEFT MARGIN 9
-.SKIP 1
Fortran 77 user's guide, Digital Equipment Corp. pp B-12
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
RESTRICTIONS:
-.FILL .LEFT MARGIN 9
-.SKIP 1
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
PROGRAMMER:
-.FILL .LEFT MARGIN 9
-.SKIP 1
-.NOFILL
Fred Fish
Goodyear Aerospace Corp, Arizona Div.
(602) 932-7000 work
(602) 894-6881 home
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
INTERNALS:
-.FILL .LEFT MARGIN 9
-.SKIP 1
Computes complex sine of Z _= x + j y from:
-.SKIP 1
-.NOFILL
	1.	R__CSIN _= DSIN(x) * DCOSH(y)
-.SKIP 1
	2.	I__CSIN _= DCOS(x) * DSINH(y)
-.SKIP 1
	Then	CSIN(z) _= R__CSIN + j I__CSIN
-.SKIP 1
-.LEFT MARGIN 0
-.COMMENT Beginning source file CSINH.C.13
-.SUBTITLE CSINH
-.PAGE
-.HEADER LEVEL 2 Complex double precision hyperbolic sine

-.SKIP 3
-.CENTER ;*********
-.CENTER ;* CSINH *
-.CENTER ;*********
-.SKIP 3
-.INDEX  CSINH
-.INDEX  machine independent routines
-.INDEX  complex functions
-.INDEX  math libraries
-.SKIP 1 .test page 4
DESCRIPTION:
-.FILL .LEFT MARGIN 9
-.SKIP 1
Computes double precision complex hyperbolic sine of
a double precision complex argument.
The result replaces the argument.
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
USAGE:
-.FILL .LEFT MARGIN 9
-.SKIP 1
-.NOFILL
csinh(z)
COMPLEX *z;
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
REFERENCES:
-.FILL .LEFT MARGIN 9
-.SKIP 1
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
RESTRICTIONS:
-.FILL .LEFT MARGIN 9
-.SKIP 1
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
PROGRAMMER:
-.FILL .LEFT MARGIN 9
-.SKIP 1
-.NOFILL
Fred Fish
Goodyear Aerospace Corp, Arizona Div.
(602) 932-7000 work
(602) 894-6881 home
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
INTERNALS:
-.FILL .LEFT MARGIN 9
-.SKIP 1
Computes complex hyperbolic sine of Z _= x + j y from:
-.SKIP 1
-.NOFILL
   CSINH(z) _= 0.5 * ( CEXP(z) - CEXP(-z) )
-.SKIP 1
-.LEFT MARGIN 0
-.COMMENT Beginning source file CSQRT.C.19
-.SUBTITLE CSQRT
-.PAGE
-.HEADER LEVEL 2 Complex double precision square root

-.SKIP 3
-.CENTER ;*********
-.CENTER ;* CSQRT *
-.CENTER ;*********
-.SKIP 3
-.INDEX  CSQRT
-.INDEX  machine independent routines
-.INDEX  complex functions
-.INDEX  math libraries
-.SKIP 1 .test page 4
DESCRIPTION:
-.FILL .LEFT MARGIN 9
-.SKIP 1
Computes double precision complex square root of
a double precision complex argument.  The result replaces
the argument.
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
USAGE:
-.FILL .LEFT MARGIN 9
-.SKIP 1
-.NOFILL
csqrt(z)
COMPLEX *z;
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
REFERENCES:
-.FILL .LEFT MARGIN 9
-.SKIP 1
Fortran 77 user's guide, Digital Equipment Corp. pp B-12
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
RESTRICTIONS:
-.FILL .LEFT MARGIN 9
-.SKIP 1
The relative error in the double precision square root
computation is 10**(-30.1) after three applications
of Heron's iteration for the square root.
-.SKIP 1
However, this assumes exact arithmetic in the iterations
and initial approximation.  Additional errors may occur
due to truncation, rounding, or machine precision limits.
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
PROGRAMMER:
-.FILL .LEFT MARGIN 9
-.SKIP 1
-.NOFILL
Fred Fish
Goodyear Aerospace Corp, Arizona Div.
(602) 932-7000 work
(602) 894-6881 home
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
INTERNALS:
-.FILL .LEFT MARGIN 9
-.SKIP 1
Computes complex square root of Z _= x + j y from:
-.SKIP 1
-.NOFILL
	1.	ROOT _= DSQRT((DABS(x) + CABS(Z)) / 2)
-.SKIP 1
	2.	Q _= y / (2 * ROOT)
-.SKIP 1
	3.	If x >_= 0 then
		CSQRT(Z) _= (ROOT,Q)
-.SKIP 1
	4.	If x _< 0 and y >_= 0 then
		CSQRT(Z) _= (Q,ROOT)
-.SKIP 1
	5.	If x _< 0 and y _< 0 then
		CSQRT(Z) _= (-Q,ROOT)
-.SKIP 1
-.LEFT MARGIN 0
-.COMMENT Beginning source file CSUBT.C.5
-.SUBTITLE CSUBT
-.PAGE
-.HEADER LEVEL 2 Double precision complex subtraction

-.SKIP 3
-.CENTER ;*********
-.CENTER ;* CSUBT *
-.CENTER ;*********
-.SKIP 3
-.INDEX  CSUBT
-.INDEX  machine independent routines
-.INDEX  complex functions
-.INDEX  math libraries
-.SKIP 1 .test page 4
DESCRIPTION:
-.FILL .LEFT MARGIN 9
-.SKIP 1
Computes double precision complex result of subtraction of
second double precision complex argument from first double
precision complex argument.  The result replaces the
first argument.  Note that the complex subtraction function is
so simple that it would not normally be called as a function
but simply done "inline".  It is supplied mostly for
completeness.
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
USAGE:
-.FILL .LEFT MARGIN 9
-.SKIP 1
-.NOFILL
double csubt(z1,z2)
COMPLEX *z1;
COMPLEX *z2;
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
PROGRAMMER:
-.FILL .LEFT MARGIN 9
-.SKIP 1
-.NOFILL
Fred Fish
Goodyear Aerospace Corp, Arizona Div.
(602) 932-7000 work
(602) 894-6881 home
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
INTERNALS:
-.FILL .LEFT MARGIN 9
-.SKIP 1
Computes CSUBT(z1,z2) from:
-.SKIP 1
-.NOFILL
	1.	Let z1 _= a + j b
		Let z2 _= c + j d
-.SKIP 1
	2.	Then CSUBT(z1,z2) _= (a - c) + j (b - d)
-.SKIP 1
-.LEFT MARGIN 0
-.COMMENT Beginning source file CTAN.C.13
-.SUBTITLE CTAN
-.PAGE
-.HEADER LEVEL 2 Complex double precision tangent

-.SKIP 3
-.CENTER ;********
-.CENTER ;* CTAN *
-.CENTER ;********
-.SKIP 3
-.INDEX  CTAN
-.INDEX  complex functions
-.INDEX  machine independent functions
-.INDEX  math libraries
-.SKIP 1 .test page 4
DESCRIPTION:
-.FILL .LEFT MARGIN 9
-.SKIP 1
Computes double precision complex tangent of
a double precision complex argument.
The result replaces the argument.
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
USAGE:
-.FILL .LEFT MARGIN 9
-.SKIP 1
-.NOFILL
ctan(z)
COMPLEX *z;
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
PROGRAMMER:
-.FILL .LEFT MARGIN 9
-.SKIP 1
-.NOFILL
Fred Fish
Goodyear Aerospace Corp, Arizona Div.
(602) 932-7000 work
(602) 894-6881 home
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
INTERNALS:
-.FILL .LEFT MARGIN 9
-.SKIP 1
Computes complex tangent of Z _= x + j y from:
-.SKIP 1
-.NOFILL
	1.	Compute CCOS(z)
-.SKIP 1
	2.	If CCOS(z) _= 0 + j0 then the
		result is MAX__POS__DBLF + j0
-.SKIP 1
	3.	Else CTAN(z) _= CSIN(z) / CCOS(z)
-.SKIP 1
-.LEFT MARGIN 0
-.COMMENT Beginning source file CTANH.C.9
-.SUBTITLE CTANH
-.PAGE
-.HEADER LEVEL 2 Complex double precision hyperbolic tangent

-.SKIP 3
-.CENTER ;*********
-.CENTER ;* CTANH *
-.CENTER ;*********
-.SKIP 3
-.INDEX  CTANH
-.INDEX  complex functions
-.INDEX  machine independent routines
-.INDEX  math libraries
-.SKIP 1 .test page 4
DESCRIPTION:
-.FILL .LEFT MARGIN 9
-.SKIP 1
Computes double precision complex hyperbolic tangent of
a double precision complex argument.
The result replaces the argument.
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
USAGE:
-.FILL .LEFT MARGIN 9
-.SKIP 1
-.NOFILL
ctanh(z)
COMPLEX *z;
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
REFERENCES:
-.FILL .LEFT MARGIN 9
-.SKIP 1
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
RESTRICTIONS:
-.FILL .LEFT MARGIN 9
-.SKIP 1
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
PROGRAMMER:
-.FILL .LEFT MARGIN 9
-.SKIP 1
-.NOFILL
Fred Fish
Goodyear Aerospace Corp, Arizona Div.
(602) 932-7000 work
(602) 894-6881 home
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
INTERNALS:
-.FILL .LEFT MARGIN 9
-.SKIP 1
Computes complex hyperbolic tangent of Z _= x + j y from:
-.SKIP 1
-.NOFILL
   CTANH(z) _= (1 - CEXP(-2z)) / (1 + CEXP(-2z))
-.SKIP 1
-.LEFT MARGIN 0
-.COMMENT Beginning source file DABS.C.6
-.SUBTITLE DABS
-.PAGE
-.HEADER LEVEL 2 Double precision absolute value

-.SKIP 3
-.CENTER ;********
-.CENTER ;* DABS *
-.CENTER ;********
-.SKIP 3
-.INDEX  DABS
-.INDEX  machine independent routines
-.INDEX  math libraries
-.SKIP 1 .test page 4
DESCRIPTION:
-.FILL .LEFT MARGIN 9
-.SKIP 1
Returns absolute value of double precision number.
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
USAGE:
-.FILL .LEFT MARGIN 9
-.SKIP 1
-.NOFILL
double dabs(x)
double x;
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
PROGRAMMER:
-.FILL .LEFT MARGIN 9
-.SKIP 1
-.NOFILL
Fred Fish
Goodyear Aerospace Corp, Arizona Div.
(602) 932-7000 work
(602) 894-6881 home
-.SKIP 1
-.LEFT MARGIN 0
-.COMMENT Beginning source file DACOS.C.7
-.SUBTITLE DACOS
-.PAGE
-.HEADER LEVEL 2 Double precision arc cosine

-.SKIP 3
-.CENTER ;*********
-.CENTER ;* DACOS *
-.CENTER ;*********
-.SKIP 3
-.INDEX  DACOS
-.INDEX  machine independent routines
-.INDEX  trigonometric functions
-.INDEX  math libraries
-.SKIP 1 .test page 4
DESCRIPTION:
-.FILL .LEFT MARGIN 9
-.SKIP 1
Returns double precision arc cosine of double precision
floating point argument.
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
USAGE:
-.FILL .LEFT MARGIN 9
-.SKIP 1
-.NOFILL
double dacos(x)
double x;
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
REFERENCES:
-.FILL .LEFT MARGIN 9
-.SKIP 1
Fortran IV-plus user's guide, Digital Equipment Corp. pp B-1.
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
RESTRICTIONS:
-.FILL .LEFT MARGIN 9
-.SKIP 1
The maximum relative error for the approximating polynomial
in DATAN is 10**(-16.82).  However, this assumes exact arithmetic
in the polynomial evaluation.  Additional rounding and
truncation errors may occur as the argument is reduced
to the range over which the polynomial approximation
is valid, and as the polynomial is evaluated using
finite-precision arithmetic.
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
PROGRAMMER:
-.FILL .LEFT MARGIN 9
-.SKIP 1
-.NOFILL
Fred Fish
Goodyear Aerospace Corp, Arizona Div.
(602) 932-7000 work
(602) 894-6881 home
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
INTERNALS:
-.FILL .LEFT MARGIN 9
-.SKIP 1
Computes arccosine(X) from:
-.SKIP 1
-.NOFILL
	(1)	If X _= 0.0 then DACOS(X) _= PI/2.
-.SKIP 1
	(2)	If X _= 1.0 then DACOS(X) _= 0.0
-.SKIP 1
	(3)	If X _= -1.0 then DACOS(X) _= PI.
-.SKIP 1
	(4)	If 0.0 _< X _< 1.0 then
		DACOS(X) _= DATAN(Y)
		Y _= DSQRT[1-(X**2)] / X
-.SKIP 1
	(4)	If -1.0 _< X _< 0.0 then
		DACOS(X) _= DATAN(Y) + PI
		Y _= DSQRT[1-(X**2)] / X
-.SKIP 1
-.LEFT MARGIN 0
-.COMMENT Beginning source file DACOSH.C.8
-.SUBTITLE DACOSH
-.PAGE
-.HEADER LEVEL 2 Double precision hyperbolic arc cosine

-.SKIP 3
-.CENTER ;**********
-.CENTER ;* DACOSH *
-.CENTER ;**********
-.SKIP 3
-.INDEX  DACOSH
-.INDEX  machine independent routines
-.INDEX  math libraries
-.SKIP 1 .test page 4
DESCRIPTION:
-.FILL .LEFT MARGIN 9
-.SKIP 1
Returns double precision hyperbolic arc cosine of double precision
floating point number.
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
USAGE:
-.FILL .LEFT MARGIN 9
-.SKIP 1
-.NOFILL
double dacosh(x)
double x;
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
REFERENCES:
-.FILL .LEFT MARGIN 9
-.SKIP 1
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
RESTRICTIONS:
-.FILL .LEFT MARGIN 9
-.SKIP 1
The range of the ACOSH function is all real numbers greater
than or equal to 1.0 however large arguments may cause
overflow in the x squared portion of the function evaluation.
-.SKIP 1
For precision information refer to documentation of the
floating point library primatives called.
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
PROGRAMMER:
-.FILL .LEFT MARGIN 9
-.SKIP 1
-.NOFILL
Fred Fish
Goodyear Aerospace Corp, Arizona Div.
(602) 932-7000 work
(602) 894-6881 home
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
INTERNALS:
-.FILL .LEFT MARGIN 9
-.SKIP 1
Computes DACOSH(X) from:
-.SKIP 1
-.NOFILL
	1.	If X _< 1.0 then report illegal
		argument and return zero.
-.SKIP 1
	2.	If X > DSQRT(MAX__POS__DBLF) then
		set X _= DSQRT(MAX__POS__DBLF and
		continue after reporting overflow.
-.SKIP 1
	3.	DACOSH(X) _= LN [X+DSQRT(X**2 - 1)]
-.SKIP 1
-.LEFT MARGIN 0
-.COMMENT Beginning source file DASIN.C.6
-.SUBTITLE DASIN
-.PAGE
-.HEADER LEVEL 2 Double precision arc sine

-.SKIP 3
-.CENTER ;*********
-.CENTER ;* DASIN *
-.CENTER ;*********
-.SKIP 3
-.INDEX  DASIN
-.INDEX  machine independent routines
-.INDEX  trigonometric functions
-.INDEX  math libraries
-.SKIP 1 .test page 4
DESCRIPTION:
-.FILL .LEFT MARGIN 9
-.SKIP 1
Returns double precision arc sine of double precision
floating point argument.
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
USAGE:
-.FILL .LEFT MARGIN 9
-.SKIP 1
-.NOFILL
double dasin(x)
double x;
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
REFERENCES:
-.FILL .LEFT MARGIN 9
-.SKIP 1
Fortran IV-plus user's guide, Digital Equipment Corp. pp B-2.
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
RESTRICTIONS:
-.FILL .LEFT MARGIN 9
-.SKIP 1
For precision information refer to documentation of the floating
point library primatives called.
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
PROGRAMMER:
-.FILL .LEFT MARGIN 9
-.SKIP 1
-.NOFILL
Fred Fish
Goodyear Aerospace Corp, Arizona Div.
(602) 932-7000 work
(602) 894-6881 home
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
INTERNALS:
-.FILL .LEFT MARGIN 9
-.SKIP 1
Computes arcsine(X) from:
-.SKIP 1
-.NOFILL
	(1)	If X _= 0.0 then DASIN(X) _= 0.0
-.SKIP 1
	(2)	If X _= 1.0 then DASIN(X) _= PI/2.
-.SKIP 1
	(3)	If X _= -1.0 then DASIN(X) _= -PI/2
-.SKIP 1
	(4)	If -1.0 _< X _< 1.0 then
		DASIN(X) _= DATAN(Y)
		Y _= X / DSQRT[1-(X**2)]
-.SKIP 1
-.LEFT MARGIN 0
-.COMMENT Beginning source file DASINH.C.6
-.SUBTITLE DASINH
-.PAGE
-.HEADER LEVEL 2 Double precision hyperbolic arc sine

-.SKIP 3
-.CENTER ;**********
-.CENTER ;* DASINH *
-.CENTER ;**********
-.SKIP 3
-.INDEX  DASINH
-.INDEX  machine independent routines
-.INDEX  math libraries
-.SKIP 1 .test page 4
DESCRIPTION:
-.FILL .LEFT MARGIN 9
-.SKIP 1
Returns double precision hyperbolic arc sine of double precision
floating point number.
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
USAGE:
-.FILL .LEFT MARGIN 9
-.SKIP 1
-.NOFILL
double dasinh(x)
double x;
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
REFERENCES:
-.FILL .LEFT MARGIN 9
-.SKIP 1
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
RESTRICTIONS:
-.FILL .LEFT MARGIN 9
-.SKIP 1
The domain of the ASINH function is the entire real axis
however the evaluation of x squared may cause overflow
for large magnitudes.
-.SKIP 1
For precision information refer to documentation of the
floating point library routines called.
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
PROGRAMMER:
-.FILL .LEFT MARGIN 9
-.SKIP 1
-.NOFILL
Fred Fish
Goodyear Aerospace Corp, Arizona Div.
(602) 932-7000 work
(602) 894-6881 home
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
INTERNALS:
-.FILL .LEFT MARGIN 9
-.SKIP 1
Computes DASINH(X) from:
-.SKIP 1
-.NOFILL
	1.	Let XMAX _= DSQRT(MAX__POS__DBLF - 1)

	2.	If X _< -XMAX or XMAX _< X then
		let X _= XMAX and flag overflow.
-.SKIP 1
	3.	DASINH(X) _= LN [X+DSQRT(X**2 + 1)]
-.SKIP 1
-.LEFT MARGIN 0
-.COMMENT Beginning source file DATAN.C.32
-.SUBTITLE DATAN
-.PAGE
-.HEADER LEVEL 2 Double precision arc tangent

-.SKIP 3
-.CENTER ;*********
-.CENTER ;* DATAN *
-.CENTER ;*********
-.SKIP 3
-.INDEX  DATAN
-.INDEX  machine independent routines
-.INDEX  trigonometric functions
-.INDEX  math libraries
-.SKIP 1 .test page 4
DESCRIPTION:
-.FILL .LEFT MARGIN 9
-.SKIP 1
Returns double precision arc tangent of double precision
floating point argument.
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
USAGE:
-.FILL .LEFT MARGIN 9
-.SKIP 1
-.NOFILL
double datan(x)
double x;
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
REFERENCES:
-.FILL .LEFT MARGIN 9
-.SKIP 1
Fortran 77 user's guide, Digital Equipment Corp. pp B-3
-.SKIP 1
Computer Approximations, J.F. Hart et al, John Wiley _& Sons,
1968, pp. 120-130.
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
RESTRICTIONS:
-.FILL .LEFT MARGIN 9
-.SKIP 1
The maximum relative error for the approximating polynomial
is 10**(-16.82).  However, this assumes exact arithmetic
in the polynomial evaluation.  Additional rounding and
truncation errors may occur as the argument is reduced
to the range over which the polynomial approximation
is valid, and as the polynomial is evaluated using
finite-precision arithmetic.
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
PROGRAMMER:
-.FILL .LEFT MARGIN 9
-.SKIP 1
-.NOFILL
Fred Fish
Goodyear Aerospace Corp, Arizona Div.
(602) 932-7000 work
(602) 894-6881 home
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
INTERNALS:
-.FILL .LEFT MARGIN 9
-.SKIP 1
Computes arctangent(X) from:
-.SKIP 1
-.NOFILL
	(1)	If X _< 0 then negate X, perform steps
		2, 3, and 4, and negate the returned
		result.  This makes use of the identity
		DATAN(-X) _= -DATAN(X).
-.SKIP 1
	(2)	If argument X > 1 at this point then
		test to be sure that X can be inverted
		without underflowing.  If not, reduce
		X to largest possible number that can
		be inverted, issue warning, and continue.
		Perform steps 3 and 4 with arg _= 1/X
		and subtract returned result from
		pi/2.  This makes use of the identity
		DATAN(X) _= pi/2 - DATAN(1/X) for X>0.
-.SKIP 1
	(3)	At this point 0 _<_= X _<_= 1.  If
		X > DTAN(pi/12) then perform step 4
		with arg _= (X*DSQRT(3)-1)/(DSQRT(3)+X)
		and add pi/6 to returned result.  This
		last transformation maps arguments
		greater than DTAN(pi/12) to arguments
		in range 0...DTAN(pi/12).
-.SKIP 1
	(4)	At this point the argument has been
		transformed so that it lies in the
		range -DTAN(pi/12)...DTAN(pi/12).
		Since very small arguments may cause
		underflow in the polynomial evaluation,
		a final check is performed.  If the
		argument is less than the underflow
		bound, the function returns x, since
		ATAN(X) approaches ASIN(X) which
		approaches X as X goes to zero.
-.SKIP 1
	(5)	DATAN(X) is now computed by one of the
		approximations given in the cited
		reference (Hart).  That is:
-.SKIP 1
		DATAN(X) _= X * SUM [ C[i] * X**(2*i) ]
		over i _= {0,1,...8}.
-.SKIP 1
		Where:
-.SKIP 1
		C[0] _=	.9999999999999999849899
		C[1] _=	-.333333333333299308717
		C[2] _=	.1999999999872944792
		C[3] _=	-.142857141028255452
		C[4] _=	.11111097898051048
		C[5] _=	-.0909037114191074
		C[6] _=	.0767936869066
		C[7] _=	-.06483193510303
		C[8] _=	.0443895157187
		(coefficients from HART table _#4945 pg 267)
-.SKIP 1
-.LEFT MARGIN 0
-.COMMENT Beginning source file DATAN2.C.8
-.SUBTITLE DATAN2
-.PAGE
-.HEADER LEVEL 2 Double precision arc tangent of two arguments

-.SKIP 3
-.CENTER ;**********
-.CENTER ;* DATAN2 *
-.CENTER ;**********
-.SKIP 3
-.INDEX  DATAN2
-.INDEX  machine independent routines
-.INDEX  trigonometric functions
-.INDEX  math libraries
-.SKIP 1 .test page 4
DESCRIPTION:
-.FILL .LEFT MARGIN 9
-.SKIP 1
Returns double precision arc tangent of two
double precision floating point arguments ( DATAN(Y/X) ).
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
USAGE:
-.FILL .LEFT MARGIN 9
-.SKIP 1
-.NOFILL
double datan2(y,x)
double x;
double y;
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
REFERENCES:
-.FILL .LEFT MARGIN 9
-.SKIP 1
Fortran 77 user's guide, Digital Equipment Corp. pp B-4.
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
RESTRICTIONS:
-.FILL .LEFT MARGIN 9
-.SKIP 1
This is a modification of the original algorithm.  Argument
conventions now follow Vax-11C and Fortran-77.
-.SKIP 1
The arguments are Y followed by X and it computes atan Y/X.
This makes it compatable with VAX-11 C and UNIX (and Fortran-77).
(Modified 12-Apr-1984 by Andy Vesper, DEC, Maynard, MA, USA)
-.SKIP 1
For precision information refer to documentation of the
other floating point library routines called.
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
PROGRAMMER:
-.FILL .LEFT MARGIN 9
-.SKIP 1
-.NOFILL
Fred Fish
Goodyear Aerospace Corp, Arizona Div.
(602) 932-7000 work
(602) 894-6881 home
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
INTERNALS:
-.FILL .LEFT MARGIN 9
-.SKIP 1
Computes DATAN(Y/X) from:
-.SKIP 1
-.NOFILL
	1.	If X _= 0 then
		DATAN(Y,X) _= PI/2 * (SIGN(Y))
-.SKIP 1
	2.	If X > 0 then
		DATAN(Y,X) _= DATAN(Y/X)
-.SKIP 1
	3.	If X _< 0 then DATAN2(Y,X) _=
		PI*(SIGN(Y)) + DATAN(Y/X)
-.SKIP 1
-.LEFT MARGIN 0
-.COMMENT Beginning source file DATANH.C.8
-.SUBTITLE DATANH
-.PAGE
-.HEADER LEVEL 2 Double precision hyperbolic arc tangent

-.SKIP 3
-.CENTER ;**********
-.CENTER ;* DATANH *
-.CENTER ;**********
-.SKIP 3
-.INDEX  DATANH
-.INDEX  machine independent routines
-.INDEX  math libraries
-.SKIP 1 .test page 4
DESCRIPTION:
-.FILL .LEFT MARGIN 9
-.SKIP 1
Returns double precision hyperbolic arc tangent of double precision
floating point number.
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
USAGE:
-.FILL .LEFT MARGIN 9
-.SKIP 1
-.NOFILL
double datanh(x)
double x;
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
REFERENCES:
-.FILL .LEFT MARGIN 9
-.SKIP 1
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
RESTRICTIONS:
-.FILL .LEFT MARGIN 9
-.SKIP 1
The range of the ATANH function is -1.0 to +1.0 exclusive.
Certain pathological cases near 1.0 may cause overflow
in evaluation of 1+x / 1-x, depending upon machine exponent
range and mantissa precision.
-.SKIP 1
For precision information refer to documentation of the
other floating point library routines called.
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
PROGRAMMER:
-.FILL .LEFT MARGIN 9
-.SKIP 1
-.NOFILL
Fred Fish
Goodyear Aerospace Corp, Arizona Div.
(602) 932-7000 work
(602) 894-6881 home
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
INTERNALS:
-.FILL .LEFT MARGIN 9
-.SKIP 1
Computes DATANH(X) from:
-.SKIP 1
-.NOFILL
	1.	If X _<_= -1.0 or X >_= 1.0
		then report argument out of
		range and return 0.0
-.SKIP 1
	2.	DATANH(X) _= 0.5 * DLN((1+X)/(1-X))
-.SKIP 1
-.LEFT MARGIN 0
-.COMMENT Beginning source file DCOS.C.41
-.SUBTITLE DCOS
-.PAGE
-.HEADER LEVEL 2 Double precision cosine

-.SKIP 3
-.CENTER ;********
-.CENTER ;* DCOS *
-.CENTER ;********
-.SKIP 3
-.INDEX  DCOS
-.INDEX  machine independent routines
-.INDEX  trigonometric functions
-.INDEX  math libraries
-.SKIP 1 .test page 4
DESCRIPTION:
-.FILL .LEFT MARGIN 9
-.SKIP 1
Returns double precision cosine of double precision
floating point argument.
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
USAGE:
-.FILL .LEFT MARGIN 9
-.SKIP 1
-.NOFILL
double dcos(x)
double x;
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
REFERENCES:
-.FILL .LEFT MARGIN 9
-.SKIP 1
Computer Approximations, J.F. Hart et al, John Wiley _& Sons,
1968, pp. 112-120.
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
RESTRICTIONS:
-.FILL .LEFT MARGIN 9
-.SKIP 1
The DSIN and DCOS routines are interactive in the sense that
in the process of reducing the argument to the range -PI/4
to PI/4, each may call the other.  Ultimately one or the
other uses a polynomial approximation on the reduced
argument.  The DSIN approximation has a maximum relative error
of 10**(-17.59) and the DCOS approximation has a maximum
relative error of 10**(-16.18).
-.SKIP 1
These error bounds assume exact arithmetic
in the polynomial evaluation.  Additional rounding and
truncation errors may occur as the argument is reduced
to the range over which the polynomial approximation
is valid, and as the polynomial is evaluated using
finite-precision arithmetic.
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
PROGRAMMER:
-.FILL .LEFT MARGIN 9
-.SKIP 1
-.NOFILL
Fred Fish
Goodyear Aerospace Corp, Arizona Div.
(602) 932-7000 work
(602) 894-6881 home
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
INTERNALS:
-.FILL .LEFT MARGIN 9
-.SKIP 1
Computes DCOS(X) from:
-.SKIP 1
-.NOFILL
	(1)	Reduce argument X to range -PI to PI.
-.SKIP 1
	(2)	If X > PI/2 then call DCOS recursively
		using relation DCOS(X) _= -DCOS(X - PI).
-.SKIP 1
	(3)	If X _< -PI/2 then call DCOS recursively
		using relation DCOS(X) _= -DCOS(X + PI).
-.SKIP 1
	(4)	If X > PI/4 then call DSIN using
		relation DCOS(X) _= DSIN(PI/2 - X).
-.SKIP 1
	(5)	If X _< -PI/4 then call DCOS using
		relation DCOS(X) _= DSIN(PI/2 + X).
-.SKIP 1
	(6)	If X would cause underflow in approx
		evaluation arithmetic then return
		sqrt(1.0 - X**2).
-.SKIP 1
	(7)	By now X has been reduced to range
		-PI/4 to PI/4 and the approximation
		from HART pg. 119 can be used:
-.SKIP 1
		DCOS(X) _= ( P(Y) / Q(Y) )
		Where:
-.SKIP 1
		Y    _=	X * (4/PI)
-.SKIP 1
		P(Y) _=  SUM [ Pj * (Y**(2*j)) ]
		over j _= {0,1,2,3}
-.SKIP 1
		Q(Y) _=  SUM [ Qj * (Y**(2*j)) ]
		over j _= {0,1,2,3}
-.SKIP 1
		P0   _=	0.12905394659037374438571854e+7
		P1   _=	-0.3745670391572320471032359e+6
		P2   _=	0.134323009865390842853673e+5
		P3   _=	-0.112314508233409330923e+3
		Q0   _=	0.12905394659037373590295914e+7
		Q1   _=	0.234677731072458350524124e+5
		Q2   _=	0.2096951819672630628621e+3
		Q3   _=	1.0000...
		(coefficients from HART table _#3843 pg 244)
-.SKIP 1
-.SKIP 1
-.FILL
**** NOTE ****    The range reduction relations used in
this routine depend on the final approximation being valid
over the negative argument range in addition to the positive
argument range.  The particular approximation chosen from
HART satisfies this requirement, although not explicitly
stated in the text.  This may not be true of other
approximations given in the reference.
-.NOFILL

-.LEFT MARGIN 0
-.COMMENT Beginning source file DCOSH.C.8
-.SUBTITLE DCOSH
-.PAGE
-.HEADER LEVEL 2 Double precision hyperbolic cosine

-.SKIP 3
-.CENTER ;*********
-.CENTER ;* DCOSH *
-.CENTER ;*********
-.SKIP 3
-.INDEX  DCOSH
-.INDEX  machine independent routines
-.INDEX  math libraries
-.SKIP 1 .test page 4
DESCRIPTION:
-.FILL .LEFT MARGIN 9
-.SKIP 1
Returns double precision hyperbolic cosine of double precision
floating point number.
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
USAGE:
-.FILL .LEFT MARGIN 9
-.SKIP 1
-.NOFILL
double dcosh(x)
double x;
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
REFERENCES:
-.FILL .LEFT MARGIN 9
-.SKIP 1
Fortran IV plus user's guide, Digital Equipment Corp. pp B-4
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
RESTRICTIONS:
-.FILL .LEFT MARGIN 9
-.SKIP 1
Inputs greater than LN(MAX__POS__DBLF) result in overflow.
Inputs less than LN(MIN__POS__DBLF) result in underflow.
-.SKIP 1
For precision information refer to documentation of the
floating point library routines called.
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
PROGRAMMER:
-.FILL .LEFT MARGIN 9
-.SKIP 1
-.NOFILL
Fred Fish
Goodyear Aerospace Corp, Arizona Div.
(602) 932-7000 work
(602) 894-6881 home
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
INTERNALS:
-.FILL .LEFT MARGIN 9
-.SKIP 1
Computes hyperbolic cosine from:
-.SKIP 1
-.NOFILL
	DCOSH(X) _= 0.5 * (DEXP(X) + DEXP(-X))
-.SKIP 1
-.LEFT MARGIN 0
-.COMMENT Beginning source file DEXP.C.26
-.SUBTITLE DEXP
-.PAGE
-.HEADER LEVEL 2 Double precision exponential

-.SKIP 3
-.CENTER ;********
-.CENTER ;* DEXP *
-.CENTER ;********
-.SKIP 3
-.INDEX  DEXP
-.INDEX  machine independent routines
-.INDEX  math libraries
-.SKIP 1 .test page 4
DESCRIPTION:
-.FILL .LEFT MARGIN 9
-.SKIP 1
Returns double precision exponential of double precision
floating point number.
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
USAGE:
-.FILL .LEFT MARGIN 9
-.SKIP 1
-.NOFILL
double dexp(x)
double x;
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
REFERENCES:
-.FILL .LEFT MARGIN 9
-.SKIP 1
Fortran IV plus user's guide, Digital Equipment Corp. pp B-3
-.SKIP 1
Computer Approximations, J.F. Hart et al, John Wiley _& Sons,
1968, pp. 96-104.
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
RESTRICTIONS:
-.FILL .LEFT MARGIN 9
-.SKIP 1
Inputs greater than LN(MAX__POS__DBLF) result in overflow.
Inputs less than LN(MIN__POS__DBLF) result in underflow.
-.SKIP 1
The maximum relative error for the approximating polynomial
is 10**(-16.4).  However, this assumes exact arithmetic
in the polynomial evaluation.  Additional rounding and
truncation errors may occur as the argument is reduced
to the range over which the polynomial approximation
is valid, and as the polynomial is evaluated using
finite-precision arithmetic.
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
PROGRAMMER:
-.FILL .LEFT MARGIN 9
-.SKIP 1
-.NOFILL
Fred Fish
Goodyear Aerospace Corp, Arizona Div.
(602) 932-7000 work
(602) 894-6881 home
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
INTERNALS:
-.FILL .LEFT MARGIN 9
-.SKIP 1
Computes exponential from:
-.SKIP 1
-.NOFILL
	EXP(X)	_=	2**Y  *  2**Z  *  2**W
-.SKIP 1
-.FILL
Where:
-.SKIP 1
-.NOFILL
	Y	_=	INT ( X * LOG2(e) )
-.SKIP 1
	V	_=	16 * FRAC ( X * LOG2(e))
-.SKIP 1
	Z	_=	(1/16) * INT (V)
-.SKIP 1
	W	_=	(1/16) * FRAC (V)
-.SKIP 1
-.FILL
Note that:
-.SKIP 1
-.NOFILL
	0 _=_< V _< 16
-.SKIP 1
	Z _= {0, 1/16, 2/16, ...15/16}
-.SKIP 1
	0 _=_< W _< 1/16
-.SKIP 1
-.FILL
Then:
-.SKIP 1
-.NOFILL
	2**Z is looked up in a table of 2**0, 2**1/16, ...
-.SKIP 1
	2**W is computed from an approximation:
-.SKIP 1
		2**W	_=  (A + B) / (A - B)
-.SKIP 1
		A	_=  C + (D * W * W)
-.SKIP 1
		B	_=  W * (E + (F * W * W))
-.SKIP 1
		C	_=  20.8137711965230361973
-.SKIP 1
		D	_=  1.0
-.SKIP 1
		E	_=  7.2135034108448192083
-.SKIP 1
		F	_=  0.057761135831801928
-.SKIP 1
	Coefficients are from HART, table _#1121, pg 206.
-.SKIP 1
	Effective multiplication by 2**Y is done by a
	floating point scale with Y as scale argument.
-.SKIP 1
-.LEFT MARGIN 0
-.COMMENT Beginning source file DFRAC.C.5
-.SUBTITLE DFRAC
-.PAGE
-.HEADER LEVEL 2 Double precision fractional portion

-.SKIP 3
-.CENTER ;*********
-.CENTER ;* DFRAC *
-.CENTER ;*********
-.SKIP 3
-.INDEX  DFRAC
-.INDEX  machine dependent routines
-.INDEX  math libraries
-.SKIP 1 .test page 4
DESCRIPTION:
-.FILL .LEFT MARGIN 9
-.SKIP 1
Returns fractional portion of double precision number as double
precision number.
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
USAGE:
-.FILL .LEFT MARGIN 9
-.SKIP 1
-.NOFILL
double dfrac(x)
double x;
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
PROGRAMMER:
-.FILL .LEFT MARGIN 9
-.SKIP 1
-.NOFILL
Fred Fish
Goodyear Aerospace Corp, Arizona Div.
(602) 932-7000 work
(602) 894-6881 home
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
RESTRICTIONS:
-.FILL .LEFT MARGIN 9
-.SKIP 1
-.LEFT MARGIN 0
-.COMMENT Beginning source file DINT.C.29
-.SUBTITLE DINT
-.PAGE
-.HEADER LEVEL 2 Double precision integer portion

-.SKIP 3
-.CENTER ;********
-.CENTER ;* DINT *
-.CENTER ;********
-.SKIP 3
-.INDEX  DINT
-.INDEX  machine dependent routines
-.INDEX  math libraries
-.SKIP 1 .test page 4
DESCRIPTION:
-.FILL .LEFT MARGIN 9
-.SKIP 1
Returns integer portion of double precision number as double
precision number.
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
USAGE:
-.FILL .LEFT MARGIN 9
-.SKIP 1
-.NOFILL
double dint(x)
double x;
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
PROGRAMMER:
-.FILL .LEFT MARGIN 9
-.SKIP 1
-.NOFILL
Fred Fish
Goodyear Aerospace Corp, Arizona Div.
(602) 932-7000 work
(602) 894-6881 home
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
RESTRICTIONS:
-.FILL .LEFT MARGIN 9
-.SKIP 1
The current DEC-20 C system treats double as float.  This
routine will need to be modified when true double precision
is implemented.
-.SKIP 1
-.LEFT MARGIN 0
-.COMMENT Beginning source file DLN.C.22
-.SUBTITLE DLN
-.PAGE
-.HEADER LEVEL 2 Double precision natural log

-.SKIP 3
-.CENTER ;*******
-.CENTER ;* DLN *
-.CENTER ;*******
-.SKIP 3
-.INDEX  DLN
-.INDEX  machine independent routines
-.INDEX  math libraries
-.SKIP 1 .test page 4
DESCRIPTION:
-.FILL .LEFT MARGIN 9
-.SKIP 1
Returns double precision natural log of double precision
floating point argument.
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
USAGE:
-.FILL .LEFT MARGIN 9
-.SKIP 1
-.NOFILL
double dln(x)
double x;
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
REFERENCES:
-.FILL .LEFT MARGIN 9
-.SKIP 1
Computer Approximations, J.F. Hart et al, John Wiley _& Sons,
1968, pp. 105-111.
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
RESTRICTIONS:
-.FILL .LEFT MARGIN 9
-.SKIP 1
The absolute error in the approximating polynomial is
10**(-19.38).  Note that contrary to DEC's assertion
in the F4P user's guide, the error is absolute and not
relative.
-.SKIP 1
This error bound assumes exact arithmetic
in the polynomial evaluation.  Additional rounding and
truncation errors may occur as the argument is reduced
to the range over which the polynomial approximation
is valid, and as the polynomial is evaluated using
finite-precision arithmetic.
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
PROGRAMMER:
-.FILL .LEFT MARGIN 9
-.SKIP 1
-.NOFILL
Fred Fish
Goodyear Aerospace Corp, Arizona Div.
(602) 932-7000 work
(602) 894-6881 home
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
INTERNALS:
-.FILL .LEFT MARGIN 9
-.SKIP 1
Computes DLN(X) from:
-.SKIP 1
-.NOFILL
	(1)	If argument is zero then flag an error
		and return minus infinity (or rather its
		machine representation).
-.SKIP 1
	(2)	If argument is negative then flag an
		error and return minus infinity.
-.SKIP 1
	(3)	Given that x _= m * 2**k then extract
		mantissa m and exponent k.
-.SKIP 1
	(4)	Transform m which is in range [0.5,1.0]
		to range [1/sqrt(2), sqrt(2)] by:
-.SKIP 1
			s _= m * sqrt(2)
-.SKIP 1
	(4)	Compute z _= (s - 1) / (s + 1)
-.SKIP 1
	(5)	Now use the approximation from HART
		page 111 to find ln(s):
-.SKIP 1
		DLN(s) _= z * ( P(z**2) / Q(z**2) )
-.SKIP 1
		Where:
-.SKIP 1
		P(z**2) _=  SUM [ Pj * (z**(2*j)) ]
		over j _= {0,1,2,3}
-.SKIP 1
		Q(z**2) _=  SUM [ Qj * (z**(2*j)) ]
		over j _= {0,1,2,3}
-.SKIP 1
		P0 _=  -0.240139179559210509868484e2
		P1 _=  0.30957292821537650062264e2
		P2 _=  -0.96376909336868659324e1
		P3 _=  0.4210873712179797145
		Q0 _=  -0.120069589779605254717525e2
		Q1 _=  0.19480966070088973051623e2
		Q2 _=  -0.89111090279378312337e1
		Q3 _=  1.0000
-.SKIP 1
		(coefficients from HART table _#2705 pg 229)
-.SKIP 1
-.FILL
(5)	Finally, compute DLN(x) from:
-.SKIP 1
-.NOFILL
		DLN(x) _= (k * dln(2)) - dln(sqrt(2)) + dln(s)
-.SKIP 1
-.LEFT MARGIN 0
-.COMMENT Beginning source file DLOG.C.6
-.SUBTITLE DLOG
-.PAGE
-.HEADER LEVEL 2 Double precision common log

-.SKIP 3
-.CENTER ;********
-.CENTER ;* DLOG *
-.CENTER ;********
-.SKIP 3
-.INDEX  DLOG
-.INDEX  machine independent routines
-.INDEX  math libraries
-.SKIP 1 .test page 4
DESCRIPTION:
-.FILL .LEFT MARGIN 9
-.SKIP 1
Returns double precision common log of double precision
floating point argument.
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
USAGE:
-.FILL .LEFT MARGIN 9
-.SKIP 1
-.NOFILL
double dlog(x)
double x;
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
REFERENCES:
-.FILL .LEFT MARGIN 9
-.SKIP 1
PDP-11 Fortran IV-plus users guide, Digital Equip. Corp.,
1975, pp. B-3.
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
RESTRICTIONS:
-.FILL .LEFT MARGIN 9
-.SKIP 1
For precision information refer to documentation of the
floating point library routines called.
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
PROGRAMMER:
-.FILL .LEFT MARGIN 9
-.SKIP 1
-.NOFILL
Fred Fish
Goodyear Aerospace Corp, Arizona Div.
(602) 932-7000 work
(602) 894-6881 home
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
INTERNALS:
-.FILL .LEFT MARGIN 9
-.SKIP 1
Computes DLOG(X) from:
-.SKIP 1
-.NOFILL
	DLOG(X) _= DLOG(e) * DLN(X)
-.SKIP 1
-.LEFT MARGIN 0
-.COMMENT Beginning source file DMAX.C.5
-.SUBTITLE DMAX
-.PAGE
-.HEADER LEVEL 2 double precision maximum of two arguments

-.SKIP 3
-.CENTER ;********
-.CENTER ;* DMAX *
-.CENTER ;********
-.SKIP 3
-.INDEX  DMAX
-.INDEX  machine independent routines
-.INDEX  math libraries
-.SKIP 1 .test page 4
DESCRIPTION:
-.FILL .LEFT MARGIN 9
-.SKIP 1
Returns maximum value of two double precision numbers.
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
USAGE:
-.FILL .LEFT MARGIN 9
-.SKIP 1
-.NOFILL
double dmax(x,y)
double x;
double y;
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
PROGRAMMER:
-.FILL .LEFT MARGIN 9
-.SKIP 1
-.NOFILL
Fred Fish
Goodyear Aerospace Corp, Arizona Div.
(602) 932-7000 work
(602) 894-6881 home
-.SKIP 1
-.LEFT MARGIN 0
-.COMMENT Beginning source file DMIN.C.5
-.SUBTITLE DMIN
-.PAGE
-.HEADER LEVEL 2 double precision minimum of two arguments

-.SKIP 3
-.CENTER ;********
-.CENTER ;* DMIN *
-.CENTER ;********
-.SKIP 3
-.INDEX  DMIN
-.INDEX  machine independent routines
-.INDEX  math libraries
-.SKIP 1 .test page 4
DESCRIPTION:
-.FILL .LEFT MARGIN 9
-.SKIP 1
Returns minimum value of two double precision numbers.
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
USAGE:
-.FILL .LEFT MARGIN 9
-.SKIP 1
-.NOFILL
double dmin(x,y)
double x;
double y;
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
PROGRAMMER:
-.FILL .LEFT MARGIN 9
-.SKIP 1
-.NOFILL
Fred Fish
Goodyear Aerospace Corp, Arizona Div.
(602) 932-7000 work
(602) 894-6881 home
-.SKIP 1
-.LEFT MARGIN 0
-.COMMENT Beginning source file DMOD.C.8
-.SUBTITLE DMOD
-.PAGE
-.HEADER LEVEL 2 Double precision modulo

-.SKIP 3
-.CENTER ;********
-.CENTER ;* DMOD *
-.CENTER ;********
-.SKIP 3
-.INDEX  DMOD
-.INDEX  machine independent routines
-.INDEX  math libraries
-.SKIP 1 .test page 4
DESCRIPTION:
-.FILL .LEFT MARGIN 9
-.SKIP 1
Returns double precision modulo of two double
precision arguments.
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
USAGE:
-.FILL .LEFT MARGIN 9
-.SKIP 1
-.NOFILL
double dmod(value,base)
double value;
double base;
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
PROGRAMMER:
-.FILL .LEFT MARGIN 9
-.SKIP 1
-.NOFILL
Fred Fish
Goodyear Aerospace Corp, Arizona Div.
(602) 932-7000 work
(602) 894-6881 home
-.SKIP 1
-.LEFT MARGIN 0
-.COMMENT Beginning source file DPOLY.C.12
-.SUBTITLE DPOLY
-.PAGE
-.HEADER LEVEL 2 Double precision polynomial evaluation

-.SKIP 3
-.CENTER ;*********
-.CENTER ;* DPOLY *
-.CENTER ;*********
-.SKIP 3
-.INDEX  DPOLY
-.INDEX  machine independent routines
-.INDEX  math libraries
-.SKIP 1 .test page 4
DESCRIPTION:
-.FILL .LEFT MARGIN 9
-.SKIP 1
Evaluates a polynomial and returns double precision
result.  Is passed a the order of the polynomial,
a pointer to an array of double precision polynomial
coefficients (in ascending order), and the independent
variable.
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
USAGE:
-.FILL .LEFT MARGIN 9
-.SKIP 1
-.NOFILL
double dpoly(order,coeffs,x)
int order;
double *coeffs;
double x;
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
PROGRAMMER:
-.FILL .LEFT MARGIN 9
-.SKIP 1
-.NOFILL
Fred Fish
Goodyear Aerospace Corp, Arizona Div.
(602) 932-7000 work
(602) 894-6881 home
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
INTERNALS:
-.FILL .LEFT MARGIN 9
-.SKIP 1
Evalates the polynomial using recursion and the form:
-.SKIP 1
-.NOFILL
	P(x) _= P0 + x(P1 + x(P2 +...x(Pn)))
-.SKIP 1
-.LEFT MARGIN 0
-.COMMENT Beginning source file DSCALE.C.27
-.SUBTITLE DSCALE
-.PAGE
-.HEADER LEVEL 2 Scale a double precision number by power of 2

-.SKIP 3
-.CENTER ;**********
-.CENTER ;* DSCALE *
-.CENTER ;**********
-.SKIP 3
-.INDEX  DSCALE
-.INDEX  math libraries
-.INDEX  machine dependent routines
-.SKIP 1 .test page 4
DESCRIPTION:
-.FILL .LEFT MARGIN 9
-.SKIP 1
Adds a specified integer to a double precision number's
exponent, effectively multiplying by a power of 2 for positive
scale values and divided by a power of 2 for negative
scale values.
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
USAGE:
-.FILL .LEFT MARGIN 9
-.SKIP 1
-.NOFILL
double dscale(value,scale)
double value;
integer scale;
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
PROGRAMMER:
-.FILL .LEFT MARGIN 9
-.SKIP 1
-.NOFILL
Fred Fish
Goodyear Aerospace Corp, Arizona Div.
(602) 932-7000 work
(602) 894-6881 home
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
INTERNALS:
-.FILL .LEFT MARGIN 9
-.SKIP 1
This routine is highly machine dependent.  As such, no
attempt was made to make it general, hence it may have
to be completely rewritten when transportation of the
floating point library is attempted.
-.SKIP 1
For the DECSYSTEM-20 the double precision word format is:
-.SKIP 1
-.NOFILL
WORD N	_=>	SEEEEEEEEMMMMMMMMMMMMMMMMMMMMMMMMMMM
WORD N+1 _=>	XMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
-.SKIP 1
-.FILL
For the PDP-11 the double precision word format is:
-.SKIP 1
-.NOFILL
WORD N _=>	SEEEEEEEEMMMMMMM
WORD N+1 _=>	MMMMMMMMMMMMMMMM
WORD N+2 _=>	MMMMMMMMMMMMMMMM
WORD N+3 _=>	MMMMMMMMMMMMMMMM
-.SKIP 1
-.FILL
Where:		S  _=>	Sign bit
-.NOFILL
		E  _=>	Exponent
		X  _=>	Ignored (set to 0)
		M  _=>	Mantissa bit
-.SKIP 1
-.FILL
DSCALE extracts the exponent, shifts it into the lower
order bits, adds the scale value to it, checks for
exponent overflow or underflow, shifts it back into the
high bits, and inserts it back into the value.
-.SKIP 1
NOTE:  On the DECSYSTEM-20, the exponent for negative
numbers is complemented.  This is not true for the PDP-11.
-.SKIP 1
-.LEFT MARGIN 0
-.COMMENT Beginning source file DSIGN.C.6
-.SUBTITLE DSIGN
-.PAGE
-.HEADER LEVEL 2 Transfer of sign

-.SKIP 3
-.CENTER ;*********
-.CENTER ;* DSIGN *
-.CENTER ;*********
-.SKIP 3
-.INDEX  DSIGN
-.INDEX  machine independent routines
-.INDEX  math libraries
-.SKIP 1 .test page 4
DESCRIPTION:
-.FILL .LEFT MARGIN 9
-.SKIP 1
Returns first argument with same sign as second argument.
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
USAGE:
-.FILL .LEFT MARGIN 9
-.SKIP 1
-.NOFILL
double dsign(x,y)
double x;
double y;
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
PROGRAMMER:
-.FILL .LEFT MARGIN 9
-.SKIP 1
-.NOFILL
Fred Fish
Goodyear Aerospace Corp, Arizona Div.
(602) 932-7000 work
(602) 894-6881 home
-.SKIP 1
-.LEFT MARGIN 0
-.COMMENT Beginning source file DSIN.C.62
-.SUBTITLE DSIN
-.PAGE
-.HEADER LEVEL 2 Double precision sine

-.SKIP 3
-.CENTER ;********
-.CENTER ;* DSIN *
-.CENTER ;********
-.SKIP 3
-.INDEX  DSIN
-.INDEX  machine independent routines
-.INDEX  trigonometric functions
-.INDEX  math libraries
-.SKIP 1 .test page 4
DESCRIPTION:
-.FILL .LEFT MARGIN 9
-.SKIP 1
Returns double precision sine of double precision
floating point argument.
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
USAGE:
-.FILL .LEFT MARGIN 9
-.SKIP 1
-.NOFILL
double dsin(x)
double x;
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
REFERENCES:
-.FILL .LEFT MARGIN 9
-.SKIP 1
Computer Approximations, J.F. Hart et al, John Wiley _& Sons,
1968, pp. 112-120.
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
RESTRICTIONS:
-.FILL .LEFT MARGIN 9
-.SKIP 1
The DSIN and DCOS routines are interactive in the sense that
in the process of reducing the argument to the range -PI/4
to PI/4, each may call the other.  Ultimately one or the
other uses a polynomial approximation on the reduced
argument.  The DSIN approximation has a maximum relative error
of 10**(-17.59) and the DCOS approximation has a maximum
relative error of 10**(-16.18).
-.SKIP 1
These error bounds assume exact arithmetic
in the polynomial evaluation.  Additional rounding and
truncation errors may occur as the argument is reduced
to the range over which the polynomial approximation
is valid, and as the polynomial is evaluated using
finite-precision arithmetic.
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
PROGRAMMER:
-.FILL .LEFT MARGIN 9
-.SKIP 1
-.NOFILL
Fred Fish
Goodyear Aerospace Corp, Arizona Div.
(602) 932-7000 work
(602) 894-6881 home
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
INTERNALS:
-.FILL .LEFT MARGIN 9
-.SKIP 1
Computes DSIN(X) from:
-.SKIP 1
-.NOFILL
	(1)	Reduce argument X to range -PI to PI.
-.SKIP 1
	(2)	If X > PI/2 then call DSIN recursively
		using relation DSIN(X) _= -DSIN(X - PI).
-.SKIP 1
	(3)	If X _< -PI/2 then call DSIN recursively
		using relation DSIN(X) _= -DSIN(X + PI).
-.SKIP 1
	(4)	If X > PI/4 then call DCOS using
		relation DSIN(X) _= DCOS(PI/2 - X).
-.SKIP 1
	(5)	If X _< -PI/4 then call DCOS using
		relation DSIN(X) _= -DCOS(PI/2 + X).
-.SKIP 1
	(6)	If X is small enough that polynomial
		evaluation would cause underflow
		then return X, since SIN(X)
		approaches X as X approaches zero.
-.SKIP 1
	(7)	By now X has been reduced to range
		-PI/4 to PI/4 and the approximation
		from HART pg. 118 can be used:
-.SKIP 1
		DSIN(X) _= Y * ( P(Y) / Q(Y) )
		Where:
-.SKIP 1
		Y    _=  X * (4/PI)
-.SKIP 1
		P(Y) _=  SUM [ Pj * (Y**(2*j)) ]
		over j _= {0,1,2,3}
-.SKIP 1
		Q(Y) _=  SUM [ Qj * (Y**(2*j)) ]
		over j _= {0,1,2,3}
-.SKIP 1
		P0   _=  0.206643433369958582409167054e+7
		P1   _=  -0.18160398797407332550219213e+6
		P2   _=  0.359993069496361883172836e+4
		P3   _=  -0.2010748329458861571949e+2
		Q0   _=  0.263106591026476989637710307e+7
		Q1   _=  0.3927024277464900030883986e+5
		Q2   _=  0.27811919481083844087953e+3
		Q3   _=  1.0000...
		(coefficients from HART table _#3063 pg 234)
-.SKIP 1
-.SKIP 1
-.FILL
**** NOTE ****	  The range reduction relations used in
this routine depend on the final approximation being valid
over the negative argument range in addition to the positive
argument range.  The particular approximation chosen from
HART satisfies this requirement, although not explicitly
stated in the text.  This may not be true of other
approximations given in the reference.
-.NOFILL

-.LEFT MARGIN 0
-.COMMENT Beginning source file DSINH.C.7
-.SUBTITLE DSINH
-.PAGE
-.HEADER LEVEL 2 Double precision hyperbolic sine

-.SKIP 3
-.CENTER ;*********
-.CENTER ;* DSINH *
-.CENTER ;*********
-.SKIP 3
-.INDEX  DSINH
-.INDEX  machine independent routines
-.INDEX  math libraries
-.SKIP 1 .test page 4
DESCRIPTION:
-.FILL .LEFT MARGIN 9
-.SKIP 1
Returns double precision hyperbolic sine of double precision
floating point number.
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
USAGE:
-.FILL .LEFT MARGIN 9
-.SKIP 1
-.NOFILL
double dsinh(x)
double x;
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
REFERENCES:
-.FILL .LEFT MARGIN 9
-.SKIP 1
Fortran IV plus user's guide, Digital Equipment Corp. pp B-5
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
RESTRICTIONS:
-.FILL .LEFT MARGIN 9
-.SKIP 1
Inputs greater than LN(MAX__POS__DBLF) result in overflow.
Inputs less than LN(MIN__POS__DBLF) result in underflow.
-.SKIP 1
For precision information refer to documentation of the
floating point library routines called.
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
PROGRAMMER:
-.FILL .LEFT MARGIN 9
-.SKIP 1
-.NOFILL
Fred Fish
Goodyear Aerospace Corp, Arizona Div.
(602) 932-7000 work
(602) 894-6881 home
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
INTERNALS:
-.FILL .LEFT MARGIN 9
-.SKIP 1
Computes hyperbolic sine from:
-.SKIP 1
-.NOFILL
	DSINH(X) _= 0.5 * (DEXP(X) - DEXP(-X))
-.SKIP 1
-.LEFT MARGIN 0
-.COMMENT Beginning source file DSQRT.C.28
-.SUBTITLE DSQRT
-.PAGE
-.HEADER LEVEL 2 Double precision square root

-.SKIP 3
-.CENTER ;*********
-.CENTER ;* DSQRT *
-.CENTER ;*********
-.SKIP 3
-.INDEX  DSQRT
-.INDEX  machine independent routines
-.INDEX  math libraries
-.SKIP 1 .test page 4
DESCRIPTION:
-.FILL .LEFT MARGIN 9
-.SKIP 1
Returns double precision square root of double precision
floating point argument.
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
USAGE:
-.FILL .LEFT MARGIN 9
-.SKIP 1
-.NOFILL
double dsqrt(x)
double x;
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
REFERENCES:
-.FILL .LEFT MARGIN 9
-.SKIP 1
Fortran IV-PLUS user's guide, Digital Equipment Corp. pp B-7.
-.SKIP 1
Computer Approximations, J.F. Hart et al, John Wiley _& Sons,
1968, pp. 89-96.
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
RESTRICTIONS:
-.FILL .LEFT MARGIN 9
-.SKIP 1
The relative error is 10**(-30.1) after three applications
of Heron's iteration for the square root.
-.SKIP 1
However, this assumes exact arithmetic in the iterations
and initial approximation.  Additional errors may occur
due to truncation, rounding, or machine precision limits.
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
PROGRAMMER:
-.FILL .LEFT MARGIN 9
-.SKIP 1
-.NOFILL
Fred Fish
Goodyear Aerospace Corp, Arizona Div.
(602) 932-7000 work
(602) 894-6881 home
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
INTERNALS:
-.FILL .LEFT MARGIN 9
-.SKIP 1
Computes square root by:
-.SKIP 1
-.NOFILL
	(1)	Range reduction of argument to [0.5,1.0]
		by application of identity:
-.SKIP 1
		sqrt(x)  _=  2**(k/2) * sqrt(x * 2**(-k))
-.SKIP 1
		k is the exponent when x is written as
		a mantissa times a power of 2 (m * 2**k).
		It is assumed that the mantissa is
		already normalized (0.5 _=_< m _< 1.0).
-.SKIP 1
	(2)	An approximation to sqrt(m) is obtained
		from:
-.SKIP 1
		u _= sqrt(m) _= (P0 + P1*m) / (Q0 + Q1*m)
-.SKIP 1
		P0 _= 0.594604482
		P1 _= 2.54164041
		Q0 _= 2.13725758
		Q1 _= 1.0
-.SKIP 1
		(coefficients from HART table _#350 pg 193)
-.SKIP 1
-.FILL
(3)	Three applications of Heron's iteration are
-.NOFILL
	performed using:
-.SKIP 1
		y[n+1] _= 0.5 * (y[n] + (m/y[n]))
-.SKIP 1
		where y[0] _= u _= approx sqrt(m)
-.SKIP 1
-.FILL
(4)	If the value of k was odd then y is either
-.NOFILL
	multiplied by the square root of two or
	divided by the square root of two for k positive
	or negative respectively.  This rescales y
	by multiplying by 2**frac(k/2).
-.SKIP 1
-.FILL
(5)	Finally, y is rescaled by int(k/2) which
-.NOFILL
	is equivalent to multiplication by 2**int(k/2).
-.SKIP 1
	The result of steps 4 and 5 is that the value
	of y between 0.5 and 1.0 has been rescaled by
	2**(k/2) which removes the original rescaling
	done prior to finding the mantissa square root.
-.SKIP 1
-.LEFT MARGIN 0
-.COMMENT Beginning source file DTAN.C.10
-.SUBTITLE DTAN
-.PAGE
-.HEADER LEVEL 2 Double precision tangent

-.SKIP 3
-.CENTER ;********
-.CENTER ;* DTAN *
-.CENTER ;********
-.SKIP 3
-.INDEX  DTAN
-.INDEX  machine independent routines
-.INDEX  trigonometric functions
-.INDEX  math libraries
-.SKIP 1 .test page 4
DESCRIPTION:
-.FILL .LEFT MARGIN 9
-.SKIP 1
Returns tangent of double precision floating point number.
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
USAGE:
-.FILL .LEFT MARGIN 9
-.SKIP 1
-.NOFILL
double dtan(x)
double x;
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
INTERNALS:
-.FILL .LEFT MARGIN 9
-.SKIP 1
Computes the tangent from tan(x) _= sin(x) / cos(x).
-.SKIP 1
If cos(x) _= 0 and sin(x) >_= 0, then returns largest
floating point number on host machine.
-.SKIP 1
If cos(x) _= 0 and sin(x) _< 0, then returns smallest
floating point number on host machine.
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
REFERENCES:
-.FILL .LEFT MARGIN 9
-.SKIP 1
Fortran IV plus user's guide, Digital Equipment Corp. pp. B-8
-.SKIP 1
-.LEFT MARGIN 0
-.COMMENT Beginning source file DTANH.C.6
-.SUBTITLE DTANH
-.PAGE
-.HEADER LEVEL 2 Double precision hyperbolic tangent

-.SKIP 3
-.CENTER ;*********
-.CENTER ;* DTANH *
-.CENTER ;*********
-.SKIP 3
-.INDEX  DTANH
-.INDEX  machine independent routines
-.INDEX  math libraries
-.SKIP 1 .test page 4
DESCRIPTION:
-.FILL .LEFT MARGIN 9
-.SKIP 1
Returns double precision hyperbolic tangent of double precision
floating point number.
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
USAGE:
-.FILL .LEFT MARGIN 9
-.SKIP 1
-.NOFILL
double dtanh(x)
double x;
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
REFERENCES:
-.FILL .LEFT MARGIN 9
-.SKIP 1
Fortran IV plus user's guide, Digital Equipment Corp. pp B-5
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
RESTRICTIONS:
-.FILL .LEFT MARGIN 9
-.SKIP 1
For precision information refer to documentation of the
floating point library routines called.
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
PROGRAMMER:
-.FILL .LEFT MARGIN 9
-.SKIP 1
-.NOFILL
Fred Fish
Goodyear Aerospace Corp, Arizona Div.
(602) 932-7000 work
(602) 894-6881 home
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
INTERNALS:
-.FILL .LEFT MARGIN 9
-.SKIP 1
Computes hyperbolic tangent from:
-.SKIP 1
-.NOFILL
	DTANH(X) _= 1.0 for X > DTANH__MAXARG
		 _= -1.0 for X _< -DTANH__MAXARG
		 _=  DSINH(X) / DCOSH(X) otherwise
-.SKIP 1
-.LEFT MARGIN 0
-.COMMENT Beginning source file DXEXP.C.11
-.SUBTITLE DXEXP
-.PAGE
-.HEADER LEVEL 2 extract double precision numbers exponent

-.SKIP 3
-.CENTER ;*********
-.CENTER ;* DXEXP *
-.CENTER ;*********
-.SKIP 3
-.INDEX  DXEXP
-.INDEX  math libraries
-.INDEX  machine dependent routines
-.SKIP 1 .test page 4
DESCRIPTION:
-.FILL .LEFT MARGIN 9
-.SKIP 1
Extracts exponent from a double precision number and
returns it as a normal length integer.
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
USAGE:
-.FILL .LEFT MARGIN 9
-.SKIP 1
-.NOFILL
int dxexp(value)
double value;
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
PROGRAMMER:
-.FILL .LEFT MARGIN 9
-.SKIP 1
-.NOFILL
Fred Fish
Goodyear Aerospace Corp, Arizona Div.
(602) 932-7000 work
(602) 894-6881 home
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
INTERNALS:
-.FILL .LEFT MARGIN 9
-.SKIP 1
This routine is highly machine dependent.  As such, no
attempt was made to make it general, hence it may have
to be completely rewritten when transportation of the
floating point library is attempted.
-.SKIP 1
For the DECSYSTEM-20 the double precision word format is:
-.SKIP 1
-.NOFILL
WORD N	_=>	SEEEEEEEEMMMMMMMMMMMMMMMMMMMMMMMMMMM
WORD N+1 _=>	XMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
-.SKIP 1
-.FILL
For the PDP-11 the double precision word format is:
-.SKIP 1
-.NOFILL
WORD N _=>	SEEEEEEEEMMMMMMM
WORD N+1 _=>	MMMMMMMMMMMMMMMM
WORD N+2 _=>	MMMMMMMMMMMMMMMM
WORD N+3 _=>	MMMMMMMMMMMMMMMM
-.SKIP 1
-.FILL
Where:		S  _=>	Sign bit
-.NOFILL
		E  _=>	Exponent
		X  _=>	Ignored (set to 0)
		M  _=>	Mantissa bit
-.SKIP 1
-.SKIP 1
-.LEFT MARGIN 0
-.COMMENT Beginning source file DXMANT.C.10
-.SUBTITLE DXMANT
-.PAGE
-.HEADER LEVEL 2 Extract double precision number's mantissa

-.SKIP 3
-.CENTER ;**********
-.CENTER ;* DXMANT *
-.CENTER ;**********
-.SKIP 3
-.INDEX  DXMANT
-.INDEX  math libraries
-.INDEX  machine dependent routines
-.SKIP 1 .test page 4
DESCRIPTION:
-.FILL .LEFT MARGIN 9
-.SKIP 1
Extracts a double precision number's mantissa and returns it
as a double precision number with a normalized mantissa and
a zero exponent.
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
USAGE:
-.FILL .LEFT MARGIN 9
-.SKIP 1
-.NOFILL
double dxmant(value)
double value;
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
PROGRAMMER:
-.FILL .LEFT MARGIN 9
-.SKIP 1
-.NOFILL
Fred Fish
Goodyear Aerospace Corp, Arizona Div.
(602) 932-7000 work
(602) 894-6881 home
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
INTERNALS:
-.FILL .LEFT MARGIN 9
-.SKIP 1
This routine is highly machine dependent.  As such, no
attempt was made to make it general, hence it may have
to be completely rewritten when transportation of the
floating point library is attempted.
-.SKIP 1
For the DECSYSTEM-20 the double precision word format is:
-.SKIP 1
-.NOFILL
WORD N	_=>	SEEEEEEEEMMMMMMMMMMMMMMMMMMMMMMMMMMM
WORD N+1 _=>	XMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
-.SKIP 1
-.FILL
For the PDP-11 the double precision word format is:
-.SKIP 1
-.NOFILL
WORD N _=>	SEEEEEEEEMMMMMMM
WORD N+1 _=>	MMMMMMMMMMMMMMMM
WORD N+2 _=>	MMMMMMMMMMMMMMMM
WORD N+3 _=>	MMMMMMMMMMMMMMMM
-.SKIP 1
-.FILL
Where:		S  _=>	Sign bit
-.NOFILL
		E  _=>	Exponent
		X  _=>	Ignored (set to 0)
		M  _=>	Mantissa bit
-.SKIP 1
-.LEFT MARGIN 0
-.COMMENT Beginning source file FTEST1.C.8
-.COMMENT Beginning source file FTEST2.C.35
-.COMMENT Beginning source file FTEST3.C.17
-.COMMENT Beginning source file FTESTERR.C.29
-.COMMENT Beginning source file PMLERR.C.5
-.SUBTITLE PMLCFS
-.PAGE
-.HEADER LEVEL 2 Clear specified PML error handler flags

-.SKIP 3
-.CENTER ;**********
-.CENTER ;* PMLCFS *
-.CENTER ;**********
-.SKIP 3
-.INDEX  PMLCFS
-.INDEX  machine independent routines
-.INDEX  math libraries
-.SKIP 1 .test page 4
DESCRIPTION:
-.FILL .LEFT MARGIN 9
-.SKIP 1
Clear the specified PML error handler flags for the
specified error.  Two or more flags may be cleared simultaneously
by "or-ing" them in the call, for example "LOG | CONTINUE".
The manifest constants for the flags and error codes are
defined in _<pmluser.h>.
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
USAGE:
-.FILL .LEFT MARGIN 9
-.SKIP 1
-.NOFILL
pmlcfs(err__code,flags)
int err__code;
int flags;
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
PROGRAMMER:
-.FILL .LEFT MARGIN 9
-.SKIP 1
-.NOFILL
Fred Fish
Goodyear Aerospace Corp, Arizona Div.
(602) 932-7000 work
(602) 894-6881 home
-.SKIP 1
-.LEFT MARGIN 0
-.SUBTITLE PMLCNT
-.PAGE
-.HEADER LEVEL 2 Get PML error count and reset it to zero

-.SKIP 3
-.CENTER ;**********
-.CENTER ;* PMLCNT *
-.CENTER ;**********
-.SKIP 3
-.INDEX  PMLCNT
-.INDEX  machine independent routines
-.INDEX  math libraries
-.SKIP 1 .test page 4
DESCRIPTION:
-.FILL .LEFT MARGIN 9
-.SKIP 1
Returns the total number of PML errors seen
prior to the call, and resets the error count to zero.
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
USAGE:
-.FILL .LEFT MARGIN 9
-.SKIP 1
int pmlcnt()
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
PROGRAMMER:
-.FILL .LEFT MARGIN 9
-.SKIP 1
-.NOFILL
Fred Fish
Goodyear Aerospace Corp, Arizona Div.
(602) 932-7000 work
(602) 894-6881 home
-.SKIP 1
-.LEFT MARGIN 0
-.SUBTITLE PMLERR
-.PAGE
-.HEADER LEVEL 2 Portable Math Library error handler

-.SKIP 3
-.CENTER ;**********
-.CENTER ;* PMLERR *
-.CENTER ;**********
-.SKIP 3
-.INDEX  PMLERR
-.INDEX  machine independent routines
-.INDEX  math libraries
-.SKIP 1 .test page 4
DESCRIPTION:
-.FILL .LEFT MARGIN 9
-.SKIP 1
Provides a sample PML error handler.  Does
not use any available hardware "traps" so is machine
independent.  Generally only called internally by the
other PML routines.
-.SKIP 1
There are currently three flags which control the
response for specific errors:
-.SKIP 1
-.NOFILL
(1)  LOG      When set an error message is sent
              to the user terminal.
-.SKIP 1
(2)  COUNT    When set the error is counted
              against the PML error limit.
-.SKIP 1
(3) CONTINUE  When set the task continues
              providing the error count has not
              exceeded the PML error limit.
-.SKIP 1
-.FILL
Each of these flags can be set or reset independently
by "pmlsfs" or "pmlcfs" respectively.
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
USAGE:
-.FILL .LEFT MARGIN 9
-.SKIP 1
-.NOFILL
pmlerr(err__code)
int err__code;
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
PROGRAMMER:
-.FILL .LEFT MARGIN 9
-.SKIP 1
-.NOFILL
Fred Fish
Goodyear Aerospace Corp, Arizona Div.
(602) 932-7000 work
(602) 894-6881 home
-.SKIP 1
-.LEFT MARGIN 0
-.SUBTITLE PMLLIM
-.PAGE
-.HEADER LEVEL 2 Set Portable Math Library error limit

-.SKIP 3
-.CENTER ;**********
-.CENTER ;* PMLLIM *
-.CENTER ;**********
-.SKIP 3
-.INDEX  PMLLIM
-.INDEX  machine independent routines
-.INDEX  math libraries
-.SKIP 1 .test page 4
DESCRIPTION:
-.FILL .LEFT MARGIN 9
-.SKIP 1
Sets the PML error limit to the specified value
and returns it previous value.
Does not affect the current error count (which may be reset
to zero by a call to "pmlcnt").  Note that the default error
limit is set at compile time by the value in "pml.h".
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
USAGE:
-.FILL .LEFT MARGIN 9
-.SKIP 1
-.NOFILL
int pmllim(limit)
int limit;
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
PROGRAMMER:
-.FILL .LEFT MARGIN 9
-.SKIP 1
-.NOFILL
Fred Fish
Goodyear Aerospace Corp, Arizona Div.
(602) 932-7000 work
(602) 894-6881 home
-.SKIP 1
-.LEFT MARGIN 0
-.SUBTITLE PMLSFS
-.PAGE
-.HEADER LEVEL 2 Set specified PML error handler flags

-.SKIP 3
-.CENTER ;**********
-.CENTER ;* PMLSFS *
-.CENTER ;**********
-.SKIP 3
-.INDEX  PMLSFS
-.INDEX  machine independent routines
-.INDEX  math libraries
-.SKIP 1 .test page 4
DESCRIPTION:
-.FILL .LEFT MARGIN 9
-.SKIP 1
Set the specified PML error handler flags for the
specified error.  Two or more flags may be set simultaneously
by "or-ing" them in the call, for example "LOG | CONTINUE".
The manifest constants for the flags and error codes are
defined in _<pmluser.h>.
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
USAGE:
-.FILL .LEFT MARGIN 9
-.SKIP 1
-.NOFILL
pmlsfs(err__code,flags)
int err__code;
int flags;
-.SKIP 1
-.LEFT MARGIN 0
-.SKIP 1 .test page 4
PROGRAMMER:
-.FILL .LEFT MARGIN 9
-.SKIP 1
-.NOFILL
Fred Fish
Goodyear Aerospace Corp, Arizona Div.
(602) 932-7000 work
(602) 894-6881 home
-.SKIP 1
-.LEFT MARGIN 0
-.COMMENT        This file is the runoff trailer file for the
-.COMMENT	Portable Math Library (PML) documentation.
-.COMMENT

-.APPENDIX REFERENCES
-.LIST
-.LIST ELEMENT
P. A. Fox, A. D. Hall, and N. L. Schryer,
The PORT Mathematical Subroutine Library,
ACM Transactions on Mathematical Software,
Vol 4, No. 2, June 1978, pp 104-126.
-.LIST ELEMENT
Brian Ford,
Parameterization of the Environment for Transportable Numerical Software,
ACM Transactions on Mathematical Software,
Vol 4, No. 2, June 1978, pp 100-103.
-.END LIST

-.DO INDEX


------- End of Returned Message
