	TITLE	OPRCMD - command tables for ORION
	SUBTTL	Murry Berkowitz/BH/DC/AWC/PJT	12-Jan-81

;
;
;
;        COPYRIGHT (c) 1975,1976,1977,1978,1979,1980,1981,1982
;           DIGITAL EQUIPMENT CORPORATION, MAYNARD, MA.
;
;     THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY  BE  USED
;     AND COPIED ONLY IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE
;     AND WITH THE INCLUSION OF THE ABOVE COPYRIGHT NOTICE.   THIS
;     SOFTWARE  OR ANY OTHER COPIES THEREOF MAY NOT BE PROVIDED OR
;     OTHERWISE MADE AVAILABLE TO ANY OTHER PERSON.  NO  TITLE  TO
;     AND OWNERSHIP OF THE SOFTWARE IS HEREBY TRANSFERRED.
;     
;     THE INFORMATION  IN  THIS  SOFTWARE  IS  SUBJECT  TO  CHANGE
;     WITHOUT  NOTICE  AND SHOULD NOT BE CONSTRUED AS A COMMITMENT
;     BY DIGITAL EQUIPMENT CORPORATION.
;     
;     DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE OR RELIABILITY
;     OF  ITS  SOFTWARE  ON  EQUIPMENT  WHICH  IS  NOT SUPPLIED BY
;     DIGITAL.


	SALL
	SEARCH	GLXMAC
	SEARCH	ORNMAC
	PROLOG(OPRCMD)

	CMDEDT==:146	;EDIT LEVEL



	.DIRECTIVE FLBLST



	INTERN	OPRCMD	;MAKE VECTOR ADDRESS AVAILABLE
OPRCMD:	EXP	2	;SIZE
	EXP	INITCM	;POINTER TO THE INI FUNCTION
	EXP	CMDFDB	;TOP LEVEL DISPATCH
SUBTTL	Table of Contents

;               TABLE OF CONTENTS FOR OPRCMD
;
;
;                        SECTION                                   PAGE
;    1. Table of Contents.........................................   2
;    2. Revision History..........................................   3
;    3. Special Macro Definitions.................................   4
;    4. $UNIT Macro...............................................   4
;    5. $STNUM Macro..............................................   4
;    6. $STREAM Macro.............................................   4
;    7. $EXPL Macro Definition....................................   5
;    8. $JOBSWI Macro Definition..................................   5
;    9. $URANGE Macro Definition..................................   6
;   10. $SRANGE Macro Definition..................................   6
;   11. Subroutine macros.........................................   7
;   12. Command Dispatch..........................................   8
;   13. Argument Subroutines......................................   9
;   14. START command tables......................................  10
;   15. CONTINUE command tables...................................  11
;   16. SHUTDOWN command tables...................................  11
;   17. STOP command tables.......................................  12
;   18. ABORT command tables......................................  13
;   19. HOLD command tables.......................................  14
;   20. RELEASE command tables....................................  14
;   21. DEFINE command tables.....................................  15
;   22. CANCEL command tables.....................................  16
;   23. MODIFY command tables.....................................  17
;   24. SHOW command tables.......................................  18
;   25. SHOW STATUS command tables................................  19
;   26. SHOW SYSTEM-LIST command tables...........................  20
;   27. LOCK/UNLOCK command tables................................  21
;   28. SHWNOD  SHOW STATUS/PARAMETERS FOR NODE...................  22
;   29. RESPOND command tables....................................  23
;   30. REQUEUE command tables....................................  24
;   31. BACKSPACE command tables..................................  25
;   32. FORWARDSPACE command tables...............................  25
;   33. ALIGN command table.......................................  26
;   34. SUPPRESS command tables...................................  27
;   35. ROUTE command tables......................................  28
;   36. SEND command tables.......................................  29
;   37. SET command tables........................................  30
;   38. SET TAPE and DISK command tables (TOPS20).................  31
;   39. SET ONLINE command tables.................................  32
;   40. SET USAGE command tables..................................  33
;   41. SET TAPE INITIALIZE command tables........................  34
;   42. SET NODE command tables...................................  35
;   43. SET SCHEDULER command tables (TOPS20).....................  36
;   44. ENABLE command tables.....................................  37
;   45. DISABLE command tables....................................  37
;   46. ENACLS  ENABLE CLASS SCHEDULER command tables.............  38
;   47. CLOSE command tables......................................  39
;   48. DEFINE command tables.....................................  39
;   49. REPORT command tables.....................................  40
;   50. MOUNT command tables (TOPS10).............................  41
;   51. IDENTIFY command tables...................................  42
;   52. SWITCH  command tables (TOPS20)...........................  43
;   53. DISMOUNT command tables...................................  44
;   54. UNLOAD  command tables (removed)..........................  44
;   55. RECOGNIZE command tables..................................  44
;   56. PUSH command tables.......................................  45
;   57. HELP command tables.......................................  46
;   58. SHOW ALLOCATION command tables............................  47
SUBTTL	Revision History

COMMENT	\
Edit      Date	 	Reason
----	  ----		-------------------------------------

0001	29-Jun-78	1)Use $DEFAULT for CLOSE command
			2)Eliminate DEFINE command.
			3)Add REPORT command.

0002	 7-Jul-78	1)Change PAUSE command back to STOP.
			2)Make SHUTDOWN command a logical STOP
			  scheduling function.

0003	10-Jul-78	1)Redo ROUTE Command.
0004	13-Jul-78	1)Implement range checking.
			2)Modify ENABLE/DISABLE commands
			3)Add node to node function in ENABLE command.
			4)Invent a SHOW QUEUES command.
0005	13-Jul-78	1)Make START command take an optional device
			  Name to support tapes.
0006	20-Jul-78	Rework the CANCEL syntax.
0007	31-Jul-78	Make minor cleanup fixes.
0010	5-Sept-78	Add the EXIT Command
0011	27-Oct-78	Add -20 Tape and Disk Commands
0012	30-Nov-78	Add Request Id to replace JOBNAME and SEQUENCE number
0013	1-Dec-78	Add DELETE Command
0014	1-Dec-78	Add SHOW OPERATOR Command and make SEND ALL allow
			only one line for this release
0015	5-Dec-78	Change SHOW STATUS and SHOW PARAMETERS
0016	7-Dec-78	Change HOLD, RELEASE, MODIFY, AND DELETE
0017	5-Jan-79	Change KEYTAB and SWITAB to ORNDSP and ORNSDP
0020	5-Jan-79	Add /SHORT to SHOW STATUS and SHOW QUEUES have a
			/NODE SWITCH
0021	17-JAN-79	MAKE USE OF $KEY AND ORNKEY AND ORNSWI WHERE POSSIBLE
			FOR TABLES ALL GOING TO SAME PLACE
0022	18-Jan-79	Add HELP Command
0023	19-Jan-79	Allow Limited Exceeded Action for Card-Punches,
			Paper-Tape-Punches, and Plotters
			Add New ENABLE Code
0024	24-Jan-79	add SET ONLINE and convert to TOPS10 and TOPS20 macros
0025	26-JAN-79	MERGE IN HELP ROUTINE
0026	29-JAN-79	REMOVE SHOW PARAMTERS FOR READERS
0027	2-FEB-79	CHANGE SHOW STATUS TAPE DRIVES
0030	6-FEB-79	ADD DN60 CODE FOR DEFINE, SET AND SHUTDOWN
0031	12-FEB-79	FIX HELP SUPPORT ROUTINE
0032	21-Feb-79	Make Define Command take Line and Port in Octal
0033	21-Feb-79	Allow only one File for FORWARDSPACE and BACKSPACE
			commands
0034	22-Feb-79	Add new Helpum Code
0035	23-Feb-79	Add SHOW QUEUE RETRIEVIAL Requests
0036	27-Feb-79	Change Mount Command to have Keyword STRUCTURE
0037	28-Feb-79	Add SET command to Initialize Tape
0040	5-Mar-79	Add PUSH Command for the -20
0041	7-MAR-79	Bytes per Message for Set Node command
			and add Unlabled to Set Initialize
0042	8-Mar-79	Rework Enable Output display Tables
0043	25-Mar-79	Add IDENTIFY Command for Tape and remove all 
			Mount options for Tape
			Add DELETE Command for Mounts and Structures
0044	6-Apr-79	Allow Ranges of 1:1 etc.. so that absolute options
			can be set
0045	10-Apr-79	Add new MOUNTR switches for TAPE and DISK
			for SHOW STATUS and remove SHOW PARAMETERS
0046	19-Apr-79	Change key outputs in SET TERM TYPE to .TTxxx
0047	23-Apr-79	Add -20 Scheduler Commands
0050	30-Apr-79	Correct SET Disk Drive Command. No Initialize  supported
0051	15-May-79 	Have SEND command accept /NODE: for Batch
0052	30-May-79	Add the WAIT command to the command tables
0053	8-Jun-79	Add SHOW STATUS/PARAMETERS NETWORK-NODE and
			START NODE command
0054	2-Jul-79	Change SHOW DAYTIME to SHOW TIME and add 
			ENABLE/DISABLE FILE-RETRIEVIAL-WAITs on the -20
0055	5-Jul-79	Change ">" and "<" to octal 76 and 74 to avoid macro bug
0056	6-Jul-79	Change the CANCEL Command to ABORT and DELETE command to
			CANCEL
			Make the WAIT command invisible

0057	9-Jul-79	Remove the MOUNT command
0060	11-Jul-79	Remove the UNLOAD command and create new form of 
			DISMOUNT command
0061	23-Aug-79	Add SET NODE xx SIGNON-REQUIRED
					NO-SIGNON-REQUIRED
0062	28-Aug-79	Remove -20 conditionals on SHOW STATUS DISK command
0063	10-SEPT-79	CHANGE HELP TEXT FOR CLEAR-SEND DELAY TO JIFFIES FROM
			MILLISECONDS
0064	11-Sept-79	On Cancel Mount-Requests check for device before
			Checking for a request number inorder to allow
			structures that begin with a number
0065	12-Sept-79	Remove Transparency from IBM SET NODE command
0066	5-Oct-79	Add Transparency again and make SET ONLINE 
			on -20 take all Octal Numbers
0067	8-Oct-79	Add Commands for MDA
				ENABLE AUTOMATIC-STRUCTURE-RECOGNITION
				ADD (Structure) foo (to) SYSTEM-SEARCH-LIST
				ADD (Structure) foo (to) Active-Swap-list	
				Lock/unlock (structure) foo (at) time/date
				SHOW STATUS STRUCTURES
				DISMOUNT /REMOVE

0070	22-Oct-79		Move HELP routine to OPRPAR as P$HELP
0071	23-Oct-79		Remove AUTOMATIC from
				AUTOMATIC-VOLUME-RECOGINTION and
				AUTOMATIC-STRUCTURE-RECOGNITION for
				TOPS10 only.  (Also remove invisible
				KEYWORDS ASR and AVR)
0072	24-Oct-79		Add /USER switch to SHO STA STR
0073	29-Oct-79		Make Keyword table for SHOW STATUS singular
0074	20-Dec-79		Add all the search list, swap list, dump list
				stuff for the -10
0075	02-Jan-79		Change help text for DISM TAPE ?
0076	08-Jan-79		Add show allocation for MDA
0077	26-Jan-80		Change noise and help text for RECOGNIZE
0100	07-Mar-80		Rearrange switch tables for set tap init.
				Remove /STARTING-VOL. Use /VOLID instead
0101	10-Mar-80		Put MOUNT command back in for the -10
0102	10-Apr-80		Add parse table entry for DISMOUNT/NOCHECK
0103	 9-MAY-80		Change mixed case text to first word mixed
				and the rest lower in all help, error and
				noise phrases.
0104	14-May-80		Make SET DISK-DRIVE accept octal channel and
				unit numbers
0105	5-JUN-80		Make the DISMOUNT structure command do a parse
				only on the structure name so that OPR's not
				running 1,2 can dismount private structures.
0106	25-JUN-80		Fix the SET USAGE command syntax once and for 
				all !!!

107	6-OCT-80		Add * to cancel mount requests

110	28-Oct-80		Remove default for the enable/disable volume-
				recog. command.

111	19-Nov-80/PJT		Add FTS and FAL commands under FTS conditional

112	24-Nov-80		Change the syntax of the ROUTE command to
				reflect new capabilities.

113	19-Dec-80		Add new /user switch to show queues

114	5-Jan-81		Add all devices to destination in route command

115	6-Jan-81		Add /NO-SESSION-ENTRIES to BILLING CLOSURE cmd

116	12-Jan-81		Clean up control-Z in command table.

117	16-Jan-81		Try to fix report command by doing noparse dev
				for the device field

120	7-Feb-81		Force VOLUME-ID to be required
				if labeled tape specified

121	9-Feb-81		Fix job switch in the suppress command
				JOB not JBX!

122	17-Feb-81		Fix help fields for setting limits to something
				meaningful

123	25-Feb-81		Change the lock and unlock commands to ask
				for future time

124	3-MAR-81		Do not allow quoted strings in /VOLUME-ID: field

125	4/9/81	Add $ACTION(SHRSWT) to eliminate switches as used in SHOW
		QUEUES command.

126	4/29/81  Use the NEXT macro and fix everything so show queue command
		deletes the switches correctly.

127	Make ^Z and CAN MOU * valid for -10 only.

130	6/26/81  Remove wait command; Fix set rpm command.

131	6/29/81  Add action routine to SHO Q RETRIEVAL/ALL @SHW470

132	8/20/81	Add /ABORT to tape initialization for TOPS10

133	9/21/81  Restore the wait command and make it visible.

134	9/22/81  Lite the parse only bit on SHOW STATUS DISK dev: commands

135	10/30/81  Move NO/SIGNON-REQ. from set command to switch in DEFINE

136	11/6/81  Remove DATA-TERMINAL-READY and SILO-WARNING from SET NODE
	command.

137	11/11/81  Lit the parse only bit on RECOGNIZE dev: commands.

140	11/17/81 Add NEXT command support

141	12/28/81 Remove /REQUEST-ID switch from ABORT and REQUEUE commands.

142	 1/4/82	Change LIMIT-EXCEEDED-ACTION to have keywords of
		ABORT, ASK, PROCEED to be consistent with new $WTORs

143	1/25/82  Remove defaults in the SET NODE command.  Also remove
	SETN70: since it references silo warning level which is no longer.

144	 3/18/82 Add support for MOUNT FOO:/WRITE-LOCKED. GCO 1272

145	4/9/82  Make the destination of ROUTE ALL FOO:: BAR:: parse only
	@RTEF75.  GCO 4.2.1307

146	8/9/82 Allow secondary ports to work on MODIFY commands.  GCO 1484

\ ;End of revision history
SUBTTL	Special Macro Definitions
SUBTTL	$UNIT Macro
SUBTTL	$STNUM Macro
SUBTTL	$STREAM Macro


;	!=======================================================!
;	!                   $UNIT (NEXT_PDB)                    !
;	!-------------------------------------------------------!
;	!               PARSE A UNIT NUMBER ONLY                !
;	!=======================================================!

;DEFINE A MACRO TO DO THE PARSING FOR A SINGLE UNIT NUMBER
DEFINE	$UNIT(NEXT,%UNI01,%UNI02),<
	.XCREF	%UNI01,%UNI02
	SUPPRESS %UNI01,%UNI02
	$NOISE	(%UNI01,<unit number>)
%UNI01:	$NUMBER	(%UNI02,^D10,<unit number (/NODE:)>,<$ACTION(CHKVAL)>)
%UNI02:	$NODE(NEXT)
>	;END $UNIT DEFINITION




;	!=======================================================!
;	!                   $STNUM (NEXT_PDB)                   !
;	!-------------------------------------------------------!
;	!              PARSE A STREAM NUMBER ONLY               !
;	!=======================================================!

;DEFINE A MACRO TO DO THE PARSING FOR A SINGLE STREAM NUMBER
;WITHOUT AN OPTIONAL NODE SPECIFICATION
DEFINE	$STNUM(NEXT,%STN01),<
	.XCREF	%STN01
	SUPPRESS %STN01
	$NOISE	(%STN01,<stream number>)
%STN01:	$NUMBER	(NEXT,^D10,<stream number>,$ACTION(CHKVAL))
>	;END $STNUM DEFINITION




;	!=======================================================!
;	!                  $STREAM (NEXT_PDB)                   !
;	!-------------------------------------------------------!
;	!           PARSE A STREAM WITH OPTIONAL NODE           !
;	!=======================================================!

;DEFINE A MACRO TO DO THE PARSING FOR A SINGLE STREAM NUMBER
DEFINE	$STREAM(NEXT,%STR01,%STR02),<
	.XCREF	%STR01,%STR02
	SUPPRESS %STR01,%STR02
	$NOISE	(%STR01,<stream number>)
%STR01:	$NUMBER	(%STR02,^D10,<stream number (/NODE:)>,$ACTION(CHKVAL))
%STR02:	$NODE(NEXT)
>	;END $STREAM DEFINITION
SUBTTL	$EXPL Macro Definition


;	!=======================================================!
;	!            $EXPL (NEXT_PDB,<KEYWORD-LIST>)            !
;	!-------------------------------------------------------!
;	!                     /REASON:TEXT                      !
;	!=======================================================!

;DEFINE A <EXPL> DEFINITION MACRO
DEFINE $EXPL (NXTLNK,ALTADR,%A,%B,%C)<
	.XCREF	%A,%B,%C
	SUPPRESS %A,%B,%C
	$SWITCH(%B,%A,ALTADR)
%A:	$STAB
	ORNSWI	(<REASON:>,RSN)
	$ETAB
%B:	$CRLF	(<$ALTER(%C),$ACTION(TXTLIN##),$HELP(<confirm for multiple line response>)>)

%C:	$CTEXT	(CONFRM,<single line response>)
>
SUBTTL	$URANGE Macro Definition
SUBTTL	$SRANGE Macro Definition

;	!=======================================================!
;	!                  $URANGE (NEXT_PDB)                   !
;	!-------------------------------------------------------!
;	!         PARSE A UNIT RANGE WITH OPTIONAL NODE         !
;	!=======================================================!

;DEFINE A MACRO TO DO THE PARSING FOR A RANGE OF UNIT NUMBERS
DEFINE	$URANGE(NEXT,%URG01,%URG02),<
	.XCREF	%URG01,%URG02
	SUPPRESS %URG01,%URG02
	$NOISE	(%URG01,<unit number>)
%URG01:	$RANGE(%URG02,<number or range (n:m)(/NODE:)>)
%URG02:	$NODE(NEXT)
>	;END $URANGE DEFINITION

;	!=======================================================!
;	!                  $SRANGE (NEXT_PDB)                   !
;	!-------------------------------------------------------!
;	!        PARSE A STREAM RANGE WITH OPTIONAL NODE        !
;	!=======================================================!

;DEFINE A MACRO TO DO THE PARSING FOR A RANGE OF STREAM NUMBERS
DEFINE	$SRANGE(NEXT,%SRG01,%SRG02),<
	.XCREF	%SRG01,%SRG02
	SUPPRESS %SRG01,%SRG02
	$NOISE	(%SRG01,<stream number>)
%SRG01:	$RANGE(%SRG02,<number or range (n:m)(/NODE:)>)
%SRG02:	$NODE(NEXT)

>	;END $SRANGE DEFINITION
SUBTTL	Subroutine macros


;DEFINE A MACRO TO ACTUALLY PARSE A RANGE OF OCTAL NUMBERS SPECIFIED AS
;   NUMBER:NUMBER (OR JUST NUMBER) WITH AN OPTIONAL NODE SWITCH

	DEFINE	$RANGE(NEXT,HLPT,ARGLST,%RNG01,%RNG02),<
	.XCREF	%RNG01,%RNG02
	SUPPRESS %RNG01,%RNG02
	$NUMBER	(%RNG01,^D10,HLPT,<$ACTION(STOBTH),ARGLST>)

%RNG01:	$TOKEN	(%RNG02,<:>,<$HELP(<colon to specify a range>),$ALTERNATE(NEXT)>)

%RNG02:	$NUMBER	(NEXT,^D10,,<$ACTION(STOHGH)>)


>	;END DEFINITION OF $RANGE



;DEFINE A MACRO FOR CORRECT PARSING OF THE OPTIONAL /NODE SWITCH

DEFINE	$NODE(NEXT,%NOD01,%NOD02),<
	.XCREF	%NOD01,%NOD02
	SUPPRESS %NOD01,%NOD02

	$SWITCH (%NOD02,%NOD01,<$ALTERNATE(NEXT)>)

%NOD01:	$STAB
	ORNSWI(NODE:,NOD)
	$ETAB

%NOD02:	$NODNM	(NEXT,<node name>,<$FLAGS(CM%PO)>)

>	;END $NODE DEFINITION


SUBTTL	Command Dispatch

INITCM:: $INIT(CMDFDB)
CMDFDB:: $KEYDSP(CMDTAB,<$ACTION(CMDACT##),$ERROR(BADCOM)>)

CMDTAB:	$STAB
TOPS10<	ORNDSP(,\"32,CTZ,CM%INV) >
	ORNDSP(ABOFDB,ABORT,CNC)
	ORNDSP(ALIFDB,ALIGN,ALI)
	ORNDSP(BKSFDB,BACKSPACE,BKS)
	ORNDSP(CANFDB,CANCEL,DEL)
	ORNDSP(CLOFDB,CLOSE,CLO)
	ORNDSP(UNVFDB,CONTINUE,CNT)
IFN	FTDN60,<
	ORNDSP(DEFFDB,DEFINE,DEF)
>;END FTDN60
	ORNDSP(ENAFDB,DISABLE,DIS)
	ORNDSP(DSMFDB,DISMOUNT,DSM) 
	ORNDSP(ENAFDB,ENABLE,ENA)
IFN	NUMAPL,<			;CHECK IS ANY APPLICATION TABLES
	ORNDSP(ENTFDB##,ENTER,ENT)
>;END NUMAPL
	ORNDSP(EXTFDB##,EXIT,EXT)
	ORNDSP(BKSFDB,FORWARDSPACE,FWS)
	ORNDSP(HLPFDB,HELP,HLP)
	ORNDSP(HLDFDB,HOLD,HLD)
	ORNDSP(IDNFDB,IDENTIFY,IDN)
TOPS10<	ORNDSP(LOCFDB,LOCK,LOC)>
	ORNDSP(MODFDB,MODIFY,MOD)
TOPS10<	ORNDSP(MTNFDB,MOUNT,MTN) >
	ORNDSP(NXTFDB,NEXT,NXT)		;[NXT] Operator NEXT command
TOPS20<	ORNDSP(PUSFDB,PUSH,PUS)>
TOPS10<	ORNDSP(RECFDB,RECOGNIZE,REC)>
	ORNDSP(HLDFDB,RELEASE,REL)
	ORNDSP(RPTFDB,REPORT,RPT)
	ORNDSP(REQFDB,REQUEUE,REQ)
	ORNDSP(RSPFDB,RESPOND,RSP)
	ORNDSP(RTEFDB,ROUTE,RTE)
	ORNDSP(SNDFDB,SEND,SND)
	ORNDSP(SETFDB,SET,SET)
	ORNDSP(SHWFDB,SHOW,SHW)
	ORNDSP(SHDFDB,SHUTDOWN,SHD)
	ORNDSP(STAFDB,START,STA)
	ORNDSP(STPFDB,STOP,PAU)
	ORNDSP(SUPFDB,SUPPRESS,SUP)
TOPS20<	ORNDSP(SWIFDB,SWITCH,SWI)>
	ORNDSP(TAKOPR##,TAKE,TAK)
TOPS10<	ORNDSP(ULCFDB,UNLOCK,ULC)>
;	ORNDSP(UNLFDB,UNLOAD,UNL)
	ORNDSP(WAIOPR##,WAIT,WAI)
	$ETAB

BADCOM:	MOVEI	S2,[ASCIZ/Invalid OPR command specified/]
	$RETF				;BAD COMMAND
SUBTTL	Argument Subroutines

;ACTION ROUTINE CALLED ON $UNIT MACRO TO BARF ON NEGATIVE UNIT
;NUMBER ARGUMENTS.
CHKVAL:	SKIPL	CR.RES(S2)	;CHECK THAT NUMBER
	$RETT			;IT'S GOOD
	PUSHJ	P,FIXIT
	MOVEI	S2,[ASCIZ/Negative number improper/]
	$RETF

CHKPOS:	SKIPLE	CR.RES(S2)	;CHECK THE NUMBER
	$RETT			;O.K..RETURN
	PUSHJ	P,FIXIT		;FIXUP COMMAND
	MOVEI	S2,[ASCIZ/Number must be positive/]
	$RETF			;RETURN FALSE

; ACTION ROUTINE TO CHECK PRIORITY RANGES
CHKPRI:	SKIPLE	T1,CR.RES(S2)	;CHECK THAT NUMBER
	CAILE	T1,^D63
	SKIPA
	$RETT			;IT'S GOOD
	PUSHJ	P,FIXIT
	MOVEI	S2,[ASCIZ/Priority not in range/]
	$RETF

;TEMPORARY STORAGE FOR RANGE ARGUMENT
	$DATA	LSTARG,1		;LAST PARSED ARGUMENT ADDRESS
	$GDATA	CMDCOD,1		;COMMAND FUNCTION CODE

STOBTH:	SKIPGE	T1,CR.RES(S2)
	PJRST	CHKVAL		;ABORT COMMAND
	MOVEM	T1,LSTARG
	$RETT

STOHGH:	SKIPGE	T1,CR.RES(S2)
	PJRST	CHKVAL		;ABORT COMMAND
	CAMGE	T1,LSTARG
	SKIPA			;SKIP AND LOAD ERROR
	$RETT
	PUSHJ	P,FIXIT
	MOVEI	S2,[ASCIZ /Improper range specification/]
	$RETF

FIXIT:	HRRZ	T4,CR.FLG(S2)	;GET ADR OF CMDBLK
	MOVE	T1,.CMPTR(T4)	;GET COMMAND POINTER
	MOVE	T2,.CMABP(T4)	;GET BP TO ATOM BUFFER
FIXI.1:	ILDB	T3,T2
	JUMPE	T3,FIXI.2	;DONE.. ALL FIXED UP
	PUSHJ	P,DBP		;DECREMENT THE BP
	AOS	.CMCNT(T4)
	JRST	FIXI.1		;TRY NEXT CHARACTER
FIXI.2:	MOVEM	T1,.CMPTR(T4)	;STORE ADJUSTED BP
	POPJ	P,0

;LOCAL ROUTINE TO DECREMENT BYTE POINTER IN T1
DBP:	SOS	T1
	IBP	T1
	IBP	T1
	IBP	T1
	IBP	T1
	$RETT
SUBTTL	START command tables

STAFDB:	$NOISE (STAF01,<object>)

STAF01:	$KEYDSP(STAF02)

STAF02:	$STAB
	ORNDSP(STAF03,BATCH-STREAM,BAT)
;[LSRSPL]	ORNDSP(STAF04,<CARD-PUNCH>,CDP)
IFN FTFTS,<
	ORNDSP(STAF03,<FAL-STREAM>,FAL)
	ORNDSP(STAF03,<FTS-STREAM>,FTS)
> ;End FTFTS conditional
	ORNDSP(STAF04,<LASER-PRINTER>,CDP)	;[LSRSPL]
	ORNDSP(SHD030,<NODE>,NOD)
	ORNDSP(STAF04,<PAPER-TAPE-PUNCH>,PTP)
;[TTY]	ORNDSP(STAF04,<PLOTTER>,PLT)
	ORNDSP(STAF11,<PLOTTER>,PLT)		;[TTY]
	ORNDSP(STAF11,PRINTER,LPT)
	ORNDSP(STAF04,READER,RDR)
	$ETAB

STAF03:	$SRANGE(CONFRM)

STAF04:	$URANGE	(CONFRM)

STAF11:	$URANGE(STAF12)

STAF12:	$SWITCH	(STAF14,STAF13,<$ALTERNATE(<CONFRM>)>)

STAF13:	$STAB
	ORNSWI	(<DEVICE:>,DEV)
	$ETAB

STAF14:	$DEV(CONFRM,<$HELP(<tape drive name>)>)
SUBTTL	CONTINUE command tables
SUBTTL	SHUTDOWN command tables

COMMENT	\
NOTE: SHOULD IT BECOME DESIRABLE FOR THE SHUTDOWN AND
CONTINUE COMMANDS TO BE NO LONGER SYNTACTICALLY IDENTICAL THEN THE
COMMON USE OF THIS PDB CHAIN DEFINITION IS NO LONGER VALID.
\

SHDFDB:	$NOISE	(SHD010,<scheduling for>)

UNVFDB:	$NOISE (UNVF01,<object>)

UNVF01:	$KEYDSP(UNVF02)

UNVF02:	$STAB
	ORNDSP(UNVF03,BATCH-STREAM,BAT)
;[LSRSPL]	ORNDSP(UNVF04,<CARD-PUNCH>,CDP)
IFN FTFTS,<
	ORNDSP(UNVF03,<FAL-STREAM>,FAL)
	ORNDSP(UNVF03,<FTS-STREAM>,FTS)
> ;End FTFTS conditional
	ORNDSP(UNVF04,<LASER-PRINTER>,CDP)	;[LSRSPL]
	ORNDSP(UNVF04,<PAPER-TAPE-PUNCH>,PTP)
	ORNDSP(UNVF04,<PLOTTER>,PLT)
	ORNDSP(UNVF04,PRINTER,LPT)
	ORNDSP(UNVF04,READER,RDR)
	$ETAB

UNVF03:	$SRANGE(CONFRM)

UNVF04:	$URANGE(CONFRM)

CONFRM:	$CRLF

SHD010:	$KEYDSP(SHD020)

SHD020:	$STAB
	ORNDSP(UNVF03,BATCH-STREAM,BAT)
;[LSRSPL]	ORNDSP(UNVF04,<CARD-PUNCH>,CDP)
	ORNDSP(UNVF04,<LASER-PRINTER>,CDP)	;[LSRSPL]
	ORNDSP(SHD030,NODE,NOD)
	ORNDSP(UNVF04,<PAPER-TAPE-PUNCH>,PTP)
	ORNDSP(UNVF04,<PLOTTER>,PLT)
	ORNDSP(UNVF04,PRINTER,LPT)
	ORNDSP(UNVF04,READER,RDR)
	$ETAB

SHD030:	$NODNM(CONFRM,<node name>,<$FLAGS(CM%PO)>)

SUBTTL	STOP command tables

STPFDB:	$NOISE (STPF01,<object>)

STPF01:	$KEYDSP(STPF02)

STPF02:	$STAB
	ORNDSP(STPS01,BATCH-STREAM,BAT)
;[LSRSPL]	ORNDSP(STPU01,<CARD-PUNCH>,CDP)
IFN FTFTS,<
	ORNDSP(STPU01,<FTS-STREAM>,FTS)
> ;End FTFTS conditional
	ORNDSP(STPU01,<LASER-PRINTER>,CDP)	;[LSRSPL]
	ORNDSP(STPU01,<PAPER-TAPE-PUNCH>,PTP)
	ORNDSP(STPU01,<PLOTTER>,PLT)
	ORNDSP(STPU01,PRINTER,LPT)
	ORNDSP(STPU01,READER,RDR)
	$ETAB

STPS01:	$NOISE	(STPN01,<stream number>)

STPU01:	$NOISE	(STPN01,<unit number>)

STPN01:	$NUMBER	(STPN02,^D10,<number or range (n:m)(/NODE:)>,<$ACTION(STOBTH)>)
STPN02:	$TOKEN	(STPN03,<:>,<$HELP(<colon to specify a range>),$DEFAULT(IMMEDIATELY),$ALTERNATE(STPN04)>)
STPN03:	$NUMBER	(STPN04,^D10,,<$ACTION(STOHGH)>)
STPN04:	$SWITCH (STPN06,STPN05,<$ALTERNATE(STP010)>)
STPN05:	$STAB
	ORNSWI(NODE:,NOD)
	$ETAB
STPN06:	$NODNM	(STP010,<node name>,<$FLAGS(CM%PO)>)


STP010:	$KEYDSP	(STP020,<$DEFAULT(<IMMEDIATELY>),$ALTERNATE(CONFRM)>)

STP020:	$STAB
	ORNDSP(STP030,<AFTER>,AFT)
	ORNDSP(CONFRM,<IMMEDIATELY>,IMM)
	$ETAB

STP030:	$KEY(CONFRM,STP040)

STP040:	$STAB
	ORNKEY(<CURRENT-REQUEST>,ACR)
	ORNKEY(<EVERY-REQUEST>,AER)
	$ETAB


SUBTTL	ABORT command tables


ABOFDB:	$NOISE	(ABO010,<current job on>)

ABO010:	$KEYDSP	(ABO020)
ABO020:	$STAB
	ORNDSP	(ABO060,<BATCH-STREAM>,BAT)
;[LSRSPL]	ORNDSP	(ABO030,<CARD-PUNCH>,CDP)
IFN FTFTS,<
	ORNDSP	(ABO060,<FAL-STREAM>,FAL)
	ORNDSP	(ABO060,<FTS-STREAM>,FTS)
> ;End FTFTS conditional
	ORNDSP	(ABO030,<LASER-PRINTER>,CDP)	;[LSRSPL]
	ORNDSP	(ABO030,<PAPER-TAPE-PUNCH>,PTP)
	ORNDSP	(ABO030,<PLOTTER>,PLT)
	ORNDSP	(ABO030,<PRINTER>,LPT)
	ORNDSP	(ABO090,<READER>,RDR)
	$ETAB


; Output device tables
;
ABO030:	$UNIT	(ABO040)
ABO040:	$SWITCH	(ABO100,ABO050,<$ALTERNATE(ABO100)>)
ABO050:	$STAB
	ORNSWI	(<PURGE>,PUR)
	$ETAB


; Batch tables
;
ABO060:	$STREAM	(ABO070)
ABO070:	$SWITCH	(ABO100,ABO080,<$ALTERNATE(ABO100),$DEFAULT(</ERROR-PROCESSING>)>)
ABO080:	$STAB
	ORNSWI	(<ERROR-PROCESSING>,ERR)
	ORNSWI	(<NOERROR-PROCESSING>,NER)
	ORNSWI	(<PURGE>,PUR)
	$ETAB


; Card reader tables
;
ABO090:	$UNIT	(ABO100)


ABO100:	$EXPL	(CONFRM,<$ALTER(CONFRM)>)
SUBTTL	HOLD command tables
SUBTTL	RELEASE command tables

HLDFDB:	$KEY	(HLD030,HLD010)

HLD010:	$STAB
	ORNKEY	(<BATCH-JOBS>,BAT)
;[LSRSPL]	ORNKEY	(<CARD-PUNCH-JOBS>,CDP)
IFN FTFTS,<
	ORNKEY	(<FTS-JOBS>,FTS)
> ;End FTFTS conditional
	ORNKEY	(<LASER-PRINTER-JOBS>,CDP)	;[LSRSPL]
	ORNKEY	(<PAPER-TAPE-PUNCH-JOBS>,PTP)
	ORNKEY	(<PLOTTER-JOBS>,PLT)
	ORNKEY	(<PRINTER-JOBS>,LPT)
	$ETAB

HLD030:	$NUMBER(CONFRM,^D10,<request-id>,<$ACTION(CHKPOS),$ALTERNATE(HLD035)>)

HLD035:	$USER(CONFRM,<$ALTERNATE(HLD040)>)

HLD040:	$TOKEN(HLD050,<*>,<$HELP(<* to specify all requests>)>)

HLD050:	$NODE(CONFRM)
SUBTTL	DEFINE command tables

IFN	FTDN60,<
;[TTY]
;DEFFDB:	$KEY(DEF020,DEF010,<$DEFAULT(<NODE>)>)
;
;DEF010:	$STAB
;	ORNKEY(<NODE>,NOD)
;	$ETAB
DEFFDB:	$KEYDSP(DEF010)			;[TTY]

DEF010:	$STAB				;[TTY]
	ORNDSP(DEF020,<NODE>,NOD)	;[TTY]
	ORNDSP(DEF300,<TTY-NODE>,TTN)	;[TTY]
	$ETAB

DEF020:	$NOISE(DEF030,<name>)

DEF030:	$NODNM(DEF040,<node name for IBM emulation/termination>,<$FLAGS(CM%PO)>)

DEF040:	$NOISE(DEF050,<type>)

DEF050:	$KEY(DEF063,DEF060,<$DEFAULT(<HASP>)>)

DEF060:	$STAB
	ORNKEY(<2780>,278)
	ORNKEY(<3780>,378)
	ORNKEY(<HASP>,HSP)
	$ETAB

DEF063:	$SWITCH	(DEF070,DEF065,<$ALTERNATE(DEF080),$DEFAULT(</SIGNON-REQUIRED>)>)
DEF065:	$STAB
	ORNSWI(<NO-SIGNON-REQUIRED>,NSN)
	ORNSWI(<SIGNON-REQUIRED>,SON)
	$ETAB

DEF070:	$NOISE(DEF080,<mode>)

DEF080:	$KEY(DEF100,DEF090,<$DEFAULT(<TERMINATION>)>)

DEF090:	$STAB
	ORNKEY(EMULATION,EMU)
	ORNKEY(TERMINATION,TRM)
	$ETAB

DEF100:	$NOISE(DEF110,<port>)

DEF110:	$NUMBER(DEF120,^D8,<port number for DN60>)

DEF120:	$NOISE(DEF130,<line>)

DEF130:	$NUMBER(CONFRM,^D8,<line number for DN60>)

DEF300:	$NOISE(DEF303,<NAME>)
DEF303:	$NodNm(DEF305,<NODE NAME FOR TTY PRINTER>,<$FLAGS(CM%PO)>)
DEF305:	$Noise(DEF310,<LINE>)
DEF310:	$Number(DEF320,^d8,<OCTAL TTY LINE NUMBER>)
DEF320:	$Noise(DEF330,<TERMINAL TYPE>)
DEF330:	$KEY(DEF350,DEF340)
DEF340:	$STAB
	ORNKEY(<LA120>,A12)
	ORNKEY(<LA180>,A18)
	ORNKEY(<LA36>,A36)
	ORNKEY(<LS120>,S12)
	$ETAB
DEF350:	$Noise(DEF360,<Speed>,<$HELP(<BAUD RATE>)>)
DEF360:	$KEY(CONFRM,DEF370)
DEF370:	$STAB
	ORNKEY(<1200>,120)
	ORNKEY(<1800>,180)
	ORNKEY(<2400>,240)
	ORNKEY(<300>,S30)
	ORNKEY(<4800>,480)
	ORNKEY(<9600>,960)
	ORNKEY(<AS-IS>,ASS)
	$ETAB
>;END FTDN60
SUBTTL	CANCEL command tables

CANFDB:	$KEYDSP(CAN010)

CAN010:	$STAB
	ORNDSP	(CAN020,<BATCH-REQUEST>,BAT)
;[LSRSPL]	ORNDSP	(CAN020,<CARD-PUNCH-REQUEST>,CDP)
IFN FTFTS,<
	ORNDSP	(CAN020,<FTS-REQUEST>,FTS)
> ;End FTFTS conditional
	ORNDSP	(CAN020,<LASER-PRINTER-REQUEST>,CDP)	;[LSRSPL]
	ORNDSP	(CAN040,<MOUNT-REQUEST>,MNT)
	ORNDSP	(CAN020,<PAPER-TAPE-PUNCH-REQUEST>,PTP)
	ORNDSP	(CAN020,<PLOTTER-REQUEST>,PLT)
	ORNDSP	(CAN020,<PRINTER-REQUEST>,LPT)
	$ETAB

CAN020:	$NUMBER(CONFRM,^D10,<request number to cancel in queue or if active>,<$ACTION(CHKPOS),$ALTERNATE(CAN030)>)

TOPS20 <
CAN030:	$USER(CONFRM,<$HELP(<user name whose jobs will be canceled>),$ALTERNATE(HLD040)>)
>;END TOPS20

TOPS10 <
CAN030:	$USER(CONFRM,<$HELP(<[project,programmer] whose jobs will be canceled>),$ALTERNATE(HLD040)>)
>;END TOPS10

CAN040:	$DEV(CAN060,<$HELP(<structure name to cancel all mount requests for>),$FLAGS(CM%PO),$ALTERNATE(CAN050)>)

TOPS10<
CAN050:	$NUMBER(CAN060,^D10,<mount request number to cancel>,<$ACTION(CHKPOS),$ALTERNATE(CAN055)>)
CAN055:	$TOKEN(CAN060,<*>,<$HELP(<* to specify all pending requests>)>)
>
TOPS20<
CAN050:	$NUMBER(CAN060,^D10,<mount request number to cancel>,<$ACTION(CHKPOS)>)
>

CAN060:	$EXPL(CONFRM,<$ALTERNATE(CONFRM)>)

SUBTTL	MODIFY command tables

MODFDB:
	$KEYDSP	(MOD010)

MOD010:	$STAB
TOPS10<	ORNDSP	(MOD300,<ACTIVE-SWAPPING-LIST>,ASL) >
	ORNDSP	(MOD020,<BATCH-REQUEST>,BAT)
;[LSRSPL]	ORNDSP	(MOD020,<CARD-PUNCH-REQUEST>,CDP)
TOPS10<	ORNDSP	(MOD200,<CRASH-DUMP-LIST>,CDL) >
IFN FTFTS,<
	ORNDSP	(MOD020,<FTS-REQUEST>,FTS)
> ;End FTFTS conditional
	ORNDSP	(MOD020,<LASER-PRINTER-REQUEST>,CDP)	;[LSRSPL]
	ORNDSP	(MOD020,<PAPER-TAPE-PUNCH-REQUEST>,PTP)
	ORNDSP	(MOD020,<PLOTTER-REQUEST>,PLT)
	ORNDSP	(MOD020,<PRINTER-REQUEST>,LPT)
TOPS10<	ORNDSP	(MOD200,<SYSTEM-SEARCH-LIST>,SSL) >
	$ETAB

MOD020:	$NUMBER(MOD030,^D10,<request number to modify in queue>,<$ACTION(CHKPOS),$ALTERNATE(MOD070)>)

MOD030:	$KEYDSP(MOD040)

MOD040:	$STAB
	ORNDSP(MOD050,<PRIORITY>,PRI)
	$ETAB

MOD050:	$NOISE(MOD060,<to be>)

MOD060:	$NUMBER(CONFRM,^D10,<priority for request in range 1 to 63>,<$ACTION(CHKPRI)>)

MOD070:	$USER(MOD030,<$ALTERNATE(MOD080)>)
MOD080:	$TOKEN(MOD090,<*>,<$HELP(<* to specify all requests>)>)

MOD090:	$NODE(MOD030)

TOPS10<

;More of the MODIFY command tables

;Here if MODIFYing lists pertaining to file structures
MOD200:	$NOISE	(MOD210,<to>)

MOD210:	$KEY	(MOD230,MOD220)

MOD220:	$STAB
	ORNKEY	(EXCLUDE,EXC)
	ORNKEY	(INCLUDE,INC)
	$ETAB

MOD230:	$DEV	(CONFRM,$HELP(<file structure name>))

;Here if MODIFYing lists pertaining to disk drives (units)
MOD300:	$NOISE	(MOD310,<to>)

MOD310:	$KEY	(MOD320,MOD220)

MOD320:	$DEV	(CONFRM,<$HELP(<disk unit name>),$FLAGS(CM%PO)>)

>;END TOPS10
SUBTTL	SHOW command tables


SHWFDB:	$KEYDSP(SHW010)

SHW010:	$STAB
TOPS10<	ORNDSP(ALC000,ALLOCATION,ALC) >
	ORNDSP(SHW110,<CONTROL-FILE>,CTL)
	ORNDSP(SHW020,MESSAGES,MSG)
	ORNDSP(SHW030,OPERATORS,OPR)
	ORNDSP(SHW210,PARAMETERS,PRM)
	ORNDSP(SHW400,QUEUES,QUE)
	ORNDSP(CONFRM,<ROUTE-TABLE>,RTE)
TOPS20<	ORNDSP(CONFRM,SCHEDULER,SCH)>
	ORNDSP(STS000,STATUS,STS)
TOPS10<	ORNDSP(SYS000,<SYSTEM-LISTS>,SLS) >
	ORNDSP(SHW060,TIME,DAY)	;DAYTIME CHANGES TO TIME
	$ETAB

SHW020:	$NUMBER(CONFRM,^D10,<message number>,<$ALTER(SHW030),$ACTION(CHKVAL)>)

SHW030:	$NODE(CONFRM)

SHW060:	$CRLF(<$ACTION(SHWDAY##)>)

SHW110:	$NOISE	(SHW120,<for>)
SHW120:	$KEY (SHW140,SHW130,<$DEFAULT(<BATCH-STREAM>)>)

SHW130:	$STAB
	ORNKEY(<BATCH-STREAM>,BAT)
	$ETAB

SHW140:	$NOISE	(SHW145,<stream number>)
SHW145:	$NUMBER	(SHW150,^D10,<stream number>,$ACTION(CHKVAL))

SHW150:	$SWITCHES(,SHW160,<$ALTER(CONFRM)>)
SHW160:	$STAB
	ORNSDP	(SHW170,<LINES:>,LNS)
	$ETAB
SHW170:	$NUMBER	(CONFRM,^D10,<number of lines>,$ACTION(CHKVAL))

SHW210:	$KEYDSP(SHW220,<$ALTER(SHW320)>)

SHW220:	$STAB
	ORNDSP	(SHW230,<BATCH-STREAM>,BAT)
;[LSRSPL]	ORNDSP	(SHW230,<CARD-PUNCH>,CDP)
IFN FTFTS,<
	ORNDSP	(SHW230,<FAL-STREAM>,FAL)
	ORNDSP	(SHW230,<FTS-STREAM>,FTS)
> ;End FTFTS conditional
	ORNDSP	(SHW230,<LASER-PRINTER>,CDP)	;[LSRSPL]
	ORNDSP	(SHWNOD,<NETWORK-NODE>,NOD)
	ORNDSP	(SHW230,<PAPER-TAPE-PUNCH>,PTP)
	ORNDSP	(SHW230,<PLOTTER>,PLT)
	ORNDSP	(SHW230,<PRINTER>,LPT)
	$ETAB


SHW230:	$SWITCH(SHW260,SHW250,<$ALTERNATE(SHW270)>)

SHW250:	$STAB
	ORNSWI(<NODE:>,NOD)
	$ETAB

SHW260:	$NODNM(CONFRM,<node name>,<$FLAGS(CM%PO)>)

SHW270:	$RANGE(SHW280,<number or range (n:m)(/NODE:)>,<$ALTERNATE(CONFRM)>)

SHW280:	$NODE(CONFRM)

SHW320:	$SWITCH(SHW340,SHW330,<$ALTERNATE(CONFRM)>)

SHW330:	$STAB
	ORNSWI(<NODE:>,NOD)
	$ETAB

SHW340:	$NODNM(CONFRM,<node name>,<$FLAGS(CM%PO)>)

;  Continued on next page
;Continued from previous page

;  SHOW QUEUE command

SHW400:	$KEYDSP(SHW420,<$DEFAULT(ALL),$ALTER(SHW430)>);NODE OR CONFIRM

SHW420:	$STAB
	ORNDSP	(SHW430,<ALL-JOBS>,ALL)
	ORNDSP	(SHW430,<BATCH-JOBS>,BAT)
;[LSRSPL]	ORNDSP	(SHW430,<CARD-PUNCH-JOBS>,CDP)
IFN FTFTS,<
	ORNDSP	(SHW430,<FTS-REQUEST>,FTS)
> ;End FTFTS conditional
	ORNDSP	(SHW430,<LASER-PRINTER-JOBS>,CDP)	;[LSRSPL]
	ORNDSP	(SHW470,<MOUNT-REQUESTS>,MNT)
	ORNDSP	(SHW430,<PAPER-TAPE-PUNCH-JOBS>,PTP)
	ORNDSP	(SHW430,<PLOTTER-JOBS>,PLT)
	ORNDSP	(SHW430,<PRINTER-JOBS>,LPT)
TOPS20<	ORNDSP	(SHW470,<RETRIEVAL-REQUESTS>,RET)>
	$ETAB

SHW430:	$SWITCH	(,SHW440,<$ALTER(CONFRM),$ACTION(SHRSWT)>) ;Switch or confirm

SHW440:	$STAB
	ORNSDP	(NEXT,<ALL>,ALL)
	ORNSDP	(SHW450,<NODE:>,NOD)
	ORNSDP	(NEXT,<SHORT>,SHT)
	ORNSDP	(SHW460,<USER:>,USR)
	$ETAB

SHW450:	$NODNM	(NEXT,<node name>,<$FLAGS(CM%PO)>)

SHW460:	$USER	(NEXT)

SHW470:	$SWITCH	(,SHW480,<$ALTER(CONFRM),$ACTION(SHRSWT)>) ;Switch or confirm

SHW480:	$STAB					;  But no node allowed!
	ORNSDP	(NEXT,<ALL>,ALL)
	ORNSDP	(NEXT,<SHORT>,SHT)
	ORNSDP	(SHW490,<USER:>,USR)
	$ETAB

SHW490:	$USER	(NEXT)
SUBTTL	SHOW STATUS command tables

STS000:	$KEYDSP(STS010,<$ALTER(STS100)>)

STS010:	$STAB
	ORNDSP	(STS020,<BATCH-STREAM>,BAT)
;[LSRSPL]	ORNDSP	(STS020,<CARD-PUNCH>,CDP)
	ORNDSP	(STS190,<DISK-DRIVE>,DSK)
IFN FTFTS,<
	ORNDSP	(STS020,<FAL-STEAM>,FAL)
	ORNDSP	(STS020,<FTS-STREAM>,FTS)
> ;End FTFTS conditional
	ORNDSP	(STS020,<LASER-PRINTER>,CDP)	;[LSRSPL]
	ORNDSP	(SHWNOD,<NETWORK-NODE>,NOD)
	ORNDSP	(STS020,<PAPER-TAPE-PUNCH>,PTP)
	ORNDSP	(STS020,<PLOTTER>,PLT)
	ORNDSP	(STS020,<PRINTER>,LPT)
	ORNDSP	(STS020,<READER>,RDR)
TOPS10<	ORNDSP	(STS250,<STRUCTURE>,STR)>
	ORNDSP	(STS160,<TAPE-DRIVE>,TAP)
	$ETAB

STS020:	$SWITCH(STS040,STS030,<$ALTERNATE(STS050)>)

STS030:	$STAB
	ORNSWI(<NODE:>,NOD)
	$ETAB

STS040:	$NODNM(STS130,<node name>,<$FLAGS(CM%PO)>)

STS050:	$RANGE(STS060,<number or range (n:m)(/NODE:)>,<$ALTERNATE(STS130)>)

STS060:	$NODE(STS130)

STS100:	$SWITCH(STS120,STS110,<$ALTERNATE(STS130)>)

STS110:	$STAB
	ORNSWI(<NODE:>,NOD)
	$ETAB

STS120:	$NODNM(STS130,<node name>,<$FLAGS(CM%PO)>)
STS130:	$SWITCH(CONFRM,STS140,<$ALTERNATE(CONFRM)>)

STS140:	$STAB
	ORNSWI(SHORT,SHT)
	$ETAB

STS150:	$DEV(STS170,<$HELP(<tape drive name>),$ALTERNATE(STS170)>)

STS160:	$CRLF(<$ALTERNATE(STS150)>)

STS170:	$SWITCH(CONFRM,STS180,<$ALTERNATE(CONFRM)>)

STS180:	$STAB
	ORNSWI(ALL,ALL)
TOPS20<	ORNSWI(CHARACTERISTICS,CHR) >	;TOPS20 ONLY
	ORNSWI(FREE,FRE)
	$ETAB

STS190:	$SWITCH(CONFRM,STS200,<$ALTERNATE(STS210)>)

STS200:	$STAB
	ORNSWI(ALL,ALL)
	ORNSWI(FREE,AVA)
	ORNSWI(MOUNTED,MNT)
	$ETAB

TOPS20<
STS210:	$CRLF
>;END TOPS20
TOPS10<
STS210:	$CRLF(<$ALTERNATE(STS220)>)

STS220:	$DEV(CONFRM,<$HELP(<disk drive name>),$FLAGS(CM%PO)>)
>;END TOPS10
TOPS10<
STS250:	$DEV(STS260,<$HELP(<structure name>),$ALTERNATE(STS260),$FLAGS(CM%PO)>)
STS260:	$SWITCH(CONFRM,STS270,<$ALTERNATE(CONFRM)>)
STS270:	$STAB
	ORNSWI(USERS,USR)
	$ETAB
>;END TOPS10
SUBTTL	SHOW SYSTEM-LIST command tables

TOPS10<
SYS000=CONFRM				;TO DELETE THE 'UNNECCESSARY CODE'
REPEAT 0,<
SYS000:	$CRLF	($ALTERNATE(SYS010))

SYS010:	$KEY	(CONFRM,SYS020)

SYS020:	$STAB
	ORNKEY	(<ACTIVE-SWAPPING-LIST>,ASL)
	ORNKEY	(<CRASH-DUMP-LIST>,CDL)
	ORNKEY	(<SYSTEM-SEARCH-LIST>,SSL)
	$ETAB
>;END REPEAT 0
>;END TOPS10
SUBTTL	LOCK/UNLOCK command tables

TOPS10 <

	;LOCK COMMAND

LOCFDB:	$NOISE(LOC010,<structure>)

LOC010:	$DEV(LOC015,<$FLAGS(CM%PO),$HELP(<structure name>)>)

LOC015:	$NOISE(LOC020,<at>)

LOC020:	$FTAD(LOC030,<$ALTERNATE(LOC030)>)

LOC030:	$SWITCH (CONFRM,LOC040,<$ALTERNATE(CONFRM)>)
LOC040:	$STAB
	ORNSWI(NOUNLOAD,NUL)
	$ETAB

	;UNLOCK COMMAND

ULCFDB:	$NOISE(ULC010,<structure>)

ULC010:	$DEV(ULC015,<$FLAGS(CM%PO),$HELP(<structure name>)>)

ULC015:	$NOISE(ULC020,<at>)

ULC020:	$FTAD(CONFRM,<$ALTERNATE(CONFRM)>)


>;END TOPS10
SUBTTL	SHWNOD	SHOW STATUS/PARAMETERS FOR NODE

SHWNOD:	$CRLF	(<$ALTERNATE(SHWN01)>)

SHWN01:	$NODNM(CONFRM,<node name>,<$FLAGS(CM%PO)>)

SUBTTL	RESPOND command tables

RSPFDB:	$NOISE	(RSP001,<to message number>)

RSP001:	$NUMBER	(RSP005,^D10,<message number>,$ACTION(CHKVAL))

RSP005:	$CRLF	(<$ALTER(RSP010),$ACTION(TXTLIN##),$HELP(<confirm for multiple line response>)>)

RSP010:	$CTEXT	(CONFRM,<single line response>)
SUBTTL	REQUEUE command tables


REQFDB:	$NOISE	(REQ010,<current job on>)

REQ010:	$KEYDSP	(REQ020)
REQ020:	$STAB
	ORNDSP	(REQ030,<BATCH-STREAM>,BAT)
;[LSRSPL]	ORNDSP	(REQ040,<CARD-PUNCH>,CDP)
IFN FTFTS,<
	ORNDSP	(REQ030,<FTS-STREAM>,FTS)
> ;End FTFTS conditional
	ORNDSP	(REQ040,<LASER-PRINTER>,CDP)	;[LSRSPL]
	ORNDSP	(REQ040,<PAPER-TAPE-PUNCH>,PTP)
	ORNDSP	(REQ040,<PLOTTER>,PLT)
	ORNDSP	(REQ040,<PRINTER>,LPT)
	$ETAB


; Batch tables
;
REQ030:	$STREAM	(REQ100)


; Output device tables
;
REQ040:	$UNIT	(REQ050)
REQ050:	$KEYDSP	(REQ060,<$DEFAULT(CURRENT-POSITION),$ALTER(REQ100)>)
REQ060:	$STAB
	ORNDSP	(REQ070,<BEGINNING-OF>,BEG)
	ORNDSP	(REQ100,<CURRENT-POSITION>,CUR)
	$ETAB
REQ070:	$KEY	(REQ100,REQ080)
REQ080:	$STAB
	ORNKEY	(<COPY>,CPY)
	ORNKEY	(<FILE>,FIL)
	ORNKEY	(<JOB>,JOB)
	$ETAB

REQ100:	$EXPL	(CONFRM,<$ALTER(CONFRM)>)
SUBTTL	BACKSPACE command tables
SUBTTL	FORWARDSPACE command tables

BKSFDB:	$KEY (BKS002,BKS001,<$DEFAULT(<PRINTER>)>)

BKS001:	$STAB
	ORNKEY (<PRINTER>,LPT)
	$ETAB

BKS002:	$UNIT(BKS003)

BKS003:	$SWITCH(,BKS004)

BKS004:	$STAB
	ORNSDP(BKS005,<COPIES:>,CPY)
	ORNSDP(CONFRM,<FILE>,FIL)
	ORNSDP(BKS007,<PAGES:>,PAG)
	$ETAB

BKS005:	$NUMBER	(CONFRM,^D10,<number of copies>,$ACTION(CHKVAL))
REPEAT 0,<
BKS006:	$NUMBER	(CONFRM,^D10,<number of files>,<$ACTION(CHKFIL),$DEFAULT(<1>)>)
>
BKS007:	$NUMBER	(CONFRM,^D10,<number of pages>,$ACTION(CHKVAL))

REPEAT 0,<
CHKFIL:	SKIPG	T1,CR.RES(S2)	;CHECK THAT NUMBER
	JRST	CHKF.1		;GENERTE AN ERROR
	CAIN	T1,1		;WAS IT A 1
	$RETT			;O.K..RETURN
CHKF.1:	PUSHJ	P,FIXIT
	MOVEI	S2,[ASCIZ/only one file allowed/]
	$RETF
>
SUBTTL	ALIGN command table

ALIFDB:	$NOISE (ALI001,<forms on>)

ALI001:	$KEY (ALI003,ALI002,<$DEFAULT(<PRINTER>)>)

ALI002:	$STAB
	ORNKEY (<PRINTER>,LPT)
	$ETAB

ALI003:	$UNIT(ALI010)

ALI004:	$IFILE	(ALI005,<alignment file>,<$ALTER(ALI005)>)

ALI005:	$SWITCH(,ALI006,<$ALTER(CONFRM),$ACTION(SHRSWT)>)

ALI006:	$STAB
	ORNSDP(ALI007,<PAUSE:>,PAU)
	ORNSDP(ALI008,<REPEAT-COUNT:>,RPT)
	$ETAB

ALI007:	$NUMBER (NEXT,^D10,<seconds to pause>,$ACTION(CHKVAL))

ALI008:	$NUMBER (NEXT,^D10,<times to print>,$ACTION(CHKVAL))

ALI009:	$STAB
	ORNSWI(STOP,STP)
	$ETAB

ALI010:	$SWITCH(CONFRM,ALI009,<$ALTER(ALI004)>)
SUBTTL	SUPPRESS command tables

SUPFDB:	$NOISE (SUP001,<carriage control on>)

SUP001:	$KEY (SUP010,SUP005,<$DEFAULT(<PRINTER>)>)


SUP005:	$STAB
	ORNKEY (<PRINTER>,LPT)
	$ETAB

SUP010:	$UNIT(SUP015)

SUP015:	$SWITCH(CONFRM,SUP020,<$DEFAULT(</JOB>),$ALTER(CONFRM)>)

SUP020:	$STAB
	ORNSWI(FILE,FIL)
	ORNSWI(JOB,JOB)
	ORNSWI(STOP,STP)
	$ETAB
SUBTTL	ROUTE command tables

RTEFDB:	$NOISE	(RTEF05,device)

RTEF05:	$KEYDSP(RTEF10)

RTEF10:	$STAB
	ORNDSP(RTEF50,<ALL-DEVICES>,ALL)
;[LSRSPL]	ORNDSP(RTEF15,<CARD-PUNCH>,CDP)
	ORNDSP(RTEF15,<LASER-PRINTER>,CDP)	;[LSRSPL]
	ORNDSP(RTEF15,<PAPER-TAPE-PUNCH>,PTP)
	ORNDSP(RTEF15,<PLOTTER>,PLT)
	ORNDSP(RTEF15,<PRINTER>,LPT)
	$ETAB

RTEF15:	$NOISE	(RTEF20,<unit number>)
RTEF20:	$NUMBER	(RTEF35,^D10,<source device unit number>,$ALTERN(RTEF25))
RTEF25:	$KEYDSP	(RTEF30)
RTEF30:	$STAB
	ORNDSP	(RTEF35,<ALL-UNITS>,ALL)
	$ETAB

;To explain the following magical line...
;The default '(' is to allow an ESC to go to the next field and display noise.
;The ERRPDB is used to only get to the next field on switch error or ESC.
;The alternate is to permit entering the destination or crlf
RTEF35:	$SWITCH	(RTEF39,RTEF36,<$DEFAULT(<(>),$ERRPDB(RTEF40),$ALTER(RTEF45)>)
RTEF36:	$STAB
	ORNSWI(NODE:,NOD)
	$ETAB
RTEF39:	$NODNM	(RTEF40,<node name>,<$FLAGS(CM%PO)>)

RTEF40:	$NOISE	(RTEF45,<to unit number>)
RTEF45:	$NUMBER	(RTEF48,^D10,<destination unit number>,<$ALTERNATE(RTEF46)>)
RTEF46:	$KEYDSP	(RTEF47,<$ALTERNATE(RTEF80)>)
RTEF47:	$STAB
	ORNDSP	(RTEF48,<ALL-UNITS>,ALL)
	$ETAB
RTEF48:	$NODE	(CONFRM)

;For parsing all devices

RTEF50:	$NOISE	(RTEF55,<on node>)
RTEF55:	$KEYDSP	(RTEF60,<$HELP(<ALL-NODES>),$ALTERNATE(RTEF65)>)
RTEF60:	$STAB
	ORNDSP	(RTEF70,<ALL-NODES>,ALL)
	$ETAB

RTEF65:	$NODNM	(RTEF70,<source node name>,<$FLAGS(CM%PO)>)

RTEF70:	$NOISE	(RTEF75,<to node>)
RTEF75:	$NODNM	(CONFRM,,<$ALTERNATE(RTEF80),$FLAGS(CM%PO)>)

RTEF80:	$CRLF	($HELP(<confirm to delete routing>))
SUBTTL	SEND command tables

SNDFDB:	$NOISE	(SND001,<to>)

SND001:	$KEYDSP	(SND005)

SND005:	$STAB
	ORNDSP(SND040,<ALL>,ALL)
	ORNDSP(SND015,<BATCH-STREAM>,BAT)
	ORNDSP(SND010,<JOB>,JOB)
	ORNDSP(SND025,<OPERATOR>,OPR)
	ORNDSP(SND020,<TERMINAL>,TRM)
	$ETAB

SND010:	$NUMBER(SND030,^D10,<job number>,$ACTION(CHKVAL))
SND015:	$STNUM(SND025)
SND020:	$NUMBER(SND030,^D8,<terminal number>,$ACTION(CHKVAL))
SND025:	$NODE(SND030)

SND030:	$CRLF	(<$ALTER(SND035),$ACTION(TXTLIN##),$HELP(<confirm for multiple line response>)>)

SND035:	$CTEXT	(CONFRM,<single line response>)
SND040:	$NODE(SND035)
SUBTTL	SET command tables

SETFDB:	$KEYDSP(SET010)

SET010:	$STAB
	ORNDSP(SET170,BATCH-STREAM,BAT)
;[LSRSPL]	ORNDSP(SET490,<CARD-PUNCH>,CDP)
TOPS20<	ORNDSP(SET700,<DISK-DRIVE>,DSK)>
	ORNDSP(SET070,JOB,JOB)
	ORNDSP(SET490,<LASER-PRINTER>,CDP)	;[LSRSPL]
IFN	FTDN60,<
	ORNDSP(SETNOD,<NODE>,NOD)
>;END FTDN60
TOPS20<	ORNDSP(SET800,<ONLINE>,ONL)>
	ORNDSP(SET430,<PAPER-TAPE-PUNCH>,PTP)
	ORNDSP(SET370,PLOTTER,PLT)
	ORNDSP(SET200,PRINTER,LPT)
TOPS20<	ORNDSP(SETSCH,<SCHEDULER>,SCH)>
TOPS20<	ORNDSP(SET600,<STRUCTURE>,STR)>
	ORNDSP(SET630,<TAPE-DRIVE>,TAP)
	ORNDSP(SET020,TERMINAL,TRM)
TOPS10<	ORNDSP(SET900,USAGE,USG)>
	$ETAB

SET020:	$KEYDSP(SET030,<$ACTION(SETRTN##)>)

SET030:	$STAB

TOPS10<	ORNDSP(SET350,KEYPAD,KPD)
	ORNDSP(SET350,NOKEYPAD,NKP)>
	ORNDSP(SET040,<TYPE>,TYP)
	$ETAB

SET040:	$NOISE (SET050,<to be>)
SET050:	$KEY(SET350,SET060,<$ACTION(SETRTN##)>)

SET060:	$STAB
DEFINE X(PARNAM,SIXNAM,SUF,EOLSEQ),<
	KEYTAB(.TT'SUF,<PARNAM>)
>;END DEFINE X
	TRMTYP				;Generate the options
	$ETAB

SET070:	$NOISE(SET080,<job number>)
SET080:	$NUMBER(SET090,^D10,<job number>,$ACTION(CHKVAL))

SET090:	$KEYDSP(SET100)

SET100:	$STAB
	ORNDSP(CONFRM,<NOOPR-INTERVENTION>,NOI)
	ORNDSP(CONFRM,<OPR-INTERVENTION>,OIA)
TOPS20<	ORNDSP(SET110,SCHEDULER-CLASS,CLS)>
	$ETAB

TOPS20 <
SET110:	$NOISE(SET120,<to be>)

SET120:	$NUMBER(CONFRM,^D10,<scheduler class to put the job in>)

>;END TOPS20

SET170:	$SRANGE(SET180)
SET180:	$KEYDSP(SET250)

SET200:	$URANGE(SET210)
SET210:	$KEYDSP(SET300)


SET250:	$STAB
	ORNDSP(SET295,ATTRIBUTE,ATR)
TOPS10<	ORNDSP(SET290,<MEMORY-LIMITS>,MEM)>
	ORNDSP(CONFRM,NOOPR-INTERVENTION,NOI)
	ORNDSP(CONFRM,OPR-INTERVENTION,OIA)
	ORNDSP(SET260,PRIORITY-LIMITS,PRL)
	ORNDSP(SET270,TIME-LIMITS,TIM)
	$ETAB

SET260:	$RANGE(CONFRM,<maximum priority limit or a range (1-63)>)
SET270:	$RANGE(CONFRM,<maximum time limits in minutes or a range>)
SET280:	$NUMBER(CONFRM,^D10,<line number>,$ACTION(CHKVAL))
;GET MEMORY LIMITS

TOPS10 <
SET290:	$RANGE(CONFRM,<maximum number of pages or a range>)
> ;End TOPS10

SET295:	$KEYDSP(SET297)
SET297:	$STAB
	ORNDSP(CONFRM,BATCON,BAT)
	ORNDSP(CONFRM,SITGO,SIT)
	$ETAB

SET300:	$STAB
	ORNDSP(SET330,FORMS-TYPE,FOT)
	ORNDSP(SET340,LIMIT-EXCEEDED-ACTION,LEA)
	ORNDSP(SET310,PAGE-LIMITS,PGL)
	ORNDSP(SET260,PRIORITY-LIMITS,PRL)
	$ETAB

SET310:	$RANGE(CONFRM,<maximum number of pages or a range>)

SET320:	$STAB
	ORNKEY(ABORT,CNC)
	ORNKEY(ASK,ASK)
	ORNKEY(PROCEED,IGN)
	$ETAB

SET330:	$FIELD(CONFRM,<forms name>)
SET340:	$KEY(CONFRM,SET320)
SET350:	$CRLF(<$ACTION(SETTRM##)>)

SET370:	$URANGE	(SET380)

SET380:	$KEYDSP	(SET390)

SET390:	$STAB
	ORNDSP	(SET330,<FORMS-TYPE>,FOT)
	ORNDSP	(SET340,LIMIT-EXCEEDED-ACTION,LEA)
	ORNDSP	(SET480,<OUTPUT-LIMIT>,OPL)
	ORNDSP	(SET260,PRIORITY-LIMITS,PRL)
	$ETAB

SET430:	$URANGE	(SET440)

SET440:	$KEYDSP	(SET450)

SET450:	$STAB
	ORNDSP	(SET330,<FORMS-TYPE>,FOT)
	ORNDSP	(SET340,LIMIT-EXCEEDED-ACTION,LEA)
	ORNDSP	(SET470,<OUTPUT-LIMIT>,OPL)
	ORNDSP	(SET260,PRIORITY-LIMITS,PRL)
	$ETAB

SET470:	$RANGE(CONFRM,<maximum limit in feet or a range>)
SET480:	$RANGE(CONFRM,<maximum limit in minutes or a range>)
SET490:	$URANGE(SET500)

SET500:	$KEYDSP	(SET510)

SET510:	$STAB
	ORNDSP	(SET330,<FORMS-TYPE>,FOT)
	ORNDSP	(SET340,LIMIT-EXCEEDED-ACTION,LEA)
;[LSRSPL]	ORNDSP	(SET530,<OUTPUT-LIMIT>,OPL)
	ORNDSP	(SET530,<PAGE-LIMIT>,OPL)	;[LSRSPL]
	ORNDSP	(SET260,PRIORITY-LIMITS,PRL)
	$ETAB

SET530:
;[LSRSPL]	$RANGE(CONFRM,<maximum limit in cards or a range>)
	$RANGE(CONFRM,<maximum number of pages>)	;[LSRSPL]
SUBTTL	SET TAPE and DISK command tables (TOPS20)

TOPS20 <

SET600:	$DEV	(SET610,<$HELP(<structure name>),$FLAGS(CM%PO)>)

SET610:	$KEYDSP(SET620)

SET620:	$STAB
	ORNDSP(SET622,<ACKNOWLEDGED>,ACK)
	ORNDSP(SET624,<AVAILABLE>,AVA)
	ORNDSP(CONFRM,<DOMESTIC>,DOM)
	ORNDSP(CONFRM,<FOREIGN>,FOR)
	ORNDSP(SET622,<IGNORED>,IGN)
	ORNDSP(CONFRM,<REGULATED>,REG)
	ORNDSP(SET624,<UNAVAILABLE>,UAV)
	ORNDSP(CONFRM,<UNREGULATED>,URG)
	$ETAB

SET622:	$NOISE(CONFRM,<as a new mountable structure>)

SET624:	$NOISE(CONFRM,<to new users>)

>;END TOPS20
SET630:	$DEV(SET640,<$HELP(<tape drive name>)>)

SET640:	$KEYDSP(SET650,<$ACTION(SET655)>)

SET650:	$STAB
	ORNDSP(SET660,<AVAILABLE>,AVA)
	ORNDSP(SETINI,<INITIALIZE>,INI)
	ORNDSP(SET670,<UNAVAILABLE>,UAV)
	$ETAB

	$DATA	VOLIDF,1		;Volume id flag (used for INITIALIZE)
					;if 0 then switch not used
					;if -1 then switch used
					;if 1 then switch needed (ANSI labels)

SET655:	SETZM	VOLIDF			;Initialize volid flag
	$RETT

SET660:	$NOISE(CONFRM,<for use by system>)

SET670:	$CRLF	(<$ALTER(SET680),$ACTION(TXTLIN##),$HELP(<confirm for multiple line explanation for drive unavailable>)>)

SET680:	$CTEXT	(CONFRM,<single line response>)

TOPS20 <

SET700:	$NOISE(SET705,<on>)

SET705:	$KEY(SET720,SET710,<$DEFAULT(<CHANNEL>)>)

SET710:	$STAB
	ORNKEY(<CHANNEL>,CHN)
	$ETAB

SET720:	$NUMBER(SET730,^D8,<channel number>,<$ACTION(CHKCHN)>)

SET730:	$KEY(SET750,SET740,<$DEFAULT(<DRIVE>)>)

SET740:	$STAB
	ORNKEY(<DRIVE>,DRV)
	$ETAB

SET750:$NUMBER(SET760,^D8,<drive number>,<$ACTION(CHKVAL)>)

SET760:	$KEYDSP(SET770)

SET770:	$STAB
	ORNDSP(SET660,<AVAILABLE>,AVA)
	ORNDSP(SET670,<UNAVAILABLE>,UAV)
	$ETAB
>;END TOPS20
SUBTTL	SET ONLINE command tables

TOPS20 <
SET800:	$NOISE(SET810,<device address>)

SET810:	$NUMBER(SET820,<^D8>,<channel number>,<$ACTION(CHKCHN)>)

SET820:	$COMMA(SET830)

SET830:	$NUMBER(SET840,<^D8>,<device unit number>,<$ACTION(CHKVAL)>)

SET840:	$COMMA(SET850,<$ALTERNATE(<CONFRM>)>)

SET850:	$NUMBER(SET860,<^D8>,<controller number or -1>,<$DEFAULT(<-1>)>)

SET860:	$NOISE(SET865,<alternate address>)

SET865:	$NUMBER(SET870,<^D8>,<alternate channel>,<$ACTION(CHKCHN),$ALTERNATE(CONFRM)>)

SET870:	$COMMA(SET875)

SET875:	$NUMBER(SET880,<^D8>,<alternate device unit number>,<$ACTION(CHKVAL)>)

SET880:	$COMMA(SET885,<$ALTERNATE(<CONFRM>)>)

SET885:	$NUMBER(CONFRM,<^D8>,<alternate controller number or -1>,<$DEFAULT(<-1>)>)

CHKCHN:	SKIPL	S1,CR.RES(S2)	;CHECK THAT NUMBER
	CAILE	S1,7		;IN BOUNDS
	SKIPA			;BAD NUMBER
	$RETT			;IT'S GOOD
	PUSHJ	P,FIXIT
	MOVEI	S2,[ASCIZ/channel number not in range 0:7/]
	$RETF

>;END TOPS20
SUBTTL	SET USAGE command tables

TOPS10<

SET900:	$KEYDSP(SET901)
SET901:	$STAB
	ORNDSP(SET910,BILLING-CLOSURE,UBC)
	ORNDSP(SET920,FILE-CLOSURE,UFC)
	$ETAB

SET910:	$TIME(CONFRM)

SET920:	$KEYDSP(SET925,<$ALTER(SET950)>)

SET925:	$STAB
	ORNDSP(SET930,DAILY,DLY)
	ORNDSP(SET940,EVERY,WKY)
	ORNDSP(SET960,NOW,NOW)
	$ETAB

SET930:	$NOISE(SET932,<at>)
SET932:	$TIME(SET960)

SET940:	$KEY(SET945,SET942)
SET942:	$STAB
	KEYTAB(2,FRIDAY)
	KEYTAB(5,MONDAY)
	KEYTAB(3,SATURDAY)
	KEYTAB(4,SUNDAY)
	KEYTAB(1,THURSDAY)
	KEYTAB(6,TUESDAY)
	KEYTAB(0,WEDNESDAY)
	$ETAB

SET945:	$NOISE(SET946,<at>)
SET946:	$TIME(SET960)

SET950:	$TAD(SET960)

SET960:	$SWITCH(CONFRM,SET965,<$ALTERNATE(CONFRM)>)
SET965:	$STAB
	ORNSWI(<NO-SESSION-ENTRIES>,NOS)
	$ETAB

> ;End TOPS10 conditional

SUBTTL	SET TAPE INITIALIZE command tables
SETINI:	$SWITCH(,INI010,<$ACTION(SHRSWT),$ALTERNATE(INI250)>)

INI010:	$STAB
TOPS10<	ORNDSP(INI300,<ABORT>,CNC) >
	ORNSDP(INI140,<COUNT:>,CNT)
	ORNSDP(INI020,<DENSITY:>,DEN)
	ORNSDP(INI240,<INCREMENT:>,INC)
	ORNSDP(INI040,<LABEL-TYPE:>,LBT)
	ORNSDP(INI060,<OVERRIDE-EXPIRATION:>,OVR)
	ORNSDP(INI080,<OWNER:>,OWN)
	ORNSDP(INI100,<PROTECTION:>,PRO)
	ORNSDP(INI120,<TAPE-DISPOSITION:>,TDP)
	ORNSDP(INI170,<VOLUME-ID:>,VID)
	$ETAB


INI020:	$KEY(NEXT(SETINI),INI030,<$DEFAULT(<1600>)>)

INI030:	$STAB
	ORNKEY(1600,160)
	ORNKEY(200,200)
	ORNKEY(556,556)
	ORNKEY(6250,625)
	ORNKEY(800,800)
	$ETAB

INI040:	$KEY(NEXT(SETINI),INI050,<$ACTION(INI057),$DEFAULT(<ANSI>)>)

INI050:	$STAB
	ORNKEY(ANSI,ANS)
	ORNKEY(EBCDIC,EBC)
TOPS20<	ORNKEY(TOPS-20,T20)>
INI055:	ORNKEY(UNLABELED,UNL)
	$ETAB

INI057:	MOVE	S1,CR.RES(S2)		;Get the result from the key table
	CAIE	S1,INI055		;Was the label type unlabeled?
	SKIPE	VOLIDF			;No - skip if still need volume id
	$RETT				;No further action needed
	MOVEI	S1,1
	MOVEM	S1,VOLIDF		;Set that we need volid to be specified
	$RETT

INI060:	$KEY(NEXT(SETINI),INI070,<$DEFAULT(<NO>)>)

INI070:	$STAB
	ORNKEY(NO,NO)
	ORNKEY(YES,YES)
	$ETAB

TOPS20 <
INI080:	$USER(NEXT(SETINI),<$HELP(<user who owns the tape>)>)
>;END -20

TOPS10 <
INI080:	$USER(NEXT(SETINI),<$HELP(<user PPN who owns the tape>)>)
>;END -10

INI100:	$NUMBER(NEXT(SETINI),^D8,<protection for the tape as an octal number>)

INI120:	$KEY(NEXT(SETINI),INI130,<$DEFAULT(<UNLOAD>)>)

INI130:	$STAB
	ORNKEY(HOLD,HLD)
	ORNKEY(UNLOAD,UNL)
	$ETAB

INI140:	$NUMBER(NEXT(SETINI),^D10,<number of volumes to be initialized>,<$ACTION(CHKPOS),$DEFAULT(<10>)>)

INI170:	$FIELD(NEXT(SETINI),<volume-id without quotes>,<$PREFILL(INI175)>)

INI175:	SETOM	VOLIDF				;Say we saw volume id
	$RETT

INI240:	$NUMBER(NEXT(INI200),^D10,<increment value for assigning next volume-id>,<$ACTION(CHKPOS),$DEFAULT(<1>)>)

INI250:	$CRLF ($ACTION(INI260))

INI260:	SKIPG	VOLIDF				;Is it not needed or not used?
	$RETT					;Yes
	MOVEI	S2,[ASCIZ/Volid must be specified/]
	$RETF

INI300:	$CRLF	(<$HELP(<confirm to abort tape initialization>)>)
SUBTTL	SET NODE command tables

IFN	FTDN60,<

SETNOD:	$NODNM(SETN10,<node name>,<$FLAGS(CM%PO)>)

SETN10:	$KEYDSP(SETN20)

SETN20:	$STAB
	ORNDSP(SETN95,<BYTES-PER-MESSAGE>,BPM)
	ORNDSP(SETN40,<CLEAR-SEND-DELAY>,CSD)
	ORNDSP(SETN60,<RECORDS-PER-MESSAGE>,RPM)
	ORNDSP(SETN80,<TIMEOUT-CATEGORY>,TOU)
	ORNDSP(SETN90,<TRANSPARENCY>,TRA)
	$ETAB

SETN40:	$NUMBER(CONFRM,^D10,<time in jiffies>,<$ACTION(CHKVAL)>)

SETN50:	$KEY(CONFRM,SETN55,<$DEFAULT(<ON>)>)

SETN55:	$STAB
	ORNKEY(<OFF>,OFF)
	ORNKEY(<ON>,ON)
	$ETAB

SETN60:	$NUMBER(CONFRM,^D10,<records per message for 2780>,<$ACTION(CHKVAL)>)

SETN80:	$KEY(CONFRM,SETN85)

SETN85:	$STAB
	ORNKEY(<PRIMARY>,PRI)
	ORNKEY(<SECONDARY>,SEC)
	$ETAB

SETN90:	$KEY(CONFRM,SETN55)
SETN95:	$NUMBER(CONFRM,^D10,<bytes per message size for the front end>)
>;END FTDN60
SUBTTL	SET SCHEDULER command tables (TOPS20)


TOPS20	<
SETSCH:	$KEYDSP(SETS10,<$DEFAULT(<BIAS-CONTROL>)>)

SETS10:	$STAB
	ORNDSP(SETS50,<BATCH-CLASS>,BAT)
	ORNDSP(SETS20,<BIAS-CONTROL>,BIA)
	ORNDSP(SETS40,<CLASS>,CLS)
	$ETAB
SETS20:	$NOISE(SETS30,<to>)

SETS30:	$NUMBER(CONFRM,^D10,<<decimal number, a small number to favor interactive processes, larger number for compute-bound>>,<$ACTION(CHKVAL)>)

SETS40:	$NOISE(SETS42,<number>)

SETS42:	$NUMBER(SETS44,^D10,<scheduler class number>,<$ACTION(CHKVAL)>)

SETS44:	$NOISE(SETS46,<to percent>)

SETS46:	$NUMBER(CONFRM,^D10,<percent for this scheduler class (0-99)>,<$ACTION(CHKPER)>)

SETS50:	$KEY(CONFRM,SETS52,<$ALTERNATE(SETS54)>)

SETS52:	$STAB
	ORNKEY(<BACKGROUND>,BCK)
	ORNKEY(<NONE>,NON)
	$ETAB

SETS54:	$NUMBER(CONFRM,^D10,<scheduler class for batch>,<$ACTION(CHKVAL)>)


CHKPER:	SKIPL	T1,CR.RES(S2)	;CHECK THAT NUMBER
	CAILE	T1,^D100	;TOO LARGE
	SKIPA
	$RETT			;RETURN
	PUSHJ	P,FIXIT
	MOVEI	S2,[ASCIZ/scheduler percent out of range/]
	$RETF
>;END TOPS20
SUBTTL	ENABLE/DISABLE command tables


ENAFDB:	$KEYDSP	(ENA001,<$DEFAULT(OUTPUT-DISPLAY)>)

ENA001:	$STAB
TOPS20<	ORNDSP(ENA050,<AUTOMATIC-VOLUME-RECOGNITION>,AVR)>
TOPS20<	ORNDSP(ENACLS,<CLASS-SCHEDULER>,CLS)>
TOPS20<	ORNDSP(CONFRM,<FILE-RETRIEVAL-WAITS>,RET)>
	ORNDSP(CONFRM,<LOGGING>,LGG)
	ORNDSP(ENA100,<OUTPUT-DISPLAY>,OPD)
	ORNDSP(CONFRM,<QUEUE-REQUESTS>,QUE)
TOPS10<	ORNDSP(CONFRM,<STRUCTURE-RECOGNITION>,ASR)>
TOPS10< ORNDSP(ENA050,<VOLUME-RECOGNITION>,AVR)>
	$ETAB

ENA050:	$NOISE(ENA065,<for>)

ENA065:	$KEY(CONFRM,ENA070,<$ALTERNATE(ENA075)>)

ENA070:	$STAB
TOPS10< ORNKEY(<DISK-DRIVES>,DSK)>
	ORNKEY(<TAPE-DRIVES>,TAP)
	$ETAB
TOPS20<
ENA075:	$DEV(CONFRM,$HELP(tape drive name))
>;END TOPS20
TOPS10<
ENA075:	$DEV(CONFRM,<$HELP(<tape or disk drive name>)>)
>;END TOPS10

ENA100:	$NOISE	(ENA105,<of>)

IFG	NUMAPL,<
ENA105:	$KEY(ENA160,ENA110,<$ALTERNATE(ENA140)>)
>;END NUMAPL
IFLE	NUMAPL,<
ENA105:	$KEY(ENA160,ENA110)
>;END

	DEFINE	X(A,B,C),<ORNKEY(<A'-MESSAGES>,<B>)>


	;
	; THE OBJORN MUST BE IN ALPHABETICAL ORDER AND BE BETWEEN ALL
	; AND USER INORDER TO WORK OTHERWISE INDIVIDUALLY ADD THE ITEMS
	;
	;


ENA110:	$STAB
	ORNKEY(<ALL-MESSAGES>,ALM)
	OBJORN			;EXPAND THE MACRO
	ORNKEY(<USER-MESSAGES>,USR)
	$ETAB

IFG	NUMAPL,<
ENA140:	$KEY(CONFRM,ENA150)

	DEFINE	X(A,B,C),<ORNKEY(<A'-MESSAGES>,<B>)>

ENA150:	$STAB
	TABAPL
	$ETAB
>;END NUMAPL

ENA160:	$SWITCH(NEXT(ENA160),ENA170,<$ACTION(SHRSWT),$ALTERNATE(CONFRM)>)

ENA170:	$STAB
	ORNSWI(<INFORMATION-MESSAGES>,OTH)
	ORNSWI(<JOB-MESSAGES>,JOB)
	ORNSWI(<OPR-ACTION-MESSAGES>,OAM)
	$ETAB
SUBTTL	ENACLS	ENABLE CLASS SCHEDULER command tables

TOPS20 <

ENACLS:	$SWITCH(,ENAC10,<$ALTERNATE(CONFRM),$ACTION(SHRSWT),$PREFILL(ENAACT)>)

ENAC10:	$STAB
	ORNSDP(ENAC30,<CLASS-ASSIGNMENTS:>,CAS)
	ORNSDP(ENAC20,<WINDFALL:>,WFL)
	$ETAB

ENAC20:	$KEY(NEXT(ENAC10),ENAC25,<$DEFAULT(<ALLOCATED>)>)

ENAC25:	$STAB
	ORNKEY(<ALLOCATED>,ALO)
	ORNKEY(<WITHHELD>,WHD)
	$ETAB

ENAC30:	$KEY(NEXT(ENAC10),ENAC35,<$DEFAULT(<ACCOUNT>)>)

ENAC35:	$STAB
	ORNKEY(ACCOUNT,ACT)
	ORNKEY(<POLICY-PROGRAM>,PPR)
	$ETAB

ENAACT:	MOVE	S1,CMDCOD			;GET THE COMMAND CODE
	CAIE	S1,.KYDIS			;WAS IT DISABLE?
	$RETT					;NO..RETURN O.K.
	MOVEI	S1,CONFRM			;GET CONFRM ADDRESS
	AOS	S1				;BUMP TO NEXT PDB
	STORE	S1,CR.PDB(S2),RHMASK		;RESET NEXT PDB
	$RETT					;RETURN
>;END TOPS20
SUBTTL	CLOSE command tables
SUBTTL	DEFINE command tables


CLOFDB:	$KEYDSP	(CLO001,<$DEFAULT(<LOG>)>)
CLO001:	$STAB
	ORNDSP	(CONFRM,LOG,LOG)
	$ETAB
SUBTTL	REPORT command tables


RPTFDB:	$NOISE	(RPT005,<by>)

RPT005:	$FIELD (RPT015,<user name>)

RPT015:	$DEV	(RPT020,<$HELP(<device being reported>),$FLAGS(CM%PO)>)

RPT020:	$CRLF	(<$ALTER(RPT025),$ACTION(TXTLIN##),$HELP(<confirm for multiple line response>)>)


RPT025:	$CTEXT	(CONFRM,<single line response>)
SUBTTL	MOUNT command tables (TOPS10)


TOPS10<

MTNFDB:	$KEY	(MTN020,MTN010,<$DEFAULT(<STRUCTURE>)>)
MTN010:	$STAB
	ORNKEY	(<STRUCTURE>,STR)
	$ETAB
MTN020:	$DEV	(MTN030,<$HELP(<structure name>),$FLAGS(CM%PO)>)
MTN030:	$NOISE	(MTN040,<as>)
MTN040:	$DEV	(MTN050,<$HELP(<alias name>),$ALTERNATE(MTN050),$FLAGS(CM%PO)>)
MTN050:	$SWITCH	(CONFRM,MTN060,<$ALTERNATE(<CONFRM>)>)
MTN060:	$STAB
	ORNSWI	(<WRITE-LOCKED>,WLK)
	$ETAB

>;END TOPS10
	SUBTTL	NEXT - NEXT COMMAND

NXTFDB:	$NOISE	(NXT010,<job on>)		;[NXT]

NXT010:	$KEYDSP(NXT020)				;[NXT]

NXT020:	$STAB					;[NXT]
	ORNDSP(NXT040,BATCH-STREAM,BAT)		;[NXT]
;[LSRSPL]	ORNDSP(NXT030,CARD-PUNCH,CDP)		;[NXT]
	ORNDSP(NXT030,LASER-PRINTER,CDP)	;[LSRSPL]
	ORNDSP(NXT030,PAPER-TAPE-PUNCH,PTP)	;[NXT]
	ORNDSP(NXT030,PLOTTER,PLT)		;[NXT]
	ORNDSP(NXT030,PRINTER,LPT)		;[NXT]
	$ETAB					;[NXT]

NXT030:	$NOISE	(NXT050,<unit number>)		;[NXT]
NXT040:	$NOISE	(NXT050,<stream number>)	;[NXT]

NXT050:	$NUMBER	(NXT080,^D10,<number (/NODE:)>,<$ACTION(STOBTH),>) ;[NXT]
NXT080:	$SWITCH (NXT090,NXT085,<$DEFAULT(<REQUEST-ID>),$ALTER(NXT100)>) ;[NXT]
NXT085:	$STAB					;[NXT]
	ORNSWI(NODE:,NOD)			;[NXT]
	$ETAB					;[NXT]
NXT090:	$NODNM	(NXT100,<node name>,<$FLAGS(CM%PO)>) ;[NXT]

NXT100:	$KEYDSP	(NXT110,<$DEFAULT(<REQUEST-ID>)>) ;[NXT]

NXT110:	$STAB					;[NXT]
	ORNDSP(NXT120,<REQUEST-ID>,RQN)		;[NXT]
	$ETAB					;[NXT]

NXT120:	$NUMBER(CONFRM,^D10,<request number of the next job to schedule>,<$ACTION(CHKPOS)>) ;[NXT]

SUBTTL	IDENTIFY command tables

TOPS20 <
IDNFDB:	$NOISE(IDN010,<tape on drive>)>

TOPS10 <
IDNFDB:	$NOISE(IDN010,<device>)>

TOPS20 <
IDN010:	$DEV(IDN020,<$HELP(<tape drive name>)>)>

TOPS10 <
IDN010:	$DEV(IDN020,<$HELP(<device name>)>)>

IDN020:	$NOISE(IDN030,<with>)

IDN030:	$KEYDSP(IDN040,<$DEFAULT(<REQUEST-ID>)>)

IDN040:	$STAB
	ORNDSP(IDN050,<REQUEST-ID>,RQN)
TOPS20<	ORNDSP(CONFRM,<SCRATCH>,SCR) >	;ONLY VALID ON TOPS20
	ORNDSP(IDN060,<VOLUME-ID>,VID)
	$ETAB

IDN050:	$NUMBER(CONFRM,^D10,<request number of the mount request>,<$ACTION(CHKPOS)>)

IDN060:	$QUOTE(CONFRM,<volume-id in quotes if has non-alphanumeric characters>,<$ALTERNATE(IDN070)>)

IDN070:	$FIELD(CONFRM,<volume-id without quotes>)


SUBTTL	SWITCH	command tables (TOPS20)


TOPS20 <
SWIFDB:	$NOISE(SWI010,<request number>)

SWI010:	$NUMBER(SWI020,^D10,<request number of the mount request to switch>)

SWI020:	$NOISE(SWI030,<to new volume>)

SWI030:	$QUOTE(SWI050,<volume-id in quotes if has non-alphanumeric characters>,<$ALTERNATE(SWI040)>)

SWI040:	$FIELD(SWI050,<volume-id without quotes>)

SWI050:	$NOISE(SWI060,<on drive>)

SWI060:	$DEV(CONFRM,<$HELP(<tape drive to switch request to>),$ALTERNATE(CONFRM)>)

>;END TOPS20
SUBTTL	DISMOUNT command tables


DSMFDB:$KEYDSP(DSM010)

DSM010:	$STAB
	ORNDSP(DSM020,<STRUCTURE>,STR)
	ORNDSP(DSM030,<TAPE-DRIVE>,TAP)
	$ETAB

TOPS10 <

DSM020:	$DEV	(DSM040,<$HELP(<structure name to dismount>),$FLAGS(CM%PO)>)

> ;End TOPS10

TOPS20 <

DSM020:	$DEV	(CONFRM,<$HELP(<structure name to dismount>)>)

> ;End TOPS20

DSM030:	$DEV	(CONFRM,<$HELP(<tape drive from which to dismount tape>)>)

TOPS10 <

DSM040:	$SWITCH(,DSM050,<$ACTION(SHRSWT),$ALTERNATE(CONFRM)>)

DSM050:	$STAB
	ORNSDP(NEXT(DSM040),<NOCHECK>,NCK)
	ORNSDP(NEXT(DSM040),<REMOVE>,REM)
	$ETAB

> ;End TOPS10

	comment \
	;removed on July 11,1979
SUBTTL	UNLOAD	command tables (removed)

UNLFDB:	$NOISE(UNL010,<tape drive>)

UNL010:	$DEV	(CONFRM,<$HELP(<tape drive to unload>)>)

;	UNDEFINED FOR NOW
	\;end of comment


SUBTTL	RECOGNIZE command tables


TOPS10 <
RECFDB:	$NOISE(REC010,<labels on>)

REC010:	$DEV (CONFRM,<$HELP(<tape or disk drive to recognize>),$FLAGS(CM%PO)>)
>;END TOPS10

SUBTTL	PUSH command tables
TOPS20 <

PUSFDB::	$NOISE(PUS100,<to EXEC level>)

PUS100:	$CRLF(<$ACTION(PUSHRT##)>)
>;END TOPS20


SUBTTL	HELP command tables

	ND	CR.ADR,4		;Address of current argument

HLPFDB:: $NOISE	(HLPFD1,<with>)

HLPFD1:	$CTEXT(,<command>,<$ACTION(HLPACT),$DEFAULT(HELP)>)

HLPACT:	MOVE	T1,CR.ADR(S2)		;Get the data
	HRROI	T1,ARG.DA(T1)		;Point to the string
	$CALL	SETOUT##		;Setup proper $TEXT defaults
	MOVEI	S1,HLPFD		;Point to help file
	MOVE	S2,T1			;Point to string
	$CALL	P$HELP##
	$CALL	SNDOUT##		;Send the output
	$CALL	P$NPRO##		;Mark no processing
	$RETT				;Return

;File descriptor for help file for OPR

TOPS20	<
HLPFD:	XWD	HSIZ,0
	ASCIZ /HLP:OPR.HLP/
HSIZ==.-HLPFD
>

TOPS10	<
HLPFD:	$BUILD	FDMSIZ
	$SET(.FDLEN,FD.LEN,FDMSIZ)
	$SET(.FDSTR,,<SIXBIT/HLP/>)
	$SET(.FDNAM,,<SIXBIT/OPR/>)
	$SET(.FDEXT,,<SIXBIT/HLP/>)
	$EOB
>

SUBTTL	SHOW ALLOCATION command tables

TOPS10<
ALC000:	$KEYDSP	(ALC010)

ALC010:	$STAB
	ORNDSP	(CONFRM,<ALL-REQUESTS>,ALL)
	ORNDSP	(ALC020,<BATCH-REQUEST>,BRQ)
	ORNDSP	(ALC030,JOB,JOB)
	$ETAB

ALC020:	$NUMBER	(CONFRM,^D10,<request-id for batch job>,<$ALTERNATE(ALC040)>)

ALC030:	$NUMBER	(CONFRM,^D10,<job number>)

ALC040:	$CRLF	($HELP(<confirm for all batch requests>))
>;END TOPS10
	END
