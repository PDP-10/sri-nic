	TITLE	BATLOG	--	BATCH CONTROLLER LOG FILE HANDLER
	SUBTTL	Murray Berkowitz/TOH	4 Apr 80


;
;
;                COPYRIGHT (c) 1975,1976,1977,1978,1979
;                    DIGITAL EQUIPMENT CORPORATION
;
;     THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY  BE  USED
;     AND COPIED ONLY IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE
;     AND WITH THE INCLUSION OF THE ABOVE COPYRIGHT NOTICE.   THIS
;     SOFTWARE  OR ANY OTHER COPIES THEREOF MAY NOT BE PROVIDED OR
;     OTHERWISE MADE AVAILABLE TO ANY OTHER PERSON.  NO  TITLE  TO
;     AND OWNERSHIP OF THE SOFTWARE IS HEREBY TRANSFERRED.
;
;     THE INFORMATION  IN  THIS  SOFTWARE  IS  SUBJECT  TO  CHANGE
;     WITHOUT  NOTICE  AND SHOULD NOT BE CONSTRUED AS A COMMITMENT
;     BY DIGITAL EQUIPMENT CORPORATION.
;
;     DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE OR RELIABILITY
;     OF  ITS  SOFTWARE  ON  EQUIPMENT  WHICH  IS  NOT SUPPLIED BY
;     DIGITAL.

	SEARCH	GLXMAC		;GET GALAXY SYMBOLS
	PROLOG(BATLOG)

	SEARCH	QSRMAC		;GET QUASAR SYMBOLS
	SEARCH	BATMAC		;GET BATCON SYMBOLS
	SEARCH	ORNMAC		;GET ORION SYMBOLS


	;THE FOLLOWING ARE DEFINED EXTERNAL

	EXTERNAL ATOKJB		;JOB LOGOUT CODE
	EXTERNAL CURTIM		;CURRENT TIME AS TEXT STRING
	EXTERNAL CLOS.1		;CLOSE OUT JOB ROUTINE
	EXTERNAL JOBTOT		;TOTAL NUMBE OF JOBS PROCESSED TO DATE
	EXTERNAL JIBTXT		;JOB INFO BLOCK ITEXT
	SUBTTL	TABLE OF CONTENTS

;               TABLE OF CONTENTS FOR BATLOG
;
;
;                        SECTION                                   PAGE
;    1. Murray Berkowitz        20-Mar-79.........................   1
;    2. L$INIT  --      LOG FILE INITIALIZATION AND SETUP.........   2
;    3. L$OUTP  --      LOG FILE PAGE OUTPUT ROUTINE..............   3
;    4. L$OUT1  --      OUTPUT CHARACTER IN S1 TO LOG.............   4
;    5. L$OUTC  --      OUTPUT CHARACTER INTO BUFFER..............   4
;    6. L$OPEN  --      LOG FILE OPEN ROUTINE.....................   5
;    7. L$OPNE  --      LOG FILE OPEN ERROR ROUTINE...............   6
;    8. L$IOER  --      LOG FILE I/O ERROR ROUTINE................   7
;    9. L$NAME  --      GENERATE NEW LOG FILE NAME................   8
;   10. L$PLOG  --      PUT A CHARACTER IN LOG WITH FORMATTING....   9
;   11. L$TIME  --      LOG THE TIME ROUTINE......................  10
;   12. L$IDEN  --      LOG THE LINE IDENTIFIER...................  11
;   13. L$TXTL  --      LOG TEXT FROM LUUO CALL...................  11
;   14. L$LSTG  --      LOG THE STRING IN LOG FILE................  11
;   15. L$BLNK  --      LOG A BLANK LINE..........................  12
;   16. L$BLK1  --      LOG A BLANK LINE WITHOUT CRLF.............  12
;   17. L$CRLF  --      LOG A CARRIAGE RETURN AND LINE-FEED.......  12
;   18. L$CRL2  --      LOG A CRLF AND ADD ANOTHER WITHOUT STAMP..  12
;   19. L$SIXU  --      LOG SIXBIT FROM LUUO......................  13
;   20. L$LSIX  --      LOG SIXBIT ROUTINE........................  13
;   21. L$LCMA  --      LOG A COMMA...............................  14
;   22. L$LCOL  --      LOG A COLON...............................  14
;   23. L$CMNT  --      LOG A COMMENT TO THE LOG FILE.............  15
;   24. L$2TAB  --      LOG 2 TABS TO LOG FILE....................  15
;   25. L$LTAB  --      LOG A TAB TO LOG FILE.....................  15
;   26. L$LPER  --      LOG A PERIOD TO LOG FILE..................  15
;   27. L$CHKP  --      CHECKPOINT THE LOG FILE ROUTINE...........  16
;   28. L$LSTP  --      LOG THE TIME STAMP AND TYPE...............  17
	SUBTTL	Revision History

COMMENT \

Jul-27-79		Change L$OUTP to return false instead of aborting
			to prevent mixing main stack with context stack and
			properly traping the errors
\
	SUBTTL	L$INIT	--	LOG FILE INITIALIZATION AND SETUP

	;THIS ROUTINE WILL SETUP A PAGE FOR LOG FILE OUTPUT THAT WILL
	;GET OUTPUT TO THE LOG FILE

L$INIT:: $CALL	M%GPAG			;GET THE PAGE
	MOVEM	S1,.JLPAG(R)		;SAVE THE PAGE ADDRESS
	MOVEI	S2,<1000*5>-2		;SETUP FIRST TIME COUNT
	SKIPA				;SKIP OVER NORMAL SETTING
L$SETO:: MOVEI	S2,<1000*5>		;GET NUMBER OF BYTES
	MOVE	S1,.JLPAG(R)		;GET PAGE ADDRESS
	MOVEM	S2,.JLPCT(R)		;SAVE THE COUNT
	MOVSI	S2,(POINT 7,0)		;SETUP BYTE POINTER
	TRNN	F,FR.LFO		;WAS LOG FILE OPEN YET?
	MOVSI	S2,(POINT 7,0,13)	;NO..SKIP FIRST TWO BYTES
	HRR	S2,S1			;PUT ADDRESS IN POINTER
	MOVEM	S2,.JLPTR(R)		;SAVE THE POINTER
	POPJ	P,			;RETURN
	SUBTTL	L$OUTP	--	LOG FILE PAGE OUTPUT ROUTINE

	;THIS ROUTINE WILL DUMP THE LOG FILE PAGE TO THE FILE AND
	;RESET ALL THE DATA POINTERS

L$OUTP:: TRNE	F,FR.LFO		;IS LOG FILE OPEN YET
	PJRST	OUTP.1			;YES..JUST DUMP THE BUFFER
	PUSHJ	P,L$OPEN		;OPEN THE LOG FILE
	MOVE	S1,.JLJFN(R)		;GET LOG FILE IFN
	MOVEI	S2,FI.SIZ		;GET FILE SIZE
	$CALL	F%INFO			;GET SIZE FROM FILE
	MOVSI	S2,(POINT 7,0)		;MAKE A POINTER
	HRR	S2,.JLPAG(R)		;PUT PAGE ADDRESS IN POINTER
	JUMPE	S1,OUTP.0		;NONE..PROCESS AS  NEW FILE
	MOVEI	S1,CHR.CR		;GET CARRIAGE RETURN
	IDPB	S1,S2			;SAVE THE BYTE
	MOVEI	S1,CHR.FF		;SET UP FORM FEED
	IDPB	S1,S2			;SAVE THE BYTE
	JRST	OUTP.1			;CONTINUE..OUTPUT THE PAGE
OUTP.0:	MOVEI	S1,CHR.CR		;SETUP CARRIAGE RETURN
	IDPB	S1,S2			;SAVE THE BYTE
	MOVEI	S1,CHR.LF		;SETUP LINE FEED
	IDPB	S1,S2			;SAVE THE BYTE
OUTP.1:	TLNE	R,RL.NLG		;LOG FILE AVAILABLE
	PJRST	L$SETO			;SETUP OUTPUT PAGE
;**;[4134] INSERT THREE LINES AT OUTP.1: + 2L.  TOH, 4-APR-80
IFN	FTJSYS,<
;**;[4154] INSERT 2 LINES AT OUTP.1:+3L (BEFORE PUSHJ P,PRVOFF)	DSW	9/14/81
	MOVE	S1,.JQJBB+JIB.SQ(R)	;[4154] GET SUBMITTERS ACTIVE PRIVS.
	TXNN	S1,EQ.PRV		;[4154] SKIP IF HE WAS ENABLED
	PUSHJ	P,PRVOFF		;[4134] TURN OFF PRIVILEGES
>;END FTJSYS
	MOVE	S2,.JLPAG(R)		;GET PAGE ADDRESS IN S2
	MOVEI	S1,<1000*5>		;GET MAX COUNT
	SUB	S1,.JLPCT(R)		;SUBTRACT COUNT REMAINING
	CAILE	S1,<1000*5>		;CHECK IF WITHIN PAGE
	MOVEI	S1,<1000*5>		;MAKE IT 5000
	HRL	S2,S1			;PLACE COUNT IN LEFT HALF
	MOVE	S1,.JLJFN(R)		;GET THE IFN
	$CALL	F%OBUF			;DUMP THE BUFFER
;**;[4134] INSERT FIVE LINES AT OUTP.E: - 2L.  TOH, 4-APR-80
IFN	FTJSYS,<
	PUSH	P,TF			;[4134] REMEMBER TRUTH VALUE
	PUSHJ	P,PRVON			;[4134] TURN PRIVILEGES BACK ON
	POP	P,TF			;[4134] RESTORE TRUTH VALUE
>;END FTJSYS
	SKIPF				;SKIP IF ERROR
	PJRST	L$SETO			;SETUP PAGE AND RETURN
OUTP.E:	$WTO	(<Batch Log File Error>,<^I/JIBTXT/^I/LOGERR/>,.JQOBJ(R),<$WTNOD(.JQLOC(R))>)
	TLO	R,RL.NLG		;NO LOG FILE AVAILABLE
	TLZ	R,RL.OPR!RL.DIA		;CLEAR SOME POSSIBLE FLAGS
	PUSHJ	P,L$IOER		;LOG FILE I/O ERROR
	$RETF				;RETURN FALSE
	SUBTTL	L$OUT1	--	OUTPUT CHARACTER IN S1 TO LOG
	SUBTTL	L$OUTC	--	OUTPUT CHARACTER INTO BUFFER

	;THIS ROUTINE WILL PLACE A CHARACTER IN THE BUFFER FOR OUTPUT
	;AND ADJUST THE COUNTS
	;
	;CALL	:	CH/	CHARACTER TO OUTPUT
	;
L$OUT1:: MOVE	CH,S1			;PLACE CHARACTER IN CH

L$OUTC:: SOSGE	.JLPCT(R)		;DECREMENT COUNT SKIP IF ROOM
	  JRST	OUTC.1			;NO ROOM..DUMP BUFFER AND CONTINUE
	IDPB	CH,.JLPTR(R)		;DEPOSIT THE BYTE
	$RETT				;RETURN
OUTC.1:	PUSHJ	P,L$OUTP		;OUTPUT THE PAGE
	PJRST	L$OUTC			;PUT OUT THE CHARACTER
	SUBTTL	L$OPEN	--	LOG FILE OPEN ROUTINE

	;THIS ROUTINE WILL OPEN UP THE LOG FILE FOR THE STREAM
	;AND IF THERE IS AN ERROR ATTEMPT TO OPEN A TEMPORARY LOG FILE
	;TO BE PRINTED INDICATING THE ERROR TO THE USER



L$OPEN:: MOVEI	S1,.JQLFD(R)		;LOG FILE FD
	MOVEM	S1,FOB.FD+.JLFOB(R)	;SAVE IN FILE OPEN BLOCK
	MOVEI	S1,7			;7 BIT BYTES
	MOVEM	S1,FOB.CW+.JLFOB(R)	;SAVE CONTROL WORD
	MOVE	S1,.JQLFP(R)		;GET FP PARAMETERS
	TXNN	S1,FP.SPL		;SPOOL BIT ON
	JRST	OPEN.1			;NO..DO IN BEHALF
	MOVEI	S1,FOB.MZ		;SHORT BLOCK SIZE
	JRST	OPEN.2			;CONTINUE LOG FILE OPEN
OPEN.1:
IFN	FTUUOS,<
	MOVE	S1,.JQPPN(R)		;GET USERS PPN IN BEHALF
	MOVEI	S2,0			;0 FOR CONSISTENCY
>;END FTUUOS
IFN	FTJSYS,<
	HRROI	S1,.JQNAM(R)		;USERS NAME
	HRROI	S2,.JQCON(R)		;CONNECTED DIRECTORY
>;END FTJSYS
	MOVEM	S1,FOB.US+.JLFOB(R)	;SAVE USER FIELD
	MOVEM	S2,FOB.CD+.JLFOB(R)	;SAVE CONNECTED DIRECTORY(-20)
	MOVEI	S1,FOB.SZ		;GET FILE OPEN BLOCK SIZE
	MOVX	T1,EQ.PRV		;GET PRIVILEGE FLAG
	TDNE	T1,.JQJBB+JIB.SQ(R)	;WAS IT SET?
	MOVEI	S1,FOB.MZ		;USE MINIMUM SIZE
OPEN.2:	MOVEI	S2,.JLFOB(R)		;ADDRESS OF BLOCK
	SKIPE	T1,.JCHRQ(R)		;SEEN BEFORE?
	JRST	OPEN.3			;YES..OPEN WITH APPEND
	GETLIM	T1,.JQLIM(R),BLOG	;GET BATCH LOG FILE DATA
	CAIN	T1,%BSCDE		;WAS IT SUPERCEDE
	JRST	OPEN.5			;DO SUPERCEDE OPEN
OPEN.3:	$CALL	F%AOPN			;OPEN THE FILE
OPEN.4:	JUMPF	L$OPNE			;LOG FILE ERROR
	MOVEM	S1,.JLJFN(R)		;SAVE IFN FOR LOG FILE
	TRO	F,FR.LFO		;LOG FILE NOW OPEN
IFN	FTJSYS,<
	MOVX	S2,FI.CHN		;GET THE JFN
	PUSHJ	P,F%INFO		;GET THE VALUE
	HRROI	S2,.JQACT(R)		;GET THE ACCOUNT STRING
	SACTF				;SET THE ACCOUNT FOR USER
	   JFCL				;IGNORE ANY ERRORS FOR NOW ***
>;END FTJSYS
	POPJ	P,			;RETURN
OPEN.5:	$CALL	F%OOPN			;DO SUPERCEDE OPEN
	JRST	OPEN.4			;CHECK THE RETURNS

	SUBTTL	L$OPNE	--	LOG FILE OPEN ERROR ROUTINE

	;THIS ROUTINE WILL PROCESS LOG FILE OPEN ERRORS

L$OPNE:: TROE	F,FR.LFE		;LOG FILE ERROR OCCUR YET
	JRST	OPNE.1			;YES,,EXIT NOW
	$WTO	(<Batch Log File Open Error>,<^I/JIBTXT/^I/LOGERR/
A Temporary Log File will be Created, Printed, and Deleted 
for This User. The Job will be Canceled.>,.JQOBJ(R),<$WTNOD(.JQLOC(R))>)
	MOVX	S1,E.LFOE		;LOG FILE OPEN ERROR
	MOVEM	S1,.JERRO(R)		;SAVE ERROR CODE
	TLO	F,FL.ERR		;ERROR BIT SET
	PUSHJ	P,L$CMNT		;LOG A COMMENT LINE
	$TEXT	(L$OUT1,<?  -- Batch Log File Open Error --
		^I/LOGERR/>)
	PUSHJ	P,L$NAME		;FIND LOG NAME...NEW NAME
	JUMPF	OPNE.1			;ERROR IN SPOOL OR 3,3..EXIT
	MOVX	S1,<FP.DEL!FP.SPL>	;GET DELETE BIT AND SPOOL BIT
	IORM	S1,.JQLFP(R)		;SAVE IN FILE FP
	PUSHJ	P,L$OPEN		;TRY TO OPEN FILE
	PUSHJ	P,L$OUTP		;DUMP THE CURRENT DATA
	$TEXT	(L$OUT1,<		A Temporary Log File ^F/.JQLFD(R)/
		Will be Created Printed and Deleted.>)
	PUSHJ	P,L$BLK1		;END AND ADD BLANK LINE
	TLZ	R,RL.OPR!RL.DIA		;CLEAR SOME POSSIBLE FLAGS
	PUSHJ	P,ATOKJB		;LOG OUT THE JOB****
	MOVEI	S1,%EQOLG		;OUTPUT LOG FILE
	STOLIM	S1,.JQLIM(R),OUTP	;RESET THE VALUE
	PJRST	CLOS.1			;AND DISMISS IT
OPNE.1:	$WTO	(<Batch Log File Error>,<^I/JIBTXT/^I/FNDLMS/>,.JQOBJ(R),<$WTNOD(.JQLOC(R))>)
OPNE.2:	TLZ	R,RL.OPR!RL.DIA		;CLEAR SOME POSSIBLE FLAGS
	PUSHJ	P,L$IOER		;LOG FILE I/O ERROR
	PUSHJ	P,ATOKJB		;LOG OUT THE JOB****
	PJRST	CLOS.1			;KILL THE JOB



FNDLMS:	ITEXT	(<Log Error Recovery Failed
^I/LOGERR/
--	 JOB CANCELED	-->)
LOGERR:: ITEXT	(<^E/[-1]/ FOR ^F/.JQLFD(R)/>)

IFN	FTJSYS,<
BATNAM:	ASCIZ /PS:<SPOOL>BATERR/
>;END FTJSYS

	SUBTTL	L$IOER	--	LOG FILE I/O ERROR ROUTINE

	;THIS ROUTINE WILL SETUP ERROR CODE FOR USER AND OPERATOR

L$IOER:: MOVX	S1,E.LFIO		;SET LOG FILE I/O ERROR
	MOVEM	S1,.JERRO(R)		;SAVE THE CODE FOR END MESSAGE
	TLO	F,FL.ERR		;MARK ERROR CODE SET
	PUSHJ	P,L$CMNT		;LOG THE COMMENT LINE
	$TEXT	(L$OUT1,<? -- Batch Log File I/O Error --
		^I/LOGERR/>)
	PUSHJ	P,L$BLK1		;LOG A BLANK LINE
	POPJ	P,			;RETURN
	SUBTTL	L$NAME	--	GENERATE NEW LOG FILE NAME

	;THIS ROUTINE WILL GENERATE A LOG FILE NAME IN THE
	;SPOOL AREA FOR THE SYSTEM

IFN	FTUUOS,<
L$NAME:	MOVX	S1,FSSSTR		;GET STRUCTURE NAME OF SPOOL AREA
	MOVEM	S1,.JQLFD+.FDSTR(R)	;SAVE IN STRUCTURE WORD
	MOVX	S1,%LDQUE		;GET PPN OF SPOOL AREA
	GETTAB	S1,			;OBTAIN VALUE
	  JRST	.RETF			;BAD RETURN EXIT
	MOVEM	S1,.JQLFD+.FDPPN(R)	;SAVE PPN OF AREA
	MOVE	S1,[POINT 6,.JQLFD+.FDNAM(R)];NAME POINTER
	MOVEM	S1,.JQBYT(R)		;SAVE BYTE POINTER
	$CALL	I%NOW			;GET CURRENT TIME
	$TEXT	(FILNAM,<B^D4R0/S1,FILEMK/^D1R0/.JQSTR(R)/LOG^A>)
	MOVX	S1,FDMSIZ		;GET MINIMUM SIZE FD(NO PATH)
	STORE	S1,.JQLFD+.FDLEN(R),FD.LEN ;SAVE NEW LENGTH
	SETZM	.JQLFD+.FDPAT(R)	;CLEAR FIRST WORD OF SFD TO BE SAFE
	$RETT				;GIVE GOOD RETURN
>;END FTUUOS
IFN	FTJSYS,<
L$NAME:	HRLI	S2,(POINT 7,0)		;MAKE A BYTE POINTER
	HRRI	S2,.JQLFD+1(R)		;GET THE START OF FD
	MOVEM	S2,.JQBYT(R)		;SAVE BYTE POINTER
	$CALL	I%NOW			;GET THE TIME
	$TEXT	(FILNAM,<^T/BATNAM/-^D/JOBTOT/-^D6R0/S1,FILEMK/.LOG^0>)
	HRRZ	S1,.JQBYT(R)		;GET ENDING POINTER
	SUBI	S1,.JQLFD-1(R)		;GET THE LENGTH
	STORE	S1,.JQLFD(R),FD.LEN	;SAVE THE NEW COUNT
	$RETT				;GIVE GOOD RETURN
>;END FTJSYS


FILNAM:	
IFN	FTUUOS,<
	SUBI	S1,40		;CONVERT TO 6 BIT
	ANDI	S1,77		;ONLY WANT TO DIGITS
>;END FTUUOS
	IDPB	S1,.JQBYT(R)	;STORE THE BYTE
	$RETT			;RETURN

	SUBTTL	L$PLOG	--	PUT A CHARACTER IN LOG WITH FORMATTING

	;THIS ROUTINE WILL ANALYZE THE CHARACTER AND CONVERT CONTROL
	;CHARACTERS AND INSERT APPROPRIATE TABS


L$PLOG:: CAIL	CH,40		;IS THIS A CONTROL CHARACTER
	  JRST	PLOG.1		;NO, OUTPUT AS IS
;**;[4152] REPLACE 4 LINES AT L$PLOG::+2L WITH 6 LINES	DSW	8/27/81
	TLNE	F,FL.XCC	;[4152] IS THIS A GENERATED CTRL CHARACTER?
	  JRST	PLOG.0		;[4152] YES, OUTPUT AS ^CHAR
	CAILE	CH,CHR.CR	;[4152] HT, LF, VT, FF, AND CR ARE OK
	  JRST	PLOG.0		;[4152] ABOVE CR SHOWS AS ^CHAR
	CAIL	CH,CHR.HT	;[4152] BELOW HT SHOWS AS ^CHAR
	  JRST	PLOG.1		;[4152] SEND HT THRU CR IN IMAGE MODE
;**;[4152] ADD LABEL AT L$PLOG::+8L (HRLM CH,(P))	DSW	8/27/81
PLOG.0:	HRLM	CH,(P)		;SAVE THE ORIGINAL
	MOVEI	CH,"^"		;GET AN UPARROW
	PUSHJ	P,PLOG.1	;OUTPUT IT
	HLRZ	CH,(P)		;GET THE ORIGINAL
	MOVEI	CH,100(CH)	;MAKE THE APPROPRIATE CHARACTER
	PUSHJ	P,PLOG.1	;AND OUTPUT IT
	HLRZ	CH,(P)		;GET THE ORIGINAL AGAIN FOR THE CALLER
	POPJ	P,		;AND RETURN
PLOG.1:	TLZN	F,FL.CRS	;WAS LAST CHARACTER A CARRIAGE RETURN
	  JRST	PLOG.2		;NO, JUST OUTPUT IT
	CAIG	CH,CHR.FF	;CHECK FOR CR NOT FOLLOWED BY VERTICAL MOTION
	CAIGE	CH,CHR.LF	;SAME CHECK AS BELOW FOR TIME STAMP
	  SKIPA			;NOT VERTICAL MOTION, OUTPUT 2 TABS
	JRST	PLOG.2		;OUTPUT THE MOTION CHARACTER
	HRLM	CH,(P)		;SAVE THE CHARACTER ON THE STACK
	PUSHJ	P,L$2TAB	;OUTPUT 2 TABS
	HLRZ	CH,(P)		;RESTORE THE CHARACTER AND OUTPUT IT
PLOG.2:	SKIPE	.JRTIM(R)	;NEED A TIME STAMP
	  PUSHJ	P,L$LSTP	;YES, DO IT
PLOG.3:	CAIN	CH,CHR.CR	;IS THIS A CARRAIGE RETURN
	  TLO	F,FL.CRS	;YES, MARK IT FOR OVERPRINTING CHECK
	PUSHJ	P,L$OUTC	;OUTPUT THE CHARACTER
	CAIG	CH,CHR.FF	;CHECK IF IT WAS VERTICAL PAPER MOTION
	CAIGE	CH,CHR.LF	;THOSE CAUSE A TIME STAMP
	  $RETT			;NO MOTION..RETURN
	SETOM	.JRTIM(R)	;YES,NEXT LINE NEEDS A TIME STAMP
	$RETT			;RETURN TRUE
	SUBTTL	L$TIME	--	LOG THE TIME ROUTINE

	;THIS ROUTINE WILL PUT TIME STAMP IN THE LOG

L$TIME:: SETZM	.JRTIM(R)		;CLEAR THE TIME-STAMP NEEDED FLAG
	MOVSI	T1,(POINT 7,0)		;MAKE A BYTE POINTER
	HRRI	T1,CURTIM		;GET THE CURRENT TIME
TIME.1:	ILDB	CH,T1			;GET A BYTE
	JUMPE	CH,.POPJ		;NULL..RETURN
	PUSHJ	P,L$OUTC		;OUTPUT THE CHARACTER TO LOG
	JRST	TIME.1			;FINISH THE TIME STAMP
	SUBTTL	L$IDEN	--	LOG THE LINE IDENTIFIER
	SUBTTL	L$TXTL	--	LOG TEXT FROM LUUO CALL
	SUBTTL	L$LSTG	--	LOG THE STRING IN LOG FILE

	;THESE ROUTINES WILL PUT A STRING IN THE LOG FILE

L$IDEN:: SKIPN	.JRTIM(R)		;NEED TO END THE PREVIOUS LINE?
	    PUSHJ P,L$CRLF		;LOG A CRLF TO LOG
	PUSHJ	P,L$TIME		;LOG THE TIME
L$TXTL:: HRR	T1,.JBUUO##		;SETUP FOR UUO
L$LSTG:	HRLI	T1,(POINT 7,0)		;SETUP THE POINTER
LSTG.1:	ILDB	CH,T1			;GET A BYTE
	JUMPE	CH,.POPJ		;ZERO..RETURN
	PUSHJ	P,L$OUTC		;OUTPUT THE BYTE
	JRST	LSTG.1			;GET NEXT BYTE

	SUBTTL	L$BLNK	--	LOG A BLANK LINE
	SUBTTL	L$BLK1	--	LOG A BLANK LINE WITHOUT CRLF
	SUBTTL	L$CRLF	--	LOG A CARRIAGE RETURN AND LINE-FEED
	SUBTTL	L$CRL2	--	LOG A CRLF AND ADD ANOTHER WITHOUT STAMP



L$BLNK:: SKIPN	.JRTIM(R)	;NEED TO END THE PREVIOUS LINE?
L$CRL2::   PUSHJ P,L$CRLF	;OUTPUT A CR-LF
L$BLK1:: SETZM	.JRTIM(R)	;CLEAR FLAG TO ADD ANOTHER ONE
L$CRLF:: MOVEI	CH,CHR.CR	;THE CARRIAGE RETURN
	PUSHJ	P,L$PLOG	;OUTPUT IT
	MOVEI	CH,CHR.LF	;AND THE LINE FEED
	PJRST	L$PLOG		;AND EXIT THROUGH PUTLOG

	SUBTTL	L$SIXU	--	LOG SIXBIT FROM LUUO
	SUBTTL	L$LSIX	--	LOG SIXBIT ROUTINE

	;THIS ROUTINE WILL OUTPUT SIXBIT TO THE LOG FILE

L$SIXU:: MOVE	T1,@.JBUUO##	;SET UP FROM UUO ENTRY
L$LSIX:: MOVE	T2,[POINT 6,T1]	;GET BYTE POINTER
LSIX.1:	ILDB	CH,T2		;GET THE BYTE
	JUMPE	CH,.POPJ	;NULL..RETURN
	MOVEI	CH," "(CH)	;MAKE ASCII
	PUSHJ	P,L$OUTC	;OUTPUT THE CHARACTER
	TLNN	T2,770000	;GOT IT ALL?
	  POPJ	P,		;YES,,RETURN
	JRST	LSIX.1		;GET THE NEXT
	SUBTTL	L$LCMA	--	LOG A COMMA
	SUBTTL	L$LCOL	--	LOG A COLON



L$LCMA:: SKIPA	CH,[","]	;A COMMA
L$LCOL:: MOVEI	CH,":"		;A COLON
	JRST	L$OUTC		;OUTPUT THE CHARACTERS

	SUBTTL	L$CMNT	--	LOG A COMMENT TO THE LOG FILE
	SUBTTL	L$2TAB	--	LOG 2 TABS TO LOG FILE
	SUBTTL	L$LTAB	--	LOG A TAB TO LOG FILE
	SUBTTL	L$LPER	--	LOG A PERIOD TO LOG FILE

	;THIS ROUTINE WILL LOG A COMMENT INTO THE LOG FILE


L$CMNT:: SKIPN	.JRTIM(R)	;NEED TO END THE PREVIOUS LINE
	  PUSHJ	P,L$CRLF	;YES, DO IT
	SETZM	.JRTIM(R)	;NO TIME STAMP NEEDED
L$2TAB:: PUSHJ	P,L$LTAB	;OUTPUT A TAB
L$LTAB:: SKIPA	CH,[CHR.HT]	;AND ANOTHER ONE
L$LPER:: MOVEI	CH,MONCHR	;A PERIOD (OR SOMETHING LIKE THAT)
	JRST	L$PLOG		;OUTPUT THE PERIOD
	SUBTTL	L$CHKP	--	CHECKPOINT THE LOG FILE ROUTINE

	;THIS ROUTINE WILL DUMP THE LOG FILE AND THEN CHECKPOINT IT
	;ON ERROR WILL ABORT THE USER


L$CHKP:: TRNN	F,FR.LFO		;IS LOG FILE OPEN
	PUSHJ	P,L$OPEN		;GO OPEN LOG FILE
	PUSHJ	P,L$OUTP		;DUMP THE DATA
	JUMPF	.POPJ			;ERROR...RETURN
;**;[4134] INSERT THREE LINES AT L$CHKP: + 4L.  TOH, 4-APR-80
IFN	FTJSYS,<
;**;[4154] INSERT 2 LINES AT L$CHKP:+5L (BEFORE PUSHJ P,PRVOFF)	DSW	9/14/81
	MOVE	S1,.JQJBB+JIB.SQ(R)	;[4154] GET SUBMITTERS ACTIVE PRIVS.
	TXNN	S1,EQ.PRV		;[4154] SKIP IF HE WAS ENABLED
	PUSHJ	P,PRVOFF		;[4134] TURN OFF PRIVILEGES
>;END FTJSYS
	MOVE	S1,.JLJFN(R)		;IFN FOR FILE
	$CALL	F%CHKP			;CHECKPOINT THE FILE
;**;[4134] INSERT FIVE LINES AT CHKP.1: - 3L.  TOH, 4-APR-80
IFN	FTJSYS,<
	PUSH	P,TF			;[4134] REMEMBER TRUTH VALUE
	PUSHJ	P,PRVON			;[4134] TURN PRIVILEGES BACK ON
	POP	P,TF			;[4134] RESTORE TRUTH VALUE
>;END FTJSYS
	JUMPF	CHKP.1			;ABORT TRANSACTION
	MOVEM	S1,.JLUSI(R)		;LOG FILE POINTER
	POPJ	P,			;RETURN
CHKP.1:	$WTO	(<Batch Log Error>,<^I/JIBTXT/^I/LOGERR/
JOB BEING CANCELED>,.JQOBJ(R),<$WTNOD(.JQLOC(R))>)
	TLO	R,RL.NLG		;NO LOG AVAILABLE
	PUSHJ	P,L$IOER		;LOG THE I/O ERROR
	$RETF				;RETURN FALSE

	SUBTTL	L$LSTP	--	LOG THE TIME STAMP AND TYPE

L$LSTP:: PUSH	P,CH		;SAVE THE CHARACTER
	PUSHJ	P,L$TIME	;PUT TIME STAMP IN LOG FILE
	MOVEI	T1,[ASCIZ/ MONTR	/]
	TLNN	J,JL.UML	;WAS JOB AT MONITOR LEVEL
	  MOVEI	T1,[ASCIZ/ USER	/] ;NO, SAY USER MODE
	PUSHJ	P,L$LSTG	;LOG THE STRING
	POP	P,CH		;RESTORE CH
	POPJ	P,		;RETURN
	SUBTTL	PRVOFF	--	TURN PRIVILEGES OFF FOR QUOTA ENFORCEMENT

	;THIS ROUTINE WILL DISABLE WHEEL AND/OR OPERATOR PRIVILEGES SO
	;THAT DIRECTORY QUOTA CHECKING WILL BE ENFORCED ON SUBSEQUENT
	;WRITES.  (TOPS-20 ONLY).  TOH, 4-APR-80

IFN	FTJSYS,<
;**;[4163] INSERT 1 LINE AT PRVOFF:+0L	DSW	1/14/82
PRVOFF:	PUSH	P,T1			;[4163] SAVE BYTE POINTER
	$CALL	I%IOFF			;[4134] TURN OFF INTERRUPTS
	MOVEI	S1,.FHSLF		;[4134] GET PROCESS HANDLE
	RPCAP				;[4134] READ OUR CAPABILITIES
	ERJMP	[$STOP (CRC,Couldn't Read/set Capabilities)] ;[4134]
	TXZ	T1,SC%WHL!SC%OPR	;[4134] TURN OFF WHEEL AND OPERATOR
	EPCAP				;[4134] AND ENABLE EVERYTHING BUT
	ERCAL	S..CRC			;[4134] HANDLE ERROR
;**;[4163] INSERT 1 LINE AT PRVOFF:+8L (BEFORE POPJ P,)	DSW	1/14/82
	POP	P,T1			;[4163] RESTORE BYTE POINTER
	POPJ	P,			;[4134] RETURN TO CALLER
>;END FTJSYS


	SUBTTL	PRVON	--	TURN PRIVILEGES BACK ON

	;THIS ROUTINE WILL RE-ENABLE WHEEL AND/OR OPERATOR PRIVILEGES
	;(TOPS-20 ONLY).  TOH, 4-APR-80

IFN	FTJSYS,<
;**;[4163] INSERT 1 LINE AT PRVON:+0L	DSW	1/14/82
PRVON:	PUSH	P,T1			;[4163] SAVE BYTE POINTER
	MOVEI	S1,.FHSLF		;[4134] GET PROCESS HANDLE
	RPCAP				;[4134] READ OUR CAPABILITIES
	ERCAL	S..CRC			;[4134] HANDLE ERROR
	TXO	T1,SC%WHL!SC%OPR	;[4134] TURN ON WHEEL AND OPERATOR
	EPCAP				;[4134] ENABLE THESE CAPABILITIES
	ERCAL	S..CRC			;[4134] HANDLE ERROR
	$CALL	I%ION			;[4134] TURN INTERRUPTS BACK ON
;**;[4163] INSERT 1 LINE AT PRVON:+8L	DSW	1/14/82
	POP	P,T1			;[4163] RESTORE BYTE POINTER
	POPJ P,				;[4134] RETURN TO CALLER
>;END FTJSYS
	END
   