;<5-1-SOURCES>MACSYM.MAC.44,  7-Jul-83 05:16:58, Edit by MRC
;Stanford changes:
; Be sure to save ENDLP. context in nested DO.
; UPD ID= 82, SNARK:<5.UTILITIES>MACSYM.MAC.43,  22-Feb-82 17:57:38 by MURPHY
;IFJER., IFNJE. - new names for IFNES., IFESK.
; UPD ID= 68, SNARK:<5.UTILITIES>MACSYM.MAC.42,  15-Jan-82 10:45:56 by WALLACE
;TCO 5.1669 - Add Error JSERR (EJSERR) and Error JSHLT (EJSHLT) macros
;TCO 5.1666 - Add If Error Skip (IFESK.) and If No Error Skip (IFNES.) macros
; UPD ID= 59, SNARK:<5.UTILITIES>MACSYM.MAC.41,  17-Nov-81 11:56:55 by MURPHY
;Allow ANxxx. between ELSE. and ENDIF.
;ENDDO. equivalent to OD. for consistency.
; UPD ID= 58, SNARK:<5.UTILITIES>MACSYM.MAC.40,  16-Nov-81 11:29:33 by MURPHY
;FORN., FORX.
; UPD ID= 34, SNARK:<5.UTILITIES>MACSYM.MAC.39,  18-Sep-81 13:35:40 by LEACHE
;Add comments
; UPD ID= 32, SNARK:<5.UTILITIES>MACSYM.MAC.38,  17-Sep-81 15:45:20 by MURPHY
;Fix STDAC.
; UPD ID= 28, SNARK:<5.UTILITIES>MACSYM.MAC.37,   8-Sep-81 17:38:36 by MURPHY
;Two PURGEs for ENDxx to get rid of both macro and symbol definition.
; UPD ID= 15, SNARK:<5.UTILITIES>MACSYM.MAC.36,  30-Jul-81 09:01:25 by LEACHE
;Remove unneeded ^O's from previous
; UPD ID= 13, SNARK:<5.UTILITIES>MACSYM.MAC.35,  29-Jul-81 09:22:17 by LEACHE
;Add macros MPRNTX,EPRNTX,LFIWM,GFIWM,L1BPT,L2BPT,G1BPT,G2BPT
; UPD ID= 2278, SNARK:<5.UTILITIES>MACSYM.MAC.34,  30-Jun-81 16:41:32 by MURPHY
;FIX IFXE.
; UPD ID= 2251, SNARK:<6.UTILITIES>MACSYM.MAC.14,  24-Jun-81 16:54:23 by MURPHY
;STDAC., DO.
; UPD ID= 2183, SNARK:<6.UTILITIES>MACSYM.MAC.13,  11-Jun-81 14:40:23 by MURPHY
;RENAME TQNx TO TMNx; TQNx WILL GENERATE EXACTLY ONE INSTRUCTION OR COMPLAIN
; UPD ID= 2158, SNARK:<6.UTILITIES>MACSYM.MAC.12,   9-Jun-81 15:13:39 by MURPHY
;IFXE., IFXN., IFQE., IFQN., ANDXE., ANDXN., ANDQE., ANDQN
;RESTRUCTURE IFE., IFN. ETC., ADD ELSE. CASE, ADD ANDE., ANDN., ETC.
; UPD ID= 2150, SNARK:<6.UTILITIES>MACSYM.MAC.11,   8-Jun-81 16:47:27 by MURPHY
;ANSKP., ANNSK., IFE., IFN., ETC.
; UPD ID= 2120, SNARK:<6.UTILITIES>MACSYM.MAC.9,   3-Jun-81 16:13:37 by MURPHY
;MORE ORNSK.
; UPD ID= 2052, SNARK:<6.UTILITIES>MACSYM.MAC.8,  20-May-81 17:47:33 by MURPHY
;Suppress one more generated tag in IFSKP.
; UPD ID= 2017, SNARK:<6.UTILITIES>MACSYM.MAC.7,  18-May-81 15:57:40 by MURPHY
;Alternate form of IFSKP., IFNSK.
; UPD ID= 1781, SNARK:<6.UTILITIES>MACSYM.MAC.6,   2-Apr-81 10:42:18 by HUIZENGA
;TCO 5.1275 - Explicitly define absolute value of .JBVER as octal. 20-15376.
; UPD ID= 1766, SNARK:<6.UTILITIES>MACSYM.MAC.4,  25-Mar-81 14:55:47 by MURPHY
;Suppress generated tags in IFSKP. etc.
;Provide optional variables in BLSUB.
; UPD ID= 1688, SNARK:<5.UTILITIES>MACSYM.MAC.26,  12-Mar-81 11:49:35 by GRANT
;Update Copyright
; UPD ID= 1629, SNARK:<5.UTILITIES>MACSYM.MAC.25,   2-Mar-81 14:47:00 by MURPHY
;FIX TO BLCAL.
;USE .SAC NOT CX
; UPD ID= 1592, SNARK:<5.UTILITIES>MACSYM.MAC.23,  26-Feb-81 17:52:17 by MURPHY
;MV., MVI.
; UPD ID= 1559, SNARK:<5.UTILITIES>MACSYM.MAC.22,  13-Feb-81 16:42:35 by MURPHY
;.IF, ORNSK.
; UPD ID= 1544, SNARK:<5.UTILITIES>MACSYM.MAC.21,   9-Feb-81 13:54:29 by MURPHY
;IFNSK., IFSKP.
; UPD ID= 1523, SNARK:<5.UTILITIES>MACSYM.MAC.20,   6-Feb-81 11:16:07 by MURPHY
;NAMES CHANGED TO BLCAL., BLSUB.
; UPD ID= 1513, SNARK:<5.UTILITIES>MACSYM.MAC.19,   3-Feb-81 17:40:52 by MURPHY
;ADD .IFATM, FIX BLCALL
; UPD ID= 1466, SNARK:<5.UTILITIES>MACSYM.MAC.18,  21-Jan-81 16:19:40 by MURPHY
;DITTO
; UPD ID= 1465, SNARK:<5.UTILITIES>MACSYM.MAC.17,  21-Jan-81 15:09:03 by MURPHY
;BLSUBR, BLCALL
; UPD ID= 1179, SNARK:<5.UTILITIES>MACSYM.MAC.16,  20-Oct-80 17:21:25 by MURPHY
;REVISE PREV EDIT IN DEFSTR
; UPD ID= 1165, SNARK:<5.UTILITIES>MACSYM.MAC.15,  15-Oct-80 12:08:44 by MURPHY
;EXTERN .SASET
; UPD ID= 1135, SNARK:<5.UTILITIES>MACSYM.MAC.14,   6-Oct-80 16:13:17 by MURPHY
;MAKE DEFSTR DEFINE A SYMBOL TO HOLD LOCATION INFO FOR DDT
; UPD ID= 1074, SNARK:<5.UTILITIES>MACSYM.MAC.13,  30-Sep-80 17:38:12 by MURPHY
;DITTO
; UPD ID= 1069, SNARK:<5.UTILITIES>MACSYM.MAC.12,  30-Sep-80 14:23:54 by MURPHY
;STKVAR, ACVAR
; SNARK:<5.UTILITIES>MACSYM.MAC.11,	5-Aug-80 09:07:15 by ELFSTROM
;	change "circonflex" to "circumflex"
; UPD ID= 611, SNARK:<4.1.UTILITIES>MACSYM.MAC.10,   6-Jun-80 14:36:44 by MURPHY
; UPD ID= 602, SNARK:<4.1.UTILITIES>MACSYM.MAC.9,   4-Jun-80 22:44:54 by MURPHY
;ALLOW MEMORY LOC FOR TQNN AND TQNE
; UPD ID= 470, SNARK:<4.1.UTILITIES>MACSYM.MAC.8,  23-Apr-80 17:28:36 by MURPHY
; UPD ID= 469, SNARK:<4.1.UTILITIES>MACSYM.MAC.7,  23-Apr-80 16:41:36 by MURPHY
;ADD .XCMSY - MACRO TO SUPPRESS JUNK SYMBOLS USER HEREIN
;<4.1.UTILITIES>MACSYM.MAC.6, 14-Apr-80 16:29:47, EDIT BY OSMAN
;Change FLDDB. and FLDBK. to allow \ in help message
;<4.1.UTILITIES>MACSYM.MAC.5, 12-Nov-79 08:42:58, EDIT BY OSMAN
;more 4.2570 - Purge ..V1 and ..V22 after using them
;<4.1.UTILITIES>MACSYM.MAC.4, 12-Nov-79 08:34:38, EDIT BY OSMAN
;MORE 4.2570 - Change V22 to ..V22
;<4.1.UTILITIES>MACSYM.MAC.3,  9-Nov-79 13:55:33, EDIT BY OSMAN
;tco 4.2570 - Change V1 to ..V1
;<4.1.UTILITIES>MACSYM.MAC.2, 31-Oct-79 10:37:13, EDIT BY OSMAN
;tco 4.1.1003 - Add .CHSPC
;<4.UTILITIES>MACSYM.MAC.27, 19-Oct-79 13:39:11, EDIT BY ZIMA
;TCO 4.2536 - Make JSMSG0 external to prevent "undefined" errors
;  from MACRO when attempting to use PERSTR macro.
;<4.UTILITIES>MACSYM.MAC.19,  2-Oct-79 15:05:45, EDIT BY OSMAN
;tco 4.2506 - allow BRKCH. ","
;<4.UTILITIES>MACSYM.MAC.18, 21-Sep-79 15:37:58, EDIT BY ENGEL
;UNDO MAKING RETSKP AN OPDEF
;<4.UTILITIES>MACSYM.MAC.17, 11-Sep-79 07:17:32, EDIT BY R.ACE
;TCO 4.2453 - PREFIX "symbol IS NOT DEFINED" WITH A QUESTION MARK
;<4.UTILITIES>MACSYM.MAC.16, 19-Aug-79 20:35:06, EDIT BY GILBERT
;MAKE RETSKP, JSHLT, ETC. OPDEFS FOR DDT TYPEOUT.
;<4.UTILITIES>MACSYM.MAC.15, 22-Jun-79 07:16:13, EDIT BY R.ACE
;TCO 4.2307 - CHANGE FLDDB. TO USE 0,,LST INSTEAD OF Z LST
;<4.UTILITIES>MACSYM.MAC.14, 10-Mar-79 14:01:35, EDIT BY KONEN
;UPDATE COPYRIGHT FOR RELEASE 4
;<4.UTILITIES>MACSYM.MAC.13,  8-Feb-79 16:46:30, EDIT BY KIRSCHEN
;ADD ENTRY DECLARATION FOR .STKST FOR LIBRARY SEARCHING
;<4.UTILITIES>MACSYM.MAC.12,  6-Feb-79 10:59:13, EDIT BY GILBERT
;REPLACE XMOVEI -- MACRO DOESN'T KNOW ABOUT IT
;<4.UTILITIES>MACSYM.MAC.11,  5-Feb-79 00:51:10, EDIT BY GILBERT
;Remove extended addressing OPDEFs now in MACRO, change XBLT MACRO
;  to XBLT. to avoid conflict with MACRO's definition of 020000,,0.
;<4.UTILITIES>MACSYM.MAC.10, 22-Jan-79 16:29:04, EDIT BY DNEFF
;Make POINTR macro take addresses with indexing again.
;<4.UTILITIES>MACSYM.MAC.9, 22-Jan-79 13:31:23, EDIT BY DBELL
;MAKE POINTR, FLD, .RTJST, MASKB, AND MOD. IMMUNE TO STRANGE ARGUMENTS
;<4.UTILITIES>MACSYM.MAC.8, 25-Oct-78 12:22:59, EDIT BY GILBERT
;Suppress CALLRET to DDT typeout.
;<4.UTILITIES>MACSYM.MAC.7, 12-Sep-78 15:52:12, EDIT BY OSMAN
;FIX FLDBK.
;<4.UTILITIES>MACSYM.MAC.4,  6-Sep-78 16:51:29, EDIT BY OSMAN
;ADD FLDDB. AND FLDBK.
;<4.UTILITIES>MACSYM.MAC.3,  6-Sep-78 16:28:36, EDIT BY OSMAN
;CHANGE BREAK SET MACROS TO HAVE DOTS IN THEM.   ADD BRMSK.
;<4.UTILITIES>MACSYM.MAC.2,  3-Sep-78 12:35:16, EDIT BY OSMAN
;ADD MACROS FOR DEFINING 128-BIT CHARACTER BREAK MASKS




;THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY ONLY BE USED
;  OR COPIED IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
;COPYRIGHT (C) 1976,1977,1978,1979,1980,1981 BY DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.

;VERSION 1

IFNDEF REL,<REL==0>		;UNIVERSAL UNLESS OTHERWISE DECLARED
   IFE REL,<
	UNIVERSAL MACSYM	COMMON MACROS AND SYMBOLS
   >
   IFN REL,<
	TITLE MACREL		SUPPORT CODE FOR MACSYM
	SEARCH MONSYM
	SALL
   >

;THE STANDARD VERSION WORD CONSTRUCTION
; VERS - PROGRAM VERSION NUMBER
; VUPDAT - PROGRAM UPDATE NUMBER (1=A, 2=B ...)
; VEDIT - PROGRAM EDIT NUMBER
; VCUST - CUSTOMER EDIT CODE (0=DEC DEVELOPMENT, 1=DEC SWS, 2-7 CUST)

DEFINE PGVER.	(VERS,VUPDAT,VEDIT,VCUST)<
	..PGV0==.		;;SAVE CURRECT LOCATION AND MODE
	.JBVER=:^O137		;;WHERE TO PUT VERSION
	LOC	.JBVER		;;PUT VERSION IN STANDARD PLACE
	BYTE	(3)VCUST(9)VERS(6)VUPDAT(18)VEDIT
	.ORG	..PGV0		;;RESTORE LOCATION AND MODE
>

;MASKS FOR THE ABOVE

VI%WHO==:7B2			;Customer edit code
VI%MAJ==:777B11			;Major version number
VI%MIN==:77B17			;Minor version/update
VI%EDN==:777777B35		;Edit number
;ADDED VI%XXX

	SUBTTL COMMON DEFS

;DEFINE STANDARD AC'S

DEFINE STDAC. <
F=:0
T1=:1
T2=:2
T3=:3
T4=:4
Q1=:5
Q2=:6
Q3=:7
P1=:10
P2=:11
P3=:12
P4=:13
P5=:14
P6=:15
CX=:16
P=:17
>
	SUBTTL MISC CONSTANTS

;MISC CONSTANTS

.INFIN==:377777,,777777		;PLUS INFINITY
.MINFI==:1B0			;MINUS INFINITY
.LHALF==:777777B17		;LEFT HALF
.RHALF==:777777			;RIGHT HALF
.FWORD==:-1			;FULL WORD

	SUBTTL	SYMBOLS FOR THE CONTROL CHARACTERS

.CHNUL==:000			;NULL
.CHCNA==:001
.CHCNB==:002
.CHCNC==:003
.CHCND==:004
.CHCNE==:005
.CHCNF==:006
.CHBEL==:007			;BELL
.CHBSP==:010			;BACKSPACE
.CHTAB==:011			;TAB
.CHLFD==:012			;LINE-FEED
.CHVTB==:013			;VERTICAL TAB
.CHFFD==:014			;FORM FEED
.CHCRT==:015			;CARRIAGE RETURN
.CHCNN==:016
.CHCNO==:017
.CHCNP==:020
.CHCNQ==:021
.CHCNR==:022
.CHCNS==:023
.CHCNT==:024
.CHCNU==:025
.CHCNV==:026
.CHCNW==:027
.CHCNX==:030
.CHCNY==:031
.CHCNZ==:032
.CHESC==:033			;ESCAPE
.CHCBS==:034			;CONTROL BACK SLASH
.CHCRB==:035			;CONTROL RIGHT BRACKET
.CHCCF==:036			;CONTROL CIRCUMFLEX
.CHCUN==:037			;CONTROL UNDERLINE
.CHSPC==:040			;SPACE

.CHALT==:175			;OLD ALTMODE
.CHAL2==:176			;ALTERNATE OLD ALTMODE
.CHDEL==:177			;DELETE

	SUBTTL	HARDWARE BITS OF INTEREST TO USERS

;PC FLAGS

PC%OVF==:1B0			;OVERFLOW
PC%CY0==:1B1			;CARRY 0
PC%CY1==:1B2			;CARRY 1
PC%FOV==:1B3			;FLOATING OVERFLOW
PC%BIS==:1B4			;BYTE INCREMENT SUPPRESSION
PC%USR==:1B5			;USER MODE
PC%UIO==:1B6			;USER IOT MODE
PC%LIP==:1B7			;LAST INSTRUCTION PUBLIC
PC%AFI==:1B8			;ADDRESS FAILURE INHIBIT
PC%ATN==:3B10			;APR TRAP NUMBER
PC%FUF==:1B11			;FLOATING UNDERFLOW
PC%NDV==:1B12			;NO DIVIDE

;THE FOLLOWING MACRO MAY BE USED TO SUPPRESS CREF ENTRIES FOR
;ALL THE JUNK SYMBOLS USED INTERNALLY WITHIN MACROS IN MACSYM

DEFINE .XCMSY <
	.XCREF
	.XCRF1 <..ACT,..CSC,..CSN,..IFT,..JX1,..MSK,..MX1,..MX2>
	.XCRF1 <..NAC,..NRGS,..NS,..NV,..PST,..STKN,..STKQ,..STKR>
	.XCRF1 <..TRR,..TSA1,..TX1,..TX2,.FP,.FPAC,.NAC,.SAC,.SAV1>
	.XCRF1 <.SAV2,.SAV3,POINTR,POS,WID,..CAS1,..CNS,..CNS2>
	.XCRF1 <..DPB,..GNCS,..ICNS,..JE,..LDB,..STR0,..STR1,..STR2>
	.XCRF1 <..STR4,..TQO,..TQZ,..TSAC,..TSIZ,..TX,..TY,.ACV1,.ACV2>
	.XCRF1 <.ACV3,.CASE,.DECR0,.IF0,.INCR0,.OPST1,.OPST2,.STKV1>
	.XCRF1 <.STKV2,.STKV3,.TRV1,.TRV2,.TRV3>
	.CREF
   >
DEFINE .XCRF1 (SYMS)<
	IRP SYMS,<
	 IFDEF SYMS,< .XCREF SYMS>>>

	SUBTTL	MACROS FOR FIELD MASKS

;STANDARD MACROS

;MACROS TO HANDLE FIELD MASKS

;COMPUTE LENGTH OF MASK, I.E. LENGTH OF LEFTMOST STRING OF ONES
;REMEMBER THAT ^L DOES 'JFFO', I.E. HAS VALUE OF FIRST ONE BIT IN WORD

;COMPUTE WIDTH OF MASK, I.E. LENGTH OF LEFTMOST STRING OF ONES

DEFINE WID(MASK)<<^L<-<<MASK>_<^L<MASK>>>-1>>>

;COMPUTE POSITION OF MASK, I.E. BIT POSITION OF RIGHTMOST ONE IN MASK

DEFINE POS(MASK)<<^L<<MASK>&<-<MASK>>>>>

;CONSTRUCT BYTE POINTER TO MASK

DEFINE POINTR(LOC,MASK)<<POINT WID(MASK),LOC,POS(MASK)>>

;PUT RIGHT-JUSTIFIED VALUE INTO FIELD SPECIFIED BY MASK

DEFINE FLD(VAL,MSK)<<<<VAL>B<POS(MSK)>>&<MSK>>>

;MAKE VALUE BE RIGHT JUSTIFIED IN WORD.

DEFINE .RTJST(VAL,MSK)<<<<VAL>&<MSK>>B<^D70-POS(MSK)>>>

;CONSTRUCT MASK FROM BIT AA TO BIT BB. I.E. MASKB 0,8 = 777B8

DEFINE MASKB(AA,BB)<<1B<<AA>-1>-1B<BB>>>

;MODULE - GIVES REMAINDER OF DEND DIVIDED BY DSOR

DEFINE MOD.(DEND,DSOR)<<<DEND>-<<DEND>/<DSOR>>*<DSOR>>>

;REPEAT WITH SUBSTITUTION OF NUMERIC INDEX

DEFINE FORN. (LOW,HIGH,ARGS,STRING,%MN1)<
  DEFINE %MN1(ARGS)<STRING>
..FORN==LOW
REPEAT HIGH-LOW+1,<
	.FORN1 (%MN1)
	..FORN=..FORN+1>>

DEFINE .FORN1 (MACN)<
	MACN (\..FORN)>

;REPEAT WITH GENERAL STRING SUBSTITUTION

DEFINE FORX. (ARGS,SYMS,STRING,%MN1)<
  DEFINE %MN1 (SYMS)<STRING>
  IRP ARGS,<
	.FORX1 %MN1,ARGS>>

  DEFINE .FORX1 (MACN,ARGS)<
	MACN ARGS>

	SUBTTL MOVX

;MOVX - LOAD AC WITH CONSTANT

DEFINE MOVX (AC,MSK)<
   ..MX1==MSK			;;EVAL EXPRESSION IF ANY
   .IFN ..MX1,ABSOLUTE,<
	MOVE AC,[MSK]>
   .IF ..MX1,ABSOLUTE,<
	..MX2==0		;;FLAG SAYS HAVEN'T DONE IT YET
	IFE <..MX1>B53,<
	  ..MX2==1
	  MOVEI AC,..MX1>	;;LH 0, DO AS RH
	IFE ..MX2,<		;;IF HAVEN'T DONE IT YET,
	IFE <..MX1>B17,<
	  ..MX2==1
	  MOVSI AC,(..MX1)>>	;;RH 0, DO AS LH
	IFE ..MX2,<		;;IF HAVEN'T DONE IT YET,
	IFE <<..MX1>B53-^O777777>,<
	  ..MX2==1
	  HRROI AC,<..MX1>>>	;;LH -1
	IFE ..MX2,<		;;IF HAVEN'T DONE IT YET,
	IFE <<..MX1>B17-^O777777B17>,<
	  ..MX2==1
	  HRLOI AC,(..MX1-^O777777)>> ;;RH -1
	IFE ..MX2,<		;;IF STILL HAVEN'T DONE IT,
	  MOVE AC,[..MX1]>	;;GIVE UP AND USE LITERAL
  >>

;MV., MVI. - Move from memory to memory or immediate to memory

DEFINE MV. (FROM,TOO)<
	MOVE .SAC,FROM
	MOVEM .SAC,TOO>

DEFINE MVI. (STUFF,DEST)<
	MOVX .SAC,<STUFF>
	MOVEM .SAC,DEST>
;VARIENT MNEMONICS FOR TX DEFINITIONS

DEFINE IORX (AC,MSK)<
	TXO AC,<MSK>>

DEFINE ANDX (AC,MSK)<
	TXZ AC,<^-<MSK>>>

DEFINE XORX (AC,MSK)<
	TXC AC,<MSK>>

	SUBTTL TX -- TEST MASK

;CREATE THE TX MACRO DEFINITIONS

;THIS DOUBLE IRP CAUSES ALL COMBINATIONS OF MODIFICATION AND TESTING
;TO BE DEFINED

DEFINE ..DOTX (M,T)<
	IRP M,<
	IRP T,<
	  DEFINE TX'M'T (AC,MSK)<
		..TX(M'T,AC,<MSK>)>>>>

	..DOTX (<N,O,Z,C>,<,E,N,A>) ;DO ALL DEFINITIONS
	PURGE ..DOTX

;..TX
;ALL TX MACROS JUST CALL ..TX WHICH DOES ALL THE WORK

DEFINE ..TX(MT,AC,MSK)<
   ..TX1==MSK			;;EVAL EXPRESSION IF ANY
   .IFN ..TX1,ABSOLUTE,<
	TD'MT AC,[MSK]>
   .IF ..TX1,ABSOLUTE,<		;;MASK MUST BE TESTABLE
	..TX2==0		;;FLAG SAYS HAVEN'T DONE IT YET
	IFE <..TX1&^O777777B17>,<
	  ..TX2==1		;;LH 0, DO AS RH
	  TR'MT AC,..TX1>
	IFE ..TX2,<		;;IF HAVEN'T DONE IT YET,
	IFE <..TX1&^O777777>,<
	  ..TX2==1		;;RH 0, DO AS LH
	  TL'MT AC,(..TX1)>>
	IFE ..TX2,<		;;IF HAVEN'T DONE IT YET,
	  IFE <<..TX1>B53-^O777777>,< ;;IF LH ALL ONES, 
	    ..TX3 (MT,AC)>>	;;TRY Z,O,C SPECIAL CASES
	IFE ..TX2,<		;;IF HAVEN'T DONE IT YET,
	  IFE <..TX1+1>,<	;;TRY WORD ALL ONES
	    ..TX4 (MT,AC)>>
	IFE ..TX2,<		;;IF STILL HAVEN'T DONE IT,
	  TD'MT AC,[..TX1]>	;;MUST GIVE UP AND USE LITERAL
  >>
;SPECIAL CASE FOR LH ALL ONES

DEFINE ..TX3 (MT,AC)<
	IFIDN <MT><Z>,<		;;IF ZEROING WANTED
	  ..TX2==1
	  ANDI AC,^-..TX1>	;;CAN DO IT WITH ANDI
	IFIDN <MT><O>,<		;;IF SET TO ONES WANTED
	  ..TX2==1
	  ORCMI AC,^-..TX1>	;;CAN DO IT WITH IORCM
	IFIDN <MT><C>,<		;;IF COMPLEMENT WANTED
	  ..TX2==1
	  EQVI AC,^-..TX1>>	;;CAN DO IT WITH EQV

;SPECIAL CASE OF WORD ALL ONES

DEFINE ..TX4 (MT,AC)<
	IFIDN <MT><NN>,<
	  ..TX2==1
	  CAIN AC,0>		;;CAN DO FULL WORD COMPARE
	IFIDN <MT><NE>,<
	  ..TX2==1
	  CAIE AC,0>>

	SUBTTL JX -- JUMP ON MASK

;JXE -- JUMP IF MASKED BITS ARE EQUAL TO 0
;JXN -- JUMP IF MASKED BITS ARE NOT EQUAL TO 0
;JXO -- JUMP IF MASKED BITS ARE ALL ONES
;JXF -- JUMP IF MASKED BITS ARE NOT ALL ONES (FALSE)

DEFINE JXE (AC,MSK,BA)<
	..JX1==MSK		;;EVAL EXPRESSION IF ANY
	.IFN ..JX1,ABSOLUTE,<PRINTX MSK NOT ABSOLUTE
		..JX1==0>
	.IF ..JX1,ABSOLUTE,<
	.IF0 <<..JX1>-1B0>,<	;;IF MASK IS JUST B0,
		JUMPGE AC,BA>,<
	.IF0 <<..JX1>+1>,<	;;IF MASK IF FULL WORD,
	  JUMPE AC,BA>,<	;;USE GIVEN CONDITION
		TXNN (AC,..JX1)
		JRST BA>>>>

DEFINE JXN (AC,MSK,BA)<
	..JX1==MSK		;;EVAL EXPRESSION IF ANY
	.IFN ..JX1,ABSOLUTE,<PRINTX MSK NOT ABSOLUTE
		..JX1==0>
	.IF ..JX1,ABSOLUTE,<
	.IF0 <<..JX1>-1B0>,<	;;IF MASK IS JUST B0,
		JUMPL AC,BA>,<
	.IF0 <<..JX1>+1>,<	;;IF MASK IF FULL WORD,
	  JUMPN AC,BA>,<	;;USE GIVEN CONDITION
		TXNE (AC,..JX1)
		JRST BA>>>>

DEFINE JXO (AC,MSK,BA)<
	..JX1==MSK		;;EVAL EXPRESSION
	.IFN ..JX1,ABSOLUTE,<PRINTX MSK NOT ABSOLUTE
		..JX1==0>
	.IF ..JX1,ABSOLUTE,<
	.IF0 <<..JX1>-1B0>,<
		JUMPL AC,BA>,<
	..ONEB (..BT,MSK)	;;TEST MASK FOR ONLY ONE BIT ON
	.IF0 ..BT,<
	  SETCM .SAC,AC		;;GENERAL CASE, GET COMPLEMENTS OF BITS
	  JXE (.SAC,..JX1,BA)>,< ;;JUMP IF BITS WERE ORIGINALLY ONES
	    TXNE AC,..JX1	;;TEST AND JUMP
	    JRST BA>>>>

DEFINE JXF (AC,MSK,BA)<
	..JX1==MSK		;;EVAL EXPRESSION
	.IFN ..JX1,ABSOLUTE,<PRINTX MSK NOT ABSOLUTE
		..JX1==0>
	.IF ..JX1,ABSOLUTE,<
	.IF0 <<..JX1>-1B0>,<
		JUMPGE AC,BA>,<
	..ONEB (..BT,MSK)	;;TEST MASK FOR ONLY ONE BIT ON
	.IF0 ..BT,<
	  SETCM .SAC,AC		;;GENERAL CASE, GET COMPLEMENT OF BITS
	  JXN (.SAC,..JX1,BA)>,< ;;JUMP IF SOME ZEROS ORIGINALLY
	    TXNN AC,..JX1	;;TEST AND JUMP
	    JRST BA>>>>

	SUBTTL SUBFUNCTION MACROS

;.IF0 CONDITION, ACTION IF CONDITION 0, ACTION OTHERWISE

DEFINE .IF0 (COND,THEN,ELSE)<
	..IFT==COND		;;GET LOCAL VALUE FOR CONDITION
	IFE ..IFT,<
	THEN
	..IFT==0>		;;RESTORE IN CASE CHANGED BY NESTED .IF0
	IFN ..IFT,<
	ELSE>>

;CASE (NUMBER,<FIRST,SECOND,...,NTH>)

DEFINE .CASE (NUM,LIST)<
	..CSN==NUM
	..CSC==0
	IRP LIST,<
	IFE ..CSN-..CSC,<
	  STOPI
	  ..CAS1 (LIST)>
	..CSC==..CSC+1>>

DEFINE ..CAS1 (LIST)<
	LIST>

;TEST FOR FULL WORD, RH, LH, OR ARBITRARY BYTE

DEFINE ..TSIZ (SYM,MSK)<
	SYM==3			;;ASSUME BYTE UNLESS...
	IFE <MSK>+1,<SYM=0>	;;FULL WORD IF MASK IS -1
	IFE <MSK>-^O777777,<SYM==1> ;;RH IF MASK IS 777777
	IFE <MSK>-^O777777B17,<SYM==2>> ;;LH IF MAST IS 777777,,0

;TEST FOR LOC BEING AN AC -- SET SYM TO 1 IF AC, 0 IF NOT AC

DEFINE ..TSAC (SYM,LOC)<
	SYM==0			;;ASSUME NOT AC UNLESS...
	..TSA1==<Z LOC>		;;LOOK AT LOC
	.IF ..TSA1,ABSOLUTE,<	;;SEE IF WE CAN TEST VALUE
	  IFE ..TSA1&^O777777777760,<SYM==1>> ;;AC IF VALUE IS 0-17
	>

;TEST FOR SPECIFIC NTH CHARACTER OF ARG

DEFINE ..TSNC (SYM,NTH,STR,CH)<
	SYM==0			;;ASSUME NO
	..TSA1==0		;;COUNT CHARS
	IRPC STR,<
	  ..TSA1=..TSA1+1
	  IFE ..TSA1-NTH,<
	   IFIDN <STR><CH>,<
		SYM==1>		;;YES
	   STOPI>>>

;FUNCTION TO TEST FOR MASK CONTAINING EXACTLY ONE BIT. RETURNS
;1 IFF LEFTMOST BIT AND RIGHTMOST BIT ARE SAME

DEFINE ..ONEB (SYM,MSK)<
	SYM==<<<-<MSK>>&<MSK>>&<1B<^L<MSK>>>>>

;DEFAULT SCRACH AC

.SAC=16

	SUBTTL DEFSTR -- DEFINE DATA STRUCTURE

;DEFINE DATA STRUCTURE
; NAM - NAME OF STRUCTURE AS USED IN CODE
; LOCN - ADDRESS OF DATA
; POS - POSITION OF DATA WITHIN WORD (RIGHTMOST BIT NUMBER)
; SIZ - SIZE OF DATA (IN BITS) WITHIN WORD

DEFINE DEFSTR (NAM,LOCN,POS,SIZ)<
	NAM==<-1B<POS>+1B<POS-SIZ>> ;;ASSIGN SYMBOL TO HOLD MASK
	IF1,<IFDEF %'NAM,<PRINTX ?NAM ALREADY DEFINED>>
	DEFINE %'NAM (OP,AC,Y,MSK)<
	$'NAM==<Z LOCN>		;;LOCATION SYMBOL FOR DDT
	OP (<AC>,LOCN''Y,MSK)>>	;;DEFINE MACRO TO HOLD LOCATION

;ALTERNATE FORM OF DEFSTR -- TAKES MASK INSTEAD OF POS,SIZ

DEFINE MSKSTR (NAM,LOCN,MASK)<
	NAM==MASK		;;ASSIGN SYMBOL TO HOLD MASK
	IF1,<IFDEF %'NAM,<PRINTX ?NAM ALREADY DEFINED>>
	DEFINE %'NAM (OP,AC,Y,MSK)<
	$'NAM==<Z LOCN>		;;LOCATION SYMBOL FOR DDT
	OP (<AC>,LOCN''Y,MSK)>>	;;DEFINE MACRO TO HOLD LOCATION

;..STR0 - PROCESS INSTANCE OF STRUCTURE USAGE, SINGLE STRUCTURE CASE.

DEFINE ..STR0 (OP,AC,STR,Y)<
	IFNDEF STR,<PRINTX ?STR IS NOT DEFINED
	  OP (<AC>,Y,.FWORD)>	;;RESERVE A WORD, ASSUME WORD MASK
	IFDEF STR,<
	IFNDEF %'STR,<
	  OP (<AC>,Y,STR)>	;;ASSUME NO OTHER LOCN
	IFDEF %'STR,<
	  %'STR (OP,<AC>,Y,STR)>>> ;;DO IT
;..STR1, ..STR2, ..STR3, AND ..STR4 ARE INTERNAL MACROS FOR PROCESSING
;INSTANCES OF STRUCTURE USAGE.

DEFINE ..STR1 (OP,AC,STR,Y,CLL)<
	..NS==0			;;INIT COUNT OF STR'S
	IRP STR,<..NS=..NS+1>	;;COUNT STR'S
	IFE ..NS,<PRINTX ?EMPTY STRUCTURE LIST, OP>
	IFE ..NS-1,<		;;THE ONE CASE, CAN DO FAST
	  ..STR0 (OP,<AC>,<STR>,Y)>
	IFG ..NS-1,<		;;MORE THAN ONE, DO GENERAL CASE
	..ICNS			;;INIT REMOTE MACRO
	..CNS (<CLL (OP,<AC>,,>) ;;CONS ON CALL AND FIRST ARGS
	IRP STR,<		;;DO ALL NAMES IN LIST
	  IFNDEF STR,<PRINTX STR NOT DEFINED>
	  IFDEF STR,<
	  IFNDEF %'STR,<
	  ..CNS (<,STR,Y>)>	;;ASSUME NO OTHER LOCN
	  IFDEF %'STR,<
	  %'STR (..STR2,,Y,STR)> ;;STR MACRO WILL GIVE LOCN TO ..STR2
	  ..CNS (<)>)		;;CLOSE ARG LIST
	  ..GCNS		;;DO THIS AND PREVIOUS NAME
	  ..ICNS		;;REINIT CONS
	  ..CNS (<CLL (OP,<AC>>) ;;PUT ON FIRST ARGS
	  IFNDEF %'STR,<
	  ..CNS (<,STR,Y>)>	;;ASSUME NO OTHER LOCN
	  IFDEF %'STR,<
	  %'STR (..STR2,,Y,STR)>>> ;;PUT ON THIS ARG, END IRP
	..CNS (<,,)>)		;;CLOSE ARG LIST
	..GCNS>>		;;DO LAST CALL

;..STR2 -- CALLED BY ABOVE TO APPEND STRUCTURE NAME AND LOC TO ARG LIST

DEFINE ..STR2 (AA,LOC,STR)<
	..CNS (<,STR,LOC>)>	;;CONS ON NEXT ARG PAIR

;..STR3 -- CHECK FOR ALL STRUCTURES IN SAME REGISTER

DEFINE ..STR3 (OP,AC,S1,L1,S2,L2)<
	IFDIF <L1><L2>,<
	  IFNB <L1>,<
	    OP (<AC>,L1,..MSK)	;;DO ACCUMULATED STUFF
	    IFNB <L2>,<PRINTX S1 AND S2 ARE IN DIFFERENT WORDS>>
	  ..MSK==0>		;;INIT MASK
	IFNB <L2>,<
	  ..MSK=..MSK!<S2>>>

;..STR4 -- COMPARE SUCCESSIVE ITEMS, DO SEPARATE OPERATION IF
;DIFFERENT WORDS ENCOUNTERED

DEFINE ..STR4 (OP,AC,S1,L1,S2,L2)<
	IFDIF <L1><L2>,<	;;IF THIS DIFFERENT FROM PREVIOUS
	  IFNB <L1>,<
	    OP (<AC>,L1,..MSK)>	;;DO PREVIOUS
	  ..MSK==0>		;;REINIT MASK
	IFNB <L2>,<
	  ..MSK=..MSK!<S2>>>	;;ACCUMULATE MASK

;..STR5 - SAME AS ..STR4 EXCEPT GIVES EXTRA ARG IF MORE STUFF TO
;FOLLOW.

DEFINE ..STR5 (OP,AC,S1,L1,S2,L2)<
	IFDIF <L1><L2>,<	;;IF THIS DIFFERENT FROM PREVIOUS,
	  IFNB <L1>,<
	    IFNB <L2>,<		;;IF MORE TO COME,
		OP'1 (AC,L1,..MSK)> ;;DO VERSION 1
	    IFB <L2>,<		;;IF NO MORE,
		OP'2 (AC,L1,..MSK)>> ;;DO VERSION 2
	  ..MSK==0>		;;REINIT MASK
	IFNB <L2>,<
	  ..MSK=..MSK!<S2>>>	;;ACCUMULATE MASK

;'REMOTE' MACROS USED TO BUILD UP ARG LIST

;INITIALIZE CONS -- DEFINES CONS

DEFINE ..ICNS <
   DEFINE ..CNS (ARG)<
	..CNS2 <ARG>,>

   DEFINE ..CNS2 (NEW,OLD)<
	DEFINE ..CNS (ARG)<
	  ..CNS2 <ARG>,<OLD'NEW>>>
   >

;GET CONS -- EXECUTE STRING ACCUMULATED

DEFINE ..GCNS <
   DEFINE ..CNS2 (NEW,OLD)<
	  OLD>			;;MAKE ..CNS2 DO THE STUFF
	..CNS ()>		;;GET ..CNS2 CALLED WITH THE STUFF

;SPECIFIC CASES

;LOAD, STORE
; AC - AC OPERAND
; STR - STRUCTURE NAME
; Y - (OPTIONAL) ADDITIONAL SPECIFICATION OF DATA LOCATION

DEFINE LOAD (AC,STR,Y)<
	..STR0 (..LDB,AC,STR,Y)>

   DEFINE ..LDB (AC,LOC,MSK)<
	..TSIZ (..PST,MSK)
	.CASE ..PST,<<
		MOVE AC,LOC>,<
		HRRZ AC,LOC>,<
		HLRZ AC,LOC>,<
		LDB AC,[POINTR (LOC,MSK)]>>>

DEFINE STOR (AC,STR,Y)<
	..STR0 (..DPB,AC,STR,Y)>

   DEFINE ..DPB (AC,LOC,MSK)<
	..TSIZ (..PST,MSK)
	.CASE ..PST,<<
		MOVEM AC,LOC>,<
		HRRM AC,LOC>,<
		HRLM AC,LOC>,<
		DPB AC,[POINTR (LOC,MSK)]>>>

;SET TO ZERO

DEFINE SETZRO (STR,Y)<
	..STR1 (..TQZ,,<STR>,Y,..STR4)>

   DEFINE ..TQZ (AC,LOC,MSK)<
	..TSIZ (..PST,MSK)	;;SET ..PST TO CASE NUMBER
	.CASE ..PST,<<
		SETZM LOC>,<	;;FULL WORD
		HLLZS LOC>,<	;;RH
		HRRZS LOC>,<	;;LH
	  ..TSAC (..ACT,LOC)	;;SEE IF LOC IS AC
	  .IF0 ..ACT,<
		MOVX .SAC,MSK	;;NOT AC
		ANDCAM .SAC,LOC>,<
		..TX (Z,LOC,MSK)>>>>

;SET TO ONE

DEFINE SETONE (STR,Y)<
	..STR1 (..TQO,,<STR>,Y,..STR4)>

   DEFINE ..TQO (AC,LOC,MSK)<
	..TSIZ (..PST,MSK)
	.CASE ..PST,<<
		SETOM LOC>,<
		HLLOS LOC>,<
		HRROS LOC>,<
	  ..TSAC (..ACT,LOC)
	  .IF0 ..ACT,<
		MOVX .SAC,MSK
		IORM .SAC,LOC>,<
		..TX (O,LOC,MSK)>>>>

;SET TO COMPLEMENT

DEFINE SETCMP (STR,Y)<
	..STR1 (..TQC,,<STR>,Y,..STR4)>

   DEFINE ..TQC (AC,LOC,MSK)<
	..TSIZ (..PST,MSK)
	.IF0 ..PST,<		;;IF FULL WORD,
		SETCMM LOC>,<	;;CAN USE SETCMM
	  ..TSAC (..ACT,LOC)	;;OTHERWISE, CHECK FOR AC
	  .IF0 ..ACT,<
		MOVX .SAC,MSK
		XORM .SAC,LOC>,<
		..TX(C,LOC,MSK)>>>

;INCREMENT, DECREMENT FIELD

DEFINE INCR (STR,Y)<
	..STR0 (.INCR0,,<STR>,Y)>

   DEFINE .INCR0 (AC,LOC,MSK)<
	..PST==MSK&<-MSK>	;;GET LOWEST BIT
	.IF0 ..PST-1,<
		AOS LOC>,<	;;BIT 35, CAN USE AOS
		MOVX .SAC,..PST	;;LOAD A ONE IN THE APPROPRIATE POSITION
		ADDM .SAC,LOC>>

DEFINE DECR (STR,Y)<
	..STR0 (.DECR0,,<STR>,Y)>

   DEFINE .DECR0 (AC,LOC,MSK)<
	..PST==MSK&<-MSK>
	.IF0 ..PST-1,<
		SOS LOC>,<	;;BIT 35, CAN USE SOS
		MOVX .SAC,-..PST ;;LOAD -1 IN APPROPRIATE POSITION
		ADDM .SAC,LOC>>

;GENERAL DEFAULT, TAKES OPCODE

DEFINE OPSTR (OP,STR,Y)<
	..STR0 (.OPST1,<OP>,<STR>,Y)>

   DEFINE .OPST1 (OP,LOC,MSK)<
	..TSIZ (..PST,MSK)
	.IF0 ..PST,<
		OP LOC>,<	;;FULL WORD, USE GIVEN OP DIRECTLY
		..LDB .SAC,LOC,MSK ;;OTHERWISE, GET SPECIFIED BYTE
		OP .SAC>>

DEFINE OPSTRM (OP,STR,Y)<
	..STR0 (.OPST2,<OP>,<STR>,Y)>

   DEFINE .OPST2 (OP,LOC,MSK)<
	..TSIZ (..PST,MSK)
	.IF0 ..PST,<
		OP LOC>,<	;;FULL WORD, USE OP DIRECTLY
		..LDB .SAC,LOC,MSK
		OP .SAC
		..DPB .SAC,LOC,MSK>>

;JUMP IF ALL FIELDS ARE 0 (ONE REGISTER AT MOST)

DEFINE JE (STR,Y,BA)<
	..STR1 (..JE,<BA>,<STR>,Y,..STR3)>

   DEFINE ..JE (BA,LOC,MSK)<
	..TSAC (..ACT,LOC)	;;SEE IF AC
	.IF0 ..ACT,<
	  ..TSIZ (..PST,MSK)	;;SEE WHICH CASE
	  .CASE ..PST,<<
		SKIPN LOC	;;FULL WORD, TEST IN MEMORY
		JRST BA>,<
		HRRZ .SAC,LOC	;;RIGHT HALF, GET IT
		JUMPE .SAC,BA>,<
		HLRZ .SAC,LOC	;;LEFT HALF, GET IT
		JUMPE .SAC,BA>,<
		MOVE .SAC,LOC	;;NOTA, GET WORD
		JXE (.SAC,MSK,<BA>)>>>,<
	  JXE (LOC,MSK,<BA>)>>

;JUMP IF NOT ALL FIELDS ARE 0 (ONE REGISTER AT MOST)

DEFINE JN (STR,Y,BA)<
	..STR1 (..JN,<BA>,<STR>,Y,..STR3)>

   DEFINE ..JN (BA,LOC,MSK)<
	..TSAC (..ACT,LOC)	;;SEE IF AC
	.IF0 ..ACT,<
	  ..TSIZ (..PST,MSK)
	  .CASE ..PST,<<
		SKIPE LOC	;;FULL WORD, TEST IN MEMORY
		JRST BA>,<
		HRRZ .SAC,LOC	;;RIGHT HALF, GET IT
		JUMPN .SAC,BA>,<
		HLRZ .SAC,LOC	;;LEFT HALF, GET IT
		JUMPN .SAC,BA>,<
		MOVE .SAC,LOC	;;NOTA, GET WORD
		JXN (.SAC,MSK,<BA>)>>>,<
	  JXN (LOC,MSK,<BA>)>>

;JOR - JUMP ON 'OR' OF ALL FIELDS

DEFINE JOR (STR,Y,BA)<
	..STR1 (..JN,<BA>,<STR>,Y,..STR4)>

;JNAND - JUMP ON NOT 'AND' OF ALL FIELDS

DEFINE JNAND (STR,Y,BA)<
	..STR1 (..JNA3,<BA>,<STR>,Y,..STR4)>

   DEFINE ..JNA3 (BA,LOC,MSK)<
	..TSAC (..ACT,LOC)
	.IF0 ..ACT,<
	  SETCM .SAC,LOC	;;NOT AC, GET COMPLEMENT OF WORD
	  JXN (.SAC,MSK,<BA>)>,<	;;JUMP IF ANY BITS ORIGINALLY OFF
	  JXF (LOC,MSK,<BA>)>>	;;DO AC CASE

;JAND - JUMP ON 'AND' OF ALL FIELDS

DEFINE JAND (STR,Y,BA,%TG)<
	..STR1 (..JAN,<%TG,<BA>>,<STR>,Y,..STR5)
%TG:>

   DEFINE ..JAN1 (BA1,BA2,LOC,MSK)<
	..JNA3 (BA1,LOC,MSK)>	;;DO JUMP NAND TO LOCAL TAG

   DEFINE ..JAN2 (BA1,BA2,LOC,MSK)<
	..TSAC (..ACT,LOC)
	.IF0 ..ACT,<
	  SETCM .SAC,LOC	;;NOT AC, GET COMPLEMENT OF WORD
	  JXE (.SAC,MSK,<BA2>)>,<	;;JUMP IF ALL BITS ORIGINALLY ONES
	  JXO (LOC,MSK,<BA2>)>> ;;DO AC CASE

;JNOR - JUMP ON NOT 'OR' OF ALL FIELDS

DEFINE JNOR (STR,Y,BA,%TG)<
	..STR1 (..JNO,<%TG,<BA>>,<STR>,Y,..STR5)
%TG:>

   DEFINE ..JNO1 (BA1,BA2,LOC,MSK)<
	..JN (BA1,LOC,MSK)>	;;DO JUMP OR TO LOCAL TAG

   DEFINE ..JNO2 (BA1,BA2,LOC,MSK)<
	..JE (<BA2>,LOC,MSK)>	;;DO JUMP NOR TO GIVEN TAG

;TEST AND MODIFY GROUP USING DEFINED STRUCTURES.  TEST-ONLY AND
;MODIFY-ONLY PROVIDED FOR COMPLETENESS.
;GENERATES EXACTLY ONE INSTRUCTION

DEFINE ..DOTY (M,T)<		;;MACRO TO DEFINE ALL CASES
	IRP M,<
	IRP T,<
	  DEFINE TQ'M'T (STR,Y)<
	    ..STR1 (..TY,M'T,<STR>,Y,..STR3)>>>>

	..DOTY (<N,O,Z,C>,<,E,N,A>) ;DO 16 DEFINES
	PURGE ..DOTY

;SPECIAL DEFINE FOR THE TWO CASES WHICH CAN TAKE MEMORY ARG
;*NOTE* MAY GENERATE MORE THAN ONE INSTRUCTION - CANNOT BE SKIPPED

DEFINE TMNE (STR,Y)<
	..STR1 (..TYNE,,<STR>,Y,..STR3)>

DEFINE ..TYNE (MT,LOC,MSK)<
	..TSAC (..ACT,LOC)	;;SEE IF LOC IS AC
	.IF0 ..ACT,<
	  ..JX1==MSK
	  .IF0 <..JX1-1B0>,<
		SKIPGE LOC>,<
	    .IF0 <..JX1+1>,<
		SKIPE LOC>,<
		MOVE .SAC,LOC
		TXNE .SAC,MSK>>>,<
		TXNE LOC,MSK>>

DEFINE TMNN (STR,Y)<
	..STR1 (..TYNN,,<STR>,Y,..STR3)>

DEFINE ..TYNN (MT,LOC,MSK)<
	..TSAC (..ACT,LOC)	;;SEE IF LOC IS AC
	.IF0 ..ACT,<
	  ..JX1==MSK
	  .IF0 <..JX1-1B0>,<
		SKIPL LOC>,<
	    .IF0 <..JX1+1>,<
		SKIPN LOC>,<
		MOVE .SAC,LOC
		TXNN .SAC,MSK>>>,<
		TXNN LOC,MSK>>

;ALL TY MACROS CALL ..TY AFTER INITIAL STRUCTURE PROCESSING

DEFINE ..TY (MT,LOC,MSK)<
	..TSAC (..ACT,LOC)	;;SEE IF LOC IS AC
	.IF0 ..ACT,<
		PRINTX ?TQ'MT - LOC NOT IN AC>,<
		TX'MT LOC,MSK>>

	SUBTTL BLOCK MACROS

;MACROS TO PROVIDE SOME BLOCK HANDLING OF CODE

;DO. - LOOP STRUCTURE, DECLARES TOP OF LOOP
; LOOP. - JUMPS TO TOP OF LOOP
; EXIT. - EXITS LOOP
; TOP. - TAG AT TOP OF LOOP FOR JUMPS, E.G. SOJG T4,TOP.
; ENDLP. - TAG AT END OF LOOP FOR JUMPS, E.G. SOJL T4,ENDLP.

DEFINE DO. (%TGB,%TGE)<
	..SVLD			;;SAVE CURRENT BLOCK
%TGB:!				;;TOP OF LOOP
  DEFINE OD. <
%TGE:!				;;END OF LOOP
	.POPX>			;;RESTORE DEFS
  DEFINE LOOP. <
	JRST %TGB>		;;LOOP TO TOP
  DEFINE TOP. <%TGB>		;;LABEL AT TOP FOR JUMPS
  DEFINE ENDLP. <%TGE>		;;LABEL AT END FOR JUMPS
  DEFINE EXIT. <
	JRST %TGE>>		;;EXIT LOOP

DEFINE ENDDO. <
	OD.>

;;;IFE STANSW -- ORIGINAL DEC VERSION
;;;DEFINE ..SVLD (%SY1,%SY2,%SY3,%SY4)<
;;;	SYN OD.,%SY1
;;;	SYN LOOP.,%SY2
;;;	SYN TOP.,%SY3
;;;	SYN EXIT.,%SY4
;;;	.PSHX <
;;;	 SYN %SY1,OD.
;;;	 SYN %SY2,LOOP.
;;;	 SYN %SY3,TOP.
;;;	 SYN %SY4,EXIT.>>
;;;END IFE STANSW -- ORIGINAL DEC VERSION
;;;IFN STANSW -- STANFORD VERSION (ENDLP. BUGFIX)
DEFINE ..SVLD (%SY1,%SY2,%SY3,%SY4,%SY5)<
	SYN OD.,%SY1
	SYN LOOP.,%SY2
	SYN TOP.,%SY3
	SYN EXIT.,%SY4
	SYN ENDLP.,%SY5
	.PSHX <
	 SYN %SY1,OD.
	 SYN %SY2,LOOP.
	 SYN %SY3,TOP.
	 SYN %SY4,EXIT.
	 SYN %SY5,ENDLP.>>
;;;END IFN STANSW -- STANFORD VERSION (ENDLP. BUGFIX)

;IFNSK., IFSKP. - "IF NO SKIP", "IF SKIP"

;These macros cause the following code to be conditionally executed
;depending on whether the preceding instruction(s) skipped or not.
;The following code is ended with ENDIF., with ELSE. optional
;within the range.

;Note: both of these result in the same or fewer instructions than
;the use of literals to handle the same cases.
;Also, since the code is not in literals, the binary appears in the
;listing, and the code is easier to follow with DDT.
;If the preceding skip can be written in either sense, it is better
;to use IFSKP. because one fewer instructions will be generated.

;IFSKP. and IFNSK. have an alternate form where the consequence code
;is given as a macro argument.  In the normal case, no macro argument is given.

;"IF NO SKIP" CONSEQUENCE-CODE ALTERNATIVE-CODE
;If the instruction(s) preceding the macro does not skip, the 'consequence
; code' will be executed; otherwise (i.e. if the instruction skips) the
; 'alternative code' will be executed.

DEFINE IFNSK. (NSCOD,SKCOD,%TG1,%TG2)<
   IFB <NSCOD'SKCOD>,<		;;THE REGULAR FORM
	..SVDF			;;SAVE DEFINITIONS OF OUTER BLOCK
	TRNA			;;SKIP
	JRST %TG1		;;JUMP PAST CODE
   DEFINE ..TAGF (INST,PCT)<
	INST %TG1''PCT>		;;SAVE THE FALSE TAG
   DEFINE ..TAGE (INST,PCT)<
	INST %TG2''PCT>		;;SAVE THE END TAG
	>
   IFNB <NSCOD'SKCOD>,<		;;THE ALTERNATE FORM
	JRST %TG1		;;THE NOSKIP CASE
	SKCOD
	JRST %TG2
%TG1:!	NSCOD
%TG2:!>>

;If JSYS Error

DEFINE IFJER. (NSCOD,SKCOD,%TG1,%TG2,%TG3)<
   IFB <NSCOD'SKCOD>,<		;;THE REGULAR FORM
	..SVDF			;;SAVE DEFINITIONS OF OUTER BLOCK
	ERJMP %TG3		;;SKIP
	JRST %TG1		;;JUMP PAST CODE
%TG3:!
   DEFINE ..TAGF (INST,PCT)<
	INST %TG1''PCT>		;;SAVE THE FALSE TAG
   DEFINE ..TAGE (INST,PCT)<
	INST %TG2''PCT>		;;SAVE THE END TAG
	>
   IFNB <NSCOD'SKCOD>,<		;;THE ALTERNATE FORM
	ERJMP %TG1		;;THE NOSKIP CASE
	SKCOD
	JRST %TG2
%TG1:!	NSCOD
%TG2:!>>

;OBSOLETE NAME

DEFINE IFNES. (ARG1,ARG2)<
	PRINTX % IFNES. should be changed to IFJER.
	IFJER. <ARG1>,<ARG2>>


;"IF SKIP" CONSEQUENCE-CODE
;If the instruction(s) preceding the macro skips, the 'consequence
; code' will be executed.

DEFINE IFSKP. (SKCOD,%TG,%TG2)<
   IFB <SKCOD>,<		;;REGULAR FORM
	..SVDF			;;SAVE DEFINITIONS OF OUTER BLOCK
	JRST %TG
   DEFINE ..TAGF (INST,PCT)<
	INST %TG''PCT>		;;SAVE FALSE TAG
   DEFINE ..TAGE (INST,PCT)<
	INST %TG2''PCT>		;;SAVE END TAG
	>
   IFNB <SKCOD>,<
	JRST %TG
	SKCOD
%TG:!>>

;If No JSYS Error

DEFINE IFNJE. (SKCOD,%TG,%TG2)<
   IFB <SKCOD>,<		;;REGULAR FORM
	..SVDF			;;SAVE DEFINITIONS OF OUTER BLOCK
	ERJMP %TG
   DEFINE ..TAGF (INST,PCT)<
	INST %TG''PCT>		;;SAVE FALSE TAG
   DEFINE ..TAGE (INST,PCT)<
	INST %TG2''PCT>		;;SAVE END TAG
	>
   IFNB <SKCOD>,<
	ERJMP %TG
	SKCOD
%TG:!>>

;OBSOLETE NAME

DEFINE IFESK. (ARG)<
	PRINTX % IFESK. should be changed to IFNJE.
	IFNJE. <ARG>>

;CONDITIONALS WHICH REPRESENT JUMP CASES - I.E. AC L, LE, G, ETC.
; IF CONDITION IS SATISFIED, DO BRACKETTED CODE

DEFINE IFE. (AC,%TG1,%TG2)<
	JUMPN AC,%TG1		;;JUMP IF NOT CONDITION
	..SVDF			;;SAVE OUTER BLOCK
   DEFINE ..TAGF (INST,PCT)<
	INST %TG1''PCT>		;;DEFINE FALSE TAG
   DEFINE ..TAGE (INST,PCT)<
	INST %TG2''PCT>		;;DEFINE END TAG
	>

DEFINE IFN. (AC,%TG1,%TG2)<
	JUMPE AC,%TG1		;;JUMP IF NOT CONDITION
	..SVDF			;;SAVE OUTER BLOCK
   DEFINE ..TAGF (INST,PCT)<
	INST %TG1''PCT>		;;DEFINE FALSE TAG
   DEFINE ..TAGE (INST,PCT)<
	INST %TG2''PCT>		;;DEFINE END TAG
	>

DEFINE IFG. (AC,%TG1,%TG2)<
	JUMPLE AC,%TG1		;;JUMP IF NOT CONDITION
	..SVDF			;;SAVE OUTER BLOCK
   DEFINE ..TAGF (INST,PCT)<
	INST %TG1''PCT>		;;DEFINE FALSE TAG
   DEFINE ..TAGE (INST,PCT)<
	INST %TG2''PCT>		;;DEFINE END TAG
	>

DEFINE IFGE. (AC,%TG1,%TG2)<
	JUMPL AC,%TG1		;;JUMP IF NOT CONDITION
	..SVDF			;;SAVE OUTER BLOCK
   DEFINE ..TAGF (INST,PCT)<
	INST %TG1''PCT>		;;DEFINE FALSE TAG
   DEFINE ..TAGE (INST,PCT)<
	INST %TG2''PCT>		;;DEFINE END TAG
	>

DEFINE IFLE. (AC,%TG1,%TG2)<
	JUMPG AC,%TG1		;;JUMP IF NOT CONDITION
	..SVDF			;;SAVE OUTER BLOCK
   DEFINE ..TAGF (INST,PCT)<
	INST %TG1''PCT>		;;DEFINE FALSE TAG
   DEFINE ..TAGE (INST,PCT)<
	INST %TG2''PCT>		;;DEFINE END TAG
	>

DEFINE IFL. (AC,%TG1,%TG2)<
	JUMPGE AC,%TG1		;;JUMP IF NOT CONDITION
	..SVDF			;;SAVE OUTER BLOCK
   DEFINE ..TAGF (INST,PCT)<
	INST %TG1''PCT>		;;DEFINE FALSE TAG
   DEFINE ..TAGE (INST,PCT)<
	INST %TG2''PCT>		;;DEFINE END TAG
	>

DEFINE IFXE. (AC,MASK,%TG1,%TG2)<
	JXN AC,MASK,%TG1	;;JUMP IF NOT CONDITION
	..SVDF			;;SAVE OUTER BLOCK
   DEFINE ..TAGF (INST,PCT)<
	INST %TG1''PCT>		;;DEFINE FALSE TAG
   DEFINE ..TAGE (INST,PCT)<
	INST %TG2''PCT>		;;DEFINE END TAG
	>

DEFINE IFXN. (AC,MASK,%TG1,%TG2)<
	JXE AC,MASK,%TG1	;;JUMP IF NOT CONDITION
	..SVDF			;;SAVE OUTER BLOCK
   DEFINE ..TAGF (INST,PCT)<
	INST %TG1''PCT>		;;DEFINE FALSE TAG
   DEFINE ..TAGE (INST,PCT)<
	INST %TG2''PCT>		;;DEFINE END TAG
	>

DEFINE IFQE. (STR,Y,%TG1,%TG2)<
	JN <STR>,<Y>,%TG1	;;JUMP IF NOT CONDITION
	..SVDF			;;SAVE OUTER BLOCK
   DEFINE ..TAGF (INST,PCT)<
	INST %TG1''PCT>		;;DEFINE FALSE TAG
   DEFINE ..TAGE (INST,PCT)<
	INST %TG2''PCT>		;;DEFINE END TAG
	>

DEFINE IFQN. (STR,Y,%TG1,%TG2)<
	JE <STR>,<Y>,%TG1	;;JUMP IF NOT CONDITION
	..SVDF			;;SAVE OUTER BLOCK
   DEFINE ..TAGF (INST,PCT)<
	INST %TG1''PCT>		;;DEFINE FALSE TAG
   DEFINE ..TAGE (INST,PCT)<
	INST %TG2''PCT>		;;DEFINE END TAG
	>

;GENERAL CASES WITHIN CONDITIONALS

;"AND SKIP"

DEFINE ANSKP. <
	..TAGF (JRST,)>		;;JUMP TO 'FALSE'

DEFINE ANNSK. <
	TRNA
	..TAGF (JRST,)>		;;JUMP TO 'FALSE'

DEFINE ELSE. <....U>		;;UNDEFINED UNTIL BLOCK ENTERED
DEFINE ENDIF. <....U>
DEFINE ..TAGF <....U>
DEFINE ..TAGE <....U>

;"AND E" ETC.

DEFINE ANDE. (AC)<
	..TAGF (<JUMPN AC,>,)>	;;JUMP IF NOT CONDITION

DEFINE ANDN. (AC)<
	..TAGF (<JUMPE AC,>,)>	;;JUMP IF NOT CONDITION

DEFINE ANDG. (AC)<
	..TAGF (<JUMPLE AC,>,)>	;;JUMP IF NOT CONDITION

DEFINE ANDGE. (AC)<
	..TAGF (<JUMPL AC,>,)>	;;JUMP IF NOT CONDITION

DEFINE ANDLE. (AC)<
	..TAGF (<JUMPG AC,>,)>	;;JUMP IF NOT CONDITION

DEFINE ANDL. (AC)<
	..TAGF (<JUMPGE AC,>,)>	;;JUMP IF NOT CONDITION

DEFINE ANDXE. (AC,MASK)<
	..TAGF (<JXN AC,MASK,>,)> ;;JUMP IF NOT CONDITION

DEFINE ANDXN. (AC,MASK)<
	..TAGF (<JXE AC,MASK,>,)> ;;JUMP IF NOT CONDITION

DEFINE ANDQE. (STR,Y)<
	..TAGF (<JN <STR>,<Y>,>,)> ;;JUMP IF NOT CONDITION

DEFINE ANDQN. (STR,Y)<
	..TAGF (<JE <STR>,<Y>,>,)> ;;JUMP IF NOT CONDITION

;LOCAL WORKER MACROS

;THIS INITS THE DEFINITIONS OF ELSE. AND ENDIF. WHEN ENTERING A
;NEW BLOCK.

DEFINE ..INDF <
 DEFINE ELSE. <
	..TAGE (JRST,)		;;JUMP TO END
	..TAGF (,<:!>)		;;DEFINE THE FALSE TAG
	SYN ..TAGE,..TAGF	;;MAKE FALSE EQUIVALENT TO END
   DEFINE ELSE. <....U>>	;;ELSE CAN APPEAR ONCE ONLY

 DEFINE ENDIF. <
	..TAGF (,<:!>)		;;DEFINE FALSE TAG
	..RSDF>			;;RESTORE DEFINITIONS OF OUTER BLOCK
   >

;SAVE DEFINITIONS

DEFINE ..SVDF (%SY1,%SY2,%SY3,%SY4)<
	SYN ELSE.,%SY1
	SYN ENDIF.,%SY2
	SYN ..TAGF,%SY3
	SYN ..TAGE,%SY4
	.PSHX <
	  SYN %SY1,ELSE.
	  SYN %SY2,ENDIF.
	  SYN %SY3,..TAGF
	  SYN %SY4,..TAGE>
	..INDF			;;REINIT DEFS
	      >

DEFINE ..RSDF <
	.POPX>

;MACROS TO PUSH/POP STRINGS

DEFINE .PSHX (STUFF)<
	.PSHX1 (.PSHX2,<STUFF>)>

DEFINE .PSHX1 (WCH,STUFF)<
	WCH (<STUFF>)>

DEFINE .PSHX2 (OLD)<
   DEFINE .PSHX1 (WCH,STUFF)<
	WCH (<<STUFF>,<OLD>>)>>

DEFINE .POPX <
	.PSHX1 (.POPX2)>

DEFINE .POPX2 (STUFF)<
	.POPX4 STUFF>

DEFINE .POPX4 (JUNK,STUFF)<
	.POPX3 STUFF>

DEFINE .POPX3 (TOP,REST)<
	TOP
   DEFINE .PSHX1 (WCH,STUFF)<
	WCH (<<STUFF>,<REST>>)>>

	SUBTTL CALL, RET, JSERR

   IFE REL,<
	EXTERN JSERR0,JSMSG0,JSHLT0,R,RSKP>

;CALL AND RETURN

.AC1==1				;ACS FOR JSYS ARGS
.AC2==2
.AC3==3
.A16==16			;TEMP FOR STKVAR AND TRVAR
P=17				;STACK POINTER

OPDEF CALL [PUSHJ P,0]
OPDEF RET [POPJ P,0]

;ABBREVIATION FOR  CALL, RET, RETSKP

OPDEF CALLRET [JRST]
.NODDT CALLRET

DEFINE RETSKP <JRST RSKP>

;MACRO TO PRINT MESSAGE ON TERMINAL

DEFINE TMSG ($MSG)<
	HRROI .AC1,[ASCIZ \$MSG\]
	PSOUT>

;MACRO TO OUTPUT MESSAGE TO FILE
; ASSUMES JFN ALREADY IN .AC1

DEFINE FMSG ($MSG)<
	HRROI .AC2,[ASCIZ \$MSG\]
	MOVEI .AC3,0
	SOUT>

;MACRO TO PRINT MESSAGE FOR LAST ERROR, RETURNS +1

DEFINE PERSTR ($MSG)<
   IFNB <$MSG>,<
	TMSG <$MSG>>
	CALL JSMSG0>

;MACRO TO PRINT JSYS ERROR MESSAGE, RETURNS +1 ALWAYS

OPDEF JSERR[<CALL JSERR0>]
OPDEF EJSERR[<JUMP 17,JSERR0>]	;Since MACRO couldn't handle OPDEF of an OPDEF
				;  (i.e. ERCAL) defined elsewhere, use JUMP 17,
				;  instead

;MACRO FOR FATAL JSYS ERROR, PRINTS MSG THEN HALTS

OPDEF JSHLT[<CALL JSHLT0>]
OPDEF EJSHLT[<JUMP 17,JSHLT0>]	;Since MACRO couldn't handle OPDEF of an OPDEF
				;  (i.e. ERCAL) defined elsewhere, use JUMP 17,
				;  instead

;PRINT ERROR MESSAGE IF JSYS FAILS

DEFINE ERMSG(TEXT),<
	ERJMP	[TMSG <? TEXT>
		 JSHLT]
>

;MAKE SYMBOLS EXTERN IF NOT ALREADY DEFINED

DEFINE EXT (SYM)<
   IF2,<
	IRP SYM,<
	IFNDEF SYM,<EXTERN SYM
	SUPPRE SYM>>>>

;MACRO TO ADD BREAK CHARACTER TO FOUR WORD BREAK MASK (W0., W1., W2., W3.)

DEFINE BRKCH. (%%V,V2)
<
%%FOO==%%V
	BRK0 (%%FOO,V2,0)
>

;MACRO TO REMOVE CHARACTER

DEFINE UNBRK. (%%V,V2)
<
%%FOO==%%V
	BRK0 (%%FOO,V2,1)
>

DEFINE BRK0 (%%11,V2,FLAVOR)
<	..V22==%%11
	..V1==%%11
	IFNB <V2>,<..V22==V2>
REPEAT ..V22-<%%11>+1,<	;;BRACKETS AROUND %%11 IN CASE ITS AN EXPRESSION
	%%W==..V1/^D32	;;DECIDE WHICH WORD CHARACTER GOES IN
	%%X==..V1-%%W*^D32	;;CALCULATE BIT POSITION WITHIN WORD
	IFE FLAVOR,BRKC1 \"<%%W+"0">	;;MODIFY CORRECT MASK WORD
	IFN FLAVOR,BRKC2 \"<%%W+"0">
	..V1==..V1+1
		   >
>

DEFINE BRKC1 (ARG1)
<	W'ARG1'.==W'ARG1'.!<1B<%%X>>
>

DEFINE BRKC2 (ARG1)
<	W'ARG1'.==W'ARG1'.&<-1-1B<%%X>>
>

;MACRO TO INITIALIZE 4-WORD 12-BIT CHARACTER BREAK MASK

DEFINE BRINI.(A0<0>,A1<0>,A2<0>,A3<0>)
<
W0.==A0
W1.==A1				;INITIALIZE BREAK MASK
W2.==A2
W3.==A3
>

;MACRO TO DEFINE A BREAK SET

DEFINE BRMSK. (INI0,INI1,INI2,INI3,ALLOW,DISALW)
<	BRINI. INI0,INI1,INI2,INI3	;;SET UP INITIAL MASK
	IRPC ALLOW,<	UNBRK. "ALLOW">	;;DON'T BREAK ON CHARS TO BE ALLOWED IN FIELD
	IRPC DISALW,<	BRKCH. "DISALW">	;;BREAK ON CHARACTERS NOT ALLOWED
	EXP W0.,W1.,W2.,W3.		;;STORE RESULTANT MASK IN MEMORY
>

;COMND - MACRO FOR BUILDING FUNCTION DESCRIPTOR BLOCK
;THIS IS THE OLD ONE, BEFORE .CMBRK EXISTED.  USE FLDBK. FOR SPECIFYING
;BREAK SETS

DEFINE FLDDB. (TYP,FLGS,DATA,HLPM,DEFM,LST)<
	..XX==<FLD(TYP,CM%FNC)>+FLGS+<0,,LST>
   IFNB <HLPM>,<..XX=CM%HPP!..XX>
   IFNB <DEFM>,<..XX=CM%DPP!..XX>
	..XX
   IFNB <DATA>,<DATA>
   IFB <DATA>,<0>
   IFNB <HLPM>,<POINT 7,[ASCIZ HLPM]>
   IFB <HLPM>,<IFNB <DEFM>,<0>>
   IFNB <DEFM>,<POINT 7,[ASCIZ \DEFM\]>>

;COMND - MACRO FOR BUILDING FUNCTION DESCRIPTOR BLOCK

DEFINE FLDBK. (TYP,FLGS,DATA,HLPM,DEFM,BRKADR,LST)<
	..XX==<FLD(TYP,CM%FNC)>+FLGS+<Z LST>
   IFNB <HLPM>,<..XX=CM%HPP!..XX>
   IFNB <DEFM>,<..XX=CM%DPP!..XX>
   IFNB <BRKADR>,<..XX=CM%BRK!..XX>
	..XX
   IFNB <DATA>,<DATA>
   IFB <DATA>,<0>
   IFNB <HLPM>,<POINT 7,[ASCIZ HLPM]>
   IFB <HLPM>,<IFNB <DEFM'BRKADR>,<0>>
   IFB <DEFM>,<IFNB <BRKADR>,<0>>
   IFNB <DEFM>,<POINT 7,[ASCIZ \DEFM\]>
   IFNB <BRKADR>,<BRKADR>
   >

;USEFUL EXTENDED ADDRESSING DEFINITIONS

OPDEF	XMOVEI [SETMI]		;EXTENDED MOVE IMMEDIATE
OPDEF	XHLLI [HLLI]		;NOT YET IN MACRO

DEFINE XBLT. (A)<
	EXTEND A,[XBLT]>

	SUBTTL SUPPORT CODE FOR JSERR

   IFN REL,<

A=1
B=2
C=3
D=4

;JSYS ERROR HANDLER
;	CALL JSERR0
; RETURNS +1: ALWAYS, CAN BE USED IN +1 RETURN OF JSYS'S

JSERR0::MOVEI A,.PRIIN
	CFIBF			;CLEAR TYPAHEAD
	MOVEI A,.PRIOU
	DOBE			;WAIT FOR PREVIOUS OUTPUT TO FINISH
	TMSG <
? JSYS ERROR: >
JSMSG0::MOVEI A,.PRIOU
	HRLOI B,.FHSLF		;SAY  THIS FORK ,, LAST ERROR
	SETZ C,
	ERSTR
	 JFCL
	 JFCL
	TMSG <
>
	RET

;FATAL JSYS ERROR - PRINT MESSAGE AND HALT
;	CALL JSHLT0
; RETURNS: NEVER

JSHLT0::CALL JSERR0		;PRINT THE MSG
JSHLT1:	HALTF
	TMSG <PROGRAM CANNOT CONTINUE
>
	JRST JSHLT1		;HALT AGAIN IF CONTINUED
   >				;END OF IFN REL,

	SUBTTL STKVAR - STACK VARIABLE FACILITY

;MACRO FOR ALLOCATING VARIABLES ON THE STACK. ITS ARGUMENT IS
;A LIST OF ITEMS.  EACH ITEM MAY BE:
; 1. A SINGLE VARIABLE WHICH WILL BE ALLOCATED ONE WORD
; 2. A VARIABLE AND SIZE PARAMETER WRITTEN AS <VAR,SIZ>.  THE
;	VARIABLE WILL BE ALLOCATED THE SPECIFIED NUMBER OF WORDS.
;RETURN FROM A SUBROUTINE USING THIS FACILITY MUST BE VIA
;RET OR RETSKP.  A DUMMY RETURN WHICH FIXES UP THE STACK IS PUT ON
;THE STACK AT THE POINT THE STKVAR IS ENCOUNTERED.
;WITHIN THE RANGE OF A STKVAR, PUSH/POP CANNOT BE USED AS THEY WILL
;CAUSE THE VARIABLES (WHICH ARE DEFINED AS RELATIVE STACK LOCATIONS)
;TO REFERENCE THE WRONG PLACE.
;TYPICAL USE:   STKVAR <AA,BB,<QQ,5>,ZZ>
;		ENDSV.		;END OF SCOPE OF NAMES

   IFE REL,<
	EXTERN .STKST,.STKRT>

DEFINE STKVAR (ARGS)<
	..STKR==10		;;REMEMBER RADIX
	RADIX 8
	..STKN==0
	IRP ARGS,<
	  .STKV1 (ARGS)>
	JSP .A16,.STKST
	 ..STKN,,..STKN
	RADIX ..STKR
	DEFINE ENDSV.<.ENSV1 <ARGS>>
   >

;INTERMEDIATE MACRO TO PEAL OFF ANGLEBRACKETS IF ANY

DEFINE .STKV1 (ARG)<
	.STKV2 (ARG)>

;INTERMEDIATE MACRO TO CALCULATE OFFSET AND COUNT VARIABLES

DEFINE .STKV2 (VAR,SIZ)<
	IFB <SIZ>,<..STKN==..STKN+1>
	IFNB <SIZ>,<..STKN==..STKN+SIZ>
	..STKQ==..STKN+1
	.STKV3 (VAR,\..STKQ)>

;INNERMOST MACRO TO DEFINE VARIABLE

DEFINE .STKV3 (VAR,LOC)<
   IFDEF VAR,<.IF VAR,SYMBOL,<PRINTX STKVAR VAR ALREADY DEFINED>>
	DEFINE VAR<-^O'LOC(P)>
	$'VAR==<Z VAR>>		;SYMBOL FOR DDT

;CLEANUP NAMES

DEFINE .ENSV1 (ARGS)<
	IRP ARGS,<
	  .ENSV2 (ARGS)>>

  DEFINE .ENSV2 (ARG)<
	.ENSV3 (ARG)>

  DEFINE .ENSV3 (ARG,SIZ)<
	DEFINE ARG<....U>>

   IFN REL,<

;COMMON ENTRY AND EXIT ROUTINE FOR STACK VARIABLE

	ENTRY .STKST

.STKST::ADD P,0(.A16)		;BUMP STACK FOR VARIABLES USED
	JUMPGE P,STKSOV		;TEST FOR STACK OVERFLOW
STKSE1:	PUSH P,0(.A16)		;SAVE BLOCK SIZE FOR RETURN
	PUSHJ P,1(.A16)		;CONTINUE ROUTINE, EXIT TO .+1
.STKRT::JRST STKRT0		;NON-SKIP RETURN COMES HERE
	POP P,.A16		;SKIP RETURN COMES HERE-RECOVER COUNT
	SUB P,.A16		;ADJUST STACK TO REMOVE BLOCK
	AOS 0(P)		;NOW DO SKIP RETURN
	RET

STKRT0:	POP P,.A16		;RECOVER COUNT
	SUB P,.A16		;ADJUST STACK TO REMOVE BLOCK
	RET			;DO NON-SKIP RETURN

STKSOV:	SUB P,0(.A16)		;STACK OVERFLOW- UNDO ADD
	HLL .A16,0(.A16)	;SETUP TO DO MULTIPLE PUSH, GET COUNT
STKSO1:	PUSH P,[0]		;DO ONE PUSH AT A TIME, GET REGULAR
	SUB .A16,[1,,0]		; ACTION ON OVERFLOW
	TLNE .A16,777777	;COUNT DOWN TO 0?
	JRST STKSO1		;NO, KEEP PUSHING
	JRST STKSE1
   >				;END OF IFN REL,

	SUBTTL TRVAR - TRANSIENT VARIABLE FACILITY

;TRANSIENT (STACK) VARIABLE FACILITY - EQUIVALENT TO STKVAR
;EXCEPT ALLOWS VARIABLES TO BE USED WITHIN LOWER LEVEL ROUTINES
;AND AFTER OTHER THINGS HAVE BEEN PUSHED ON STACK.
;N.B. USES .FP AS FRAME POINTER - MUST NOT BE CHANGED WHILE
;VARIABLES IN USE.

.FP==15				;DEFAULT FRAME POINTER

   IFE REL,<
	EXTERN .TRSET,.TRRET,.ASSET,.SASET,.ASRET>

DEFINE TRVAR (VARS)<
	..TRR==10		;;REMEMBER CURRENT RADIX
	RADIX 8
	..NV==1			;;INIT COUNT OF STACK WORDS
	IRP VARS,<
	  .TRV1 (VARS)>		;;PROCESS LIST
	JSP .A16,.TRSET		;;ALLOCATE STACK SPACE, SETUP .FP
	 ..NV-1,,..NV-1
	RADIX ..TRR		;;RESTORE RADIX
	DEFINE ENDTV.<.ENSV1 <VARS>>
	>

DEFINE .TRV1 (VAR)<
	.TRV2 (VAR)>		;;PEEL OFF ANGLEBRACKETS IF ANY

DEFINE .TRV2 (NAM,SIZ)<
	.TRV3 (NAM,\..NV)	;;DEFINE VARIABLE
	IFB <SIZ>,<..NV=..NV+1>
	IFNB <SIZ>,<..NV=..NV+SIZ>>

DEFINE .TRV3 (NAM,LOC)<
   IFDEF NAM,<.IF NAM,SYMBOL,<PRINTX TRVAR NAM ALREADY DEFINED>>
	DEFINE NAM<^O'LOC(.FP)>
	$'NAM==<Z NAM>>		;;SYMBOL FOR DDT

;AC SUBROUTINE - ENTRY FOR SUBROUTINE CALLED WITH 1-4 ARGS IN ACS T1-T4.
;USES .FP AS FRAME PTR LIKE TRVAR

DEFINE ASUBR (ARGS)<
	..TRR==10		;;SAVE RADIX
	RADIX 8
	..NV==1			;;INIT ARG COUNT
	IRP ARGS,<
	  .TRV1 (ARGS)>		;;DEFINE ARG SYMBOL
	IFG ..NV-5,<PRINTX ?TOO MANY ARGUMENTS: ARGS>
	JSP .A16,.ASSET		;;SETUP STACK
	RADIX ..TRR		;;RESTORE RADIX
	DEFINE ENDAS.<.ENSV1 <ARGS>>
	>
;SAME AS ABOVE EXCEPT ALSO RESTORES T1-T4 FROM STACK

DEFINE SASUBR (ARGS)<
	..TRR==10		;;SAVE RADIX
	RADIX 8
	..NV==1			;;INIT ARG COUNT
	IRP ARGS,<
	  .TRV1 (ARGS)>		;;DEFINE ARG SYMBOL
	IFG ..NV-5,<PRINTX ?TOO MANY ARGUMENTS: ARGS>
	JSP .A16,.SASET		;;SETUP STACK
	RADIX ..TRR		;;RESTORE RADIX
	DEFINE ENDSA.<.ENSV1 <ARGS>>
	>

   IFN REL,<
;SUPPORT ROUTINE FOR TRVAR

.TRSET::PUSH P,.FP		;PRESERVE OLD .FP
	MOVE .FP,P		;SETUP FRAME PTR
	ADD P,0(.A16)		;ALLOCATE SPACE
	JUMPGE P,TRSOV
TRSET1:	PUSHJ P,1(.A16)		;CONTINUE ROUTINE, EXIT VIA .+1
.TRRET::JRST [	MOVEM .FP,P	;CLEAR STACK
		POP P,.FP	;RESTORE OLD .FP
		POPJ P,]
	MOVEM .FP,P		;HERE IF SKIP RETURN
	POP P,.FP
	AOS 0(P)		;PASS SKIP RETURN
	POPJ P,

TRSOV:	MOVE P,.FP		;STACK OVERFLOW, UNDO ADD
	PUSH P,.A16		;SAVE LOCAL RETURN
	HRRZ .A16,0(.A16)	;GET COUNT
	ADJSP P,-1(.A16)	;ADJUST STACK, GET TRAP HERE OR ON PUSH
	MOVE .A16,1(.FP)	;RESTORE LOCAL RETURN
	JRST TRSET1		;NOW CHARGE AHEAD

;SUPPORT ROUTINE FOR ASUBR

.ASSET::PUSH P,.FP		;SAVE .FP
	MOVE .FP,P		;SETUP FRAME POINTER
	ADJSP P,4		;BUMP STACK
	DMOVEM A,1(.FP)	;SAVE ARGS
	DMOVEM C,3(.FP)
	PUSHJ P,0(.A16)		;CONTINUE ROUTINE
.ASRET:: JRST [	MOVEM .FP,P	;NO-SKIP RETURN, CLEAR STACK
		POP P,.FP
		POPJ P,]
	MOVEM .FP,P		;SKIP RETURN, CLEAR STZCK
	POP P,.FP
	AOS 0(P)
	POPJ P,

;SUPPORT ROUTINE FOR SASUBR

.SASET::PUSH P,.FP		;SAVE .FP
	MOVE .FP,P		;SETUP FRAME POINTER
	ADJSP P,4		;BUMP STACK
	DMOVEM A,1(.FP)	;SAVE ARGS
	DMOVEM C,3(.FP)
	PUSHJ P,0(.A16)		;CONTINUE ROUTINE
.SARET:: JRST [	DMOVE A,1(.FP)	;RESTORE
		DMOVE C,3(.FP)
		MOVEM .FP,P	;NO-SKIP RETURN, CLEAR STACK
		POP P,.FP
		POPJ P,]
	DMOVE A,1(.FP)		;RESTORE
	DMOVE C,3(.FP)
	MOVEM .FP,P		;SKIP RETURN, CLEAR STACK
	POP P,.FP
	AOS 0(P)
	POPJ P,
   >				;END OF IFN REL,

;AC VARIABLE FACILITY

   IFE REL,<
	EXTERN .SAV1,.SAV2,.SAV3,.SAV4,.SAV8>

.FPAC==5			;FIRST PRESERVED AC
.NPAC==10			;NUMBER OF PRESERVED ACS

DEFINE ACVAR (LIST)<
	..NAC==0		;;INIT NUMBER OF ACS USED
	IRP LIST,<
	  .ACV1 (LIST)>		;;PROCESS ITEMS
	.ACV3 (\..NAC)		;;SAVE ACS USED
	DEFINE ENDAV.<.ENAV1 <LIST>>>

DEFINE .ACV1 (ITEM)<
	.ACV2 (ITEM)>		;;PEEL OFF ANGLEBRACKETS IF ANY

DEFINE .ACV2 (NAM,SIZ)<
   IFDEF NAM,<.IF NAM,SYMBOL,<PRINTX ACVAR NAM ALREADY DEFINED>>
	NAM==.FPAC+..NAC	;;DEFINE VARIABLE
	$'NAM==NAM		;;FOR DDT
	IFB <SIZ>,<..NAC=..NAC+1>
	IFNB <SIZ>,<..NAC=..NAC+SIZ>>

DEFINE .ACV3 (N)<
	IFG N-.NPAC,<PRINTX ?TOO MANY ACS USED>
	IFLE N-4,<
	  JSP .A16,.SAV'N>	;;SAVE ACTUAL NUMBER USED
	IFG N-4,<
	  JSP .A16,.SAV8>>	;;SAVE ALL

DEFINE .ENAV1 (ARGS)<
	IRP ARGS,<
	  .ENAV2 (ARGS)>>

  DEFINE .ENAV2 (ARG)<
	.ENAV3 (ARG)>

  DEFINE .ENAV3 (NAM,SIZ)<
	PURGE NAM,NAM
  >

   IFN REL,<
;SUPPORT ROUTINES FOR AC VARIABLE FACILITY

.SAV1::	PUSH P,.FPAC
	PUSHJ P,0(.A16)		;CONTINUE PROGRAM
	 SKIPA
	AOS -1(P)
	POP P,.FPAC
	POPJ P,

.SAV2::	PUSH P,.FPAC
	PUSH P,.FPAC+1
	PUSHJ P,0(.A16)
	 SKIPA
	AOS -2(P)
	POP P,.FPAC+1
	POP P,.FPAC
	POPJ P,

.SAV3::
.SAV4::	PUSH P,.FPAC
	PUSH P,.FPAC+1
	PUSH P,.FPAC+2
	PUSH P,.FPAC+3
	PUSHJ P,0(.A16)
	 SKIPA
	AOS -4(P)
	POP P,.FPAC+3
	POP P,.FPAC+2
	POP P,.FPAC+1
	POP P,.FPAC
	POPJ P,

.SAV8::	ADD P,[10,,10]
	JUMPGE P,[HALT .]
	DMOVEM .FPAC,-7(P)
	DMOVEM .FPAC+2,-5(P)
	DMOVEM .FPAC+4,-3(P)
	DMOVEM .FPAC+6,-1(P)
	PUSHJ P,0(.A16)
	 SKIPA
	AOS -10(P)
	DMOVE .FPAC+6,-1(P)
	DMOVE .FPAC+4,-3(P)
	DMOVE .FPAC+2,-5(P)
	DMOVE .FPAC,-7(P)
	SUB P,[10,,10]
	POPJ P,
   >

;AC SAVE FACILITY - COMPILES OPEN PUSH'S
;	SAVEAC <LIST-OF-ACS>
;DUMMY ROUTINE PUT ON STACK TO CAUSE AUTOMATIC RESTORE. SUPPORTS
; +1 OR +2 RETURNS.

DEFINE SAVEAC (ACS)<
	.NAC==0
	IRP ACS,<
	  PUSH P,ACS		;;SAVE AN AC
	  .NAC=.NAC+1>		;;COUNT THEM
	.N1==.NAC
	SETMI .A16,[CAIA	;;STACK DUMMY RETURN
		AOS -.N1(P)	;;HANDLE SKIP RETURN
	  IRP ACS,<
		.N1=.N1-1
		MOVE ACS,-.N1(P)>  ;;RESTORE AN AC
		SUB P,[.NAC,,.NAC]  ;;CLEAR STACK
		POPJ P,]	;;FINAL RETURN
	PUSH P,.A16>

   IFN REL,<
;STANDARD RETURNS

RSKP::	AOS 0(P)
R::	RET
   >				;END OF IFN REL,

	SUBTTL BLSUBR - BLISS-STYLE SUBROUTINE MECHANISM

;MACROS FOR STACK-STYLE (BLISS) SUBROUTINE ENTRY
;BLSUBR DEFINE A SUBROUTINE ENTRY POINT.  IT TAKES THE LIST OF
;SYMBOLS WHICH WILL BE BOUND TO VALUES ON THE STACK AT ENTRY TO
;THE ROUTINE.  A STACK FRAME POINTER IS SETUP IN .FP AND MUST
;BE UNDISTURBED THROUGH THE ROUTINE.  OTHER MECHANISMS WHICH
;USE THE STACK (E.G. SAVEAC) CAN BE USED.
;AN OPTIONAL LIST OF VARIABLES IN THE SAME FORMAT AS FOR TRVAR CAN
;BE GIVEN TO ALLOCATE LOCAL DYNAMIC STORAGE.

;SUBROUTINES DEFINED HEREBY ARE CALLED WITH BLCALL.

   IFE REL,<
	EXTERN .ENTER>

DEFINE BLSUB. (ARGS,VARS)<	;;ARGUMENTS, LOCAL VARIABLES
	..TRR==10		;;REMEMBER CURRENT RADIX
	RADIX 8			;;SO BACKSLASH ARGS WILL WORK HEREIN
	..NA==2			;;INIT ARG COUNT
	IRP ARGS,<
	  ..NA=..NA+1>		;;COUNT ARGS
	IRP ARGS,<
	  .BLSU1(ARGS,\..NA)	;;DEFINE AN ARG
	  ..NA=..NA-1>
	..NV==1			;;SETUP TO COUNT VARIABLE STORAGE
	IRP VARS,<
	  .TRV1 (VARS)>		;;COUNT WORDS AND DEFINE SYMBOLS
  DEFINE ENDBS. <.ENBS1 <ARGS>
		.ENSV1 <VARS>> ;;SAVE SYMBOLS
	JSP .A16,.ENTER
	..NV-1,,..NV-1
	RADIX ..TRR>		;;SETUP FRAME PTR

DEFINE .BLSU1 (ARG,LOC)<
	DEFINE ARG<-^O'LOC(.FP)>
	$'ARG==<Z ARG>>

DEFINE .ENBS1 (ARGS)<
	IRP ARGS,<
   DEFINE ARGS<....U>>>

;CALL STACK-STYLE (BLISS) SUBROUTINE
;THIS MACRO TAKES THE NAME OF THE SUBROUTINE AND A LIST OF ARGUMENTS.
;EACH ARGUMENT IN THE ARG LIST IS ONE OF THE FOLLOWING:
;  1. A NORMAL EFFECTIVE ADDRESS SPECIFICATION, E.G. FOO, @FIE(X)
;  2. AN IMMEDIATE ADDRESS WRITTEN AS <.,ADR> WHERE ADR IS AN EFFECTIVE
;	ADDRESS SPECIFICATION, E.G. FOO, @FIE(X).  NOTE THAT THIS
;	ADDRESS WILL BE COMPUTED BY AN XMOVEI AT THE TIME OF THE CALL
;	SO SECTION INFORMATION WILL BE BOUND AT THAT TIME.  NOTE ALSO
;	THAT THIS FORM SHOULD *NOT* BE USED FOR A LITERAL CONSTANT
;	WHERE YOU WOULD NOT WANT THE CURRENT SECTION PUT IN THE LEFT
;	HALF.  USE [CONST] INSTEAD.  YES, THE DOT HERE IS LIKE NO-DOT IN BLISS
;	AND VICE-VERSA.
;  3. A STRUCTURE REFERENCE SPECIFICATION, E.G. AAA, <BB,(X)>.  IF
;	THE LATTER FORM IS USED, THE BRACKETS ARE REQUIRED.

DEFINE BLCAL. (NAME,ARGS)<
	..NA==0			;;INIT ARG COUNT
	IRP ARGS,<
	  .BLCL2 ARGS>		;;COMPILE PUSH
	PUSH P,[..NA+1,,..NA+1]	;;COUNT OF ARGS AND SELF
	PUSHJ P,NAME		;;JUMP TO SUBR
   >

;SEPARATE PAIRED ARGS

  DEFINE .BLCL2 (ARGS)<
	.BLCL1 ARGS>

  DEFINE .BLCL1 (ARG1,ARG2)<
	  IFIDN <ARG1><.>,<
		XMOVEI .A16,ARG2	;;IMMEDIATE ARG
		PUSH P,.A16>
	  IFDIF <ARG1><.>,<
	  .IFATM <ARG1>,.BLF1	;;SEE IF ARG IS ATOMIC
	  IFN .BLF1,<
	    .BLF1==0		;;SET TO 1 IFF STRUCTURE REF
	    .IF %'ARG1,MACRO,<	;;CHECK RELATED STRUCTURE SYMBOL
		.BLF1==1>	;;IS A STRUCTURE
	    IFNB <ARG2>,<
		.BLF1==1>	;;SECOND ARG IMPLIES STRUCTURE TOO
	    IFN .BLF1,<		;;'OR' OF ABOVE TWO CHECKS
		LOAD .A16,ARG1,ARG2
		PUSH P,.A16>>
	  IFE .BLF1,<		;IF WASN'T A STRUCTURE REF,
		PUSH P,ARG1>>	;;PUSH ONE ARG
	  ..NA=..NA+1>

;MACRO TO SEE IF STRING IS AN ATOM, I.E. CONTAINS ONLY LEGAL SYMBOL
;CONSTITUENTS A-Z, 0-9, %, $, .
;IT IS PAINFULLY SLOW, BUT MACRO PROVIDES NO OTHER WAY
;FLAG WILL BE SET TO 1 IF STRING IS ATOM, 0 OTHERWISE

DEFINE .IFATM (S,FLG)<
	IRPC S,<
	FLG==0
	IFGE "S"-"A",<IFLE "S"-"Z",<FLG=1>> ;;SET FLG IF LETTER OK
	IFGE "S"-"0",<IFLE "S"-"9",<FLG=1>>
	IFE "S"-"%",<FLG=1>
	IFE "S"-"$",<FLG=1>
	IFE "S"-".",<FLG=1>
	IFE FLG,<STOPI>>>

   IFN REL,<
;SUPPORT CODE FOR BLSUBR

.ENTER::PUSH P,.FP
	MOVE .FP,P
	ADD P,0(.A16)		;ALLOCATE LOCAL STORAGE
	JUMPGE P,ENTOV		;JUMP IF OVERFLOW
ENTOV1:	PUSHJ P,1(.A16)
	 JRST [	MOVE P,.FP	;RESET STACK PTR
		JRST ENTX1]
	MOVE P,.FP
	AOS -1(P)		;PROPAGATE SKIP
ENTX1:	POP P,.FP
	POP P,.A16
	SUB P,0(P)		;REMOVE ARGS
	JRST 0(.A16)		;RETURN

ENTOV:	MOVE P,.FP		;STACK OVERFLOW, UNDO ADD
	PUSH P,.A16		;SAVE LOCAL RETURN IN 1(.FP)
	HRRZ .A16,0(.A16)	;GET COUNT
	ADJSP P,-1(.A16)	;ALLOCATE SPACE, GET TRAP HERE OR ON PUSH
	MOVE .A16,1(.FP)	;RESTORE LOCAL RETURN
	JRST ENTOV1		;CHARGE AHEAD
   >				;END IFN REL

	SUBTTL ERROR-MESSAGE SUPPORT FOR MACROS




	;Macro to print current location, macro name, and text
	DEFINE MPRNTX (MNAME,TEXT)
	  <DEFINE ..MP. (LOCN,MTEXT,PTEXT)
	    <PRINTX Location 'LOCN', Macro 'MTEXT': PTEXT
	    >
	  ..MP.(\.,MNAME,<TEXT>)
	  PURGE ..MP.
	  >

	;Macro to print current location and text
	DEFINE EPRNTX (TEXT)
	  <DEFINE ..EP. (LOCN,PTEXT)
	    <PRINTX Location 'LOCN': PTEXT
	    >
	  ..EP.(\.,<TEXT>)
	  PURGE ..EP.
	  >


	SUBTTL MACROS TO SUPPORT EXTENDED ADDRESSING


;	Local format indirect word
;	=================================================================
;	!1!0!    Reserved   ! I !   X   !	      ADDR		!
;	=================================================================
;	!0!1!2     	  12! 13!14   17!18			      35!



	;Macro to generate local-format (instruction-format) indirect words
	;Args:	
	;	ADDR	18-bit in-section address (indexing or indirection
	;		may be specified)

	;Generates Q errors on the following:
	;		Bits 0-12 non-zero in ADDR

	DEFINE LFIWM (ADDR)
	<..ERR.=0		;;Reset error flag
	IFN <<ADDR>&<^O<777740,,0>>>,
	  <MPRNTX(LFIWM,Bits 0 - 12 non-zero in address field: ADDR)
	  ..ERR.=1
	  >
	IFN ..ERR.,<-1,-1,-1>	;;Generate Q error
	IFE ..ERR.,<1B0!<<^O<400037,,-1>>&<ADDR>>>	;;Generate LFIW
	PURGE ..ERR.
	>




;	Global format indirect word
;	=================================================================
;	!0! I !   X   !       SEC       !	      ADDR		!
;	=================================================================
;	!0! 1 !2     5!6	      17!			      35!


	;Macro to generate global-format (extended-format) indirect words
	;Args:
	;	SEC	12-bit section number
	;	ADDR	18-bit in-section address (indexing or indirection
	;		may be specified)

	;Generates Q errors on the following:
	;		Bits 0-12 non-zero in ADDR
	;		SEC greater than 12 bits

	DEFINE GFIWM (SEC,ADDR)
	<..ERR.=0		;;Reset error flag
	IFN <<SEC>&<^O<-1,,770000>>>,
	  <MPRNTX(GFIWM,Section greater than 12 bits: SEC)
	  ..ERR.=1
	  >
	IFN <<ADDR>&<^O<777740,,0>>>,
	  <MPRNTX(GFIWM,Bits 0 - 12 non-zero in address field: ADDR)
	  ..ERR.=1
	  >
	IFN ..ERR.,<-1,-1,-1>	;;Generate Q error
				;;Generate GFIW
	IFE ..ERR.,<
	  <<<ADDR>_<^O14>>&<^O<370000,,0>>!<<ADDR>&<0,,-1>>!<<SEC>_<^O22>>>>
	PURGE ..ERR.
	>

;	The following macros generate all flavors of 1 and 2-word
;	global and local byte pointers.  They are similar to the
;	POINT pseudo-op, with the following exceptions:

;	1.	The basic argument triad of (bytesize,address,byte position)
;		is maintained.  However, some of the macros will prefix
;		and-or postfix the triad with additional argument(s).
;	2.	Numeric arguments are always interpreted in the current radix.
;		Assuming the current radix is octal, note the following
;		equivalences:
;			a.  POINT 10,200,36
;			b.  L1BPT(12,200,44)
;			c.  L1BPT(^D10,200,^D36)
;	3.	Strict field-limits are enforced.  Any expression that
;		will not fit into its appropriate field will generate
;		an error message and cause a Q error.  Thus:
;		L1BPT (10,200,-1) will cause an error.  (The correct effect
;		is generated with:  L1BPT (10,200).)

;	Also, note that in those macros that generate global byte-pointers,
;	section values and address values must always be specified as distinct
;	arguments.  If address symbol FOO resolves to 377,,123456 , then it
;	would be specified in the macros as follows:
;		G2BPT(FOO_-^D18,7,FOO&777777,36)
;	Or (better):
;		FOOSEC=FOO_-^D18
;		FOOADR=FOO&777777
;		G2BPT(FOOSEC,7,FOOADR,36)

;	If runtime-generated values are needed, then any or all argument
;	fields may be assembled as zero and filled in at runtime using an
;	appropriate DPB instruction.  (G1BPT will not allow a zero bytesize
;	and will only allow a zero byte position if it is legal for that
;	particular bytesize.)



;	1-word local byte pointer
;	=================================================================
;	!   P   !   S   ! 0 ! I !   X   !	      ADDR		!
;	=================================================================
;	!0     5!6    11! 12! 13!14   17!18			      35!



	;Macro to generate local, 1-word byte pointers
	;Args:
	;	BSIZ	Byte size
	;	ADDR	18-bit address (indexing or indirection
	;		may be specified)
	;	BPOS	Optional byte position

	;Generates Q errors on the following:
	;		Bits 0-12 non-zero in ADDR
	;		BSIZ or BPOS greater than 6 bits

	DEFINE L1BPT (BSIZ,ADDR,BPOS)
	<.BSIZ.=BSIZ		;;Convert args to numeric
	.BPOS.=BPOS
	..ERR.=0		;;Reset error flag
	IFN <<ADDR>&<^O<777740,,0>>>,
	  <MPRNTX(L1BPT,Bits 0 - 12 non-zero in address field: ADDR)
	  ..ERR.=1
	  >
	IFN <.BSIZ.&<^O<-1,,777700>>>,
	  <MPRNTX(L1BPT,Bytesize greater than 6 bits: BSIZ)
	  ..ERR.=1
	  >
	IFN <.BPOS.&<^O<-1,,777700>>>,
	  <MPRNTX(L1BPT,Byte offset greater than 6 bits: BPOS)
	  ..ERR.=1
	  >
	;;Cause Q error
	IFN <..ERR.>,<-1,-1,-1>
	;;Generate byte pointer
	IFE <..ERR.>,
	  <IFIDN <BPOS><>,<POINT .BSIZ.,ADDR>
	  IFDIF <BPOS><>,<POINT .BSIZ.,ADDR,.BPOS.>
	  >
	PURGE ..ERR.,.BSIZ.,.BPOS.
	>



;	1-word global byte pointer
;	=================================================================
;	!     P,S     !       SEC       !	      ADDR		!
;	=================================================================
;	!0           5!6	      17!			      35!



	;Macro to generate global, 1-word byte pointers
	;Args:
	;	
	;	SEC	12-bit section address
	;	BSIZ	Byte size
	;	ADDR	18-bit address (NO!! indexing or indirection
	;		may be specified)
	;	BPOS	Optional byte position

	;Generates Q errors on following:
	;		Illegal byte size or byte position
	;		Indirection or indexing specified with ADDR
	;		ADDR greater than 18 bits
	;		SEC greater than 12 bits

	;Legal sizes and positions are as follows:

	;Size		Positions (Octal)
	;6		44,36,30,22,14,6,0
	;7		44,35,26,17,10,1
	;8		44,34,24,14,4
	;9		44,33,22,11,0
	;18		44,22,0

	DEFINE G1BPT (SEC,BSIZ,ADDR,BPOS<^O44>)
	<..ERR.=0			;;Reset error flag
	..ENC.=0			;;Define it as an arbitrary value
	IFE BSIZ-7,			;;IF BYTESIZE=7
	  <..ENC.=^O57			;;Get correct encode value
	  IFN BPOS-^O44,<IFN BPOS-^O35,<IFN BPOS-^O26,<IFN BPOS-^O17,<IFN BPOS-^O10,
		     	<IFN BPOS-1<..ERR.=..ERR.!1>>>>>>
	  >
	IFN BSIZ-7,			;;ELSE IF BYTESIZE=6
	  <IFE BSIZ-6,
	    <..ENC.=^O45			;;Get correct encode value
	    IFN BPOS-^O44,<IFN BPOS-^O36,<IFN BPOS-^O30,<IFN BPOS-^O22,<IFN BPOS-^O14,
			<IFN BPOS-6,<IFN BPOS,<..ERR.=.ERR.!1>>>>>>>
	    >
	  IFN BSIZ-6,			;;ELSE IF BYTESIZE=8
	    <IFE BSIZ-^O10,
	      <..ENC.=^O50		;;Get correct encode value
	      IFN BPOS-^O44,<IFN BPOS-^O34,<IFN BPOS-^O24,<IFN BPOS-^O14,<IFN BPOS-4,
			<..ERR.=.ERR.!1>>>>>
	      >
	    IFN BSIZ-^O10,		;;ELSE IF BYTESIZE=9
	      <IFE BSIZ-^O11,
		<..ENC.=^O62		;;Get correct encode value
		IFN BPOS-^O44,<IFN BPOS-^O33,<IFN BPOS-^O22,<IFN BPOS-^O11,<IFN BPOS,
			<..ERR.=..ERR.!1>>>>>
		>
	      IFN BSIZ-^O11,		;;ELSE IF BYTESIZE=18
		<IFE BSIZ-^O22,
		  <..ENC.=^O54		;;Get correct encode value
		  IFN BSIZ-^O44,<IFN BSIZ-^O22<IFN BSIZ,<..ERR.=..ERR.!1>>>
		  >
		IFN BSIZ-^O22,<..ERR.=..ERR.!2>	;;ELSE: Illegal byte size
		>
	      >
	    >
	  >
	IFN <<ADDR>&<-1,,0>>,<..ERR.=..ERR.!4> ;;Address greater than 18 bits
					     ;; or indexing or indirection specified
	IFN <<SEC>&<^O<-1,,770000>>>,<..ERR.=..ERR.!<^O20>> ;;Section greater than 12 bits 
	IFN ..ERR.,
	  <IFN ..ERR.&1,<MPRNTX (G1BPT,Illegal byte offset: BPOS)>
	  IFN ..ERR.&2,<MPRNTX (G1BPT,Illegal byte size: BSIZ)>
	  IFN ..ERR.&4,
	    <MPRNTX (G1BPT,<Address indexed, indirect, or greater than 18 bits: ADDR>)>
	  IFN ..ERR.&<^O20>,<MPRNTX (G1BPT,Section greater than 12 bits: SEC)>
	  -1,-1,-1		;;Cause a "Q" error
	  >
	;;Generate the byte pointer
	IFE ..ERR.,
	  <<<..ENC.+<<BSIZ>-<<BPOS>/<BSIZ>>>>_<^O36>>!<<ADDR>&<0,,-1>>!<<SEC>_^O<22>>>	
	PURGE ..ERR.,..ENC.
	>




;	2-word local byte pointer

;	!0     5!6    11! 12! 13      17!18			      35!
;	=================================================================
;	!   P   !   S   ! 1 ! Reserved  !       Available to User       !
;	=================================================================
;	!1!0!    Reserved   ! I !   X   !	      ADDR		!
;	=================================================================
;	!0!1!2     	  12! 13!14   17!18			      35!



	;Macro to generate local, 2-word byte pointers
	;Args:
	;	
	;	BSIZ	Byte size
	;	ADDR	18-bit address (Indexing or indirection
	;		may be specified)
	;	BPOS	Optional byte position
	;	OPT	Optional user field available in word 1, right half

	;Generates Q errors on the following:
	;		Bits 0-12 non-zero in ADDR
	;		Bits 0-17 non-zero in OPT
	;		BSIZ or BPOS greater than 6 bits

	DEFINE L2BPT(BSIZ,ADDR,BPOS,OPT<0>)
	<..ERR.=0		;;Reset error flag
	  .BSIZ.=BSIZ		;;Convert args to numeric
	  .BPOS.=BPOS
	IFN <<ADDR>&<^O<777740,,0>>>,
	  <MPRNTX(L2BPT,Bits 0 - 12 non-zero in address field: ADDR)
	  ..ERR.=1
	  >
	IFN <<OPT>&<-1,,0>>,
	  <MPRNTX(L2BPT,Bits 0-17 non-zero in optional field: OPT)
	  ..ERR.=1
	  >
	IFN <.BSIZ.&<^O<-1,,777700>>>,
	  <MPRNTX(L2BPT,Bytesize greater than 6 bits: BSIZ)
	  ..ERR.=1
	  >
	IFN <.BPOS.&<^O<-1,,777700>>>,
	  <MPRNTX(L2BPT,Byte offset greater than 6 bits: BPOS)
	  ..ERR.=1
	  >
	IFN ..ERR.,<-1,-1,-1>		;;Generate Q error
	;;Generate the byte pointer
	IFE ..ERR.,
	  <IFDIF <BPOS><>,<<<POINT .BSIZ.,OPT,.BPOS.>!1B12>&<^O<777740,,-1>>>
	  IFIDN <BPOS><>,<<<POINT .BSIZ.,OPT>!1B12>&<^O<777740,,-1>>>
	    <1B0!<<^O<400037,,-1>>&<ADDR>>>	;;Generate LFIW
	  >
	PURGE ..ERR.,.BSIZ.,.BPOS.
	>


;	2-word global byte pointer

;	!0     5!6    11! 12! 13      17!18			      35!
;	=================================================================
;	!   P   !   S   ! 1 ! Reserved  !       Available to User       !
;	=================================================================
;	!0! I !   X   !       SEC       !	      ADDR		!
;	=================================================================
;	!0! 1 !2     5!6	      17!			      35!


	;Macro to generate global, 2-word byte pointers
	;Args:
	;	SEC	12-bit section address
	;	BSIZ	Byte size
	;	ADDR	18-bit address (Indexing or indirection
	;		may be specified)
	;	BPOS	Optional byte position
	;	OPT	Optional user field available in word 1, right half

	;Generates Q errors on the following:
	;		SEC greater than 12 bits
	;		Bits 0-12 non-zero in ADDR
	;		Bits 0-17 non-zero in OPT
	;		BSIZ or BPOS greater than 6 bits

	DEFINE G2BPT(SEC,BSIZ,ADDR,BPOS,OPT<0>)
	<..ERR.=0		;;Reset error flag
	  .BSIZ.=BSIZ		;;Convert args to numeric
	  .BPOS.=BPOS
	IFN <<SEC>&<^O<-1,,770000>>>,
	  <MPRNTX(G2BPT,Section greater than 12 bits: SEC)
	  ..ERR.=1
	  >
	IFN <<ADDR>&<^O<777740,,0>>>,
	  <MPRNTX(G2BPT,Bits 0 - 12 non-zero in address field: ADDR)
	  ..ERR.=1
	  >
	IFN <<OPT>&<-1,,0>>,
	  <MPRNTX(G2BPT,Bits 0-17 non-zero in optional field: OPT)
	  ..ERR.=1
	  >
	IFN <.BSIZ.&<^O<-1,,777700>>>,
	  <MPRNTX(G2BPT,Bytesize greater than 6 bits: BSIZ)
	  ..ERR.=1
	  >
	IFN <.BPOS.&<^O<-1,,777700>>>,
	  <MPRNTX(G2BPT,Byte offset greater than 6 bits: BPOS)
	  ..ERR.=1
	  >
	IFN ..ERR.,<-1,-1,-1>		;;Generate Q error
	;;Generate the byte pointer
	IFE ..ERR.,
	  <IFDIF <BPOS><>,<<<POINT .BSIZ.,OPT,.BPOS.>!1B12>&<^O<777740,,-1>>>
	  IFIDN <BPOS><>,<<<POINT .BSIZ.,OPT>!1B12>&<^O<777740,,-1>>>
	    ;;Generate GFIW
	    <<<ADDR>_<^O14>>&<^O<370000,,0>>!<<ADDR>&<0,,-1>>!<<SEC>_<^O22>>>
	  >
	PURGE ..ERR.,.BSIZ.,.BPOS.
	>

LIT				;MAKE SURE LITERALS COME BEFORE END MARK
   IFN REL,<
.RLEND==:.-1			;MARK END OF CODE IN MACREL
   >
  IF2,<PURGE REL>		;FLUSH REL FROM UNIV FILE

	.XCMSY

	END		;End of MACSYM
