;<4.ARPA-UTILITIES>NETSTA.MAC.7, 11-Oct-79 11:38:17, Edit by LCAMPBELL
; Update version and edit numbers for release 4
;<4.ARPA-UTILITIES>NETSTA.MAC.6, 10-Jul-79 18:32:49, Edit by LCAMPBELL
; Also leave B19 clear, it now has meaning
;<4.ARPA-UTILITIES>NETSTA.MAC.5, 23-Apr-79 18:43:34, Edit by LCAMPBELL
; Leave DEC-reserved bit (B18) zero in SFMODs
;<4.ARPA-UTILITIES>NETSTA.MAC.4,  9-Jan-79 14:00:16, Edit by LCAMPBELL
; Update copyright notice
;<JBORCHEK>NETSTA.MAC.3,  6-Nov-78 11:44:50, EDIT BY JBORCHEK
;IF HOST NUMBER IS 0 ASSUME DEAD AT LP2
;<3-CLEMENTS>NETSTA.MAC.18, 20-Aug-78 23:01:08, EDIT BY CLEMENTS
; Combine and trim files into one.
;<3.ARPA-UTILITIES>NETSTA.MAC.5, 14-Nov-77 10:20:01, EDIT BY CROSSLAND
;CORRECT COPYRIGHT NOTICE
;<3.ARPA-UTILITIES>NETSTA.MAC.4, 26-Oct-77 02:37:41, EDIT BY CROSSLAND
;UPDATE COPYRIGHT FOR RELEASE 3
;<3.ARPA-UTILITIES>NETSTA.MAC.2,  5-Oct-77 00:53:50, EDIT BY CROSSLAND
;CONVERT STDIR TO RCUSR IN USERS COMMAND
;<A-SOURCES>NETSTA.MAC.6, 30-Dec-76 22:13:10, EDIT BY CROSSLAND
;CONVERT VERSION NUMBER TO DEC STYLE VERSION NUMBER
;<2MURPHY>NETSTA.MAC.15,  2-Sep-76 23:01:11, EDIT BY MURPHY
;ADDED SEARCH MONSYM,MACSYM
;<JOHNSON>NETSTA.MAC;16     5-FEB-74 09:42:45 EDIT BY JOHNSON


;This software is furnished under a license and may only be used
;  or copied in accordance with the terms of such license.
;
;Copyright (C) 1976,1977,1978,1979 Digital Equipment Corporation, Maynard, Mass.


	TITLE NETSTAT
	SEARCH MONSYM,MACSYM
	SALL
	.REQUIRE SYS:MACREL
	.DIRECT FLBLST

VWHO==0			;LAST EDITED BY DEC
VMAJOR==4		;MAJOR VERSION #
VMINOR==0		;REVISION #
VEDIT==33		;EDIT NUMBER

	LOC	<.JBVER==137>
VERSIO:	<VWHO>B2+<VMAJOR>B11+<VMINOR>B17+VEDIT ;VERSIONS FOR TYPEOUT
	RELOC

;AC DEFINITIONS

A=1
B=2
C=3
D=4
AC5=5
AC6=6
AC7=7
NCOL=10
COL=11
PTR=12
FM=15
FS=16
P=17

OPDEF NOP [JFCL 0,0]		;A NO-OP
OPDEF IFIW [400B8]		;FOR INDIRECTS ON MODEL B MACHINE

;FLAGS IN FM
FIRSTF==400000			;1 MEANS: NOT FIRST TYPEOUT OF SKT INFO.
FGO==200000			;GO START TYPEOUT (SET BY CSPEC WHEN DONE)
DOHSTF==100000			;GIVE HOST INFO
DOSKTF==040000			;GIVE SOCKET CONNECTION INFO
FSCON==020000			;SPECIFIC CONNECTIONS WANTED
TTYALL==010000			;ALL (OR NOT ALL) TTYS WANTED
HELPF==004000			;SHORT HELP MESSAGE ALREADY GIVEN
FNOTLK==002000			;DO NOT TALK TO USER
FREPT==001000			;REPEAT RATHER THAN HALTF AT END.
FVERB==000400			;USE HEADINGS ALWAYS.
FBRIEF==000200			;USE NO HEADINGS OR MESSAGES.
DOSITF==000100			;GIVE SITE INFO.
DECHNF==000040			;DECIMAL HOST NUMBERS.
OCTHNF==000020			;OCTAL HOST NUMBERS.
AGAINF==000010			;THIS IS A REPEAT WITH NO COMMANDS YET.

;FLAGS IN FS
FNOT==400000
FHO==200000
FNHO==100000
FJO==040000
FNJO==020000
FSI==010000
FNSI==004000
FST==002000
FNST==001000
FTT==000400
FNTT==000200
FUS==000100
FNUS==000040
FLS==000020
FNLS==000010
FFS==000004
FNFS==000002

RAZ==200000			;BIT FLAG FOR CASE CONVERSION FOR INEDIT

; PARAMETERS

TBLSIZ==1000			;SIZE OF GETAB TABLES TOALLOW FOR.
MXNHST==1000			;NUMBER OF HOSTS WHICH MAY BE KNOWN


ENTVEC:	JRST BEG		;STARTING ADDRESS
	JRST JSTCON
	JRST JSTHST

;ENTRY FOR CONNECTION INFO ONLY
;HOST NUMBER IN AC0
;STATES WANTED IN A (BIT N => STATE #N)
JSTCON:	RESET
	MOVE P,[XWD -100,PDL-1]
	PUSH P,0
	PUSH P,1
	PUSHJ P,SETUP
	POP P,1
	POP P,0
	TRO FM,DOSKTF!FSCON!FNOTLK
	CAMN 0,[-1]
	 JRST JSTCN1		;IF AC0=-1 THEN ALL HOSTS
	MOVE D,HOSTS
	AOJ D,
	MOVEM 0,HOSTS(D)
	MOVEM D,HOSTS
	TRO FM,FIRSTF		;NO HEADING IF A HOST IS GIVEN.
JSTCN1:	CAME 1,[-1]
	 TRO FM,FIRSTF		;NO HEADING IF STATE IS GIVEN.
	TDZ 1,[1B0+1B14]	;IGNORE DEAD AND FREE STATES.
	MOVEM 1,STATES
	TRO FS,FHO!FST
	JRST NTSTAT

;ENTRY FOR HOST STATUS INFO ONLY
;A CONTAINS FLAGS:
; BIT 0 - HOSTS ONLY (NO TIPS).
; BIT 1 - DECIMAL HOST NUMBERS.
; BIT 2 - OCTAL HOST NUMBERS.
; BIT 3 - NO HEADING.
JSTHST:	RESET
	MOVE P,[XWD -100,PDL-1]
	PUSH P,A
	PUSHJ P,SETUP
	POP P,A
	TLNE A,400000
	 TRO FM,DOHSTF
	TLNE A,200000
	 TRO FM,DECHNF
	TLNE A,100000
	 TRO FM,OCTHNF
	TLNE A,040000
	 TRO FM,FBRIEF
	TRO FM,DOSITF!FNOTLK	;Do sites, No talk to user
	JRST NTSTAT

;REPEAT ENTRY
KEEPF==FIRSTF!HELPF!FREPT!FVERB!FBRIEF!DECHNF!OCTHNF
AGAIN:	PUSH P,B
	PUSH P,C
	PUSH P,10
	PUSHJ P,SETAGN
	ANDI FM,KEEPF		;KEEP THESE FLAGS.
	POP P,10
	POP P,C
	POP P,B
	POPJ P,

BEG:	RESET
	MOVE P,[XWD -100,PDL-1]
	PUSHJ P,SETUP
	HRROI A,[ASCIZ /   "?" FOR HELP
/]
;	PSOUT

NTSTAT:	MOVEI A,100		;GET, SAVE, AND RESET TTY MODE.
	RFMOD
	MOVEM B,TTYMOD
	TRZ B,776000
	TRO B,174000		;WAKE ON ALL,
	SFMOD			;DEFFERED OR IMMEDIATE ECHOING.
	MOVE A,[SIXBIT /NETRDY/] ;CHECK FOR LIVE IMP.
	SYSGT
	JUMPGE A,[HRROI A,[ASCIZ /
THE IMP IS DEAD!
/]
		PSOUT
		JRST ENDUP]
;LOOP TO READ ALL AVAILABLE INFO ABOUT HOSTS KNOWN TO SYSTEM
; FIRST, ALL NAMES KNOWN TO SYSTEM

	MOVEI A,.GTHSZ		;GET TABLE SIZE
	GTHST			; FROM MONITOR
	 JRST ENDUP		;NOT AVAILABLE
	HLRE C,B		;MAKE SURE WILL FIT IN TABLES
	MOVMS C			; ..
	CAILE C,MXNHST		;TOO BIG?
	MOVEI C,MXNHST		;YES, TRIM IT
	MOVNS C			;NEGATIVE AGAIN
	HRL B,C			;AND UPDATE TO TRIMMED VALUE
	MOVE COL,B		;HERE IS THE AOBJN POINTER
	HLLZ NCOL,COL		;SAME, WITH INDEX OF 0 IN RH
	MOVEM B,NHOSTS		;NUMBER OF HOST NAMES
	SETZM HOSTAB		;CLEAR NAME STRINGS
	MOVE C,[HOSTAB,,HOSTAB+1]
	BLT C,EHSTAB
	MOVEI PTR,HOSTAB	;WHERE TO STORE FIRST STRING

GTHL1:	MOVEI A,.GTHIX		;GET HOSTNAME, FROM INDEX
	MOVE B,PTR		;NEXT WORD IN STRING TABLE
	HRLI B,440700		;STRING POINTER
	MOVEI C,(COL)		;INTERNAL INDEX
	GTHST			;GET THE INFO
	 JRST EGETH1		;NOT THERE?
	MOVEI A,0(PTR)		;START OF THIS STRING
	SUBI A,HOSTAB		;AS INDEX INTO TABLE
	MOVEM A,HOSTNT(NCOL)	;SAVE NAME TABLE INDEX
	MOVEI PTR,1(B)		;POINTER FOR NEXT NAME
	MOVEM C,HOSTN(NCOL)	;REMEMBER THE NUMBER
	MOVEM D,NAMSTS(NCOL)	;AND NAME'S STATUS
	AOBJN NCOL,.+1		;STEP TWO COUNTERS
	AOBJN COL,GTHL1		;AND GET ALL HOST NAMES
EGETH1:

;;
	TRNE FM,FNOTLK		;SHOULD WE TALK TO USER
	 JRST NTSTR1		;NO, GO WORK ON CONNECTIONS.

;FIND OUT WHAT TO DO
NTST10:	MOVEI A,400000
	MOVE B,[1B1]
	DIC
	MOVEI A,.CHLFD
	PBOUT
NTST1:	MOVEI A,"*"		;PROMPT CHARACTER
	PBOUT
	PUSHJ P,CHQUES		;CHECK FOR QUESTION MARK.
	 JRST CHELP
	PUSHJ P,CHSEMI
	 JRST NTCMNT		;COMMENT.
	MOVEI A,CMNDF		;SET UP TO LOOK FOR COMMAND.
	MOVEM A,PRSTAB
	MOVEI A,CMNDN
	MOVEM A,PRSTRN
	MOVEI A,PRSFND
	TLO A,RAZ		;RAISE LOWER CASE TO UPPER CASE
	SETZ B,
	PUSHJ P,INEDIT
	 JRST NTCHEL		;NO MATCH
	 JRST NTST10		;RUBOUT
	JUMPE A,NTEOL		;BLANK LINE
	TRZE FM,AGAINF		;FIRST COMMAND OF A REPEAT?
	 PUSHJ P,AGAIN		;YES. RESET THINGS.
	PUSHJ P,ALTSPC		;OUTPUT SPACE IF TERM WAS ALTMODE.
	HLRZ A,(10)		;GET ADDRESS OF ROUTINE TO HANDLE THIS
	PUSHJ P,@A		;COMMAND, AND CALL IT.
	CAIN C,","
	 JRST NTQUES
	TRNE FM,FGO
	 JRST NTEOL
	CAIE C,.CHLFD
	 JRST NTST10
	JRST NTST1

;CHECK FOR BLANK LINE
NTCHEL:	JUMPE A,NTEOL

;ERROR
NTQUES:	HRROI A,[ASCIZ / ??/]
	PSOUT
	JRST NTST10

;COMMENT
NTCMNT:	PUSHJ P,COMENT
	 JRST NTST1+2		;^A PAST ;
	 JRST NTST10		;RUBOUT
	JRST NTST1		;EOL.

;OUTPUT SPACE IF TERM WAS ALTMODE.
ALTSPC:	PUSH P,A
	MOVEI A," "		;SPACE
	CAIN C,33		;DID IT TERMINATE WITH ALTMODE?
	PBOUT			;YES, TYPE SPACE
	POP P,A
	POPJ P,

;COMMAND TABLE
	DEFINE CMNDS(CC)<
CC(ALL,CALL)
CC(HOSTS,CHOSTS)
CC(CONNECTIONS,CCONN)
CC(SPECIFIC,CSPEC)
CC(SITES,CSITE)
CC(SOCKETS,CCONN)
CC(QUIT,CQUIT)
CC(REPEAT,CREPT)
CC(BRIEF,CBRIEF)
CC(VERBOSE,CVERB)
CC(DECIMAL.HOST.NUMBERS,CDECHN)
CC(OCTAL.HOST.NUMBERS,COCTHN)
CC(NO.HOST.NUMBERS,CNOHN)
>


;REPEAT UNTIL "QUIT"
CREPT:	TRO FM,FREPT
	POPJ P,

;QUIT
CQUIT:	TRZ FM,FREPT
	POP P,
	JRST ENDUP

;BRIEF MESSAGES AND HEADINGS
CBRIEF:	TRO FM,FBRIEF
	TRZ FM,FVERB
	POPJ P,

;LONG MESSAGES AND HEADINGS
CVERB:	TRO FM,FVERB
	TRZ FM,FBRIEF
	POPJ P,

;DECIMAL HOST NUMBERS WITH HOST NAME TYPEOUT.
CDECHN:	TRO FM,DECHNF
	POPJ P,

;OCTAL HOST NUMBERS
COCTHN:	TRO FM,OCTHNF
	POPJ P,

;NO HOST NUMBERS
CNOHN:	TRZ FM,DECHNF!OCTHNF
	POPJ P,

;ALL HOSTS AND CONNECTIONS
CALL:	TRO FM,DOSKTF!DOSITF
	POPJ P,

;ALL HOSTS
CHOSTS:	CAIN C,.CHLFD
	 JRST CHORT
	PUSHJ P,NTHGRP		;GET HOST GROUP NAME
	 POPJ P,
CHORT:	TRO FM,DOHSTF!DOSITF
	POPJ P,

;ALL SITES
CSITE:	CAIN C,.CHLFD
	 JRST CSIRT
	PUSHJ P,NTHGRP
	 POPJ P,
CSIRT:	TRO FM,DOSITF
	TRZ FM,DOHSTF
	POPJ P,

;ALL CONNECTIONS
CCONN:	TRO FM,DOSKTF
	POPJ P,

;BLANK LINE.  GO TO OUTPUT SECTION.
NTEOL:	CAIE C,.CHLFD
	 JRST NTQUES
	TRNN FM,DOSKTF!DOHSTF!DOSITF ;ARE ANY SET?
	 TRO FM,DOSKTF!DOSITF	;NO.  DO ALL.
	JRST NTSTRT


;READ IN AND STORE HOST GROUP NAMES.
NTHGRP:	MOVE D,HSTGRP
	MOVEI A,HGRPF
	MOVEM A,PRSTAB
	MOVEI A,HGRPN
	MOVEM A,PRSTRN
	MOVEI A,PRSFND
	TLO A,RAZ		;RAISE LC TO UC.
	MOVEI B,HGMESS
	PUSHJ P,INEDIT
	 JRST NTHGCH
	 POPJ P,		;RUBOUT
	HLRZ A,(10)		;GET GROUP BITS.
	AOJ D,
	HRRZM A,HSTGRP(D)	;SAVE THEM.
	PUSHJ P,ALTSPC		;TYPE SPACE IF TERM WAS ALTMODE.
NTHGR1:	CAIE C,.CHLFD
	 JRST NTHGRP+1		;BACK FOR MORE.
	CAMG D,HSTGRP		;WAS ANYTHING GIVEN?
	 POPJ P,		;NO.
	MOVEM D,HSTGRP		;YES. SAVE POINTER AND RETURN.
	AOS 0(P)
	POPJ P,

;CHECK IF ONLY A CONFIRMING CR.
NTHGCH:	CAIE C,.CHLFD
	 JRST NTHGER
	JUMPN A,NTHGER
	CAME D,HSTGRP
	 JRST NTHGR1+2
	AOS 0(P)
	POPJ P,

NTHGER:	PUSHJ P,QUESMK
	JRST NTHGR1

;HOST GROUP BITS, AND TABLE.
FTENEX==1000
FITS==2000
FDEC10==3000
FTIP==4000
FMTIP==5000
FSERV==400000
FUSER==200000
FNICKN==100000
	DEFINE HGRPS(CC)<
CC(TENEX,FTENEX)
CC(ITS,FITS)
CC(DEC10,FDEC10)
CC(TIP,FTIP)
CC(MTIP,FMTIP)
>

;SPECIFIC CONNECTIONS
CSPEC:	HRROI A,[ASCIZ /CONNECTIONS:/]
	CAIN C,33
	 PSOUT

SP10:	MOVEI A,.CHLFD		;EOL
	PBOUT
SP1:	TRZ FS,FNOT		;CLEAR "NOT" FLAG.
SP3:	MOVEI A,"*"		;TYPE ** PROMPT.
	PBOUT
	PBOUT

SP33:	PUSHJ P,CHQUES
	 JRST SPHELP
	PUSHJ P,CHSEMI
	 JRST SPCMNT
	MOVEI A,SPECF
	MOVEM A,PRSTAB
	MOVEI A,SPECN
	MOVEM A,PRSTRN
	MOVEI A,PRSFND
	TLO A,RAZ		;RAISE LC TO UC.
	SETZ B,
	PUSHJ P,INEDIT
	 JRST SPCHEL
	 JRST SP10		;RUBOUT
	JUMPE A,SPEOL		;BLANK LINE
	PUSHJ P,ALTSPC		;TYPE SPACE IF TERM WAS ALTMODE.
	HLRZ A,(10)		;GET SPECIFICATION ROUTINE.
	PUSHJ P,@A		;CALL IT.
	 JRST SPQUES
	 JRST SP10		;RUBOUT
	TRNE FS,FNOT
	 JRST SP33
	TRO FM,DOSKTF!FSCON	;TYPE OUT SPECIFC CONNECTIONS.
	JRST SP3

;CHECK FOR BLANK LINE
SPCHEL:	JUMPE A,SPEOL

;ERROR
SPQUES:	HRROI A,[ASCIZ / ??/]
	PSOUT
	JRST SP10

;TYPE QUESTION MARK
QUESMK:	HRROI A,[ASCIZ / ? /]
	PSOUT
	POPJ P,


;COMMENT
SPCMNT:	PUSHJ P,COMENT
	 JRST SP33		;^A PAST ;
	 JRST SP10		;RUBOUT
	JRST SP1		;EOL


;SPECIFICATION COMMANDS
	DEFINE SPECS(CC)<
CC(NOT,SPNOT)
CC(STATES,SPSTAT)
CC(SIZES,SPSIZE)
CC(HOSTS,SPHOST)
CC(SITES,SPHOST)
CC(TTYS,SPTTY)
CC(JOBS,SPJOB)
CC(USERS,SPUSE)
CC(LOCAL.SOCKETS,SPLSKT)
CC(FOREIGN.SOCKETS,SPFSKT)
CC(SOCKETS,SPLSKT)
>

; "NOT" SPECIFICATIONS
SPNOT:	CAIN C,.CHLFD
	 POPJ P,
	PUSHJ P,ALTSPC		;TYPE SPACE IF TERM WAS ALTMODE.
	TRNE FS,FNOT		;IS THERE ALREADY A NOT.
	 POPJ P,		;YES. ERROR.
	TRO FS,FNOT		;NO. SET NOT FLAG.
	AOS 0(P)
	AOS 0(P)
	POPJ P,


;EOL
SPEOL:	TRNE FS,FNOT
	 JRST SPQUES		;"NOT" THEN EOL. ERROR.
	TRNE FM,FSCON		;WAS ANYTHING SPECIFIED?
	 TRO FM,FGO		;YES. SET GO FLAG.
	POPJ P,


NTSTRT:	MOVEI A,.CHLFD		;EOL
	PBOUT

NTSTR1:	TRNN FM,DOSITF		;WANT TO DO SITES?
	 JRST ENDUPH		;NO.
	MOVEI A,ENDUPH		;GO TO ENDUPH
	MOVEM A,ABRET		; ON ^O INTERRUPT.
	MOVEI A,400000
	MOVE B,[1B1]
	AIC			;ARM THE ^O INT.

;FIRST, SEE HOW MANY HOSTS THE MONITOR KNOWS OF, WITH OR W/O NAMES.

	MOVEI A,.GTHSZ		;GET HOST TABLE SIZES
	GTHST
	 JRST ENDUPH		;NOT IMPLEMENTED?
	MOVEM C,AC5		;THIS IS THE NUMBER IN HOST HASH TABLE

	MOVE PTR,[POINT 7,STRING]
	MOVEI AC6,HLIST-1
LP2:	MOVEI A,.GTHHI		;GET HOST STATUS & NUM FROM IDX
	MOVEI B,0		;SHOULD BE UNUSED
	MOVEI C,0(AC5)		;THIS INDEX
	GTHST			;GET THE STATUS AND NUMBER
	 JRST DEAD		;FAILED?
	JUMPLE C,DEAD		;IF NO HOST NUMBER OR
	JUMPGE D,DEAD		;IF STATUS BIT 0 OFF, DEAD.
	PUSH AC6,PTR
	MOVE A,PTR
	HRLI A,440700
	MOVE B,C		;FULL HOST NUMBER
	MOVE C,[1B2+12B17+10]
	PUSHJ P,GETHST
	 JRST [POP AC6,PTR
		 JRST DEAD]
	MOVE A,PTR		;NOW COUNT THE CHARS IN NAME
	HRLI A,440700		;RESCAN OVER THE TEXT
	MOVEI C,0		;COUNT FROM 0
LP2A:	ILDB B,A		;GET A NAME CHAR
	AOS C			;COUNT IT
	JUMPN B,LP2A		;LOOP IF NOT AT TND
	HRLM C,0(AC6)		;REMEMBER THE COUNT
	MOVEI PTR,1(A)		;POINT FOR NEXT NAME
DEAD:	AOBJN AC5,LP2		;LOOP THRU ALL INDEXES

	HLRZS AC6		; NUMBER OF UP HOSTS
	JUMPE AC6,[HRROI A,[ASCIZ /
NONE ARE UP.
/]
		SKIPE HSTGRP
		 HRROI A,[ASCIZ /
NONE OF SPECIFIED TYPE ARE UP.
/]
		TRNN FM,FBRIEF	;SKIP IF BRIEF MODE.
		PSOUT
		JRST ENDUPH]
	MOVEI NCOL,8
FIT1:	PUSHJ P,CHKFIT
	 SOSA NCOL
	  AOJA NCOL,FIT1
	PUSHJ P,CHKFIT
	 SOJA NCOL,.-1
	HRROI A,[ASCIZ /
THE FOLLOWING ARE UP:
/]
	TRNN FM,FBRIEF		;SKIP IF BRIEF MODE.
	PSOUT
	SETZ AC7,		; START AT 0
PLN:	MOVEI A,.CHLFD
	PBOUT
	PUSH P,AC7
	MOVE COL,NCOL
PHL:	HRRO A,HLIST(AC7)
	PSOUT
	SOJLE AC6,EPHL
	SOJLE COL,EPHL
	HLRZ B,HLIST(AC7)	; GET WIDTH OF THIS STRING
	SUB B,CWIDTH(COL)	; NEG OF SPACING NEEDED
	MOVEI A," "
	PBOUT
	AOJL B,.-1
	ADD AC7,HITE(COL)
	 JRST PHL
EPHL:	POP P,AC7		; BACK TO WHERE WE STARTED
	AOS AC7			; WHERE TO START NEXT ROW
	JUMPG AC6,PLN
	JRST ENDUPH

; ROUTINE TO SEE IF NCOL COLUMNS WILL FIT

CHKFIT:	MOVE COL,NCOL
	SETZ AC7,
	SETZM TWIDTH
FITLP:	MOVE A,AC6		; TOTAL HOSTS
	SUBI A,0(AC7)		; LESS HOW MANY SO FAR
	ADDI A,-1(COL)		; FIND LEAST INTEGER .GE. AC7/COL
	IDIV A,COL
	MOVEM A,HITE-1(COL)	; KEEP AS HEIGHT OF THIS COL
	MOVNS A
	HRL AC7,A		; MAKE AOBJN PTR
	SETZM CWIDTH-1(COL)	; KEEP MAX WIDTH STRING
FMAXW:	HLRZ A,HLIST(AC7)	; GET WIDTH
	ADDI A,1
	CAML A,CWIDTH-1(COL)
	 MOVEM A,CWIDTH-1(COL)
	AOBJN AC7,FMAXW
	MOVE A,CWIDTH-1(COL)
	ADDB A,TWIDTH		; KEEP TOTAL WIDTH
	CAILE A,^D72
	 POPJ P,
	SOJG COL,FITLP
	AOS 0(P)
	POPJ P,


;SUBROUTINE TO GET HOST NAME
; ACCEPTS IN 1 POINTER TO DESTINATION
;           2 HOST NUMBER
; RETURNS +1 IF NOT OF RIGHT HOST GROUP
;		+2 IF SUCCESS
;
GETHST:	PUSH P,A		;PRESERVE THE ARG AC'S
	PUSH P,B
	PUSH P,C
	PUSH P,D
	MOVE C,B		;ARGS TO GTHST JSYS
	MOVE B,[440700,,TMPSTR]	;STRING POINTER, IF FOUND
	MOVEI A,.GTHNS		;NUMBER TO STRING FUNCTION
	GTHST			;GET THE INFO
	 JRST GETHSU		;NUMBER NOT FOUND
GETHS0:	SKIPN HSTGRP		;IT WAS FOUND. WANT GROUP CHECK?
	JRST GETHS1		;NOPE, GO CHECK SERVERS FLAG
	PUSHJ P,CHHGRP		;SEE IF THIS IS IN THE GROUP
	 JRST GETHR1		;IT ISN'T. FAIL.
	JRST GETHOK		;SUCCESS. RETURN THE NAMESTRING

GETHSU:	MOVE A,B		;POINTER
	MOVE B,C		;NUMBER
	MOVEI C,10		;OCTAL
	NOUT
	 JFCL
	SKIPN HSTGRP		;WANT GROUP?
	JRST GETHOK		;NO. RETURN THE NUMBER, THOUGH
	JRST GETHR1		;WELL, IT ISN'T IN THE GROUP!

GETHS1:	TRNN FM,DOHSTF		;CHECK IF ONLY SERVERS WANTED.
	 JRST GETHOK		;NO
	TXNN D,HS%SRV		;SKIP IF A SERVER
	 JRST GETHR1		;NOT WANTED. SAME AS NOT IN GROUP
GETHOK:	MOVE A,-3(P)		;AND ORIGINAL STRING POINTER
	TRNN FM,DECHNF		;DECIMAL HOST NUMBERS?
	 JRST GETHS2		;NO.
	LDB B,[POINT 8,-2(P),19]
	MOVE C,[1B2+4B17+^D10]	;YES.
	NOUT
	 JFCL
	MOVEI B,"/"
	BOUT
	LDB B,[POINT 16,-2(P),35]
	MOVE C,[6B17+^D10]
	NOUT
	 JFCL
;MORE

; FALLS THRU

GETHS2:	MOVE B,-2(P)		;CALLED HOST NUMBER
	TRNN FM,OCTHNF		;OCTAL HOST NUMBERS?
	 JRST GETHS3		;NO.
	MOVE C,[1B2+12B17+10]	;YES.
	NOUT
	 JFCL
	PUSH P,B
	MOVEI B," "
	IDPB B,A
	POP P,B
GETHS3:	MOVE C,[440700,,TMPSTR]	;ELSE COPY OUT THE NAME
GETHS4:	ILDB D,C
	IDPB D,A
	JUMPN D,GETHS4
	AOS -4(P)
GETHR1:	POP P,D
	POP P,C
	POP P,B
	POP P,A
	POPJ P,

CHHGRP:	PUSH P,A
	MOVE C,D
	ANDI C,17000
	MOVE A,HSTGRP
CHHGR1:	CAMN C,HSTGRP(A)
	JRST CHHGR2
	SOJG A,CHHGR1
	SKIPA
CHHGR2:	 AOS -1(P)
	POP P,A
	POPJ P,

; HOST STATES DONE. NOW REPORT CONNECTION STATUS

ENDUPH:	TRNN FM,DOSKTF
	 JRST ENDUP
	MOVEI A,101
	DOBE			;WAIT FOR ALL HOST STUFF TO MAKE IT OUT.
	MOVEI A,ENDUP		;GO TO ENDUP
	MOVEM A,ABRET		;ON ^O INTERRUPT.
	MOVEI A,400000
	MOVE B,[1B1]
	AIC			;ARM THE ^O INT.
;NOW GET THE INFO ABOUT ALL SOCKETS
	MOVEI A,.GTNSZ		;FIRST, GET THE TABLE SIZE
	GTNCP			; ..
	 JRST ENDUP		;JSYS NOT IMPLEMENTED?
	HLRE C,B		;NEG SIZE
	MOVMS C			;POS SIZE
	CAILE C,TBLSIZ		;FIT IN SPACE ALLOCATED?
	MOVEI C,TBLSIZ		;NO, TRIM IT
	MOVNS C			;NEGATIVE AGAIN
	HRL B,C			;TRIM POINTER, MAYBE
	HLLZM B,NSKT		;REMEMBER FOR LATER SCANNING
	MOVE PTR,B		;NOW A COUNTER STARTING AT 0
	HLLZ AC5,B		;SAME, STARTING AT 0
GETSL1:	MOVEI A,.GTNIX		;ASK BY INDEX
	MOVEI B,(PTR)		;THIS INDEX
	MOVEI C,DGTNCP		;INTO DATA BLOCK
	MOVSI D,-NNCPGT		;THIS MANY DATA ITEMS
	GTNCP			;GET THE POOP
	 JRST ENDUP		;CAN'T FAIL HERE?!?
	MOVSI COL,-NNCPGT	;NOW DISTRIBUTE THE DATA
GETSL2:	MOVE A,DGTNCP(COL)	;GET AN ITEM
	XCT TBLTBL(COL)		;SAVE IT
	AOBJN COL,GETSL2	;INNER LOOP
	AOBJN AC5,.+1		;BOTH INDEXES OF OUTER LOOP
	AOBJN PTR,GETSL1	;OUTER LOOP
	JRST DUMPCN		;GO DUMP CONNECTION INFO

TBLTBL:	NOP			;(00)INDEX
	MOVEM A,FHST(AC5)	;(01)THIS CONN'S FOREIGN HOST
	MOVEM A,NETLSK(AC5)	;(02)THIS CONN'S LOCAL SOCKET
	MOVEM A,NETFSK(AC5)	;(03)THIS CONN'S FOREIGN SOCKET
	DPB A,PFSM		;(04)FSM STATE
	DPB A,PLINK		;(05)LINK NUMBER
	HRLM A,NVT(AC5)		;(06)NVT NUMBER
	DPB A,PBPBYT		;(07)BYTE SIZE
	HRRM A,MSGALL(AC5)	;(10)MSG ALLOCATION
	MOVEM A,NETBAL(AC5)	;(11)BIT ALLOCATION
;	NOP			;(12)DESIRED ALLOCATION
;	NOP			;(13)BITS TRANSFERRED
;	NOP			;(14)BYTES PER BUFFER
;	NOP			;(15)TIMEOUT COUNTER
;	NOP			;(16)CONN STATUS WORD
NNCPGT==.-TBLTBL		;NUMBER OF WORDS TO HANDLE PER CONN

DUMPCN:	TRNE FM,FVERB		;VERB FORCES HEADINGS.
	TRZ FM,FIRSTF
	TRNE FM,FBRIEF
	 TRO FM,FIRSTF		;BRIEF FORCES NO HEADINGS.
	HLLZ AC5,NSKT		;AOBJN THRU ALL CONN'S

DEFINE NUMBER(GETIT,COLUMNS,RADIX,NOT)<
	GETIT
	MOVE C,[XWD 130000+COLUMNS,RADIX]
	CAMN B,[NOT]
	 JRST NEXT
	MOVEI A,101
	NOUT
	 JFCL
>
; CHECK EACH CONNECTION FOR SATISFICATION OF CONDITIONS
; AND TYPE IT IF IT PASSES.
LP4:	TRNN FS,FST		;STATE CONDITIONS
	 JRST LP4A
	PUSHJ P,SKSTAT
	 JRST  NEXT
	TRNN FS,FNST		;FOR "NOT" CASE EXCISE FREE AND DEAD STATES.
	 JRST LP4B
LP4A:	LDB B,PFSM
	CAIE B,16
	 CAIN B,0
	  JRST NEXT
; HOST CONDITIONS
LP4B:	SKIPG HOSTS		;HOSTS .GT. 0 MEANS SELECTED CONNECTION BASED
	 JRST LP4C		;ON CERTAIN HOSTS
	PUSHJ P,SKHOST		;SKIPS IF HOST FOR THIS CONNECTION IS OK
	 JRST NEXT
; TTY CONDITIONS
LP4C:	SKIPG TTYS
	 JRST LP4D
LP4F:	PUSHJ P,SKTTY
	 JRST NEXT
	JRST LP4E

LP4D:	TRNE FM,TTYALL
	 JRST LP4F
; JOB CONDITIONS
LP4E:	SKIPG JOBS
	 JRST LP4G
	PUSHJ P,SKJOB
	 JRST NEXT
; USER CONDITIONS
LP4G:	SKIPG USERS
	 JRST LP4H
	PUSHJ P,SKUSER
	 JRST NEXT
; LOCAL SOCKET CONDITIONS
LP4H:	SKIPG LCLSKT
	 JRST LP4J
	PUSHJ P,SKLSKT
	 JRST NEXT
; FOREIGN SOCKET CONDITIONS
LP4J:	SKIPG FRNSKT
	 JRST LP4I
	PUSHJ P,SKFSKT
	 JRST NEXT
; BYTE SIZE CONDITIONS
LP4I:	SKIPG BYTES		;BYTES>0 MEANS CHECK CONNECTION BYTE
	 JRST LP4K		;SIZE TO SEE IF SHOULD PRINT
	PUSHJ P,SKBYTE		;SKIPS IF BYTE SIZE OK
	 JRST NEXT

LP4K:	HRROI A,[ASCIZ \

ACTIVE CONNECTIONS:
  I STATE LCL-SOCKET     HOST      4N-SOCKET LNK  BITS-ALLOC M-ALL BS/VT
\]
	TRON FM,FIRSTF
	 PSOUT
	MOVEI A,.CHLFD
	PBOUT
	NUMBER(<HRRZ B,AC5>,3,10,-1)
	MOVEI A,40
	PBOUT
	LDB B,PFSM
	HRROI A,STTB(B)
	PSOUT
PRLSK:	NUMBER(<MOVE B,NETLSK(AC5)>,^D12,10,-1)
PRFHN:	MOVE B,FHST(AC5)
	CAMN B,[-1]
	JRST NEXT
	MOVE A,[POINT 7,STRING]
	MOVE C,[1B2+12B17+10]
	CVHST
	 JRST [	MOVE A,[POINT 7,STRING]
		NOUT
		 MOVE A,[POINT 7,STRING]
		JRST .+1]
	MOVEI B," "
	IDPB B,A		; TERMINATE WITH SPACE
	MOVEI A,101
	BOUT			; INITIAL SPACE
	HRROI B,STRING
	MOVEI C,^D100
	MOVEI D," "
	SOUT			; SOUT THRU THE SPACE
	SUBI C,^D<100-12>	; WANT 11 SPACES
	JUMPL D,[HRROI B,[ASCIZ /
/]
		MOVEI C,0
		SOUT
		MOVEI C,^D33
		JRST .+1]
	MOVEI B," "
	SKIPE C
	BOUT
	SOJG C,.-1
PRFSK:	NUMBER(<MOVE B,NETFSK(AC5)>,^D11,10,-1)
PRLNK:	NUMBER(<LDB B,PLINK>,4,10,0)
PRBAL:	NUMBER(<MOVE B,NETBAL(AC5)>,^D12,12,-1)
PRMAL:	NUMBER(<HRRZ B,MSGALL(AC5)>,7,12,-1)
PRBSZ:	HLRE B,NVT(AC5)
	JUMPL B,PRBSZ1
	HRROI A,[ASCIZ / T/]
	PSOUT
	NUMBER(<HLRZ B,NVT(AC5)>,3,10,0)
	JRST PRBSZ2

PRBSZ1:	HRROI A,[ASCIZ /  B/]
	LDB B,PBPBYT
	SKIPE B
	PSOUT
	NUMBER(<LDB B,PBPBYT>,2,12,0)
PRBSZ2:NEXT:	AOBJN AC5,LP4
	HRROI A,[ASCIZ /
There are no active connections.
/]
	TRNE FM,FSCON
	 HRROI A,[ASCIZ /
There are no connections of the specified type.
/]
	TRNN FM,FIRSTF
	PSOUT
ENDUP:	MOVEI A,101
	DOBE			;WAIT TILL IT ALL GETS OUT (OR ^O).
	MOVEI A,.CHLFD
	PBOUT
	MOVEI A,100
	MOVE B,TTYMOD
	SFMOD
	MOVEI A,400000
	MOVE B,[1B1]
	DIC			;DISARM ^O INT.
	TRNN FM,FREPT		;SKIP IF IN REPEAT MODE
	 HALTF
	TRO FM,AGAINF		;FLAG THE REPEAT.
	JRST NTSTAT		;BACK AGAIN.

; MACRO TO HANDLE SPECIFICATION ROUTINES

DEFINE SPSET(MN,RDSUB)<
	TRNN FS,FNOT!FN'MN
	 JRST RDSUB		;NO NOTS.
	TRNN FS,F'MN
	 JRST RDSUB		;NEW SPEC.
	TRNN FS,FN'MN
	 POPJ P,		;NEW NOT. ERROR.
	TRNE FS,FNOT
	 JRST RDSUB		;BOTH ARE NOT.
	HRROI A,[ASCIZ /(NOT) /] ;OLD NOT, TYPE REMINDER.
	PSOUT
	TRO FS,FNOT		;SET NOT FLAG.
	JRST RDSUB

;RETURN
;FIRST CHECK IF ANYTHING WAS INPUT CORRECTLY
;AND THEN SET FLAGS.
SP'MN'RT:	TRO FS,F'MN	;SET FLAG FOR THIS SPEC.
	TRZE FS,FNOT
	 TRO FS,FN'MN		;SET NOT FLAG FOR THIS SPEC.
	AOS 0(P)
SP'MN'RB:	AOS 0(P)	;RUBOUT
SP'MN'ER:	POPJ P,		;ERROR
>


;SIZES
SPSIZE:	SPSET (SI,RDBYTE)

;HOSTS
SPHOST:	SPSET (HO,RDHOST)

;STATES
SPSTAT:	SPSET (ST,RDSTAT)

;TTYS
SPTTY:	SPSET (TT,RDTTT)

;JOBS
SPJOB:	SPSET (JO,RDJOB)

;USERS
SPUSE:	SPSET (US,RDUSER)

;LOCAL.SOCKETS
SPLSKT:	SPSET (LS,RDLSKT)

;FOREIGN.SOCKETS
SPFSKT:	SPSET (FS,RDFSKT)

RDBYTE:	CAIN C,.CHLFD
	 JRST SPSIER		;NO ARGS. ERROR.
	MOVE D,BYTES
RDBYT0:	MOVEI C,12		;DECIMAL INPUT
	HRROI B,HDNUM
	MOVE A,B
	PUSHJ P,CHQUES
	 PSOUT
	PUSHJ P,NUMGET		;READ IN NUMBER.
	 JRST RDBYCH
	 JRST SPSIRB
	JUMPE B,RDBYER		;0 IS ERROR.
	AOJ D,
	MOVEM B,BYTES(D)	;STORE NUM.
RDBYT1:	CAIE C,.CHLFD		;EOL
	 JRST RDBYT0		;BACK FOR MORE.
	CAMG D,BYTES
	 JRST SPSIER		;NOTHING GIVEN. ERROR.
	MOVEM D,BYTES
	JRST SPSIRT		;RETURN
RDBYCH:	CAIN C,.CHLFD
	 JUMPE A,RDBYT1+2
RDBYER:	PUSHJ P,QUESMK
	JRST RDBYT1

RDTTT:	CAIN C,.CHLFD
	 JRST RDTTAL		;NO ARGS, ALL TTYS.
	MOVE D,TTYS
RDTTY0:	MOVEI C,10		;OCTAL INPUT
	HRROI B,HONUM
	MOVE A,B
	PUSHJ P,CHQUES
	 PSOUT
	PUSHJ P,NUMGET
	 JRST RDTTCH
	 JRST SPTTRB
	JUMPE B,RDTTER		;0 IS ERROR.
	AOJ D,
	MOVEM B,TTYS(D)
RDTTY1:	CAIE C,.CHLFD
	 JRST RDTTY0
	CAMG D,TTYS
	 JRST SPTTER
	MOVEM D,TTYS
	JRST SPTTRT		;RETURN

RDTTCH:	CAIE C,.CHLFD
	 JRST RDTTER
	JUMPN A,RDTTER
	CAME D,TTYS
	 JRST RDTTY1+4
	JRST RDTTAL

RDTTER:	PUSHJ P,QUESMK
	JRST RDTTY1

RDTTAL:	TRO FM,TTYALL
	JRST SPTTRT

RDJOB:	CAIN C,.CHLFD
	 JRST SPJOER
	MOVE D,JOBS
RDJOB0:	MOVEI C,12		;DECIMAL INPUT
	HRROI B,HDNUM
	MOVE A,B
	PUSHJ P,CHQUES
	 PSOUT
	PUSHJ P,NUMGET
	 JRST RDJOCH
	 JRST SPJORB
	AOJ D,			;ZERO JOB OK.
	MOVEM B,JOBS(D)
RDJOB1:	CAIE C,.CHLFD
	 JRST RDJOB0
	CAMG D,JOBS
	 JRST SPJOER
	MOVEM D,JOBS
	JRST SPJORT		;RETURN

RDJOCH:	CAIN C,.CHLFD
	 JUMPE A,RDJOB1+2
RDJOER:	PUSHJ P,QUESMK
	JRST RDJOB1

; SUBROUTIN TO READ IN A NUMBER.
;ACCEPTS IN 3 THE RADIX.
;RETURNS +1 IF ERROR.
;RETURNS +2 WITH NUMBER IN B, # OF CHARS IN A, AND TERMINATOR IN C.
;
NUMGET:	PUSH P,D
	PUSH P,AC5
	SETZ A,
	MOVE D,C
	PUSHJ P,INEDIT		;GET STRING.
	 0
	 JRST NMGRT2		;RUBOUT
	MOVE AC5,A
	MOVE A,B
	EXCH C,D
	NIN			;CONVERT IT TO A NUMBER.
	 JRST NMGRT1		;ERROR
	AOS -2(P)
NMGRT2:	AOS -2(P)
NMGRT1:	MOVE C,D
	MOVE A,AC5
	POP P,AC5
	POP P,D
	POPJ P,

;GET LOCAL SOCKET SPECS.

RDLSKT:	CAIN C,.CHLFD
	 JRST SPLSER		;NO ARGS,   ERROR.
	MOVEI AC5,LCLSKT		;PNTR TO CORRECT TABLE.
	PUSHJ P,RDSKTS		;GET SOCKET RANGE WORDS.
	 JRST SPLSER		;ERROR.
	 JRST SPLSRB		;RUBOUT.
	MOVEM D,LCLSKT		;OK. RETURN.
	JRST SPLSRT


;GET FOREIGN SOCKET SPECS.

RDFSKT:	CAIN C,.CHLFD
	 JRST SPFSER		;NO ARGS,  ERROR.
	MOVEI AC5,FRNSKT		;PNTER TO CORRECT TABBLE.
	PUSHJ P,RDSKTS		;GET SOCKET RANGE WORDS.
	 JRST SPFSER		;ERROR.
	 JRST SPFSRB		;RUBOUT.
	JRST SPFSRT		;OK. RETURN.

;RETURNS +1 IF ERROR
;	+2 IF RUBOUT
;	+3 IF OK HAVING PUT SOCKET RANGES INTO TABLE INDEXED
;		BY D.

RDSKTS:	MOVE D,0(AC5)		;GET OFFSET INTO TABLE.
	ADD D,AC5			;GET INDEX INTO TABLE.
RDSKT0:	HRROI B,HSKTS		;SOCKETS HELP MESSAGE.
	MOVE A,B
	PUSHJ P,CHQUES
	 PSOUT
	SETZ A,
	PUSHJ P,INEDIT
	 0
	 JRST RDSKRB		;RUBOUT
	CAIN C,.CHLFD		;WAS TERM EOL?
	 JUMPE A,RDSKT4		;YES.  JUMP IF BLANK SPEC.
	MOVE AC6,C		;SAVE TERM CHAR.
	MOVE A,B
	ILDB B,B		;GET FIRST CHAR.
	CAIE B,"<"		;CHECK IF < OR > RANGGE.
	CAIN B,">"
	 JRST [ MOVEM B,2(D)	;YES. SAVE WHICH AND GET NUMBER.
		  ILDB B,A	;MOVE ON TO FIRST CHAR OF NUMBER.
		  JRST RDSKT2
		]
	CAIL B,"0"
	CAILE B,"7"		;MUST BE OCTAL DIGIT.
	 JRST RDSKER
	MOVEI C,10
	NIN			;GET FIRST SOCKET.
	 JRST RDSKER
	TLZE B,740000		;32 BIT MAX.
	 JRST RDSKER
	MOVEM B,1(D)		;PUT INTO TABLE TEMPORARILY.
	LDB C,A			;GET MIDDLE CHAR.
	JUMPE C,[MOVEM B,2(D)	;SINGLE SOCKET.  USE IT AS FINAL ALSO.
		   JRST RDSKT1
		  ]
	CAIE C,"+"
	CAIN C,"-"		;MUST BE + OR -.
	CAIA
	 JRST RDSKER
	MOVEM C,2(D)		;SAVE MIDDLE CHAR.
RDSKT2:	MOVE B,A
	ILDB B,B		;GET FIRST CHAR OF SECOND NUM.
	CAIL B,"0"
	CAILE B,"7"		;MUST BE OCTAL DIGIT.
	 JRST RDSKER
	MOVEI C,10
	NIN			;GET SECOND NUM.
	 JRST RDSKER
	MOVE C,2(D)		;GET MIDDLE CHAR BACK.
	CAIN C,"+"		;IS THIS THE RANGE?
	 ADD B,1(D)		;YES.  GET IT AS LAST SOCKET.
	TLZE B,740000		;32 BIT MAX.
	 JRST RDSKER
	CAIN C,"<"		;CHECK FOR LESS-THAN RANGE.
	 JRST [ MOVEM B,2(D)	;YES.  USE NUMBER AS TOP
		  SETZM 1(D)	;AND ZERO AS BOTTOM.
		  JRST RDSKT3
		]
	CAIN C,">"		;CHECK FOR GREATER-THAN RANGE.
	 JRST [ MOVEM B,1(D)	;YES.  USE NUMBER AS BOTTOM AND
		  HRLOI B,37777	;MAXIMUM 32-BIT NUMBER AS TOP.
		  MOVEM B,2(D)
		  JRST RDSKT3
		]
	MOVEM B,2(D)		;NEITHER. SAVE IT IN TABLE AS TOP.

RDSKT3:	LDB B,A			;CHECK CHAR WHICH TERMINATED THE NIN.
	JUMPN B,RDSKER		;SHOULD HAVE BEEN FINAL CHAR (THUS ZERO)

RDSKT1:	ADDI D,2		;MAKE THEM SEMI-OFFICIAL.
	CAIE AC6,.CHLFD		;WAS TERM A <EOL>?
	 JRST RDSKT0		;NO.  BACK FOR MORE.
RDSKT4:	SUB D,AC5			;YES. GET OFFSET.
	MOVEM D,0(AC5)		;ALL IS FULLY OFFICIAL NOW.
	AOS (P)
RDSKRB:	AOS (P)
RDSKER:	POPJ P,


RDHOST:	CAIN C,.CHLFD
	 JRST SPHOER
	MOVE D,HOSTS
RDHST0:	HRROI B,HELPHO
	MOVE A,B
	PUSHJ P,CHQUES
	 PSOUT
	MOVEI A,HSTVER
	TLO A,RAZ		;RAISE LC TO UC.
	PUSHJ P,INEDIT		;READ HOST NAME WITH RECOGNITION.
	 JRST RDHOCH
	 JRST SPHORB
	JUMPE A,RDHST2		;NOTHING GIVEN
	HLRZ A,(10)		;GET ANSWER. 10 POINTS INTO TABLE
	SKIPE HVMTCH
	 JRST SETGRP		;A HOST GROUP
	MOVEI A,0(10)		;POINTER INTO HOSTNT
	SUBI A,HOSTNT		;BUT WE NEED HOSTN TABLE
	MOVE A,HOSTN(A)		;GET HOST NUMBER
RDHST1:	AOJ D,
	MOVEM A,HOSTS(D)	;SAVE IT.
	PUSHJ P,ALTSPC		;TYPE SPACE IF TERM WAS ALTMODE.
RDHST2:	CAIE C,.CHLFD
	 JRST RDHST0		;BACK FOR MORE.
	CAMG D,HOSTS		;ANY GIVEN?
	 JRST SPHOER		;NO, ERROR.
	MOVEM D,HOSTS		;YES, SAVE POINTER.
	JRST SPHORT

SETGRP:	ANDI A,17000		;GET GROUP BITS.
	JRST RDHST1

RDHOCH:	CAIN C,.CHLFD
	 JUMPE A,RDHST2+2

RDHOER:	PUSHJ P,QUESMK
	JRST RDHST2

;RECOGNITION ROUTINE FOR HOSTS.
; CALLED FROM INEDIT ON "$" FOR RECOGNITION.
;CHECKS FOR BOTH HOST NAME OR HOST GROUP.
;ALSO CHECKS FOR A NUMBER TO BE USED AS HOST NUM.

HSTVER:	PUSH P,AC5
	PUSH P,A		;SAVE ARGS.
	HRRZS B			;GET CHAR COUNT ONLY.
	PUSH P,B
;CHECK FOR HOST NUM.
	MOVE AC5,A
	ILDB AC5,AC5
	CAIL AC5,"0"
	CAILE AC5,"7"
	 SKIPA
	JRST HSTVNM
	SETZM HVMTCH
	MOVEI AC5,HGRPF
	MOVEM AC5,PRSTAB
	MOVEI AC5,HGRPN
	MOVEM AC5,PRSTRN
	PUSHJ P,PRSFND		;CHECK FOR HOST GROUP
	 JRST HSTVR1		;NOT A GROUP.
	 JRST HSVAMB		;HOST GROUP IS AMBIGUOUS.
	SETOM HVMTCH		;A HOST GROUP.
HSTVR1:	EXCH A,-1(P)		;SAVE POINTERS AND GET ARGUMENTS BACK.
	EXCH B,0(P)
	MOVEI AC5,HOSTNT	;TABLE OF OFFSETS INTO STRINGS
	MOVEM AC5,PRSTAB
	MOVEI AC5,HOSTAB	;TABLE OF NAMESTRINGS
	MOVEM AC5,PRSTRN
	PUSHJ P,PRSFND		;LOOK FOR HOST NAME.
	 JRST NTHST		;NOT A HOST.
	 JRST HSVAMB		;HOST NAME AMBIGUOUS.
	SKIPE HVMTCH
	 JRST HSVAMB		;BOTH ARE AMBIGUOUS.
HSVRTN:	SUB P,[2,,2]
HSVRT3:	AOS -1(P)
HSVRT2:	AOS -1(P)
HSVRT1:	POP P,AC5
	POPJ P,

HSVAMB:	SUB P,[2,,2]
	JRST HSVRT2

NTHST:	POP P,B
	POP P,A
	SKIPE HVMTCH
	 JRST HSVRT3
	JRST HSVRT1

HSTVNM:	PUSH P,C
	MOVEI C,10		;HOST NUMBERS READ IN OCTAL
	NIN
	 JRST HVNMER
	HRLZM B,HVNUM		;PUT INTO LEFT HALF (AS IN HOSTAB)
	MOVEI B,HVNUM		;AND POINT TO IT.
	POP P,C
	JRST HSVRTN

HVNMER:	POP P,C
	SUB P,[2,,2]
	JRST HSVRT1

HVNUM:	0

HVMTCH:	0

RDSTAT:	CAIN C,.CHLFD
	 JRST SPSTER
	SETZ D,

RDST1:	HRROI A,HELPST
	PUSHJ P,CHQUES
	 PSOUT
	MOVEI A,STVER		;SET UP TO VERIFY STATES
	TLO A,RAZ		;RAISE LC TO UC.
	HRROI B,HELPST		;HELP STRING.
	PUSHJ P,INEDIT		;GET VERIFIED STATE STRING
	 JRST RDSTCH		;NOT A VALID STATE
	 JRST SPSTRB		;RUBOUT.
	JUMPE A,RDST2
	SUBI 10,STTB-1
	MOVNS 10
	HRLZI AC5,400000
	ROT AC5,(10)
	IOR D,AC5
	PUSHJ P,ALTSPC		;TYPE SPACE IF TERM WAS ALTMODE.
RDST2:	CAIE C,.CHLFD		;CHECK FOR EOL
	 JRST RDST1		;NO.  GET NEXT STATE.
	JUMPE D,SPSTER
	IORM D,STATES
	JRST SPSTRT		;YES. BACK FOR NEXT SPEC.

RDSTCH:	CAIN C,.CHLFD
	 JUMPE A,RDST2+2

STBAD:	PUSHJ P,QUESMK
	JRST RDST2



;VERIFY STATE STRING
STVER:	PUSH P,11
	PUSH P,10
	PUSH P,C		;SAVE C
	PUSH P,D		;SAVE D
	HRRZS B
	MOVNS B			;NEGATE COUNT
	MOVE C,[POINT 7,STTB]
	HRROI D,-20
	PUSHJ P,CSVER
	 JRST STVN
	 JRST STVA
	MOVE B,10
	MOVE A,11
	AOS -4(P)		;UNIQUE
STVA:	AOS -4(P)		;AMBIGUOUS
STVN:	POP P,D			;NO MATCH.  RESTORE D
	POP P,C			;RESTORE C
	POP P,10
	POP P,11
	POPJ P,			;RETURN



; READ IN USER NAMES.
RDUSER:	CAIN C,.CHLFD
	 JRST SPUSER
	MOVE D,USERS
RDUSE0:	HRROI A,HELPUS
	PUSHJ P,CHQUES
	 PSOUT
	MOVEI A,VRDIR		;SET UP TO RECOGNIZE NAMES.
	TLO A,RAZ		;RAISE LC TO UC.
	HRROI B,HELPUS		;HELP STRING.
	PUSHJ P,INEDIT		;GO GET NAME.
	 JRST RDUSCH		;NOT KNOWN.
	 JRST SPUSRB		;RUBOUT.
	JUMPE A,RDUSE3
	AOJ D,			;FOUND ONE.  DIR # IS AN AC10.
	MOVEM 10,USERS(D)	;SAVE IT.
	PUSHJ P,ALTSPC		;TYPE SPACE IF TERM WAS ALTMODE.
RDUSE3:	CAIE C,.CHLFD
	 JRST RDUSE0
	CAMG D,USERS
	 JRST SPUSER
	MOVEM D,USERS
	JRST SPUSRT		;RETURN

RDUSCH:	CAIN C,.CHLFD
	 JUMPE A,RDUSE3+2

RDUSE5:	PUSHJ P,QUESMK
	JRST RDUSE3

;RECOGNIZE DIR NAMES.
VRDIR:	PUSH P,D
	PUSH P,C
	HRRZS B
	PUSH P,B
	PUSH P,A
	MOVE B,A
	SETZ C,
	SOUT			;FIRST FIND END OF STRING FOR LATER USE.
	MOVE D,A		;SAVE IN D.
	POP P,A
	POP P,B
	POP P,C			;GET ARGS BACK.
	JUMPE B,VRDRT3		;NULL STRING.
	MOVE B,A		;SET UP FOR RCUSR CALL.
	SETZ A,			;USE RECOGNITION
	RCUSR			;VERIFY DIR STRING
	 ERJMP VRDRT3		;NOT KNOWN.
	TXNE A,RC%NOM		;WAS THERE A MATCH
	JRST VRDRT3		;NO, GIVE ERROR
	TXNE A,RC%AMB		;AMBIGIOUS?
	JRST VRDRT2		;YES.
	MOVE A,D		;GET REST OF NAME.
	MOVE B,C		;AND USER NUMBER
	AOS -1(P)
VRDRT2:	AOS -1(P)
VRDRT3:	POP P,D
	POPJ P,


SKHOST:	MOVE B,FHST(AC5)	;SKIP IF HOST NAME IS IN LIST.
	HLLZ C,NHOSTS		;CHECK FOR HOST TYPE.
SKHOS0:	MOVE D,HOSTN(C)
	CAME D,B		;THIS HOST NUMBER SELECTED?
	AOBJN C,SKHOS0
	MOVE D,NAMSTS(C)	;IF SO, GET HOST TYPE
	ANDI D,17000
	MOVE C,HOSTS
SKHOS1:	SKIPG A,HOSTS(C)
	 JRST SKHOGR
	CAMN B,A
	 JRST SKHORT
SKHOS2:	SOJG C,SKHOS1
	TRNE FS,FNHO		;CHECK "NOT" FLAG AND ADJUST RETURN.
	 AOS 0(P)
	POPJ P,
SKHORT:	TRNN FS,FNHO
	 AOS 0(P)
	POPJ P,

SKHOGR:	CAMN D,A
	 JRST SKHORT
	JRST SKHOS2


SKBYTE:	LDB B,PBPBYT		;SKIP IF BYTE SIZE IS IN LIST.
	MOVE C,BYTES
SKBYTL:	CAMN B,BYTES(C)
	 JRST SKBYT1
	SOJG C,SKBYTL
	TRNE FS,FNSI		;CHECK "NOT" FLAG AND ADJUST RETURN.
	 AOS 0(P)
	POPJ P,

SKBYT1:	TRNN FS,FNSI
	 AOS 0(P)
	POPJ P,



;SKIP IF TTY NUMBER IS IN LIST.
SKTTY:	HLRE B,NVT(AC5)	;GET TTY #
	JUMPL B,TTNSKP		;NOT A TTY
	TRNE FM,TTYALL
	 JRST TTSKP		;ALL TTYS FLAG SET. SKIP.
	MOVE C,TTYS
SKTTY1:	CAMN B,TTYS(C)
	 JRST TTSKP
	SOJG C,SKTTY1
TTNSKP:	TRNE FS,FNTT
	 AOS 0(P)
	POPJ P,
TTSKP:	TRNN FS,FNTT
	 AOS 0(P)
	POPJ P,

;SKIP IF JOB NUMBER IS IN LIST.
SKJOB:	LDB B,[POINT 17,NETLSK(AC5),20] ;GET LOCAL SOCKET.
	CAIGE B,^D100000	;IS IT JOB REL?
	 POPJ P,		;NO.
	SUBI B,^D100000
	MOVE C,JOBS
SKJOB0:	CAMN B,JOBS(C)
	 JRST SKJOB1
	SOJG C,SKJOB0
	TRNE FS,FNJO
	 AOS 0(P)
	POPJ P,

SKJOB1:	TRNN FS,FNJO
	 AOS 0(P)
	POPJ P,


SKSTAT:	LDB B,PFSM		;GET STATE
	MOVE C,STATES
	ROT C,(B)
	JUMPL C,SKSTT1
	TRNE FS,FNST		;CHECK "NOT" FLAG AND ADJUSS RETURN.
	 AOS 0(P)
	POPJ P,

SKSTT1:	TRNN FS,FNST
	 AOS 0(P)
	POPJ P,


;SKIP IF USER IS IN LIST
SKUSER:	LDB B,[POINT 17,NETLSK(AC5),20]
	SKIPN B
	 POPJ P,		;0 HIGH ORDER PART.
	CAIL B,^D100000
	 POPJ P,		;JOB REL
	MOVE C,USERS
SKUSRL:	CAMN B,USERS(C)
	 JRST SKUSR1
	SOJG C,SKUSRL
	TRNE FS,FNUS
	 AOS 0(P)
	POPJ P,

SKUSR1:	TRNN FS,FNUS
	 AOS 0(P)
	POPJ P,


;SKIP IF LOCAL SOCKET IS ON LIST.
SKLSKT:	MOVE B,NETLSK(AC5)	;GET LOCAL SOCKET.
	MOVEI D,LCLSKT		;USE LOCAL SOCKET TABLE.
	MOVEI C,FNLS		;USE CORRECT FLAG.
	JRST SKSOKT		;GO TO COMMON ROUTINE FOR SOCKETS.

;SKIP IF FOREIGN SOCKET IS ON LIST.
SKFSKT:	MOVE B,NETFSK(AC5)	;GET FOREIGN SOCKET.
	MOVEI D,FRNSKT		;USE FOREIGN SOCKET TABLE.
	MOVEI C,FNFS		;USE CORRECT FLAG.
	JRST SKSOKT		;GO TO COMMON ROUTINE FOR SOCKETS.


;COMMON ROUTINE FOR SKIP IF SOCKET IS ON LIST.
SKSOKT:	MOVN A,0(D)		;NEGATIVE COUNT OF ENTRIES.
	HRL D,A			;SET FOR LOOP.
SKOSK1:	CAML B,1(D)		;SEE IF IT IS IN THIS RANGE.
	CAMLE B,2(D)
	CAIA			;NO.
	 JRST SKSKP		;YES.
	AOBJN D,.+1		;MOVE ON
	AOBJN D,SKOSK1		;TO NEXT RANGE.
SKNSKP:	TRNE FS,0(C)		;NOT FOUND.
	 AOS 0(P)
	POPJ P,
SKSKP:	TRNN FS,0(C)		;FOUND.
	 AOS 0(P)
	POPJ P,



;CHECK FOR QUESTION MARK AND SKIP IF NONE.
CHQUES:	PUSH P,A
	PBIN
	CAIN A,"?"
	 JRST CHQURT
	MOVEI 1,100
	BKJFN
	 0
	AOS -1(P)
CHQURT:	POP P,A
	POPJ P,


;CHECK FOR SEMI-COLON AND SKIP IF NONE.
CHSEMI:	PUSH P,A
	PBIN
	CAIE A,";"
	 AOS -1(P)
	MOVEI A,100
	BKJFN
	 0
	POP P,A
	POPJ P,


;HANDLE COMMENT
COMENT:	MOVE A,[POINT 7,TEMP]
	MOVEI B,TMPSIZ*5-1	;NUM OF CHARS -1
	JRST RDLINE



;ROUTINE TO READ IN A LINE OF TEXT.
;EDITTED BY ^A ^R AND RUBOUT.
;TERMINATED BY <CR>.
; ENTER WITH:
; A - POINTER TO DESTINATION
; B - MAX NUMBER OF CHARS
; RETURNS:
; +1 - IF USER TRIED TO ^A PAST START OF STRING
; +2 - ON RUBOUT (XXX ALREADY TYPED)
; +3 - <CR> TERMINATION. STRING AT DESTINATION, UPDATES POINTER IN AC1.
;
RDLINE:	HRLI B,(RD%BRK+RD%BEL+RD%CRF+RD%RND)
	PUSH P,C
	SETZ C,
	RDTTY
	 JSHLT
	POP P,C
	AOS 0(P)		;NEVER GIVE +1 RETURN
	TXNE B,RD%BLR		;EDITTED BACK TO BEG OF STRING?
	RET			;YES, RETURN +2
	HRLI B,0		;NO, CLEAR FLAGS
	AOS 0(P)		;GIVE +3 RETURN
	RET

;SETUP TABLES AND FLAGS AND ^O INTERRUPT.
SETUP:	SETZ FM,
SETAGN:	SETZ FS,
	SETZM HOSTS
	SETZM BYTES
	SETZM STATES
	SETZM JOBS
	SETZM TTYS
	SETZM USERS
	SETZM HSTGRP
	SETZM LCLSKT
	SETZM FRNSKT

	MOVEI A,400000
	MOVE B,[LEVTAB,,CHNTAB]
	SIR			;SET UP INT TABLES.
	SETO B,
	DIC			;NO INTS YET.
	MOVE A,[^D15,,1]	;^O TO CHAN 1.
	ATI
	MOVEI A,400000
	EIR			;ENABLE INTS.

	POPJ P,


;STOP OUTPUT ON ^O
;CLEARS OUTPUT BUFFER AND DEBRK'S TO ADDRESS IN ABRET.
STPOUT:	MOVEI A,101
	CFOBF
	MOVE A,PC
	HRR A,ABRET		;NEW RETURN ADDRESS
	TLO A,010000		;TURN ON USER MODE BIT
	MOVEM A,PC
	DEBRK


;ROUTINE TO DO RECOGNITION FOR INEDIT
;ADDRESS OF POINTER TABLE IS IN PRSTAB
; TABLE IN FORM    ARG,,STRING POINTER
;WILL ALLWAYS SEARCH THE WHOLE TABLE.

PRSFND:	PUSH P,D
	PUSH P,10
	PUSH P,11
	PUSH P,12
	PUSH P,13
	MOVE D,A
	SETZM MATSW
	SETZ 12,
	HRRZ 10,PRSTAB

FNDLP:	HRRZ 11,0(10)
	ADD 11,PRSTRN
	HRLI 11,440700
	PUSHJ P,COMPAR
	 JRST PRNEXT
	SKIPE MATSW
	 JRST FNDTWO
	SETOM MATSW
	MOVE 12,10
	MOVE 13,11

PRNEXT:	AOJ 10,
	SKIPN 0(10)
	 JRST FNDRT
	MOVE A,D
	JRST FNDLP

FNDRT:	SKIPN MATSW
	 JRST FNDRT1
FNDRT3:	JUMPE 12,FNDRT2
	MOVE B,12
	MOVE A,13
	AOS -5(P)
FNDRT2:	AOS -5(P)
FNDRT1:	POP P,13
	POP P,12
	POP P,11
	POP P,10
	POP P,D
	POPJ P,

PRSTRN:	BLOCK 1
PRSTAB:	BLOCK  1
MATSW:	BLOCK 1

COMPAR:	PUSH P,D
	ILDB D,A
	JUMPE D,MAT
	ILDB B,11
	JUMPE B,NOMAT
	CAME D,B
	 JRST NOMAT
	JRST COMPAR+1

MAT:	AOS -1(P)
NOMAT:	POP P,D
	POPJ P,


;FOUND TWO MATCHES.
FNDTWO:	CAIN C,33		;IS THIS AN ALTMODE SEARCH?
	 JRST FNDRT2		;YES. AMBIGOUS.
	JUMPE 12,FNDTW0		;NO.  SEE IF WE HAVE A COMPLETED STRING.
	ILDB B,13
	JUMPE B,FNDRT3
FNDTW0:	ILDB B,11
	JUMPE B,FNDTW1
	SETZ 12,
	JRST PRNEXT

FNDTW1:	MOVE 12,10
	MOVE 13,11
	JRST FNDRT3

CHNTAB:	XWD 0
	XWD 1,STPOUT		;ON ^O INT.
	BLOCK ^D34

LEVTAB:	PC
	0
	0

PC:	0

ABRET:	0

;FIELDS IN NETSTS (NO LONGER SAME AS WAS IN MONITOR CORE)

PBPBYT:	POINT 6,NETSTS(AC5),17
PFSM:	POINT 4,NETSTS(AC5),3
PLINK:	POINT 8,NETSTS(AC5),35

STTB:	ASCIZ /DEAD/
	ASCIZ /CLZD/
	ASCIZ /PNDG/
	ASCIZ /LSNG/
	ASCIZ /RFCR/
	ASCIZ /CLW2/
	ASCIZ /RFCS/
	ASCIZ /OPND/
	ASCIZ /CLSW/
	ASCIZ /DATW/
	ASCIZ /RFN1/
	ASCIZ /CLZW/
	ASCIZ /RFN2/
	ASCIZ /KILD/
	ASCIZ /FREE/
	ASCIZ /AAGH/

DEFINE A1(NAM,F)<
	ASCIZ \NAM\>

DEFINE A2(NAM,F)<
Q==0
IRPC NAM,<
Q==Q+1>
	XWD F,QQ
QQ==QQ+<<Q+5>/5>>

QQ==0
CMNDN:	CMNDS(A1)
CMNDF:	CMNDS(A2)
	0

QQ==0
SPECN:	SPECS(A1)
SPECF:	SPECS(A2)
	0

QQ==0
HGRPN:	HGRPS(A1)
HGRPF:	HGRPS(A2)
	0

PDL:	BLOCK 100

TMPSIZ==200
TEMP:	BLOCK TMPSIZ

TTYMOD:	BLOCK 1
NHOSTS:	BLOCK 1
NSKT:	BLOCK 1
STRING:	BLOCK 2000
TMPSTR:	BLOCK 40
HLIST:	BLOCK 1000
CWIDTH:	BLOCK ^D72
TWIDTH:	BLOCK 1
HITE:	BLOCK ^D72
HSTGRP:	BLOCK 10
HOSTS:	BLOCK 44
BYTES:	BLOCK 44
STATES:	BLOCK 1
TTYS:	BLOCK 44
JOBS:	BLOCK 44
USERS:	BLOCK 44
LCLSKT:	BLOCK 110
FRNSKT:	BLOCK 110
HOSTAB:	BLOCK 2*MXNHST
EHSTAB=.-1			;END FOR CLEARING
HOSTN:	BLOCK MXNHST+1		;THE HOST NUMBER
HOSTNT:	BLOCK MXNHST+1		;INDEX INTO NAME TABLE (HOSTAB)
NAMSTS:	BLOCK MXNHST+1		;STATUS FOR NAME
;
FHST:	BLOCK TBLSIZ		;FOREIGN HOST
NVT:				;SHARE TABLE. NVT IN LH
MSGALL:	BLOCK TBLSIZ		;RH = MESSAGE ALLOCATION FOR THIS CONN
NETBAL:	BLOCK TBLSIZ		;BIT ALLOCATION
NETFSK:	BLOCK TBLSIZ		;FOREIGN SOCKET
NETLSK:	BLOCK TBLSIZ		;LOCAL SOCKET NUMBER
NETSTS:	BLOCK TBLSIZ		;BYTESIZE, FSM, AND LINK

DGTNCP:	BLOCK NNCPGT		;GTNCP JSYS READS DATA INTO HERE

;HELP ROUTINE FOR COMMANDS.
CHELP:	MOVEI A,CHELRT
	MOVEM A,ABRET		;ADDRESS FOR ^O RETURN.
	MOVEI A,400000
	MOVE B,[1B1]
	AIC			;TURN ^O ON.
	TROE FM,HELPF
	 JRST CHELP0
	HRROI A,HBRIEF		;GET BRIEF MESSAGE
	JRST CHELP1

CHELP0:	TRZ FM,HELPF
	HRROI A,HLONG		;LONG MESSAGE.
CHELP1:	PSOUT
CHELRT:	MOVEI A,101
	DOBE			;WAIT TILL ITS ALL OUT (OR ^O).
	MOVEI A,400000
	MOVE B,[1B1]
	DIC			;TURN ^O OFF.
	JRST NTST10

HBRIEF:	ASCIZ /
 (^O TO STOP OUTPUT)
 AVAILABLE COMMANDS ARE:
  ALL, HOSTS, SITES, CONNECTIONS, SOCKETS, SPECIFIC, BRIEF, VERBOSE,
  DECIMAL.HOST.NUMBERS, OCTAL.HOST.NUMBERS, NO.HOST.NUMBERS,
  REPEAT, QUIT, OR BLANK.
 FOR MORE HELP TYPE ? AGAIN.
/

HLONG:	ASCIZ /
 POSSIBLE COMMANDS:
  ALL		GIVES STATUS OF BOTH SITES AND CONNECTIONS
  SITES		GIVES STATUS OF ALL SITES
  HOSTS		GIVES STATUS OF HOSTS ONLY
		(BOTH THE ABOVE CAN TAKE A SITE TYPE AS ARGUMENT)
  CONNECTIONS GIVES STATUS OF ALL CONNECTIONS
  SOCKETS SAME AS "CONNECTIONS"
  BRIEF		NO HEADINGS OR MESSAGES TO BE TYPED.
  VERBOSE ALL HEADINGS OR MESSAGES TO BE TYPED.
		(THE DEFAULT IS TO TYPE HEADINGS THE FIRST TIME AND
		 NOT AGAIN.)
  DECIMAL.HOST.NUMBERS
		PRINT DECIMAL HOST NUMBERS WITH HOST NAMES.
  OCTAL.HOST.NUMBERS
		PRINT OCTAL HOST NUMBERS WITH HOST NAMES.
  NO.HOST.NUMBERS
		DO NOT PRINT HOST NUMBERS.
  REPEAT COME BACK FOR MORE COMMANDS INSTEAD OF QUITTING.
  QUIT		QUIT NETSTAT.

  SPECIFIC ALLOWS SELECTION OF SPECIFIC CONNECTIONS.
		POSSIBLE SPECIFICATIONS ARE:
    SITES CONNECTIONS WITH SPECIFIC SITES (OR SITE TYPES)
    HOSTS SAME AS "SITES"
    JOBS CONNECTIONS RELATIVE TO SPECIFIC JOBS
    SIZES CONNECTIONS WITH SPECIFIC BYTE SIZES
    STATES CONNECTIONS IN SPECIFIC STATES
    TTYS CONNECTIONS WITH SPECIFIC TTYS
    USERS CONNECTIONS RELATIVE TO SPECIFIC USERS
    SOCKETS CONNECTIONS WITH THE SPECIFIED LOCAL SOCKETS
    LOCAL.SOCKETS  SAME AS "SOCKETS"
    FOREIGN.SOCKETS
		CONNECTIONS WITH THE SPECIFIED FOREIGN SOCKETS
    NOT		ALL CONNECTIONS WITHOUT THE FOLLOWING SPECIFICATION

     EACH SPECIFICATION CAN HAVE MORE THAN ONE ARGUMENT,
     SEPERATED BY COMMAS, SPACES, OR ALTMODE (WHEN USED FOR COMPLETION).
     THE SPECIFICATIONS FOR THE "SOCKETS" COMMANDS CAN BE ANY OF THE
     FOLLOWING (ALL ARE OCTAL NUMBERS):
	SKT		A SINGLE SPECIFIC SOCKET:  S = SKT
	SKT1-SKT2 ANY SOCKET IN RANGE:  SKT1 <= S <= SKT2
	SKT1+INCR ANY SOCKET IN RANGE:  SKT1 <= S <= SKT1+INCR
	<SKT		ANY SOCKET IN RANGE:  S <= SKT
	>SKT		ANY SOCKET IN RANGE:  SKT <= S


 ALTMODE MAY BE USED TO COMPLETE ALL COMMANDS, SPECIFICATIONS,
 SITE NAMES (OR TYPES), STATES, AND USER NAMES.

 A BLANK LINE WILL START THE TYPEOUT.
 IF NO COMMAND IS GIVEN "ALL" IS ASSUMED, EXCEPT THAT ON REPEATING
 AN INITIAL BLANK LINE MEANS "DO WHAT I SPECIFIED LAST TIME".
 RUBOUT ABORTS THE GIVEN LINE.
 ^O (CNTL O) WILL STOP TYPE OUT.
SEMICOLON (;) AT THE START OF ANY COMMAND OR SPECIFICATION LINE MAY BE
USED TO INDICATE A LINE TO BE IGNORED.
/

;SPECIFICATION HELP (GENERAL)
SPHELP:	MOVEI A,HELPSP
	PSOUT
	JRST SP10
HELPSP:	ASCIZ /
 SITES, HOSTS, JOBS, SIZES, STATES, TTYS, USERS,
 SOCKETS, LOCAL.SOCKETS, FOREIGN.SOCKETS, OR NOT/

HELPHO:	ASCIZ /(NAME, TYPE, OR OCT NUM) /
HELPST:	ASCIZ /(NAME) /
HELPUS:	ASCIZ /(NAME) /
HONUM:	ASCIZ /(OCT NUM OR BLANK) /
HDNUM:	ASCIZ /(DEC NUM) /
HGMESS:	ASCIZ /(SITE TYPE) /
HSKTS:	ASCIZ /(OCT NUM, OR RANGE) /


LN$DEL=="U"-100			;CONTROL-U DELETES LINE
CH$DEL==.CHDEL			;RUBOUT DELETES CHAR

	AC0==0
	AC1==1
	AC2==2
	AC3==3
	AC4==4
	AC5==5
	AC6==6
	AC7==7
	AC10==10
	AC11==11
	AC12==12
	AC13==13
	AC14==14
	AC15==15
	AC16==16
	AC17==17
	P==17

	A==1
	B==2
	C==3
	D==4

;PROGRAM TO ACCEPT INPUT STRINGS FROM THE TTY ALLOWING THE USER
;TO DO EDITTING WITH ^A, ^R, RUBOUT AND TO USE ALTMODE
;FOR COMPLETION.
;COMMA, SPACE AND NEWLINE TERMINATE THE STRING

;INEDIT:
;ACCEPTS IN AC1 FLAGS,,PTR
;		FLAGS:
;		  BIT 0 - ON => DON'T ECHO / OFF => USE ECHO DEFAULT
;		  BIT 1 - ON => RAISE LOWER CASE / OFF DON'T
;		  BIT 2 - ON => DON'T RECOG ON EOL/ OFF DO
;               PTR=ADDRESS OF ROUTINE USED FOR COMPLETION
;               IF PTR=0 THEN ALTMODE COMPLETION IS NOT USED AND INPUT
;               OF ALTMODE MERELY RINGS THE TERMINAL BELL.
;           AC2 0/PTR TO "HELP" STRING FOR ALTMODE
;RETURNS +1 IF STRING IS NOT FOUND BY THE SEARCH ROUTINE.
;RETURNS +2 IF STRING INCLUDED RUBOUT
;RETURNS +3 IF STRING IS FOUND BY SEARCH ROUTINE
;           OR IF NO SEARCH ROUTINE IS SPECIFIED

;INSTR:
;SAME AS INEDIT WITH ADDITIONAL PARAMETER
;ACCEPTS IN AC3 ADDITIONAL TERMINATION CHARACTER

;RETURNS WITH AC1 CONTAINING # OF CHARACTERS INPUT FROM TTY
;             AC2 CONTAINING STRING POINTER TO CHARACTER STRING.
;             AC3 CONTAINING TERMINATING CHARACTER
;             AC10 POINTING TO ENTRY FOUND BY SEARCH ROUTINE

;THE ROUTINE PASSED TO INEDIT/INSTR IS ASSUMED TO ACT AS FOR GTSTR

;INEDIT AND INSTR NOW JUST CALL GTSTR.

INSTR:	HRL	AC3,AC3
	CAIA

INEDIT:	SETZ	AC3,
	HRR	AC3,AC1			;AC3_ADDR OF SEARCH ROUTINE
	PUSH	P,AC4
	MOVE	AC4,[BUFSIZ*5-1]	;GET CHAR COUNT.
	MOVEM	AC4,INBCNT		;PUT IN WORD 0 OF BUFFER.
	HRLZI	AC4,INBCNT		;SET GTSTR FLAGS IN AC4
	TRO	AC4,11			;JFN PAIR
	TLNN	AC1,400000		;DEFAULT ECHO
	TRO	AC4,2			;YES.
	TLNE	AC1,200000		;RAISE?
	TRZ	AC4,10			;NO
	TLNN	AC1,100000
	TRO	AC4,4			;RECOG ON EOL
	TRO	AC4,1B30		;USE CHAR COUNT.
	MOVE	AC1,AC4
	MOVE	AC4,AC2			;AC4_PROMPT PTR
	MOVE	AC2,[XWD 100,101]	;AC2_JFN PAIR
	PUSHJ	P,GTSTR
	SOS	-1(P)
	SOS	-1(P)
	MOVE	AC10,AC3		;SET UP ACS FOR RETURN
	HLRZ	AC3,AC1
	HRRZ	AC1,AC1
	MOVE	AC2,[POINT 7,INBUFF]
	AOS	-1(P)
	AOS	-1(P)
	POP	P,AC4
	POPJ	P,

LIT


BUFSIZ==^D20

INBCNT:	BLOCK 1
INBUFF: BLOCK BUFSIZ

;PROGRAM TO ACCEPT INPUT STRINGS AND DO RECOGNITION
;WILL DO EDITTING WITH ^A, ^R, RUBOUT AND TO USE ALTMODE
;FOR COMPLETION.
;COMMA, SPACE AND NEWLINE TERMINATE THE STRING

;ACCEPTS IN AC1 PTR,,FLAGS:
;		PTR - TO BUFFER TO STORE STRING COLLELCTED
;               FLAGS:
;                BIT 35 ON => AC2 - JFN PAIR / OFF => AC2 - STR PTR
;                BIT 34 ON => ECHO / OFF => DON'T ECHO
;		 BIT 33 ON => RECOG ON EOL / OFF => EXACT MATCH ON EOL
;		 BIT 32 ON => NO RAISE / OFF => RAISE
;		 BIT 31 ON => DON'T IGNORE LEADING SPACES /OFF => DO
;		 BIT 30 ON => USE CHAR COUNT IN WORD 0 OF BUFFER.
;				START STRING IN WORD 1.
;		 BIT 29 ON => LONG CALL AC5 IS PTR TO PARAM BLOCK
;		 BIT 28 (RETURN PARAMETER IN LONG CALL ON =>
;				SWITCH FROM STR PTR TO JFNS
;			PARAM BLOCK:
;			0:  FLAGS (1 IS OR'D INTO AND IT IS OR'D WITH 1)
;			1:  IN,,OUT JFNS (377777,,377777 FOR NONE)
;			2:  EXHAUSTED AC2 STR PTR RET'D HERE IF SWITCH
;			3:  STRING PTR FOR ^R - STRING IS OUTPUT
;				AS PREFIX
;           AC2 (STRING PTR)/(INJFN,,OUTJFN) AS SPEC'D BY BIT 35 OF AC1
;           AC3 SPECIAL TERM CHAR,,ADDRESS OF SEARCH ROUTINE
;           AC4 PTR TO PROMPT STRING
;	    AC5 PTR TO PARAM BLOCK IF BIT 29 OF 1 ON
;RETURNS +1 IF STRING IS NOT FOUND BY THE SEARCH ROUTINE.
;RETURNS +2 IF STRING INCLUDED RUBOUT
;RETURNS +3 IF STRING IS FOUND BY SEARCH ROUTINE
;           OR IF NO SEARCH ROUTINE IS SPECIFIED

;RETURNS WITH AC1 CONTAINING TERM CHAR,,# OF CHARACTERS IN STRING
;             AC2 CONTAINING UPDATED STRING POINTER (IF APPROPRIATE)
;             AC3 POINTING TO ENTRY FOUND BY SEARCH ROUTINE /
;                 STRING PTR TO STRING READ IF SEARCH ROUTINE UNSPEC


;THE ROUTINE PASSED TO GTSTR IS ASSUMED TO:
;ACCEPT IN AC1 PTR TO STRING TO BE VERIFIED
;          AC2 (0/-1),, CHARACTER COUNT
;               -1 => TRY EXACT MATCH, 0 => TRY TO RECOGNIZE
;	   AC3 TERMINATING CHAR TYPED
;RETURN + 1 IF COMPLETE FAILURE
;       + 2 IF AMBIGUOUS
;       + 3 IF UNIQUE WITH AC1 POINTING TO "REST" OF STRING
;                          AC2 POINTING TO ENTRY FOUND

ECH==2		;ECHO FLAG
REC==4		;EOL RECOG FFLAG
RAZ==10		;RAISE FLAG
IGSP==20	;IGNORE SPACES FLAG
LONG==100	;LONG CALL
STJF==200	;SWITCH FROM STR PTR TO JFNS OCCURRED

SVAC5==-11


DEFINE	READCH
<	MOVE	AC1,AC10
	BIN
	JUMPGE	AC6,.+5		;STRING IO?
	JUMPN	AC2,.+3		;YES, NULL CH?
	PUSHJ	P,IOSWCH	;YES, TRY TO SWITCH TO JFNS
	CAIA
	MOVE	AC10,AC1	;SAVE STR PTR
>

;ROUTINE TO ACCOMPLISH IO SWITCH

IOSWCH:	TRNN	AC14,LONG		;LONG CALL?
	POPJ	P,			;NO, DO NOTHING.
	MOVE	AC2,SVAC5-1(P)		;2=PTR TO PARAM BLOCK
	MOVEM	AC10,2(AC2)		;SAVE EXHAUSTED PTR
	MOVE	AC2,1(AC2)		;2=IN,,OUT JFNS
	CAMN	AC2,[XWD 377777,377777]	;NULL?
	JRST [	SETZ AC2,		;YES, RETURN NULL CH
		POPJ P, ]
	HLRZ	AC1,AC2			;1=IN JFN
	MOVEI	AC10,(AC1)		;AND 10
	MOVEI	AC11,(AC2)		;11=OUTJFN
	SETZ	AC6,			;INDICATE JFNS
	TRO	AC14,ECH+STJF		;INDICATE IO SWITCH AND ECHOS ON
	MOVE	AC2,SVAC5-1(P)
	MOVEM	AC14,0(2)		;SAVE FLAGS
	PUSH	P,AC3
	HRRZ	AC1,AC11		;NOW SET MODES FOR JFNS
	RFCOC
	MOVEM	AC2,TTYCOC
	MOVEM	AC3,TTYCOC+1
	TLZ	AC2,(3B3+3B13+3B15)	;IGNORE ^A,^F
	TLO	AC2,(2B15)		;SEND CODE FOR BELL
	TLZ	AC3,(3B1+3B9)		;IGNORE ^R, ^V
	TRZ	AC3,3B19		;IGNORE ALTNODE
	SFCOC				;ON OUTPUT TO JFN
	HRRZ	AC1,AC10
	RFMOD
	MOVEM	AC2,TTYMDS
	TRO	AC2,770000		;WAKEUP ON EVERYTHING
	PUSHJ	P,ISALNM		;UNLESS TERM CHAR NOT ALPAHNUM.
	 TRZ	AC2,10000
	SFMOD
	POP	P,AC3
	MOVEI	AC1,(AC10)
	BIN				;READ THE CH
	POPJ	P,			;AND RETURN

GTSTR:	PUSH	P,AC0			;SAVE USER'S ACS
	HRLI	AC0,AC1
	HRRI	AC0,1(P)
	ADDI	P,16
	BLT	AC0,0(P)

	SETZ	AC11,
	HRRZ	AC14,AC1		;AC14_FLAGS
	TRNN	AC14,LONG		;LONG CALL?
	JRST	.+4
	IOR	AC14,(AC5)		;OR IN FLAGS IN PARM BLOCK
	MOVEM	AC14,(AC5)		;AND VICE VERSA.
	HRRZ	AC11,1(AC5)		;AC11=OUT JFN
	HRRZ	AC5,AC3			;AC5=PTR TO SEARCH ROUTINE/0
	HLRZ	AC7,AC3			;AC7=SPECIAL TERM CH
	MOVS	AC13,AC1		;SET UP PTR TO BUFFER
	HRLI	AC13,440700
	HRLOI	AC15,377777		;USE MAX CHAR COUNT,
	TRNN	AC1,1B30		;UNLESS ONE IS GIVEN?
	 JRST	.+3			;NO.
	MOVE	AC15,0(AC13)		;YES. USE IT.
	AOJ	AC13,			;START STRING IN WORD 1.
	MOVEM	AC13,STRBPT		;SAVE PTR TO USER'S BUFFER
	TRNE	AC1,1			;BIT 35 ON?
	JRST	GTSTR1			;YES
	MOVE	AC10,AC2		;NO
	HLRZ	AC2,AC2
	CAIN	AC2,-1
	HRLI	AC10,440700
	SETO	AC6,			;AC6 < 0 => STRING PTR IN AC2
	JRST	GTSTR2
GTSTR1:	HLRZ	AC10,AC2		;AC10=INJFN
	HRRZ	AC11,AC2		;AC11=OUTJFN
	SETZ	AC6,			;AC6 = 0 => ECHO AND JFNS IN AC2
	TRNE	AC1,2			;BIT 34 ON?
	JUMPN	AC11,.+3		;YES.  DON'T JUMP IF NO OUT JFN
	AOJ	AC6,			;AC6 > 0 => DON'T ECHO AND JFNS
	JUMPE	AC11,GTST1A		;JUMP IF NO OUT JFN.
	HRRZ	AC1,AC11
	RFCOC
	MOVEM	AC2,TTYCOC
	MOVEM	AC3,TTYCOC+1
	TLZ	AC2,(3B3+3B13+3B15)	;IGNORE ^A,^F
	TLO	AC2,(2B15)		;SEND CODE FOR BELL
	TLZ	AC3,(3B1+3B9)		;IGNORE ^R, ^V
	TRZ	AC3,3B19		;IGNORE ALTNODE
	SFCOC				;ON OUTPUT TO JFN
GTST1A:	HRRZ	AC1,AC10
	RFMOD
	MOVEM	AC2,TTYMDS
	TRNN	AC14,ECH
	TRZ	AC2,6000		;FORCE ECHO IF REQUESTED
	TRO	AC2,170000		;WAKEUP ON EVERYTHING
	PUSHJ	P,ISALNM		;UNLESS TERM CHAR NOT ALPAHNUM.
	 TRZ	AC2,10000
	SFMOD
GTSTR2:	MOVE	AC12,AC4

GTSTST:	SETZ	AC3,			;AC3 HOLDS CHAR COUNT
	TRNE	AC14,IGSP		;IGNORE SPACES
	JRST	GTSTS4			;NO

GTSTS1:	READCH				;IGNORE LEADING SPACES IN INPUT
	CAIN	AC2," "
	JRST	GTSTS1
	CAIE	AC2,33
	JRST	GTSTS5
	JUMPE	AC12,GTSTS2		;ALT MODE BUT NO PROMPT
	TRNN	AC14,LONG
	JUMPN	AC6,.+4
	MOVE	AC1,AC11
	MOVE	AC2,AC12
	SOUT
	SETZ	AC12,
	JRST	GTSTS1

GTSTS2:	HRRZI	AC2,7
	TRNN	AC14,LONG
	JUMPN	AC6,GTSTS1
	HRRZ	AC1,AC11
	BOUT
	JRST	GTSTS1

GTSTS5:	MOVE	AC4,STRBPT		;AC4=PTR TO CHAR BUFF
	JRST	GTSTLP+2

GTSTS4:	MOVE	AC4,STRBPT

GTSTLP:	READCH
	JUMPE	AC2,DONL		;END OF ASCIZ STRING
	CAIN	AC2,LN$DEL			;RUBOUT
	JRST	DORUB
	CAIN	AC2,22			;CONTROL R - RETYPE
	JRST	DOCNTR
	CAIN	AC2,CH$DEL			;CONTROL A - DELETE CHAR
	JRST	DOCNTA
	CAIN	AC2,.CHLFD			;NEWLINE - ENDS STRIN
	JRST	DONL
	CAIN	AC2,15			;CARRIARE RETURN -MUST BE
	JRST	DOCR			;FOLLOWED BY LINE FEED = NEWLINE
	CAIN	AC2," "			;SPACE - TERMINATES STRING
	JRST	DOSP
	CAIN	AC2,33			;ALTMODE - USED WITH SEARCH
	JRST	DOALT			;ROUTINE FOR STRING COMPLETION
	CAIN	AC2,6			;CONTROL F - USED AS ALTMODE
	JRST	DOCNTF
	CAIN	AC2,","			;COMMA - ENDS STRING
	JRST	DOCOMA
	CAIN	AC2,26			;CONTROL V - ESCAPE IN NEXT CHAR
	JRST	DOCNTV
	CAMN	AC2,AC7			;USER SPECIFIED TERMINATOR
	JRST	DOUTRM

DOCH:	MOVE	AC10,AC1
	TRNN	AC14,RAZ
	PUSHJ	P,RAISE
DOCH1:	IDPB	AC2,AC4
	AOJ	AC3,
	CAMLE	AC3,AC15		;IS BUFFER FULL?
	 JRST	RET1			;YES.
	JRST	GTSTLP

DORUB:	MOVE	AC7,AC2
	TRNN	AC14,LONG
	JUMPN	AC6,RET2
	HRRZ	AC1,AC11
	HRROI	AC2,[ASCIZ /XXX/]
	SETZ	AC3,
	SOUT
	JRST	RET2

DOCNTR:	TRNN	AC14,LONG
	JUMPN	AC6,GTSTLP
	MOVE	AC13,AC4
	SETZ	AC2,
	IDPB	AC2,AC13		;MAKE STRING ASCIZ FOR ECHO
	HRRZ	AC1,AC11
	HRRZI	AC2,.CHLFD
	BOUT
	TRNN	AC14,LONG		;LONG CALL
	JRST	.+8			;NO
	MOVE	AC2,SVAC5(P)
	SKIPN	AC2,3(AC2)		;^R PREFIX SPEC'D
	JRST	.+5			;NO
	PUSH	P,AC3			;YES, OUTPUT IT
	SETZ	AC3,
	SOUT
	POP	P,AC3
	JUMPE	AC3,RNGBEL
	MOVE	AC2,STRBPT
	MOVE	AC12,AC3
	SETZ	AC3,
	SOUT
	MOVE	AC3,AC12
	JRST	GTSTLP

DOCNTA:	JUMPL	AC6,DOCH
	HRRZ	AC1,AC11
	JUMPE	AC3,RNGBEL
	HRRZI	AC2,"\"
	SKIPE	AC11			;SKIP IF NO OUT JFN.
	BOUT
	LDB	AC2,AC4
	TRNN	AC14,LONG
	SKIPN	AC6
	BOUT
	SETZ	AC1,
	DPB	AC1,AC4
	MOVE	AC4,STRBPT
	SOJE	AC3,GTSTLP
	MOVE	AC1,AC3
	IBP	AC4
	SOJG	AC1,.-1
	JRST	GTSTLP

DOCNTV:	IDPB	AC2,AC4
	AOJ	AC3,
	CAMLE	AC3,AC15
	 JRST	RET1
	READCH
	JRST	DOCH1

DOALT:	PUSH	P,AC2			;REMEMBER ALT
DOALT2:	JUMPE	AC5,[ POP P,
		      JRST RNGBEL ]
	MOVE	AC13,AC4
	SETZ	AC2,
	IDPB	AC2,AC13		;MAKE ASCIZ STRING FOR SEARCH
	MOVE	AC1,STRBPT
	MOVE	AC2,AC3
	PUSH	P,AC3
	MOVE	AC3,-1(P)		;GET THE ALT.
	PUSHJ	P,@AC5
	JRST	[ POP P,AC3
		  POP P,AC7
		  JRST RET1 ]

	JRST	[ POP P,AC3
		  POP P,
		  JRST RNGBEL ]
	POP	P,AC3
	MOVE	AC12,AC1
	MOVEM	AC2,ENTPTR
	JUMPE	AC3,.+5
	LDB	AC2,AC1
	JUMPE	AC2,DOALT1
	ILDB	AC2,AC1
	JUMPE	AC2,DOALT1
	JUMPG	AC6,DOALT0
	TRNN	AC14,LONG
	JUMPN	AC6,.+3
	HRRZ	AC1,AC11
	CAIA
	MOVE	AC1,AC10
	MOVE	AC2,AC12
	PUSH	P,AC3
	SETZ	AC3,
	SOUT
	POP	P,AC3
	JUMPE	AC6,DOALT0
	MOVE	AC10,AC1
DOALT0:	ILDB	AC2,AC12
	JUMPE	AC2,DOALT1
	IDPB	AC2,AC4
	AOJ	AC3,
	JRST	.-4
DOALT1:	JUMPE	AC7,DOALT4		;IF SPECIAL TERM CH ECHO IT
	TRNE	AC14,LONG
	JRST	.+3
	JUMPG	AC6,DOALT4
	JUMPN	AC6,.+3
	HRRZ	AC1,AC11
	CAIA
	MOVE	AC1,AC10
	MOVE	AC2,AC7			;ECHO SPECIAL TERM CHAR.
	BOUT
	JUMPE	AC6,DOALT4
	 MOVE	AC10,AC1
DOALT4:	POP	P,AC7			;AC7 = ALT OR ^F
	MOVE	AC2,ENTPTR
	JRST	RET3

DONL:	MOVE	AC7,AC2
	JUMPE	AC5,RET3
	MOVE	AC13,AC4
	SETZ	AC2,
	IDPB	AC2,AC13		;MAKE STRING ASCIZ
	MOVE	AC1,STRBPT
	SETZ	AC2,
	TRNN	AC14,REC
	SETO	AC2,			;TRY FOR EXACT MATCH
	HRR	AC2,AC3
	PUSH	P,AC3
	MOVE	AC3,AC7			;GET TERM CHAR.
	PUSHJ	P,@AC5
	JFCL
	JRST	[ POP P,AC3
		  JRST RET1 ]
	POP	P,AC3
	MOVEM	AC2,ENTPTR
	JRST	RET3

DOSP=DONL

DOCR:	READCH
	CAIE	AC2,12			;LINE FEED
	JRST	.+4
	HRRZI	AC7,.CHLFD
	JUMPE	AC5,DOCR1
	JRST	DONL
	JUMPL	AC6,RET1
	JUMPE	AC11,RET1
	HRRZ	AC1,AC11
	BOUT
	JRST	RET1
DOCR1:	JUMPL	AC6,.+4
	JUMPE	AC11,.+3
	HRRZ	AC1,AC11
	BOUT
	HRRZI	AC2,.CHLFD
	JRST	RET3

DOCNTF:	PUSH	P,AC2			;REMEMBER ^F
	JRST	DOALT2			;AND HANDLE LIKE ALT

DOCOMA=DONL

DOUTRM=DONL

RNGBEL:	TRNN	AC14,LONG
JUMPN	AC6,GTSTLP
	MOVE	AC1,AC11
	HRRZI	AC2,7
	BOUT
	JRST	GTSTLP

RET3:	SETZ	AC2,
	IDPB	AC2,AC4			;MAKE COLLECTED STRING ASCIZ
	AOS	-17(P)
RET2:	AOS	-17(P)
RET1:	JUMPGE	AC6,.+3
	MOVE	AC2,AC10
	JRST	RET11
	MOVE	AC1,AC10
	MOVE	AC2,TTYMDS
	SFMOD
	JUMPE	AC11,.+7
	PUSH	P,AC3
	MOVE	AC1,AC11		;RESTORE COC
	MOVE	AC2,TTYCOC
	MOVE	AC3,TTYCOC+1
	SFCOC
	POP	P,AC3
	TRNE	AC14,STJF		;CHANGED IO?
	JRST [	MOVE AC5,SVAC5(P)	;YES, MUST RESTORE STR PTR
		MOVE AC2,2(AC5)
		JRST RET11 ]
	HRL	AC2,AC10
	HRR	AC2,AC11
RET11:	HRR	AC1,AC3
	HRL	AC1,AC7
	JUMPN	AC5,.+3
	MOVE	AC3,STRBPT
	CAIA
	MOVE	AC3,ENTPTR
	HRLI	AC0,-12(P)		;RESTORE STACK
	HRRI	AC0,4
	BLT	AC0,AC16
	SUBI	P,16
	POP	P,AC0
	POPJ	P,

STRBPT:	BLOCK	1
TTYMDS:	BLOCK	1
TTYCOC:	BLOCK	2
ENTPTR:	BLOCK	1

ISALNM:	CAIGE	AC7,"0"			;ROUTINE TO SKIP IF CAHR IN AC7
	POPJ	P,			;IS ALPHANUMERIC
	CAIG	AC7,"9"
	JRST	ISANSK
	CAIGE	AC7,"A"
	POPJ	P,
	CAIG	AC7,"Z"
	JRST	ISANSK
	CAIGE	AC7,"a"
	POPJ	P,
	CAIG	AC7,"z"
ISANSK:	AOS	0(P)
	POPJ	P,


RAISE:	CAIL	AC2,"a"			;RAISE LOWER TO UPPER
	CAILE	AC2,"z"
	POPJ	P,
	SUBI	AC2,40
	POPJ	P,

;PROGRAM TO BE USED AS VERIFICATION ROUTINE WITH INEDIT.
;ACCEPTS IN:	AC1 POINTER TO INPUT STRING
;		AC2 NEGATIVE CHAR COUNT FOR INPUT STRING
;		AC3 POINTER TO COMPARISON LIST
;		AC4 NEGATIVE COUNT OF STRINGS IN COMP LIST
;
;RETURNS:	+1 NO MATCH
;		+2 AMBIGUOUS
;		+3 UNIQUE WITH: AC10 POINTER TO MATCH
;				AC11 POINTER TO "REST" OF MATCH
;
; NOTE:	IT IS AMBIGUOUS TO HAVE A STRING IN THE COMPARISON LIST
;	WHICH IS THE SAME AS THE START OF SOME OTHER STRING
;	IN THE LIST.
; E.G.  HAVING BOTH "GOOD" AND "GOODY" IS AMBIGUOUS.
;

CSVER:	MOVEM	AC1,INPNT#	;SAVE INPUT POINTER
	MOVEM	AC2,INCNTS#	;SAVE INPUT COUNT
	MOVEM	AC2,INCNT#	;SET WORKING INPUT COUNT
	SETZ	AC10,		;ZERO MATCH POINTER
	MOVEM	AC3,CMPPNT#	;SAVE COMP POINTER
	MOVEM	AC4,CMPCNT#	;SET UP COMP COUNTER
;INITIALIZATION DONE
;START COMPARISON
CSV1:	ILDB	AC4,AC3		;GET COMP CHAR
	JUMPE	AC4,CSV2	;IF NULL, GO ON TO NEXT STRING.
	ILDB	AC2,AC1	;NO. GET INPUT CHAR
	CAME	AC2,AC4		;ARE THEY THE SAME?
	JRST	CSV3		;NO.  ON TO THE NEXT.
	AOSGE	INCNT		;INCREMENTINPUT COUNT.
	JRST	CSV1		;MORE TO WORD. CONTINUE COMP
	JUMPN	AC10,CSVAMB	;A MATCH. CHECK IF WE HAVE ANOTHER.
	MOVE	AC10,CMPPNT	;NO.  SAVE POINTER TO MATCH.
	MOVE	AC11,AC3	;SAVE POINTER TO REST.
CSV3:	ILDB	AC4,AC3		;LOOP UNTIL WE HIT A NULL
	JUMPN	AC4,.-1		;BEFORE GOING ON.
	JRST	CSV2		;ON WE GO.

;GET NEXT COMP WORD AND RESTART
;IF COMPARISON LIST IS FINISHED THEN EXIT.
CSV2:	AOSL	CMPCNT		;INCR COMP COUNT
	JRST	CSV4		;DONE. GO EXIT.
	ANDCM	AC3,[77B5]	;CLEAR P TO MAKE POINTER POINT
				;TO FIRST CHAR OF NEXT WORD
	MOVEM	AC3,CMPPNT	;SAVE IT.
	MOVE	AC1,INPNT	;RESET INPUT POINTER BACK
	MOVE	AC2,INCNTS	;AND
	MOVEM	AC2,INCNT	;RESET INPUT COUNTER.
	JRST	CSV1		;GO LOOK AT NEXT COMP STRING.
;
;CHECK FOR UNIQUE OR NO MATCH AND RETURN
CSV4:	JUMPE	AC10,CSVNOM	;CHECK FOR A MATCH POINTER.
;
CSVUNQ:	AOS	(P)		;UNIQUE MATCH
CSVAMB:	AOS	(P)		;AMBIGUOUS
CSVNOM:	POPJ	P,		;NO MATCH.  RETURN.
;
	END <3,,ENTVEC>
