;Merge CMU and BBN code
;<MONITOR.CMU>TCPTCP.MAC.3, 14-Aug-85 05:42:33, Edit by VAF
;CS147 Put counter of bad checksums under MNTM5.
;<MONITOR.CMU>TCPTCP.MAC.2, 13-May-85 14:26:21, Edit by VAF
;CS147 Search PROLGX
;Fix empty send buffer bug recently introduced, more work on retransmissions
; UPD ID= 3928, SNARK:<6.MONITOR>TCPTCP.MAC.7,  14-Mar-84 14:54:44 by PAETZOLD
;More TCO 6.1733 - Make initial buffer size selection more reasonable.
; UPD ID= 3891, SNARK:<6.MONITOR>TCPTCP.MAC.6,  11-Mar-84 10:35:31 by PAETZOLD
;More TCO 6.1733 - Fix  for exceeding the  send window. Fix for runaway
;ACK bug. Fix TCB's hung in NOT.FIN.  Fix  for  zero  window  bug.  fix
;packetizer  to  see  if transfer count fills window. fix packetizer to
;make sure FIN sent after deferred data transmitted.
; UPD ID= 3820, SNARK:<6.MONITOR>TCPTCP.MAC.5,  29-Feb-84 18:09:34 by PAETZOLD
;More TCO 6.1733 - ANBSEC and MNTSEC removal.  Bug Fixes.  Cleanup.
;[BBNF]<TAPPAN.MERGE>TCPTCP.MAC.20, 26-Jan-84 12:15:31, Edit by: TAPPAN
; Merge in stanford changes
; UPD ID= 3171, SNARK:<6.MONITOR>TCPTCP.MAC.4,  16-Nov-83 18:22:35 by PAETZOLD
;TCO 6.1867 - Use SAVEAC and not SAVP1
; UPD ID= 2998, SNARK:<6.MONITOR>TCPTCP.MAC.3,   5-Oct-83 14:51:26 by PAETZOLD
;More TCO 6.1733 - bug fixes to packetizer.
; UPD ID= 2715, SNARK:<6.MONITOR>TCPTCP.MAC.2,  22-Jul-83 14:52:29 by PAETZOLD
;TCO 6.1733 - Merge TCP/IP changes in release 6 again
; TTTVDV/OPSCAN needs to check for zero windows before setting TSEP/TSFP
; Interaction of TELNET negotiation timeout with zero windows
;<TCPIP.5.1.MONITOR>TCPTCP.MAC.19,  5-Jul-83 22:30:44, Edit by PAETZOLD
;JFN Interface

;TCP Changes for 5.1



;THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY ONLY BE USED
;  OR COPIED IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.

;COPYRIGHT (C) 1982,1983,1984,
;BY DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.

IFDEF  CMU,<	SEARCH	ANAUNV,PROLGX	;CS147 >
IFNDEF CMU,<	SEARCH	ANAUNV,PROLOG >

IFNDEF PART,<PART==1>	; 1- one module, 2,0 two pieces
IFL PART-2,<
	TTITLE	(TCPTCP,TCPTCP,< - ARPANET Transmission Control Protocol>) >
IFE PART-0,<
	EXTERNAL $TCPT2P >
IFE PART-2,<
	TTITLE	(TCPT2P,TCPT2P,< - ARPANET Transmission Control Protocol>) >

	SWAPCD

Comment \

This  module  implements  most  of  the  Department  of Defense (DOD)
Standard  Tranmission  Control  Protocol  (TCP)  for  the   TOPS-20AN
Operating  system. This code was originally developed at Bolt Beranek
and Newman (BBN) under contract  to  the  Defense  Advanced  Research
Projects Agency (DARPA).

\

IFL PART-2,<
	SUBTTL	TCP Process

COMMENT	!

This is the top level of the TCP protocol module.  Herein are the
TCP initialization, "interprocess communication" between parts of
the TCP, etc.

!

;TCPINI	TCP once-only initialization, and subroutines.

;	CALL TCPINI		(From INTINI)
;Ret+1:	Always.  TCP initialized.

TCPINI::
	SAVEAC <Q1>
	MOVEI T1,OHUSE		; Overhead time accumulator
	MOVEM T1,TIMPTR		; Select that as the timer
	NOSKED
	MOVEI T1,CELL(TCPIQ,0,,TCP)  ; Address of TCP Input Queue
	MOVEM T1,TCPIPQ		; That is the TCP input queue
	CALL INITQ		; Initialize it

	CALL TBFINI		; Initialize Buffer Windows
	JUMPE T1,R		; Lose
	CALL PZINI		; Initialize Packetizer
	JUMPE T1,R		; Lose
	CALL IPINI		; Initialize Input Processor
	JUMPE T1,R		; Lose
	CALL RAINI		; Initialize Reassembler
	JUMPE T1,R		; Lose
	CALL RXINI		; Initialize Retransmitter
	JUMPE T1,R		; Lose
	CALL DYINI		; Initialize Delayed Action Generator
	JUMPE T1,R		; Lose
	CALL BGINI		; Initialize Background Routine
	JUMPE T1,R		; Lose
	CALL USRINI		; Initialize User Interface
	JUMPE T1,R		; Lose
	CALL TCBINI		; Initialize TCB Hash table
	JUMPE T1,R		; Lose
	SETZM TCPSID		; Clear TCP segment idents.
				; All ok
	HRRE T1,TCPON		; Want TCP ON (1B18)?
	TRZ T1,-1		; It is initialized
	MOVEM T1,TCPON		; Set the flag
	OKSKED
	RET

PRC==Q1				; Used in initialization routines

;IPINI	Initialize IP process block.

;	CALL IPINI
;Ret+1:	ALways. T1 zero if error.

IPINI:	XMOVEI PRC,IP		; Pointer to process block

;Following are guards against really bad things

	SETZM PRCQ(PRC)		; Be sure queue is empty.
	SETZM PRCLCK(PRC)	; Should never try to lock IP lock!
	SETZM PRCWAK(PRC)	; Be sure to run it promptly!
	SETZM PRCQOF(PRC)	; Clear unused cells
	SETZM PRCWOF(PRC)
	XMOVEI T1,INPROC	; Routine address
	MOVEM T1,PRCROU(PRC)	; Set into the control block
	MOVEI T1,TCPIDQ+1	; Address of Queue Header
	MOVEM T1,TCPIDQ		; Save pointer to it
	CALL INITQ		; Initialize it
	SETO T1,
	RET


;USRINI
;Initialize the user interface.

USRINI:	MOVEI T1,TCPBDQ+1
	MOVEM T1,TCPBDQ		; Save for all to find
	CALL INITQ		; Initialize it
	SETO T1,		; All ok
	RET


;TBFINI	Buffer initialization code. Called only at startup.

;	CALL TBFINI
;Ret+1:	ALways. T1 zero if error.

TBFINI:	SETO T1,		; No error
	RET			; Nothing to do in this version


;PZINI
;Initialize PZ process block.

;	CALL PZINI
;Ret+1:	ALways. T1 zero if error.

PZINI:	MOVEI PRC,PZ		; Pointer to the Process block for PZ
	XMOVEI T2,PKTIZE	; Packetizer function
	CALL PRCINI		; Setup process block
	  GFIWM 0,TCQPZ(TCB)	; Offset of PZ queue in TCB
	  GFIWM 0,TCTPZ(TCB)	; Offset of PZ run time in TCB
	RET

;RAINI
;Initialize RA process block.

;	CALL RAINI
;Ret+1:	ALways. T1 zero if error.

RAINI:	XMOVEI PRC,RA		; Pointer to the Process block for RA
	XMOVEI T2,REASEM	; The Reassembler function
	CALL PRCINI		; Setup process block
	  GFIWM 0,TCQRA(TCB)	; Offset of RA queue in TCB
	  GFIWM 0,TCTRA(TCB)	; Offset of RA run time in TCB
	RET

;RXINI
;Initialize RX process block.

;	CALL RXINI
;Ret+1:	ALways. T1 zero if error.

RXINI:	XMOVEI PRC,RX		; Pointer to the Process block for RX
	XMOVEI T2,REXMIT	; Retransmitter function
	CALL PRCINI		; Setup process block
	  GFIWM 0,TCQRX(TCB)	; Offset of RX queue in TCB
	  GFIWM 0,TCTRX(TCB)	; Offset of RX run time in TCB
	RET

;DYINI	Initialize DY process block.

;	CALL DYINI
;Ret+1:	ALways. T1 zero if error.

DYINI:	XMOVEI PRC,DY		; Pointer to the Process block for DY
	XMOVEI T2,EXITMW	; The only DY function!
	CALL PRCINI		; Setup process block
	  GFIWM 0,TCQDY(TCB)	; Offset of DY queue in TCB
	  GFIWM 0,TCTDY(TCB)	; Offset of DY run time in TCB
	RET

;BGINI
;Initialize BG process block

;	CALL BGINI
;Ret+1:	ALways

BGINI:	XMOVEI PRC,BG		; Pointer to the Process block for BG
	SETZM PRCQ(PRC)		; Input queue
	XMOVEI T1,PRCLCK(PRC)	; Lock
	CALL CLRLCK		; Initilize it
	XMOVEI T1,BACKG		; Background function
	MOVEM T1,PRCROU(PRC)	; Routine address
	MOVE T1,TODCLK		; Now
	ADD T1,TCPBGT		; Plus a few seconds
	MOVEM T1,PRCWAK(PRC)	; Start BG for the first time
	SETZM PRCWOF(PRC)	; Store in process block

	MOVEI T1,TCBDH		; Address of Queue Header
	MOVEM T1,TCBDQ		; Queue head for SCAN
	CALL INITQ		; Initialize it

	MOVEI T1,TCBDHK		; Address of Queue Header for debug
	MOVEM T1,TCBDQK		; Used at cleanup (don't want to fail then)
	CALL INITQ		; Initialize it

	SETO T1,		; All ok
	RET


;TCBINI	Initialize the TCB Hash Table.

;	CALL TCBINI
;Ret+1:	Always

TCBINI:	ACVAR <TCBX>
	MOVEI T1,TCBHSZ*QSZ	; Size of the TCB Hash table
	CALL GETBLK
	JUMPE T1,R		; No space

	MOVEM T1,TCBH		; Extended Loc of hash table.

	MOVSI TCBX,-TCBHSZ	; Set to scan TCBH
	DO.
	  HRRZ T1,TCBX		; Offset within TCBH table
	  ADD T1,TCBH		; Pointer to table base
	  CALL INITQ		; Initialize as a queue
IFN <QSZ-1>,<ADDI TCBX,QSZ-1>	; Move to next queue
	  AOBJN TCBX,TOP.	; Loop over all slots
	ENDDO.
	SETZM TCBHUC		; Clear the use count
	XMOVEI T1,TCBHLK	; Pointer to the lock on TCBH
	CALLRET CLRLCK		; Initialize it

	ENDAV.

;PRCINI	Common initialization of TCP process block.

;T2/	Address of processing routine
;PRC/	Extended pointer to process block for this process
;	CALL PRCINI
;	  Global indirect pointer to this process's queue entry in TCB
;	  Global indirect pointer to this process's scheduled time entry in TCB
;Ret+1:	Always.

PRCINI:	MOVEM T2,PRCROU(PRC)	; Set routine address
	MOVX T1,.INFIN		; Plus infinity
	MOVEM T1,PRCWAK(PRC)	; Not yet time to run
	MOVEM T1,PRCSGT(PRC)	; Set time of most recent signal
	MOVE T3,(P)		; Pointer to args
	MOVE T4,(T3)
	MOVEM T4,PRCQOF(PRC)	; Store pointer to queue entry
	MOVE T4,1(T3)
	MOVEM T4,PRCWOF(PRC)	; Store pointer to scheduled time

	MOVEI T1,PRCQH(PRC)	; Get address of Queue Head
	MOVEM T1,PRCQ(PRC)	; Input queue
	CALL INITQ		; Initialize it
	XMOVEI T1,PRCLCK(PRC)	; Lock
	CALL CLRLCK		; Initilize it

	SETO T1,		; All ok
	AOS (P)			; Skip over arguments
	AOS (P)
	RET

	PURGE PRC

	SUBTTL	TCPICM -- ICMP Message Processor for TCP

;TCPICM	An ICMP error message has been received which contains an imbedded
;TCP packet.

;Destination unreachable
;Time exceeded
;Parameter problem
;Source quench
;Redirect

;PKT/	Pointer to packet containing ICMP/TCP packets
;CPKT/	Pointer to ICMP header
;	CALL TCPICM
;Ret+1:	Always (caller disposes of the packet).

CPKT==TPKT

TCPICM::
	LOAD T1,CMTYP,(CPKT)	
	  SETZ T2,		; Assume no additional information
	  XMOVEI T3,TCPICU	; Destination unreachable processor
	  CAIN T1,ICM%DU
	IFSKP.			; Not destination unreachable

	  XMOVEI T3,TCPICQ	; Source quench processor
	  CAIN T1,ICM%SQ
	ANSKP.			; Not Source quench

	  XMOVEI T3,TCPICT	; Time exceeded processor
	  CAIN T1,ICM%TE
	ANSKP.			; Not time exceeded

	  LOAD T2,CMGWA,(CPKT)	; First-hop destination if redirect
	  XMOVEI T3,TCPICR	; Redirect processor
	  CAIN T1,ICM%RD
	ANSKP.			; Not redirect

	  LOAD T2,CMPTR,(CPKT)	; Pointer if parameter problem
	  XMOVEI T3,TCPICP	; Parameter problem processor
	  CAIN T1,ICM%PP
	ANSKP.			; Not parameter problem
				; None of the above
	  MOVX T1,PT%TKI	; Received ICMP packet, unknown type
	  TDNE T1,MNTRAC	; Want trace?
	    CALL PRNPKT		; Yes
	ELSE.			; Something recognizable
	  SAVEAC <FR,BFR,TPKT,PKT,TCB> ; TCP registers
	  TRVAR <<ARGBLK,CHKADW>,NPKTS,<TICMPA,2>,TICMPP,TICMPR>
				; Setup argument block for CHKADD
	  CHKADL		; Local PARAMS also defined
	  XMOVEI PARAMS,ARGBLK	; Local PARAMS points to ARGBLK
	  MOVE BFR,P6		; Frame pointer (moved by TICMPS)

;Now setup for a call to CHKADD which matches the packet to a TCB.  If a
;TCB is found, CHKADD calls appropriate routine with the TCB locked.

	  MOVEM PKT,TICMPP	; Pointer to ICMP packet for TCPICR & trace
	  LOAD T4,CMCOD,(CPKT)	; Get code
	  HRL T1,T4		; Pack code,,type
	  DMOVEM T1,TICMPA	; Save code,,type and info
	  MOVEM T3,TICMPR	; Save tail routine
	  XMOVEI T3,TICMPS	; Common header routine
	  TXO T3,<044B8>	; TCPICM/ TCB
	  MOVEM T3,FN		; Function

	  XMOVEI PKT,.CMINH-PKTELI(CPKT) ; Set PKT for imbedded IP packet
	  LOAD TPKT,PIDO,(PKT)	; Get IP header length
	  ADD TPKT,PKT		; Set TPKT to
	  ADDI TPKT,PKTELI	; Point to TCP header

	  LOAD T4,PISH,(PKT)	; Source Host is local
	  MOVEM T4,LH
	  LOAD T4,PSP,(TPKT)	; Source Port
	  MOVEM T4,LP
	  LOAD T4,PIDH,(PKT)	; Destination Host is foreign
	  MOVEM T4,FH
	  LOAD T4,PDP,(TPKT)	; Destination port
	  MOVEM T4,FP
	  SETZM JCN		; Packet from net, not a JSYS call
	  SETZM WILDOK		; Wild TCB (Listen) is not ok for match

	  MOVE T1,PARAMS	; Arg block for CHKADD
	  CALL CHKADD		; Check the address of the packet
	  ANDN. T1		; Find TCB?
	    MOVE PKT,TICMPP	; Restore original pkt
	    MOVX T1,PT%TKI	; Received ICMP packet, no connection
	    TDNE T1,MNTRAC	; Want trace?
	      CALL PRNPKT	; Yes
	ENDIF.

	CHKADR
	RET

TICMPS:	SETZ FR,
	IFQN. TERRT,(TCB)	; Tracing connection?
	  TXO FR,1B0		; Yes
	ENDIF.

	PUSH P,PKT
	EXCH P6,BFR		; Put frame pointer back
	MOVE PKT,TICMPP		; Pointer to original packet
;;;	EXCH P6,BFR		; Put frame pointer back
	MOVX T1,PT%TIC		; Received ICMP packet for connection
	TXNN FR,1B0		; TCB trace or
	 TDNE T1,MNTRAC		; Want trace?
	  CALL PRNPKT		; Yes
	POP P,PKT

;;;	EXCH P6,BFR		; Put frame pointer back
	DMOVE T1,TICMPA		; Get code,,type & info
	MOVE T3,TICMPR		; Processing routine
	MOVE P6,TICMPP		; Pointer to original packet
	EXCH P6,BFR		; Put frame pointer back
	CALLRET (T3)		; Onward

	ENDTV.
	PURGE CPKT

;Destination unreachable

TCPICU:	INCRNO TCIDU,(TCB)	; Count messages
	HLRZ T2,T1		; Code
	CAIG T2,5
	 SKIPA T2,[EXP MNTX16	; Net down
		   EXP MNTX06	; Host down
		   EXP MNTX17	; Protocol not available
		   EXP MNTX23	; Service not available
;cwl set tsmxs & repacketize? get icmp to return size
		   EXP MNTX02	; Datagram too long
		   EXP MNTX25	; Route failure
		](T2)
	  MOVX T2,MNTX34	; Unspecified error
	MOVX T1,EFP+^D14	; Foreign end cannot be reached
	CALL USRERR		; Set TERR and TCERR from T1 and T2
				; T1 now zero if interrupt sent
	IFN. T1			; For compatability, abort if interrupts not on
	ANDQE. TTOSR,(TCB)	; And this isn't a high-reliability connection
	  MOVX T1,EFP+^D14	; "Connection reset"
	  CALL ABTCON		; Abort the connection, T1 non-zero if "abort"
	ENDIF.
	MOVX T1,OK
MNTM5	AOS CELL(TCIAA,7,,TCI)	; Connections aborted by ICMP destination unr.
	RET



;Parameter problem

TCPICP:	INCRNO TCIPB,(TCB)	; Count messages
	MOVX T2,MNTX03		; Error in protocol header
;cwl say options if pointer .gt. 20. ?
	MOVX T1,OK
	CALL USRERR		; Set TERR and TCERR from T1 and T2
				; T1 now zero if interrupt sent
	IFN. T1			; For compatability, abort if interrupts not on
	ANDQE. TTOSR,(TCB)	; And this isn't a high-reliability connection
	  MOVX T1,EFP+^D14	; "Connection reset"
	  CALL ABTCON		; Abort the connection, T1 non-zero if "abort"
	ENDIF.
	MOVX T1,OK
	RET

;Redirect

TCPICR:	INCRNO TCIRD,(TCB)	; Count messages
	MOVE T3,T2		; New first-hop destination
	HLRZ T2,T1		; Code
	CAIG T2,3
	 SKIPA T2,[EXP MNTX27	; Net
		   EXP 1B0+MNTX26 ; Host
		   EXP 1B0+MNTX27 ; Net+TOS
		   EXP 1B0+MNTX26 ; Host+TOS
		](T2)
	  MOVX T2,<MNTX34>	; Unspecified error
;cwl build source route? what if there already is a source route?
	TXZN T2,1B0		; Want to setup a First-Hop-Route?
	IFSKP.			; Yes
	  STOR T3,TSFHOP,(TCB)	; Record route
	  MOVE T3,TODCLK
	  STOR T3,TSFHT,(TCB)	; When route specified
	  LOAD T3,PISH,(BFR)	; Sender of ICMP packet is
	  STOR T3,TSFHW,(TCB)	; Who redirected
	ENDIF.
	MOVX T1,OK		; Notify of error
	CALL USRERR		; Set TERR and TCERR from T1 and T2
	MOVX T1,OK
	RET



;Source quench

TCPICQ:	INCRNO TCISQ,(TCB)	; Count messages
	MOVE T1,TODCLK
	ADD T1,TPSQ0+0		; Coumpute block end time
	STOR T1,TCSQT,(TCB)
	MOVX T1,OK		; Try to report error
	MOVX T2,MNTX04		; Flow control
	CALL USRERR		; Set TERR and TCERR from T1 and T2
	MOVX T1,OK
	RET



;Time exceeded		(Could get TCP sequence # and RX it)

TCPICT:	INCRNO TCITE,(TCB)	; Count messages
	MOVX T1,EFP+^D09	; Report error
	MOVX T2,MNTX33		; Transmission timeout
	CALL USRERR		; Set TERR and TCERR from T1 and T2
	MOVX T1,OK
	RET
	SUBTTL	TCPPRC -- Top Level TCP Processing Routines

;TCPPRC	TCP processing. Process TVT's and run IP, RA, PZ, RX, DY, and BG
;processes.  IP is special because it is driven by packets arriving from
;the network.  BG is special because it does not have an input queue and
;that it must lock TCBH while it is running.

;	CALL TCPPRC		(From Internet fork)
;Ret+1:	Always.

TCPPRC::
	SAVEAC <FR>
MNTM5	AOS CELL(TCTPR,0,,TCT)	; TCPPRC calls
	SETZB T1,FR
	EXCH T1,TCPFLG		; Clear run request
MNTM5	SKIPE T1		; Wake up due to TCPFLG?
MNTM5	  AOS CELL(TCTPR,1,,TCT) ; TCPPRC runs due to TCPFLG
MNTM5<	ADDM T1,CELL(TCTPR,2,,TCT)> ; Accumulate sum of TCPFLG
	CALL UPDTCK		; Update time

	SKIPE INSVR		; Internet level needs space badly?
	  SETZM BG+PRCWAK	; Yes.  Make BG scavenge what it can

	CALL TVTOPR		; Operate TCP Virtual Terminals
				; (DLAYPZ, Negotiations, Listener)
	XMOVEI T1,IP		; Select Input Processor
	MOVE T2,TCPIPQ		; Extended Ptr to TCP input queue head
	LOAD T3,QNEXT,(T2)	; Get first thing on the queue
	CAMN T3,T2		; Empty if that is the head.
	IFSKP.
	  CALL TCPTSK		; Process available input packets
MNTM5<	ELSE.>
MNTM5<	  AOS CELL(TCTPR,3,,TCT)> ; TCPPRC run w/o any input
	ENDIF.

	CALL TCPRUN		; Run all the other "processes"
				; RA, PZ, RX, DY (in that order)
	XMOVEI T1,BG		; Ptr to Background Process
	MOVE T2,PRCWAK(T1)	; Wakeup time for BG
	CAMG T2,TODCLK		; Due for a run?
	  CALL TCPTSK		; Yes.  Run BG.

	SKIPN T1,TCPFLG		; Further work to do?
	  RET			; No
MNTM5	AOS CELL(TCTPR,4,,TCT)	; TCPFLG non-zero after TCPPRC run
MNTM5<	ADDM T1,CELL(TCTPR,5,,TCT)> ; Sum of non-zero TCPFLG after TCPPRC
	MOVE T1,TCPSW		; Check if allowed to loop
	TXNE T1,TCS%LP
	  JRST TCPPRC		; Yes, back again
	RET			; No

	SUBTTL	TCPCHK -- TCP's Periodic Check Routine

;TCPCHK	Periodic check on TCP.

;T1/	A TODCLK to be min'd against
;	CALL TCPCHK		; From Internet fork
;Ret+1:	Always.  T1 as min of arg and next TCP check time
;		 TCPTIM set to next run time

TCPCHK::
	SKIPLE TCPON		; Has the TCP been initialized?
	  RET			; No, nothing to do

MNTM5	AOS CELL(TCTAA,1,,TCT)	; TCPCHK calls
	MOVE T2,TODCLK		; Assume nothing-to-do check time
	ADD T2,TCPCKT

	MOVSI T4,-NPROCS	; Set to scan process table
	DO.
	  MOVE T3,PRCTAB(T4)	; Get pointer to process block
	  CAMLE T2,PRCWAK(T3)	; Before current soonest time?
	    MOVE T2,PRCWAK(T3)	; Yes.  Take the new value
	  AOBJN T4,TOP.		; Loop over all processes in the table
	ENDDO.
				; BG is a special case - not in the table
	CAMLE T2,BG+PRCWAK	; Before current soonest time?
	  MOVE T2,BG+PRCWAK	; Yes.  Take the new value
	MOVEM T2,TCPTIM		; Save for scheduler test
	CAMLE T1,T2		; Min against arg
	  MOVE T1,T2		; TCP is next protocol to be run (so far)

MNTM5<	SUB T2,TODCLK>		; Interval
MNTM5	INHIST(TCTHS,TCT,T2,T3,T4) ; Histogram reschedule interval (CELL()

	RET

;Table of process block pointers (Order significant - RA before PZ, RX)

PRCTAB:	IFIW!RA			; Reassembler
	IFIW!PZ			; Packetizer
	IFIW!RX			; Retransmitter
	IFIW!DY			; Delayed Actions
NPROCS==.-PRCTAB

	SUBTTL	TCP Process Manipulation Routines

;TCPRUN	Run all the per-connection scheduled TCP tasks (RA, PZ, RX, DY).  Each
;process has a queue of scheduled TCBs.  TCPRUN scans all TCP "processes"
;and for each with a non-empty queue, calls the approriate routine for each
;due TCB in the queue.  A new wake up time is set into the process block.

;	CALL TCPRUN
;Ret+1:	Always.

TCPRUN:	SAVEAC <TCB>		; DQTASK kills it
	ACVAR <I,PRC>
	MOVSI I,-NPROCS		; Scan all TCP processes
	DO.			; A TCP process
	  CALL UPDTCK		; Update time
	  MOVE PRC,PRCTAB(I)	; Get pointer to process block
	  DO.			; While connections are (past) due
	    MOVE T1,PRCWAK(PRC) ; Get wakeup time for process
	    CAMLE T1,TODCLK	; Past due?
	      EXIT.		; Not yet time

	    ; Following IFSKP only used to reduce lock overhead
	    MOVE T4,PRCQ(PRC)	; Get pointer to queue head
	    LOAD T3,QNEXT,(T4)	; Get first TCB in the queue
	    CAMN T3,T4		; Empty queue?
	    IFSKP.		; No
	      XMOVEI T1,PRCLCK(PRC) ; The lock to lock
	      XMOVEI T2,DQTASK	; The function to call
	      TXO T2,<066B8>	; TCPRUN/ DQTASK
	      MOVE T3,PRC	; Process being run
	      CALL LCKCAL	; Lock the lock and dequeue the TCB
	      SKIPN TCB,T1	; Put pointer to TCB (or 0) in standard place
	        EXIT.		; Queue was empty

MNTM5	      AOS XCELL(Proc,PRCTCP,(PRC)) ; # TCBs processed by the process
	      LOAD FR,TERRT,(TCB) ; Trace flag
	      SKIPE FR		; Not want trace
	        MOVX FR,1B0	; Want trace

	      XMOVEI T1,TCBLCK(TCB) ; The lock on the TCB
	      XMOVEI T2,TCPTSK	; Overhead routine before applying process
	      TXO T2,<067B8>	; TCPRUN/ TCPTSK/ TCB
	      MOVE T3,PRC	; Process to be run
	      CALL LCKCAL	; Lock the TCB and  apply the process
	      LOOP.		; See if next TCB is due
	    ENDIF.
	  ENDDO.
	  AOBJN I,TOP.		; Loop over all processes in table
	ENDDO.
	RET
	ENDAV.

;DQTASK	Remove a TCB from a task input queue and resets the wakeup time for
;that task.  Beware empty queue.

;T1/	Process block pointer
; 	NOINT	TCB saved
;	CALL DQTASK
;Ret+1:	Always.  T1/ Extended pointer to TCB, or 0 if queue was empty.

PRC==T4
PROCQ==T3

DQTASK:	MOVE PRC,T1		; Save pointer to process block

MNTM5	AOS CELL(TCTDQ,0,,TCT)	; DQTASK calls

	SETZ T1,		; Assume empty queue
	MOVE PROCQ,PRCQ(PRC)	; Pointer to input queue
	LOAD T1,QNEXT,(PROCQ)	; Get 1st item on the queue
	CAMN T1,PROCQ		; If queue empty,
	IFSKP.			; Queue isn't empty

	  CALL DQ ;(T4 saved)	; Remove TCB from the process queue
	  MOVE T2,PRCQOF(PRC)	; Get queue word offset in TCB
	  SUBI T1,(T2)		; Point to top of TCB structure

MNTM5	  AOS CELL(TCTDQ,1,,TCT) ; Count tasks DQTASK'ed

	  LOAD TCB,QNEXT,(PROCQ) ; Get 1st item on remaining queue
	  CAMN TCB,PROCQ	; Is the queue now empty?
	  ANSKP.		; No
	    SUBI TCB,(T2)	; Point to top of TCB structure
	    MOVE T2,@PRCWOF(PRC) ; Get time due (double index by PRC and TCB)
MNTM5	    AOS CELL(TCTDQ,2,,TCT) ; # times more tasks remain in DQTASK

	ELSE.			; Process's queue is empty

	  MOVX T2,.INFIN	; No need to run

	ENDIF.
	MOVEM T2,PRCWAK(PRC)	; Set new wakeup
	RET

	PURGE PRC,PROCQ

;TCPTSK	Call the process routine and do accounting.

;T1/	Extended Process block pointer
;TCB/	Extended Locked Connection Block, unless IP or BG being run
;	CALL TCPTSK
;Ret+1:	Always.

TCPTSK::
	ACVAR <PRC>
	MOVEM T1,PRC
	MOVEM PRC,PROC		; Indicate who is running now.

	SKIPN STATF		; Taking statistics right now?
	IFSKP.			; Yes
	  XMOVEI T1,BG
	  XMOVEI T2,IP
	  CAME PRC,T1		; Running Background, or
	   CAMN PRC,T2		; Running Input Processor?
	  IFSKP.		; No, then have an activation delay
	    MOVEI T1,ACDLAY	; Point to activation delay histogram
	    MOVE T2,TODCLK	; Now
	    SUB T2,PRCSGT(PRC)	; Time of most recent signal
	    CALL DOHIST		; Histogram that delta
	  ENDIF.
	  XMOVEI T1,PRCTMR(PRC)	; Pointer to appropriate timer
	  MOVE T2,PRCROU(PRC)	; The routine to call
	  CALL TIMCAL		; Time the call

	ELSE.			; Not collecting statistics

	  CALL @PRCROU(PRC)	; Call the routine

	ENDIF.

	AOS TASKCT		; Count tasks run
	AOS PRCRNC(PRC)		; Count runs of this particular process
	SETZM PROC		; Indicate nobody running now.
	RET

	ENDAV.

	SUBTTL	TCP Process Scheduling

;SIGNAL	Cause a process to run.

;T1/	Extended Target process ID
;T2/	0 or delta in milliseconds
;TCB/	Extended Locked Connection Block
;	CALL SIGNAL
;Ret+1:	Always

SIGNAL::
	DMOVEM T1,T3
MNTM5	AOS CELL(TCTSG,0,,TCT)	; SIGNAL calls
MNTM5	AOS XCELL(,PRCTSG,(T3)) ; Count signals to process
	ADD T4,TODCLK		; Compute deadline
	XMOVEI T1,PRCLCK(T3)	; Pointer to lock cell of process
	XMOVEI T2,SIGNL0	; Function
				; T3/PRC and T4/DL are args to SIGNL0
	CALL LCKCAL		; Lock the lock and call the function
	RET


;SIGNL0	Guts of the Signal.

;T1/	Extended Process block (locked)
;T2/	Wakeup TODCLK
;TCB/	Extended Connection block (locked)
;      	NOINT
;	CALL SIGNL0
;Ret+1:	Always

SIGNL0:	ACVAR <PRC,DL,SAVTCB>
	DMOVEM T1,PRC		; Save Process and Deadline
	MOVEM TCB,SAVTCB	; Save the TCB to be scheduled
	MOVE T3,TODCLK		; Now in milliseconds
	MOVEM T3,PRCSGT(PRC)	; Set time of most recent signal
	SKIPN @PRCQOF(PRC)	;@TCQxx(TCB) This TCB already Q'd for task?
	IFSKP.			; Yes, check if sooner than before
MNTM5	  AOS CELL(TCTSG,2,,TCT) ; Assume re-SIGNAL for later time
	  CAML DL,@PRCWOF(PRC)	;@TCTxx(TCB) Compare with deadline already set
	    RET			; Re-signal later, leave in current position.
	  XMOVEI T1,@PRCQOF(PRC) ;@TCQxx(TCB) Point to queue in the TCB
	  CALL DQ		; Dequeue TCB so it can be inserted earlier
MNTM5	  AOS CELL(TCTSG,1,,TCT) ; Re-SIGNAL for TCB sooner than before
	ENDIF.
	MOVEM DL,@PRCWOF(PRC)	;@TCTxx(TCB) NB: double index, here and below
	MOVE T2,PRCQ(PRC)	; Pointer to input queue head
	MOVE T3,PRCQOF(PRC)	; Get offset to queue in TCB
	DO.
	  LOAD T2,QNEXT,(T2)	; Get next TCB on input queue
	  CAMN T2,PRCQ(PRC)	; Back to head?
	    EXIT.		; Yes.  Append to end of queue.
MNTM5	  AOS XCELL(,PRCTCC,(PRC)) ; Count total TCBs examined
	  MOVE TCB,T2		; Make right for indirect index
	  SUBI TCB,(T3)		; Make TCB point to base of block
	  CAML DL,@PRCWOF(PRC)	;@TCTxx(TCB) Found place to insert?
	    LOOP.		; No. Scan more of queue
	ENDDO.
	MOVE TCB,SAVTCB		; Point TCB at the signalee
	XMOVEI T1,@PRCQOF(PRC)	; Point to queue in that TCB
	CALL NQ			; And queue it up
	MOVE TCB,PRCQ(PRC)	; Pointer to input queue head
	LOAD TCB,QNEXT,(TCB)	; Get first TCB on the queue
	SUB TCB,PRCQOF(PRC)	; Make into standard TCB pointer
	MOVE T1,@PRCWOF(PRC)	;@TCTxx(TCB) Get wakeup time of 1st TCB on Q
	MOVEM T1,PRCWAK(PRC)	; That is new wakeup for this process
	MOVE TCB,SAVTCB		; Restore TCB pointer for caller
	CAMG T1,TODCLK		; Wakeup already gone by?
	  AOS TCPFLG		; Yes. Request that TCP keep running
	RET

	ENDAV.

	SUBTTL	TCP Input Processor

COMMENT	!

Executed in Internet (JOB0) context.  The Input Processor is called to
process the queue of packets just input from the network.  Each packet
is checked for proper format, checksum, etc and if all is OK, it is
bound to a TCB (if none is found IP responds with an RST packet).  An
ACK may be sent if the packet is a duplicate, or some things may be
processed from the packet.  The packet may be queued for the Reassembler.
In particular, IP processes the data acknowledged by the packet and sets
the new window for PZ.

!

;INPROC	Process the input packet queue. Packets have been queued by IP.
;	CALL INPROC
;Ret+1:	always.

INPROC:
	SAVEAC <PKT,TPKT>
	TRVAR <<ARGBLK,CHKADW>,NPKTS> ; Setup argument block for CHKADD
	CHKADL			; Local PARAMS also defined
	XMOVEI PARAMS,ARGBLK	; Local PARAMS points to ARGBLK
MNTM5	AOS CELL(TCIIP,0,,TCI)	; Count calls to INPROC
	SETZB FR,NPKTS

;Main loop.  Get next packet to be processed.

	DO.
	  MOVE CX,TCPIPQ	; Get pointer to input queue head
	  LOAD T1,QNEXT,(CX)	; Get pointer to first thing on queue
	  CAMN T1,CX		; If that is the head itself
	    EXIT.		; Get out because it is empty
	  XMOVEI PKT,-PKTQ(T1)	; Locate beginning of structure
	  CALL DQ		; Remove from input queue

	  SKIPGE T1,TCPIPQ-.INTPQ+.INTPM ; Input queue -n,,addr
	   CAMGE T1,[-5,,0]	; Big enough?
	  IFSKP.		; Yes
	    SOS XCELL(TCPIPQ,0,(T1)) ; One less packet in TCP input queue
	    AOS XCELL(TCPIPQ,4,(T1)) ; Total TCP packets processed
	  ENDIF.
	  AOS NPKTS		; Count packets this run

	  SETZ TCB,		; May be a bad packet
	  MOVX T1,PT%TDI	; TCP received packet
	  TDNE T1,MNTRAC	; Want trace?
 	    CALL PRNPKT		; Yes

	  LOAD T1,PIDO,(PKT)	; IP Data Offset
	  XMOVEI TPKT,PKTELI(PKT) ; Pointer to IP header
	  ADD TPKT,T1		; Pointer to TCP header
	  STOR TPKT,PSSDT,(PKT)	; Address of session level leader
	  LOAD T2,PIPL,(PKT)	; Transport level length
	  LSH T1,2
	  SUB T2,T1
	  STOR T2,PSSBZ,(PKT)	; Session level length

	  CALL TCPCKS		; Compute checksum function
	  IFN. T1		; Checksum failure

;Packet has bad checksum.  Flush it.

	    AOS BADPCT		; Count bad packets
MNTM2	    AOS CELL(TCPAB,1,,TCP) ; Count TCP checksum failures
MNTM5	    AOS CELL(TCIIP,3,,TCI) ; Count bad checksums in INPROC
	    MOVX CX,PT%TKC	; TCP packet with bad checksum
	    LOAD T2,PISH,(PKT)	; For trap log
	    LOAD T3,PIDH,(PKT)
	    MOVE T4,(TPKT)	; Packed source/dest ports
	    CALL MNTRAP
	    MOVX T1,PT%TKC	; TCP Killed due to bad checksum
	    TDNE T1,MNTRAC	; Want trace?
	      CALL PRNPKT	; Yes
badtck:	jfcl
	    CALL RETPKT		; Return the packet storage
	    LOOP.		; Back for next packet
	  ENDIF.

;Packet is OK to process

INPRO2:	  LOAD T1,PSSBZ,(PKT)	; Session level length
	  LOAD T2,PTDO,(TPKT)	; Words in session level leader
	  MOVE T3,TPKT
	  ADD T3,T2
	  LSH T2,2		; Bytes
	  SUB T1,T2
	  STOR T3,PAPDT,(PKT)	; Address of application level data
	  STOR T1,PAPBZ,(PKT)	; Application level length
	  
	  LOAD T1,PLNDE,(PKT)	; Time local net received packet is first
	  STOR T1,PTS,(PKT)	; Timestamp ok for subsequent checks
	  XMOVEI T1,IPDLAY	; Select the input processor delay histogram
	  CALL TSTAMP		; Process/update the timestamp

	  CALL PKTEND		; Get sequence number of end of packet + 1
	  STOR T1,PESEQ,(PKT)	; Save for subsequent checks

;Now setup for a call to CHKADD which matches the packet to a TCB.  If a
;TCB is found, CHKADD calls INPUT with the TCB locked.

	  LOAD T1,PIDH,(PKT)	; Destination Host
	  MOVEM T1,LH
	  LOAD T2,PDP,(TPKT)	; Destination port
	  MOVEM T2,LP
	  LOAD T3,PISH,(PKT)	; Source Host
	  MOVEM T3,FH
	  LOAD T4,PSP,(TPKT)	; Source Port
	  MOVEM T4,FP
	  SETZM JCN		; No JCN.  Call is from IP (net).
	  SETOM WILDOK		; Wild TCB (Listen) is ok for match

	  XMOVEI T2,INPUT	; Function to call if TCB found
	  MOVEM T2,FN		; With no ID to use PROC
	  SETZM ARG1		; No ARG1
	  SETZM ARG2		; or ARG2
	  MOVE T1,PARAMS	; Arg block for CHKADD
	  CALL CHKADD		; Check the address of the packet

;CHKADD	-1,,ELP+^D13 ; Invalid port(LP=0)
;CHKADD	-1,,ELP+^D05 ; Packet with wild FH/FP
;CHKADD	-1,,EFP+^D07 ; No such TCB (or NOTSYN.NOTSYN)
;INPUT	-1,,EFP+^D07 ; Not really for this TCB
;INPUT	-1	     ; Packet processed
;INPUT	 0	     ; Just return packet, don't send reset

	  CAMN T1,[-1]		; Packet disposed of successfully?
	    LOOP.		; Yes. Do another one.

;Packet on, and not for, a closed connection

MNTM5	  AOS CELL(TCIIP,4,,TCI) ; Count errors detected by INPROC

	  IFN. T1		; Want a RESET sent
	  ANDQE. PRST,(TPKT)	; If packet does not contain a RESET
	    HRRZ T2,T1		; Get just the error code
	    CAIE T2,EFP+^D07	; Is it "No such TCB" ?
	     CAIN T2,ELP+^D07	; Is it "No such TCB" ?
	      SETZ TCB,0	; Yes.  TCB used as flag to SNDRST
	    CALL SNDRST		; Reply with an RST Packet
MNTM5	    AOS CELL(TCIIP,5,,TCI) ; Count resets sent by INPROC
	  ENDIF.
				; Here when done with packet.
	  MOVX T1,PT%TID	; TCP done with packet
	  TXNN FR,1B0		; TCB trace or
	   TDNE T1,MNTRAC	; Want trace?
	    CALL PRNPKT		; Yes
	  CALL RETPKT		; Give back the storage
	  LOOP.			; Back for next packet
	ENDDO.
  
;TCP input packet queue completely processed.

MNTM5<	SKIPN T1,NPKTS>		; Packets processed
MNTM5	  AOS CELL(TCIIP,1,,TCI) ; Count no-input runs by INPROC
MNTM5<	ADDM T1,CELL(TCIIP,2,,TCI)> ; Count packets processed by INPROC

	CHKADR
	RET

	ENDTV.

;INPUT	3nd phase of Input Processor, Packet has been associated with a TCB.
;Called via CHKADD from INPROC

;PKT/	Extended Packet Pointer
;TPKT/	Extended TCP Packet Pointer
;TCB/	Extended Locked connection block
;	CALL INPUT
;Ret+1:	Always.  T1 has -1 if Pkt was handled OK,
;			-1,,EFP+^D07 ; No such TCB
;			 0 if Pkt not for (RX to) a closed connection

INPUT:	ACVAR <TESTB>
MNTM5	AOS CELL(TCIIN,0,,TCI)	; Count calls to INPUT
	LOAD FR,TERRT,(TCB)	; Trace flag
	STOR FR,PTRAC,(PKT)	; Set/Clear packet trace flag
	SKIPE FR		; Not want trace
	  MOVX FR,1B0		; Want trace
	CALL CHKSEQ		; See if properly sequenced
	MOVEM T1,TESTB		; -1 OK or DUP,,0; IGN,,0; ERR,,EFP+^D07
	HLRZ T2,TESTB		;	(rcv RX'd)(ReSync)

	CAIE T2,ERR		; ERROR ?
	IFSKP.			; Yes, Return an error

;CHKSEQ said this packet is in error -- no TCB (ERR,,EFP+^D07)

	  MOVX T1,PT%TKX	; TCP Killed, no TCB
	  TXNN FR,1B0		; TCB trace or
	   TDNE T1,MNTRAC	; Want trace?
	    CALL PRNPKT		; Yes
	  HRRO T1,TESTB		; -1,,EFP+^D07 to return
	  RET			; (must RETPKT)
	ENDIF.

	CAME T1,[-1]		; TRUE?
	IFSKP.			; Yes

;cwl	  check for matching precedence and security here
;	  preserve t2 or restore it

	  ANSKP.		; Doesn't match
	    SETZRO PACK,(TPKT)	; Force RESET to have seq=0, ack=peseq
	    HRROI T1,EFP+^D07	; Return error
	    RET
	ENDIF.

;TRUE, DUP, IGN packets

	LOAD T3,TSSYN,(TCB)	; State of Send synchronization
	LOAD T4,TRSYN,(TCB)	; State of Recv synchronization
;	CAIE T4,NOTSYN		; (CHKADD won't accept NOT.NOT)
	 CAIN T4,TIMWAT		; Connection in Time Wait state?
	  CAIE T3,NOTSYN
	IFSKP.			; Packet on TIME-WAIT connection
	  INCRNO TCPCC,(TCB)	; Packets for TIMWAT.NOT in INPUT for conn.
MNTM5	  AOS CELL(TCIIN,1,,TCI) ; Packets for TIMWAT.NOT in INPUT
	  MOVX T1,PT%TKN	; TCP Pkt received on Time-wait connection
	  TXNN FR,1B0		; TCB trace or
	   TDNE T1,MNTRAC	; Want trace?
	    CALL PRNPKT		; Yes
	  MOVX T1,OK		; Assume all ok
	  CAMN TESTB,[-1]	; TRUE?
	  IFSKP.		; No
	    OPSTR SKIPN,PRST,(TPKT) ; Packet have a RESET, or
	     CAIE T2,DUP	; Not DUP? (I.e. IGN)
	      RET		; Yes, ignore it, return ok
	  ELSE.			; TRUE
	    JN PSYN,(TPKT),R	; Ignore packets with SYN, it will be rx'ed.
	    ANDQN. PRST,(TPKT)	; Packet contains a RESET
	      $SIGNL (DY,0)	; Yes, exit TIME-WAIT state
	      MOVX T1,OK	; All ok
	      RET		; All done
	  ENDIF.
	  CALL RETPKT		; No longer need received packet

	  SETZ T1,		; No RESET
	  CALL ABTREP		; Send an ACK, original must have been lost
	  SETO T1,		; Return TRUE, packet has been released
	  RET
	ENDIF.

;TRUE, DUP, IGN packets and connection is neither Time-wait (nor Closed)

	CAIN T2,IGN		; SYN not for this connection?
	IFSKP.			; No, packet for this connection

;Packet is for the TCB, update info

	  LOAD T3,TCATM,(TCB)	; Time activated
	  MOVE T4,TODCLK	; Get current time
	  SKIPN T3		; Already activated?
	    STOR T4,TCATM,(TCB)	; No, it is now
	  STOR T4,TCLTM,(TCB)	; Update last packet receive time
	  STOR T4,TCBTP,(TCB)	; Keep from sending an inactivity probe
	  INCRNO TCRPC,(TCB)	; Count packets received for connection

	ENDIF.

	CAME TESTB,[-1]		; TRUE ?
	IFSKP.

; Handle normal, acceptable packet

	  LOAD T1,PIDH,(PKT)	; Get which incarnation he knows us under
	  STOR T1,TLH,(TCB)	; Stick it away
	  CALL PRCPKT		; Process the packet
	  AOS IPPKCT		; Count as Processed by IP
	  SETO T1,
	  RET
	ENDIF.

;DUP, IGN packets and connection is neither Time-wait (nor Closed)

	CAIE T2,DUP		; DUPlicate ?
	IFSKP.			; Yes

;Duplicate received. (SYN on a synched connection, old/future data, i-probe)

	  AOS DUPKCT		; Count it.
	  IFQE. PSYN,(TPKT)	; If not a possible TOPS20 probe
MNTM5	    AOS CELL(TCIIN,2,,TCI) ; Duplicates found by INPUT (no psyn)
	    INCRNO TCDUP,(TCB)	; Duplicates found by INPUT for conn. (no psyn)
	  ENDIF.

	  IFQN. PACK,(TPKT)	; Has ACK and
	  ANDQE. PRST,(TPKT)	; Doesn't have RESET
	    CALL PRCAW		; Process the ACK, window, and urgent
	  ENDIF.

	  CALL NULPKT		; Does the packet have any contents
	  SKIPN T1		; Skip FRCPKT if null
	    CALL FRCPKT		; Generate an ACK for the DUP
	  MOVX T1,PT%TKD	; TCP killed duplicate packet

	ELSE.			; IGNorable (new SYN)

	  INCRNO TCIGN,(TCB)	; Count packets IGNored for connection
	  MOVX T1,PT%TKR	; TCP killed ignorable packet (resync)

	ENDIF.

	TXNN FR,1B0		; TCB trace or
	 TDNE T1,MNTRAC		; Want trace?
	  CALL PRNPKT		; Yes
	CALL RETPKT		; Release the storage space
	SETO T1,		; Return TRUE, packet processed & RETPKT'd
	RET

	ENDAV.

;CHKSEQ	Determine the validity of a packet on the basis of sequence number,
;acknowledge number, synchronization state, and the presence of SYN
;in the packet.  Only called from INPUT.

;PKT/	Extended Packet Pointer
;TPKT/	Extended TCP Packet Pointer
;TCB/	Extended Locked connection block
;	CALL CHKSEQ
;Ret+1:	Always
;T1 is set to -1 if packet is ok to process (R.eq.SYNABL & SYN w/o ACK,
;or R.eq.SYNABL,S.ne.SYNABL & PACKS ACKs something we sent), or
;ERR,,EFP+^D07 (R.eq.SYNABL) otherwise.

;With T1 having ERR,,EFP+^D07; DUP,,0; IGN,,0 or -1 if OK

CHKSEQ:	LOAD T1,TRSYN,(TCB)	; Recv state
	CAIN T1,SYNABL		; Listening?
	  JRST CKACKS		; Yes.  Validate using ACK sequence
				; No.
;CKSYNS  Check sequence number.  Used after receive sync is established.
;A packet containing sequence numbers within the receive window is
;accepted;  if all sequence numbers spanned by the packet are outside
;the receive window, the packet is considered a DUPlicate.
;Stray  SYNs on already synched connections are called DUPlicates and
;will cause a null packet to be emitted which contains  the  sequence
;we  are  sending  on and the ACK sequence describing what we want to
;hear next.  This is enough information for the other end to be  able
;to form an RESET packet which will flush this connection (this would
;only happen if the other end had restarted recently).

;Ret+1:	always. T1 has -1 if pkt is OK to process, or DUP,,0; IGN,,0

CKSYNS:
MNTM5	AOS CELL(TCICK,0,,TCI)	; Count calls to CKSYNS

	IFQN. PSYN,(TPKT)	; If packet contains a SYN,
	  LOAD T1,TRSYN,(TCB)	; Get receive state
	  LOAD T2,PSEQ,(TPKT)	; and sequence number from packet
	  LOAD T3,TRIS,(TCB)	; and seq. number of original SYN recvd
	  CAIN T1,SYNRCV	; In SYN-RECEIVED?
	   CAMN T2,T3		; or just another copy of orig SYN?
	    JRST CKSYND		; Call it a dup. to get null pkt sent

;SYNRCV & PSEQ .ne. TRIS

	  CALL SYNAGN		; Resync. the conn.  Other end crashed
	  MOVX T1,<IGN,,0>	; Tell caller to ignore this packet
	  RET
	ENDIF.

CKSYN1:
MNTM5	AOS CELL(TCICK,1,,TCI)	; Count non-syns in CKSYNS
	LOAD T1,TRLFT,(TCB)	; Left window edge
	LOAD T2,TRWND,(TCB)	; Width of window
	IFQN. PRST,(TPKT)	; If packet contains a RESET,

	  SKIPN T3,T2		; If non-0, use it
	    MOVX T3,1		; Otherwise diddle so RST gets done
	  ADD T3,T1		; Compute Right plus max(1,width window)
	  MODSEQ T3		; Keep within right number of bits
	  LOAD T2,PSEQ,(TPKT)	; Get sequence number of packet
	  CALL CHKWND		; Is RST within the window?

	ELSE.			; If no RESET

	  ADD T2,T1		; Right window edge plus 1
	  MODSEQ T2
	  LOAD T3,PSEQ,(TPKT)	; Packet sequence number
	  LOAD T4,PESEQ,(PKT)	; Sequence number following Pkt
	  CALL OVRLAP		; Pkt and window have common point(s)?

	ENDIF.

	SKIPN T1		; Skip if yes
CKSYND:	  MOVX T1,<DUP,,0>	; Call it a DUPlicate
	RET			; From CHKSEQ

;CHKSEQ/CKACKS:  Validate packet when not synchronized.
;When  receive  synchronization  has  not  been established, the only
;acceptable   packet   is   one   which   will   establish    receive
;synchronization.   Furthermore,   if   we   have   established  send
;synchronization, the  packet,  if  it  acknowledges  anything,  must
;acknowledge something we have sent (eg, a SYN).
;T1 is set to -1 if packet is ok to process (R.eq.SYNABL & SYN w/o ACK,
;or R.eq.SYNABL,S.ne.SYNABL & PACKS ACKs something we sent), or
;ERR,,EFP+^D07 otherwise.

CKACKS:
MNTM5	AOS CELL(TCIAA,1,,TCI)	; Count CHKSEQ/CKACKS
	JN PACK,(TPKT),CKASE1	; Jump if packet ACKs something
	JE PSYN,(TPKT),CKASE2	; Give error if no SYN and no ACK
	JRST CKASET		; SYN and no ACK.  Try to open conn.

;Have ACK

CKASE1:	LOAD T1,TSSYN,(TCB)	; Get send state
	CAIN T1,SYNABL		; Have a Send Sequence to check?
	  JRST CKASE2		; Error if not waiting for SYN
				; (ACKing something we never sent)
;	LOAD T1,TSLFT,(TCB)	; Get Send Left
	LOAD T1,TSIS,(TCB)	; Get sequence # of our SYN
	LOAD T2,PACKS,(TPKT)	; What the Packet ACKS
	LOAD T3,TSSEQ,(TCB)	; Current Send Sequence
	ADDI T3,1
	MODSEQ T3
	CALL CHKWND		; Does Pkt ACK someting outstanding?
	JUMPN T1,CKASET		; Return TRUE if so

;No ACK, no SYN, not for this connection,  or  ACK when still LISTENing

CKASE2:
	CALL RSTADR		; Restore Wild foreign address fields
	SKIPA T1,[ERR,,EFP+^D07] ; Give error
CKASET:	 SETO T1,		; Ok to process
	RET			; From CHKSEQ

;PRCPKT	Process Packet which has been determined to be acceptable.

;PKT/	Extended Packet Pointer
;TPKT/	Extended TCP Packet Pointer
;TCB/	Extended Locked connection block
;	CALL PRCPKT
;Ret+1:	always. No value returned. PKT gone.

PRCPKT:	ACVAR <QP,QS,URGPTR>
MNTM5	AOS CELL(TCIPP,0,,TCI)	; Count calls to PRCPKT

;Process RESET (don't worry about (routing) options in RESET packets)

	IFQN. PRST,(TPKT)	; If packet contains a RESET
	  CALL PRCRST		; Process the reset (may not have PACK)
MNTM5	  AOS CELL(TCIPP,1,,TCI) ; Count RESETs seen by PRCPKT
	  MOVX T1,PT%TRS
	  JRST PRCPKR		; Return to caller.
	ENDIF.

;Extract IP & TCP options	;cwl what if unacceptable RST - wipe std opts?

	CALL TCPXOP		; Extract IP and TCP options
;	CALL TCPXIO		; Extract IP
;	CALL TCPXTO		; and TCP options

;Process ACK and window

	IFQN. PACK,(TPKT)	; If the packet contains an ACK
	  CALL PRCAW		; Process the ACK & update send window
	  JUMPN T1,PRCPKQ	; No TVTs available
	ENDIF.

;Process URGENT pointer from packet

	IFQN. PURG,(TPKT)	; Packet contains an urgent pointer
PRCURG:
MNTM5	  AOS CELL(TCIAA,2,,TCI) ; Count packets with URGent set
	  LOAD URGPTR,PSEQ,(TPKT) ; Sequence number of packet
	  LOAD T1,PURGP,(TPKT)	; Offset to urgent pointer
	  ADD URGPTR,T1		; Compute actual urgent pointer
	  MODSEQ URGPTR		; Reduce to the right number of bits

	  IFQE. TRURG,(TCB)	; Not yet in urgent receive mode

	    STOR URGPTR,TRURP,(TCB) ; No.  Set receive urgent pointer
	    SETONE TRURG,(TCB)	; Mark it as valid.
	    INCRNO TCRUR,(TCB)	; Count new URGENTs for connection
	    CALL USRURG		; Signal user of urgent data waiting

	  ELSE.			; Already in urgent receive mode

	    LOAD T1,TRLFT,(TCB)	; Receive Left pointer
	    MOVE T2,URGPTR	; What packet says pointer is
	    LOAD T3,TRURP,(TCB)	; Current Urgent pointer
	    CALL CHKWND		; See if urgent pointer is "bigger"
	    SKIPN T1		; Nothing to do if not
	      STOR URGPTR,TRURP,(TCB) ; Update receive urgent pointer
	  ENDIF.
	ENDIF.

;See if there is anything to reassemble from the packet. If not return the
;storage and return to caller.

	CALL NULPKT		; See if PKT is null
	IFN. T1			; Yes
MNTM5	  AOS CELL(TCIPP,2,,TCI) ; Count null packets seen by PRCPKT
	  MOVX T1,PT%TID
	  JRST PRCPKR		; Return to caller.
	ENDIF.

;Process SYN in incoming packet

	IFQN. PSYN,(TPKT)	; Jump if no SYN
PRCSYN:
MNTM5	  AOS CELL(TCIPS,0,,TCI) ; Count packets with SYN
	  LOAD T1,TRSYN,(TCB)	; Get receive state
	  CAIE T1,FINRCV	; Ignore SYN if FIN Received
	  IFSKP.
MNTM5	    AOS CELL(TCIPS,1,,TCI) ; Count SYNs when in FINRCV by PRCPKT
	  ELSE.
	    LOAD T1,TFH,(TCB)	; Foreign host
	    MOVE T2,T1		; Who is self
	    MOVX T3,RTCRTP	; Credability of transport protocol
	    LOAD T4,TCLTM,(TCB)	; Last packet to arrive
	    CALL HSTUP		; Update status
	      JFCL		; Already knew it

	    IFQE. TTOSU,(TCB)	; If user hasn't specified any TOS
	      LOAD T2,PITOS,(PKT) ; Copy that from other end
	      STOR T2,TTOS,(TCB)
	    ENDIF.

	    LOAD T2,TSSYN,(TCB)	; Get send state
	    CAIE T2,SYNCED	; Send sync established?
	    IFSKP.		; Yes

;S-SYNCED (Recv'd ACK, maybe this packet)

	      MOVX T1,SYNCED
	      STOR T1,TRSYN,(TCB) ; Make the state "synchronized" (syn.syn)

;cwl probably better to leave it as user set it instead of making user reset it
;	      IFQN. TDEC,(TCB)
;	        SETZRO <TRXPN,TRXPD,TRXPI>,(TCB) ; Back to dynamic algorithm
;	      ENDIF.

	      MOVX T1,OK	; General success event code
	      CALL USREVT	; State-change interrupt - connection open
	      JUMPN T1,PRCPKQ	; No TVTs available
	    ELSE.
;S-not synced (& not in this packet)

	      MOVX T1,SYNRCV	; SYN Received state
	      STOR T1,TRSYN,(TCB) ; is new Receive state
	      LOAD T2,PWNDO,(TPKT) ; Extract the window
	      STOR T2,TSWND,(TCB) ; That is the (first) send window for us

	      MOVE T1,TODCLK
	      SKIPN T2		; If window is closed
	        ADD T1,TVTWTM	; Delay a little
	      STOR T1,TSPRB,(TCB) ; Set time of first window probe

	      CALL USRSYN	; Signal first packet arrival with PSI
	    ENDIF.

	    LOAD T1,PSEQ,(TPKT)	; Get the packet sequence number
	    STOR T1,TRIS,(TCB)	; Save for filtering duplicate SYNs
	    STOR T1,TRURP,(TCB)	; Not in urgent receive mode
	    ADDI T1,1		; Advance Recv.Left over SYN
	    MODSEQ T1
	    STOR T1,TRLFT,(TCB)	; That is the first Left for us
	    STOR T1,TRLST,(TCB)	; First right-most segment received

;If the Reassembler will not see this packet, get an ACK for it now.
;Otherwise, see to it that one is eventually generated.

	    IFQE. PAPBZ,(PKT)	; If no session level data and
	    ANDQE. <PFIN>,(TPKT) ; No FIN
	      CALL FRCPKT	; Force an ACK of received SYN, now.
	    ELSE.
	      CALL SKDACK	; To encourage PZ
	    ENDIF.

	    AOS SYNRCT		; Count SYNs received
	  ENDIF.
	ENDIF.

;Queue  the  Packet  for the Reassembler. The receive packet queue is
;basically  ordered  by  sequence  number,  but  may  have  partially
;overlapping segments on it. (try searching right to left)

PRCPK7:	XMOVEI QS,TCBRPQ(TCB)	; Set scan pointer to Reassembly Q head
	MOVE CX,$TRPP(TCB)	; Word containing partial packet flag
	TXNE CX,TRPP		; A partial pkt contains left. Skip it.
	  LOAD QS,QNEXT,(QS)	; Point (into) partial packet

;Top of the search for right place to insert loop, QS points to element
;before first candidate.
;QS/	Extended pointer INTO a packet structure, at PKTQ.

	DO.
	  LOAD QS,QNEXT,(QS)	; Point into next candidate
	  XMOVEI CX,TCBRPQ(TCB)
	  CAMN QS,CX		; If that is the head,
	    EXIT.		; Insert new packet at end (before head)
	  LOAD T1,TRLFT,(TCB)	; Receive-left is beginning and
	  PNTLDR T2,PSSDT,-PKTQ(QS) ; Pointer to TCP header
	  LOAD T2,PSEQ,(T2)	; Sequence of current pkt (QS) is end
	  PUSH P,T2		; Save sequence number around call
	  LOAD T3,PSEQ,(TPKT)	; Sequence of new packet
	  LOAD T4,PESEQ,(PKT)	; End sequence of new packet
	  CALL OVRLAP		; New pkt fit before this one (QS) in queue?
	  POP P,T2		; Recover sequence number for use below
	  JUMPE T1,TOP.		; No. Advance queue scan ptr. Try next.

;Have a likely place to put the packet.  Be sure that we will not
;insert it before one which contains left.

	  MOVE T1,T2		; Sequence number of packet on queue (QS)
	  LOAD T2,TRLFT,(TCB)	; Recv Left
	  LOAD T3,PESEQ,-PKTQ(QS) ; End of packet + 1
	  CALL CHKWND		; Left within this packet?
	  JUMPN T1,TOP.		; Jump if so.  Look at next packet.
	ENDDO.



;Now  QS  points  to  where  to insert the new packet (before QS). Do
;checking to see if the packet to the left and packets to  the  right
;are  completely  contained  by  the  newly arrived packet.
;Release those which are.  This works well  if  retranmissions  are
;equal  to-  or  bigger than- the original transmissions. It does not
;worry about duplicates of (small) original transmissions which might
;be contained by packets already queued.
;N.B.  It works to replace a "partial packet" with a bigger one.


	LOAD T1,QPREV,(QS)	; Get one just skipped (or header)
	XMOVEI CX,TCBRPQ(TCB)	; Avoid fiddling with the header
	CAME T1,CX
	  CALL REMCHK		; Check and maybe remove T1 from Q

	DO.
	  XMOVEI CX,TCBRPQ(TCB)	; Head of queue
	  CAMN QS,CX		; Is current insert point the header?
	  IFSKP.
	    MOVE QP,QS		; No, save as predecessor in case needed
	    LOAD QS,QNEXT,(QP)	; Get next item on Q for next time
	    MOVE T1,QP		; Check the current item
	    CALL REMCHK		; Maybe delete it
	    JUMPN T1,TOP.	; Jump if deleted (QS ok for next time)
	    MOVE QS,QP		; Restore QS (point of insertion)
	  ENDIF.
	ENDDO.

;Actually queue the packet for the Reassembler.

	XMOVEI T1,PKTQ(PKT)	; Select the packet for EnQueueing
	MOVE T2,QS		; Where to enqueue it -- before QS.
	CALL NQ			; Enqueue the packet
	MOVX T1,PT%TQR
	TXNN FR,1B0		; TCB trace or
	 TDNE T1,MNTRAC		; Want trace?
	  CALL PRNPKT		; Yes

	
	XMOVEI QS,PKTQ(PKT)	; Get packet queue address
	DO.
	  PNTLDR T1,PSSDT,-PKTQ(QS) ; Point to TCP leader
	  LOAD T1,PSEQ,(T1)	; Packet beginning sequence number
	  LOAD T3,PESEQ,-PKTQ(QS) ; Packet ending sequence number
	  MOVE QP,T3		; Save it
	  LOAD T2,TRLST,(TCB)	; Last endpoint received

	  CALL CHKWND		; Overlap?
	  IFN. T1		; Overlap, can move TRLST further right
	    STOR QP,TRLST,(TCB)	; Move TRLST
	    LOAD QS,QNEXT,(QS)	; Get the next
	    XMOVEI CX,TCBRPQ(TCB)  ; Get RP Queue head
	    CAME QS,CX		; At the head?
	      LOOP.		; No, Try next
	  ENDIF.
	ENDDO.

;Now that packet has been queued, check to see if the maximum number of
;queued packets has been exceeded.  Close window level is processed by
;EMTPKT, source-quench and flush levels are processed here.

	LOAD T1,QCNT,+TCBRPQ(TCB)	; Get received packet queue length
	LOAD T2,TCRMW,(TCB)		; Get the close window limit for TCB
	IFG. T1				; Beware something clobbered
	CAMG T1,T2			; Exceed it?
	ANSKP.				; Yes
	  LOAD T2,TCRMQ,(TCB)		; Get the Source Quench limit
	  CAMG T1,T2			; Exceed it?
	  IFSKP.			; Yes, try to send a source quench
	    XMOVEI CX,TCBRPQ(TCB)	; Get RPQ queue head
	    LOAD PKT,QPREV,(CX)		; Get the previous
	    XMOVEI PKT,-PKTQ(PKT)  	; Top of packet structure

	    LOAD T1,TCSQF,(TCB)		; When can send next quench
	    CAML T1,TODCLK		; Time to send another?
	    IFSKP.			; Yes
	      SETONE PPROG,(PKT)	; Don't let ICMERR flush the packet
	      MOVX T1,ICM%SQ		; ICMP Source Quench
	      SETZ T2,
	      CALL ICMERR		; Send ICMP error
	      SETZRO PPROG,(PKT)  	; It is zero in input packets
	      MOVE T1,TODCLK
	      ADD T1,TPSQ0+3		; When can send the next
	      STOR T1,TCSQF,(TCB)	; Set it
	    ENDIF.

	    LOAD T1,QCNT,+TCBRPQ(TCB)	; Get received packet queue length
	    LOAD T2,TPRMF		; Get the flush limit
	    CAMG T1,T2			; Exceed that?
	    IFSKP.			; Yes, flush the previous
	      MOVX T1,PT%TKQ		; Packet killed Queue over limit
	      TXNN FR,1B0		; TCB trace or
	       TDNE T1,MNTRAC		; Want trace?
		CALL PRNPKT		; Yes

	      XMOVEI T1,PKTQ(PKT)	; Point to queue entry
	      CALL DQ			; Dequeue the previous
	      CALL RETPKT		; Release the packet
	    ENDIF.
	  ELSE.				; We just exceeded close window limit
	    MOVX T1,^D500		; Encourage a packet
	    CALL ENCPKT
	  ENDIF.
	ENDIF.

;Now see if the Reassembler has anything to do.  Signal it if so.

	LOAD T4,QNEXT,+TCBRPQ(TCB) ; Must be a pkt queued!
	LOAD T3,PESEQ,-PKTQ(T4)	; Fetch end sequence for what follows
	PNTLDR T4,PSSDT,-PKTQ(T4) ; Pointer to TCP header

;Now see if the Reassembler has anything to do.  Schedule it if so.

	IFQE. <PSYN,PFIN>,(T4)	; Controls don't need buffer space.
	ANDQE. TRCB,(TCB)	; Maybe there is a partially filled buffer
	ANDQE. TTVT,(TCB)	; TVTs don't need normal buffers
	  XMOVEI CX,TCBRBQ(TCB)	; Pointer to receive buffer queue head
	  LOAD T1,QNEXT,(CX)	; Pointer first element in queue
	  CAMN T1,CX		; Empty?
	    RET			; Yes.  RA cannot do anything without space.
	ENDIF.			; T3 has packet end sequence

	LOAD T1,PSYN,(T4)	; If have a SYN, TRLFT already increased
	ADD T3,T1		; So increase PESEQ too
	MODSEQ T3
	LOAD T1,PSEQ,(T4)	; Get sequence number of pkt
	LOAD T2,TRLFT,(TCB)	; Recv Left is the point of reassembly
	CALL CHKWND		; Does (first) packet have the next octet?
	IFN. T1			; Have next octet needed
MNTM5	  AOS CELL(TCIPP,4,,TCI) ; Count signals to RA by PRCPKT
	  $SIGNL(RA,-1)		; Make Reassembler run now (Note: -1 means
	ENDIF.			; Now, but after IP has finished all input)
	RET

;Packet contains nothing of further use.  Release it.

PRCPKQ:	MOVX T1,PT%TKT		; Killed, no TVTs available

;T1/	Trace code (PT%xxx)

PRCPKR:	TXNN FR,1B0		; TCB trace or
	 TDNE T1,MNTRAC		; Want trace? (PT%TID,PT%TRS)
	  CALL PRNPKT		; Yes
	CALLRET RETPKT		; Give back to free storage

	ENDAV.

;REMCHK	Check whether incoming packet contains (queued) argument packet.
;If so, dequeue and delete the argument packet.

;T1/	Extended pointer INTO a packet on a queue @ PKTQ
;PKT/	Extended Packet Pointer (incoming pkt)
;TPKT/	Extended TCP Packet Pointer (incoming pkt)
;TCB/	Extended Locked connection block
;	CALL REMCHK
;Ret+1:	Always.  T1 -1 if packet was deleted or 0 otherwise.

REMCHK:	SAVEAC <PKT>		; Will have pointer to queued packet
MNTM5	AOS CELL(TCIRM,0,,TCI)	; Count calls to REMCHK

	LOAD T4,PSEQ,(TPKT)	; Start of newly arrived packet
	LOAD T3,PESEQ,(PKT)	; End + 1 of newly arrived packet
				; PKT is now free for argument packet (RETPKT)
	XMOVEI PKT,-PKTQ(T1)	; Extended pointer at top of queued packet

	PNTLDR T1,PSSDT,(PKT)	; Pointer to TCP header of queued packet
	LOAD T1,PSEQ,(T1)	; Start of queued packet
	LOAD T2,PESEQ,(PKT)	; End + 1 of queued packet

	CAMN T1,T4		; Quick check for exact duplicate
	 CAME T2,T3		; (Faster than OVRLAP)
	  CAIA			; Have to use OVRLAP to be sure
	   TDZA T1,T1		; Fake false return from OVRLAP
	    CALL OVRLAP		; See if QPKT has something PKT does not
	IFE. T1			; Must keep both if T1 is non-zero.
				; Really mean if overlap of UNACKED areas
MNTM5	  AOS CELL(TCIRM,1,,TCI) ; Count packets deleted by REMCHK
	  XMOVEI T1,PKTQ(PKT)	; This packet is extra baggage.
	  CALL DQ		; Remove it from the queue.
	  MOVX T1,PT%TDR	; Dequeued from reassembly
	  TXNN FR,1B0		; TCB trace or
	   TDNE T1,MNTRAC	; Want trace?
	    CALL PRNPKT		; Yes
	  CALL RETPKT		; Give up possibly full-size packet
	  SETZ T1,		; Return true to say something was done
	ENDIF.
	SETCM T1,T1		; Flip result
	RET

	ENDAV.

;PRCRST	Process a RESET packet received for an existing connection.

;PKT/	Extended Packet Pointer
;TPKT/	Extended TCP Packet Pointer
;TCB/	Extended Locked connection block
;	CALL PRCRST
;Ret+1:	always

PRCRST:	AOS RSTRCT		; Count RSTs received
MNTM5	AOS CELL(TCIPR,0,,TCI)	; Count calls to PRCRST
	INCRNO TCRST,(TCB)	; Count calls to PRCRST for connection
REPEAT 0,<;cwl archaic
	LOAD T1,TSSYN,(TCB)	; Send state
	LOAD T2,TRSYN,(TCB)	; Recv state
	CAIN T1,FINSNT
	 CAIE T2,NOTSYN
	IFSKP.

; R-NOTSYN, S-FINSNT		; CLOSING or LAST ACK

MNTM5	  AOS CELL(TCIPR,1,,TCI) ; Count PRCRST waiting for final ack
	  JE PACK,(TPKT),R	; ACK field not valid
MNTM5	  AOS CELL(TCIPR,2,,TCI) ; Count calls to PRCAW by PRCRST

	  CALLRET PRCAW		; Process it.

	ENDIF.
> ; End of REPEAT 0

	JRST PRCRS2		; Prevent hang when SYNAGN forgets user timeout
	IFQE. TSOPN,(TCB)	; If connection was never open, and
	ANDQN. TSPRS,(TCB)	; It is persistent
	  CALLRET SYNAGN	; Start over.
	ENDIF.
PRCRS2:
	MOVX T1,<EFP+^D07>	; "Connection RESET"
	MOVX T2,TCPX31		; Connection error or rejected
	CALL USRERR		; Set TERR and TCERR from T1 and T2
	MOVX T1,<EFP+^D07>	; "Connection RESET"
	CALLRET ABTCON		; Abort the connection.

;PRCAW	Update send left, send window (maybe schedule PZ), delete acknowledged
;send data.  Called from IP for DUPs, RESETS, normal packets, etc.

;TPKT/	Extended TCP Packet Pointer
;TCB/	Extended Locked Connection block
;	CALL PRCAW
;Ret+1:	Always.  T1/ OK or -1,,ELT+^D04 (No TVTs available)

PRCAW:	ACVAR <ACKSEQ,OLDL,OLDR,NEWAW>
MNTM5	AOS CELL(TCIPA,0,,TCI)	; Count calls to PRCAW
	LOAD ACKSEQ,PACKS,(TPKT) ; ACK sequence from Packet is new Send-left
	LOAD OLDL,TSLFT,(TCB)	; Save old Send-left in safe place

;Check that ACK is not to the left of the present Send-left, or of something
;that has not been sent.

	MOVE T1,OLDL		; Left-most ACK willing to accept
	MOVE T2,ACKSEQ		; The ACK
	LOAD T3,TSSEQ,(TCB)	; Get the current Send Sequence
	ADDI T3,1		; Willing to accept ACKSEQ = TSSEQ
	MODSEQ T3
	CALL CHKWND		; ACKs the same or more?
;cwl if of something not sent, must send ACK-only packet in response
	JUMPE T1,R		; Do no more if not

;ACK is acceptable, continue processing ACK and window information from packet.

	STOR ACKSEQ,TSLFT,(TCB)	; ACK sequence is new Send-left

MNTM5	AOS CELL(TCIPA,1,,TCI)	; Count ACKs processed by PRCAW

;Check if Urgent Send data has been ACKed, if it has, leave urgent send mode.

	IFQN. TSURG,(TCB)	; If in urgent send mode,
	  MOVE T1,OLDL		; Send-left
	  LOAD T2,TSURP,(TCB)	; Send urgent pointer
	  MOVE T3,ACKSEQ	; Number being acknowledged
	  ADDI T3,1		; Consider ACKd if URP=ACK
	  MODSEQ T3		; Worry about 32-bit arithmetic
	  CALL CHKWND		; See if urgent pointer is being ACKed
	  ANDN. T1		; True.
	    SETZRO TSURG,(TCB)	; Leave urgent send mode
MNTM5	    AOS CELL(TCIPA,2,,TCI) ; Count end of urgent in PRCAW
	ENDIF.

;Process (send) window information from incoming packet.  Window
;information is processed out of sequence-number order since the most
;recent information should be used (assumed to be in the last packet received).

PRCWND:	LOAD OLDR,TSWND,(TCB)	; Old Send-window plus
	ADD OLDR,OLDL		; Old Send-left is
	MODSEQ OLDR		; Old Send-right

	LOAD T2,PWNDO,(TPKT)	; The new window from packet
	STOR T2,TSWND,(TCB)	; Set into the TCB

;Determine if window is open (new send right greater than max of send
;sequence or what has been packetized) or closed.

	;cwl ought to be "ancient-send-left" for .gt. 2**32 octet wrap-around
	LOAD T1,TRIS,(TCB)	; Initial sequence # since window might
				; have moved back before old Send-left
	ADD T2,ACKSEQ		; New Send-right
	MODSEQ T2
	MOVE NEWAW,T2		; Make NEWAW non-zero if send-right
	SUB NEWAW,OLDR		; has changed
				; Right-most sequence number used is either
	LOAD T3,TSSEQ,(TCB)	; Send-sequence, if no partial packet, or
	LOAD T4,TSCPK,(TCB)	; If there is a partially filled packet,
	SKIPLE T4		; No
	  LOAD T3,PESEQ,(T4)	; Yes, the packet end sequence
	ADDI T3,1		; Want equal to be "overlap" = closed
	MODSEQ T3
	CALL CHKWND		; New right .le. what has been packetized?
	LOAD T3,TCFWT,(TCB)	; Cumulative time window has been closed
	IFN. T1			; Overlap means window is now closed
	  IFGE. T3		; Was it open?
	    SUB T3,TODCLK	; Yes, begin accumulating closed-window time
	    STOR T3,TCFWT,(TCB)
MNTM5	    AOS CELL(TCIPW,1,,TCI) ; Window closing in PRCWND
	    INCRNO TCRZW,(TCB)	; Window closing in PRCWND for connection
	  ENDIF.
	ELSE.			; No overlap means window is now open
	  IFL. T3		; Was it closed?
	    ADD T3,TODCLK	; Yes, stop accumulating closed-window time
	    STOR T3,TCFWT,(TCB)
MNTM5	    AOS CELL(TCIPW,2,,TCI) ; Window openings in PRCAW
	  ENDIF.		; Window opened
	ENDIF.			; Now closed or open


;If the window has opened or something has been acked, the packetizer
;might be able to run.  If the send side is SYNCED, signal PZ so it can
;check.

PRCWNO:	LOAD T1,TSSYN,(TCB)	; Get send state
	CAIE T1,SYNCED		; Synchronized?
	IFSKP.			; Yes
	  MOVE T1,ACKSEQ	; New ACK
	  SUB T1,OLDL		; Old ACK
	  IFE. T1		; No new ACK
	  ANDE. NEWAW		; No new window
				; Don't bother PZ
	  ELSE.
MNTM5	    AOS CELL(TCIPA,5,,TCI) ; Count times PRCAW notified PZ
	    $SIGNL(PZ,-1)	; Run PZ, but after RA
	  ENDIF.		; Something waiting
	ENDIF.			; Connection synchronized

;See if packets which might have been made untransmittable due to Send-right
;moving backwards have now become transmittable.  If so signal the
;Retransmitter.

PRCWNR:	LOAD T1,QCNT,+TCBRXQ(TCB) ; Any packets on retransmit queue?
	IFG. T1			; Yes
	  MOVE T1,OLDL		; Old Left before ACK
	  MOVE T2,OLDR		; Old right, before this ACK
	  LOAD T3,TSSEQ,(TCB)	; Current send sequence
	  CALL CHKWND		; Any pkts cutoff?
	  ANDN. T1		; Yes
	    MOVE T1,OLDR	; Right before this ACK,WND processed
	    MOVE T2,ACKSEQ	; New Left due to this ACK
	    LOAD T3,TSSEQ,(TCB)	; Current send sequence
	    CALL CHKWND		; See if ACK has exposed any pkts
	    ANDN. T1		; Yes
MNTM5	      AOS CELL(TCIPA,7,,TCI) ; Count signals to RX by PRCAW
	      $SIGNL(RX,-1)	; Run RX after all input packets queued to TCB
	ENDIF.

;Check if optimizing, if so, extract additional info

	IFQN. TPOMZ,(TCB)	; If optimizing and
	ANDQE. PURG,(TPKT)	; Urgent field doesn't have an urgent pointer

;cwl
;process PO1AK - which retransmission is being acked
;process PO1LS - retransmit any packets from (PACKS to PACKS+PO1LS)

;process PO1RX - which retransmission of packet - really want in RA, for TRLFT
;	  LOAD T1,PO1RX,(TPKT) ; Copy packet's retransmission counter
;	  STOR T1,TRLRX,(TCB)

	ENDIF.

;Check if something outstanding is being ACKed

	MOVE T1,OLDL		; Right-most already ACKed
	MOVE T2,ACKSEQ		; The ACK
	SUBI T2,1		; OLDL=ACKSEQ no good, ACKSEQ=TSSEQ ok
	MODSEQ T2
	LOAD T3,TSSEQ,(TCB)	; Get the current Send Sequence
	CALL CHKWND		; ACKs more? (OLDL lt ACKSEQ le TSSEQ)
	JUMPE T1,R		; Do no more if not

;Process unACKed SYN

	LOAD T1,TSSYN,(TCB)	; Send State
	CAIE T1,SYNSNT
	IFSKP.			; Have outstanding SYN to be processed
	  LOAD T1,TFH,(TCB)	; Foreign host is up - something was received
	  MOVE T2,T1		; Foreign host supplied the information
	  MOVX T3,RTCRTP	; Credability of transport protocol
	  LOAD T4,TCLTM,(TCB)	; Time last packet arrived
	  CALL HSTUP		; Update host status
	    JFCL		; Already knew it was up

	  MOVX T1,SYNCED
	  STOR T1,TSSYN,(TCB)	; Send side now synched
	  LOAD T2,TRSYN,(TCB)	; Recv state
	  CAIE T2,SYNRCV	; If a SYN has also been received,
	  IFSKP.
	    STOR T1,TRSYN,(TCB)	; Make receive side synced (going to ACK it)

;cwl probably better to leave it as user set it instead of making user reset it
;	    IFQN. TDEC,(TCB)
;	        SETZRO <TRXPN,TRXPD,TRXPI>,(TCB) ; Back to dynamic algorithm
;	    ENDIF.

	    MOVX T1,OK		; General success code
	    CALL USREVT		; State-change interrupt - connection open
	    JUMPN T1,R		; No TVTs available, connection was aborted
	  ENDIF.

;cwl also need -tvt & trbs or tvt & TVTISP - faster than scheduling RA
	  IFQN. TRPP,(TCB)	; If have a partial packet,
MNTM5	    AOS CELL(TCIPA,4,,TCI) ; Conn. synced by PRCAW, let RA pass data
	    $SIGNL(RA,-1)	; Make Reassembler run now (-1 means now,
	  ENDIF.		; but after IP has finished all input)
	ENDIF.

;Remove all fully-acked packets from the retransmission queue.

PRCAC2:	XMOVEI T1,TCBRXQ(TCB)	; Retransmit queue
	IFQN. QCNT,(T1)		; Something in it
	  MOVE T2,OLDL		; Old Left
	  MOVE T3,ACKSEQ	; New Left
	  CALL REMRXQ		; Delete ACKed packets
	ENDIF.

	LOAD T1,TSCPK,(TCB)	; Get Current Packet (0 if none)
	IFN. T1
	  PNTLDR T2,PSSDT,(T1)	; Point to TCP header
	  IFQE. <PPSH>,(T2)	; Push bit set?
	    LOAD T2,PIPL,(T1)	; Get current packet length
	    LOAD T1,PMXSZ,(T1)	; Get maximum packet length
	    CAMG T1,T2		; Packet full?
	    ANSKP.		; Packet not full
				; Do nothing
	  ELSE.
	    $SIGNL(PZ,-1)	; Push or Packet full...
	  ENDIF.		; Run the packetizer this pass
	ENDIF.

	MOVX T1,OK		; No error
	RET

	ENDAV.

;SNDRST Send a RESET Response to the Foreign TCP.

;PKT/	Extended Packet Pointer
;TPKT/	Extended TCP Packet Pointer
;TCB/	0 (no such connection error) or Extended connection block
;	CALL SNDRST		Beware of routing options
;Ret+1:	Always.

SNDRST:	SAVEAC <PKT,TPKT>
	TRVAR <SVTCB,<ADR,4>>
	ACVAR <PKTACK,ENDPKT>
MNTM5	AOS CELL(TCIAA,3,,TCI)	; Count calls to SNDRST

	MOVEM TCB,SVTCB		; Save this register where can get to it
	LOAD T1,PISH,(PKT)	; Extract source of packet
	LOAD T2,PIDH,(PKT)	; Get number he knew me by
	LOAD T3,PSP,(TPKT)
	LOAD T4,PDP,(TPKT)	; and destination port
	DMOVEM T1,ADR		; Swap into address block
	DMOVEM T3,2+ADR

	LOAD ENDPKT,PESEQ,(PKT)	; Get the end of the packet (plus 1)
	MOVX PKTACK,1B0		; Assume no ack
	OPSTR SKIPE,PACK,(TPKT)	; Skip if no ACK
	  LOAD PKTACK,PACKS,(TPKT) ; Extract the ACK Sequence from PKT

;Now we have tucked away all we need from the incoming packet.

	SETZB T1,TCB		; Min packet & no data & no TCB
	XMOVEI T2,ADR		; Address block
	CALL TCPIPK		; Get packet & initialize header
	  RET			; Error.  Other end will try again.
	MOVE TCB,SVTCB		; Restore this register

	SETONE <PRST>,(TPKT)	; Set the RST bit
	IFL. PKTACK		; No ACK
	  SETZRO PSEQ,(TPKT)	; So no sequence number
	  STOR ENDPKT,PACKS,(TPKT) ; Make acceptable ACK
	  SETONE <PACK>,(TPKT)	; Set the ACK bit
	ELSE.
	  STOR PKTACK,PSEQ,(TPKT) ; Take sequence number from packet
	ENDIF.

	SETZRO PTCKS,(TPKT)	; Checksumt field must be zero
	CALL TCPCKS		; Compute TCP packet checksum
	STOR T1,PTCKS,(TPKT)	; Set into packet

	LOAD T1,PIPL,(PKT)	; Transport level length
	STOR T1,PTPBZ,(PKT)
	LOAD T2,PIDO,(PKT)	; Transport level leader length, w
	LSH T2,2		; Bytes
	SUB T1,T2
	STOR T1,PSSBZ,(PKT)	; Session level length
	LOAD T2,PTDO,(TPKT)	; Session level leader length, w
	LSH T2,2		; Bytes
	SUB T1,T2
	STOR T1,PAPBZ,(PKT)	; Application level length

	MOVX T1,PT%TIR		; Reset generated by input processor
	IFN. TCB		; If have a TCB
	  INCRNO TCSPC,(TCB)	; Count packets sent over connection
;cwl second code for have TCB case?
	ENDIF.
	TXNN FR,1B0		; TCB trace or
	 TDNE T1,MNTRAC		; Want trace?
	  CALL PRNPKT		; Yes
	MOVX T1,1
	TXNN FR,1B0		; Trace?
	  SETZ T1,		; No
	STOR T1,PTRAC,(PKT)	; Yes flag packet	
	AOS RSTSCT		; Count errors sent
	AOS OPPKCT		; Count Output packets

	XMOVEI T1,OPDLAY	; Select the output processor delay histogram
	CALL TSTAMP		; Process the timestamp

	SETZ T1,		; No special first-hop routing
	CALLRET SNDGAT		; Send it to gateway. (NB: PPROG is 0)

	ENDAV.
	ENDTV.

;REMRXQ	Remove packets from a queue which are between Left and Right.  Called
;PRCAW(TCBRXQ,Old-Left,New-Left=TSLFT) and REXMIT(TCBRXQ,TSLFT,TSSEQ=FIN+1).

;T1/	Extended Queue head pointer
;T2/	Left
;T3/	Right
;TCB/	Extended Locked connection block
;	CALL REMRXQ
;Ret+1:	always

REMRXQ::			; Only global if two parts
	SAVEAC <PKT,TPKT>
	TRVAR <RXCNT,RXFUL,INITD,FINTD,SUMBY,IRXD,FRXD,RXC0>
	ACVAR <Q,LEFT,RIGHT,NEXT>
MNTM5	AOS CELL(TCIRS,0,,TCI)	; Count calls to REMRXQ
	DMOVEM T1,Q		; T1,T2 to Q,LEFT
	MOVEM T3,RIGHT		; T3 to RIGHT
	LOAD T1,TCRXC,(TCB)	; # pkts at head of rx q out during some rx
	MOVEM T1,RXCNT		; (so their round-trip-time is suspect)
	MOVEM T1,RXC0		; Save original for trace
	LOAD T1,QCNT,+TCBRXQ(TCB) ; Length of RX queue
	LOAD T2,TCSMO,(TCB)	; Connection's "full" count
	SUBI T1,-1(T2)		; Is RX queue "full"
	MOVEM T1,RXFUL		; .Gt. 0 means yes
	SETZM INITD		; PLNDE of oldest pkt not out during an rx
;           FINTD (if INITD ne 0) PLNDE of newest pkt not out during an rx
	SETZM SUMBY		; # bytes acked in pkts not out during an rx
	SETZM IRXD		; PXT of first rx of first rx'd packet in rx q
;           FRXD (if IRXD ne 0)  PLNDE of last rx of first rx'd packet in rx q

;Loop through RX queue, collecting info from ACKed packets

	LOAD NEXT,QNEXT,(Q)	; Get first packet in queue (if any)
	DO.
	  MOVE PKT,NEXT		; Get the current pkt to standard place
	  LOAD NEXT,QNEXT,(PKT)	; Set for next time
	  CAMN PKT,Q		; Is this the queue Head?
	    EXIT.		; Yes. Done.  Whole queue scanned.
IFN PKTQ,<XMOVEI PKT,-PKTQ(PKT)> ; Point to top of structure

MNTM5	  AOS CELL(TCIRS,1,,TCI) ; Count packets checked by REMRXQ
	  MOVE T1,LEFT
	  LOAD T2,PESEQ,(PKT)	; End of packet plus one
	  SUBI T2,1		; Seq. Num of last byte in packet
	  MODSEQ T2
	  MOVE T3,RIGHT
	  CALL CHKWND		; Is end of packet within the window?
	  IFE. T1		; No

;If packet has been retransmitted, it may have been enlarged by REPKTZ,
;so also check if data unique to this packet has been ACKed - get
;sequence number from PSEQ in next packet in queue, if it exists.

	    JE PRXD,(PKT),ENDLP. ; If not RXed, not REPKTZed, so stop looking
	    CAMN NEXT,Q		; Back to Q head?
	      EXIT.		; Yes, couldn't have REPKTZed, so stop looking
	    PNTLDR T3,PSSDT,-PKTQ(NEXT) ; Locate TCP header of next packet

	    MOVE T1,LEFT
	    LOAD T2,PSEQ,(T3)	; End of original packet plus one
	    SUBI T2,1		; Seq. Num of last byte in orig. packet
	    MODSEQ T2
	    MOVE T3,RIGHT
	    CALL CHKWND		; Is end of packet within the window?
	    JUMPE T1,ENDLP.	; No, so stop looking
	  ENDIF.		; Yes, delete the REPKTZed packet

;Packet has been ACKed, remove it from RX queue, collecting appropriate info.

	  XMOVEI T1,PKTQ(PKT)	; Packet has been ACKed, remove it from the Q
	  CALL DQ		; Dequeue the packet from the queue
	  LOAD T1,TCRXC,(TCB)	; Count of packets in RX queue at last RX
	  SUBI T1,1		; Removing one here
	  SKIPL T1		; Should never underflow
	    STOR T1,TCRXC,(TCB)	; Count of packets in RX queue at last RX

	  PNTLDR TPKT,PSSDT,(PKT) ; Pointer to TCP header

	  IFQN. PFIN,(TPKT)	; ACK of FIN
	    MOVX T1,NOTSYN	; Not Synchronized state (dead)
	    STOR T1,TSSYN,(TCB)	; Set into TCB
	    LOAD T1,TRSYN,(TCB)	; Get receive state
	    CAIE T1,NOTSYN	; Also closed?
	    ANSKP.		; No, still half open
	      MOVX T1,<XLP+^D03> ; "Not OPEN" event code
	      CALL USREVT	; State-change interrupt - connection closed
	      ANDQN. TSTMW,(TCB) ; Need Time Wait?
		SETZRO TSTMW,(TCB) ; Yes, doing it now
		MOVX T1,TIMWAT	; Begin Time-Wait
		STOR T1,TRSYN,(TCB)
		XMOVEI T1,DY
		MOVE T2,TPMSL	; Maximum segment lifetime is its duration
		CALL SIGNAL
	  ENDIF.


;Gather info based on whether packet was ever involved in a retransmission

	  SOSL RXCNT		; Packet unreliable due to a retransmission?
	  IFSKP.		; None retransmitted and none out during an RX
	    LOAD T1,PLNDE,(PKT)	; Time transmission ended
	    SKIPN INITD		; Have oldest time?
	      MOVEM T1,INITD	; No, this is it
	    MOVEM T1,FINTD	; This is youngest time
	    LOAD T1,PTPBZ,(PKT)	; Bytes being ACKed
	    ADDM T1,SUMBY	; Added to count
	  ELSE.			; Unreliable
	    SKIPE IRXD		; First packet (the retransmitted one)?
	    IFSKP.		; Yes
	      LOAD T1,PXT,(PKT)	; Time of original transmission
	      MOVEM T1,IRXD
	      LOAD T1,PLNDE,(PKT) ; Time of last transmission
	      MOVEM T1,FRXD
	    ENDIF.
	  ENDIF.

;Finished with packet, return it if there are no other readers

	  MOVX CX,PPROG		; We're done with packet
	  ANDCAB CX,PKTFLG(PKT)
	  PUSH P,CX		; Save readers

	  MOVX T1,PT%TDX	; Dequeued from retransmitter
	  TXNN FR,1B0		; TCB trace or
	   TDNE T1,MNTRAC	; Want trace?
	    CALL PRNPKT		; Yes

	  POP P,CX		; Restore readers
	  TXNN CX,PFLGP		; If no others using it, then
	    CALL RETPKT		; Return the packet
	  LOOP.			; Go look at more of the queue
	ENDDO.			; Finished scanning RX queue

;Update estimate of baud rate.

	SKIPN T1,SUMBY		; Able to estimate a baud rate?
	IFSKP.			; Yes
	  IMULI T1,^D8000	; Bytes per msec to Baud
	  MOVE T2,TODCLK	; Find time to get them ACKed
	  SUB T2,INITD		; Now - time first packet was sent
	  IDIV T1,T2		; Estimated baud rate
	  LOAD T4,TSESB,(TCB)
	  CALL FILRTT		; Filter it too
	  STOR T1,TSESB,(TCB)
	ENDIF.

	MOVX T1,PT%TRT		; Update round trip time parameters
	TXNN FR,1B0		; TCB trace or
	 TDNE T1,MNTRAC		; Want trace?
	  CALL TRCRTT		; Yes

;Update estimate of round trip time.

	SKIPN INITD		; Have unambiquous information?
	IFSKP.			; Yes
	  MOVE T1,TODCLK	; "Now"
	  SUB T1,FINTD		; Time for last packet to be ACKed
	  LOAD T2,TMNRT,(TCB)	; Min Round Trip time
	  SKIPE T2		; First sample or
	   CAMGE T1,T2		; Is this one shorter?
	    STOR T1,TMNRT,(TCB)	; Save new min

	  IFQN. <TRXPN,TRXPD>,(TCB) ; Static - fixed backoff
	    LOAD T2,TMXRT,(TCB)	; MAX Round Trip time
	    CAMLE T1,T2		; Is this longer?
	      STOR T1,TMXRT,(TCB) ; Save new max
	  ELSE.			; Dynamic backoff
	    LOAD T4,TSMRT,(TCB) ; Current estimate
	    CALL FILRTT		; Filter round trip time
	    STOR T1,TSMRT,(TCB)	; New reliable estimate
	    SETZRO TUNRT,(TCB)	; Forget unreliable component
	  ENDIF.		; End of which method

	ELSE.			; No unambiquous data
	SKIPN IRXD		; Any ambiguous data?
	ANSKP.			; Yes

	  IFQE. <TRXPN,TRXPD>,(TCB) ; Dynamic method
	    MOVE T1,TODCLK	; End of interval, find beginning
	    MOVE T2,IRXD	; Time of first transmission
;Must use worse case to get it to stabalize at no unnecessary retransmissions
jfcl;	    ADD T2,FRXD		; Time of last transmission
jfcl;	    LSH T2,-1		; Average time
	    SUB T1,T2		; Interval
	    SKIPGE T1		; Beware negatives
	    ANSKP.
	      LOAD T4,TSMRT,(TCB) ; Reliable component
	      LOAD CX,TUNRT,(TCB) ; Current unreliable
	      ADD T4,CX		; Current estimate
	      CALL FILRTT	; Filter unreliable estimate
	      LOAD CX,TSMRT,(TCB) ; Reliable component
	      SUB T1,CX		; New unreliable estimate
	      SKIPGE T1		; Beware negatives
	        SETZ T1,
	      STOR T1,TUNRT,(TCB) ; Save new unreliable estimate
	  ENDIF.		; Dynamic method
	ENDIF.			; New data


;If RX queue has become not-full, and packetizer blocked due to full queue,
;run packetizer
;cwl pz-blocked-rxq bit
	SKIPG RXFUL		; Was it full
	IFSKP.			; Yes
	  LOAD T1,QCNT,+TCBRXQ(TCB) ; Length of RX queue
	  LOAD T2,TCSMO,(TCB)	; Connection's "full" count
	  SUBI T1,-1(T2)	; Is RX queue "full"
	  ANDLE. T1		; Not now
	    $SIGNL (PZ,-1)	; Run packetizer this pass to reevaluate state
	ENDIF.

;Schedule retransmitter if there is still something unacknowledged

	IFQN. QCNT,+TCBRXQ(TCB)	; If something remains in RX queue
MNTM5	  AOS CELL(TCIRS,2,,TCI) ; Count signals to RX by REMRXQ

	  LOAD NEXT,QNEXT,+TCBRXQ(TCB) ; Get first thing in the queue
	  XMOVEI T1,RX		; Select the Retransmitter
	  LOAD T2,PLNDE,-PKTQ(NEXT) ; Get the Transmit time and
	  LOAD T3,PRXI,-PKTQ(NEXT) ; Current Retransmit interval
	  ADD T2,T3		; Time of next retransmit
	  SUB T2,TODCLK		; Convert to increment
	  MOVE T3,TPNOW		; Scheduling minimum
	  LSH T3,1		; Double it
	  CAMGE T2,T3		; RX very soon?
	    MOVE T2,T3		; Yes wait a bit for those who ACK each pkt
	  CALLRET SIGNAL	; Make the retransmitter run then
	ENDIF.

;Could unschedule this TCB from RX process, but its more work than just
;letting REXMIT find the queue empty and returning.

	RET

	ENDAV.

;TRCRTT	Dump parameters to be used to update round-trip time
;T1/	PT%TRT
;	CALL TRCRTT

TRCRTT:	SAVEAC <2,3,4,5,6,7,10,11,12,13,14> ; NB: P6=15 is TRVAR pointer
	MOVE 2,RXC0
	MOVE 3,RXCNT
	MOVE 4,RXFUL
	MOVE 5,INITD
	MOVE 6,FINTD
	MOVE 7,SUMBY
	MOVE 10,IRXD
	MOVE 11,FRXD
	LOAD 12,TCRXC,(TCB)
	LOAD 13,TSMRT,(TCB)
	LOAD 14,TUNRT,(TCB)	;NB 14 is TCB
	CALL PRNPKT
	RET

	ENDTV.


;FILRTT	Filter a round-trip time estimate

;T1/	New estimate
;T4/	Current smoothed estimate
;	CALL FILRTT
;Ret+1:	Always, T1 has new smoothed estimate

FILRTT:	MOVX T2,1
	MOVNI T3,@TPRXF		; Positive scale factor
	LSH T2,(T3)		; Scaled 1.0
	MOVE T3,TPRXI		; Assume increasing
	CAMLE T4,T1		; Old : New
	  MOVE T3,TPRXD		; Decreasing
	SUB T2,T3		; Scaled (1-alpha)
	IMUL T1,T2		; RTT*(1-alpha)
	IMUL T4,T3		; SRTT*alpha
	ADD T1,T4
	LSH T1,@TPRXF		; New smoothed estimate
	RET



;BYBETA	Adjust variable by variance function
;T1/	Value to be adjusted
;	CALL BYBETA
;Ret+1:	Always, T1 updated

BYBETA:	IMUL T1,TPRXV		; Increase by (scaled) variance
	ASH T1,@TPRXF		; Remove scale factor
	RET

;SYNAGN	Return a connection to Synchable state.

;TCB/	Extended Locked Connection Block
;	CALL SYNAGN
;Ret+1:	always

SYNAGN:	SAVEAC <BFR,PKT>
MNTM5	AOS CELL(TCIAA,5,,TCI)	; Count calls to SYNAGN
	INCRNO TCSAG,(TCB)	; Count SYNAGNs for connection
	CALL RSTADR		; Restore wild address fields
	SETZRO TCLTM,(TCB)	; Nothing received
	SETZRO TCBTP,(TCB)

;Moving Send Left to Send Sequence makes the next incarnation of this
;connection different from the one which has just failed and is
;getting resynched.  Thus, RSTs caused by old copies of the original
;SYN will be unacceptable and will not wipe out the new incarnation.

	LOAD T1,TSSEQ,(TCB)	; Send sequence = SYN + DATA
	STOR T1,TSLFT,(TCB)	; Where to begin next time.
	STOR T1,TSIS,(TCB)

	MOVX T1,SYNABL
	STOR T1,TSSYN,(TCB)	; Reset Send state
	LOAD BFR,TSCB,(TCB)	; Get current send buffer
	IFN. BFR		; If one
	  SETZRO TSCB,(TCB)	; Forget there was one
	  CALL RSTBFR		; Reset the buffer
	  XMOVEI T1,BFRQ(BFR)	; Point to queue entry
	  XMOVEI T2,TCBSBQ(TCB)	; Send buffer queue
	  LOAD T2,QNEXT,(T2)	; First thing on the queue
	  CALL NQ		; Make recycled buffer first again
	ENDIF.

	DO.
	  XMOVEI CX,TCBRXQ(TCB)	; Retransmit queue
	  LOAD T1,QNEXT,(CX)	; Get next item
	  CAMN T1,CX		; Qhead point to self?
	    EXIT.		; Yes, done
	  XMOVEI PKT,-PKTQ(T1)	; Point at top of structure
	  CALL DQ		; No, dequeue item
jfcl;	  SETONE PPRAX,(PKT)	; Don't bother sending it
jfcl;cwl test this
	  MOVX CX,PPROG		; We're done with it
	  ANDCAB CX,PKTFLG(PKT)
	  TXNN CX,PFLGP		; Anyone else want it?
	    CALL RETPKT		; No, release it
	  LOOP.			; Loop until queue empty
	ENDDO.

	MOVX T1,SYNABL
	STOR T1,TRSYN,(TCB)	; Reset the Recv state
	SETONE TRIS,(TCB)	; Do not know sequence number
	LOAD BFR,TRCB,(TCB)	; Get possible current receive buffer
	IFN. BFR
	  SETZRO TRCB,(TCB)	; Forget about it
	  CALL RSTBFR		; Reset it to virgin state (hard to do)
	  XMOVEI T1,BFRQ(BFR)	; What to NQ
	  XMOVEI T2,TCBRBQ(TCB)	; The receive buffer queue
	  LOAD T2,QNEXT,(T2)	; First thing on the queue
	  CALL NQ		; Make the recycled buffer first again
	ENDIF.

	SETZRO TRPP,(TCB)	; Forget about partially processed PKT

	DO.
	  XMOVEI CX,TCBRPQ(TCB)
	  LOAD T1,QNEXT,(CX)	; Receive Packet Queue
	  CAMN T1,CX		; Empty now?
	    EXIT.
	  CALL DQ		; Dequeue the packet
	  XMOVEI PKT,-PKTQ(T1)	; Put in standard place
	  CALL RETPKT		; Return packet buffer
	  LOOP.
	ENDDO.

;If persistent and know foreign address,

	JE TSPRS,(TCB),R	; If not persistent, quit
	JE TFP,(TCB),R		; If don't have foreign port, quit
	LOAD T1,TFH,(TCB)	; If don't have a foreign address,
	JUMPE T1,R		; Quit
;cwl assuming NP.IP format here... (may be unused/obsolete)
	LOAD T2,IA%CLS,+T1	; Extract IP network class bits
	TXZ T1,INTCLS(T2)	; Drop 1, 2, or 3 bits of network class
	TXZN T1,INTNET(T2)	; If wild net (within class),
	  RET			; Quit
	JUMPE T1,R		; If wild "rest", quit

;Schedule the packetizer

JFCL;	MOVX T1,SYNABL
JFCL;	STOR T1,TSSYN,(TCB)
	MOVE T1,TCPSY0		; 2 second delay to prevent loop if
	CALLRET DLAYPZ		; Foreign TCB non-x and RST causing us to loop

;RSTADR	Restore wild address fields.  Called from SYNAGN and CKACKS.

;A delayed duplicate may cause a foreign TCP to emit an RST packet to
;kill  what  it thinks is a half-open connection here. If in fact the
;connection has been closed and deleted, there may be a listening TCB
;which  CHKADD  will  find  and  bind  to  the  source  of  the  RST.
;Subsequently the TCP will just flush the RST and will not  emit  any
;response  to  it.  This  routine  is  called  to  undo the temporary
;binding.

;TCB/	Extended Locked connection block
;	CALL RSTADR
;Ret+1:	Always.

RSTADR:
MNTM5	AOS CELL(TCIAA,6,,TCI)	; Count calls to RSTADR
	LOAD T1,TOPLH,(TCB)	; Restore original local host
	STOR T1,TLH,(TCB)
	LOAD T1,TOPFH,(TCB)	; Restore original foreign host
	STOR T1,TFH,(TCB)
	LOAD T1,TOPFP,(TCB)	; Restore original foreign port
	STOR T1,TFP,(TCB)
	SETZRO TIPOR,(TCB)	; No received IP option count
	SETZM TCBIR(TCB)	; Nor data
	SETZRO TTPOR,(TCB)	; No received TCP option count
	SETZM TCBTR(TCB)	; Nor data
	SETO T1,		; Don't change options
	CALL TCPUOP		; But re-merge
	SETONE TSMXS,(TCB)	; Unspecified max segment size
	RET

> ; End of IFL PART-2
IFE PART-1,<LTCPT3:	LIT >
IFG PART-0,<
	SUBTTL	TCP Reasembler

COMMENT	!

The  REASEMBLER  is  called  with  TCB  set up to point at a (locked)
connection block. Its function  is  to  transfer  data  from  packets
queued for it by the Input Processor into user buffers queued by RECV%
calls on the TCP. The REASEMBLER also processes certain control  bits
in  the packets such FIN. Once handled, the PACKETIZER is signaled so
that it may generate an ACK for  the  packet.  TCP  Virtual  Terminal
characters  are  moved  into  line  buffers  via  the TELNET protocol
routines in the NVT code.

!

;REASEM
;Reasembler.

;TCB/	Extended Pointer to connection block
;	CALL REASEM
;Ret+1:	always

REASEM::			; Only global if two parts
	SAVEAC <PKT,TPKT,BFR>
	ACVAR <BYTNUM,XFRCNT,RCVLFT,LINBLK>
MNTM5	AOS CELL(TCARA,0,,TCA)	; REASEM calls
	SETO LINBLK,		; Indicate no terminal line locked
		; <0 must check TTVT, not locked (NOTSYN or no TVT assigned)
		; =0 non-standard, locked
		; >0 have TTVT (& TVTL & R-SYNCED) & locked

	IFQN. TTVT,(TCB)	; If a TCP Virtual Terminal
MNTM5	  AOS CELL(TCARA,1,,TCA) ; REASEM calls for TVT
	  LOAD T1,TRSYN,(TCB)	; State of receive side
	  CAIE T1,SYNCED	; OK to pass data now?
	    ANSKP.		; No.  But process control
MNTM5	  AOS CELL(TCARA,2,,TCA) ; REASEM found TVT synced
	  LOAD T2,TVTL,(TCB)	; Get the line number
	  IFN. T2		; Jump if none assigned yet or gone away
MNTM5	    AOS CELL(TCARA,3,,TCA) ; REASEM found TVTL
	    CALL TVTCHK		; Lock the terminal data base
	    IFSKP.
	      MOVEM T2,LINBLK	; Save here for later
	    ELSE.
MNTM5	      AOS CELL(TCARA,4,,TCA) ; REASEM TVTCHK failure
	      ANDG. T2		; Nothing locked (inactive, becoming active)
		SETZM LINBLK	; Locked & non-standared so
	    ENDIF.
	  ENDIF.
	ENDIF.

;Top of main loop:
;Check the queue of packets from the Input Processor.  If there are
;no packets, there is nothing that the Reassembler can do.

REASM0:
MNTM5	AOS CELL(TCARA,5,,TCA)	; REASEM loops
	XMOVEI CX,TCBRPQ(TCB)
	LOAD PKT,QNEXT,(CX)	; Get pointer to first thing on Q
	CAMN PKT,CX		; Receive packet queue empty?
	  JRST REASMX		; Yes.  Get out.
IFN PKTQ,<XMOVEI PKT,-PKTQ(PKT)> ; Point at top of structure
MNTM5	AOS CELL(TCARA,6,,TCA)	; Pkts available to REASEM
	PNTLDR TPKT,PSSDT,(PKT)	; Pointer to TCP header

;Set BFR to 0 if this is a TVT to avoid code which processes normal buffers.

	MOVX BFR,0		; Indicate no normal buffer
	IFLE. LINBLK		; Not a TVT, or not yet a TVT or TVT gone away

;Try to find a user buffer for filling.  This could be the Receive
;current buffer left from a previous pass or one queued from
;a user RECV% call.  Note TVTs cannot do RECV%s to queue buffers.

	  LOAD BFR,TRCB,(TCB)	; Get 0 or receive current buffer
	  ANDE. BFR		; Go use any that might be left

	    XMOVEI CX,TCBRBQ(TCB)
	    LOAD BFR,QNEXT,(CX)	; Pointer to first buffer queued
	    CAME BFR,CX		; Empty if that is the queue head
	    IFSKP.

;No buffer available. If there is a partially processed packet, it MUST
;contain unprocessed data so nothing more can be done.  Otherwise there
;may be controls (PUSH, FIN) which can be handled.

	      CALL TFRTST	; Should RECV buffers be flushed?
	      IFNSK.		; No
		JN TRPP,(TCB),REASMX  ; If there is a partial packet,
				;stop(unlock)
	      ENDIF.
	      MOVX BFR,0	; Indicate no buffer to use.

	    ELSE.		; Dq buffer at the head of receive buffer queue

	      MOVE T1,BFR	; Pointer to the buffer
	      CALL DQ		; Dequeue it
IFN BFRQ,<    XMOVEI BFR,-BFRQ(BFR)> ; Point at top of structure
	      STOR BFR,TRCB,(TCB) ; Remember as the current buffer
	    ENDIF.
	ENDIF.

	LOAD RCVLFT,TRLFT,(TCB)	; Seq. # of next octet of data required

;If this is a partial packet (TRPP ne 0), it hass more data to be processed.

	JN TRPP,(TCB),REAS13	; If continuing a packet, go process the rest

;First time we have seen this packet.  Flush it if it is not within
;the current window.  (Should we really throw away future data?)

MNTM5	AOS CELL(TCARA,7,,TCA)	; New packets seen by REASEM
	AOS RAPKCT		; Count packets seen by Reassembler
	MOVX T1,PT%TRA
	TXNN FR,1B0		; TCB trace or
	 TDNE T1,MNTRAC		; Want trace?
	  CALL PRNPKT		; Yes
	MOVE T1,RCVLFT		; Recv Left -- start of "The present"
	LOAD T2,TRWND,(TCB)	; Get current window width
	ADD T2,T1		; Form Recv.Right -- beginning of "Past"
	ADDI T2,1		; Allow SYN thru 0-window crock
	MODSEQ T2		; T1,T2 are Left and Right of the past
	LOAD T3,PSEQ,(TPKT)	; Sequence of the packet
	LOAD T4,PESEQ,(PKT)	; Get end + 1 from packet
	CALL OVRLAP		; Packet within window?
	IFE. T1			; No

;Nothing interesting in packet

	  XMOVEI T1,RADLAY	; Select the reassembler delay histogram
	  CALL TSTAMP		; Process/update the timestamp.
	  MOVX T1,PT%TDR	; Code for reassembler
	  TXNN FR,1B0		; TCB trace or
	   TDNE T1,MNTRAC	; Want trace?
	    CALL PRNPKT		; Yes, Call the packet printer
	  SETZRO PPROG,(PKT)	; Done with packet
	  XMOVEI T1,PKTQ(PKT)	; Pointer to this useless packet
	  CALL DQ		; Dequeue it
	  CALL RETPKT		; Give space to free storage
	  JRST REASM0		; Try the next packet.
	ENDIF.

MNTM5	AOS CELL(TCARA,10,,TCA)	; Packet is within receive window

;If receive-left is within the current packet, there is something which
;can be reassembled out of it.

	LOAD T1,PSEQ,(TPKT)	; Start of the packet
	MOVE T2,RCVLFT		; Next thing needed for reassembly
	LOAD T3,PESEQ,(PKT)	; End of the packet
	CALL CHKWND		; Left within the packet?
	JUMPE T1,REASMX		; Jump if not.  Must wait for it to show

MNTM5	AOS CELL(TCARA,11,,TCA)	; REASEM found left within packet


REAS13:

MNTM5	AOS CELL(TCARA,12,,TCA)	; Packet instances processed by REASEM

;Set BYTNUM to the byte offset into the packet of the first byte needed.

	MOVE BYTNUM,RCVLFT	; Next to be reassembled
	LOAD T1,PSEQ,(TPKT)	; Start of packet
	SUB BYTNUM,T1		; Offset into data
	IFG. BYTNUM		; If not zero, check for SYN
	  LOAD T1,PSYN,(TPKT)	; Get value of SYN bit
	  SUBI BYTNUM,0(T1)	; Discount space taken by SYN
	ENDIF.
	MODSEQ BYTNUM		; Beware wrap-around

;Find the number of bytes of buffer space available

	SKIPG T2,LINBLK		; Is this a TVT with a standard data block?
	 TDZA T1,T1		; No. Assume no buffer and no space
	  CALL TVTISP		; Yes.  Get amount of space to T1
	IFN. BFR		; If have a user buffer,
	  LOAD T1,BCNT,(BFR)	; Get number of unused bytes in it (may be 0)
	ENDIF.


;Setup XFRCNT to be the number of bytes remaining in the packet (preserve T1)

	LOAD XFRCNT,PAPBZ,(PKT)	; Get application level (TCP data) length
	SUB XFRCNT,BYTNUM	; Forget already processed bytes
	PUSH P,XFRCNT		; Save number bytes available in packet


;Find number of bytes which can be transferred, Min(space,data), but
;zero if receive synchronization has not yet been established. (Preserve T3)

	SKIPN T1		; No space available AND
	  CALL TFRTST		; Should we flush RECV buffers?
	IFSKP.			; Yes
	  SETONE TWFR,(TCB)	; Flag we have done it in TCB
MNTM5	  AOS CELL(TCARA,20,,TCA)  ; Count total number of times
	ELSE.
	  CAMLE XFRCNT,T1	; Min of available bytes and space is
	    MOVE XFRCNT,T1	; The actual transfer count
	  LOAD T2,TRSYN,(TCB)	; Allowed to pass data?
	  CAIE T2,SYNCED	; Receive side must be either SYNCED
	   CAIN T2,FINRCV	; or FINRCV'd (cwl how??)
	    CAIA
	     SETZ XFRCNT,	; Cannot pass data yet (continue for controls)

	  IFG. XFRCNT		; If have something to transfer,
	    MOVE T1,BYTNUM	; Where to start transfer from packet
	    LOAD T3,PTDO,(TPKT)	; Get TCP data offset in words
	    ADD T3,[POINT 8,(TPKT)] ; Byte pointer to data byte zero
	    ADJBP T1,T3		; Byte pointer to TRLFT byte
	    SKIPG T2,LINBLK	; Address of dynamic data area
	    IFSKP.		; Have TVT terminal line block
MNTM5	      AOS CELL(TCARA,13,,TCA)  ; REASEM calls PRCTVT
	      MOVE T3,XFRCNT	; How much to transfer
	      CALL PRCTVT	; Process TVT chr on line in T2
	      MOVEM T1,XFRCNT	; how much actuallt transfered
	    ELSE.
	      MOVE T2,XFRCNT	; How much to transfer
	      CALL PRCDAT	; Process the data
	    ENDIF.
	    ADDM XFRCNT,BYTRCT	; Count bytes received
	  ENDIF.
	ENDIF.
	ADD RCVLFT,XFRCNT	; Update receive left
	MODSEQ RCVLFT
	STOR RCVLFT,TRLFT,(TCB)
	IFQN. TPOMZ,(TCB)	; If optimizing and
	ANDQE. PURG,(TPKT)	; Urgent field doesn't have an urgent pointer
	  LOAD T1,PO1RX,(TPKT)
	  STOR T1,TRLRX,(TCB)
	ENDIF.
	CALL SKDACK		; To encourage PZ
MNTM5	AOS CELL(TCARA,14,,TCA)	; (cwl this sb same as 12)
	POP P,T1		; Restore the number of bytes in packet
	CAME T1,XFRCNT		; Emptied all data from the packet?
	  JRST REAS18		; No.

;Packet empty, finish it off & loop back for next

MNTM5	AOS CELL(TCARA,15,,TCA)	; Packets emptied by REASEM
	SETZRO TRPP,(TCB)	; Indicate no partial packet waiting

;Check if can leave receive urgent mode -- urgent pointer must be in the past.

	IFQN. TRURG,(TCB)	; If in urgent receive mode
	  LOAD T3,PESEQ,(PKT)	; Get the end plus one of this packet
	  LOAD T2,TRURP,(TCB)	; And the receive urgent pointer
	  MOVE T1,T3
	  SUBI T1,200000
	  MODSEQ T1
	  CALL CHKWND		; Urgent pointer in recent past
	  ANDN. T1		; And the pointer is now in the past,
	    SETZRO TRURG,(TCB)	; Leave urgent receive mode
	ENDIF.

;PUSH buffer to user if PUSH or FIN

	IFQN. <PPSH,PFIN>,(TPKT) ; If packet contains a PUSH or FIN,
MNTM5	  AOS CELL(TCARA,16,,TCA) ; PUSH seen by REASEM
	  ANDQE. TTVT,(TCB)	; Put nothing to do for TVTs
	    CALL PRCPSH		; Process PUSH
	ENDIF.

;Process FIN

	MOVE T2,LINBLK		; Possible TVT
	LOAD T1,PFIN,(TPKT)
	SKIPE T1		; If packet contains a FIN
	  CALL PRCFIN		; Process FIN, generate Ack

	LOAD T1,PESEQ,(PKT)	; Sequence number following packet (maybe FIN)
	STOR T1,TRLFT,(TCB)	; Set the new Left
	LOAD T1,PO1RX,(TPKT)
	STOR T1,TRLRX,(TCB)
	CALL NUWNDO		; Update receive window, maybe encourage ACK

	XMOVEI T1,RADLAY	; Select the reassembler delay histogram
	CALL TSTAMP		; Process/update the timestamp

	MOVX T1,PT%TDR
	TXNN FR,1B0		; TCB trace or
	 TDNE T1,MNTRAC		; Want trace?
	  CALL PRNPKT		; Yes

;Finished with this packet, dequeue it and return the space to free storage.

	SETZRO PPROG,(PKT)	; Done with packet
	XMOVEI T1,PKTQ(PKT)	; Pointer to the packet
	CALL DQ			; Dequeue it
	CALL RETPKT		; Free the area
	JRST REASM0		; Process the next packet.

;Here when more remains in packet that couldn't be moved into a buffer
;(because it is now full, or because receive synchronization has not
;yet been established).

REAS18:	IFN. BFR		; If have a buffer,
	ANDQE. BCNT,(BFR)	; Which is full,
	  SETZRO TRCB,(TCB)	; Return it to the user
	  MOVX T1,OK		; Indicate buffer is good
	  CALL USRBFF		; User buffer filled routine
MNTM5	  AOS CELL(TCARA,17,,TCA) ; Calls to USRBFF by REASEM
	ENDIF.

;Flag current packet as a "partial packet" so can omit initial checks next time

	SETONE TRPP,(TCB)	; Set the partial packet waiting bit

;If the TVT buffer has been filled (BFR=0), or if a current buffer couldn't
;be filled, must stop a while.  In either case, encourage an ack.
;Otherwise, loop back for another pass.

	IFN. BFR		; If not a TVT
	  JE TRCB,(TCB),REASM0	; Try to get another buffer from queue
	ENDIF.

;All done for now

REASMX:	SKIPL T2,LINBLK		; Do we have a term line locked?
	  CALL ULKTTY		; Yes.  Unlock it
	RET

	ENDAV.

;PRCPSH	Process a received PUSH.

;TCB/	Extended Locked connection block
;BFR/	Extended Current buffer NB: MAY BE 0
;	CALL PRCPSH
;Ret+1:	always

PRCPSH:
MNTM5	AOS CELL(TCAAA,2,,TCA)	; PRCPSH calls
	INCRNO TCRPU,(TCB)	; PRCPSH calls for connection
	JUMPE BFR,R		; All done if no buffer

	LOAD T1,BICNT,(BFR)	; If buffer is empty, don't
	LOAD T2,BCNT,(BFR)	; bother returning it
	CAMN T1,T2
	  RET

	MOVX T1,<<OK>B7+TCP%PU>	; OK code, with PUSH flag
	SETZRO TRCB,(TCB)	; Indicate no current buffer
	CALL USRBFF		; Tell user buffer filled
	MOVX BFR,0		; Indicate no current buffer
	RET





;PRCFIN	Process FIN.

;TCB/	Extended Locked connection block
;T2/	LINBLK
;	CALL PRCFIN
;Ret+1:	always

PRCFIN:
MNTM5	AOS CELL(TCAAA,3,,TCA)	; PRCFIN calls
	MOVX T1,FINRCV		; FIN Received state
	STOR T1,TRSYN,(TCB)	; Set into TCB
	AOS FINRCT		; Count FINs received

;If this connection is a virtual terminal, cancel any outstanding
;negotiations since the other end can no longer reply.

	SKIPLE T2		; TVT dynamic data block address?
	  CALL TVTNC1		; Yes, Cancel negotiations for single line

	MOVX T1,^D100
	CALL ENCPKT		; Make sure FIN is ACKed promptly
	RET

;PRCDAT	Move data from packet into user buffer.

;TCB/	Extended Locked connection block
;PKT/	Extended Packet
;TPKT/	Extended Pointer to TCP header
;BFR/	Extended Buffer
;T1/	Byte pointer into packet
;T2/	Count of bytes to transfer to buffer
;	CALL PRCDAT
;Ret+1:	always

PRCDAT:	ACVAR <PKTPTR,XFRCNT>
MNTM5	AOS CELL(TCAAA,1,,TCA)	; PRCDAT calls
	DMOVEM T1,PKTPTR

	SETZ T1,		; Request data mapping
	CALL SETTUM		; Set TCP's usermode map (NOSKED)

	MOVE T1,PKTPTR		; Source byte pointer
	LOAD T2,BPTR,(BFR)	; Destination byte pointer
	MOVE T3,XFRCNT		; Number to do
	SETZ T4,		; Monitor-to-user transfer
	CALL XFRDAT		; Do the data transfer
	STOR T2,BPTR,(BFR)	; Store back updated pointers
	MOVEM T1,PKTPTR

	LOAD T1,BCNT,(BFR)	; Get number of holes in buffer at start
	SUB T1,XFRCNT		; Reduce by number transferred
	STOR T1,BCNT,(BFR)	; Update the count in the buffer

	LOAD T3,TRBS,(TCB)	; Get receive bufferspace (due to RECV%s)
	SUB T3,XFRCNT		; Remove space just filled from window
	STOR T3,TRBS,(TCB)

	CALLRET USTTUM		; (OKSKED)

	ENDAV.

;NUWNDO	Update Receive Window.

;Whenever a user RECV% increases the available buffer space, or
;after processing a packet entirely, the size of the window being
;sent to the remote TCP is updated and set into the TCB.  If
;processing the packet has moved Received Left, the Packetizer is
;signaled so it will generate an ACK.

;TCB/	Extended Locked Connection block
;	CALL NUWNDO
;Ret+1:	always

NUWNDO::
MNTM5	AOS CELL(TCANW,0,,TCA)	; NUWNDO calls
	LOAD T1,TRBS,(TCB)	; Currently available buffer space
	IFQN. TTVT,(TCB)	; If a TVT
	  SETZ T1,		; Assume no space
	  LOAD T2,TVTL,(TCB)	; Unless a line
	  ANDN. T2		; Has been assigned
	    CALL STADYN		; Get line's data block
	     TRNA		; ??  address
	      CALL TVTISP	; Get TTY input space
	ENDIF.

;Now have available input space, maybe zero

	LOAD T2,TRLWN,(TCB)	; Seq # of last receive-right reported
	IFGE. T2		; Is valid
	  LOAD T3,TRLFT,(TCB)	; Compute unused space from last window
	  SUB T2,T3
	  MODSEQ T2
	  CAIL T2,<.RTJST(-1,PIPL)> ;CAML T2,[MAXSEQ/2] ; Beware negative
	    SETZ T2,		; Window (transmitter sent too much)
	  JUMPLE T1,NUWND4	; No space, don't increase offered window
				; (but don't shrink it either)
	  MOVE T4,INXPB		; Estimated packet size
	  SUBI T4,MINIHS+MINTHS	; w/o minimal headers
	  JFCL ; LSH T4,1	; How optimistic are we??
	  CAIG T1,(T4)		; If user space is less
	    MOVE T1,T4		; Be optimistic
	  CAILE T1,<.RTJST(-1,PWNDO)> ; But not more so than
	    MOVX T1,<.RTJST(-1,PWNDO)> ; Size of window field
	  MOVE T3,T2		; Remaining space, last window
	  LSH T3,1		; Factor is 1/2
MNTM5<	  CAMG T3,T1>		; If remaining .gt. 1/2 actual
MNTM5	    AOS CELL(TCANW,1,,TCA) ; Window increases by NUWNDO
	  CAMLE T3,T1		; If remaining .gt. 1/2 actual
NUWND4:	    MOVE T1,T2		; Don't report it (no silly windows)
	ENDIF.
	STOR T1,TRWND,(TCB)	; Offered window space

;Check if sender should be notified of ACKed data or new window info

	LOAD T3,TRSYN,(TCB)	; Check connection state
	LOAD T4,TSSYN,(TCB)
	CAIE T4,SYNABL		; If send side doesn't have a seq #
	 CAIN T3,SYNABL		; or don't know foreign address
	  RET			; Cannot send a packet
	LOAD T4,TRLFT,(TCB)	; Current ACK point
	LOAD T3,TRLAK,(TCB)	; Last reported ACK point
	SUB T2,T1		; Non-zero if new window info
	CAMN T3,T4		; If new ACK point or
	 SKIPE T2		; New window space
	  CAIA			; Get packet sent
	   RET
MNTM5	AOS CELL(TCANW,2,,TCA)	; Encourages of PZ by NUWNDO
	CALLRET SKDACK		; To encourage PZ




;SKDACK	Schedule packetizer to get ack sent

SKDACK::
	LOAD T1,TRWND,(TCB)	; Offered window size
	CALL BYT2MS		; Bytes to msec at estimated baud rate

	IFQN. <TRXPN,TRXPD>,(TCB) ; Using static method
	  LOAD T2,TMNRT,(TCB)	; Estimated time
	ELSE.			; Using dynamic method
	  LOAD T2,TSMRT,(TCB)	; Estimated time
	ENDIF.
jfcl;	LSH T2,1		; Pause factor
	ADD T1,T2
jfcl;
	MOVE T1,TCPRA0		; Estimated time too long, get RXs
	CALLRET ENCPKT		; Get a packet sent in a bit


;TFRTST	Test to see if RECV data should be flushed (used by REASEM).

; if ((bit TSFR is on) and
;     (send state is NOTSYN) and
;     (the connection has been opened) and
;     (((not a tvt) and (RECV Q buffers are empty)) or
;      ((is a tvt) and (line number is 0))))
;  then RECV data should be flushed
;  else RECV data should NOT be flushed

;TCB/	Extended TCB pointer
;Returns: +1: RECV data should NOT be flushed
;	  +2: RECV data be flushed

TFRTST::			; Only global if two parts
	JE TSFR,(TCB),R		; Return if bit TSFR is off
	LOAD CX,TSSYN,(TCB)	; Get send state
	CAIE CX,NOTSYN		; Is it NOTSYN?
	IFSKP.			; Yes, AND
	  ANDQN. TSOPN,(TCB)	; Has it ever been open?
	    IFQN. TTVT,(TCB)	; Yes, Is it a TVT?
	      IFQE. TVTL,(TCB)	; Yes, Is it detached? (ie. Line = 0)
		RETSKP		; Yes, we pass
	      ENDIF.
	    ELSE.		; Not a TVT
	      IFQE. TRBS,(TCB)	; RECV Q buffer empty? (ie. Size = 0)
		RETSKP		; Yes, we pass
	      ENDIF.
	    ENDIF.
	ENDIF.
	RET			; Fail the test, return +1

;FLSRBF	Flush Receive Buffers.

;Called when aborting a connection by ABTCON or PZ

;TCB/	Extended Locked connection block
;T1/	Code (377B35) to be left in the buffer header for user to see
;ABTCON	ELT+^D04 (TVTs)
;ABTCON	EFP+^D07 (RST received)
;ABTCON	ELP+^D07 (@PZ with TSABT)
;PZ	XLP+^D12 (FIN received)
;ABTCON	ELP+^D14 (RX timeout)
;	CALL FLSRBF
;Ret+1:	Always.

FLSRBF:	SAVEAC <BFR>
	ACVAR <CODE,NBUF>
	MOVEM T1,CODE
MNTM5	AOS CELL(TCAFB,0,,TCA)	; FLSRBF calls
	SETZ NBUF,
	LOAD BFR,TRCB,(TCB)	; Get possible receive current buffer
	SETZRO TRCB,(TCB)	; It is now gone
	DO.
	  IFN. BFR		; Do we have a buffer here?
	    MOVE T1,CODE	; Yes.
	    LSH T1,^D<36-8>	; Position it in error byte
	    CALL USRBFF		; Tell user buffer "filled"
	    AOS NBUF
	  ENDIF.
	  XMOVEI CX,TCBRBQ(TCB)
	  LOAD T1,QNEXT,(CX)	; First thing on queue
	  CAMN T1,CX		; If it points at head of queue
	    EXIT.		; Means	 empty queue.  Done.
	  XMOVEI BFR,-BFRQ(T1)	; Point to top of structure
	  CALL DQ		; Dequeue the buffer
	  LOOP.
	ENDDO.

MNTM5	SKIPN NBUF
MNTM5	  AOS CELL(TCAFB,1,,TCA) ; FLSRBF flushed none
MNTM5<	ADDM NBUF,CELL(TCAFB,2,,TCA)> ; Buffers flushed by FLSRBF
	LOAD T2,TRBS,(TCB)	; Update receive window
	STOR T2,TRWND,(TCB)
	MOVE T1,NBUF		; Return # buffers flushed
	RET

	ENDAV.

;FLSRBX	Called when killing a fork to flush its receive Buffers.

;TCB/	Extended Locked connection block
;	CALL FLSRBX
;Ret+1:	always

FLSRBX::			; Flush receive buffers for current FORKX
	JN TDEC,(TCB),R		; Do not do this for DEC TCBs
	SAVEAC <BFR>		; Do not trash this AC
	ACVAR <NBUF,NXTQ>
MNTM5	AOS CELL(TCAFX,0,,TCA)	; FLSRBX calls
MNTM5<	SETZ NBUF,>
	LOAD BFR,TRCB,(TCB)	; Get possible current receive buffer
	IFN. BFR
	  LOAD T1,BFRKX,(BFR)	; Get the FORKX that owns this buffer
	  CAME T1,FORKX		; Is it us?
	  ANSKP.
	    SETZRO TRCB,(TCB)	; Yes, forget the current buffer
	    MOVX T1,<<ELP+^D07>B7> ; Error code for buffers
	    CALL USRBFF		; Indicate current buffer filled
MNTM5	    AOS NBUF
	ENDIF.
				; Here to loop through buffers for the TCB
	LOAD NXTQ,QNEXT,<+TCBRBQ(TCB)> ; Get the first queue entry
	DO.
	  MOVE T1,NXTQ
	  XMOVEI CX,TCBRBQ(TCB)
	  CAMN T1,CX		; If that is the head,
	    EXIT.		; All FORKX's buffers removed
	  LOAD NXTQ,QNEXT,(T1)	; Get next element
	  XMOVEI BFR,-BFRQ(T1)	; Point to top of structure
	  LOAD T2,BFRKX,(BFR)	; Get the FORKX that owns this buffer
	  CAME T2,FORKX		; Is it us?
	  IFSKP.
	    CALL DQ		; Yes, dequeue the buffer
	    MOVX T1,<<ELP+^D07>B7> ; Error code for buffers
	    CALL USRBFF		;Indicate the buffer is filled
MNTM5	    AOS NBUF
	  ENDIF.
	  LOOP.
	ENDDO.

MNTM5<	SKIPN T1,NBUF>
MNTM5	  AOS CELL(TCAFX,1,,TCA) ; FLSRBX flushed none
MNTM5<	ADDM T1,CELL(TCAFX,2,,TCA)> ; Buffers flushed by FLSRBX
	RET

	ENDAV.

	SUBTTL	TCP Packetizer

COMMENT !

The  PACKETIZER  is  called  with  TCB  setup  to point at a (locked)
connection block. It attempts  to  form  packets  from  data  in  any
buffers  which  are queued from the user SEND%s. If the "force packet"
bit is on, the PACKETIZER will always generate a packet containing an
ACK, even if there is no data to be sent. Packetizing continues until
no more is available from user buffers or until the send  window  has
been filled.

In  the  case  of  virtual  terminals  (TVTs) output is stored in TTY
buffers and TVTNOF is set to cause a scan by OPSCAN  which  forces  a
packet  on  TCBs which are TVTs. PZ runs with BFR set to 0 and BUFCNT
set to infinity in this case since it is not known how much output is
waiting to go and since the buffers are non-standard format.

!


;PKTIZE	TCP Packetizer.

;TCB/	Extended Pointer to connection block
;	CALL PKTIZE
;Ret+1:	Always

PKTIZE::			; Only global if two parts
MNTM5	AOS CELL(TCZPZ,0,,TCZ)	; PKTIZE calls

	IFQN. TSABT,(TCB)	; User requested ABORT%/CLZFF%/RESET%/LGOUT%?
MNTM5	  AOS CELL(TCZPZ,1,,TCZ) ; PKTIZE found TSABT set
	  RET
	ENDIF.

	IFQE. TSFP,(TCB)	; If not forcing...
	  ;; Short Blocked?
	  LOAD T1,TCPZT,(TCB)	; When short block time over (or 0)
	  CAMG T1,TODCLK	; Still short blocked?
	  IFSKP.		; Yes
	    SUB T1,TODCLK	; Interval
	    CAMGE T1,TPSB0	; Shorter than the minimum
	      MOVE T1,TPSB0	; Yes, use the minimum
	    CAMLE T1,TPSB0+1	; Longer than the maximum
	      MOVE T1,TPSB0+1	; Yes, use the maximum
MNTM5	    AOS CELL(TCZPD,0,,TCZ) ; PKTIZE short blocks
MNTM5<	    ADDM T1,CELL(TCZPD,1,,TCZ)> ; PKTIZE short block time
	    CALLRET DLAYPC	; Try again later
	  ENDIF.

	  ;; Source quenching?
	  LOAD T1,TCSQT,(TCB)	; When quench time will be over (or 0)
	  CAMG T1,TODCLK	; Still quenching?
	  IFSKP.		; Yes
	    LOAD T1,TRIS,(TCB)  ; Initial sequence
	    LOAD T2,TRLAK,(TCB)  ; Last ACKed
	    LOAD T3,TRLFT,(TCB)  ; Accepted
	    CALL CHKWND		; Anything accepted but not yet ACKed?
	    ANDE. T1		; Everything accepted has been ACKed
	      LOAD T1,TCSQT,(TCB)  ; When quench time will be over
	      SUB T1,TODCLK	; Interval until then
	      CAMGE T1,TPSQ0+1	; Shorter than the minimum
		MOVE T1,TPSQ0+1	; Yes, use the minimum
	      CAMLE T1,TPSQ0+2	; Longer than the maximum
		MOVE T1,TPSQ0+2	; Yes, use the maximum
MNTM5	      AOS CELL(TCZPD,2,,TCZ)  ; PKTIZE source quench
MNTM5<	      ADDM T1,CELL(TCZPD,3,,TCZ)>  ; PKTIZE source quench time
	      CALLRET DLAYPC	; Try again later
	  ENDIF.

	  ;; Encouraging a packet and the encourage time has past?
	  IFQN. TSEP,(TCB)	; If encouraging
	    LOAD T1,TSEPT,(TCB)	; Get Encourage time
	    SUB T1,TODCLK	; Msec before Encourage Time
	    CAIL T1,^D20	; Past due (or too soon to bother scheduling)?
	    ANSKP.		; Yes
	      SETONE TSFP,(TCB)	; Force a packet
;;MNTN5	      AOS (...)		; System wide count
;;	      INCRNO ...,(TCB)	; Count for the TCB
	  ENDIF.

	ENDIF.			; Proceed

	SAVEAC <PKT,TPKT,BFR>
	ACVAR <BUFCNT,XFRCNT,WNDSPC,LINBLK>
	SETO LINBLK,		; Assume not TVT (abort case)

PKTIZ0:
MNTM5<	LOAD T1,TSEP,(TCB)>	; Monitor flags
MNTM5<	LOAD T2,TSFP,(TCB)>
MNTM5	SKIPE T2
MNTM5	  AOS CELL(TCZPZ,2,,TCZ) ; PKTIZE forced
MNTM5	SKIPE T1
MNTM5	  AOS CELL(TCZPZ,3,,TCZ) ; PKTIZE encouraged
MNTM5<	ADD T1,T2>
MNTM5<	CAIN T1,2>
MNTM5	  AOS CELL(TCZPZ,4,,TCZ) ; PKTIZE forced+encouraged

;When the connection is first used, a send sequence number is obtained from
;the "Initial Sequence Number" curve (a function of the clock).

	LOAD T1,TSSYN,(TCB)	; Get send state
	CAIN T1,SYNABL		; SYNCABLE?
	  CALL SETISN		; Yes. Set initial sequence number

;If this is a TVT, there may be no buffer.
;Do the special things for this case.

	IFQN. TTVT,(TCB)	; If a TVT,
	  MOVX BUFCNT,177700	; Maybe lots of output to handle
	  LOAD T2,TVTL,(TCB)	; Get the line number
	  ANDN. T2		; Which has been assigned
	    CALL LCKTTY		; Lock TTY, trm blk address to T2 & NOINT
	      JUMPLE T2,PKTZ1C	; Can't.  Unlock but leave LINBLK -1
	    MOVEM T2,LINBLK	; Save the address
	    CALL TVSBE1		; CFOBF might have happened since OPSCAN
	      JRST PKTZ1E	; Chrs available. (Zero if ^S)
	    MOVE T2,LINBLK	; Restore line blk address
PKTZ1C:     CALL ULKTTY		; Decrease the lock count & OKINT
	ENDIF.
	SETO LINBLK,		; No terminal block to unlock later


;Top of main non-TVT loop

;Try to find a user buffer to send data from.  This could the the
;"send current buffer" which is left from a previous call or a
;buffer queued from user SEND%.  If there is no buffer, BFR is set
;to 0 as is the byte count.

PKTIZ1:	LOAD BFR,TSCB,(TCB)	; Get current send buffer if any
	JUMPN BFR,PKTIZ3	; Got one. Go set count.
	XMOVEI CX,TCBSBQ(TCB)
	LOAD T1,QNEXT,(CX)	; Get next thing on send buffer Q
	CAMN T1,CX		; Next differs from header
	IFSKP.			; Have a queued send buffer
	  XMOVEI BFR,-BFRQ(T1)	; Point to top of structure
	  CALL DQ		; Dequeue the buffer
	ELSE.
PKTZ1E:	  MOVX BFR,0		; 0 means no buffer
	ENDIF.
	STOR BFR,TSCB,(TCB)	; Remember as current buffer

;Top of main TVT loop

;If there is a current buffer, set BUFCNT from the sum of the buffers.
;If no current buffer, try for a TVT.  If neither, set BUFCNT to 0.

PKTIZ2:	IFE. BFR		; IF no buffer,
	  MOVX BUFCNT,0		; Count if not a TVT
	  IFGE. LINBLK		; Have TVT terminal block
	    MOVE T2,LINBLK	; Arg for TVTOSP
;cwl check +1 failure to get a character doesn't send garbage
	    CALL TVTOSP		; Get # characters waiting (maybe +1)
	    MOVE BUFCNT,T1	; May be zero
	    STOR T1,TSBYT,(TCB)	; Keep TSBYT up to date too
	  ENDIF.
	ELSE.
PKTIZ3:	  LOAD BUFCNT,TSBYT,(TCB) ; Get total (SEND%) queued byte count
	ENDIF.

PKTIZ4:	LOAD PKT,TSCPK,(TCB)	; May have partially filled packet
	IFN. PKT		; If so...
	  PNTLDR TPKT,PSSDT,(PKT)  ; Locate TCP header
	ENDIF.

	CALL PKTWND		; Get the Useable Window
	  JRST PKTIZX		; Rescheduled, exit the packetizer

	CALL PKTZSD		; Should we send the a packet?
	IFNSK.			; No
	  INCRNO TCPZA,(TCB)	; # times PKTIZE gave up for this connection
MNTM5	  AOS CELL(TCZPZ,7,,TCZ) ; # times PKTIZE gave up
MNTM5<	  IFQN. TTVT,(TCB)>	; If TVT, different statistics
MNTM5	    AOS CELL(TCZPZ,13,,TCZ) ; PKTIZE gave up on a TVT
MNTM5<	  ENDIF.>
	  JRST PKTIZX		; Quit, maybe reschedule
	ENDIF.

;Now the number of bytes available from the user buffer(s) is
;known and the apparent amount of useable window space is known.
;Set XFRCNT to the (maximum) amount which can actually be sent in this
;Packet.  In the case of a TVT, it is not known how much is available
;and we will assume a full packet (or window, etc) is to be sent.

PKTIZ7:	CAML BUFCNT,WNDSPC	; Min of octets available to be sent and
	 SKIPA XFRCNT,WNDSPC	; Space allowed to send into
	  MOVE XFRCNT,BUFCNT
	CAMLE XFRCNT,INXPB	; Limit (roughly) to what a
	  MOVE XFRCNT,INXPB	; Packet can hold.

;May have a current packet to continue filling

	IFN. PKT		; Have partially filled packet
	  LOAD T1,PMXSZ,(PKT)	; Packet's maximum packet length
	  LOAD T2,PIPL,(PKT)	; Packet's current length
	  SUB T1,T2		; Unused data space in pkt (NB in T1)
	  JUMPLE T1,PKTZ16	; Already full?? An inconsistancy, send it
	ELSE.			; Begin filling a new packet

;Try to assign a block of free storage for the packet to be sent.

	  LOAD T1,TSMXS,(TCB)	; Connection's biggest segment length
	  CAIL T1,<.RTJST(-1,TSMXS)> ; Specified yet?
	    MOVX T1,^D<576-40>	; No, use default
	  SETZ T2,		; Have a TCB
	  CALL TCPIPK		; Get packet & fill in headers, set T1/count
	  IFNSK.
	    INCRNO TCTBS,(TCB)	; Count no-core errors for connection
MNTM5	    AOS CELL(TCZPZ,15,,TCZ)  ; Count no-core errors for system
	    MOVX T1,^D2000	; Two seconds later,
	    CALL DLAYPC		; Try again (ignoring TSFP)
	    JRST PKTIZX		; Leave for now
	  ENDIF.

	  PUSH P,T1		; T1/ max data count, PMXSZ/ max PIPL

;Enter the send sequence for the connection as the sequence number
;of the packet.

	  LOAD T1,TSSEQ,(TCB)	; Current send sequence
	  STOR T1,PSEQ,(TPKT)	; Packet sequence number

;Send a SYN if connection is opening

	  LOAD T1,TSSYN,(TCB)	; Get send state
	  CAIN T1,SYNABL	; SYNCHABLE means we must tell other
	    CALL SNDSYN		; end our seq. num. by sending a SYN
				; PSYN to 1 & TSSYN to SYNSNT
	  POP P,T1		; Max # data octets
	ENDIF.			; Either old packet or new

;Copy data from the user buffer(s) (if any) to the packet.  XFRCNT has the
;maximum number of octets available, which may be 0.  T1 has unused octets
;in the packet.  Find how much can really be copied, given options & header.

PKTZ12:	CAMLE XFRCNT,T1		; Min against available data
	  MOVEI XFRCNT,(T1)	; Cannot send all the data in pkt
	MOVE T1,XFRCNT		; # of octets for SNDxxx

;Call appropriate data copy routine

	IFN. BFR		; If have a buffer,
	  CALL SNDDAT		; Copy data from user Buffer(s) to packet
	  STOR T2,PLBYT,(PKT)	; Last octet
	ELSE.			; Must be a TVT
	  SKIPGE T2,LINBLK	; Do we have a TVT terminal block?
	  IFSKP.		; Yes
	    CALL SNDTVT		; Send data from a virtual terminal
	    STOR T2,PLBYT,(PKT)	; Last octet
	    SETONE PPSH,(TPKT)	; Hussle up receiver
	    INCRNO TCSPU,(TCB)	; Count PUSHes for connection
	  ELSE.			; No terminal block ??
	    SETZ T1,		; Nothing to be sent
	  ENDIF.
	ENDIF.
	MOVEM T1,XFRCNT		; Save number actually sent
	ADDM T1,BYTSCT		; Count total bytes sent

	LOAD T1,PIPL,(PKT)	; Get previous packet length (b)
	ADD T1,XFRCNT		; Add # octets just inserted
	STOR T1,PIPL,(PKT)	; Update IP Packet Length

	LOAD T1,TSBYT,(TCB)	; Reduce queued octet count, too
	SUB T1,XFRCNT
	STOR T1,TSBYT,(TCB)

;Send a FIN if it is time.  User must have said CLOSE% (TSUOP
;bit is off), the send side must be synchronized, and there must be
;nothing waiting to be sent (no current send buffer and nothing Q'd)

	LOAD T1,TSSYN,(TCB)	; Get send state
	CAIE T1,SYNCED		; Connection synchronized?
	IFSKP.			; Yes, and
	ANDQE. TSUOP,(TCB)	; User has CLOSE%d the connection, and
	ANDQE. TSCB,(TCB)	; No current send Buffer, nor
	  XMOVEI CX,TCBSBQ(TCB)
	  LOAD T1,QNEXT,(CX)	; Get first thing in send Buffer queue
	  CAMN T1,CX		; Any queued send Buffers, then
	    CALL SNDFIN		; Include a FIN in this packet.
	ENDIF.		; PFIN is 1, TSSYN=FINSNT; if R=SYNCED, TSTMW=1

;Now all control and data have been stored in the packet.

PKTZ16:	CALL PKTEND		; Returns next seq num after this Pkt
	STOR T1,PESEQ,(PKT)	; Save computed end of packet

;If we are ACKing a remote FIN, the receive side becomes NOTSYNCHED.
;Queued RECV% buffers are returned with the CLOSING error. If a FIN
;is also being sent (entering LAST ACK state), force the packet out
;now; otherwise inform the user that the connection is CLOSING (if
;only the receive side is NOTSYN), or is CLOSED (both sides NOTSYN).
;If we are entering the TIME WAIT state, signal DY when it should end.

	LOAD T1,TRSYN,(TCB)	; Get receive state
	CAIE T1,FINRCV		; FINRECEIVED?
	IFSKP.
	  MOVX T1,NOTSYN
	  STOR T1,TRSYN,(TCB)	; Change to NOTSYNCHED
	  MOVX T1,XLP+^D12	; "Closing" code (Why not XFP+^D12??)
	  CALL FLSRBF		; Flush receive buffers with this code
	  LOAD T2,TSSYN,(TCB)	; Get send state
	  CAIN T2,FINSNT	; Sending a FIN now?
	    JRST PKTZ20		; Yes, force this packet out now. (LAST ACK)

	  MOVX T1,XFP+^D12	; Assume "Closing"
	  CAIN T2,NOTSYN	; Send side already closed?
	    MOVX T1,XLP+^D3	; Yes, "Closed" event
	  CALL USREVT		; State-change interrupt - connection closed

	  LOAD T2,TSSYN,(TCB)	; Get send state
	  CAIE T2,NOTSYN	; Send side already closed?
	  ANSKP.
	    MOVX T1,TIMWAT	; Yes, begin Time-Wait
	    STOR T1,TRSYN,(TCB)
	    SETZRO TSTMW,(TCB)
	    XMOVEI T1,DY
	    MOVE T2,TPMSL	; Maximum segment lifetime
	    CALL SIGNAL
	    SETZRO TSTMW,(TCB)	; Have entered TIME WAIT.
	ENDIF.

;Decide whether to wait for more data or send what packet now holds

PKTZ19:	CALL PKTZHD		; Want to hold packet?
	IFSKP.			; Yes
	  STOR PKT,TSCPK,(TCB)	; Then hold packet for a while
jfcl;;	  SETZRO <TSFP,TSEP>,(TCB) ; Clear signals
jfcl;;
MNTM5	  AOS CELL(TCZPZ,10,,TCZ) ; PKTIZE held a packet for more data
	  JRST PKTZ24		; Go look for more data to be sent
	ENDIF.

;Packet will be sent now, finish it off

PKTZ20:	SETZRO TSCPK,(TCB)	; No saved packet
	SETZRO <TSFP,TSEP>,(TCB) ; Clear signals

;Advance the send sequence in the TCB to include all of this packet.

	LOAD T1,PESEQ,(PKT)	; Packet end sequence becomes
	STOR T1,TSSEQ,(TCB)	; New send sequence

	IFQN. PSYN,(TPKT)	; If first packet on connection
	  LOAD T2,TSLFT,(TCB)	; Get send left
	  SUB T1,T2		; Compute amount of window taken by this
	  MODSEQ T1		; first Pkt.
	  STOR T1,TSWND,(TCB)	; And prevent further sends until window
				; info arrives from other end.
	  MOVE T2,TODCLK
	  SKIPN T1		; If window is closed
	    ADD T2,TVTWTM	; Delay a little
	  STOR T2,TSPRB,(TCB)	; Set time of first probe
	ENDIF.
	CALL NULPKT		; See if anything retransmittable here
	SETCA T1,		; Get sense right
	STOR T1,PPROG,(PKT)	; Say program must retain the packet
	CALL SETRXP		; Setup packet rexmit parameters

;Done filling the packet.

;Probably obsolete
;If running in  secure mode and this packet has something which will be
;acknowledged, make the current level be the next level so as to shut
;off subsequent connection change request options to the KDC.

	IFQN. PPROG,(PKT)	; See if pkt will be ACK'd
	  LOAD T2,TSLVN,(TCB)	; Guaranteed that KDC will here the word
	  STOR T3,TSLVC,(TCB)	; So update the current level
	ENDIF.



PKTZ22:	LOAD T1,PPROG,(PKT)	; Save flag for later test
	PUSH P,T1		; PKT may vanish if error in EMTPKT (SNDGAT)

	AOS PZPKCT		; Count Packetizer packets

	MOVX T1,PT%TPZ		; Packet formed by packetizer
	TXNN FR,1B0		; TCB trace or
	 TDNE T1,MNTRAC		; Want trace?
	  CALL PRNPKT		; Yes

;Do statistics functions

	XMOVEI T1,OPDLAY	; Select the output processor delay histogram
	CALL TSTAMP		; Process/update the time stamp
	SKIPN STATF		; Taking statistics right now?
	IFSKP.			; Yes
	  XMOVEI T1,OP+PRCTMR	; Charge time to Output Processor
	  XMOVEI T2,EMTPKT	; for call to EmitPacket
	  MOVE T3,LINBLK	; TVT block if any
	  CALL TIMCAL		; Do a timed call.
	ELSE.			; No
	  MOVE T1,LINBLK	; TVT block if any
	  CALL EMTPKT		; EmitPacket
	ENDIF.

;Process error code here ...

	INCRNO TCSPC,(TCB)	; Count packets sent for connection
MNTM5	AOS CELL(TCZPZ,11,,TCZ)	; PKTIZE emitted packet


	POP P,T1		; Saved PPROG tells if PKT needed RX
	IFN. T1
	  MOVX T1,PT%TQX	; Queued for retransmitter(unless error)
	  TXNN FR,1B0		; TCB trace or
	   TDNE T1,MNTRAC	; Want trace?
	    CALL PRNPKT		; Yes
	  SKIPN T1,PKT		; What to Enqueue (if there wasn't an error)
	  ANSKP.		; Unless error in EMTPKT/SNDGAT
				; (ought to do something, ICMP ??)
IFN PKTQ,<  XMOVEI T1,PKTQ(T1)>	; Point at queue head
	    XMOVEI T2,TCBRXQ(TCB) ; Pointer to the retransmit queue
	    CALL NQ		; Enqueue it there
	    XMOVEI T1,RX	; Select the Retransmitter
	    LOAD T2,PRXI,(PKT)	; Retransmission interval
	    MOVE T4,T2
	    ADD T4,TODCLK	; Time of next run
	    SKIPE TCQRX(TCB)	; Not queued, or ...
	     CAMG T4,TCTRX(TCB)	; Need it sooner than scheduled?
	      CALL SIGNAL;(T1,T2) ; Cause RX to run after that time
	ENDIF.

	;; Compute the next time the pipe will be empty (flow control)
	;; This time will be the next time that we think that we will
	;; be able to send a packet.  Compute as follows:
	;; Pipe Empty Time = 
	;;  TODCLK + ((PIPL*1000)/(TSMXB/^D8)) - (TSMRT-(TSMRT/TCSMO*2))
	;; N.B. Pipe Emtpy Time really means the next time we can send
	;;  a packet based on our baud rate, the maximum number of
	;;  outstanding packets, and the round trip time.
	LOAD T1,PIPL,(PKT)	; Get packet length in bytes
	IMULI T1,^D8000		; Times 1000msec/sec * 8bits/byte
	LOAD T2,TSMXB,(TCB)	; Get send baud rate in bits/sec
	IDIV T1,T2		; Compute milliseconds for this packet
	LOAD T2,TSMRT,(TCB)	; Get the RTT
	LOAD T3,TCSMO,(TCB)	; Get the Maximum Outstanding Packets
	SKIPG T3		; Positive values only
	  MOVX T3,1		; Use 1 if .LE. 0
	LSH T3,1		; Times 2
	IDIV T2,T3		; Compute 1/2 RTT per Outstanding Packet
	LOAD T3,TSMRT,(TCB)	; Get the RTT again
	SUB T3,T2		; Compute RTT minus 1/2 RTT per Out. Pkt.
	SUBB T1,T3		; Interval when time to send is OK
	ADD T1,TODCLK		; Time in the future
	SKIPLE T3		; Make sure in future
	  STOR T1,TSPET,(TCB)	; is the Pipe Empty Time

;See if Packetizer should continue running to form another packet for this
;connection.  This is true if there is something waiting to be sent and
;there is still window space in which to send it.

PKTZ24:	IFQN. TTVT,(TCB)	; TVT
	  ;; TVT check
	  SETZ T1,		; Assume LINBLK is -1
	  SKIPLE T2,LINBLK	; Pointer to dynamic area
;cwl check +1 failure to get a character doesn't send garbage
	    CALL TVTOSP		; Get # characters waiting (maybe +1)
	  STOR T1,TSBYT,(TCB)
	  JUMPE T1,PKTIZX	; None right now.
	  CAMLE WNDSPC,XFRCNT	; If there is still unused window space
	  IFSKP.
MNTM5	    AOS CELL(TCZPZ,12,,TCZ) ; PKTIZE filled TVT window
	  ELSE.			; One more check
	    LOAD T1,QCNT,+TCBRXQ(TCB)  ; Get RX queue current length
	    LOAD T2,TCSMO,(TCB)	; Get maximum outstanding RX packets
	    CAMGE T1,T2		; About to exceed the limit?
	      JRST PKTIZ2	; No, go try for it
	    MOVE T1,TPPZ0	; Yes, wait
	    CALL DLAYPC		; Try again later
MNTM5	    AOS CELL(TCZPZ,16,,TCZ) ; PKTIZE stopped, RX queue too long
	  ENDIF.		; Don't need to reschedule - OPSCAN will do
				; it if TTY output buffer isn't empty.
	ELSE.			; Not a TVT
	  ;; Non-TVT checks
	  CAMLE WNDSPC,XFRCNT	; Is there some unused window space?
	  IFSKP.		; No
MNTM5	    AOS CELL(TCZPZ,14,,TCZ) ; PKTIZE filled non-tvt window
	    MOVE T1,TVTWTM	; After this number of milliseconds
	    CALL DLAYPZ		; Try again, may have to probe
	  ELSE.			; Have more window space
	    IFQE. TSCB,(TCB)	; No current buffer
	      XMOVEI CX,TCBSBQ(TCB)
	      LOAD T1,QNEXT,(CX) ; Send buffer queue
	      CAME T1,CX	; Empty?
	      ANSKP.		; Yes.
				; Nothing to send.  Return.
	    ELSE.		; Have window space and unsent buffers
	      LOAD T1,QCNT,+TCBRXQ(TCB)	; Get RX queue current length
	      LOAD T2,TCSMO,(TCB) ; Get maximum outstanding RX packets
	      CAMGE T1,T2	; About to exceed the limit?
	        JRST PKTIZ1	; No, loop back for another packet
	      MOVE T1,TPPZ0	; Yes, wait
	      CALL DLAYPC	; Try again later
MNTM5	      AOS CELL(TCZPZ,16,,TCZ) ; PKTIZE stopped, RX queue too long
	    ENDIF.		; Of send buffer
	  ENDIF.		; Of window space or not
	ENDIF.			; Of TVT or not

PKTIZX:	;; Return from the Packetizer

;If still in encourage mode, make sure that packetizer is scheduled no
;later than the encourage time, TSEPT; beware times in the past

	IFQN. TSEP,(TCB)	; If still have to encourage
	  LOAD T1,TSEPT,(TCB)	; When need to have packet sent
	  MOVX T2,.INFIN	; Maybe PZ is not scheduled
	  SKIPE TCQPZ(TCB)	; Scheduled?
	    MOVE T2,TCTPZ(TCB)	; Yes, get scheduled time
	  CAML T1,T2		; Need encourage before that?
	  ANSKP.		; Yes
;cwl count
	    SUB T1,TODCLK	; Msec remaining
	    CALL DLAYPC		; Schedule PZ (ignoring TSFP)
	ENDIF.

	SKIPL T2,LINBLK		; Have a TVT line locked?
	  CALL ULKTTY		; Yes.  Unlock it.
	RET

;PKTWND
;Packetizer Get Usable Window
;Call:	TCB/ TCB address
;	PKT/ Current packet or 0 if none
;	CALL PKTWND
;Returns: +1: Packetizer rescheduled
;	  +2: WNDSPC set to useable window space

PKTWND:
	;; Get actual window space available as provided by the remote end.
	LOAD T3,TSWND,(TCB)	; Send Window offered
	IFQN. TDBGQ,(TCB)	; Unless faking zero send window,
	  SETZ T3,		; Whereupon it is zero
	ENDIF.

	SETZ WNDSPC,		; Assume no useable window space

	;; If we are source quenching and not forcing, then reschedule
	;; If we are source quenching and forcing, then use a 0 window
	LOAD T1,TCSQT,(TCB)	; When quench time over
	CAMG T1,TODCLK		; Still quenching?
	IFSKP.			; Yes
	  IFQN. TSFP,(TCB)	; If we are forcing
	    JRST PKTWNX		; Make useable window 0, Exit
	  ENDIF.
	  SUB T1,TODCLK		; Interval until quench time will be over
	  CAMGE T1,TPSQ0+1	; Shorter than the minimum
	    MOVE T1,TPSQ0+1	; Yes, use the minimum
	  CAMLE T1,TPSQ0+2	; Longer than the maximum
	    MOVE T1,TPSQ0+2	; Yes, use the maximum
MNTM5	  AOS CELL(TCZPD,2,,TCZ)  ; PKTIZE source quench
MNTM5<	  ADDM T1,CELL(TCZPD,3,,TCZ)>  ; PKTIZE source quench time
	  CALLRET DLAYPC	; Check back then, return
	ENDIF.

	;; If cannot send data but have to ACK, use 0 window
	LOAD T1,TSSYN,(TCB)	; Send state
	LOAD T2,TRSYN,(TCB)	; Receive state
	CAIE T1,SYNABL		; If send side is SYNABL or
	 CAIN T2,SYNABL		; Recv side is SYNABL then
	  JRST PKTWNX		; Make useable window 0, Exit

	;; If we are not forcing and the pipe is not empty, reschedule
	IFQE. TSFP,(TCB)	; Not forcing
	  LOAD T1,TSPET,(TCB)	; Get the pipe empty time
	  CAMG T1,TODCLK	; Can we send another (flow control)?
	  ANSKP.		; No, reschedule
	    SUB T1,TODCLK	; Interval until we can send next
MNTM5	    AOS CELL(TCZPD,6,,TCZ)  ; PKITZE Pipe not empty
MNTM5<	    ADDM T1,CELL(TCZPD,7,,TCZ)>	; PKTIZE Pipe not empty time
	    CALLRET DLAYPC	; Check back then, return
	ENDIF.


	;; Compute useable window space =
	;;	TSLFT+TSWND-last packetized (TSSEQ or PESEQ)
	LOAD T1,TSLFT,(TCB)	; Send Left
	LOAD T2,TSSEQ,(TCB)	; Send Sequence if no partial packet
	SKIPE PKT		; or
	  LOAD T2,PESEQ,(PKT)	; Packet end sequence if partial packet
	ADD T1,T3		; Compute Send Right
	SUB T1,T2		; Minus Sequence
	MODSEQ T1		; Keep within right number of bits
	CAML T1,[MAXSEQ/2]	; If window space is .lt. 0 then
	  JRST PKTWNX		;  use 0 window, Exit
	MOVEM T1,WNDSPC		; Amount of useable window space

	;; If not forcing and not a partial packet, Reduce "silly window"
	IFQE. TSFP,(TCB)	; If not forcing
	ANDE. PKT		; and no partial packet...
	  LOAD T2,TSMXS,(TCB)	; Max segment size
	  CAIL T1,(T2)		; If window is as large as a packet, use it
	  IFSKP.		; Otherwise,
	    ;; Use 0 if available less than 1/4 offered
	    LOAD T4,TSBFP,(TCB)	; Number of unpacketized buffers with PUSH
	    LSH T1,2		; 4*Useable
	    CAMGE T1,T3		; If Useable/Offered .lt. 1/4, and
	     SKIPE T4		; No unsent PUSHes,
	    ANSKP.
	      SETZ WNDSPC,	; Make useable window 0
	  ENDIF.
	ENDIF.

PKTWNX:	;; Exit PKTWND
	IFE. WNDSPC		; Count times window was full
MNTM5	  AOS CELL(TCZPZ,5,,TCZ) ; PKTIZE zero windows
MNTM5	  SKIPE T3		; Offered window space?
MNTM5	    AOS CELL(TCZPZ,6,,TCZ) ; PKTIZE forced-to-zero windows
	  INCRNO TCFWN,(TCB)	; Times window full for connection
	  LOAD T4,TCFWT,(TCB)	; Total time window closed
	  IFGE. T4		; Was open
	    SUB T4,TODCLK	; Time it closed
	    STOR T4,TCFWT,(TCB)	; Start accumulating more
	  ENDIF.
	ENDIF.

	RETSKP			;Success, skip return

; Decide if we should try to send a packet
; Call: TPKT/ Pointer to TCP header
;	PKT/ Pointer to Packet
;	TCB/ Pointer to locked extended TCB
;	WNDSPC/ Amount of useable window space, maybe 0
;	BUFCNT/ Amount of data that can be sent, maybe 0
; Returns: +1: if the packet can not be sent
;	   +2: if the packet can be sent

PKTZSD:	IFQE. TSFP,(TCB)	; If don't have to send a packet, and
	  IFG. WNDSPC		; We have window space and
	    IFG. BUFCNT		; Data to send
	      RETSKP		; We should send the packet
	    ELSE.
	      IFN. PKT		; Do we have a current packet
	      ANDQN. <PPSH>,(TPKT)  ; that has a push in it?
		RETSKP		; Yes, Packet should be sent
	      ENDIF.
	    ENDIF.
	  ENDIF.
	  RET			; No data, no window or no current
				;  packet with a push, don't send
	ENDIF.			; Forcing
	RETSKP			; Packet should be sent

; Decide if current packet should be held for more data
; Call: TPKT/ Pointer to TCP header
;	PKT/ Pointer to Packet
;	TCB/ Pointer to locked extended TCB
; Returns: +1: if the packet can be sent
;	   +2: if the packet should be held for more data

PKTZHD:	IFQE. TSFP,(TCB)	; If are not in force packet mode, and
;; ;cwl loose push - pkt is held due to full rx queue, but when it becomes
;; ;not-full, pz doesn't notice it has a current packet with a push which
;; ;should be sent
;;	andqe. <psyn,pfin,ppsh>,(tpkt) ; temp push overrides full rx queue
	ANDQE. <PSYN,PFIN>,(TPKT) ; Packet doesn't contain controls,
	  LOAD T1,QCNT,+TCBRXQ(TCB)  ; Get RX queue current length
	  LOAD T2,TCSMO,(TCB)	; Get maximum outstanding RX packets
	  CAMGE T1,T2		; About to exceed the limit?
	  IFSKP.
;;MNTM5	    AOS (...)		; System wide count
;;	    INCRNO ...,(TCB)	; Count fo the TCB
	    RETSKP		; RX queue full, hold packet a while
	  ENDIF.

	  ANDQE. PPSH,(TPKT)	; Push means send it now

	    LOAD T1,PIPL,(PKT)	; Current PIPL
	    LOAD T2,PMXSZ,(PKT)	; Max PIPL
	    CAMLE T2,T1		; If packet is not full and 
	     CAML XFRCNT,WNDSPC	; Transfer count didn't fill window
	    ANSKP.		; Packet not full, window not full
	      RETSKP		; Hold it for more
	ENDIF.
	RET			; Send packet now

	ENDAV.			; End the ACVAR at start of PKTIZE:

;SETISN	Set Initial Sequence Number for a connection.
;SETIS1	Sets default initial send window.

;TCB/	Extended Locked connection block
;	CALL SETISN
;Ret+1:	always

SETISN:
MNTM5	AOS CELL(TCZAA,1,,TCZ)	; SETISN calls
	IFQE. TSSV,(TCB)	; If send sequence isn't valid,
	  CALL GETISN		; Get current value of ISN curve
	  STOR T1,TSSEQ,(TCB)	; Store as current send sequence
	  SETONE TSSV,(TCB)	; Indicate sequence is now valid
	ENDIF.
	LOAD T1,TSSEQ,(TCB)
	STOR T1,TSLFT,(TCB)	; Move Send Left up to Sequence
	STOR T1,TSIS,(TCB)	; Record initial value
	RET			; Wait for window

;SNDSYN	Include a SYN bit and possibly a segment size option in the packet.

;TCB/	Extended Current locked connection block
;PKT/	Extended Packet
;TPKT/	Extended pointer to TCP header
;	CALL SNDSYN
;Ret+1:	Always.

SNDSYN:
MNTM5	AOS CELL(TCZAA,2,,TCZ)	; SYDSYN calls
	SETONE PSYN,(TPKT)	; Set the SYN bit in the packet
	SETONE PLBYT,(PKT)	; No octet there
	LOAD T1,TSSYN,(TCB)	; Get send state
	CAIE T1,SYNABLE		; SYNCABLE (ie, opening)
	IFSKP.
	  MOVX T2,SYNSNT
	  STOR T2,TSSYN,(TCB)	; Yes. Change to SYNSENT state.

	  LOAD T2,TCATM,(TCB)	; Time of first packet
	  ANDE. T2
	    MOVE T2,TODCLK	; First packet received
	    STOR T2,TCATM,(TCB)	; Set time
	ENDIF.
	AOS SYNSCT		; Count SYNs sent

	CALL SNDOMZ		; Send optimization option
	CALLRET SNDMSL		; Maybe include segment size option

;SNDDAT Move data from user buffer(s) to a (partially filled) packet.
;All options must be in the Packet at the time this is called.

;TCB/	Extended Locked connection block
;PKT/	Extended Packet
;TPKT/	Extended pointer to TCP header
;BFR/	Extended Buffer header address (of first buffer)
;T1/	Number of bytes to move (maybe 0).
;	CALL SNDDAT
;Ret+1:	Always. T1 has number actually transferred, T2/ last octet or -1

SNDDAT:	ACVAR <CPYCNT,XFRCNT,PKTPTR,LSTBYT>
	MOVEM T1,XFRCNT		; Set up the transfer count
MNTM5	AOS CELL(TCZSD,0,,TCZ)	; SNDDAT calls
	SETZ CPYCNT,
	SETO LSTBYT,
	LOAD PKTPTR,PIPL,(PKT)	; Current packet length is next byte to insert
	ADJBP PKTPTR,[POINT 8,PKTELI(PKT)] ; Byte pointer there
	LOAD T1,BTS,(BFR)	; Get the buffer time stamp
	STOR T1,PTS,(PKT)	; and make that the Packet time stamp

;Top of per-user buffer loop

SNDDA1:
MNTM5	AOS CELL(TCZSD,1,,TCZ)	; Loops in SNDDAT
	SETZ T1,		; Request data mapping
	CALL SETTUM		; Set internet's user map (NOSKED)
	LOAD T4,BCNT,(BFR)	; Available bytes in user buffer
	MOVE T3,T4
	CAILE T3,(XFRCNT)	; Min'ed with remaining space in packet
	  MOVE T3,XFRCNT
	SUB XFRCNT,T3		; Bytes to transfer from next buffer
	SUB T4,T3		; Bytes remaining in user buffer
	STOR T4,BCNT,(BFR)
	ADDM T3,CPYCNT		; Total bytes transferred so far
	LOAD T1,BPTR,(BFR)	; Source is buffer ptr (mapped into mon)
	MOVE T2,PKTPTR		; Destination is packet pointer
	SETO T4,		; Indicate User-to-monitor
	CALL XFRDAT		; Do the data transfer
	MOVEM T2,PKTPTR		; Store updated infomation
	STOR T1,BPTR,(BFR)
	LDB LSTBYT,T2		; Get last octet
	CALL USTTUM		; Unmap user space (OKSKED)

;Stop if more remains in user buffer (should have reached end of count)

	JN BCNT,(BFR),SNDDAX	; More remains in buffer, wait for next pkt

;Finished with this buffer, transfer PUSH if present

MNTM5	AOS CELL(TCZSD,2,,TCZ)	; Buffers emptied by SNDDAT
	SETZRO TSCB,(TCB)	; Done with this buffer
	JE BPSH,(BFR),SNDDA5	; Jump if no PUSH in the buffer
	SETONE PPSH,(TPKT)	; Set packet PUSH
	INCRNO TCSPU,(TCB)	; Count PUSHes for connection
SNDDA5:

	XMOVEI T1,PZDLAY	; Select the packetizer delay histogram
	CALL TSTAMP		; Process/update the timestamp

	MOVX T1,<<OK>B7>	; The general success event code
	CALL USRBFE		; Tell user his send buffer is empty

;Stop if transferred full count

	JUMPLE XFRCNT,SNDDAX	; Pkt filled so quit

;Setup for next user buffer

	XMOVEI CX,TCBSBQ(TCB)
	LOAD T1,QNEXT,(CX)	; Get next thing on send buf Q
	CAMN T1,CX		; Next points at header ...
	  JRST SNDDAW		; means empty.  Something is wrong...stop
	XMOVEI BFR,-BFRQ(T1)	; And setup the standard pointer.
	CALL DQ			; Dequeue the buffer
	STOR BFR,TSCB,(TCB)	; Remember as current buffer
	JRST SNDDA1		; Go to work on this buffer

SNDDAW:
MNTM5	AOSA CELL(TCZSD,4,,TCZ)	; SNDDAT terminations - no buffers
SNDDAX:
MNTM5	  AOS CELL(TCZSD,3,,TCZ) ; SNDDAT terminations - full packet
	MOVE T1,CPYCNT		; Return bytes actually transferred
	MOVE T2,LSTBYT		; Last byte transferred
	RET

	ENDAV.

;SNDFIN	Send a FIN in this packet.

;TCB/	Extended Locked connection block
;PKT/	Extended Packet
;TPKT/	Extended pointer to TCP header
;	CALL SNDFIN
;Ret+1:	Always.

SNDFIN:
MNTM5	AOS CELL(TCZSF,0,,TCZ)	; SNDFIN calls
	SETONE PFIN,(TPKT)	; Set FIN bit in the packet
	SETONE PLBYT,(PKT)	; No octet there
	MOVX T1,FINSNT		; New send state
	STOR T1,TSSYN,(TCB)	; Set it.
	AOS FINSCT		; Count FINs sent

	LOAD T1,TRSYN,(TCB)	; Get receive state
	CAIE T1,SYNCED		; Is it still synced?
	  JRST SNDFI1		; No
	SETONE TSTMW,(TCB)	; Yes, remember need TIME WAIT state.
MNTM5	AOS CELL(TCZSF,1,,TCZ)	; Count times SNDFIN requested TIME WAIT state.
SNDFI1:	RET


;EMTPKT	Emit a packet into a network.

;TCB/	Extended Locked connection block
;PKT/	Extended Packet, NB: It may be invalid on return from SNDGAT
;TPKT/	Extended pointer to TCP header
;T1/WHY?	Pointer to dynamic data if TVT w/ output data, or -1

EMTPKT::			; Only global if two parts
	ACVAR <LINBLK>
	MOVEM T1,LINBLK		; Save TTYSRV line block if any
MNTM5	AOS CELL(TCZEM,0,,TCZ)	; EMTPKT calls
	JN PINTL,(PKT),EMTPKX	; Already in use by interrupt level
				; (Retransmit while net is off or slow)

	LOAD T3,TRWND,(TCB)	; Offered window size
	IFQN. TDBGW,(TCB)	; Want to fake a zero window?
	  SETZ T3,		; Yes
	ELSE.			; No, See if we should shut it
	  LOAD T1,QCNT,+TCBRPQ(TCB)  ; Get recv. pkt. queue length
	  LOAD T2,TCRMW,(TCB)	; Get the maximum for this TCB
	  CAMG T1,T2		; Exceed the limit?
	  IFSKP.		; Yes
	  ANDG. T1		; Guard against 0 queue lengths
	    LOAD T1,QNEXT,+TCBRPQ(TCB)	; Get the next in the q
	    PNTLDR T1,PSSDT,-PKTQ(T1)  ; Point to the session data
	    LOAD T3,PSEQ,(T1)	; Get the sequence number
	    LOAD T2,TRLFT,(TCB)	; Get receive left
	    SUB T3,T2		; Difference
	    MODSEQ T3		; 32 bits only
	    CAML T3,[MAXSEQ/2]	; If .lt. 0 then
	      SETZ T3,		; use 0
	    CAILE T3,<.RTJST(-1,PWNDO)>	 ; If .gt. 2**16-1 then
	      MOVX T3,<.RTJST(-1,PWNDO)>  ; use 2**16-1
	  ENDIF.
	ENDIF.
	STOR T3,PWNDO,(TPKT)	; Offered window size into packet

	LOAD T4,TRSYN,(TCB)	; Get receive state
	CAIN T4,SYNABLE		; SYNCABLE?
	IFSKP.			; No, can send an ACK

;Insert ACK (T3/ offered window)

	  SETONE PACK,(TPKT)	; Set the packet ACK bit
	  LOAD T1,TRLFT,(TCB)	; Receive Left is what we want to hear next
	  STOR T1,PACKS,(TPKT)	; ACK that
	  STOR T1,TRLAK,(TCB)	; Sending an ACK

;Compute receive window (T1/ PACKS, T3/ offered window)

	  CAIE T4,FINRCV	; If received FIN, or
	   CAIN T4,TIMWAT	; In TIME-WAIT, or
	    SETZ T3,		; Offered window is zero
	  CAIN T4,NOTSYN	; Already closed
	    SETZ T3,		; Leave window zero
	  ADD T1,T3		; PACKS plus offered window is
	  MODSEQ T1		; Receive-right
	  STOR T1,TRLWN,(TCB)	; Last offered

;Insert receive window

	  STOR T3,PWNDO,(TPKT)	; Offered window size into packet

;Set urgent if required

	  ANDQN. TSURG,(TCB)	; In urgent send mode
	    LOAD T1,TSLFT,(TCB)
	    LOAD T2,PSEQ,(TPKT)	; Check if this packet begins left of urgent
	    LOAD T3,TSURP,(TCB)
	    ADDI T3,1
	    MODSEQ T3
	    CALL CHKWND
	    IFN. T1		; If so, compute offset from PSEQ
	      LOAD T1,TSURP,(TCB) ; End of urgent data
	      LOAD T2,PSEQ,(TPKT) ; Sequence number of this packet
	      SUB T1,T2
	      MODSEQ T1		; Shouldn't be needed
	      CAILE T1,<PURGP/<PURGP&<-PURGP>>> ; Limit to field size
	        MOVX T1,<PURGP/<PURGP&<-PURGP>>>
	      STOR T1,PURGP,(TPKT) ; Set urgent offset into packet
	      SETONE PURG,(TPKT) ; Set the control bit
MNTM5	      AOS CELL(TCZEM,2,,TCZ)	; EMTPKT calls that set urgent
	      INCRNO TCSUR,(TCB) ; Count urgents sent for connection
	    ENDIF.
	ENDIF.

; Optimizations ...

	IFQE. PURG,(TPKT)	; If urgent field wasn't used  and
	  MOVX CX,TCS%O1	; Get enable optimization bit
	  TDNN CX,TCPSW		; On in the TCP switches
jfcl;	  ANSKP.		; Yes
	    IFQE. PRXD,(PKT)	; Any RX yet?
	      SETZRO PO1RX,(TPKT) ; No, zero number of RXs
	    ELSE.
	      INCRNO PO1RX,(TPKT) ;Yes, increment
	    ENDIF.

	    LOAD CX,TRLRX,(TCB)	; Get last RX seq num
	    STOR CX,PO1AK,(TPKT) ; Save it
	    IFQE. TRLST,(TCB)
	      SETZRO PO1LS,(TPKT)
	    ELSE.
	      LOAD T1,TRLST,(TCB)
	      LOAD T2,TRLFT,(TCB)
	      SUB T1,T2
	      MODSEQ T1
	      CAIL T1,<.RTJST(-1,PO1LS)>
	        MOVX T1,<.RTJST(-1,PO1LS)>
	      STOR T1,PO1LS,(TPKT)
	    ENDIF.
	ENDIF.

;Insert TCP checksum

	SETZRO PTCKS,(TPKT)	; Clear the check sum field
	CALL TCPCKS		; Compute the packet checksum and
	STOR T1,PTCKS,(TPKT)	; Enter it in the packet

	LOAD T1,TTTL,(TCB)	; Reset Time to Live
	STOR T1,PITTL,(PKT)

	LOAD T1,PIPL,(PKT)	; IP length
	STOR T1,PTPBZ,(PKT)	; Transport level length
	XMOVEI T2,PKTELI(PKT)
	STOR T2,PTPDT,(PKT)	; Address of transport level leader
	LOAD T2,PIDO,(PKT)	; Transport level leader length, words
	LSH T2,2		; Bytes
	SUB T1,T2
	STOR T1,PSSBZ,(PKT)	; Session level length
	STOR TPKT,PSSDT,(PKT)	; Address of session level leader
	LOAD T2,PTDO,(TPKT)	; Session level leader length, words
	MOVE T3,TPKT
	ADD T3,T2
	LSH T2,2		; Bytes
	SUB T1,T2
	STOR T1,PAPBZ,(PKT)	; Application level length
	STOR T3,PAPDT,(PKT)	; Address of application level data

;Log packet

	MOVX T1,1
	TXNE FR,1B0		; Trace?
	  STOR T1,PTRAC,(PKT)	; Yes flag packet	

	MOVX T1,PT%TTR		; Being transmitted
	TXNN FR,1B0		; TCB trace or
	 TDNE T1,MNTRAC		; Want trace?
	  CALL PRNPKT		; Yes
				; NB: this is deliberately after trace
	IFQE. PRXD,(PKT)	; If first transmission
	  MOVE T1,TODCLK	; Current millisecond number
	  STOR T1,PXT,(PKT)	; Store as time of most recent transmit
	ENDIF.

	LOAD T1,TSFHOP,(TCB)	; Special first-hop routing
	CALL SNDGAT		; Send it
				; If all ok, T2 has short-block time, msec
	STOR T1,PHINT,(PKT)	; Record transmission error code
	SUBI T1,MNTX00		; All ok?
	IFN. T1			; No (T2 not valid)
	  HRRZ T2,T1
	  CAILE T2,MNTX34-MNTX00 ; Defined code?
	    MOVX T2,MNTX34-MNTX00 ; No, treat as Unspecified error
	  MOVE T2,BITS(T2)	; Get bit corresponding to error
	  TXZN T1,NE%DRP	; Packet dropped?
	  IFSKP.		; Yes
.FATAL==1B<MNTX03-MNTX00>	; Error in protocol header
.FATAL==.FATAL+1B<MNTX06-MNTX00> ; Host down
.FATAL==.FATAL+1B<MNTX07-MNTX00> ; Host unknown
.FATAL==.FATAL+1B<MNTX11-MNTX00> ; Interface to local network down
.FATAL==.FATAL+1B<MNTX16-MNTX00> ; Network down
.FATAL==.FATAL+1B<MNTX17-MNTX00> ; Protocol not available
.FATAL==.FATAL+1B<MNTX20-MNTX00> ; Protocol not supported
.FATAL==.FATAL+1B<MNTX21-MNTX00> ; Protocol not supported by local network
.FATAL==.FATAL+1B<MNTX23-MNTX00> ; Requested service not available
.FATAL==.FATAL+1B<MNTX25-MNTX00> ; Route invalid or failed
.FATAL==.FATAL+1B<MNTX33-MNTX00> ; Transmission timeout
	    TXNN T2,.FATAL	; Fatal error?
	    IFSKP.		; Yes
	      HRRZI T2,MNTX00(T1) ; Reconstruct error code
	      MOVX T1,ELP+^D14	; Connection reset
	      CALL USRERR	; Set TERR and TCERR from T1 and T2
	    ENDIF.
	  ELSE.			; Packet not dropped
	    AOS OPPKCT		; Count packets output and
	    AOS OP+PRCRNC	; Output runs
jfcl
	  ENDIF.
	ELSE.			; All ok (T2 has short-block time)
	  AOS OPPKCT		; Count packets output and
	  AOS OP+PRCRNC		; Output runs
	  CAML T2,TPSB0
	   CAMLE T2,TPSB0+1
	  IFSKP.
	    ADD T2,TODCLK
	    STOR T2,TCPZT,(TCB)
	  ENDIF.
	ENDIF.

MNTM5	CAIA
EMTPKX:
MNTM5	  AOS CELL(TCZEM,1,,TCZ) ; EMTPKT found packet in use
	RET

	ENDAV.

;ABTREP	Send reply to remote TCP when this end is ABORT%ed before fully closed.

;TCB/	Extended Locked connection block
;T1/	Non-zero if reply should contain a RESET, zero for ACK only
;	CALL ABTREP
;Ret+1:	always

ABTREP::
	SAVEAC <TPKT,PKT>
	ACVAR <RSTFLG>
MNTM5	AOS CELL(TCZAB,0,,TCZ)	; ABTREP calls
	SKIPE RSTFLG,T1		; Save argument
	  SETO RSTFLG,

	SETZB T1,T2		; No data & have TCB
	CALL TCPIPK		; Get packet & fill in headers
	  RET			; No space.
	STOR RSTFLG,PRST,(TPKT) ; Set the reset bit if requested
	LOAD T1,TSSEQ,(TCB)	; Current send sequence
	STOR T1,PSEQ,(TPKT)	; Is the Packet sequence
	LOAD T2,TRIS,(TCB)	; Negative if no receive sequence number
	IFGE. T2		; If have receive sequence number,
	  LOAD T2,TRLFT,(TCB)	; What we want to hear next (or 0)
	  STOR T2,PACKS,(TPKT)	; Is the acknowledge
	  SETONE PACK,(TPKT)	; Make the ACK Sequence meaningful
	ENDIF.
	SETZRO PWNDO,(TPKT)	; 0 window to other end (TCB is dead)
	SETZRO PTCKS,(TPKT)	; Field must be zero for computation
	CALL TCPCKS		; Compute TCP packet checksum and
	STOR T1,PTCKS,(TPKT)	; Insert into packet

	LOAD T1,PIPL,(PKT)	; Transport level length
	STOR T1,PTPBZ,(PKT)
	LOAD T2,PIDO,(PKT)	; Transport level leader length, w
	LSH T2,2		; Bytes
	SUB T1,T2
	STOR T1,PSSBZ,(PKT)	; Session level length
	LOAD T2,PTDO,(TPKT)	; Session level leader length, w
	LSH T2,2		; Bytes
	SUB T1,T2
	STOR T1,PAPBZ,(PKT)	; Application level length

	MOVX T1,1
	TXNN FR,1B0		; Trace?
	  SETZ T1,		; No
	STOR T1,PTRAC,(PKT)	; Yes flag packet	

	MOVX T1,PT%TOR		; Reset generated by ABORT%
	SKIPN RSTFLG
	  MOVX T1,PT%TOR
	TXNN FR,1B0		; TCB trace or
	 TDNE T1,MNTRAC		; Want trace?
	  CALL PRNPKT		; Yes
MNTM5	AOS CELL(TCZAB,1,,TCZ)	; Successful ABTREP
	INCRNO TCSPC,(TCB)	; Count packets sent for connection
	AOS PZPKCT		; Count Packetized packets
	AOS OPPKCT		; Count Output packets
	SKIPE RSTFLG
	  AOS RSTSCT		; Count RESETs sent

	LOAD T1,TSFHOP,(TCB)	; Special first-hop routing
	CALLRET SNDGAT		; Sent Pkt to the net. (NB: PPROG is 0)
	ENDAV.

;FRCPKT	Causes a packet to be emitted even if there is no data to send.
;Done to cause something to be ACKd for instance.  Called when INPUT got a
;duplicate, PRCSYN found something funny, active OPEN%, or CLOSE%.

;TCB/	Extended Locked connection block
;	CALL FRCPKT
;Ret+1:	Always.

FRCPKT::
MNTM5	AOS CELL(TCZFP,0,,TCZ)	; FRCPKT calls
	IFQE. TSFP,(TCB)	; Filter extra calls
	  SETONE TSFP,(TCB)	; Set the Force packet request bit
	  $SIGNL(PZ,0)		; Make Packetizer run now
	ELSE.
MNTM5	  AOS CELL(TCZFP,1,,TCZ) ; FRCPKT not needed
	ENDIF.
	RET

;ENCPKT	Encourage generation of a packet.  A packet is needed to ACK something,
;but allow time for some data to appear so that the ACK can piggyback on it.
;Also, more calls may be made and we wish to minimize network traffic by not
;generating an ACK-only packet each time.

;TCB/	Extended Locked connection block
;T1/	# msec to wait
;	CALL ENCPKT
;Ret+1:	Always.

ENCPKT::
MNTM5	AOS CELL(TCZEP,0,,TCZ)	; ENCPKT calls
	IFQN. <TSFP>,(TCB)	; If we are here and Force Pkt set, BUG
	  MOVE CX,TCTPZ(TCB)	; Get PKTIZE sched time for BUGINF
;cwl via jvd: disable this BUGINF until the bug is found.
	  TRNA			; Disable TCPEFS, too much CTY output generated
	  BUG.(INF,TCPEFS,TCPTCP,SOFT,<ENCPKT: TSFP set in ENCPKT>,
<<T1,Delay>,<TODCLK,TODCLK>,<CX,Sched>,<TCB,TCBADR>>,<

Cause:	The Force Packet bit was set in Encourage Packet.

Action:	Notify the software staff if this happens.

Data:	Requested delay, TODCLK, TCTPZ from TCB, TCB address.

>)
	ENDIF.
	; Here to Encourage a Packet, if not already Encouraging, or
	;  if already Encouraging but for a sooner time.
	PUSH P,T1		; Save delay
	ADD T1,TODCLK		; Compute new Encourage Packet Time
	IFQN. TSEP,(TCB)	; If already encouraged, see if
	  LOAD CX,TSEPT,(TCB)	;  new time is sooner than the old
	  CAMGE T1,CX
	  ANSKP.		; New time is NOT sooner
	    POP P,(P)		; Drop delay
MNTM5	    AOS CELL(TCZEP,1,,TCZ)  ; ENCPKT already encouraged, not needed
	    RET			; Return
	ENDIF.
	SETONE TSEP,(TCB)	; Remember we are Encouraging
	STOR T1,TSEPT,(TCB)	; Set new Encourage Packet Time
	POP P,T1		; Restore Delay
	CALLRET DLAYPZ		; Signal PZ(TCB)

;DLAYPZ, DLAYPC	Schedule the packetizer at some time in the future.

;TCB/	Extended Locked TCB
;T1/	Delay time in milliseconds
;	CALL DLAYPZ, or CALL DLAYPC for reschedule ignoring TSFP
;Ret+1:	Always.

DLAYPZ::
MNTM5	AOS CELL(TCZDY,0,,TCZ)	; DLAYPZ calls, less CELL(TCZPZ,15)
	IFQE. TSFP,(TCB)	; Not yet forced
DLAYPC:	  MOVE T2,T1		; Desired delay for SIGNAL
	  MOVE T1,TCTPZ(TCB)	; When
	  SUB T1,TODCLK
	  SKIPE TCQPZ(TCB)	; If not yet queued, or
	   CAMLE T1,T2		; This request is sooner,
	  ANNSK.		; Then signal
	    XMOVEI T1,PZ	; Select Packetizer
	    CALLRET SIGNAL
	ENDIF.
MNTM5	AOS CELL(TCZDY,1,,TCZ) ; DLAYPZ not needed
	RET

;FLSSBF	Flush all SEND% buffers with a given Event Code (377B35).

;Called by ABTCON.

;TCB/	Extended Locked connection block
;T1/	Event Code: (377B35)
;	ELT+^D04 (no TVTs)
;	EFP+^D07 (RST received)
;	ELP+^D07 (@PZ with TSABT)
;	ELP+^D14 (RX timeout)
;	CALL FLSSBF
;Ret+1:	Always, T1 has # Buffers flushed.

FLSSBF:	SAVEAC <BFR>
	ACVAR <CODE,NBUF>
MNTM5	AOS CELL(TCZFB,0,,TCZ)	; FLSSBF calls
	MOVEM T1,CODE
	SETZ NBUF,		; No Buffers flushed

	LOAD BFR,TSCB,(TCB)	; Get possible send current buffer
	SETZRO TSCB,(TCB)	; Now it is gone
	DO.
	  IFN. BFR		; Do we have a buffer here?
	    MOVE T1,CODE	; Yes.
	    LSH T1,^D<36-8>	; Position it in error byte
	    CALL USRBFE		; Tell user buffer "emptied"
	    AOS NBUF
	  ENDIF.

	  XMOVEI CX,TCBSBQ(TCB)
	  LOAD T1,QNEXT,(CX)	; First thing on send buffer queue
	  CAMN T1,CX		; If it points at head of queue
	    EXIT.		; Means	 empty queue.  Done.
	  XMOVEI BFR,-BFRQ(T1)	; Point to top of structure
	  CALL DQ		; Dequeue the buffer
	  LOOP.
	ENDDO.

MNTM5	SKIPN NBUF
MNTM5	  AOS CELL(TCZFB,1,,TCZ) ; FLSSBF flushed none
MNTM5<	ADDM NBUF,CELL(TCZFB,2,,TCZ)> ; Buffers flushed by FLSSBF
	MOVE T1,NBUF		; Return # buffers flushed
	RET

	ENDAV.

;FLSSBX	Flush all SEND% buffers for the current fork.

;TCB/	Extended Locked connection block
;Ret+1:	always

FLSSBX::			; Flush send buffers for current FORKX
	JN TDEC,(TCB),R		; Do not do this for DEC TCBs
	SAVEAC <BFR>		; Do not trash this AC
	ACVAR <NBUF,NXTQ>
MNTM5	AOS CELL(TCZFX,0,,TCZ)	; FLSSBX calls
MNTM5<	SETZ NBUF,>
	LOAD BFR,TSCB,(TCB)	; Get possible send current buffer
	IFN. BFR
	  LOAD T1,BFRKX,(BFR)	; Get the FORKX that owns this buffer
	  CAME T1,FORKX		; Is it us?
	  ANSKP.
	    SETZRO TSCB,(TCB)	; Yes, forget the current buffer
	    MOVX T1,<<ELP+^D07>B7> ; Error code for the buffers
	    CALL USRBFE		; Indicate current buffer empty
MNTM5	    AOS NBUF
	ENDIF.
				; Here to loop through buffers for the TCB
	LOAD NXTQ,QNEXT,<+TCBSBQ(TCB)> ; Get the first queue entry
	DO.
	  MOVE T1,NXTQ
	  XMOVEI CX,TCBSBQ(TCB)
	  CAMN T1,CX		; If that is the head,
	    EXIT.		; All FORKX's buffers removed
	  LOAD NXTQ,QNEXT,(T1)	; Get next element
	  XMOVEI BFR,-BFRQ(T1)	; Point to top of structure
	  LOAD T2,BFRKX,(BFR)	; Get the FORKX that owns this buffer
	  CAME T2,FORKX		; Is it us?
	  IFSKP.
	    CALL DQ		; Dequeue the buffer
	    MOVX T1,<<ELP+^D07>B7> ; Error code for buffers
	    CALL USRBFE		; Indicate current buffer empty
MNTM5	    AOS NBUF
	  ENDIF.
	  LOOP.
	ENDDO.

MNTM5<	SKIPN T1,NBUF>
MNTM5	  AOS CELL(TCZFX,1,,TCZ) ; FLSSBX flushed none
MNTM5<	ADDM T1,CELL(TCZFX,2,,TCZ)> ; Buffers flushed by FLSSBX
	RET

	ENDAV.


;TCPIPK	Get space for packet and fill in IP and TCP headers.

;T1/	Maximum segment (data) length, in octets, may be 0
;T2/	Address of address block, or 0 if addresses in TCB are valid
;	Address block:	32-bit Destination address
;			32-bit Source (local) address
;			16-bit Destination port
;			16-bit Source port
;TCB/	Contains addresses if T2 is zero; may be zero
;	Call TCPIPK
;Ret+1:	  Cannot get space for packet, or neither T2 nor TCB specified
;Ret+2:	Success, PKT & TPKT set, packet headers & options set

;PMXSZ/	Contains maximum PIPL allowed
;PIPL/	Header+option length
;PTG,PTS/ Current TODCLK
;T1/	PMXSZ-PIPL octets are available	for data

TCPIPK::			; Only global if two parts
	ACVAR <ADRS>
	MOVEM T2,ADRS		; Save Adr block address or 0
MNTM5	AOS CELL(TCMAA,4,,TCM)	; TCPIPK calls
	IOR T2,TCB		; Make sure have TCB or Adr argument
	JUMPE T2,R		; Both T2 & TCB zero is error

;Try to assign a packet buffer for the packet to be sent.

	SKIPL T1		; Check arg
	 CAIL T1,177777		; Segment size +infinity?
	  MOVX T1,^D20		; Seg size not known (sending initial SYN)
	ADDI T1,3		; Round bytes up
	ASH T1,-2		; Convert to word count
	ADDI T1,TCPNPW		; + overhead - minimal pkt (w/max headers), w

	MOVX T2,NP.IP		; Protocol code
	CALL GETBUF		; Try to get storage
	JUMPE T1,R		; Failed

	MOVE PKT,T1		; Put in standard place

IFL TCPNPW-NBHDRL,<PRINTX % TCPTCP: TCPNPW should not be smaller than NBHDRL>
	MOVX T1,TCPNPW		; Clear (maximum) protocol header areas
				; so unspecified fields will be zero. GETBUF
				; has only cleared internal variables.
	LOAD T2,NBSIZ,(PKT)	; Words allocated
	CAML T1,T2		; Make sure have that many words
	  MOVE T1,T2		; Don't??
	SUBI T1,NBHDRL		; Zero from NBHDRL
	XMOVEI T2,NBHDRL(PKT)	; Source
	XMOVEI T3,1(T2)		; Destination
	SETZM 0(T2)		; Clear a word
	CALL XBLTA		; Clear the rest

	MOVE T1,TODCLK		; Set packet time generated
	STOR T1,PTG,(PKT)
	STOR T1,PTS,(PKT)	; Store as timestamp

;Fill in IP header

	XMOVEI T1,PKTELI(PKT)	; Address of transport level leader
	STOR T1,PTPDT,(PKT)
	MOVX T1,.INTVR
	STOR T1,PIVER,(PKT)	; Store protocol version number
	MOVX T1,<<MINIHS+3>/4>	; # words in smallest IP hdr
	STOR T1,PIDO,(PKT)	; Set as initial data offset
	ASH T1,2		; Length, bytes
	STOR T1,PIPL,(PKT)	; Current length
	AOS T2,TCPSID		; Get the next segment ID
	STOR T2,PISID,(PKT)	; Into packet

	SETO T3,		; Max time to live
	IFN. TCB		; If have a TCB, use user specified values
	  LOAD T3,TTOS,(TCB)	; Copy Type of Service
	  STOR T3,PITOS,(PKT)
	  LOAD T3,TIFDF,(TCB)	; Copy Don't Fragment flag
	  STOR T3,PIDF,(PKT)
	  LOAD T3,TTTL,(TCB)	; Copy Time to Live
	ENDIF.
	STOR T3,PITTL,(PKT)	; Set Time to Live
	MOVX T3,.TCPFM		; TCP format
	STOR T3,PIPRO,(PKT)	; Set into protocol field

;Insert IP options to locate the beginning of the TCP header.

	CALL TCPIIO		; Insert IP Options & adjust PIDO and PIPL
				; (Note TCB may be 0)
;Set pointer to TCP header in packet now that all IP options have been
;set or reserved.

	XMOVEI TPKT,PKTELI(PKT)	; Pointer to IP header
	LOAD T2,PIDO,(PKT)	; IP data offset (including options)
	ADD TPKT,T2		; TPKT now points at TCP header area
	STOR TPKT,PSSDT,(PKT)	; Address of session level leader

;Fill in IP addresses & TCP header

	SKIPN ADRS		; Address block specified?
	IFSKP.
	  DMOVE T1,(ADRS)	; Yes, get addresses from arg block
	  DMOVE T3,2(ADRS)
	ELSE.
	  LOAD T1,TFH,(TCB)	; No, destination address
	  LOAD T2,TLH,(TCB)	; Source address
	  LOAD T3,TFP,(TCB)	; Destination port
	  LOAD T4,TLP,(TCB)	; Source port
	ENDIF.
	STOR T1,PIDH,(PKT)	; Store the destination host
	STOR T2,PISH,(PKT)	; Store the source host
	STOR T3,PDP,(TPKT)	; Store the destination port
	STOR T4,PSP,(TPKT)	; Store the source port

	MOVX T1,<<MINTHS+3>/4>	; Minimum TCP header size
	STOR T1,PTDO,(TPKT)	; Set into TCP data offset field
	ASH T1,2		; Bytes in TCP header
	LOAD T2,PIPL,(PKT)	; Current IP header length (inc opt)
	ADD T2,T1		; Total IP+TCP header length
	STOR T2,PIPL,(PKT)	; Set IP packet length

;Now the TCP header is initialized and TCP options can be inserted.

	CALL TCPITO		; Insert TCP options & update PTDO and PIPL
				; (Note TCB may be 0)
	LOAD T2,PTDO,(TPKT)	; TCP header length, words
	ADD T2,TPKT		; Data area
	STOR T2,PAPDT,(PKT)	; Address of application level data

IFL <WID(PMXSZ)-WID(PIPL)>,<PRINTX ? Width of PIPL exceeds that of PMXSZ>

	LOAD T1,NBSIZ,(PKT)	; Get total size of buffer in words
	SUB T1,PROOVH+NP.IP	; Reduce by overhead
	ASH T1,2		; Max # IP bytes (max PIPL due to buffer size)
	IFN. TCB		; If have a TCB,
	  LOAD T3,TSMXS,(TCB)	; Have a maximum segment length (+infinity ok)
	  ADDI T3,^D40		; Plus nominal headers is max packet length
	ELSE.
	  MOVX T3,^D576		; Internet default max packet length
	ENDIF.
	CAMLE T1,T3		; Take min(buffer limit,net/user limit)
	  MOVE T1,T3
	STOR T1,PMXSZ,(PKT)	; Save max PIPL for this packet
	LOAD T2,PIPL,(PKT)	; Sum of header sizes is space already used
	SUB T1,T2		; Octets available for data is returned
	SKIPGE T1
	  SETZ T1,		; Don't return a negative size
	AOS (P)			; Skip, have packet buffer
	RET

	ENDAV.

;GETISN	Get value of initial sequence number curve.

;Get  the  current  value  of the Initial Sequence Number curve. This
;curve is a straight line which starts at  0  and  goes  through  the
;maximum  sequence number minus 1 every cycle time of the network. It
;steps once a second.

;cwl TCS%O2 optimization for hashing TCBS ...



;	CALL GETISN
;Ret+1:	always, ISN in T1

GETISN:
MNTM5	AOS CELL(TCMAA,1,,TCM)	; GETISN calls
	CALL LGTAD		; Day,,tick
	HRRZS T1		; Save tick with day
	LSH T1,^D17		; Make into binary fraction of day
;TCPISN is [^D<<MAXSEQ/8>*<<24*60*60>/CYCTIM>>]
	MUL T1,TCPISN		; Get sequence number
	LSH T1,@TCPISN+1	; Scale factor of 8 above
	MODSEQ T1
	RET
;cwl options
	SUBTTL	TCP Option Routines

COMMENT	!

These routines perform various functions associated with TCP and IP Options.
Options are stored in packets after the header and before the data.  The
format is described in ANAUNV.

!


;SNDMSL If local net has a maximum packet length significantly greater than
;the 576 "sociable size" include a maximum segment option.

;PKT/	Extended Packet pointer
;TPKT/	Extended pointer to TCP header
;TCB/	Extended Locked Connection Block
;	CALL SNDMSL
;Ret+1:	Always. T1/	MNTX00 if ok, or TCPX47 if error

SNDMSL:	LOAD T1,TFH,(TCB)	; Get foreign host address
	PUSH P,P1		; Save register
	CALL GWYLUK ;(T1:T1,P1)	; Find current routing to destination
	SKIPE T3,P1		; Any way there?
	  MOVE T3,NTPSIZ(P1)	; Yes, get maximum packet length
	POP P,P1		; Restore register
	MOVE T2,T1
	MOVX T1,MNTX00		; All ok
	JUMPE T2,R		; No way there (how did we get here?)
	JUMPLE T3,R		; No size specified, assume internet default

	LOAD T2,TFH,(TCB)	; Get foreign host address
	NETNUM T2,T2		; Extract network number
	LOAD T4,TLH,(TCB)	; Get local host address
	NETNUM T4,T4		; Extract network number
	CAMN T2,T4		; If hosts are on same net and
	 CAIGE T3,^D<576+40>	; Significantly greater than 576, or
	  CAIGE T3,^D576	; If local net has limit less than 576
	   TRNA			; Send the option
	    RET			; Otherwise, don't bother, MNTX00

IF2 <IFN MSLLEN-4,<PRINTX ?TCP Max Seg Len option length isn't 4, fix SNDMSL:>>

	SUBI T3,<MINIHS+MINTHS>	; Maximum segment size excludes headers
	LSH T3,4		; Position size in 32-bit word
	IOR T3,[BYTE(8)MSLOPT,MSLLEN,0,0] ; Build option octets
	MOVX T1,<TMSLBIT>	; Internal option id bit
	MOVX T2,<MSLLEN>	; Option will add 4 octets
	CALLRET INSOPT		; Get it inserted

;SNDOMZ	Send an optimization option, if enabled

;PKT/	Extended Packet pointer
;TPKT/	Extended pointer to TCP header
;TCB/	Extended Locked Connection Block
;	CALL SNDOMZ
;Ret+1:	Always. T1/ MNTX00 is ok, or TCPX47 if error

SNDOMZ:	MOVX T1,.GTHHN		; Number to status
	LOAD T3,TFH,(TCB)	; Foreign host
	TXO T3,<FLD(NP.IP,NA%PRO)> ; This is an IP address
	GTHST%
	  SETZ T4,		; Zero on error
	LOAD T2,HS%STY,+T4	; Extract host type
	MOVX T1,MNTX00		; Assume Ok
	MOVE CX,TCPSW		; TCP switches
	TXNN CX,TCS%O1		; Enabled  or 
	 CAIN T2,.HST20		; TOPS20?	 
	  TRNA			; Yes, send it
	   RET			; No, stop
	MOVX T1,<TOMZBIT>	; Internal option identification bit
	MOVX T2,OMZLEN		; Number of octets
	MOVE T3,TCPOMZ		; Default optimization
	LSH T3,^D8+4		; Third octet
	TXO T3,<BYTE (8)OMZOPT,OMZLEN,0,0> ; Prototype option
	CALLRET INSOPT		; Insert it

;INSOPT	Insert word of options

;T1/	Internal option identification bit (TxxxOPT)
;T2/	Length of option (1 to 4)
;T3/	Option word, left justified
;	CALL INSOPT
;Ret+1	Always.  T1/	TCPX47	bad option/not supported
;			MNTX00	All ok (or application already specified option

INSOPT:	MOVE T4,T1		; Save bit
	MOVX T1,MNTX00		; Only have option once
	LOAD CX,TTOPF,(TCB)	; Get flags for TCP options present
	TDNE CX,T4		; Option already there?
	  RET			; Yes, stop
	MOVX T1,TCPX47		; Error in option
	SKIPLE T4,T2		; Reject 0 or negative, copy number of octets
	 CAILE T2,4		; Code only works for single words
	  RET			; Bad length (internal problem)

	CAIN T2,4		; If not full word
	IFSKP.			; Easiest to pad
	  IMULI T4,<-^D8>	; Bits per byte	
	  MOVX T1,<-1>
	  LSH T1,(T4)		; Bits to flush
	  ANDCM T3,T1
	  MOVX T1,<BYTE (8)NOPOPT,NOPOPT,NOPOPT,NOPOPT>
	  LSH T1,(T4)		; NOP padding
	  IOR T3,T1
MNTM5<	  MOVX T1,NOP>
MNTM5	  INHIST(TCOPS,TCO,T1,T4,CX) ; TCP system NOPs sent (CELL()
	ENDIF.

	LOAD T2,PTDO,(TPKT)	; TCP header size
	ADDI T2,1		; One more header word
	MOVX T1,TCPX47		; Error in option
	CAILE T2,.RTJST(-1,PTDO) ; Will including it overflow TCP header?
	  RET			; Yes, cannot include it
	STOR T2,PTDO,(TPKT)	; New TCP header length

	LOAD T1,PIPL,(PKT)	; IP packet length
	ADDI T1,4*1		; Add octets for padded option
	STOR T1,PIPL,(PKT)	; New packet length

MNTM5<	LDB T1,[POINT 8,T3,7]>	; Get option
MNTM5	INHIST(TCOPS,TCO,T1,T4,CX) ; TCP system options sent (CELL()

	XMOVEI T1,<<MINTHS+3>/4>(TPKT) ; Locate first TCP option word
	SUBI T2,<<MINTHS+3>/4>+1 ; Number of option words to be "pushed"
	DO.
	  EXCH T3,(T1)		; Insert and get previous contents
	  ADDI T1,1		; Move to next word
	  SOJG T2,TOP.		; Back if more
	ENDDO.
	MOVEM T3,(T1)		; Insert last word "pushed"
	MOVX T1,MNTX00		; All ok
	RET


;TCPIIO	Insert IP Options (from TCB image) into packet.

;PKT/	Extended pointer to packet being constructed
;TCB/	Extended pointer to TCB  or  0
;	CALL TCPIIO
;Ret+1:	Always, Any options inserted & PIPL & PIDO updated accordingly

TCPIIO:
MNTM5	AOS CELL(TCOAA,1,,TCO)	; TCPIIO calls
	JUMPE TCB,R		; No TCB

	LOAD T1,TIPDO,(TCB)	; TOTAL IP header size, words
	SUBI T1,<MINIHS+3>/4	; Minus standard header
	JUMPLE T1,R		; No IP options
	LOAD T2,PIDO,(PKT)	; IP header size, words
	CAIE T2,<MINIHS+3>/4	; Insert or refresh?

	IFSKP.			; Insert options

	  ADD T1,T2		; Desired header+options
	  CAILE T1,.RTJST(-1,PIDO) ; Too big?
	    MOVX T1,.RTJST(-1,PIDO) ; Clamp to max
	  STOR T1,PIDO,(PKT)	; Update IP header size, words
	  SUB T1,T2		; Room for options, words
	  MOVE T4,T1		; Option words
	  LSH T4,2		; Bytes in option words
	  LOAD T2,PIPL,(PKT)	; Current packet length
	  ADD T2,T4		; New packet length, bytes
	  STOR T2,PIPL,(PKT)	; Updated packet length

	ELSE.			; Refresh options

	  MOVE T1,T2		; Available space for options
	  SUBI T1,<MINIHS+3>/4
	ENDIF.

;Copy options into header

	XMOVEI T2,TCBIO(TCB)	; Option image in TCB
	XMOVEI T3,PKTELI(PKT)	; IP header base
	ADDI T3,<MINIHS+3>/4	; Pointer to IP option area
	CALLRET XBLTA		; Options into header

;TCPITO	Insert TCP options (from TCB image) into packet.

;PKT/	Extended pointer to packet being constructed
;TPKT/	Extended pointer to TCP header of packet
;TCB/	Extended pointer to TCB  or  0
;	CALL TCPITO
;Ret+1:	Always, any options copied & PIPL and PTDO updated

TCPITO:
MNTM5	AOS CELL(TCOAA,2,,TCO)	; TCPITO calls
	JUMPE TCB,R		; No TCB

	LOAD T1,TTPDO,(TCB)	; TOTAL TCP header size, words
	SUBI T1,<MINTHS+3>/4	; Minus standard header
	JUMPLE T1,R		; No TCP options
	LOAD T2,PTDO,(TPKT)	; TCP header size, words
	MOVE T3,TPKT		; TCP header base
	ADD T3,T2		; Pointer to TCP option area
	ADD T1,T2		; Desired header+options
	CAILE T1,.RTJST(-1,PTDO) ; Too big?
	  MOVX T1,.RTJST(-1,PTDO) ; Clamp to max
	STOR T1,PTDO,(TPKT)	; Update TCP header size, words
	SUB T1,T2		; Room for options, words
	MOVE T4,T1		; Option words
	LSH T4,2		; Bytes in option words
	LOAD T2,PIPL,(PKT)	; Current packet length
	ADD T2,T4		; New packet length, bytes
	STOR T2,PIPL,(PKT)	; Updated packet length
	XMOVEI T2,TCBTO(TCB)	; Option image in TCB
	CALLRET XBLTA		; Options into header


;Maximum # words for options

MAXIOW==1_<WID(PIDO)>-1-<MINIHS+3>/4	; Max # IP option words
MAXTOW==1_<WID(PTDO)>-1-<MINTHS+3>/4	; Max # TCP option words
MAXOPW==MAXIOW				; Max of the two
IFG <MAXTOW-MAXIOW>,<MAXOPW==MAXTOW>

;AC redefinitions, temp and local register definitions initiated by CALL OPSAV

OPSAV:	TRVAR <UPTRS,<UOPS,MAXOPW+1>,<REGS,11+1>>
	MOVEM 11,11+REGS	; Save last reg
	MOVEI 11,REGS		; 0,,save area adr
	BLT 11,11-1+REGS	; Save others

	SETZM T1+REGS		; No error

	MOVX CX,<MSEC1,,R>	; Wipe out our
	EXCH CX,-2+UPTRS	; return with dummy
	CALL (CX)		; Back to mainline
	JRST OPRES		; Go clean up stack

OPTS==0				; Bit corresponding to options present
RP==2     			; Pointer to received option byte
RC==3 				; Count of remaining received option bytes
BIT==4  			; Bit corresponding to current option
OPT==5 				; Option (byte)
OPL==6 				; Option length
OPC==7  			; Count of remaining option bytes
OPP==10  			; Pointer to option byte
IORT==11       			; Pointer to IP or TCP Info table


;Option Tables
;Note: IPOPTS(U,R,E) [TCPOPTS(U,R,E)] calls, for each defined IP [TCP]
;	option, OPTION(I[T],name,Copy-on-fragmentation,number,length,U,R,E)

;Table of known option numbers, and id bits


DEFINE OPTION (T,NA,C,NU,L,U,R,E)<
	EXP NU
> ; End of DEFINE OPTION

	-NIPOP,,.+1	; IP option numbers
IOPNU:	IPOPTS
NIPOP==.-IOPNU		; # IP options
	ENDOPT

	-NTCPOP,,.+1	; TCP option numbers
TOPNU:	TCPOPTS
NTCPOP==.-TOPNU		; # TCP options
	ENDOPT

;Table of "check" routine (namCHK:) for each known option, skip if ok

DEFINE OPTION (T,NA,C,NU,L,U,X)<
IFDEF  NA'U,<	MSEC1,,NA'U	>
IFNDEF NA'U,<	MSEC1,,X	>
> ; End of DEFINE OPTION

OPTCOF==.-IOPNU		; Is user option valid
	IPOPTS  (CHK,RSKP)	; Known IP Options
	MSEC1,,RSKP	; Unknown IP Options - OK if cannot prove wrong
	MSEC1,,RSKP	; Maintain spacing
	TCPOPTS (CHK,RSKP)	; Known TCP Options
	MSEC1,,RSKP	; Unknown TCP Options - OK if cannot prove wrong

;Should received options be returned to originator (namCPY:), skip if so

OPTDOF==.-IOPNU		; Should received option be dropped or sent?
	IPOPTS  (CPY,R)	; Known IP Options
	MSEC1,,R	; Unknown IP Options - Drop unknowns
	MSEC1,,R	; Maintain spacing
	TCPOPTS (CPY,R)	; Known TCP Options
	MSEC1,,R	; Unknown TCP Options - Drop unknowns

;Routine (namXCT:) to interpret received options

OPTXOF==.-IOPNU		; What does received option mean?
	IPOPTS  (XCT,R)	; Known IP Options
	MSEC1,,R	; Unknown IP Options - Forget unknowns
	MSEC1,,R	; Maintain spacing
	TCPOPTS (XCT,R)	; Known TCP Options
	MSEC1,,R	; Unknown TCP Options - Forget unknowns

;Table of (minumum) lengths for received options and name corresponding bit
;NB: bits must come AFTER number of options is known in pass1 so values are
;correct at the beginning of pass2.  First letter of name is Ip or Tcp,
;followed by 3-letter option name, followed by "BIT", e.g. TMSLBIT.

DEFINE OPTION (T,NA,C,NU,L,U,R,E)<
T'NA'BIT==<..X==..X_-1>
NA'LEN==L
> ; End of DEFINE OPTION

..X==1_NIPOP		; Bits so last option is 1B35
	IPOPTS
..X==1_NTCPOP		; Bits so last option is 1B35
	TCPOPTS
	PURGE ..X,OPTION

;TCPUOP	Process User specified options.

;T1/	(ip,,tcp) user section 0 option addresses (or -1 to re-merge)
;TCB/	Extended pointer to locked connection block
;	CALL TCPUOP
;Ret+1:	Always, T1 is 0 or error code
;PARSOP	-1,,ELP+^D02 ; Cannot parse options or option length too long

TCPUOP::
MNTM5	AOS CELL(TCOUO,0,,TCO)	; TCPUOP calls
	CALL OPSAV		; Save regs & get working area
	MOVEM T1,UPTRS		; Save user addresses

;Process user specified IP options

	HLRZ T2,UPTRS		; User address of IP options
	IFN. T2
	  XMOVEI IORT,IPINFO	; IP Info
	  CAIE T2,-1		; Skip PARSOP if re-merge
	    CALL PARSOP		; Parse and validate user specified options
	  SKIPL T1+REGS		; If error, don't MERGE, but go check TCP
	    CALL MERGE		; Merge new user options with received
	ENDIF.
	HRRZS T1+REGS		; Remember possible error code w/o LH

;Process user specified TCP options

	HRRZ T2,UPTRS		; User address of TCP options
	IFN. T2
	  XMOVEI IORT,TCPINFO	; TCP Info
	  CAIE T2,-1		; Skip PARSOP if re-merge
	    CALL PARSOP		; Parse and validate user specified options
	  SKIPL T1+REGS		; If error, don't MERGE
	    CALL MERGE		; Merge new user options with received
	ENDIF.

	MOVX T1,PT%TOO		; User options processed
	MOVE T2,T1+REGS		; Report error, if any
	TXNN FR,1B0		; TCB trace or
	 TDNE T1,MNTRAC		; Want trace?
	  CALL PRNPKT		; Yes

	SKIPN T1+REGS		; Look for error
	  RET			; None
	HRROS T1+REGS		; Make sure negative
MNTM5	AOS CELL(TCOUO,1,,TCO)	; TCPUOP failures
	RET

;PARSOP	Parse and validate user specified options.

;T2/	(Section 0) user address of options (non-vaild to get here)
;IORT/	Extended pointer to IP or TCP Info table
;	CALL PARSOP
;Ret+1:	Always, T1+REGS non-zero if error
;	-1,,ELP+^D02 ; Cannot parse options or option length too long

PARSOP:
MNTM5	AOS CELL(TCOPO,0,,TCO)	; PARSOP calls

	SETZM OPTS		;		No user options yet
	MOVE T1,MXW(IORT)	; MAXxOW	Max possible length, w
	XMOVEI T3,UOPS		;		Our local copy
	CALL BLTUM		;		Get user options
	MOVE T3,MXW(IORT)	; MAXxOW	Maximum length, w
	LSH T3,2		;		Bytes
	MOVE OPC,T3		;		Used later too
	MOVX OPP,<POINT 8,UOPS,7> ;		Byte pointer to first

;Parsing loop

PARSO2:	DO.
	  LDB OPT,OPP		;		Get option
	  ANDCM OPT,CPY(IORT)	; CPYOPT/0	Without copy on fragmentation

MNTM5	  INHIST(TCOPS,TCO,OPT,T1,BIT) ;	Histogram user options (CELL()

	  CAIN OPT,ENDOPT	; End?
	    EXIT.		; Yes
	  CAIN OPT,NOPOPT	; NOP?
	  IFSKP.		; (OPT code is length for NOP)

;Option with length, look it up in the option table

	    MOVE CX,OTAB(IORT)	; MSEC1,,xOPNU		Address of option table
	    MOVE CX,-1(CX)	; -count,,address of first
	    DO.
	      CAME OPT,(CX)	; This it?
	        AOBJN CX,TOP.	; No, try next
	    ENDDO.
	    HLRE BIT,CX		; -i or 0
	    SKIPE BIT		; Unknown option
	    MOVE BIT,BITS+^D36(BIT) ; Known option

            CALL @OPTCOF(CX)	; Check option
	      JRST PARSOE	; Looses, error code set

	    ILDB OPT,OPP	; Get length
	    CAIL OPT,2		; Must be at least 2 and
	     CAMGE OPC,OPT	; Small enough to fit in remaining space?
	      JRST PARSO9	; No, error
	    IORM BIT,OPTS	; Remember which options user specified
	    SUBI OPC,1		; Count option byte
	    SUBI OPT,1		; Already past it
	  ENDIF.		; Option with length

	  SUB OPC,OPT		; Free bytes after this option
	  ADJBP OPT,OPP		; Point at next
	  MOVEM OPT,OPP
	  JUMPG OPC,TOP.	; Back for next option
	ENDDO.

	SUB T3,OPC		; Used bytes
	IFG. OPC		; Unused bytes exist
	  MOVX T1,ENDOPT	; Fill with END options
	  DO.
	    IDPB T1,OPP		; Clear free bytes
	    SOSLE OPC
	      LOOP.
	  ENDDO.
	ENDIF.

	XCT SOU(IORT)		; STOR T3,TxPOU,(TCB)	Store user option bytes
	MOVE T1,MXW(IORT)	; MAXxOW		Max possible length, w
	XMOVEI T2,UOPS		;			New options
	XCT XTOU(IORT)		; XMOVEI T3,TCBxU(TCB)	TCB location
	CALL XBLTA		;			Copy them there
	XCT SOF(IORT)		; STOR OPTS,TxOPF,(TCB)	Save flags
	RET			; All ok

PARSO9:	HRROI T1,ELP+^D2	; Error (option length)
PARSOE:	MOVEM T1,T1+REGS	; Set error code
MNTM5	AOS CELL(TCOPO,1,,TCO)	; PARSOP errors
	RET

;LSRCHK	Make sure routing options end with packet destination address.

;T1/	Option table index (free)
;T2/	(free)
;T3/	Max count (preserve)
;T4=BIT/Bit representing option (preserve)
;OPT/	Option code w/o CPYOPT (free)
;OPP/	Pointing at option code byte (preserve)
;OPC/	Remaining count (preserve)
;TCB/	Locked Extended TCB address
;	CALL LSRCHK or SSRCHK
;Ret+1:	Error in option (T1+REGS set)
;Ret+2:	Ok

LSRCHK:
MNTM5	AOSA CELL(TCORK,0,,TCO)	; LSRCHK calls
SSRCHK:
MNTM5	  AOS CELL(TCORK,1,,TCO) ; SSRCHK calls
	SAVEAC <OPP>

	JE TFH,(TCB),RUTCKO	; Not yet specified so cannot check
	ILDB T2,OPP		; Length
	ILDB OPT,OPP		; Initial pointer
	CAIL T2,7		; 7 is leagal but 13(8) is reasonable
	 CAIE OPT,4
	  JRST RUTCKE		; Bad
	SUBI T2,3		; Option header length
	DO.
	  ILDB OPT,OPP		; Next address byte
	  LSH T1,^D8		; Room for another byte
	  IOR T1,OPT		; of address
	  SOSLE T2		; More bytes?
	    LOOP.		; Yes
	ENDDO.
	ANDX T1,<BYTE (4)0(8)377,377,377,377> ; Just last 4 bytes

	LOAD T2,TFH,(TCB)	; Source
	CAMN T1,T2		; Same?
	  JRST RUTCKO		; Yes, ok

RUTCKE:	HRROI T1,ELP+^D02	; Error (length or last adr not dest)
	MOVEM T1,T1+REGS	; Set error code
MNTM5	AOS CELL(TCORK,2,,TCO)	; LSRCHK+SSRCHK errors
	CAIA
RUTCKO:	  AOS (P)		; OK, skip return
	RET

;TCPXOP	Extract IP and TCP options from a packet

;PKT/	Extended pointer to IP header
;TPKT/	Extended pointer to TCP header
;TCB/	Extended pointer to locked TCB
;	CALL TCPXIO
;Ret+1:	Always, options updated/processed, T1 lt 0 if error detected

TCPXOP::			; Only global if two parts
	CALL TCPXIO		; Extract IP
	CALLRET TCPXTO		; and TCP options


;TCPXIO	Extract interesting IP options from received packet.

TCPXIO:	SETZ T1,		; Assume no error
	LOAD T2,PIDO,(PKT)	; IP header size, w
	SUBI T2,<MINIHS+3>/4	; Size w/o options
	JUMPLE T2,R		; None

	CALL OPSAV		; Save regs & get working area

	MOVE T1,T2		; Length options, words
	MOVE T2,PKT
	ADDI T2,PKTELI+<MINIHS+3>/4
	XMOVEI IORT,IPINFO	; IP Info
	CALL TCPXXO		; Process received IP options
MNTM5	SKIPL T1+REGS		; Error?
MNTM5	 AOSA CELL(TCOXI,0,,TCO) ; TCPXIO w/ options
MNTM5	  AOS CELL(TCOXI,1,,TCO) ; TCPXIO errors
	RET


;TCPXTO	Extract interesting TCP options from received packet.

TCPXTO:	SETZ T1,		; Assume no error
	LOAD T2,PTDO,(TPKT)	; TCP header size, w
	SUBI T2,<MINTHS+3>/4	; Size w/o options
	JUMPLE T2,R		; None

	CALL OPSAV		; Save regs & get working area

	MOVE T1,T2		; Length options, words
	MOVE T2,TPKT
	ADDI T2,<MINTHS+3>/4
	XMOVEI IORT,TCPINFO	; TCP Info
	CALL TCPXXO		; Process TCP options
MNTM5	SKIPL T1+REGS		; Error?
MNTM5	 AOSA CELL(TCOXT,0,,TCO) ; TCPXTO w/ options
MNTM5	  AOS CELL(TCOXT,1,,TCO) ; TCPXTO errors
	RET

;TCPXXO	Scan received options, merge any to be returned w/ user specified ones

;T1/	# option words
;T2/	Extended pointer to options in packet
;IORT/	Extended Information table address
;	CALL TCPXXO
;Ret+1:	Always, T1+REGS lt 0 if error detected

TCPXXO:	PUSH P,T1		; Save received option words
	SETZM UOPS		; Clear working area
	MOVEI T4,UOPS		; Build BLT word
	HRLS T4
	ADDI T4,1		; But save T2
	BLT T4,MAXOPW-1+UOPS
	MOVE T1,(P)		; Words received
	XMOVEI T3,UOPS
	CALL XBLTA		; Get options from packet
	MOVE RC,(P)		; Words received
	LSH RC,2		; Bytes
	MOVEM RC,(P)		; Save for later
	MOVX RP,<POINT 8,UOPS,7> ; First received option

;Option loop

TCXXX3:	DO.
	  LDB OPT,RP		; Reveived option byte
	  ANDCM OPT,CPY(IORT)	; CPYOPT/0	Without copy on fragmentation

MNTM5<	  PUSH P,T2>
MNTM5	  INHIST(TCOPR,TCO,OPT,T1,T2) ; Histogram received options (CELL()
MNTM5<	  POP P,T2>

	  CAIN OPT,ENDOPT	; End of options?
	    EXIT.		; Yes, all done
	  CAIN OPT,NOPOPT	; Watch out for length 1
	  IFSKP.		; (OPT code is length)

	    MOVE CX,OTAB(IORT)	; MSEC1,,xOPNU	Option table address
	    MOVE CX,-1(CX)	; AOBJN pointer for options
	    DO.
	      CAME OPT,(CX)	; This the option?
	        AOBJN CX,TOP.	; No, look further
	    ENDDO.
	    ILDB OPT,RP		; Get option length

	    CALL @OPTXOF(CX)	; Interpret option

	    LDB OPT,RP		; Option length
	    CAILE OPT,2		; Must be .ge. 2
	    IFSKP.
	      MOVEI OPT,2	; Force to 2 to protect self
	    DPB OPT,RP		; (Send garbage back?)
	    ENDIF.
	    SUBI RC,1		; Count option code
	    SUBI OPT,1		; Already past it
	  ENDIF.

	  SUB RC,OPT		; Bytes left to process
	  ADJBP OPT,RP		; Option byte
	  MOVEM OPT,RP
	  JUMPG RC,TOP.		; Loop if more
	ENDDO.
	MOVNS RC
	ADD RC,(P)		; 		Acutal option bytes
	XCT SOR(IORT)		; STOR RC,TxPOR,(TCB)
	ADJSP P,-1		; 		Restore stack
	MOVE T1,MXW(IORT)	; MAXxOW
	XMOVEI T2,UOPS
	XCT XTOR(IORT)		; XMOVEI T3,TCBxR(TCB)
	CALL XBLTA		;		Save options for future
	CALLRET MERGE		; 		Merge them with user's

;MSLXCT	Received TCP Maximum Segment Length Option.

;RP/	Points to length byte
;	CALL MSLXCT
;Ret+1:	Always, TSMXS updated if possible

MSLXCT:	SAVEAC <RP,RC>
MNTM5	AOS CELL(TCOMX,0,,TCO)	; MSLXCT calls
	MOVE T3,RP
	LDB T4,T3		; Get length
	CAIN T4,MSLLEN		; Right length?
	IFSKP.			; (ICMP error msg??)
MNTM5	  AOS CELL(TCOMX,1,,TCO) ; MSLXCT errors (length)
	  RET
	ENDIF.

	SETZ T1,
	MOVX T4,<-MSLLEN+2,,0>	; Two more bytes
	DO.
	  ILDB T2,T3		; Accumulate #
	  LSH T2,^D<36-8>
	  LSHC T1,^D8
	  AOBJN T4,TOP.
	ENDDO.
	CALLRET TCPMXS		; Compute new maximum segment length

;OMZXCT	Received TCP Maximum Segment Length Option.

;RP/	Points to length byte
;	CALL OMZXCT
;Ret+1:	Always, TCOMZ updated

OMZXCT:	SAVEAC <RP,RC>
MNTM5	AOS CELL(TCOOP,0,,TCO)	; OMZXCT calls
	MOVE T3,RP
	LDB T4,T3		; Get length
	CAIN T4,OMZLEN		; Right length?
	IFSKP.			; (ICMP error msg??)
MNTM5	  AOS CELL(TCOOP,1,,TCO) ; OMZXCT errors (length)
	  RET
	ENDIF.

	SETZ T1,
	MOVX T4,<-OMZLEN+2,,0>	; One more byte
	DO.
	  ILDB T2,T3		; Accumulate #
	  LSH T2,^D<36-8>
	  LSHC T1,^D8
	  AOBJN T4,TOP.
	ENDDO.
	STOR T1,TCOMZ,(TCB)	; Record remote optimization configuration
	CAME T1,TCPOMZ		; Our default optimization configuration
	IFSKP.			; Same
	  MOVE T1,TCPSW
	  TXNE T1,TCS%O1	; If optimization is enable in general,
	    RET
	  SETONE TPOMZ,(TCB)	; Optimize for this connection
	ELSE.
MNTM5	  AOS CELL(TCOOP,2,,TCO) ; OMZXCT different configurations
	ENDIF.
	RET

;MERGE	User options and received options into send options.

;IORT/	IP/TCP Information table address
;	CALL MERGE
;Ret+1:	Always, T1+REGS lt 0 if error detected
;	-1,,EFT+^D02		; Bad received option, too many options

;Point to User options, just copy them if no options have been received

MERGE:	XCT XFOU(IORT)		; XMOVEI T2,TCBxU(TCB)	Assume User options
	XCT LOU(IORT)		; LOAD OPP,TxPOU,(TCB)	User bytes used
	XCT LOR(IORT)		; LOAD RC,TxPOR,(TCB)	Received bytes used
	JUMPE RC,MERGE8		;		Nothing to merge - User only

;Copy User options into working area

	MOVE T1,MXW(IORT)	; MAXxOW	; Begin with User options
	XMOVEI T3,UOPS		; 		  Get user options
	CALL XBLTA

;Find number of octets available for merging after user options,
;Set pointer to first free octet, and get bits identifying user options

	MOVE OPC,MXW(IORT)	; MAXxOW	Max words allowed
	LSH OPC,2		;		Max bytes allowed
	SUB OPC,OPP		;		Free bytes after User

;Either merge or copy/drop received options

	ADJBP OPP,[POINT 8,UOPS,7] ; Point at free output byte
	XCT LOF(IORT)		; LOAD OPTS,TxOPF,(TCB)	Get User option flags

;Set pointer to last options received, and set received octet count

	MOVE RP,POR(IORT)	; POINT 8,TCBxR(TCB),7	Point to received opt
	XCT LOR(IORT)		; LOAD RC,TxPOR,(TCB)	Received octet count

;Process next received option, either appending it or dropping it

MERGE1:	DO.
	  LDB OPT,RP		; Received option code
	  ANDCM OPT,CPY(IORT)	; CPYOPT/0 ; Without copy on fragmentation

	  CAIN OPT,ENDOPT	; End of options?
	    EXIT.		; Yes, All done

	  CAIE OPT,NOPOPT	; Nop?
	  IFSKP.		; Drop received NOP
	    SUBI RC,NOPLEN	; Length of NOP
	    ILDB OPT,RP		; Point at next
	  ELSE.

;Option with length, look it up in table of known options

	    MOVE CX,OTAB(IORT)	; MSEC1,,xOPNU	Option table address
	    MOVE CX,-1(CX)	; AOBJN pointer for options
	    DO.
	      CAME OPT,(CX)	; This the option?
	        AOBJN CX,TOP.	; No, look further
	    ENDDO.
	    HLRE BIT,CX		; -i (or 0 if an unknown option)
	    SKIPE BIT
	      MOVE BIT,BITS+^D36(BIT) ; 1B<36-i> identifies option

;Copy option code (assuming will copy it all, gets overwritten otherwise)

	    LDB OPT,RP		; Copy option (w/ possible CPYOPT)
	    DPB OPT,OPP
	    ILDB OPT,RP		; Get length
	    SUB RC,OPT		; Received bytes after this option
	    MOVEI OPL,-1(OPT)	; # bytes left to copy in this option
	    TRNN OPTS,(BIT)	; If User has also specified this option, or
	     CALL @OPTDOF(CX)	; Option shouldn't be returned, has error, or
	      CALL MERGED	; Is unknown, Drop it
	  ENDIF.
	  SKIPLE RC		; If more received option octets left and
	    JUMPG OPC,TOP.	; Have (some) room, loop
	ENDDO.

;Reached end (or ran out of space to merge rest).  Should unprocessed
;received options be an error?  End option list (but don't count END option).

	MOVX OPT,ENDOPT		; End options (may overflow
	DPB OPT,OPP		; into guard word ending UOPS)
	MOVE OPP,MXW(IORT)	; MAXxOW		Maximum option words
	LSH OPP,2		; Bytes
	SUB OPP,OPC		; Used bytes
	XMOVEI T2,UOPS		; Copy from merged

;T2/	Extended pointer to merged options
;OPP/	Number of merged option bytes
MERGE8:	;Enter here if no merge, just copy user to send

	ADDI OPP,3		;			Round bytes up to
	LSH OPP,-2		;			Option words used
	ADD OPP,MNW(IORT)	; <<MINxHS+3>/4>	Including header
	XCT SDO(IORT)		; STOR OPP,TxPDO,(TCB)	Set send header length
	MOVE T1,MXW(IORT)	; MAXxOW		Maximum option words
	XCT XTOO(IORT)		; XMOVEI T3,TCBxO(TCB)	To TCB image
	CALL XBLTA		;			Go the options

MNTM5	SKIPL T1+REGS		; Error?
MNTM5	 AOSA CELL(TCOMG,0,,TCO) ; MERGE calls
MNTM5	  AOS CELL(TCOMG,1,,TCO) ; MERGE errors
	RET

;MERGED	Drop option from net.

;RP/	Points at Len byte
;OPT/	Len of option
;OPL/	Len-1 of option
;OPC/	Len of option
;OPP/	Points at output option byte (already copied)
;	CALL MERGED
;RP/	Points at next option
;OPC/	Unchanged since none used
;OPP/	Unchanged since none used

MERGED:	ADJBP OPL,RP
	MOVEM OPL,RP		; Point at next
MNTM5	AOS CELL(TCOAA,3,,TCO)	; MERGED calls
	RET

;RRTCPY	Change Record Route from net into Strict Source Route for reply.

;RP/	Points at Len byte
;OPT/	Len of option
;OPL/	Len-1 of option
;OPC/	Len of option
;OPP/	Points at output option byte (already copied)
;	CALL RRTCPY	Sets T1+REGS lt 0 if error
;Ret+1:	  Option should be dropped
;Ret+2:	Option was copied and
;RP/	Points at next option
;OPC/	Count reduced if copied
;OPP/	Pointer updated if copied

RRTCPY:	PUSH P,[0]		; Turn it into a (trimmed) SSR
	MOVE T1,RP		; Peek ahead at
	ILDB T4,T1		; Pointer
	CAIN OPT,-1(T4)		; At end? (Len vs (Ptr)-1)
	IFSKP.
	  MOVE T1,OPT		; Len reserved for RRT
	  MOVEI OPT,-1(T4)	; Len actually used
	  SUB T1,OPT		; Unused bytes in RRT option
	  MOVEM T1,(P)		; Save for RP adjustment
	ENDIF.
	MOVX T1,SSROPT		; Change RRT
	DPB T1,OPP		; to SRT
	CALL NUSSR		; Process as Strict Source Route
	IFSKP.
				; OPL still Len-1, T1+REGS set
	  POP P,T1		; Unused bytes in RRT are
	  ADJBP T1,RP		; Skipped
	  MOVEM T1,RP		; over
	  AOS (P)		; All OK return
MNTM5	  AOS CELL(TCORR,0,,TCO) ; RRTCPY calls
	  RET
	ELSE.
	  ADJSP P,-1		; Clear stack of unused RRT bytes
MNTM5	  AOS CELL(TCORR,1,,TCO) ; RRTCPY errors
	  RET			; Dropped return
	ENDIF.

;LSRCPY	Invert Record Route or Loose  Source Route from net for reply.

;SSRCPY	Invert Record Route or Strict Source Route from net for reply.

;RP/	Points at Len byte
;OPT/	Len of option
;OPL/	Len-1 of option
;OPC/	Len of option
;OPP/	Points at output option byte (already copied)
;	CALL LSRCPY  or  SSRCPY  or  NUSSR	Sets T1+REGS lt 0 if error
;Ret+1:	  Option should be dropped
;Ret+2:	Option was copied and
;RP/	Points at next option
;OPC/	Count reduced if copied
;OPP/	Pointer updated if copied

LSRCPY:
MNTM5	AOSA CELL(TCORC,0,,TCO)	; LSRCPY calls
SSRCPY:				; Invert address list
MNTM5	  AOS CELL(TCORC,1,,TCO) ; SSRCPY calls

;Check that pointer is multiple of 4 and at end of route

	MOVE T1,RP		; Peek ahead at
	ILDB T4,T1		; LSR/SSR pointer
	TRNN T4,3		; Pointer multiple of 4 and
	 CAIE OPT,-1(T4)	; At end? (Len vs (Ptr)-1)
	IFNSK.
MNTM5	  AOS CELL(TCORC,2,,TCO) ; LSRCPY+SSRCPY bad pointer/end route
	  HRROI T1,EFT+^D02	; Error code (bad pointer)
	  MOVEM T1,T1+REGS	; Set it (ought to trap)
	  RET
	ENDIF.

;Must invert address list (Entry from record route)

NUSSR:	PUSH P,RC		; Save register for our use
	PUSH P,OPP		; Pointer to (copied) option code
	IDPB OPT,OPP		; Copy option length
	SUB OPC,OPT		; Remaining free bytes tobe
	JUMPL OPC,NDSSR		; Not enough space

	ILDB RC,RP		; Old pointer changed to
	LSH RC,-2		; Counter of addresses
	SUBI RC,1		; (omit code,len,ptr)
	MOVX OPT,4		; Initial pointer
	IDPB OPT,OPP

	PUSH P,[-1]		; Marker
	DO.
	  MOVX T4,<-4,,0>	; Collect 4-byte addresses
	  PUSH P,BHC ;[0]	; In the stack
	  MOVX T1,<POINT 8,(P),3> ; Point to it (right justified)
	  DO.
	    ILDB OPT,RP
	    IDPB OPT,T1		; Pack 4 octets per address
	    AOBJN T4,TOP.
	  ENDDO.
	  SOJG RC,TOP.		; Another address to pack
	ENDDO.
	DO.
	  MOVX T4,<-4,,0>	; Pack 4-byte addresses
	  MOVX T1,<POINT 8,(P),3> ; From top of stack (right justified)
	  DO.
	    ILDB OPT,T1
	    IDPB OPT,OPP	; Into send option
	    AOBJN T4,TOP.
	  ENDDO.
	  POP P,T1		; Save processed address
	  SKIPL (P)		; Reached marker?
	    LOOP.		; No, do another
	ENDDO.
	ADJSP P,-1		; Drop marker


;Check that destination is last address in route

	LOAD T4,TFH,(TCB)	; Destination must be last address in route
	CAMN T1,T4		; Same as last?
	  JRST NDSSR		; Yes all ok
	MOVE T1,(P)		; Pointer to option code byte
	MOVX OPT,LSROPT		; Adding address so make into loose route
	DPB OPT,T1
	ILDB OPT,T1		; Must increase length by another address
	ADDI OPT,4
	DPB OPT,T1
	SUBI OPC,4		; Using 4 more bytes
	IFGE. OPC		; Fits into leader
	  MOVEM T4,(P)		; Have to append destination address
	  MOVX T4,<-4,,0>	; Pack 4-byte addresses
	  MOVX T1,<POINT 8,(P),3> ; From top of stack (right justified)
	  DO.
	    ILDB OPT,T1
	    IDPB OPT,OPP	; Into send option
	    AOBJN T4,TOP.
	  ENDDO.
	ELSE.
	  HRROI T1,EFT+^D02	; Not enough space for (expanded) route
	  MOVEM T1,T1+REGS
MNTM5	  AOS CELL(TCORC,3,,TCO) ; LSRCPY+SSRCPY not enough space errors
	ENDIF.

NDSSR:	ADJSP P,-1		; Drop pointer to option byte
	ILDB OPT,RP		; Point at next received and
	ILDB OPT,OPP		; Send option position
	POP P,RC		; Restore register
	AOS (P)			; Skip return since processed
	RET

;TSPCPY	CCopy Received option if reserved space not all used.

;RP/	Points at Len byte
;OPT/	Len of option
;OPL/	Len-1 of option
;OPC/	Len of option
;OPP/	Points at output option byte (already copied)
;	CALL TSPCPY	Sets T1+REGS lt 0 if error
;Ret+1:	  Option should be dropped
;Ret+2:	Option was copied and
;RP/	Points at next option
;OPC/	Count reduced if copied
;OPP/	Pointer updated if copied

TSPCPY:
MNTM5	AOS CELL(TCOTC,0,,TCO)	; TCPCPY calls
	MOVE T1,RP		; Peek ahead at
	ILDB T4,T1		; Pointer
	CAIL OPC,(OPT)		; Drop if no space or
	 CAIN OPT,-1(T4)	; Not at end? (Len vs (Ptr)-1)
	IFNSK.			; Errors aren't worth complaining about
MNTM5	  AOS CELL(TCOTC,1,,TCO) ; TCPCPY drops
	  RET
	ENDIF.

;Fall into SIDCPY


;SIDCPY	Copy Received option.

;RP/	Points at Len byte
;OPT/	Len of option
;OPL/	Len-1 of option
;OPC/	Len of option
;OPP/	Points at output option byte (already copied)
;	CALL SIDCPY	Sets T1+REGS lt 0 if error
;Ret+1:	  Option should be dropped
;Ret+2:	Option was copied and
;RP/	Points at next option
;OPC/	Count reduced if copied
;OPP/	Pointer updated if copied

SIDCPY:				; Copy option
MNTM5	AOS CELL(TCOSC,0,,TCO)	; SIDCPY+TSPCPY calls
	SUB OPC,OPT		; Remaining free send bytes tobe
	IFGE. OPC		; Room to copy
	  DO.
	    IDPB OPT,OPP	; Copy length
	    ILDB OPT,RP		; and rest
	    SOJG OPL,TOP.	; Back if more
	  ENDDO.
	  ILDB OPL,OPP		; Both point at start of next
	ELSE.
	  HRROI T1,EFT+^D02	; Copy option
	  MOVEM T1,T1+REGS
MNTM5	  AOS CELL(TCOSC,1,,TCO) ; SIDCPY(+TSPCPY) errors
	ENDIF.
	AOS (P)			; Skip MERGED since copied it
	RET

;IP and TCP Information Tables

ICPY==CPYOPT	; IP copy-on-fragmentation
TCPY==0		; TCP doesn't have such a bit

DEFINE INFOW (NAM,INST)<NAM==.-..X
	INST
> ; End of INFOW


DEFINE INFO (W)<..X=.
INFOW(CPY,<W'CPY>);;			Copy-on-fragmentation bit
INFOW(LOF,<LOAD OPTS,T'W'OPF,(TCB)>);;	Get bits identifying user options
INFOW(LOR,<LOAD RC,T'W'POR,(TCB)>);;	Get # received option octets
INFOW(LOU,<LOAD OPP,T'W'POU,(TCB)>);;	Get # user option octets
INFOW(MNW,< <<MIN'W'HS+3>/4> >);;	Minimum # words in header
INFOW(MXW,<MAX'W'OW>);;			Maximum # words in header
INFOW(OTAB,<MSEC1,,W'OPNU>);;		Address of option code table
INFOW(POR,<POINT 8,TCB'W'R(TCB),7>);;	Byte pointer to received options
INFOW(SDO,<STOR OPP,T'W'PDO,(TCB)>);;	Set header data offset field
INFOW(SOF,<STOR OPTS,T'W'OPF,(TCB)>);;	Set bits identifying user options
INFOW(SOR,<STOR RC,T'W'POR,(TCB)>);;	Set # received option octets
INFOW(SOU,<STOR T3,T'W'POU,(TCB)>);;	Set # user option octets
INFOW(XFOR,<XMOVEI T2,TCB'W'R(TCB)>);;	(From) address of received options
INFOW(XFOU,<XMOVEI T2,TCB'W'U(TCB)>);;	(From) address of user options
INFOW(XTOO,<XMOVEI T3,TCB'W'O(TCB)>);;	(To) address for options to be sent
INFOW(XTOR,<XMOVEI T3,TCB'W'R(TCB)>);;	(To) address for received options
INFOW(XTOU,<XMOVEI T3,TCB'W'U(TCB)>);;	(To) address for user options
PURGE ..X
> ; End of DEFINE INFO


IPINFO:	INFO (I)		; IP Info Table

TCPINFO:INFO (T)		; TCP Info Table

IF2 <PURGE INFO,INFOW>

;Restore registers and clean up stack

OPRES:	MOVEI 11,REGS		; Saved registers
	HRLZS 11		; REGS,,0
	BLT 11,11		; Restore them

	SKIPE T1		; Error?
	  HRROS T1		; Yes, make sure negative
	RET			; To R: then to caller

	ENDTV.

	SUBTTL	TCP Buffer handling routines

	DEFAC (FX,Q3)		; Must agree with PROLOG, PAGEM

COMMENT	!

These are routines for mapping, reading, and writing buffers. Buffers
are  actually  in  the  address space of the fork executing a SEND% or
RECV%, but are manipuated by the TCP fork. Data is copied  only  once,
directly from (or to) the buffer into a packet (or vice versa).

Since  the  TCP  fork  must  guard against the page(s) containing the
buffer disappearing (unmapped, fork killed, etc), it  increments  the
share  count  on the SPT slot containing the calling fork's UPT. This
prevents the map from going away.  Subsequent  access  checking  will
discover that the page is missing and approriate errors returned.

SEND%  and  RECV%  buffer  headers  are  actually  formed by the MAKBFR
routine in TCPJS. They are queued on TCBSBQ or TCBRBQ for  action  by
the Packetizer or Reassembler.

!



;BUFHNT	Hunt for data for the JFN interface.

;T1/ Locked TCB Address
;CALL BUFHNT

BUFHNT::
	SAVEAC <TCB,BFR>
	MOVE TCB,T1		; put TCB into correct AC
	SETZ T1,		; no special flags
	LOAD BFR,TRCB,(TCB)	; get the receive buffer
	SETZRO TRCB,(TCB)	; no more receive buffer
	SKIPE BFR		; make sure have a buffer
	  CALL USRBFF		; user buffer filled
	RET			; and return to caller


;SETTUM	Set current process's (user or TCP fork) section 0 user map
;to be that of the buffer header or data.  This routine is called by the
;Reassembler and Packetizer to get the current data buffer mapped so it
;can reference it via previous context instructions.  It is also called
;by BFRDUN to map the buffer header so flags and updated counts may be
;returned.  It returns NOSKED; USTTUM is called after the transfers have
;been completed to restore the context and go OKSKED.

;T1/	0 - Setup buffer data mapping, NZ - Setup buffer header mapping
;BFR/	Extended Pointer to the current buffer descriptor block.
;TCB/	Extended Pointer to TCB for connection.
;	CALL SETTUM
;Ret+1:	Always. NOSKED

TCPUSC==0		; User section used for previous context mapping

SETTUM:	SAVEAC <FX>
MNTM5	AOS CELL(TCFAA,1,,TCF)	; Count calls to SETTUM
	IFE. T1			; Header or Data map?
	  LOAD T1,BDSPT,(BFR)	; SPT index of section map containing data
	ELSE.
	  LOAD T1,BHSPT,(BFR)	; SPT index of section map containing header
	ENDIF.			; T1/ SPT index for share pointer below

	NOSKED			; Prevent user from changing access
	MOVE T2,USECTB+TCPUSC	; Process's normal section 0 user map
	MOVEM T2,TCPUS0		; Save it around transfer

	MOVE T2,SHRPTR		; Prototype share pointer
	STOR T1,SPTX,+T2	; To SPT slot becomes
	MOVEM T2,USECTB+TCPUSC	; Current process's section 0 user map

	DATAI PAG,T1		; Get current pager status (UBA)
	TXZ T1,PGLACB+PGLPCS	; Ignore AC blocks & previous context section
	TXO T1,PGLUBR		; Say we want to load the User Base Register
	DATAO PAG,T1		; Which invalidates stale info in map

	XSFM T1			; Get previous context flags
	MOVEM T1,TCPUS0+1	; Save Previous Context Section
	TXZ T1,<PCU+37>		; Clear Previous Context User and Section
	IFQE. BFRMN,(BFR)	; Is buffer in monitor space, or
;cwl TDEC should imply BFRMN since SEND%/RECV% for DEC was from monitor context
	ANDQE. TDEC,(TCB)	; Is this a DEC TCB?
	  IORX T1,PCU+TCPUSC	; Set previous context to user section 0
	ENDIF.
	JSP T2,[XJRSTF T1]	; Return with PCU set so XCTU will work

	MOVX T1,PT%TSM		; Set TCP buffer maps
	TXNN FR,1B0		; TCB trace or
	 TDNE T1,MNTRAC		; Want trace?
	  CALL PRNPKT		; Yes
	RET

;USTTUM	Unmap buffer space.  Undoes SETTUM, returning OKSKED.

;BFR/	Extended pointer to buffer descriptor block
;NOSKED
;	CALL USTTUM
;Ret+1:	Always.  Returns OKSKED

USTTUM:	SAVEAC <FX>
MNTM5	AOS CELL(TCFAA,2,,TCF)	; Count calls to USTTUM

	MOVE T1,TCPUS0		; Get normal user section 0 map pointer
	MOVEM T1,USECTB+0	; Restore normal user section 0 map info

	DATAI PAG,T1		; Get current pager status (UBA)
	TXZ T1,PGLACB+PGLPCS	; Ignore AC blocks & previous context section
	TXO T1,PGLUBR		; Say we want to load the User Base Register
	DATAO PAG,T1		; Which invalidates stale info in map

	MOVE T1,TCPUS0+1	; Get saved previous context and section
	JSP T2,[XJRSTF T1]	; Restore PCU and Section (flags don't matter)

	MOVX T1,PT%TUM		; Unset TCP buffer maps
	TXNN FR,1B0		; TCB trace or
	 TDNE T1,MNTRAC		; Want trace?
	  CALL PRNPKT		; Yes

	OKSKED
	RET

;XFRDAT	Transfer data between user buffer and a packet.

;T1/	Source pointer (may index by TPKT)
;T2/	Dest pointer (may index by TPKT)
;T3/	Number of 8-bit bytes to transfer
;T4/	Non-0 says User-to-monitor transfer (Send direction)
;	CALL XFRDAT
;Ret+1:	Always.  T1, T2, T3 updated

;This is a cutdown version of BYTBLT which assumes 8-bit bytes and is
;able  to  cope  with  the source or destination pointers indexing by
;TPKT which is required to get extended addressing.

XFRDAT:	SAVEAC <FR>
	ACVAR <SRC,DEST,CNT,CNT2>
MNTM5	AOS CELL(TCFAA,4,,TCF)	; Count calls to XFRDAT
	PUSH P,T3		; Save initial count for histogram
	MOVE FR,T4		; Save the Send flag
	SKIPG CNT,T3		; Move count and test for early done
	  JRST XFRDAZ		; Zero byte move
	DMOVEM T1,SRC		; T1 to SRC and T2 to DEST
	CAIG CNT,20		; Short transfer? (must be ge 10!)
	  JRST XFRDA1		; Yes
	XOR T1,T2		; Set to compare
	TLC T2,(10B11)		; Flip the byte size
	TLNN T1,(77B11)		; Byte sizes agree?
	 TLNE T2,(77B11)	; And both are 8?
	  CAIA			; No, Something is fishy
	   JRST XFRDA3		; Yes, Go do it word-at-a-time
.SRC==SRC
.DEST==DEST
	BUG.(CHK,TCPMSX,TCPBFR,SOFT,
<XFRDAT: Byte size screwed up - src/dst>,<<.SRC,D>,<.DEST,D>>,<

Cause:	The routine which transfers data between user buffers and
	network packets has been called with a source or destination
	byte pointer which specifies something other than 8-bit bytes.

Action:	Notify the software staff if this happens.

Data:	The source byte pointer and the destination byte pointer.

>)

;Byte-at-a-time  mover. Use Extended Instruction Set if present.
;Here for byte-at-a-time move when EIS not on the machine.  Also
;used to finish up after other move routines.

XFRDA1:
REPEAT 0,<	; This doesn't work on the 2020.  (Why?)
IFNKA <
	CAIG CNT,4		; Is setup for MOVSLJ worth it?
	  JRST XFRDA2		; No.
	PUSH P,FR		; Save send flag
	MOVE FR,CNT		; Set source count
	MOVE T1,SRC		; Source ptr (local ptr, T2 not used)
	MOVE T3,CNT		; Set dest count
	MOVE T4,DEST		; Dst pointer (local ptr, T4+1 not used)
	SKIPN 0(P)		; Skip if send direction
	IFSKP.
	  XCT 2,[EXTEND [MOVSLJ]]
	    JRST XFRD10
	ELSE.
	  XCT 1,[EXTEND [MOVSLJ]]
XFRD10:	    BUG.(CHK,TCPMSY,TCPBFR,SOFT,<XFRDAT: MOVSLJ failure>,,<

Cause:	A MOVSLJ instruction with identical source and destination
	byte counts did not skip, indicating the source count was
	greater than the destination count.

Action:	ACs 0-5 contain the source/destination counts and pointers.
	Notify the software staff if this happens.

Data:

>)
	ENDIF.
	POP P,FR		; Recover flag
	MOVE SRC,T1		; Get updated source pointer
	MOVE DEST,T4		; Get updated dst pointer
	JRST XFRDAX		; Get out
	> ; End of IFNKA
> ; End of REPEAT 0

;Here for byte-at-a-time move when EIS not on the machine.
	JRST XFRDA2		; Go finish up

;Word-at-a-time movers.  Use BLT if no offset in positions.

XFRDA3:	DO.			; While 
	  TXNN DEST,70B5	; Dst not up to a word boundary yet or
	   TXNE SRC,40B5	; SRC is a 4410XX style pointer?
	  IFNSK.		; Bump both pointers by moving a byte.
	    IFN. FR		; Send direction
	      XCTBU [ILDB T1,SRC] ; Get a byte from user buffer
	      IDPB T1,DEST	; Put into packet
	      SOJA CNT,TOP.	; Back to check
	    ENDIF.		; Receive direction
	    ILDB T1,SRC		; Get a byte from packet
	    XCTBU [IDPB T1,DEST] ; Put into user buffer
	    SOJA CNT,TOP.	; Back to check
	  ENDIF.
	ENDDO.

	PUSH P,SRC		; Save pointers so left half can be
	PUSH P,DEST		; restored after using as local indirect
	LDB T1,[POINT 3,SRC,2]	; Position will be 04, 14, 24, or 34
	TXZ SRC,-1B12		; Clear reserved bits
	TXZ DEST,-1B12
	TXO SRC,IFIW		; Form local indirect pointers
	TXO DEST,IFIW
	IDIVI CNT,^D<36/8>	; Number of full words to move
	JUMPE T1,XFRDA8		; No offset in position.  Use BLT

; Offset move

XFRDA5:	ASH T1,3		; Number of bits present in T1
	MOVNI T3,-^D36(T1)	; Amount of shift required in loop
	MOVNI T4,-^D32(T3)	; Number left in T2 after 1st LSH
	SKIPN FR		; Sending?
	 SKIPA T1,@SRC		; No.  Source is packet in monitor space
	  UMOVE T1,@SRC		; Yes. Source is user buffer
	ADDI SRC,1		; Bump extended pointer
	LSH T1,-4		; Flush the extra bits

;Main move-shift loop (should be in ACs on KA10)

	DO.			; While full words remain to be moved
	  SKIPN FR		; Skip if send-direction
	   SKIPA T2,@SRC	; Get four more bytes from packet
	    UMOVE T2,@SRC	; Get four more bytes from user buffer
	  ADDI SRC,1		; Bump extended indirect word
	  LSHC T1,0(T3)		; Fill out 32 T1 bits and left justify
	  ADDI DEST,1		; Advance destination indirect word
	  SKIPN FR		; Skip if sending
	    UMOVEM T1,@DEST	; Store away in user buffer
	  SKIPE FR		; Skip if receiving
	    MOVEM T1,@DEST	; Store away in packet
	  LSHC T1,0(T4)		; Right justify rest from T2 into T1
	  SOJG CNT,TOP.		; Loop over all full words
	ENDDO. 
	POP P,T2		; Original DEST
	POP P,T1		; Original SRC
	HLL SRC,T1		; Restore position and size fields
	HLL DEST,T2		; Index and indirect bits wont change
	SOJA SRC,XFRDA9		; Undo the last increment

; No offset, use BLT.  SRC and DEST were 0410xx,,Y-1

XFRDA8:	MOVE T1,CNT		; Get count
	XMOVEI T2,@SRC		; Get source address and
	XMOVEI T3,@DEST		; Destination
	ADDI T2,1		; Byte ptrs were at end of previous word
	ADDI T3,1
	IFE. FR			; Send direction
	  HRRZS T3		; Destination is user section 0
	  CALL BLTMU		; Move to user
	ELSE.			; Receive direction
	  HRRZS T2		; Source is user section 0
	  CALL BLTUM		; Move from user
	ENDIF.
	POP P,DEST		; Original DEST
	POP P,SRC		; Original SRC
	ADD SRC,CNT
	ADD DEST,CNT		; Advance pointers

;Exit for word-at-a-time movers.

XFRDA9:	SKIPN CNT,CNT2		; Number left in partial word
	IFSKP.			; Finish them and return

;Used to finish up after other move routines.

XFRDA2:	  IFN. FR		; Send direction
	    DO.
	      XCTBU [ILDB T1,SRC] ; Get a source byte from user buffer
	      IDPB T1,DEST	; Put it into packet
	      SOJG CNT,TOP.	; Loop til done
	    ENDDO.
	  ELSE.
	    DO.			; Receive direction
	      ILDB T1,SRC	; Get a source byte from packet
	      XCTBU [IDPB T1,DEST] ; Put it into user buffer
	      SOJG CNT,TOP.	; Loop til done
	    ENDDO.
	  ENDIF.
	ENDIF.			; Partial word

; Common exit

XFRDAX:	DMOVE T1,SRC		; Get updated pointers
	SETZ T3,		; Return a count of 0
XFRDAZ:

; Histogram transfer size, (P) has initial count

	EXCH T3,(P)		; Get initial, save final
MNTM5<	SUB T3,(P)>		; Bytes transferred
MNTM5<	PUSH P,T1>
MNTM5<	MOVEI T4,CELL(TCFHR,0,,TCF)> ; Locate receive histogram
MNTM5	SKIPN FR
MNTM5<	  MOVEI T4,CELL(TCFHS,0,,TCF)> ; Locate send histogram
MNTM5	INHIST(,,T3,T4,T1)	; Histogram T3, into T4, using T1 (CELL()
MNTM5<	POP P,T1>

	POP P,T3		; Final count (bytes not transferred)
	RET

	ENDAV.
	SUBTTL	TCP Retransmitter

	COMMENT	!

The Retransmitter task is call from the top level of the TCP when a
connection deadline has elapsed.  The single packet at the head of the
restransmission queue is sent again and its retranmission interval
adjusted.  Should the maximum persistence of some message be exceeded,
the user is notified and the connection aborted.

Two retransmission strategies are available.  The old initial interval
with backoff and the "newer" dynamic method.

The "newer" method is the default;  it is specified by a
"retransmission parameters word" (OPEN%, SEND%) of zero.  It uses a
smoothed round trip time estimate based on the formula:

	SRTT = SRTT(last) * alpha + RTT * (1-alpha)

and the packet retransmission interval is computed by

	RXI = SRTT * beta

where	SRTT	is TSMRT	(initial value is TPRX0)
	alpha	is either

TSMRT .lt. RTT:	   TPRXD	(scaled by 2**-(TPRXF)), or
TSMRT .ge. RTT:	   TPRXI	(scaled by 2**-(TPRXF))

	RTT	is TODCLK(ACK)-PTG
	beta	is TPRXV	(scaled by 2**-(TPRXF))
	RXI	is PRXI

The  old  method is specified if the "retransmission parameters word"
has ever been non-zero. It computes the  minimum  and  maximum  round
trip  times  for  all packets in a TCPBG0 msec interval and then sets
the estimated retransmission time (TRXI, initial value from RX  param
word,  or TPDXI if 0) to one-half second above the average estimated
round trip time. With each  retransmission  of  a  packet,  the  next
retransmission   interval   is   the  current  value  *  numinator  /
denominator (each from the RX param word or TPDXN, TPDXD).

!


;REXMIT	Retransmit for a connection.

;TCB/	Extended Locked connection block. (Dequeued from RX queue)
;	CALL REXMIT
;Ret+1:	Always

REXMIT::			; Only global if two parts
	SAVEAC <PKT,TPKT>
	ACVAR <LINBLK,NXRXI>
MNTM5	AOS CELL(TCXRX,0,,TCX)	; REXMIT calls
	SETO LINBLK,		; Assume not a TVT

	XMOVEI T1,TCBRXQ(TCB)	; Pointer to the retranmit queue
	LOAD PKT,QNEXT,(T1)	; Set pointer to first thing on queue
	CAME PKT,T1		; Check if RX queue is empty
	IFSKP.
MNTM5	  AOS CELL(TCXRX,1,,TCX) ; Useless RX call - RX queue was empty
	  JRST REXMIX		; Queue empty, all done.
	ENDIF.
IFN PKTQ,<XMOVEI PKT,-PKTQ(PKT)> ; Point to top of structure

	LOAD NXRXI,PRXI,(PKT)	; Get the current retransmit interval

	MOVE CX,$PINTL(PKT)	; Get packet flags
	TXNN CX,PINTL		; Make sure last transmission is done
	IFSKP.
	  INCRNO TCRXF,(TCB)	; Cannot RX if last still unsent, for conn.
MNTM5	  AOS CELL(TCXRX,2,,TCX) ; Slow net in REXMIT
	  JRST REXMI9		; Go check again later
	ENDIF.

	LOAD T1,PLNDE,(PKT)	; Time of last transmission (completed)
	ADD NXRXI,T1		; Plus interval is time to RX
	SUB NXRXI,TODCLK	; Interval before "this" RX
	CAMG NXRXI,TPNOW+1	; If within 100 msec, RX now, don't reschedule
	IFSKP.
MNTM5	  AOS CELL(TCXRX,3,,TCX) ; Reschedule RX due to slowness
	  JRST REXMI9		; Not yet time, go reschedule
	ENDIF.

;TVT processing

	IFQN. TTVT,(TCB)	; TVT
MNTM5	  AOS CELL(TCXRX,5,,TCX) ; REXMIT for TVT
	  LOAD T2,TVTL,(TCB)	; Get the line number
	  ANDG. T2		; TVTL may be 0 if RXing a SYN, or gone away
	    CALL LCKTTY		; Lock and get ptr to dynamic block
	       SKIPLE T2	; Not init'd yet
	     SKIPA LINBLK,T2	; All ok, remember dynamic block address
	       CALL ULKTTY	; Bad, unlock (if required), LINBLK is -1
	ENDIF.

;Common processing

MNTM5	AOS CELL(TCXRX,4,,TCX)	; REXMIT for either TVT or user
	PNTLDR TPKT,PSSDT,(PKT)	; Pointer to TCP header
	SKIPL TCPON		; Force error if TCP is turned off
	IFSKP.			; Still on

;If this is the first retransmission of this packet, reinitialize
;the retransmission parameters (Initial interval and discard
;time).   Since this is done as each packet appears at Send-Left,
;timeouts are avoided in the case where the receiver is very slow.

	  IFQE. PRXD,(PKT)	; Pkt has not been RX'd at least once
MNTM5	    AOS CELL(TCXRX,6,,TCX) ; First retransmission by REXMIT
	    LOAD T1,PSEQ,(TPKT)	; Packet sequence number
	    LOAD T2,TSLFT,(TCB)	; Send Left
	    LOAD T3,PESEQ,(PKT)	; End sequence of the Packet
	    CALL CHKWND		; Is Left within this Pkt?
	    SKIPE T1
	      CALL SETRXP	; Yes, re-initialize the RX parameters
	    JRST REXMI4		; Retransmit
	  ENDIF.

;This packet has already been retransmitted.
;Check for Retransmission timeout.

	  LOAD T1,PDCT,(PKT)	; Get discard time for this pkt
	  JUMPE T1,REXMI4	; Jump if no discard time specified
	  CAML T1,TODCLK	; Packet undeliverable?
	    JRST REXMI4		; Not yet.

	  IFQN. TSRX,(TCB)	; If "Don't kill conn. on RTX TIMOT" bit
	    LOAD T1,TSTO,(TCB)	; Get transmission timeout
	    LOAD T2,PDCT,(PKT)	; Send time out set by user
	    SKIPE T1		; Use 0 if none specified
	      ADD T1,T2		; Else compute the new deadline
	    STOR T1,PDCT,(PKT)	; Set the discard time in the packet
	    MOVX T1,XLT+^D09	; "Retransmission timeout"
	    MOVX T2,TCPX32	; Transmission timeout
	    CALL USRERR		; Set TERR and TCERR from T1 and T2
	    JRST REXMI4		; Keep going
	  ENDIF.
	ENDIF.

;A pkt has not been ACKed within the (send) timeout specified by the user,
;or TCP has been shut off (TCPON is 0)

REPEAT 1,<
;cwl this should now be archaic ... leave it until all older systems fixed
;Fake  input  of an ACK for final outstanding FIN. This occurs if the
;final ACK gets lost in the network  for  more  than  the  prescribed
;number  of  seconds.  It  is  necessary because the final ACK cannot
;itself be ACKd and therefore cannot have guaranteed delivery. Note,
;however that one of the FIN's retransmissions should elicit an ACK.

	LOAD T2,TRSYN,(TCB)	; Just missing ACK to our FIN?
	LOAD T3,TSSYN,(TCB)
	CAIN T2,NOTSYN
	 CAIE T3,FINSNT
	IFSKP.			; Yes
MNTM5	  AOS CELL(TCDFA,1,,TCD) ; Count fakes
	  SETONE TCFAK,(TCB)	; Record it was done

	  XMOVEI T1,TCBRXQ(TCB)	; Pointer to the Retransmit queue
	  LOAD T2,TSLFT,(TCB)	; Send Left
	  LOAD T3,TSSEQ,(TCB)	; Send Sequence (1 after FIN)
	  CALL REMRXQ		; Clear all that are outstanding
	  JRST REXMIX
	ENDIF.
> ; End of REPEAT 1

;Abort connection

	MOVX T1,ELP+^D09	; "Retransmission timeout"
	MOVX T2,TCPX32		; Transmission timeout
	CALL USRERR		; Set TERR and TCERR from T1 and T2
				; T1 now zero if interrupt sent
	IFN. T1			; For compatability, abort if interrupts not on
	  MOVX T1,ELP+^D14	; "Connection reset"
	  CALL ABTCON		; Abort the connection, T1 non-zero if "abort"
	  SKIPE T1		; It should never skip
	    CALL ABTREP		; T1 not zero, send a RESET
	ENDIF.

MNTM5	AOS CELL(TCXRX,7,,TCX)	; Connections aborted by REXMIT
	SETONE TCABR,(TCB)	; Reason for abort - rx timeout
	JRST REXMIX		; Return to caller

;Try to repacketize before retransmission

REXMI4:	CALL REPKTZ		; Try to combine packets

;Set count of packets in TCBRXQ at retransmission for ack processing

	LOAD T1,TCRXC,(TCB)	; Count of packets in RX queue at last RX
	LOAD T2,QCNT,+TCBRXQ(TCB) ; Count of packets currently in RX queue
	CAMGE T1,T2		; Already have maximum
	  STOR T2,TCRXC,(TCB)	; Update count of packets in RX queue at RX

;Re-transmit the packet.  Restore parts of IP header that might have changed.

	LOAD T1,TTTL,(TCB)	; Reset time to live
	STOR T1,PITTL,(PKT)
	LOAD T1,TFH,(TCB)	; Reset the destination host
	STOR T1,PIDH,(PKT)
	CALL TCPIIO		; Hope user hasn't changed the options

	MOVE NXRXI,TPRXW	; Time to use if zero window (note that
	IFQN. TSWND,(TCB)	; PRXI is unchanged but won't look til later)
	ANDQE. TDBGQ,(TCB)	; Faking zero send window? Jump if so

	  IFQN. <TRXPN,TRXPD>,(TCB) ; Use static method
	    LOAD T1,PRXI,(PKT)	; Get the current retransmit interval
	    LOAD T2,TRXPN,(TCB)	; Numerator of backoff ratio
	    LOAD T3,TRXPD,(TCB)	; Denominator
	    IMULI T1,0(T2)
	    IDIVI T1,0(T3)

	  ELSE.			; Use dynamic method

;Estimates based only on round trip time are essentially constant
;retransmissions, which looses if a large round trip time is usual.

MNTM5	    AOS CELL(TCXRX,11,,TCX) ; REXMIT using RSRE algorithm
	    IFQE. PRXD,(PKT)	; If never rx'd, use round trip estimate
	      LOAD T1,TSMRT,(TCB) ; Get reliable estimated round trip time
	      LOAD T2,TUNRT,(TCB) ; Unreliable component
	      TXNE T3,TCS%RX	; Include retransmitted info?
	        ADD T1,T2	; Yes
	    ELSE.		; Multiple retransmissions
	      LOAD T2,PLNDE,(PKT) ; Time packet last sent
	      MOVE T1,TODCLK	; Now
	      SUB T1,T2		; Time since last transmission for backoff
	    ENDIF.
	    CALL BYBETA		; Backoff factor uses beta
	  ENDIF.

	  CAMLE T1,TPRXX	; Limit to maximum
	    MOVE T1,TPRXX
	  CAMGE T1,TPRXN	; Limit to minimum
	    MOVE T1,TPRXN
	  STOR T1,PRXI,(PKT)	; Store back in the packet header
	  MOVE NXRXI,T1		; Save for signal
				; could add "average output queue delay"
				; to reduce TCXRX+3 rescheduling
	ELSE.
MNTM5	  AOS CELL(TCXRX,10,,TCX) ; RX into zero window (NXRXI already set)
	ENDIF.

	INCRNO TCRXP,(TCB)	; Retransmitted packets for connection
MNTM5	AOS CELL(TCXRX,12,,TCX)	; Retransmitted packets

;Before queueing the packet for an interface, set RXd flag

	SETONE PRXD,(PKT)	; Indicate that packet has been RXd
	MOVX T1,PT%TRX		; Being retransmitted
	TXNN FR,1B0		; TCB trace or
	 TDNE T1,MNTRAC		; Want trace?
	  CALL PRNPKT		; Yes

	XMOVEI T1,RXDLAY	; Select the retransmitter delay histogram
	CALL TSTAMP		; Process/update the timestamp
	SKIPN STATF		; Taking statistics right now?
	IFSKP.
	  XMOVEI T1,OP+PRCTMR	; Select a time accumulator
	  XMOVEI T2,EMTPKT	; Function to call
	  MOVE T3,LINBLK	; TVT block if any
	  CALL TIMCAL		; Time the call
	ELSE.
	  MOVE T1,LINBLK	; TVT block if any
	  CALL EMTPKT		; Send off the packet
	ENDIF.
	AOS RXPKCT		; Count retransmitted packets

;Now reschedule Retransmitter to run again when this packet should
;again be retransmitted

REXMI9:	XMOVEI T1,RX		; What to signal
	MOVE T2,NXRXI		; The desired interval
	CALL SIGNAL		; Cause ourself to run later

REXMIX:	SKIPL T2,LINBLK		; Running for a TVT?
	  CALL ULKTTY		; Yes.  Unlock it
	RET

	ENDAV.

;REPKTZ	Repacketize before retransmission.

;PKT/	Extended Packet pointer
;TPKT/	Extended pointer to TCP header
;TCB/	Extended Locked connection block
;	CALL REPKTZ
;Ret+1:	Always.

SIZ==T2	; Number of bytes to be copied into packet being enlarged
OBP==T3	; Byte pointer (using PKT) in PKT for next byte to be inserted
SPC==T4	; Number of free bytes remaining in PKT

REPKTZ:
MNTM5	AOS CELL(TCXRZ,0,,TCX)	; REPKTZ calls
	JN <PSYN,PFIN>,(TPKT),R	; Forget packets with controls

	LOAD SPC,PMXSZ,(PKT)	; Max PIPL
	LOAD OBP,PIPL,(PKT)	; Actual PIPL / bytes to current end of packet
	SUB SPC,OBP		; Remaining free space
	CAIGE SPC,10		; Make sure some space available
	  RET			; Not enough to bother with

	ACVAR <IBPES,NPKT,TNPKT,CNT>
;IBPES	End sequence number of last byte in PKT,  or
;	Byte pointer (using TNPKT @ TCP data) into NPKT of next byte to copy
;NPKT	Pointer to packet being combined into PKT
;TNPKT	Pointer to TCP header (or TCP data) in NPKT
;CNT	Number of packets which have been combined into PKT

	SETZ CNT,		; No packets combined
	ADJBP OBP,[POINT 8,PKTELI(PKT)] ; Byte pointer to next byte
	MOVE NPKT,PKT		; Pointer to find "next" packet to be RXed
	LOAD IBPES,PESEQ,(PKT)	; Next octet to be moved into PKT

	DO.		; Have valid NPKT (last repacketized) & it's IBPES
	  LOAD NPKT,QNEXT,+PKTQ(NPKT) ; Next packet in queue
	  XMOVEI CX,TCBRXQ(TCB)
	  CAMN NPKT,CX		; If queue head,
	    EXIT.		; No more to be combined
	  XMOVEI NPKT,-PKTQ(NPKT) ; Point to top of packet structure

	  LOAD SIZ,PESEQ,(NPKT)	; End of next packet to be combined
	  SUB SIZ,IBPES		; Less end of current packet is
	  MODSEQ SIZ		; # bytes to be copied
	  CAILE SIZ,200000	; If negative,
	    LOOP.		; Skip to next (?? ought to bugchk)

	  CAMLE SIZ,SPC		; Will it all fit into current packet?
	    EXIT.		; No, don't copy, will have to RX NPKT anyway

	  PNTLDR TNPKT,PSSDT,(NPKT) ; Locate TCP header
	  JN <PSYN,PFIN>,(TNPKT),ENDLP. ; Don't combine controls

	  AOS CNT		; Combined another packet
	  IFQN. PPSH,(TNPKT)	; If packet has PUSH
	    SETONE PPSH,(TPKT)	; Copy it
	  ENDIF.
	  JUMPE SIZ,TOP.	; If no data (Push without data?), skip to next

	  LOAD CX,PSEQ,(TNPKT)	; Start of data
	  SUB IBPES,CX		; Data offset into packet for first byte needed
	  MODSEQ IBPES
	  ADJBP IBPES,[POINT 8,(TNPKT)] ; Byte pointer there
	  PNTLDR TNPKT,PAPDT,(NPKT) ; Address of TCP data

	  SUB SPC,SIZ		; Remaining free space in packet being enlarged
	  LOAD T1,PIPL,(PKT)	; Update it's current length
	  ADD T1,SIZ
	  STOR T1,PIPL,(PKT)
	  STOR T1,PTPBZ,(PKT)	; Let EMTPKT do PSSBZ and PAPBZ later
	  DO.
	    ILDB T1,IBPES	; Copy data bytes
	    IDPB T1,OBP
	    SOJG SIZ,TOP.	; Back if more
	  ENDDO.

	  LOAD T1,PDCT,(NPKT)	; Keep packet a little longer
	  STOR T1,PDCT,(PKT)
	  LOAD IBPES,PESEQ,(NPKT) ; End of copied packet
	  STOR IBPES,PESEQ,(PKT) ; Becomes end of current (& for loop)
	  JUMPGE SPC,TOP.	; Back for more (maybe just a PUSH?)
	ENDDO.

	IFG. CNT		; Anything merged?
MNTM5	  AOS CELL(TCXRZ,1,,TCX) ; REPKTZ enlarged a packet
MNTM5<	  ADDM CNT,CELL(TCXRZ,2,,TCX)> ; Packets combined by REPKTZ
	  AOS T1,TCPSID		; Get the next segment ID
	  STOR T1,PISID,(PKT)	; So IP reassembly will work
	ENDIF.
	RET

	ENDAV.
	PURGE SIZ,OBP,SPC

;SETRXP	Initialize retransmission parameters in a packet.

;PKT/	Extended Packet pointer
;(TPKT/	Extended pointer to TCP header)
;TCB/	Extended Locked connection block
;	CALL SETRXP
;Ret+1:	Always

SETRXP:
MNTM5	AOS CELL(TCXAA,1,,TCX)	; SETRXP calls

;Set packet discard time

	LOAD T1,TSTO,(TCB)	; Send time out set by user
	SKIPE T1		; Use 0 if none specified
	  ADD T1,TODCLK		; Else compute the deadline
	STOR T1,PDCT,(PKT)	; Set the discard time in the packet

;Set initial retransmission interval
; Optionally adjust retransmission interval by packet size/baud rate

	LOAD T1,PTPBZ,(PKT)	; Get transport length
	CALL BYT2MS		; Bytes to msec in T1 (0 if not TCS%BR)
				; NB: T3 set to TCPSW

; Static or Dynamic Algorithm

	IFQN. <TRXPN,TRXPD>,(TCB) ; Static algorithm
	  LOAD T2,TRXI,(TCB)	; Get estimated Retrans. Interval.
	  SKIPG T2		; Guard against bad extimate of rnd trip
	    MOVE T2,TPDXI	; Choose default interval in that case
	  ADD T1,T2		; Maybe have baud rate diddle
	  LOAD T2,TRXPI,(TCB)	; Get possible user setting
	  IMULI T2,^D1000	; Convert to milliseconds
	  SKIPE T2		; Did user set retrans parameters?
	    MOVE T1,T2		; Yes.  Use that initial interval
	ELSE.			; Use dynamic method
	  LOAD T2,TSMRT,(TCB)	; Get reliable estimated round trip time
	  ADD T1,T2		; Maybe have baud rate diddle
	  LOAD T2,TUNRT,(TCB)	; Unreliable component
	  TXNE T3,TCS%RX	; Include retransmitted info?
	    ADD T1,T2		; Yes
	  CALL BYBETA		; Increase by (scaled) variance
	ENDIF.


; Optionally adjust retransmission interval by integer load average

	MOVE T2,IRJAV		; Use integer load average
	ADDI T2,5		;  plus 5...
	IMULI T2,^D1000		;  as min rx interval
	CAIGE T1,(T2)		; Is it less than min?
	 TXNN T3,TCS%LA		; Use load average?
	  CAIA			; No
	   MOVEI T1,(T2)	; Yes, use min.


	CAMLE T1,TPRXX		; Keep within bounds
	  MOVE T1,TPRXX
	CAMGE T1,TPRXN		; both ends.
	  MOVE T1,TPRXN

	STOR T1,PRXI,(PKT)	; Set packet retrans interval
	RET



;BYT2MS	Convert bytes to msec at current estimated baud rate

;T1/	Bytes
;TCB/	Connection block
;	CALL BYT2MS
;T1/	Msec, or 0 if not using baud rate adjustments
;T3/	TCPSW (expected by some callers)

BYT2MS:	MOVE T3,TCPSW		; Switches (preserved for use below)
	TXNN T3,TCS%BR		; Want baud rate adjustments?
	IFSKP.			; Yes
	  LOAD T2,TSESB,(TCB)	; Estimated baud rate
	  ANDG. T2		; No divide by zero
	    IMULI T1,^D8000	; Bytes to milli-bits
	    IDIV T1,T2		; To msec
	ELSE.
	  SETZ T1,		; No time
	ENDIF.
	RET

;RXPARS	Change retransmission parameters.

;Called by SEND% and OPEN% which allow the caller to change the
;retransmission characteristics -- Backoff rate and initial
;retransmission interval.

;TCB/	Extended Locked Connection Block
;T1/	Retrans. parameter word.  Format is that of TRXP.
;	CALL RXPARS
;Ret+1:	Always.

;Note:  Newly created TCBs have 0 in the TRXP word which
;means that the user has not chosen to override the use of
;measured round trip time as the way of selecting the retrans
;interval.  If the user sets TRXP, those parameters are used.

RXPARS::
MNTM5	AOS CELL(TCXRP,0,,TCX)	; RXPARS calls
	JUMPE T1,R		; No change wanted

	LOAD T2,TRXP,(TCB)	; Current settings
	CAMN T1,T2		; Different?
	  RET			; No.

MNTM5	AOS CELL(TCXRP,1,,TCX)	; RXPARS changed RX parameters

	STOR T1,TRXP,(TCB)	; Put them in place for LOADs
	LOAD T2,TRXPN,(TCB)	; Get numerator
	LOAD T3,TRXPD,(TCB)	; and denominator of backoff fraction
	LOAD T4,TRXPI,(TCB)	; Initial interval in seconds

	SKIPN T2		; Get defaults
	  MOVE T2,TPDXN
	SKIPN T3
	  MOVE T3,TPDXD
	SKIPN T4
	  MOVE T4,TPDXI
	CAMLE T3,T2		; Prevent interval from decreasing
	  MOVE T3,T2
	STOR T2,TRXPN,(TCB)	; Set it all into the TCB
	STOR T3,TRXPD,(TCB)
	STOR T4,TRXPI,(TCB)
	RET

;ABTCON	Abort a connection, deciding whether "abort" or just "release
;resources".  Clears queues and forces send and receive buffers back to the
;user with the (argument) Code.  The connection is set to Not Synchronized
;(unless just releasing resources and in TIMWAT).  Called from (the ABORT%
;JSYS /TCPCZF via) ABTTCB and from PRCRST.

;TCB/	Extended Locked Connection Block
;T1/	Event Code	ELT+^D04 - no free TVTs (USREVT w/TVTOPN failure)
;			EFP+^D07 - RST received (PRCRST)
;			ELP+^D07 - connection aborted (PKTIZE w/TSABT)
;			EFP+^D14 - received ICMP dest. unr.  or  par. prob.
;			ELP+^D14 - reset due to timeout (REXMIT)
;			ELP+^D14 - inactivity (DEADP)
;			ELP+^D14 - ABTTCB from ABORT%, CLZFF%, RESET%, LGOUT%
;	CALL ABTCON
;Ret+1:	Always, T1 non-zero if "abort", zero if "release resources".

ABTCON::
	SAVEAC <PKT>
	ACVAR <CODE,VAL,BFQ,NXTBFQ>
MNTM5	AOS CELL(TCIAA,4,,TCI)	; Count calls to ABTCON
	MOVEM T1,CODE
	SETZ VAL,		; Assume just releasing resources

;Packet buffers flushed via USRBFE/F are placed onto the TCPDBQ by
;BFRDUN if they have wait bits assigned (to wait for interrupt),
;others are returned directly to free storage.

;	MOVE T1,CODE
	CALL FLSSBF		; Flush SEND% buffers
	ADDM T1,VAL		; If any flushed, "abort"ing

	MOVE T1,CODE
	CALL FLSRBF		; Flush RECV% buffers
	ADDM T1,VAL		; If any flushed, "abort"ing

ABTCO1:	DO.			; Flush packets from Retransmission Queue
	  XMOVEI CX,TCBRXQ(TCB)	
	  LOAD T1,QNEXT,(CX)	; Get first thing on Retrans Q
	  CAMN T1,CX		; Is that the head itself?
	    EXIT.		; Yes.  The queue is now empty.
	  AOS VAL		; If any flushed, "abort"ing
	  XMOVEI PKT,-PKTQ(T1)	; Point to top of structure
	  CALL DQ		; Remove from the Retransmission queue
	  SETZRO PLNCR,(PKT)	; Forget completion routine
jfcl;	  SETONE PPRAX,(PKT)	; Don't bother sending it
jfcl;cwl test this
	  MOVX CX,PPROG		; Program level now has no claim on PKT
	  ANDCAB CX,PKTFLG(PKT)
	  TXNN CX,PFLGP		; Anyone else using packet?
	    CALL RETPKT		; We were last user, release packet
	  LOOP.
	ENDDO.

ABTCO2:	DO.			; Flush packets from Received Packet Queue
	  XMOVEI CX,TCBRPQ(TCB)
	  LOAD T1,QNEXT,(CX)
	  CAMN T1,CX		; Queue head?
	    EXIT.		; Yes
	  AOS VAL		; If any flushed, "abort"ing
	  XMOVEI PKT,-PKTQ(T1)	; Point to top of structure
	  CALL DQ		; Dequeue packet
	  CALL RETPKT		; Release packet buffer
	  LOOP.
	ENDDO.

	SKIPN TCQPZ(TCB)	; DQ this TCB from the PACKETIZER if necessary
	IFSKP.
	  XMOVEI T1,PZ+PRCLCK	; Must lock process to change queue
	  XMOVEI T2,ABTCOP	; Routine to do the work
jfcl;	  TLO T2,<0B8>		; ABTCON/ Use PROC as ID
	  CALL LCKCAL		; Lock PZ & dequeue this TCB
	ENDIF.

;Flush any Partially Filled Packet

	NOSKED			; Prevent changes to queues

;Collect Buffers for this TCB from TCPBDQ and place them on TCPIDQ,
;releasing any BIDX wait bits.  Will release them all after go OKSKED.

	LOAD NXTBFQ,QNEXT,+TCPBDQ ; Pointer to first entry in queue @ BFRQ
ABTCO3:	DO.
	  MOVE BFQ,NXTBFQ	; Next Buffer to be checked @ BFRQ
	  LOAD NXTBFQ,QNEXT,(BFQ) ; Get next item in the list for next time
	  CAMN BFQ,TCPBDQ	; Back to head means done
	    EXIT.
	  LOAD T1,BTCB,-BFRQ(BFQ) ; Get owning TCB
	  CAME T1,TCB		; Is it this connection?
	    LOOP.		; No, go check next Buffer
	  MOVE T1,BFQ
	  CALL DQ		; Remove it
	  LOAD T1,BIDX,-BFRQ(BFQ) ; Get the wait bit index
	  SKIPE T1		; Have one?
	    CALL RELWTB		; Yes, release it
	  MOVE T1,BFQ		; Pointer to the block again
	  MOVE T2,TCPIDQ	; Where to stash the buffer for later
	  CALL NQ		; Release when OKSKED
	  LOOP.
	ENDDO.

	LOAD PKT,TSCPK,(TCB)	; Possible current packet
	SETZRO TSCPK,(TCB)	; Is gone

	OKSKED

	IFN. PKT		; If had a current packet,
	  AOS VAL		; TCB is being "abort"ed
	  CALL RETPKT		; Release it
	ENDIF.

ABTCO4:	DO.			; Return all buffers to free storage
	  MOVE CX,TCPIDQ	; Locate queue head	  
	  LOAD T1,QNEXT,(CX)	; Get pointer to next item
	  CAMN T1,CX		; If it is the queue head,
	    EXIT.		; Done, queue flushed of Buffers
	  CALL DQ		; Remove Buffer from the queue
	  XMOVEI T1,-BFRQ(T1)	; Point to top of structure
	  CALL RETBLK		; Return block to free storage
	  LOOP.
	ENDDO.

;Force state to NOT.NOT if "abort"ing

	LOAD T1,TRSYN,(TCB)	; Get Receive state
	LOAD T2,TSSYN,(TCB)	; Get Send state
	IFE. VAL		; Anything Flushed?
				; No, maybe just "releasing"
	  CAIE T1,NOTSYN	; If receive side is NOTSYN, or
	   CAIN T1,TIMWAT	; TIMWAT, and
	    CAIE T2,NOTSYN	; Send side is NOTSYN
	  ANSKP.		; Isn't, "abort"ing
				; Just releasing
	ELSE.
	  AOS VAL		; "Abort"ing
	  MOVX T1,NOTSYN
	  STOR T1,TRSYN,(TCB)	; Set Recv state to Not Synchronized
	  STOR T1,TSSYN,(TCB)	; Set Send state to Not Synchronized
	ENDIF.

;Notify the user

	MOVE T1,CODE
	CALL USREVT		; State-change interrupt - connection closed

	MOVE T1,VAL		; Return result
	RET

	ENDAV.

ABTCOP:	SKIPN TCQPZ(TCB)	; Check if TCB queued for PZ after have lock
	  RET			; Gone, PZ must have snuck in
	XMOVEI T1,TCQPZ(TCB)	; PZ queue locked,
	CALLRET DQ		; DQ this TCB

> ; End of IFG PART-0
IFE PART-1,<LTCPT4:	LIT >
IFL PART-2,<
	SUBTTL	TCP Delayed Actions



COMMENT	!

Delayed  actions  are  those things which must happen after some time
delay. No event in the TCP can  be  counted  on  to  kick  off  these
functions.

!


;EXITMW
;Exit from the TIME WAIT state by descheduling DY; the connection is
;NOT-NOT.

;TCB/	Extended Connection block (locked)
;	CALL EXITMW
;Ret+1:	Always.

EXITMW::
MNTM5	AOS CELL(TCDFA,0,,TCD)	; Count calls
	MOVX T1,NOTSYN
	STOR T1,TRSYN,(TCB)
	RET


	SUBTTL	TCP Background Routines

COMMENT	!

Routines  run  periodically at a low rate to check for things such as
dead (closed) TCBs and connections which need to be  poked  in  order
that they resynchronized.

!

;BACKG		Top level of background
;	CALL BACKG
;Ret+1:	Always

BACKG::	SAVEAC <BFR,TPKT,PKT,TCB>

MNTM5	AOS CELL(TCKBG,0,,TCK)	; Count calls
	CALL UPDTCK		; Update time
	MOVEI T1,TCBHLK		; Which lock to set
	XMOVEI T2,SCAN		; Function to run
jfcl;	TXO T2,<0B8>		; BACKG/ Id is PROC
	CALL LCKCAL		; Lock the lock and run the function
MNTM5<	ADD T4,T1>		; Waiting time in SCAN added to LCKCAL
MNTM5<	ADDM T4,CELL(TCKBG,2,,TCK)> ; Accumulate it
MNTM5	SKIPE T4
MNTM5	  AOS CELL(TCKBG,1,,TCK) ; Count times waited

	SKIPE INSVR		; Was a scavenge requested?
	  AOS INSVC		; Yes.  Count it as having been done
	SETZM INSVR		; Cancel scavenge request

	MOVE T1,TCPBGT		; Run again in a few seconds
	ADD T1,TODCLK
	MOVEM T1,BG+PRCWAK
	RET

;SCAN	Scan through all TCBs and apply the functions to each.

;TCBH/	Locked, NOINT, 	BFR,TPKT,PKT,TCB saved
;	CALL SCAN
;Ret+1:	Always (waiting time in T1)

SCAN:  	SAVEAC <TCB>
	ACVAR <TCBHX,NXTTCB,Q,WAITIM>

;Get unique access to TCBH by waiting for TCBHUC to become zero

	MOVEI T1,TCBHUC		; Pointer to TCBH Use Count
	SUB WAITIM,TODCLK	; Started
	SKIPE TCBHUC		; Is it 0 as required?
	  CALL DISE		; No.  Wait for that.
	ADD WAITIM,TODCLK	; Time waiting

;Scan TCBH chains

	MOVSI TCBHX,-TCBHSZ	; Set to loop through all of TCBH
	DO.
	  HRRZ Q,TCBHX		; Index into TCBH table
	  ADD Q,TCBH		; Plus Extended pointer to table base
	  LOAD NXTTCB,QNEXT,(Q)	; Pointer to first thing on this queue
	  DO.
	    CAMN Q,NXTTCB	; Back to head of queue?
	      EXIT.		; Yes.  On to next queue
	    XMOVEI TCB,-TCBQ(NXTTCB) ; Set current TCB
				; Process next TCB
	    LOAD NXTTCB,QNEXT,(NXTTCB) ; Setup for next time
	    XMOVEI T1,TCBLCK(TCB) ; Pointer to lock
	    XMOVEI T2,FUNCS ;(TCB) ; Routine to apply functions
jfcl;	    TXO T2,<0B8>	; SCAN/ Id is PROC
	    CALL LCKCAL		; Lock the TCB and do the functions
	    ADD WAITIM,T4	; Time waiting for the lock
	    LOOP.		; Go to next TCB on this queue
	  ENDDO.
	  ADDI TCBHX,QSZ-1
	  AOBJN TCBHX,TOP.	; On to next queue
	ENDDO.

;All dead TCBs now in TCBDQ list

	MOVE Q,TCBDQ		; Queue of dead TCBs
	LOAD NXTTCB,QNEXT,(Q)	; First thing on the queue
	DO.
	  CAMN Q,NXTTCB		; Back to head?
	    EXIT.		; Yes.  Done.
	  XMOVEI TCB,-TCBQ(NXTTCB) ; Point to top of structure
	  LOAD NXTTCB,QNEXT,(NXTTCB) ; Set for next time

;Clean up dead TCB

	  CALL REMBFS ;(TCB)	; Remove all buffers from TCPDBQ

	  LOAD T1,TOPNF,(TCB)	; Get open/close wait bit index
	  CALL RELWTB		; Release it
	  LOAD T1,TERRF,(TCB)	; Get error wait flag number
	  CALL RELWTB		; Release it
	  XMOVEI T1,TCBLCK(TCB)	; Pointer to the lock
	  CALL RELLCK		; Delete that

	  JFCL ; CALL xxxx ;(TCB) ; Netowrk Accounting & TCB statistics

	  XMOVEI T1,TCBQ(TCB)	; Point to queue entry
	  CALL DQ		; Dequeue from dead queue

	  IFQE. TDBGK,(TCB)
	    MOVE T1,TCB		; Point to top of structure
	    CALL RETBLK		; Return the storage
	  ELSE.			; Don't release TCB storage (debug)
	    MOVE T2,TCBDQK	; Special queue for dead packets
	    CALL NQ
	  ENDIF.
	  LOOP.			; Back for next
	ENDDO.

	MOVE T1,WAITIM		; Return time waiting
	RET

	ENDAV.

;REMBFS	Remove buffers owned by dead TCB from TCPBDQ.

;TCB/	Extended Pointer to dead TCB
;	NOINT,	BFR,TPKT,PKT saved
;	CALL REMBFS
;Ret+1:	Always

REMBFS:	ACVAR <NEXT>
MNTM5	AOS CELL(TCKRB,0,,TCK)	; Count calls
	MOVE BFR,TCPBDQ		; Get pointer to queue head
	LOAD NEXT,QNEXT,(BFR)	; Get first thing on queue
	DO.
	  MOVE BFR,NEXT
	  CAMN BFR,TCPBDQ	; If next in queue is queue head,
	    EXIT.		; Scan is complete

MNTM5	  AOS CELL(TCKRB,1,,TCK) ; Count buffers checked
	  LOAD NEXT,QNEXT,(BFR)	; Get next item on queue
IFN BFRQ,<XMOVEI BFR,-BFRQ(BFR)> ; Point to top of structure
	  LOAD T1,BTCB,(BFR)	; Get owning TCB
	  CAME T1,TCB		; Is it the one under consideration?
	    LOOP.		; No.  Try next.

MNTM5	  AOS CELL(TCKRB,2,,TCK) ; Count buffers returned
	  XMOVEI T1,BFRQ(BFR)	; What to dequeue
	  CALL DQ		; Do it.
	  MOVE T1,BFR		; Point to top of structure
	  CALL RETBLK		; And return the storage
	  LOOP.			; Scan some more
	ENDDO.
	RET

	ENDAV.

;FUNCS	Apply a list of functions to a TCB.

;TCB/	Extended Locked connection block
;TCBHLK/Locked
;	NOINT,	BFR,TPKT,PKT saved
;	CALL FUNCS
;Ret+1:	Always

FUNCS:
MNTM5	AOS CELL(TCKAA,1,,TCK)	; Count calls
	LOAD FR,TERRT,(TCB)	; Trace flag
	SKIPE FR		; Not want trace
	  MOVX FR,1B0		; Want trace

;First, see if TCB is dead, if so, DQ from TCBH table and place in c(TCBDQ)

;DEADP(TCB)		Collect dead (closed) TCBs on c(TCBDQ)
;A DEAD TCB has:	TJCN, TSUOP, TSCB, TCQRA, TCQPZ, TCQRX, TCQDY = 0
;			TRSYN, TSSYN = NOTSYN
;			TCBSBQ, TCBRXQ, TCBRBQ, TCBRPQ empty

DEADP:
MNTM5	AOS CELL(TCKDP,0,,TCK)	; Count calls
	JN TSUOP,(TCB),DEADPA	; Keep if no CLOSE% from user yet

;TVT processing

	JE TTVT,(TCB),DEADP1	; Jump if not a TVT
	LOAD T2,TVTL,(TCB)	; Get tvt line number, if any
	JUMPE T2,DEADP2		; Jump if no line number
	NOSKD1			; Don't let tty data change under us
	CALL STADYN		; Get tty datablock, if any
	 TDZA T1,T1		; Skip load if line not active
	  LOAD T1,PTVT,(T2)	; Get tcb pointer, if any
	OKSKD1
	JUMPN T1,DEADPA		; Keep if tty datablock points to it
DEADP2:
	JN TERR,(TCB),DEADP0	; Jump to release JCN if error
	LOAD T1,TRSYN,(TCB)	; Receive state
	LOAD T2,TSSYN,(TCB)	; Send state
	CAIN T1,NOTSYN		; No error & FINs exchanged
	 CAIE T2,NOTSYN
	  JRST DEADP1		; Jump if not dead state (closed)
DEADP0:	LOAD T1,TJCN,(TCB)	; Get the JCN (owned by INTFRK)
	JUMPE T1,DEADP1		; Jump if USREVT already released it
	CALL RETJCN		; Return JCN & disable all PIs
	SETZRO TJCN,(TCB)	; (RETJCN can't do this if JCN = -1)
DEADP1:

;Common processing

	JN TJCN,(TCB),DEADPA	; Keep if user can still reference this
	LOAD T1,TSSYN,(TCB)	; Send state
	LOAD T2,TRSYN,(TCB)	; Recv state
	CAIN T1,NOTSYN
	 CAIE T2,NOTSYN
	  JRST DEADPA		; Keep unless FINd on both sides

	XMOVEI CX,TCBRXQ(TCB)
	LOAD T1,QNEXT,(CX)
	CAME T1,CX		; Head of queue?
	  JRST DEADPA		; Keep if retransmit queue non-empty

	XMOVEI CX,TCBSBQ(TCB)
	LOAD T1,QNEXT,(CX)
	CAME T1,CX
	  JRST DEADPA		; Keep if stuff waiting to be sent

	JN TSCB,(TCB),DEADPA	; Which might be a current SEND% buffer

	XMOVEI CX,TCBRPQ(TCB)
	LOAD T1,QNEXT,(CX)
	CAME T1,CX
	  JRST DEADPA		; Keep if packets waiting for RA

	XMOVEI CX,TCBRBQ(TCB)
	LOAD T1,QNEXT,(CX)
	CAME T1,CX
	  JRST DEADPA		; Keep if RECV% buffers waiting

	JN TRCB,(TCB),DEADPA	; or if there is a current RECV% buffer

	SKIPN TCQRA(TCB)	; Must not be queued for RA
	 SKIPE TCQPZ(TCB)	; Or PZ
	  JRST DEADPA
	SKIPN TCQRX(TCB)	; Or RX
	 SKIPE TCQDY(TCB)	; Or DY
	  JRST DEADPA

	XMOVEI T1,TCBQ(TCB)
	CALL DQ			; Dequeue the buffer from the TCBH queue
	SOS TCBCNT		; Now one less connection
	MOVE T2,TCBDQ		; Put it on the Dead queue
	CALL NQ			; to be released after unlock TCBH
DEADPX:	JRST FUNCX		; Return from FUNCS - no more TCB

DEADPA:

;The connection is still in use in some way at this end.


;TCB is not dead, so apply other functions ... SCAVNG, UPDATE, ALTADR, probes


;SCAVNG	Scavenge free storage from connection blocks.
;All packets on the reassembly queue are released to permit the TCP
;to continue functioning.  Retransmissions will replace them.


SCAVNG:	SKIPN INSVR		; Scavenge free storage requested?
	IFSKP.			; If it skips, something is very wrong
MNTM5	  AOS CELL(TCKSV,0,,TCK) ; Count calls
	  DO.
	    XMOVEI CX,TCBRPQ(TCB)
	    LOAD T1,QNEXT,(CX)	; Get first thing on RA queue
	    CAMN T1,CX		; Empty if that is the head itself
	      EXIT.		; No more to get from this connection
	    XMOVEI PKT,-PKTQ(T1) ; Point to top of structure

MNTM5	    AOS CELL(TCKSV,1,,TCK) ; Count packets discarded

	    CALL DQ		; Take it off the receive packet queue
	    CALL RETPKT		; Return packet buffer
	    LOOP.
	  ENDDO.
	ENDIF.


;Make sure retransmitter is running for processes that might
;have gotten "stuck"

	CALL TFRTST
	IFSKP.
	  $SIGNL(RA,^D250)	; Make reassembler run now
	ENDIF.

;Update retransmission parameters

UPDATE:	IFQN. <TRXPN,TRXPD>,(TCB) ; Omit if newer algorithm
	  LOAD T1,TMXRT,(TCB)	; Maximum round trip time (millisec.)
	  LOAD T2,TMNRT,(TCB)	; Minimum
	  MOVE T3,T1
	  SUB T3,T2		; Delta
	  IDIVI T3,2		; Decay 50% towards min.
	  SUB T1,T3
	  STOR T1,TMXRT,(TCB)	; Set new max.
	  IDIVI T3,5
	  ADD T2,T3		; Expand by 10% towards max.
	  STOR T2,TMNRT,(TCB)	; Set new min.
	  ADD T1,T2		; 2 times new average
	  ADDI T1,^D1000	; Arrange for a half second above average
	  ASH T1,-1
	  STOR T1,TRXI,(TCB)	; Is the new retransmit interval
	ENDIF.


;Collect host status information

	MOVE T1,TODCLK		; Now
	SUB T1,NTHT0+2		; Recently
	LOAD T4,TCLTM,(TCB)	; Last packet to arrive
	CAMLE T1,T4		; Get a packet recently?
	  JRST HOSTAX		; No, forget status (maybe slow/down?)

	LOAD T1,TFH,(TCB)	; Foreign host
	IFG. T1
	  MOVE T2,T1		; Who is self
	  MOVX T3,RTCRTP	; Credability of transport protocol
	  LOAD T4,TCLTM,(TCB)	; Last packet to arrive
	  CALL HSTUP		; Update status
	    JFCL		; Already knew it
	ENDIF.

	LOAD T1,TSFHOP,(TCB)	; First hop
	LOAD T2,TFH,(TCB)	; Foreign host
	SKIPLE T1		; Have a first hop which is
	 CAMN T1,T2		; Distinct from destination?
	IFSKP.
	  MOVE T2,T1		; Who is self
	  MOVX T3,RTCRTP	; Credability of transport protocol
	  LOAD T4,TCLTM,(TCB)	; Last packet to arrive
	  CALL HSTUP		; Update status
	    JFCL		; Already knew it
	ENDIF.
;cwl not yet
setz t1,;	LOAD T1,TSLHOP,(TCB)	; Last hop
	LOAD T2,TFH,(TCB)	; Foreign host
	SKIPLE T1		; Have a last hop which is
	 CAMN T1,T2		; Distinct from destination?
	IFSKP.
	  MOVE T2,T1		; Who is self
	  MOVX T3,RTCRTP	; Credability of transport protocol
	  LOAD T4,TCLTM,(TCB)	; Last packet to arrive
	  CALL HSTUP		; Update status
	    JFCL		; Already knew it
	ENDIF.
HOSTAX:

;Check for alternate addresses

	MOVEI T1,.TCPFM		; Protocol is TCP
	XMOVEI T2,TCBFH(TCB)	; Point to connection block
	CALL ALTADR		; Make sure other end is using the best address

;FIXHNG 
;Flush hung TCB's by aborting them. The better way of dealing with this
;problem  is to not put TCB's into a hung state, but until such time as
;someone solves that problem, we'll use this after the fact method. TCB
;must satisify the following criteria:
;	- owned by job zero, associated with a TVT, TVT line number is zero
;	- RCV.SND state is EST.NOT
;Takes TCB/ pointer to locked TCB

FIXHNG:	IFQE. TOWNR,(TCB)	; Quit if TCB owner is other than job zero
	ANDQN. TTVT,(TCB)	; Quit if TCB not associated with a TVT
	ANDQE. TVTL,(TCB)	; Quit if TVT is still there
	  LOAD T1,TSSYN,(TCB)	; Get Send state
	  CAIE T1,NOTSYN	; NOT?
	  ANSKP.		; Quit if send side still active
	    LOAD T1,TRSYN,(TCB)	; Get Recv state
	    CAIE T1,SYNCED	; EST?
	    ANSKP.		; Quit if receive side is other than active
	      MOVEI T1,EFP+^D7	; T1/ error code is "Connection RESET"
	      CALL ABTCON	; Flush buffers, set to NOT.NOT
	ENDIF.

;Check if need to probe a zero send window.  Don't bother if send side
;isn't synced, or if it hasn't been zero very long.

WPROBE:	LOAD T4,TSSYN,(TCB)	; Don't probe
	CAIE T4,SYNCED		; If cannot send anything
	IFSKP.			; Send side is established

	  LOAD T3,TSWND,(TCB)	; Send Window offered
	  IFQN. TDBGQ,(TCB)	; Faking zero send window?
	    SETZ T3,		; Yes
	  ENDIF.
	  LOAD T2,TSPRB,(TCB)	; Time of next window probe
	  SKIPN T3		; Window closed and
	   CAMLE T2,TODCLK	; Time for another probe
	  ANSKP.		; Yes

	    SETZB T1,T2		; Have a TCB, no data
	    CALL TCPIPK		; Get empty packet
	    ANSKP.		; Got one

	      LOAD T1,TSSEQ,(TCB) ; Set the sequence #
	      STOR T1,PSEQ,(TPKT)
	      STOR T1,PESEQ,(PKT) ; Save end of packet

	      SETZRO PPROG,(PKT) ; Don't bother with retransmissions

	      SETO T1,		; No TVT line block
	      CALL EMTPKT	; Send the packet
				; failure? 
	      MOVE T1,TODCLK
	      ADD T1,TVTWTM	; Probe delay
	      STOR T1,TSPRB,(TCB) ; Update time for next probe
MNTM5	      AOS CELL(TCKDP,3,,TCK) ; Count total window probes
	ENDIF.

;Check (actively) for half-open connections.  A probe of a half-open
;connection will probably elicit an RESET response (which will cause
;this end to abort the connection and clean up).  A probe of a fully
;open connection is intended to elicit an ACK (which will update TCLTM,
;thus extending the inactivity timeout).

IPROBE:	LOAD T2,TCLTM,(TCB)	; Time last packet received
	IFG. T2			; Have received a packet (NOT a passive OPEN%)
	  LOAD T1,TSTO,(TCB)	; User send time out
	  ANDG. T1		; If infinite (tsto = 0) no check for reset
	    CAMG T1,TCPFAT	; User time out .gt. default?
	      MOVE T1,TCPFAT	; No, use default time out
	    ADD T1,T2		; Time of connection inactivity timeout
	    CAMLE T1,TODCLK	; Has timeout been exceeded?
	    IFSKP.		; Yes

;Kill connection which have not received any packets in a long time.
;Probably some case of "destination unreachable".  This is primarily
;for the TELNET server to get jobs logged out when the user cannot
;get back to this host.  Killing the connection will detach the job,
;and the system will take care of the logout.

MNTM5	      AOS CELL(TCKDP,2,,TCK) ; Count inactivity forced aborts
	      SETONE TCABI,(TCB) ; Remember what happened

	      MOVX T1,<ELP+^D14> ; "Connection RESET"
	      MOVX T2,TCPX46	; Connection aborted
	      CALL USRERR	; Set TERR and TCERR from T1 and T2
	      MOVX T1,<ELP+^D14> ; "Connection RESET"
	      CALL ABTCON	; Abort the connection.  Flush bufs etc

	    ELSE.		; Not yet time to kill connection

;Both ends of connection still exist.  See if time for next inactivity probe.

	      LOAD T1,TCBTP,(TCB)	; Last probe (packet received) time +
	      ADD T1,TCPPST		; Probe interval = max inactivity time
	      LOAD T2,TRSYN,(TCB)
	      LOAD T3,TSSYN,(TCB)
	      ANDQN. TSOPN,(TCB)	; If connection has been opened
	        CAIE T2,TIMWAT
	         CAIN T2,NOTSYN
	          CAIE T3,NOTSYN
	           CAMLE T1,TODCLK	; Time for next probe?
	        ANSKP.			; Is time and not (TIME-WAIT or CLOSED)


;Send a probe packet.  Since TCBTP has not been updated, failure to get the
;probe sent will cause us to try again next time BG is run.
;Is this what we really want to do?  How should it interact with flow control?
;How should we probe?  a) next octet, b) last octet, c) RST, d) SYN
;We'll use an "unacceptable" SYN containing an ACK (cannot get here unless a
;packet has been received).  The other end should return an "unacceptable"
;reset which will be a "DUP,,0" thus causing TCBTP to be updated.

	          SETZB T1,T2		; Have a TCB, no data
	          CALL TCPIPK		; Get empty packet
	          ANSKP.		; Got one

	            SETONE <PSYN>,(TPKT) ; This is the last data
	            LOAD T1,TSSEQ,(TCB)	; Set the sequence #
	            SETCA T1,		; but make it "unacceptable"
	            STOR T1,PSEQ,(TPKT)
	            ADDI T1,1		; End seq #
	            MODSEQ T1
	            STOR T1,PESEQ,(PKT)	; Save recomputed end of packet

	            SETZRO PPROG,(PKT)	; Don't bother with retransmissions
;	            CALL SETRXP		; Setup packet rexmit parameters

	            SETO T1,		; No TVT line block
	            CALL EMTPKT		; Send the packet
; failure? J? ??,IPROBX			; Probe packet rejected
	            MOVE T1,TODCLK	; Update probe parameters - probe (being) sent
	            STOR T1,TCBTP,(TCB)	; Time of this probe
MNTM5	            AOS CELL(TCKDP,1,,TCK) ; Count total inactivity probes
	            INCRNO TCFWP,(TCB)	; Count probes for connection
	    ENDIF.		; Abort or not
	ENDIF.			; IPROBEs

;End of functions

FUNCX:	RET			; From FUNCS

    	SUBTTL	TCP Miscellaneous Routines

;CHKWND	Test "Sequence" to see if it is between "Left" (inclusive) and
;"Right" (not incl.).  Sequence numbers are modulo MAXSEQ and are
;always positive when represented in a 36-bit word.
; If Left .le. Right, Left .le. Sequence  and  Sequence .lt. Right
; If Right .lt. Left, Left .le. Sequence  or   Sequence .lt. Right

;T1/	Left
;T2/	Sequence
;T3/	Right
;	CALL CHKWND
;Ret+1:	Always, T1/ -1 if Sequence is in the window, 0 if outside.

CHKWND::
	MOVEM T1,T4		; Make T1 available for value
MNTM5	AOS CELL(TCMCW,0,,TCM)	; CHKWND calls
	SETZ T1,		; Init value
	CAMG T4,T3		; Crosses 0?
	 SOSA T1		; No. Get a -1 to return
	  EXCH T4,T3		; Yes.  Reverse Left and Right.
	CAMGE T2,T3
	 CAMGE T2,T4
	  SETCA T1,		; Out of window.  Complement initial guess

MNTM5	SKIPN T1		; Fail?
MNTM5	  AOS CELL(TCMCW,1,,TCM) ; CHKWND out of window
	RET

;OVRLAP	Test to see if two sequence number segments have one or more common
;points.  The two segments are semi-open on the right, similar to CHKWND.
; Left1 .le. Left2 .lt. Right1  or  Left2 .le. Left1 .lt. Right2

;T1/	Left1
;T2/	Right1
;T3/	Left2
;T4/	Right2
;	CALL OVRLAP
;Ret+1:	Always, T1 is -1 if overlap exists, 0 if not

OVRLAP::			; Only global if two parts
	ACVAR <LEFT1,LEFT2,RIGHT2>
	MOVEM T1,LEFT1
	DMOVEM T3,LEFT2		; T3,T4 to LEFT2,RIGHT2
MNTM5	AOS CELL(TCMOL,0,,TCM)	; OVRLAP calls

	EXCH T2,T3
	CALL CHKWND
	IFE. T1			; Check further
	  MOVE T1,LEFT2
	  MOVE T2,LEFT1
	  MOVE T3,RIGHT2
	  CALL CHKWND
MNTM5	  SKIPN T1		; Overlap?
MNTM5	    AOS CELL(TCMOL,1,,TCM) ; Not OVRLAP
	ENDIF.
	RET

	ENDAV.


;PKTEND	Returns the sequence number following the packet.

;PKT/	Extended Packet pointer
;TPKT/	Extended pointer to TCP header
;	CALL PKTEND
;Ret+1:	always.  End of packet plus one in T1

PKTEND::			; Only global if two parts
MNTM5	AOS CELL(TCMAA,2,,TCM)	; PKTEND calls
	LOAD T1,PSEQ,(TPKT)	; Get the start of the packet
	LOAD T2,PCTL,(TPKT)	; Get word containing control flags
	TXNE T2,<PSYN>		; Count one for SYN
	  ADDI T1,1
	TXNE T2,<PFIN>		; Another if FIN
	  ADDI T1,1
	LOAD T2,PIPL,(PKT)	; Length of whole packet in bytes
	LOAD T3,PIDO,(PKT)	; Number of words in IP part
	LOAD T4,PTDO,(TPKT)	; Number of words in TCP header
	ADD T3,T4		; Total header word count
	ASH T3,2		; Byte count
	SUB T2,T3		; Difference is # bytes in data part
	ADD T1,T2		; Each data byte is one sequence slot
	MODSEQ T1		; Take MOD field size
	RET


;NULPKT(PKT)
;Tells if packet doesn't contain anything ACK-able (SYN, data, FIN).

;PKT/	Extended Packet pointer
;TPKT/	Extended pointer to TCP header
;	CALL NULPKT
;Ret+1:	Always.  T1 -1 if packet is null, 0 if something

NULPKT::			; Only global if two parts
MNTM5	AOS CELL(TCMNP,0,,TCM)	; NULPKT calls
	SETZ T1,		; Assume something ackable
	LOAD T2,PIPL,(PKT)	; Total packet length
	LOAD T3,PIDO,(PKT)	; Offset to IP data in words
	LOAD T4,PTDO,(TPKT)	; Offset to TCP data in words
	ADD T3,T4		; Number of header words, total
	ASH T3,2		; Number of header bytes, total
	CAMLE T2,T3		; Anything in TCP data part?
	IFSKP.			; No data
	  LOAD T2,PCTL,(TPKT)	; Get word of control flags
	  TXNN T2,<PSYN!PFIN>
	    SETO T1,		; No data, no control.  Pkt is null.
	ENDIF.
MNTM5	SKIPN T1
MNTM5	  AOS CELL(TCMNP,1,,TCM) ; Packet not null
	RET

;TCPMXS	Update maximum segment size generated on connection.

;T1/	Foreign specified segment limit, or 0 (or +infinity)
;TCB/	Containing TFH, TLH - host addresses
;	CALL TCPMXS		;	 !         good arg         !
;TSMXS=Max[1.,Min[net limit (NTPSIZ-40.),!   0/+infinity, 576-40.   !]]
				;	 ! except PR Nets, 200.-40. !
TCPMXS::			; Only global if two parts
	ACVAR <PSZ>
MNTM5	AOS CELL(TCMAA,3,,TCM)	; TCPMXS calls
	SKIPLE PSZ,T1		; Use argument if not too small, and
	 CAIL PSZ,177777	; Not too large (uninitialized)
	IFNSK.			; Nothing has been specified, or bad argument
	  LOAD T1,TFH,(TCB)	; Pick one based on foreign address
	  CALL LCLHST		; Is it one of this host's addresses?
	  IFSKP.		; Yes
	    MOVE PSZ,LUPNCT	; Find loopback NCT
	    MOVE PSZ,NTPSIZ(PSZ) ; Get it's max size
	  ELSE.			; No
	    MOVX PSZ,^D576	; Use the sociable maximum
	  ENDIF.
	  SUBI PSZ,<MINIHS+MINTHS>
	ENDIF.			; Defaulted bad arg
	LOAD T1,TLH,(TCB)	; Address foreign end used for this host
	NETNUM T1,T1
	CALL NETLUK ;(T1:T1)	; Is there an interface on that net?
	SKIPLE T1		; No, or not up
         SKIPG T1,NTPSIZ(T1)	; Get max packet size for that (interface) net
          MOVEI T1,^D576	; None or 0, use internet default
	SUBI T1,<MINIHS+MINTHS>	; Convert packet size to segment size
	CAMLE PSZ,T1		; Use local interface limit if smaller
	  MOVE PSZ,T1
	SKIPG PSZ		; Watchout for garbage
	  MOVX PSZ,1		; Ought to send a parameter problem message...
	CAILE PSZ,10		; If reasonable segment size,
	  TRZ PSZ,3		; Make it mod 4
	STOR PSZ,TSMXS,(TCB)	; Set max segment size for connection
	RET

	ENDAV.


;ONLCLT	Check timebase of sending host.

;Test  to see if the current packet was sent by a host which is using
;the same timebase as this host. So that we will  know  if  the  time
;stamp is valid

;PKT/	Extended Pointer to the packet under consideration
;	CALL ONLCLT
;Ret+1:	always, T1 non-0 if packet has a useable timestamp

ONLCLT:
MNTM5	AOS CELL(TCMLT,0,,TCM)	; ONLCLT calls
	LOAD T1,PISH,(PKT)	; Get the 32-bit source address
	CALL LCLHST		; Is it me?
	  SETZ T1,		; No, clear T1
MNTM5	SKIPN T1
MNTM5	  AOS CELL(TCMLT,1,,TCM) ; Not ONLCLT
	RET


;CHKADD	Lookup up a connection and maybe create a new one.

;If the desired (possibly wild) connection is found, the argument
;function is called (JCN,ARG1) with the TCB locked.  If no TCB is
;found, the value of CHKADD is -1,,errorcode.  Otherwise the value
;is that of the function called, which may also be an error value.

;T1/	Extended Pointer to argument block defined by CHKADL
;	NB: "JCN" is a JCN iff .gt. 0, .le. 0 is not a JCN.
;      	NOINT
;	CALL CHKADD
;Ret+1:	always.  Value in T1, TCB set up.
;		-1,,ELP+^D13 ; Invalid port(LP=0)
;(net)		-1,,ELP+^D05 ; Packet with wild FH/FP
;(jsys)	NEWTCB	-1,,ELT+^D04 ; No free JCN/TCB space/free WAIT bit
;(net)		-1,,EFP+^D07 ; No such TCB

CHKADD::
	TRVAR <WILD1>
	CHKADL (<TCBX,TCB.FH,TCB.FP>) ; PARAMS & other ACVARs
	MOVEM T1,PARAMS		; Save pointer to parameters
MNTM5	AOS CELL(TCMCA,0,,TCM)	; CHKADD calls

	HRROI T1,ELP+^D13	; "Illegal port"
	SKIPN LP
	 JRST CHKADX		; Should never have to lookup wild LP
	HRROI T1,ELP+^D05
	SKIPE FP		; Wild FP and/or FH ok only if "listen"
	 SKIPN FH
	  SKIPLE JCN		; Called from a JSYS?
	   TRNA			; Yes, wild is ok
	    JRST CHKADX		; Bad packet from network (FP=0 or FH=0)

MNTM5	CALL CHKAM0		; Gather beginning statistics
	HLLZ T2,FN		; Possible ID
	TLZ T2,777		; In 777B8
	CALL HTLOCK		; Get unique access to the TCB hash table
MNTM5	CALL CHKAMW		; Gather ending (wait) statistics
MNTM5	CALL CHKAM0		; Gather beginning statistics

;Get hash index to the TCB Hash table

	MOVE T1,LP		; Local port is what is hashed on
	CALL TCBHSH		; Hash LP into a TCBH index
	MOVEM T2,TCBX		; Working pointer, T2 pointer to queue head

;Scan the TCB queue which has its head in the slot at TCBX

	MOVE TCB,TCBX		; Initize the scan pointer
	SETZM WILD1		; No Wild match found yet
CHKAD4:	DO.
	  LOAD TCB,QNEXT,(TCB)	; Get next (first) thing on queue
	  CAMN TCB,TCBX		; Points back to head?
	    EXIT.		; Yes.  Scan done, no exact match.

; If here due to a JSYS, the job numbers must match

	  LOAD T1,TOWNR,(TCB)	; Get Job number which owns this tcb
	  SKIPLE JCN		; Any job ok if called from net side
	   CAMN T1,JOBNO	; Must stay in this job
	    TRNA		; OK to think about this TCB
	     LOOP.		; Skip it and try next

; Local port must match (wild local port is illegal)

	  LOAD T1,TLP,(TCB)	; Get the Local Port from this TCB
	  CAME T1,LP		; Does it match what we are looking for?
	    LOOP.		; No.  Try next TCB

; Look for an exact match

	  LOAD TCB.FH,TFH,(TCB)	; Get foreign host
	  LOAD TCB.FP,TFP,(TCB)	; Get foreign port
	  CAMN TCB.FH,FH	; Compare these with what
	   CAME TCB.FP,FP	; is being sought
	  IFSKP.		; "Exact match"

; Should TCP demand an exact match on the local host address?
; Reasons for YES:  it is part of the identifier; seems like one
;	ought to.  The host can attempt to restrict connections
;	based on the local Host Address which is used.
; Reasons for NO:   the Host Address is a manifestation of the physical
;	network structure while TCP should be concerned with the Host
;	Name (historically the DARPA protocol suite has never had to
;	resolve the issue).  The TCP is more robust since packets that
;	are Addressed to any of its interfaces can be used in the
;	event of failure of interfaces and networks in the internet.
;	Restrictions based on local Host Address will not really work
;	since the internet will deliver packets to the host reguardless
;	of which Host Address is specified in the IP leader.
; Decided no.

repeat 0,<
	   LOAD T1,TLH,(TCB)	; Get local host
	   CAME T1,LH		; Check local host
	   ANSKP.		; Even local address matches
> ; End of repeat 0

;TCB points to an exact match.  If CHKADD was called from the JSYS
;side, it means the user is trying to re-open the connection.

	    SKIPLE JCN		; Called from a JSYS?
	      JRST CHKAD8	; Yes.  Go use this exact match.
	    LOAD T1,TRSYN,(TCB)	; Get state of Receive synchronization
	    LOAD T2,TSSYN,(TCB)	; and state of Send synch.
	    CAIN T1,NOTSYN	; Recv side still open?
	     CAIE T2,NOTSYN	; Send side still open?
	      JRST CHKAD8	; Yes.  Match this TCB.
	    LOOP.		; Both closed. Pkt cannot reactivate
	  ENDIF.		; conn.  Look for another incarnation.

; Check if it is ok to match a wild TCB

	  SKIPN WILDOK		; Caller says OK to use wild TCB?
	    LOOP.		; No.  Keep looking for exact match.

; Find the "best" match for the current listening connections.
; The implemented ordering is:				<<<<<

; F.Net+Host > F.Net > F.Port > L.Net+Host > L.Net > L.Port

; Ranking based on network address classes, protocol suite, or IP
; precedence is not implemented.

; Foreign field is B1-5 (cannot use B0), Local is B7-11
  CHK.EX==1B7	; Exact host address match
  CKW.NT==1B8	; Network numbers match
; CKW.CL==1B9	; Address classes match (doesn't seem useful)
; CKW.PS==1B10	; Protocol suites match (tcp assumes IP & NP.IP)
  CHK.PT==1B11	; (Foreign) port matches

 	  MOVX T4,<CHK.PT_<-6>>	; Local port already matched above

; Check foreign port

	  IFN. TCB.FP		; If TCB has foreign port and
	    CAME TCB.FP,FP	; Exact match, continue
	      LOOP.		; Otherwise, look for better TCB
	    TXO T4,CHK.PT	; Binding for exact port match
	  ENDIF.

; Check tightness of foreign host binding

	  IFN. TCB.FH		; If TCB has foreign host and
	    CAMN TCB.FH,FH	; Exact match,
	     TXOA T4,CHK.EX	; Continue, binding for exact host match
	      JSP T3,CHKWLF	; Otherwise look for partial foreign match
	  ENDIF.

; Shift foreign values over to B1-5 from B7-11

	  LSH T4,6		; Foreign binding tighter than local

; Check tightness of local host binding

	  LOAD T1,TLH,(TCB)	; Get local host
	  IFN. T1		; If TCB has local host and
	    CAMN T1,LH		; Exact match,
	     TXOA T4,CHK.EX	; Continue, binding for exact host match
	      JSP T3,CHKWLL	; Otherwise look for partial local match
	  ENDIF.

; Compare tightness of this candidate with best previous

	  CAMG T4,WILD1		; Tighter binding than had previously?
	    LOOP.		; No, forget this candidate
	  ADD T4,TCB		; Binding and TCB
	  MOVEM T4,WILD1	; Save the location of the wild TCB
	  LOOP.			; Continue looking for exact match.

; Subroutine to bind partiall wild local/foreign host addresses

;T1/	(if CHKWLL) TCB foreign host
;T4/	Current best wild match
;	JSP T3,CHKWLL or CHKWLF
;Ret+1:	Possible match, T4 updated
;LOOPs:	Conflict, T4 unchanged

CHKWLF:	  MOVE T1,TCB.FH	; T1/ Foreign TCB spec
	  SKIPA T2,FH		; T2/ Foreign address from packet
CHKWLL:	    MOVE T2,LH		; Local
	  LOAD CX,IA%CLS,+T1	; Net class from TCB
	  TDNE T1,INTHST(CX)	; "Rest" field wild?
	  IFSKP.		; Yes
	    CALL @PRONET+NP.IP	; Get IP "net number" specified in TCB
	    EXCH T1,T2
	    CALL @PRONET+NP.IP	; Get IP "net number" used in packet
	    CAME T1,T2		; Same net?
	    ANSKP.		; Yes
	      TXO T4,CKW.NT	; Binding level is network
	      JRST (T3)		; Continue
	  ENDIF.
	  LOOP.			; On to next TCB

	ENDDO.
;End of scan when pass here. (EXIT if no exact match, CHKAD8 if exact match)

;None found:  TCB points at queue head (TCBX)
;WILD1 is 0  or  binding & pointer to a wild TCB.

CHKAD6:	SKIPG WILD1		; Have a wild match?
	IFSKP.			; Yes

;Bind a wild match.

	  MOVE T1,FH		; Get the desired foreign host
	  MOVE T2,FP		; and foreign port
	  MOVE T3,LH		; and local host
	  MOVE TCB,WILD1	; This is the TCB to work with
	  ANDX TCB,<37777777>	; Just TCB address
	  STOR T1,TFH,(TCB)	; Store in the wild TCB
	  STOR T2,TFP,(TCB)
	  STOR T3,TLH,(TCB)	; Set local "Name" to what the remote
				; end is now calling this host
	ELSE.

;No wild match, no exact match.  If called from JSYS Create the connection.
				; Note TCB=TCBX & WILD1=0
	  SKIPG JCN		; Called from a JSYS?
	    JRST CHKA10		; Net.  Don't create a TCB

;JSYS & no TCB

	  MOVE T1,PARAMS	; Argument block address
	  MOVE T2,TCBX		; Extended Where to enqueue the new TCB
	  CALL NEWTCB		; Create it and initialize it.
	  ANDE. TCB		; Too many TCBs, No space, No wait bits
	    CALL HTUNLK		; Unlock TCBH
MNTM5	    CALL CHKAMX		; Gather ending statistics
	    HRROI T1,ELT+^D04	; "No room for another connection"
	    JRST CHKADX		; Report the error to the caller
	ENDIF.

;TCB has the TCB to use.

CHKAD8:	SKIPG T4,JCN		; Called from the JSYS side?
	IFSKP.

;The JSYS might have been called with an old CDB, don't give two JCNs!

	  LOAD T1,TJCN,(TCB)	; Get original JCN of TCB - user may have it.
	  IFN. T1
	    EXCH T1,JCN		; Use the original JCN
	    CAME T1,JCN		; If new one is different, then
	      CALL RETJCN	; Return new (RH of JCNTCB is 0)
	  ELSE.			; Both JCN & TJCN have original JCN
	    STOR T4,TJCN,(TCB)	; Put new JCN into TCB
	  ENDIF.
	ENDIF.


;Unlock the TCB hash table to other readers, but not writers.

CHKA10:	AOS TCBHUC		; Indicate TCBH has a reader
	CALL HTUNLK		; Unlock TCBH with use count .gt. 0

MNTM5	CALL CHKAMX		; Gather ending statistics

	HRROI T1,EFP+^D07	; "No such TCB" (must be net side)
	CAMN TCB,TCBX		; Did we locate a TCB?
	IFSKP.			; Yes

;A TCB was found/created, lock it and call the argument function.

	  XMOVEI T1,TCBLCK(TCB)	; Pointer to the TCB Lock
	  MOVE T2,FN		; Function to be called (w/ID)
	  MOVE T3,JCN		; Argument for the function
	  MOVE T4,ARG1		; The argument passed through
	  CALL LCKCAL		; Lock the lock and call the function
				; T1/ error code from routine
	ENDIF.

	SOS TCBHUC		; Indicate TCBH may now change

CHKADX:	CHKADR			; Restore

MNTM5	SKIPGE T1		; Error?
MNTM5	  AOS CELL(TCMCA,1,,TCM) ; CHKADD errors
	RET

	ENDTV.

;Gather and compute times and traps

MNTM5 <
CHKAM0:	MOVN T1,TODCLK			; Time at beginning
	PUSH P,T1
	MOVN T1,UTRPCT			; Pager traps
	PUSH P,T1
	MOVN T1,PTTIM			; Time in pager traps
	PUSH P,T1
	PUSH P,-3(P)			; Move return down
	RET

CHKAMW:	XMOVEI T2,CELL(TCMCA,2,,TCM)	; CHKADD wait stats
	TRNA
CHKAMX:	  XMOVEI T2,CELL(TCMCA,6,,TCM)	; CHKADD run stats
	POP P,T1			; Move return down
	MOVEM T1,-3(P)
	POP P,T1
	ADD T1,PTTIM
	ADDM T1,XCELL(TCMCA+2/6,3,(T2)) ; CHKADD time in pager traps
	POP P,T1
	ADD T1,UTRPCT
	ADDM T1,XCELL(TCMCA+2/6,2,(T2)) ; CHKADD number of pager traps
	POP P,T1
	ADD T1,TODCLK
	ADDM T1,XCELL(TCMCA+2/6,1,(T2)) ; CHKADD time used
	AOS XCELL(TCMCA+2/6,0,(T2))	; CHKADD number of times
	RET
> ; End of MNTM5

;Routine to get unique access to the TCB Hash table.  This means having
;it locked with the TCBH Use Count = 0.

;T2/	777B8 has ID or 0

HTLOCK::
	DO.
	  PUSH P,T2		; Save arg
	  XMOVEI T1,TCBHLK	; Pointer to the TCBH Lock
	  CALL SETLCK		; Test and set the lock
	  SKIPG TCBHUC		; TCBH Use Count.  Any readers?
	    EXIT.		; OK we have sole access
	  XMOVEI T1,TCBHLK	; Pointer to the lock
	  CALL UNLCK		; Unlock it.
	  MOVEI T1,TCBHUC	; Pointer to the use count
	  CALL DISE		; Wait for it to go to zero
	  POP P,T2		; Restore arg
	  LOOP.			; Try again.
	ENDDO.
	POP P,(P)		; Drop arg
	RET


HTUNLK::			; Hash table unlock routine
	MOVEI T1,TCBHLK		; Pointer to the TCBH lock
	CALL UNLCK		; Unlock the lock
	RET






;Routine to get TCB Hash table index from local port number
;Local port is in T1.  Returned in T2.

;cwl TCS%O2 optimization ....



TCBHSH::			; Get TCB hash
	MOVE T2,T1		; Save port number for a while
	LSH T1,-3		; Divide port by 8
	ADDI T1,^D23		; Add in a prime
	IMUL T1,T2		; Multiply by the local port number
	IDIVI T1,TCBHSZ		; Divide by the size of the hash table
	IMULI T2,QSZ		; Size of an entry
	ADD T2,TCBH		; Get location within TCBH
	RET			; Return to caller


;NEWTCB	Initialize a new connection block. Only called from CHKADD if no match.

;T1/	PARAMS	; Extended address of parameter block
;T2/	TCBX	; Extended Adr of TCB Hash table entry
;	CALL NEWTCB
;Ret+1:	Always.  TCB points to the TCB or is 0 if no space,
;		too many conn, no wait bits

NEWTCB:	CHKADL (TCBX)
	MOVEM T1,PARAMS		; Argument block address
	MOVEM T2,TCBX		; Where to enqueue new TCB
MNTM5	AOS CELL(TCMNT,0,,TCM)	; NEWTCB calls

MNTM5<	XMOVEI T4,CELL(TCMNT,1,,TCM)> ; NEWTCB too many connections failures
MNTM0<	MOVE T2,TCBCNT> ;CELL(TCMTC,0,,TCM) Current number of connections
MNTM0<	CAML T2,TCBMAX> ;CELL(TCMTC,1,,TCM) Test against max we support at once
	  JRST NEWTCE		; No room for another.

	MOVX T1,TCBSIZ		; Size of a connection block
	CALL GETBLK		; Get a block of free storage
MNTM5<	XMOVEI T4,CELL(TCMNT,2,,TCM)> ; NEWTCB no free space failures
	JUMPE T1,NEWTCE		; None available.  Fail.
	MOVEM T1,TCB		; Put Extended adr in standard place
	MOVX T2,TCBSIZ		; Size again for CLRBLK
	CALL CLRBLK
	STOR TCB,TCBAD,(TCB)	; Address of self
	MOVE T1,LH		; Set the local host
	STOR T1,TLH,(TCB)
	STOR T1,TOPLH,(TCB)
	MOVE T2,LP		; Set the local port
	STOR T2,TLP,(TCB)
	MOVE T3,FH		; Set the foreign host
	STOR T3,TFH,(TCB)
	STOR T3,TOPFH,(TCB)
	MOVE T4,FP		; Set the foreign port
	STOR T4,TFP,(TCB)
	STOR T4,TOPFP,(TCB)
	MOVX T1,NOTSYN
	STOR T1,TRSYN,(TCB)
	STOR T1,TSSYN,(TCB)
	SETONE TRIS,(TCB)

	XMOVEI T1,TCBSBQ(TCB)	; TCB Send buffer queue
	CALL INITQ		; Initialize it.
	XMOVEI T1,TCBRXQ(TCB)	; TCB Retransmission queue
	CALL INITQ		; Initialize it.
	XMOVEI T1,TCBRBQ(TCB)	; TCB Receive buffer queue
	CALL INITQ		; Initialize it.
	XMOVEI T1,TCBRPQ(TCB)	; TCB Receive packet queue
	CALL INITQ		; Initialize it.
	CALL ASNWTB		; Assign a wait bit index for open/close
	JUMPL T1,NEWTC9		; Jump if we didn't get the bit.
	STOR T1,TOPNF,(TCB)	; Set into TCB
	CALL CLRWTB		; Initialize to zero state (closed)
	CALL ASNWTB		; Get another bit for error events
	JUMPL T1,NEWTC8		; Jump if that failed
	STOR T1,TERRF,(TCB)	; Set into TCB
	CALL CLRWTB		; Clear it.  (No error yet)
	XMOVEI T1,TCBLCK(TCB)	; Pointer to the TCB lock
	CALL CLRLCK		; Clear it.

	MOVE T1,TCPDTL		; STG Default time to live
	STOR T1,TTTL,(TCB)	; for this connection
	SETONE TSMXS,(TCB)	; Unspecified max segment length

	MOVE T3,TODCLK		; Now
MNTM0<	AOS T2,CELL(TCMTC,4,,TCM)> ; Total TCBs
MNTM0<	AOS T1,TCBCNT> ;CELL(TCMTC,0,,TCM) Count as another connection
MNTM0<	CAMGE T1,CELL(TCMTC,2,,TCM)> ; New max?
MNTM0<	  JRST NEWTC6>		; No
MNTM0<	MOVEM T1,CELL(TCMTC,2,,TCM)> ; Yes
MNTM0<	MOVEM T3,CELL(TCMTC,3,,TCM)> ; Record when
NEWTC6:
	STOR T2,TCBID,(TCB)	; Set ID
	STOR T3,TCRTM,(TCB)	; When TCB was created

	XMOVEI T1,TCBQ(TCB)	; Extended Pointer to the TCB just initialized
	MOVE T2,TCBX		; Extended Adr of TCB Hash table entry (of Q's)
	CALL NQ			; Place it on the right queue
	JRST NEWTCX

NEWTC8:	LOAD T1,TOPNF,(TCB)	; Oh well.  Have to back out.
	CALL RELWTB		; Release the open/close wait bit
NEWTC9:	MOVE T1,TCB		; Pointer to the connection block
	CALL RETBLK		; Give back that storage
MNTM5	AOSA CELL(TCMNT,3,,TCM)	; NEWTCB no wait bit failures
NEWTCE:
MNTM5	  AOS XCELL(TCMNT+1/2,0,(T4)) ; NEWTCB failed, MAXTCB or no space
	SETZ TCB,		; Tell caller the bad news.
NEWTCX:	CHKADR
	RET


; Set output speed in the TCB
; Call: T3/ Speed
;	TCB/ Unlocked TCB
;	CALL TCBSPD
; Returns+1 always
TCBSPD::
	SAVEAC <T1,T2,T3,T4>
	XMOVEI T1,TCBLCK(TCB)
	XMOVEI T2,TCBSP0
	CALLRET LCKCAL

; Work routine for TCBSPD
; Call: T1/ Output speed
;	TCB/ Locked TCB
;	CALL TCBSP0
; Returns+1 always, clobbers T1,T2
TCBSP0:	STOR T1,TSMXB,(TCB)	; Set maximum send rate
	IDIV T1,TCPBRD		; Divide by baud rate divisor
	LOAD T2,TPSMO		; Get system default max outstanding pkts
	CAMLE T1,T2		; Limit to maximum
	  MOVE T1,T2
	SKIPG T1		; Which is maximum outstanding pkts
	  MOVX T1,1		; Minimum of 1
	LOAD T2,TTVT,(TCB)	; TVT's
	LSH T1,(T2)		; Get twice the number
	STOR T1,TCSMO,(TCB)	; Save in TCB
	RET


repeat 0,<
DECRAD==^D10
OCTRAD==^D8

AUDIT:	TRVAR <SBUS,RXUS,RBUS,RPUS>
	ACVAR <IDX>
	PUSH P,TCB
	SETZM IDX

AUDTCL:	AOS T1,IDX
	CAMLE IDX,TCBCNT	; Processed all TCBs?
	  JRST AUDXIT		; Yes

	MOVX T4,<-TCBHSZ,,0>
	MOVE T3,TCBH		; Extended address of first queue head

	NOSKED

AUDHD:	MOVE TCB,T3		; Extended address of queue head
AUDCH:	LOAD TCB,QNEXT,(TCB)	; Next entry in chain
	CAME TCB,T3		; Back to head?
	  JRST AUDCHN		; No, Go count index
	AOS T3,			; Yes, next head
	AOBJN T4,AUDHD		; Back if valid
	TDZA TCB,TCB		; Cannot find it
AUDCHN:	  SOJGE T1,AUDCH	; Back if this isn't the one

; Collect data from TCB

	XMOVEI T1,TCBSBQ(TCB)
	MOVX T2,BFRQ
	CALL TCBUSE		; Send buffer queue
	MOVEM T2,SBUS

	XMOVEI T1,TCBRXQ(TCB)
	MOVX T2,PKTQ
	CALL TCBUSE		; Retransmission queue
	MOVEM T2,RXUS

	XMOVEI T1,TCBRBQ(TCB)
	MOVX T2,BFRQ
	CALL TCBUSE		; Receive buffer queue
	MOVEM T2,RBUS

	XMOVEI T1,TCBRPQ(TCB)
	MOVX T2,PKTQ
	CALL TCBUSE		; Receive packet queue
	MOVEM T2,RPUS

	OKSKED

;Print info collected

	MOVX T1,.PRIOU
	HRRZ T2,TCB
	MOVX T3,<NO%LFL+FLD(6,NO%COL)+OCTRAD>
	NOUT
	  JFCL

	HLRZ T2,SBUS
	MOVX T3,<NO%LFL+FLD(6,NO%COL)+DECRAD>
	NOUT
	  JFCL

	HLRZ T2,RXUS
	MOVX T3,<NO%LFL+FLD(6,NO%COL)+DECRAD>
	NOUT
	  JFCL

	HRRZ T2,RXUS
	MOVX T3,<NO%LFL+FLD(6,NO%COL)+DECRAD>
	NOUT
	  JFCL

	HLRZ T2,RBUS
	MOVX T3,<NO%LFL+FLD(6,NO%COL)+DECRAD>
	NOUT
	  JFCL

	HLRZ T2,RPUS
	MOVX T3,<NO%LFL+FLD(6,NO%COL)+DECRAD>
	NOUT
	  JFCL

	HRRZ T2,RPUS
	MOVX T3,<NO%LFL+FLD(6,NO%COL)+DECRAD>
	NOUT
	  JFCL

	HRROI T2,[ASCIZ /
/]
	SETZ T3,
	SOUT

	JRST AUDTCL		; Back for next TCB

	ENDAV.
	ENDTV.

;  T1/	Extended address of Queue head
;  T2/	Offset to queue entry
;	CALL TCBUSE
;  T2/	Count,,Space

TCBUSE:	ACVAR <QP>
	AOS T2			; Get to free storage word
	MOVE T3,T2		; Offset of queue head
	SETZ T2,
	MOVE QP,T1		; Working pointer
	DO.
	  LOAD QP,QNEXT,(QP)	; BFRQ or PKTQ
	  CAMN QP,T1		; Back to queue head?
	    RET			; Yes
	  MOVE T4,QP		; Pointer at queue entry
	  SUB T4,T3		; Point before top of structure
	  HLLZ T4,(T4)		; Free storage size
	  AOS T4		; Count of one
	  MOVSS T4
	  ADD T2,T4
	  LOOP.
	ENDDO.
AUDXIT:
	POP P,TCB
	RET

	ENDAV.

> ;end repeat 0

;cwl options
	SUBTTL	TCP Statistics Routines

COMMENT	!

These  routines  handle  time  accounting, timestamping and histogram
making.

!


;TSTAMP	Histogram packet time interval.

;T1/	Extended Histogram pointer
;PKT/	Extended Packet
;	CALL TSTAMP
;Ret+1:	Always.

TSTAMP::
	LOAD T3,PTS,(PKT)	; Get the timestamp from packet
	MOVE T2,TODCLK
	STOR T2,PTS,(PKT)	; Set the new timestamp
	SKIPN STATF		; Taking statistics right now?
	  RET			; No, stop now

	SUB T2,T3		; Compute Difference

;Fall into DOHIST



;DOHIST
;Do the histogram functions.

;T1/	Extended Histogram pointer
;T2/	Sample
;	CALL DOHIST
;Ret+1:	Always

DOHIST:	AOS HSMPL(T1)		; Count number of samples
	IFG. T2
	  ADDM T2,HTOTL(T1)	; Accumulate total
	  JFFO T2,.+1		; Get log
	  MOVNS T3		; Want low first
	  ADDI T3,^D36		; Positive exp
	  HLRE CX,HSQNB(T1)	; Squeeze factor
	  ASH T3,(CX)
	  HRRZ CX,HSQNB(T1)	; Number of bins
	  CAIL T3,(CX)		; Fit into histogram or overflow bin?
	    MOVEI T3,-1(CX)	; No, put in overflow bin
	  ADD T1,T3		; Address in histogram
	ENDIF.
	AOS HBIN0(T1)		; Count sample
	RET

;TIMCAL	Time a call to a subroutine.

;T1/	Extended Address to charge time to
;T2/	Extended Function to call
;T3/	Arg1 for function
;T4/	Arg2 for function
;TIMPTR/ Extended pointer to current time accumulator

TIMCAL::			; Only global if two parts
	PUSH P,TIMPTR		; Save old timer
	MOVEM T1,TIMPTR		; Set new timer
	PUSH P,T3		; Save ARG1
	PUSH P,T4		; Save ARG2
	PUSH P,T2		; Save routine
	CALL GETFRT		; Get fork's runtime til now
	POP P,T4		; Get the routine address
	POP P,T2		; Get Arg2
	EXCH T1,0(P)		; Save start time and get Arg1
	CALL 0(T4)		; Call the function
	PUSH P,T1		; Save result of the function
	CALL GETFRT		; Get the runtime now, after the funcal
	MOVE T3,T1		; Put in a safe place for a second
	POP P,T1		; Restore the result
	POP P,T4		; Get starting usage
	SUB T4,T3		; Compute negative usage
	MOVN T3,T4		; Positive useage
	MOVE T2,TIMPTR		; Get current time accumulator
	ADDM T3,0(T2)		; Charge to the current timer cell
	POP P,T3		; Restore previous timer
	MOVEM T3,TIMPTR

;Would like to avoid double charges, but this fails because top level
;never gets finished, thus is always negative and also because there
;may not be a (logical) top level when non-INTFRK has called here (a
;random timer would get bashed).  To keep things consistent, double...

jfcl;	ADDM T4,(T3)		; Avoid double charges
	RET


;RSTBFR	Reset a buffer (descriptor block)

;BFR/	Extended Pointer to the buffer descriptor
;	CALL RSTBFR
;Ret+1:	Always.

RSTBFR::
MNTM5	AOS CELL(TCFAA,3,,TCF)	; Count calls to RSTBFR
	LOAD T1,BICNT,(BFR)	; Initial byte/word cnt set by SEND%, etc
	STOR T1,BCNT,(BFR)	; Set as the working countdown
	LOAD T1,BDADR,(BFR)	; Data address in user space
	SETZRO <BDAIN,BDASE>,-BFRDAD+T1	 ; Clear Indirect+Section bit
	SETZ T2,		; Normalize byte pointer
	ADJBP T2,T1		; ...
	STOR T2,BPTR,(BFR)	; Set buffer byte pointer
	RET

> ; End of IFL PART-2
IFE PART-1,<LTCPT5:	LIT >
	SUBTTL	TCP Interrupts to User

COMMENT	!

Routines called from within the TCP to inform the user (via interrupts)
of various events that have occurred such as errors detected (USRERR),
or a connection opening or closing (USREVT), or presence of urgent data
(USRURG), or a buffer completion (USRBFE and USRBFF).

!

IFG PART-0,<


;USRBFE	Pass SEND% buffer empty interrupt to user, update user's buffer header.

; Never called for TVTs
;T1/	Event (error) code and flags (377B7)
;SNDDAT	OK	 ; Emptied user SEND% buffer
;ABTCON	ELT+^D04 ; No free TVT
;ABTCON	EFP+^D07 ; RST received
;ABTCON	ELP+^D07 ; @PZ with TSABT
;ABTCON	ELP+^D14 ; RX timeout
;TCB/	Extended Locked Connection Block
;BFR/	Extended Buffer descriptor
;	CALL USRBFE
;Ret+1:	Always

USRBFE:
MNTM5	AOS CELL(TCUAA,1,,TCU)	; USRBFE calls
	PUSH P,T1		; Save the code for a second
	SETO T1,		; Request header mapping
	CALL SETTUM		; Set internet's user map (NOSKED)
	POP P,T1		; Recover the code
	OPSTR SKIPE,TSABT,(TCB)	; Different error if ABORT in progress
	  MOVX T1,<<ELP+^D14>B7> ; Connection reset
	MOVE T4,BFRFLG(BFR)	; Get original flags
	IFXN. T4,BPSH		; Does it have a PUSH?
	  LOAD T4,TSBFP,(TCB)	; Yes, decrement count of buffers with push
	  SOJL T4,.+2
	    STOR T4,TSBFP,(TCB)	; Update count
	ENDIF.

	LOAD T2,BHADR,(BFR)	; Origin of the Buffer Header
	LOAD T3,BCNT,(BFR)	; Get the count
	UMOVEM T3,BFRCNT(T2)	; Store into user space
	IFN. T3			; Only part of buffer sent
	  LOAD T4,TSBYT,(TCB)	; Reduce outstanding count
	  SUB T4,T3		; by bytes not sent
	  STOR T4,TSBYT,(TCB)
	ENDIF.
	TXO T1,TCP%DN		; Buffer done bit
	MOVX T3,<-1B7+TCP%DN>	; Bits changed here
	AND T1,T3		; Flush stray bits
	XCTU [ANDCAM T3,BFRFLG(T2)] ; Clear in user space
	XCTU [IORM T1,BFRFLG(T2)] ; Set to tell the user it has finished
	CALL USTTUM		; Unmap the user space (OKSKED)
	MOVX T1,PT%TBE		; User buffer emptied
	TXNN FR,1B0		; TCB trace or
	 TDNE T1,MNTRAC		; Want trace?
	  CALL PRNPKT		; Yes
	LOAD T1,TPICS,(TCB)	; Get the SEND% done PSI Channel
	LOAD T2,TPIFS,(TCB)	; And forkx
	SETO T3,		; Flag from SEND
	CALLRET BFRDUN		; Dispose of the buffer


;USRBFF	Pass RECV% buffer full interrupt to user, update user's buffer header.

; Never called for TVTs
;T1/	Event (error) code and flags (TCP%PU, TCP%UR, etc.) (377B7)
;REASEM	OK	 ; User RECV% buffer filled
;PRCPSH	OK	 ; Received PUSH
;FLSRBF via ABTCON
;FLSRBF	ELT+^D04 ; No free TVT
;FLSRBF	EFP+^D07 ; RST received
;FLSRBF	ELP+^D07 ; @PZ with TSABT
;PKTIZE	XLP+^D12 ; Received FIN implies a PUSH
;FLSRBF	ELP+^D14 ; RX timeout
;BFR/	Extended Buffer desciptor which is completing
;TCB/	Extended Locked Connection Block
;	CALL USRBFF
;Ret+1:	Always.

USRBFF:
MNTM5	AOS CELL(TCUAA,2,,TCU)	; USRBFF calls
	PUSH P,T1		; Save the code
	SETO T1,		; Request header mapping
	CALL SETTUM		; Set internet's user map (NOSKED)
	POP P,T1		; Recover the code
	OPSTR SKIPE,TRURG,(TCB)	; Jump if not in receive urgent mode
	  TXO T1,TCP%UR		; Give urgent flag in buffer
	OPSTR SKIPE,TSABT,(TCB)	; Different error if ABORT in progress
	  MOVX T1,<<ELP+^D14>B7> ; Connection reset
	LOAD T2,BHADR,(BFR)	; Get address of header in user space
	LOAD T3,BCNT,(BFR)	; Get count from monitor copy of header
	UMOVEM T3,BFRCNT(T2)	; Store into user copy
	LOAD T4,TRBS,(TCB)	; Amount of RECV% buffer space
	SUB T4,T3		; The whole buffer is going back!
				; Shrinking the window is bad!!
	STOR T4,TRBS,(TCB)	; Leave what is left for window setting.
	TXO T1,TCP%DN		; Set the done bit
	MOVX T3,<-1B7+TCP%PU+TCP%UR+TCP%DN> ; Bit we change
	AND T1,T3		; Flush stray bits
	XCTU [ANDCAM T3,BFRFLG(T2)] ; Clear in user space
	XCTU [IORM T1,BFRFLG(T2)] ; Merge with user's header

	IFQN. TNUFM,(TCB)	; If new format
	  MOVX T1,<.RTJST(-1,PIDO)-<MINIHS+3>/4> ; Max IP option words
	  XMOVEI T2,TCBIR(TCB)	; Received IP options
	  HLRZ T3,BFROPT(BFR)	; Address for IP options
	  SKIPE T4,T3		; If none, don't return any
	    CALL BLTMU		; IP options to user
	  MOVX T1,<.RTJST(-1,PTDO)-<MINTHS+3>/4> ; Max TCP option words
	  XMOVEI T2,TCBTR(TCB)	; Received TCP options
	  HRRZ T3,BFROPT(BFR)	; Address for TCP options
	  IOR T4,T3
	  SKIPE T3		; If none, don't return any
	    CALL BLTMU		; TCP options to user
	  ANDN. T4		; Anything to user?
	    MOVX T1,PT%TIO	; Options to user
	    TXNN FR,1B0		; TCB trace or
	     TDNE T1,MNTRAC	; Want trace?
	      CALL PRNPKT	; Yes
	ENDIF.
	CALL USTTUM		; Unmap the user space (OKSKED)
	MOVX T1,PT%TBF		; User buffer filled (or PUSHed)
	TXNN FR,1B0		; TCB trace or
	 TDNE T1,MNTRAC		; Want trace?
	  CALL PRNPKT		; Yes
	LOAD T1,TPICR,(TCB)	; Get the RECV% done PSI Channel
	LOAD T2,TPIFR,(TCB)	; And forkx
	SETZ T3,		; Flag from RECV
	CALLRET BFRDUN		; Dispose of the buffer


;BFRDUN	Common ending for USRBFE and USRBFF to initiate user interrupt, dec.
;share counts, return callers Buffer header, and release TCP's buffer header.
;Never called for TVTs.

;T1/	PSI Channel
;T2/	FORKX to PSI
;T3/	Flag: (Came from RECV = 0) or (Came from SEND = -1)
;BFR/	Extended Buffer
;TCB/	Extended Locked connection block
;	CALL BFRDUN
;Ret+1:	Always

BFRDUN:	SAVEAC <FX>
MNTM5	AOS CELL(TCUBD,0,,TCU)	; BFRDUN calls
	NOSKED
	CAIE T1,77		; No channel named?
	 CAIN T2,-1		; Or fork went away?
	IFSKP.			; Means no PSI
	  PUSH P,T3		; Save (RECV=0)/(SEND=-1) flag
	  CALL TCPPSI		; Set off the PSI
	  POP P,T3		; Restore flag for statistics
MNTM5	  AOS CELL(TCUBD,1,,TCU) ; BFRDUN PSIs
	  IFN. T3
	    INCRNO TCCIS,(TCB)	; SEND PSI's for connection
	  ELSE.
	    INCRNO TCCIR,(TCB)	; RECV PSI's for connection
	  ENDIF.
	ENDIF.

	IFQN. BFSRC,(BFR)	; Have to DWNSHR?
	  LOAD T1,BHSPT,(BFR)	; SPT index of section map containing header
	  CALL DWNSHR		; Decrement share count
	  LOAD T1,BDSPT,(BFR)	; SPT index of section map containing data
	  CALL DWNSHR		; Decrement share count
	ENDIF.

	IFQN. BIDX,(BFR)	; Some fork is waiting, keep the Buffer header
	  XMOVEI T1,BFRQ(BFR)	; The item to enqueue
	  MOVE T2,TCPBDQ	; The buffer done queue
	  CALL NQ		; Pick it up later
	  LOAD T1,BIDX,(BFR)	; Get the wait bit index
	  CALL SETWTB		; Make the user wake up now
	  OKSKED
	ELSE.			; No fork waiting, return Buffer header now
	  OKSKED
	  MOVE T1,BFR		; What to release
	  CALL RETBLK		; Return the free storage
	ENDIF.
	RET
> ; End of IFG PART-0
IFL PART-2,<

;USRERR Pass connection error interrupt to user.  May be called for TVTs.

;T1/	Event (error) Code (377B35)
;PRCRST	EFP+^D07 ; RST Received, [will ABTCON(EFP+^D07)]
;REXMIT	ELP+^D09 ; RX timeout, [will ABTCON(ELP+^D14)]
;DEADP	ELP+^D14 ; Inactivity timeout, [will ABTCON(ELP+^D14)]
;TCB/	Extended Locked Connection block
;T2/	TOPS20 error code
;	CALL USRERR
;Ret+1:	Always.  T1 set to zero if interrupt was initiated.

USRERR::			; Only global if two parts
	PUSH P,T1		; Save error code to be returned
	SKIPE T4,T1		; Keep BBN code for later
	  STOR T1,TERR,(TCB)	; Save the BBN error code for user to see
	STOR T2,TCERR,(TCB)	; Save the TOPS20 error code for the user

MNTM5	AOS CELL(TCUUE,0,,TCU)	; USRERR calls
MNTM5<	ANDI T1,<.RTJST(-1,TCP%EC)>> ; Error code
MNTM5	INHSTI(TCUEH,TCU,T1,CX,T3) ; Histogram USRERR codes (CELL()
;cwl hist tops20 codes?
	NOSKED			; Keep TCPPSI and SETWTB together

	IFQE. TSABT,(TCB)	; Forget PSI if ABORT in progress
	  LOAD T1,TPICE,(TCB)	; Get the error channel
	  LOAD T2,TPIFE,(TCB)	; Get the error FORKX
	  CAIE T1,77		; No channel named
	   CAIN T2,-1		; or fork went away
	  ANSKP.		; Skip the PSI
	    CALL TCPPSI		; Poke that fork's channel
MNTM5	    AOS CELL(TCUUE,1,,TCU) ; USRERR PSIs
	    INCRNO TCCIE,(TCB)	; ERROR PSI's for the connection
	    MOVE T4,(P)		; Get code back
	    SETZM (P)		; Initiated interrupt
	ENDIF.

	LOAD T1,TERRF,(TCB)	; Index of the error flag
	SKIPE T4		; Don't wake forks for information only
	  CALL SETWTB		; Set it to wake up waiting process(es)

	OKSKED
	POP P,T1		; Error code or zero if interrupt initiated
	RET

;USREVT	Pass state-change interrupt to user (connection open/closing/closed).

;T1/	Event Code (Error Code) (377B35)
;PRCAW	OK	 ; ESTABLISHED - ACKed a SYN, received a SYN, became SYN.SYN
;PRCSYN
;REMRXQ	XLP+^D03 ; CLOSED - Received ACK of our FIN, became NOT.NOT
;PKTIZE		 ; CLOSED - ACKing received FIN, beame NOT.NOT
;ABTCON	ELT+^D04 ; No free TVT, became NOT.NOT
;ABTCON	EFP+^D07 ; RST received, became NOT.NOT
;ABTCON	ELP+^D07 ; @PZ with TSABT, became NOT.NOT
;PKTIZE	XFP+^D12 ; CLOSING - ACKing received FIN, became NOT.FINSNT
;ABTCON	EFP+^D14 ; ICMP reported error, became NOT.NOT
;ABTCON	ELP+^D14 ; RX timeout, became NOT.NOT

;TCB/	Extended Locked Connection block
;	CALL USREVT
;Ret+1:	Always.  T1/ OK or -1,,ELT+^D04 (No TVTs available)

USREVT::			; Only global if two parts
	ACVAR <CODE>
	MOVEM T1,CODE
MNTM5	AOS CELL(TCUUV,0,,TCU)	; USREVT calls
	MOVX T1,OK		; Assume not TVT error
	JN TSABT,(TCB),R	; Ignore if ABORT in progress

	LOAD T3,TRSYN,(TCB)	; Recv state
	LOAD T4,TSSYN,(TCB)	; Send state
	CAIE T3,NOTSYN
	 CAIN T3,TIMWAT		; Both NOT SYNCHRONIZED?
	  CAIE T4,NOTSYN
	IFSKP.

;State now TIMWAT/NOTSYN.NOTSYN

	  LOAD T1,TOPNF,(TCB)	; Index of open/close wait bit index
	  CALL CLRWTB		; Clear the wait bit (now CLOSED)
MNTM5	  AOS CELL(TCUUV,1,,TCU) ; UEREVT found state not.not
	ELSE.
	  CAIN T3,SYNCED	; Both fully synchronized?
	   CAIE T4,SYNCED
	  ANSKP.

;State now SYNCED.SYNCED

MNTM5	    AOS CELL(TCUUV,2,,TCU) ; USREVT found state syn.syn
	    JN TSOPN,(TCB),R	; Jump if we have already said its open
	    SETONE TSOPN,(TCB)	; Indicate that is now true
	    LOAD T1,TOPNF,(TCB)	; Index of open/close wait bit index
	    CALL SETWTB		; Set the wait bit.
MNTM5	    AOS CELL(TCUUV,3,,TCU) ; USREVT TSOPN'd syn.syn connection
	    LOAD T1,TSMXS,(TCB) ; Set maximum segment size to the largest
	    CALL TCPMXS		; plausible value if the other end has not
	ENDIF.			; specified any limit (now know addresses).

;Any state

	IFQE. TTVT,(TCB)

;Connection is NOT a TVT

	  MOVE T1,CODE		; Histogram code
MNTM5<	  ANDI T1,<.RTJST(-1,TCP%EC)>> ; Just code
MNTM5	  INHSTI(TCUVU,TCU,T1,T2,T3) ; Histogram user codes by USREVT

	  LOAD T1,TPICX,(TCB)	; Get Status-Change channel
	  LOAD T2,TPIFX,(TCB)	; And FORKX to PSI
	  CAIE T1,77		; No channel named
	   CAIN T2,-1		; or fork went away,
	  IFSKP.
	    CALL TCPPSI		; Set off the PSI
	    INCRNO TCCIX,(TCB)	; STATE CHANGE PSI's for connection
	  ENDIF.
	  MOVX T1,OK		; No error
	  RET
	ENDIF.

; Here for TVT actions

USREV3:	MOVE T1,CODE		; Histogram code
MNTM5<	ANDI T1,<.RTJST(-1,TCP%EC)>> ; Just code
MNTM5	INHSTI(TCUVT,TCU,T1,T2,T3) ; Histogram TVT codes by USREVT (CELL()

	CAIN CODE,OK		; What kind of event is this?
	IFSKP.
	  MOVE T1,CODE		; Must be something to do with closing
	  CALLRET TVTCLS	; Go close the Virtual terminal
	ENDIF.

	CALL TVTOPN		; Open a TCP Virtual Terminal
	JUMPE T1,R		; Done if TVT assigned

	MOVEM T1,CODE		; Save error code (ELT+^D04)
MNTM5	AOS CELL(TCUUV,4,,TCU)	; USREVT TVTOPN failures


;Failed to assign a TVT to the connection.  The connection is now
;synchronized in both directions.  Try to send an error message to
;the other end before we abort the connection so the user has some
;idea of why the connection is being aborted.


	PUSH P,PKT		; Save these
	PUSH P,TPKT
	MOVX T1,TVTFLN*4	; Message length, words
	SETZ T2,		; Have a TCB
	CALL TCPIPK		; Get empty packet
	  JRST USREV7		; Failed, just abort connection
	LOAD T1,PIPL,(PKT)	; Update packet byte length
	ADDI T1,TVTFLN*4
	STOR T1,PIPL,(PKT)
	MOVX T1,TVTFLN		; Move message into packet
	XMOVEI T2,TVTFUL
	LOAD T3,PTDO,(TPKT)
	ADD T3,TPKT
	CALL XBLTA

	SETONE <PPSH,PFIN>,(TPKT) ; This is the last data
	LOAD T1,TSSEQ,(TCB)	; Set the sequence #
	STOR T1,PSEQ,(TPKT)
	ADDI T1,TVTFLN*4+1	; End seq # is initial + data + FIN
	MODSEQ T1
	STOR T1,TSSEQ,(TCB)	; Advance Send sequence
	STOR T1,PESEQ,(PKT)	; Save recomputed end of packet
	SETZRO PPROG,(PKT)	; Don't bother with retransmissions

REPEAT 0,<
	IFQN. INS%SC		; In secure mode?
	ANDQN. PPROG,(PKT)	; See if pkt will be ACK'd
	  LOAD T2,TSLVN,(TCB)	; Guaranteed that KDC will hear the word
	  STOR T3,TSLVC,(TCB)	; So update the current level
	ENDIF.
> ; End of REPEAT 0

	SETO T1,		; No TVT line block
	CALL EMTPKT		; Send the packet
	AOS FINSCT
USREV7:
	POP P,TPKT		; Restore registers
	POP P,PKT

	MOVE T1,CODE		; Error code
	CALL ABTTCB		; Abort the connection - in Job0/Owner here
	MOVE T1,CODE		; Return the error (ABTCON/USREVT/TVTCLS)
	RET

	ENDAV.

TVTFUL:	BYTE (8)"4","2","1"," ","N","o"," ","f","r","e","e"," "
	BYTE (8)"t","e","r","m","i","n","a","l","s",15,12
TVTFLN==.-TVTFUL

;USRSYN	Signal the arrival of the first SYN for a connection by interrupting
; the user.

;TCB/	Extended Locked TCB
;	CALL USRSYN
;Returns: +1 always.

USRSYN:
MNTM5	AOS CELL(TCUUS,0,,TCU)	; USRSYN calls
	LOAD T1,TPICX,(TCB)	; Get State-Change channel
	LOAD T2,TPIFX,(TCB)	; And FORX to PSI
	CAIE T1,77		; No channel named
	 CAIN T2,-1		; or fork went away,
	IFSKP.			; Means no PSI, just return
	  CALL TCPPSI		; Set off the PSI
MNTM5	  AOS CELL(TCUUS,1,,TCU)  ; USRSYN psi's
	  INCRNO TCCIX,(TCB)	; STATE CHANGE PSI's for connection
	ENDIF.
	RET




;USRURG	Pass urgent data interrupt to user.

;TCB/	Extended Locked Connection Block
;	CALL USRURG
;Ret+1:	Always.

USRURG:
MNTM5	AOS CELL(TCUUU,0,,TCU)	; USRURG calls
	IFQE. TSABT,(TCB)	; Forget if ABORT in progress
	  LOAD T1,TPICU,(TCB)	; Get the URG channel
	  LOAD T2,TPIFU,(TCB)	; and FORKX
	  CAIE T1,77		; None named
	   CAIN T2,-1		; or fork went away
	  ANSKP.		; Skip the PSI
	    CALL TCPPSI		; Request the PSI in that fork
MNTM5	    AOS CELL(TCUUU,1,,TCU) ; USRURG PSIs
	    INCRNO TCCIU,(TCB)	; URGENT PSI's for connection
	ENDIF.
	RET
;cwl usrbfe,usrbff,bfrdun

;TCPPSI	Initiate user interrupt.

;T1/	Channel
;T2/	FORKX
;	CALL TCPPSI
;Ret+1:	Always

TCPPSI::			; Only global if two parts
	MOVE T3,T1		; Channel
	MOVX T1,PT%TIU		; User interrupt request
	TXNN FR,1B0		; TCB trace or
	 TDNE T1,MNTRAC		; Want trace?
	  CALL PRNPKT		; Yes
	MOVE T1,T3		; Get arg back

	CALLRET PSIRQ		; Request PI
> ; End of IFL PART-2

	TNXEND
	END
