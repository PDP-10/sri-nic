;Merge CMU and BBN code
;<MONITOR.CMU>IPIPIP.MAC.7, 27-Sep-85 15:25:25, Edit by VAF
;CM236 Make INTWA1 a BUGHLT.
;<MONITOR.CMU>IPIPIP.MAC.6, 13-Aug-85 14:43:34, Edit by VAF
;CS147 For incoming ICMP messages, look at count of queue header, not count
;      in statistics block to see if there are any messages. The statistics
;      block does not exist unless MNTMN is GEQ 5.
;CS147 Put all of the gateway ping stats undef MNTM5 (from MNTM0).
;CS147 Conditionalize monitoring code on IPMONF.
;<MONITOR.CMU>IPIPIP.MAC.2, 12-Aug-85 19:37:53, Edit by VAF
;CS147 Search PROLGX - no bugs.
;CS147 Check INQON before attempting to do RCVIN

; UPD ID= 3936, SNARK:<6.MONITOR>IPIPIP.MAC.14,  17-Mar-84 13:01:43 by PAETZOLD
;More TCO 6.1733 - More cleanup.
; UPD ID= 3895, SNARK:<6.MONITOR>IPIPIP.MAC.13,  11-Mar-84 10:36:30 by PAETZOLD
;More TCO 6.1733 - Handle destination unreachable ICMP messages. Change
;GWYFNB  BUGHLT  into  a BUGHCK and handle it. Remove NTHSHF BUGHLT. Up
;the hold time of the internet fork to one second.  Do check  IMPNOS in
;INTBPT.
; UPD ID= 3824, SNARK:<6.MONITOR>IPIPIP.MAC.12,  29-Feb-84 18:13:31 by PAETZOLD
;More TCO 6.1733 - ANBSEC and MNTSEC removal. Bug fixes.  Cleanup.
; UPD ID= 3204, SNARK:<6.MONITOR>IPIPIP.MAC.11,  20-Nov-83 18:49:59 by PAETZOLD
;TCO 6.1872 - Always call SIQCHK in INTBP1
; UPD ID= 3172, SNARK:<6.MONITOR>IPIPIP.MAC.10,  16-Nov-83 18:23:07 by PAETZOLD
;TCO 6.1867 - Use SAVEAC and not SAVP1
; UPD ID= 3161, SNARK:<6.MONITOR>IPIPIP.MAC.9,  16-Nov-83 13:41:04 by PAETZOLD
;Remove foolish question mark from INGWA1
; UPD ID= 3071, SNARK:<6.MONITOR>IPIPIP.MAC.8,  25-Oct-83 11:12:02 by PAETZOLD
;Move gateway block symbols to ANAUNV from here
; UPD ID= 3060, SNARK:<6.MONITOR>IPIPIP.MAC.7,  22-Oct-83 09:34:49 by PAETZOLD
;TCO 6.1836 - Make GWYINI global
; UPD ID= 2992, SNARK:<6.MONITOR>IPIPIP.MAC.6,   5-Oct-83 14:49:00 by PAETZOLD
;More TCO 6.1733 - Fix some Gateway problems
; UPD ID= 2868, SNARK:<6.MONITOR>IPIPIP.MAC.5,  25-Aug-83 10:53:44 by PURRETTA
; UPD ID= 2789, SNARK:<6.MONITOR>IPIPIP.MAC.4,   3-Aug-83 13:23:14 by PAETZOLD
;TCO 6.1630 - PSIMB/MONBK Fix
; UPD ID= 2723, SNARK:<6.MONITOR>IPIPIP.MAC.3,  22-Jul-83 14:56:29 by PAETZOLD
;TCO 6.1733 - Merge TCP/IP changes in release 6 again
;<TCPIP.5.1.MONITOR>IPIPIP.MAC.7,  5-Jul-83 08:25:46, Edit by PAETZOLD
;TCP Merge for 5.1



;THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY ONLY BE USED
;  OR COPIED IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
;COPYRIGHT (C) 1982,1983,1984,
;BY DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.

IFDEF  CMU,<	SEARCH ANAUNV,PROLGX	;CS147 >
IFNDEF CMU,<	SEARCH ANAUNV,PROLOG >
	TTITLE (IPIPIP,IPIPIP,< - ARPANET Internet Protocols>)

	;RESCD	;ps

	IF1 <IFN IPLDSW,<PRINTX Assembling Debuging IP Locking Routines>>
	IF1 <IFN IPQDSW,<PRINTX Assembling Debuging IP Queue Routines>>


	SUBTTL	Internet Once-only Initialization

	SWAPCD	;ps Process level
					; Global AC usage
;DEFACY(VNCT,P1);ps			; 10 Address of an NCT
VNCT==P1

;INTBEG	Initialize the Internet Protocols, called by Multinet at system
; startup time.  N.B. System startup code clears all resident variables.
; In particular all queues to/from interrupt level are "empty".

;	CALL INTBEG
;Ret+1:	Always.

INTBEG::
	SE1CAL				; Make sure in section 1

	MOVE T2,[777777,,777760]	; Initialize scheduler test wait bits
	MOVEM T2,INTBFF
	MOVE T1,[INTBFF,,INTBFF+1]	; Indicate bits free
	BLT T1,INTBFF+NTWBWD-1
	TXZ T2,1B0
	MOVEM T2,INTBFF			; Never use index 0

	CALL FREINI			; Initialize Internet free storage

	MOVSI T1,(CR%CAP)
	CFORK%				; Get a fork of JOB0
	  BUG.(HLT,INTMA0,IPIPIP,SOFT,<INTBEG: Can't create Internet fork>,,<
Cause:	JOB0 has exceeded the maximum number of forks which a job is permitted.

Action:	Try moving some JOB0 jobs to another job, or increasing the monitor
	assembly parameter NFKS and rebuilding the system.
>)
	XMOVEI T2,INTBP0
	MSFRK%				; Start fork in monitor mode

	MOVSI T1,(CR%CAP)
	CFORK%				; Get a fork of JOB0
	  BUG.(HLT,INTMA1,IPIPIP,SOFT,
<INTBEG: Can't create Internet utility fork>,,<
Cause:	JOB0 has exceeded the maximum number of forks which a job is permitted.

Action:	Try moving some JOB0 jobs to another job, or increasing the monitor
	assembly parameter NFKS and rebuilding the system.
>)
	XMOVEI T2,INTUT0
	MSFRK%				; Start fork in monitor mode
	RET

	SUBTTL	Main Internet fork, once-only initialization.

INTBP0:	MOVX Q2,INTUXI			; Unexpected interrupt address
	CALL MNTFKI			; Setup high priority monitor fork
	MOVEM T1,INTFRK			; Save for debugging

; Wait here if protocols are not to be started (e.g. DBUGSW = 2)

	MOVEI T1,NETSUP			; Will be negative to proceed
	CALL DISL

	HRRE T1,INTON			; Want IP up? (1B18 implies yes)
	TRZ T1,-1			; Initialization complete
	MOVEM T1,INTON			; ON is -1,,0,  OFF is 0

;Initialize protocols above IP (ICMP,User Queues, TCP).

					; Initialization AC usage
;DEFACY(PIX,Q1);ps			; Protocol AOBJN counter
PIX==Q1
;DEFACY(PTB,Q2)				; Pointer to protocol table
PTB==Q2
;DEFACY(PTL,Q3)				; Length of protocol table
PTL==Q3


	MOVEI PTB,INTPIX+1		; Locate first table
	MOVE PIX,-1(PTB)		; Get # of protocols
	HRRZ PTL,PIX			; Table length
	DO.
	  MOVE T1,.INTPO(PTB)
	  TXNE T1,1B35			; Want it initialized and
	   SKIPG T2,.INTPI(PTB)		; Have xxxINI address?
	    TRNA
	     CALL (T2)			; Yes, initialize protocol
	  ADD PTB,PTL			; Next protocol
	  AOBJN PIX,TOP.
	ENDDO.
	JRST INTBP1			; Join main loop

;DEFACY(Q1,PIX)	;ps			; Terminate alternate definitions
;DEFACY(Q2,PTB)
;DEFACY(Q3,PTL)
PURGE PIX,PTB,PTL

; Utility fork once-only initialization

INTUT0:	MOVX Q2,INTU2I			; Unexpected interrupt address
	CALL MNTFKI			; Setup high priority monitor fork
	MOVEM T1,INTFRK+1		; Save for debugging

; Wait here if protocols are not to be started (e.g. DBUGSW = 2)

	MOVEI T1,NETSUP			; Will be negative to proceed
	CALL DISL

	MOVEI T1,INTON			; Wait for IP to be initialized
	CALL DISLE
	JRST INTUT1			; Join main loop

	SUBTTL	Lock Handling

COMMENT	!

These routines are the lowest level lock manipulating functions. This
whole  module  may  be  replaced  by  some  other for the purposes of
testing as long as the functionality of the  individual  routines  is
preserved.

!
	SUBTTL Lock Handling - Clear and Release Locks

;CLRLCK	Initialize a lock.
;T1/	(Extended) Pointer to lock
;	CALL CLRLCK
;Ret+1:	Always.  T1 is -1,,MNTX24 if no wait bit available

CLRLCK::
	ACVAR <LOCKPT>
	MOVEM T1,LOCKPT
MNTM5	AOS CELL(INLAA,1,,INL)		; CLRLCK calls

	SETZM (LOCKPT)			; Clear first word in block
	MOVX T1,LOCKSZ-1		; Additional words
	XMOVEI T2,(LOCKPT)		; First word
	XMOVEI T3,1(LOCKPT)		; Second
	CALL XBLTA			; Clear them all

	CALL ASNWTB			; Assign a wait bit index
	SKIPL T1			; Get a bit?
	  STOR T1,LIDX,(LOCKPT)		; Yes

	SETONE LWORD,(LOCKPT)
	RET
	ENDAV.



;RELLCK	Release a lock handle.
;T1/	(Extended) Pointer to lock
;	CALL RELLCK
;Ret+1:	always

RELLCK::
MNTM5	AOS CELL(INLAA,2,,INL)		; RELLCK calls
	LOAD T1,LIDX,(T1)		; Wait bit index
	CALLRET RELWTB			; Release it

	SUBTTL Lock Handling - Seize Locks and Free Locks

;SETLCK	Seize a lock.
;T1/	(Extended) Pointer to lock
;T2/	Caller ID in B0-8, or zero to use TCP "PROC"
;	CALL SETLCK
;Ret+1:	Always.  NOINT, lock set.

	%LTIME (<;>)			; Get $LTIME defined

SETLCK::
	ACVAR <LOCKPT,CALLER,WAITIM>
MNTM5	AOS CELL(INLSL,0,,INL)		; SETLCK calls

	HLRZ CALLER,T2			; Possible ID
	SKIPN CALLER			; ID specified?
	 SKIPN CALLER,PROC		; No, try TCP process ID
	  ADD CALLER,JOBNO		; Yes (or no PROC), use job number
	MOVEM T1,LOCKPT			; Save Lock address & caller id
	MOVN WAITIM,TODCLK		; Measure duration
	DO.
	  NOINT
	  LOAD T1,LIDX,(LOCKPT)		; Get the wait bit index
	  CALL SETWTB			; Set it
	  AOSN $LWORD(LOCKPT)		; Attempt to get the lock
	   EXIT.			; Got it.  Return NOINT.
	  TLO CALLER,400000		; Remember had to wait at least once
MNTM5	  AOS CELL(INLSL,1,,INL)	; Conflicts in SETLCK
MNTM0	  AOS GENCFL			; Count up general conflicts
	  INCRNO LCCNT,(LOCKPT)		; Increment the conflict count
	  LOAD T2,LLOKR,(LOCKPT)	; Get the current locker
	  STOR T2,LOLKR,(LOCKPT)	; Save as the Old locker
	  STOR CALLER,LNLKR,(LOCKPT)	; Save this as the New locker
	  OKINT
	  LOAD T1,LIDX,(LOCKPT)		; Get the wait bit index
	  HRLI T1,INTBZT		; Select the wait bit zero test
	  MOVSS T1
	  MDISMS
	  JRST TOP.
	ENDDO.

; Have the lock

	STOR CALLER,LLOKR,(LOCKPT)	; Remember who set the lock
	ADD WAITIM,TODCLK		; Accululate time for caller
MNTM5<	ADDM WAITIM,CELL(INLSL,3,,INL)>	; Accumulate time in SETLCK
IFN <LTIME&1B35>,<ADDM WAITIM,$LTIME(LOCKPT)>; Accumulate time waiting for lock
IFE <LTIME&1B35>,<LOAD CX,LTIME,(LOCKPT); Get current value
		  ADD CX,WAITIM		; Add in new increment
		  STOR CX,LTIME,(LOCKPT)>; Update structure
	SKIPG WAITIM			; Have to wait?
	IFSKP.
MNTM5	  AOS CELL(INLSL,2,,INL)	; System wide # waits for lock
	  INCRNO LNWAT,(LOCKPT)		; Waits for lock
	ENDIF.
	MOVE T4,WAITIM			; Return time
	RET
	ENDAV.



;UNLCK	Free a lock.
;T1/	(Extended) Pointer to lock
;	CALL UNLCK
;Ret+1:	Always, OKINT.

UNLCK::
MNTM5	AOS CELL(INLAA,3,,INL)		; UNLCK calls
	SETONE LWORD,(T1)
	LOAD T1,LIDX,(T1)		; Get the wait bit index
	CALL CLRWTB			; Indicate not locked
	OKINT
	RET


;LCKCAL	Call Fn(Arg1, Arg2) with Lock set & NOINT
;T1/	(Extended) Lock pointer
;T2/	(Extended) Function address & ID in B0-8
;T3/	Arg1
;T4/	Arg2
;	CALL LCKCAL
;Ret+1:	always.  T1 has value of Fn(Arg1, Arg2)
; Can be used for cross-section calls (T2/ has real-waiting-time)

LCKCAL::
MNTM5	AOS CELL(INLAA,4,,INL)		; LCKCAL calls
	PUSH P,BHC+0			; Zero time
	PUSH P,T1			; (Ext) Lock address (save for UNLCK)
	PUSH P,T2			; (Ext) Function to CALL (& ID)
	PUSH P,T3			; Save args from SETLCK
	PUSH P,T4

	ANDX T2,<777B8>			; Extract ID and
	ANDCAM T2,-2(P)			; Clean up Ext Function address
	CALL SETLCK			; Test and set the lock (may wait)
	MOVEM T4,-4(P)			; Save waiting time

	POP P,T2			; Put args in standard place for a call
	POP P,T1
	CALL @0(P)			; Call function

	SUB P,BHC+1			; Drop Function address
	EXCH T1,0(P)			; Save the return value while
	CALL UNLCK			; Unlock
	POP P,T1			; Value returned
	POP P,T2			; Time waiting
	RET

	SUBTTL	Queue Handling 

COMMENT	!

Queues are double linked lists. The QPREV field points back to the previous
item, the QNEXT field points forward to the next item, and the QHDR field
points to the queue head.  Each queue has a head which looks like any other
item.  When a queue is empty, the previous and next pointers of the head
both point at the head itself.  The QCNT field contains the count of the
number of entries that are currently in the queue (zero when empty).  The
QMAX field contains the maximum number of entries that were in the queue,
and the QMWHN field contains TODCLK shifted -9 bits (resolution 1/2 second)
of when the maximum was recorded.  The high order bit of QMAX (QLHR)
signals that the status monitoring information has been read and that a new
maximum for the next monitoring interval should be set.

!


	SUBTTL Queue Handling - Event Tracking

; IP Queue Manipulation Debugging code and storage

IFN IPQDSW,<
;	Queue event ring buffer entries have the following format
	.IPQFX==0		; word 0/ 525252,,FORKX
	.IPQBK==1		; word 1/ Address of ITEM
	.IPQQH==2		; word 2/ address of queue head pointer
	.IPQTD==3		; word 3/ TODCLK value
	.IPQHP==4		; word 4/ HP time value
	.IPQTK==5		; word 5/ Stack Cells
	.IPQTS==5		; number of stack words to save
	IPQLEN==<.IPQTK+.IPQTS>-.IPQFX+1 ; Length of ring entry
	IPQRNN==^D50		; number of entries in ring buffer

RS IPQRNG,<IPQRNN*IPQLEN>	; QUEUE EVENT RING BUFFER
RS IPQADR,1			; CURRENT RING BUFFER ADDRESS


	RESCD			;ps THIS CODE IS RESIDENT
IPQTRK:				; TRACK IP QUEUE EVENTS
	PUSH P,T1		; SAVE ACS (CAN NOT USE SAVEAC)
	PUSH P,T2
	PUSH P,T3
	PUSH P,T4
	SETO T3,		; ASSUME PI IS ON
	CONSO PI,PIPION		; IS PI ON?
	 TDZA T3,T3		; NO SO TURN OFF FLAG
          PIOFF			; YES SO MAKE THE MACHINE MINE
	MOVE T1,IPQADR		; GET THE CURRENT RING POINTER
	ADDI T1,IPQRNG		; OFFSET BY BASE ADDRESS OF THE RING BUFFER
	HRRZ T2,FORKX		; GET OUR FORKX
	HRLI T2,525252		; GET THE MAGIC CODE
	MOVEM T2,.IPQFX(T1)	; SAVE THE FIRST WORD
	MOVE T2,-3(P)		; GET THE ADDRESS OF THE BLOCK
	MOVEM T2,.IPQBK(T1)	; SAVE IT
	MOVE T2,-2(P)		; GET THE ADDRESS OF THE QUEUE HEADER
	MOVEM T2,.IPQQH(T1)	; SAVE IT
	MOVE T2,TODCLK		; GET THE CURRENT TODLCK
	MOVEM T2,.IPQTD(T1)	; SAVE TODCLK VALUE ALSO
	PUSH P,T1		; SAVE T1
	JSP T4,MTIME		; GET THE HPTIM
	MOVE T2,T1		; GET TIME IN PROPER PLACE
	POP P,T1		; RESTORE
	MOVEM T2,.IPQHP(T1)
				; NOW SAVE THE LAST .IPSTS STACK CELLS
	HRLI T2,-<.IPQTS+3>(P)	; GET THE ADDRESS OF THE FIRST STACK WORD
	HRRI T2,.IPQTK(T1)	; GET THE ADDRESS OF THE FIRST RING STACK WORD
	BLT T2,<.IPQTK+.IPQTS-1>(T1) ; SAVE THE STACK CELLS
				; NOW MOVE THE RING BUFFER ADDRESS
	MOVE T1,IPQADR		; GET THE RING ADDRESS AGAIN
	ADDI T1,IPQLEN		; BUMP THE RING POINTER
	CAIL T1,<IPQLEN*IPQRNN>	; SHOULD THE POINTER LOOP AROUND?
	 SETZ T1,		; YES SO MAKE IT LOOP
	MOVEM T1,IPQADR		; SAVE THE NEW RING POINTER
	SKIPE T3		; SHOULD WE GO PION?
         PION			; YES SO GIVE BACK THE MACHINE
	JRST PA4		; POP ACS AND RETURN TO CALLER

	SWAPCD	;ps		; CODE IS NOW SWAPPABLE AGAIN
>					; end of IPQDSW

	SUBTTL Queue Handling - Enqueueing

;NQ	Add an item to a queue just to the left of another item.
;Usual  application  is  where the other item is the queue head. This
;has the effect of adding the new item to the end of the queue.

;T1/	(Extended) Item pointer
;T2/	(Extended) Queue head pointer
;	CALL NQ
;Ret+1:	Always, value is the new item.
;Preserves T1,T2,T3,T4.

NQ::
IFN IPQDSW,<CALL IPQTRK>		; If debuging queue maniulations
MNTM5	AOS CELL(INQAA,2,,INQ)		; NQ calls
	SKIPE (T1)			; Make sure item not already queued
	  BUG.(HLT,INTNQ1,IPIPIP,SOFT,<NQ: Item not dequeued - item/q>,
<<T1,ITEM>,<(T2),QHEAD>>,<

Cause:	An item to be placed into a queue appears to already be in some
	queue.  This may be due to either actually already being in the
	queue, or may be the result of a bad pointer to the item.

Action:	Try to determine which reason is applicable.

Data:	Pointer to the item (from T1), the contents of the queue forward
	link, which should have been zero.
>)
	STOR T2,QNEXT,(T1)		; Make Item point forward to the head
	LOAD CX,QPREV,(T2)		; Pointer to thing to left of head
	STOR CX,QPREV,(T1)		; Is now to the left of new item
	STOR T1,QNEXT,(CX)		; New item is now to right of prev.
	STOR T1,QPREV,(T2)		; And to left of the head.
	PUSH P,T3			; Save some ACs
	PUSH P,T4
	LOAD T3,QHDR,(T2)		; Get the head pointer
	STOR T3,QHDR,(T1)		; And make item point to the head
	LOAD T4,QCNT,(T3)		; Get the count from the header
	AOJ T4,				; Add 1
	CAMLE T4,TPQMAX			; Larger than the maximum allowed?
	  BUG.(CHK,INTQ2L,IPIPIP,SOFT,<NQ: Queue too long>,
<<T2,ITEM>,<T3,QHDR>,<T4,QCNT>>,<


Cause:	The number of entries in the queue has grown too large.
	This indicates that there is a problem with the particular
	queue.  Possibly trouble with a network	interface.

Action:	Try to determine the problem with the queue, correct it,
	and proceed.

Data:	Item that was queued, the queue header and the incremented
	count of the number of items in the queue.
>)


; QCNT and QMAX must be in the same bit positions
IFN <QCNT-QMAX>,<PRINTX ?NQ: QCNT and QMAX not in same bit position
>
; QMAX must have bit 0 on
IFE <QMAX&<1B0>>,<PRINTX ?NQ: QMAX must use bit 0
>

	CAILE T4,.RTJST(-1,QCNT1)	; Greater than field width
					;  excluding bit 0?
	  MOVEI T4,.RTJST(-1,QCNT1)	; Yes, Don't overflow the count
	STOR T4,QCNT,(T3)		; Save the new count
	SKIPL CX,$QMAX(T3)		; Get the maximum word, skip if
					; monitoring information sent
	  CAMGE CX,$QCNT(T3)		; Compare to count word
	  IFNSK.			; Here when monitoring info
					;  recorded or new maximum found
	    STOR T4,QMAX,(T3)		; Save the new maximum
	    LDB T4,[POINT 27,TODCLK,26]	; Get TODCLK shifted -9 bits
	    STOR T4,QMWHN,(T3)		; Save when
	  ENDIF.
	POP P,T4			; Restore the ACs
	POP P,T3
	RET




	SUBTTL Queue Handling - Initialization

;INITQ	Initialize a queue head.
;T1/	(Extended) Pointer to the queue head
;	CALL INITQ
;Ret+1:	Always.

INITQ::
MNTM5	AOS CELL(INQAA,1,,INQ)		; INITQ calls

.Q==0
REPEAT QSZ,<	SETZM .Q(T1)		; Clear the Q head
	.Q==.Q+1>
PURGE .Q

	STOR T1,QPREV,(T1)		; Make previous(head) point to the head
	STOR T1,QNEXT,(T1)		; Make next(head) point to the head
	STOR T1,QHDR,(T1)		; Make head(head) point to head
	RET


;DQ	Remove an item from a queue.
;T1/	(Extended) Pointer to the item to be dequeued
;	CALL DQ
;Ret+1:	always.  Queue slot is cleared.
;Preserves T1,T3,T4
;Kills T2.

DQ::
IFN IPQDSW,<CALL IPQTRK>		; If debuging queue maniulations
MNTM5	AOS CELL(INQAA,3,,INQ)		; DQ calls
	SKIPN (T1)			; Make sure item is in a queue
	  BUG.(HLT,INTDQ1,IPIPIP,SOFT,<DQ: Item not queued>,<<T1,ITEM>>,<

Cause:	An item to be removed from a queue does not appear to be in any
	queue.  This may be due to either actually not being in the
	queue, or may be the result of a bad pointer to the item.

Action:	Try to determine which reason is applicable.

Data:	Pointer to the item (from T1).

>)
	LOAD T2,QHDR,(T1)		; Get address of queue head
	LOAD CX,QHDR,(T2)		; Head's head ought to be same
	CAME CX,T2			; Look reasonable?
	  BUG.(HLT,INTDQ2,IPIPIP,SOFT,
<DQ: Item's header conflicts with purported header's header>,
<<T1,Item>,<T2,Item's header>,<CX,Header therein>>,<

Cause:	The queue header entry in an item to be removed from a queue 
	points to something which does not appear to be a queue head
	because its own header entry is different.

Action:	Try to determine if the address of the item to be dequeued is
	wrong or whether the queue head has been clobbered.

Data:	Pointer to the item, purported header from the item, and
	header entry from purported header.

>)
	LOAD CX,QCNT,(T2)		; Get the current count
	SOSL CX				; Decrement the count
	  STOR CX,QCNT,(T2)		; But not negative
	IFL. CX
	  BUG.(CHK,INTDQ3,IPIPIP,SOFT,<DQ: Attempt to DQ from empty queue>,
<<T1,DQITEM>,<T3,QHEADR>>,<

Cause:	DQ attempted to over decrement a queue count.  Indicates either a
	bad pointer to an item to be dequeued, or an attempt to dequeue
	an item from an empty queue.

Action:	Compare the queue head pointer in the item to be dequeued with
	the actual queue header.  If they differ, it indicates that the
	pointer to the item to be dequeued is bad.  In any case, notify 
	the software staff.

Data:	Item to be dequeued, pointer to header found in item to be
	dequeued.

>)
	ENDIF.
	LOAD T2,QPREV,(T1)		; Dequeue the item
	LOAD CX,QNEXT,(T1)
	STOR CX,QNEXT,(T2)
	STOR T2,QPREV,(CX)
	SETZM (T1)			; Indicate this item not queued.
	RET

	SUBTTL	Wait Bit Routines

COMMENT	!

INTWTB is a pool of bits which are dynamically assigned to things for
which the Internet may have to wait such as non-resident locks, and
buffer done conditions.  These bits are in resident storage for
access by scheduler test routines.

INTBFF is a parallel bit table which tells which bits are free.
These bits are in resident storage for efficiency reasons.

!



	SUBTTL	Wait Bit Assignment, and Deassignment

;ASNWTB	Assign a wait bit index.
;	CALL ASNWTB
;Ret+1:	Always. T1 has the index or -1,,MNTX24 (resource shortage)

ASNWTB::
MNTM5	AOS CELL(INWAW,0,,INW)		; ASNWTB calls
	NOSKED				; Only one process at a time
	MOVSI T3,-NTWBWD		; Number of words in bit table
	DO.
	  SKIPE T1,INTBFF(T3)		; Any free bits in this word?
	  JFFO T1,ASNWT1		; Yes.  Get bit number
	  AOBJN T3,TOP.			; No.  Try next
	ENDDO.
	OKSKED
MNTM5	AOS CELL(INWAW,1,,INW)		; ASNWTB failures
MNTM0	AOS ASNWTF			; ASNWTB failures
	HRROI T1,MNTX24			; "Resource shortage"
	RET				; No free buffer bits


ASNWT1:	MOVE T1,BITS(T2)		; Get the corresponding bit mask
	ANDCAM T1,INTBFF(T3)		; Make it not free
	OKSKED
	HRRZ T1,T3			; Get word offset
	LSH T1,5			; Convert to bits
	ADD T1,T2			; Add bit within last word
	RET


;RELWTB	Release the wait bit assignment.
;T1/	Bit index to INTWTB
;	CALL RELWTB
;Ret+1:	Always.

RELWTB::
MNTM5	AOS CELL(INWAA,1,,INW)		; RELWTB calls
	JUMPE T1,R			; Beware

	SETZ T2,			; Convert index to
	LSHC T1,-5			; Word offset
	ROT T2,5			; And bit within word
	MOVE T2,BITS(T2)		; Get corresponding bit mask
	TDNE T2,INTBFF(T1)		; Better be in use right now.
	  BUG.(HLT,INTWA0,IPIPIP,SOFT,
<RELWTB: Attempt to release unassigned wait bit - off/bit>,<<T1,D>,<T2,D>>,<

Cause:	An unassigned wait bit is being released.  The bit index has the
	corresponding bit-free bit set in INTBFF.  The problem may be due
	to a bad bit index, or trying to release the same bit more than
	once.

Action:	Determine which situation applies.

Data:	The word offset (into INTBFF) and bit mask.  The bit index is
	32 * word offset + bit number from mask.

>)
	IORM T2,INTBFF(T1)		; Free it
	RET

	SUBTTL Wait Bit State Changing Routines

;SETWTB	Set a wait bit to one state.
;T1/	Index of bit
;	CALL SETWTB
;Ret+1:	Always.

SETWTB::
MNTM5	AOS CELL(INWAA,2,,INW)		; SETWTB calls
	SETZ T2,			; Beware bit 0
	JUMPE T1,SETWTE
	LSHC T1,-5			; Word offset
	ROT T2,5			; And bit within word
	MOVE T2,BITS(T2)		; Get bit mask
	TDNE T2,INTBFF(T1)		; Check that it is assigned
SETWTE:	  BUG.(HLT,INTWA1,IPIPIP,SOFT,
<SETWTB: Attempt to SET uassigned wait bit - off/bit>,<<T1,D>,<T2,D>>,<
Cause:	An unassigned wait bit is to be set.  The bit index has the
	corresponding bit-free bit set in INTBFF.  The problem may be due
	to a bad bit index, or trying to use a bit that has been released.

Action:	Determine which situation applies.

Data:	The word offset (into INTBFF) and bit mask.  The bit index is
	32 * word offset + bit number from mask.

>)
	IORM T2,INTWTB(T1)		; Set the bit
	RET


;CLRWTB	Clear a wait bit to zero state.
;T1/	Index of bit
;	CALL CLRWTB
;Ret+1:	Always.

CLRWTB::
MNTM5	AOS CELL(INWAA,3,,INW)		; CLRWTB calls
	SETZ T2,			; Beware bit 0
	JUMPE T1,CLRWTE
	LSHC T1,-5			; Word offset
	ROT T2,5			; And bit within word
	MOVE T2,BITS(T2)
	TDNE T2,INTBFF(T1)
CLRWTE:	  BUG.(CHK,INTWA2,IPIPIP,SOFT,
<CLRWTB: Attempt to CLEAR unassigned wait bit - off/bit>,<<T1,D>,<T2,D>>,<

Cause:	An unassigned wait bit is to be cleared.  The bit index has the
	corresponding bit-free bit set in INTBFF.  The problem may be due
	to a bad bit index, or trying to use a bit that has been released.

Action:	Determine which situation applies.

Data:	The word offset (into INTBFF) and bit mask.  The bit index is
	32 * word offset + bit number from mask.

>)
	ANDCAM T2,INTWTB(T1)
	RET

	SUBTTL Wait Bit Single Bit Scheduler Test Routines

	RESCD	;ps Scheduler test routines

;INTBZT	Scheduler test for a wait bit zero.
;T1/	Wait Bit Index
;T4/	Return address to continue waiting
;	JSP T4,INTBZT
;Ret+1:	 Bit not zero
;Ret+2:	Bit is zero

INTBZT:
MNTM9	AOS CELL(INWBZ,0,,INW)		; INTBZT calls
	JUMPE T1,INTBZX			; Beware bit 0
	SETZ T2,			; Convert index to
	LSHC T1,-5			; Word offset
	ROT T2,5			; And bit within word
	MOVE T2,BITS(T2)		; Get bit mask
	TDNN T2,INTWTB(T1)		; Zero yet?
INTBZX:	  JRST 1(T4)			; Yes, stop waiting
MNTM9	AOS CELL(INWBZ,1,,INW)		; INTBZT waits longer
	JRST 0(T4)			; Keep waiting



;INTBOT	Scheduler test for a wait bit being on.
;T1/	Index to INTWTB
;T4/	Return address to continue waiting
;	JSP T4,INTBOT
;Ret+1:	 Wait flag still off
;Ret+2:	Wait flag now on

INTBOT:
MNTM9	AOS CELL(INWBO,0,,INW)		; INTBOT calls
	JUMPE T1,INTBOX			; Beware bit 0
	SETZ T2,			; Convert index to
	LSHC T1,-5			; Word offset
	ROT T2,5			; And bit within word
	MOVE T2,BITS(T2)
	TDNE T2,INTWTB(T1)		; One yet?
INTBOX:	  JRST 1(T4)			; Yes, stop waiting
MNTM9	AOS CELL(INWBO,1,,INW)		; INTBOT waits longer
	JRST 0(T4)			; Keep waiting

	SUBTTL Wait Bit Multiple Bit Scheduler Tests

;INTOOT	Scheduler test for either of 2 bits becoming a one.
;T1/	Index1 in left half of right half, Index 2 in RH of RH
;T4/	Return address to continue waiting
;	JSP T4,INTOOT
;Ret+1:	Both bits are still off
;Ret+2:	One or both of the bits are now on

INTOOT::
MNTM9	AOS CELL(INWOO,0,,INW)		; INTOOT calls
	SETZB T2,T3
	LSHC T1,-11			; Index1 to T1, Index2 to T2 (lj)
	JUMPE T2,INTOOX			; Beware bit 0
	ROTC T2,4			; Word offset to T3
	ROT T2,5			; Bit within word to T2
	MOVE T2,BITS(T2)		; Get the bit
	TDNE T2,INTWTB(T3)		; Is bit2 on?
	  JRST 1(T4)			; Yes, stop waiting
	JUMPE T1,INTOOX			; Beware bit 0
	SETZ T2,
	LSHC T1,-5			; Word offset to T1
	ROT T2,5			; Bit within word to T2
	MOVE T2,BITS(T2)		; Get the bit
	TDNE T2,INTWTB(T1)		; Is bit1 on?
INTOOX:	  JRST 1(T4)			; Yes, stop waiting
MNTM9	AOS CELL(INWOO,1,,INW)		; INTOOT waits longer
	JRST 0(T4)			; Keep waiting


;INTZOT	Scheduler test for either bit becoming a 0 or the other becoming a 1.
;T1/	Index1 in left half of right half, Index 2 in RH of RH
;T4/	Return address to continue waiting
;	JSP T4,INTZOT
;Ret+1:	Index1 still on and Index2 still off
;Ret+2:	Either Index1 has gone off or Index2 has come on, or both

INTZOT::
MNTM9	AOS CELL(INWZO,0,,INW)		; INTZOT calls
	SETZB T2,T3
	LSHC T1,-11			; Index1 to T1, Index2 to T2 (lj)
	JUMPE T2,INTZOX			; Beware bit 0
	ROTC T2,4			; Word offset
	ROT T2,5			; Bit within word
	MOVE T2,BITS(T2)
	TDNE T2,INTWTB(T3)		; Is bit2 on?
	  JRST 1(T4)			; Yes.  Stop waiting
	JUMPE T1,INTZOX			; Beware bit 0
	SETZ T2,
	LSHC T1,-5			; Word offset
	ROT T2,5			; Bit witihin word
	MOVE T2,BITS(T2)		; Get the bit
	TDNN T2,INTWTB(T1)		; Is bit1 off?
INTZOX:	  JRST 1(T4)			; Yes.  Stop waiting
MNTM9	AOS CELL(INWZO,1,,INW)		; INTZOT waits longer
	JRST 0(T4)			; Keep waiting.

	SWAPCD	;ps

	SUBTTL	Internet Process Switching (INTFRK)

COMMENT	!

These  routines control the running of the various Internet processes
and higher level protocols, such as ICMP, Internet User Queues, TCP, etc.

!




; Unexpected interrupt

INTUXI:	BUG.(CHK,INTMA2,IPIPIP,SOFT,<Internet fork: unexpected interrupt>,,<

Cause:	The main Internet fork has encountered an unexpected interrupt.

Action:	Try to determine the cause of the interrupt.

Data:

>)
	SE1ENT				; Enter section 1
	MCENTR
	JRST INTBP1

	SUBTTL Main Internet Control Loop

	RESCD	;ps Better response

					; Global top-level AC usage

;DEFACY(NRT,BFR);ps			; 11 Negative runtime at start of loop
NRT==BFR

INTBP1::				; Start of main Internet loop

MNTM5<	CALL MNTFRT			; Fork's run time to T1
	MOVN NRT,T1			; Run time at start
>

MNTM5	AOS CELL(INPIP,0,,INP)		; Runs of Internet fork, INTBP1
	SETZ T1,
	EXCH T1,INTFLG			; Clear forced run flag.
MNTM5	SKIPN T1			; Run due to INTFLG?
MNTM5	 AOSA CELL(INPIP,1,,INP)	; Runs with INTFLG zero
MNTM5<	  ADDM T1,CELL(INPIP,2,,INP)>	; Sum of INTFLG

	MOVE T1,TODCLK			; Check if time to discard
	CAML T1,IPRAT			; Timedout IP fragments
	  CALL RCVFLS			; Yes

	SKIPE IPIQ			; Packets waiting for dispatch?
					; NB: INTDSP,ff have use own AC def'ns
	  CALL INTDSP			; Yes.  Hand them out to TCP, etc.

	SKIPE NTFRO			; Any empty output buffers around?
	  CALL INTNRB			; Yes.  Go release them.

					; Top-level AC usage
;DEFACY(PIX,Q1);ps			;  5 Index into protocol tables
PIX==Q1
;DEFACY(PTB,Q2)			;  6 Pointer to a protocol table
PTB==Q2
;DEFACY(PTL,Q3)			;  7 Length of a protocol table
PTL==Q3
;DEFACY(NXRTM,TPKT)		; 12 Next run time for Internet
NXRTM==TPKT
;Call main processing routine for each protocol whose run flag is set
;or whose next run time has passed, then call its next run time routine.

	HRLOI NXRTM,377777		; Next run time unless needed sooner

	MOVEI PTB,INTPIX+1		; Address of first protocol table
	MOVE PIX,-1(PTB)		; AOBJN counter
	HRRZ PTL,PIX			; Length of a protcol table
	DO.
	  SKIPLE T2,.INTPP(PTB)		; Processing routine
	   SKIPL .INTPO(PTB)		; Check if its ON
	  IFSKP.
	    MOVE T1,.INTPT(PTB)		; Next run time
	    CAMLE T1,TODCLK		; Call if time to run or
	     SKIPE .INTPF(PTB)		; Run flag set
	      CALL (T2)			; Call protocol processor
	  ENDIF.

	  SKIPLE T2,.INTPC(PTB)		; Time check routine
	   SKIPL .INTPO(PTB)		; Check if its ON
	  IFSKP.
	    MOVE T1,NXRTM		; Soonest so far
	    CALL (T2)			; Call protocol time checker
	    MOVEM T1,NXRTM		; Maybe sooner
	  ENDIF.

	  ADD PTB,PTL			; Point at next protocol table
	  AOBJN PIX,TOP.		; Back to process it
	ENDDO.

IFN IPMONF,<				;CS147
;Check on monitoring

	SKIPGE T1,CELL(INMUQ,0,,INM)	; Have a Monitoring User Queue handle?
	  CALL INTMNI			; No, get one

	DO.
	  MOVE T2,TODCLK		; Now
	  CAMGE T2,CELL(INMTM,0,,INM)	; Next report due or
	   CAML T2,CELL(INMRT,1,,INM)	; Due for retry of last report?
	  IFSKP.			; Neither, maybe received a probe
	    SKIPE INQSP(T1)		; Received a request? (Fast RCVIN%) and
	     SKIPGE T1,CELL(INMUQ,0,,INM) ; Have a queue handle and
	      EXIT.			; No, forget it
	    CAMGE T2,CELL(INMTM,1,,INM)	; Time to accept a probe?
	      EXIT.			; No, forget it
	  ENDIF.
	  CALL INTMON			; Perform Monitoring Functions
	ENDDO.
   >;IPMONF				;CS147

;Dump packet printer buffer if it's getting full

	MOVE T1,MNTPTB
	ADD T1,MNTPTE			; Size of packet printer buffer
	ASH T1,-1
	MOVX T2,1B0
	CAMG T1,MNTPTC			; Over half full?
	 SKIPN MNTRAC			; & tracing?
	  TRNA				; No, skip it
	   IORM T2,MNTFLG+1		; Dump what's there

;Histogram reschedule interval

	MOVE T1,NXRTM
	MOVE T2,T1			; Scheduled time
	SUB T2,TODCLK			; Time from now

MNTM5	INHIST(INPHS,INP,T2,T4,T3)	; INTBP1 reschedule histogram

	MOVE T2,TODCLK
	ADD T2,INFT0+0			; Minimum time
	CAMGE T1,T2			; Take larger
	  MOVE T1,T2
	MOVEM T1,INTTIM			; Set wakup

MNTM5<	SKIPE T1,INTFLG>		; Flag already set?
MNTM5	  AOS CELL(INPIP,3,,INP)	; Times INTFLG set after run
MNTM5<	ADDM T1,CELL(INPIP,4,,INP)>	; Sum of INTFLG after run

MNTM5<	CALL MNTFRT			; Fork's run time to T1
	ADD T1,NRT			; Run time used
	INHIST (INPHR,INP,T1,T4,T3)	; Internet fork run time hist (CELL(
>

	MOVE T1,INPSW
	TXNN T1,IPS%LP
	IFSKP.
	JSP T4,INTBPT			; Run the test at process level
	 CAIA				; To save overhead of scheduler
	  JRST INTBP1			; Back to INTBP1
	ENDIF.

	MOVEI T1,INTBPT			; Select the activation test
	HDISMS 1000			; Keep us around for a while
	JRST INTBP1

;DEFACY(TPKT,NXRTM)	;ps		; Terminate special AC definitions

;DEFACY(BFR,NRT)
PURGE NXRTM,NRT

	SWAPCD	;ps End better response
	RESCD	;ps Scheduler test routine

;INTBPT	Scheduler activation test for Internet fork.
;	JSP T4,INTBPT
;Ret+1:	Internet fork not ready to run
;Ret+2:	Internet fork runnable

INTBPT:
MNTM9	AOS CELL(INPIT,0,,INP)		; INTBPT calls
	SKIPE INTFLG			; Forced run?
	 JRST 1(T4)			; Yes.
	MOVE T1,TODCLK			; Current millisecond number
	CAML T1,INTTIM			; After desired wakeup time?
MNTM9	 AOSA CELL(INPIT,2,,INP)	; INTBPT time wakeups
MNTM9	  AOSA CELL(INPIT,1,,INP)	; INTBPT failures
	 JRST 1(T4)			; Yes.
	JRST 0(T4)

	SWAPCD	;ps End of scheduler test routine

					; Local top-level AC usage

;      NRT,BFR				; 11 Used by top level
;DEFACY(NPKTS,TPKT);ps		; 12 Packets processed by INTDSP
NPKTS==TPKT
;  ==PKT				; 13 Pointer to a packet



;INTDSP	Get datagrams from the IP Input Queue, IPIQ, throught the gateway
;(RCVGAT), and queue them for the higher level protocols (e.g. TCP).

;	CALL INTDSP
;Ret+1:	Always.  IP Input Queue empty.


INTDSP:
MNTM5	AOS CELL(INUDS,0,,INU)		; INTDSP calls
MNTM5	SETZM NPKTS			; No packets this run

INTDS0:	SKIPE PKT,IPIQ			; More input? (Save overhead of RCVGAT)
	  CALL RCVGAT			; Yes, Get a message from the gateway
	JUMPE PKT,INTDSX		; None available.  We're done for now.
MNTM5	AOS NPKTS			; Another packet this run

;The Logical Protocol is a function of a possible Logical Host Field.
;If Logical Host Field is less than or equal to contents of INTLHX,
;then the Logical Protocol is the Physical Protocol from the IP header,
;otherwise the Logical Protocol is (Logical Host)*256+(Physical Protocol).
;(Note that the datagram may have been received on a different interface
;than the destination (local) address would imply).

	LOAD T2,PIPRO,(PKT)		; Internet protocol (physical)
	LOAD T3,PIDH,(PKT)		; Local address used by sender. 
	NETNUM T1,T3			; Find its VNCT 
	CALL NETNCT ;(T1:VNCT)		; Find desired local interface
	 TDZA T3,T3			; None ???
	  AND T3,NTNLHM(VNCT)		; Logical host mask for that net
	SKIPE T1,T3			; Logical host 0 uses system protocols
	  CALL LHCEK ;(T1,T2:T1,T2)	; Check non-zero logical host values
	STOR T2,PESEQ,(PKT)		; Logical host, Protocol (for INQDSP)

;Scan Protocol Table for match

	XMOVEI PTB,INTPIX+1		; Locate tables
	MOVE PIX,-1(PTB)		; # Protocols
	HRRZ PTL,PIX			; Individual Protocol Table length
	DO.
	  SKIPL .INTPO(PTB)		; Protocol on?
	  IFSKP.			; Yes
	    SKIPL T3,.INTPL(PTB)	; Take any protocol, or
	     CAMN T2,T3			; Exact match?
	      EXIT.			; Yes, stop searching protocols
	  ENDIF.
	  ADD PTB,PTL			; Not for this protocol module
	  AOBJN PIX,TOP.		; Try next
	ENDDO.

	IFGE. PIX			; No next higher level protocol

;(Shouldn't get here because Internet User Queues should take anything)

MNTM5	  AOS CELL(INUDS,4,,INU)	; INTDSP protocol unreachable
	  MOVX T1,PT%KIP		; Invalid protocol
	  TDNE T1,MNTRAC		; Want trace?
	    CALL PRNPKI ;(T1,PKT)	; Yes
	  MOVX T1,<DU%PRO,,ICM%DU>	; Protocol unreachable
	  CALL ICMERR			; (releases storage)
	  JRST INTDS0			; and process next
	ENDIF.
					; Found protocol
MNTM5	AOS CELL(INUDS,3,,INU)		; INTDSP packets to a protocol
	XMOVEI T1,PKTQ(PKT)		; What to enqueue
	MOVE T2,.INTPQ(PTB)		; Where to enqueue it
MNTM2<	SKIPL T3,.INTPM(PTB)>		; -N,,Protocol statistics block
MNTM2	  JRST INTDS6			; None, skip it

; The following reference:  ICMAB, INQAB, TCPAB, etc.

MNTM2<	AOS T4,XCELL(.INTPM,0,(T3))>	; Another input packet
MNTM2<	CAMGE T4,XCELL(.INTPM,2,(T3))>	; New max?
MNTM2	  JRST INTDS6			; No
MNTM2<	MOVEM T4,XCELL(.INTPM,2,(T3))>	; Yes, remember length
MNTM2<	MOVE T4,TODCLK>			; And when
MNTM2<	MOVEM T4,XCELL(.INTPM,3,(T3))>

INTDS6:	NOSKED				; Maybe protocol run by different fork
	CALL NQ
	OKSKED
	AOS .INTPF(PTB)			; Say a pkt waiting
	MOVX T1,PT%IQP			; Packet given to protocol
	TDNE T1,MNTRAC			; Want trace?
	  CALL PRNPKI ;(T1,PKT)		; Yes
	JRST INTDS0			; Process another message

INTDSX:					; All packets processed
MNTM5<	SKIPE T1,NPKTS>			; Packets this run
MNTM5	  AOS CELL(INUDS,1,,INU)	; INTDSP runs with packets

MNTM5<	ADDM T1,CELL(INGIQ,4,,ING)>	; Sum of packets from gateway
MNTM5<	ADDM T1,CELL(INUDS,2,,INU)>	; Packets received by INTDSP

	RET

;DEFACY(Q1,PIX)
;DEFACY(Q2,PTB)
;DEFACY(Q3,PTL)
PURGE PIX,PTB,PTL

;DEFACY(TPKT,NPKTS)	;ps		; Terminate special AC definition
PURGE NPKTS

	SUBTTL	Host Monitoring Processes

IFN IPMONF,<				;CS147
;INTMNI
;ASNIQ% for Monitoring Protocol

;	CALL INTMNI
;Ret+1:	  Failed
;Ret+2:	Success, T1 has queue handle

INTMNB:	EXP 0				; No flags
INTMNC:	BYTE (8)0,0,0,0-0		; Protocol
	BYTE (32)0			; Foreign Host
	BYTE (32)0			; Local Host
INTMND:	BYTE (16)0-0,0			; Local Port, Wild Foreign Port
	BYTE (8)-1,-1,-1,-1		; Logical host and Protocol Mask
	BYTE (32)0			; Foreign Host Mask
	BYTE (32)0			; Local Host Mask
	BYTE (16)-1,0			; Local Port, Foreign Port Masks
INTMNE:

INTMNI:	STKVAR <<INTMNA,INTMNE-INTMNB>>

	MOVE T1,[XWD INTMIB,INTMIB+1]	; Initialize the monitoring buffer
	SETZM INTMIB
	BLT T1,INTMIB+PKTELI-1		; Zero the IP area
	MOVX T1,<PPROG+PKLIM+PKDUL>	; Program needs the packet
	MOVEM T1,INTMIB+PKTFLG		; (so it doesn't get RETPKT'd)

	HRLI T1,INTMNB			; Copy argument block to writable area
	HRRI T1,INTMNA			; Insert current protocol/port numbers
	BLT T1,INTMNE-1-INTMNB+INTMNA
	MOVE T1,CELL(INMPT,0,,INM)	; Protocol number
	DPB T1,[POINT 8,INTMNC-INTMNB+INTMNA,31]
	MOVE T1,CELL(INMPT,1,,INM)	; Local port number
	DPB T1,[POINT 16,INTMND-INTMNB+INTMNA,15]

	XMOVEI T1,INTMNA		; Argument block address
	CALL ASNIQ.			; Get an Internet User Queue
	IFGE. T1			; Have a queue
	  MOVEM T1,CELL(INMUQ,0,,INM)	; Save monitoring User Queue handle
	  AOS (P)			; No, return +2
	ENDIF.

	RET

	ENDSV.

	RESCD	; Does PIOFF/PION

;INTMON	Send Monitoring Report Datagram

;	CALL INTMON
;Ret+1:	Always, Scheduled time updated, if appropriate

INTMON::
	JN PINTL,<+INTMIB>,R		; Interrupt level still has it
	AOSLE INTMLK			; Monitoring buffer free
	  JRST INTMOY			; No, try later
	MOVE T1,MNTSW			; Get switches
	TXNE T1,MNS%MP			; Reporting via queue and
	 SKIPGE CELL(INMUQ,0,,INM)	; Have a queue handle? or
	  TXNE T1,MNS%MT		; Reporting via TCP?
	   TRNA				; Yes
	    JRST INTMOY			; No, try later
	SAVEAC <PKT>			; Save register
	SETZ PKT,			; No probe packet to release

;If trap data has accumulated, send it in

	SKIPN T4,INTMFR			; Have any trap data?
	IFSKP.
	  MOVEI T3,<INTMBS-INTMIP>(T4)	; Length w/ header
	  PUSH P,T3			; Setup length

	  ADDI T4,1			; Include size word
	  LSH T4,4			; 32 bits sent
	  MOVEM T4,INTMDA+1		; Data block size

	  MOVE T1,CELL(INMAD,0,,INM)	; Monitor's address
	  SETZ T2,
	  CALL BSTADR			; Find best local address to use
	    JFCL
	  MOVE T1,T2			; Local address
	  MOVE T2,CELL(INMAD,0,,INM)	; Monitor's address
	  LSHC T1,4			; Left justify them
	  MOVE T3,CELL(INMID,0,,INM)	; Get next ID
	  ADDI T3,100001		; With trap info bit
	  MOVE T4,CELL(INMPT,1,,INM)	; Port
	  SUBI T4,1

	  CALL INTMOS			; Try to report traps

	  SETZM INTMFR			; No trace data in buffer
	  POP P,(P)			; Drop length
;cwl cannot reuse buffer this quickly
	ENDIF.


;Time stamp monitoring data and copy it into (free) working buffer

	PIOFF				; Protect from others and the network
	CALL LGTAD			; Sample Timestamp
	MOVE T2,TODCLK
	DMOVEM T1,AASDT			; Into data

; Copy NCT information into monitoring area

	SKIPE T4,NCTVT			; Locate first NCT
	  CALL NCTCPY
	SKIPE T4,LUPNCT			; Loopback NCT
	  CALL NCTCPY

	MOVE T1,[STAT0,,INTMBS]		; Take snapshot
	BLT T1,INTMBS+STATZZ-STAT0-1
					; Reset extrema
	MOVE T1,STSLIM			; AOBJN pointer
	MOVX T3,1B0			; Max becomes negative
	MOVX T4,1B1			; Min becomes positive
	DO.
	  MOVE T2,(T1)			; Get address & flag
	  TXZE T2,1B0			; Max or Min?
	  IFSKP.
	    IORM T3,(T2)		; Maxima becomes negative
	  ELSE.
	    IORM T4,(T2)		; Minima becomes positive
	  ENDIF.
	  AOBJN T1,TOP.			; Back for rest
	ENDDO.
	PION				; Data is safe now

;Left justify the data

	MOVE T3,[-INTMES+INTMBS,,INTMBS]; AOBJN pointer
	DO.
	  DMOVE T1,(T3)			; Get two words
	  LSHC T1,4			; Left justify them
	  DMOVEM T1,(T3)
	  AOBJP T3,ENDLP.
	  AOBJN T3,TOP.			; Back for next pair
	ENDDO.

	PUSH P,[<INTMBF-INTMIP>]	; # words, including symbols
	MOVX T3,<<STATZZ-STAT0+1>*20>	; Size of statistics block
	MOVEM T3,INTMDA+1		; Into header

;Find where to send monitoring data

	MOVE T3,TODCLK
	CAMGE T3,CELL(INMTM,0,,INM)	; Time for monitoring report?
	IFSKP.				; Yes

;Reporting to Monitor

	  MOVX T2,1B1			; Infinite retry time
	  IORM T2,CELL(INMRT,1,,INM)	; Assume no error

	  MOVE T1,CELL(INMAD,0,,INM)	; Monitor's address
	  SETZ T2,
	  CALL BSTADR			; Find best local address to use
	    JFCL
	  MOVE T1,T2			; Local address
	  MOVE T2,CELL(INMAD,0,,INM)	; Monitor's address
	  LSHC T1,4			; Left justify
	  MOVX T4,<INTMBE-INTMIP>	; # words, w/o symbols
	  AOS T3,CELL(INMID,0,,INM)	; Count monitor sample #
	  CAILE T3,1			; First time reporting?
	    MOVEM T4,(P)		; No, don't include symbols
	  MOVE T4,CELL(INMPT,1,,INM)	; Port
	  SUBI T4,1

	  CALL INTMOS			; Try to report
	  CAIN T1,MNTX00		; Ok?
	  IFSKP.			; No
	    MOVE T2,CELL(INMRT,0,,INM)	; Retry period
	    ADD T2,TODCLK		; Time of next attmept
tlo t2,200000 ;cwl not yet
	    MOVEM T2,CELL(INMRT,1,,INM)
	  ENDIF.

	  MOVE T2,CELL(INMPR,0,,INM)	; Scheduled report period
	  ADDM T2,CELL(INMTM,0,,INM)	; Next scheduled reporting time

	ELSE.

	  SKIPL T1,CELL(INMUQ,0,,INM)	; Need Queue handle for probes
	   SKIPG T2,INQSP(T1)		; Have a probe packet?
	  ANSKP.			; Have queue and a packet
	    MOVE T3,TODCLK
	    CAMGE T3,CELL(INMTM,1,,INM) ; Time to accept a probe?
	    ANSKP.			; Yes, reply to probe

;Received a probe packet

	      MOVX T3,<1,,0>		; External probe count
	      ADDM T3,CELL(INMID,0,,INM) ; Count probes for statistics

	      TXO T1,RIQ%NW		; Don't wait (it will hang forever!)
	      MOVX T2,30		; Size
	      CALL RCVIN.		; Get probe packet
					; T2/ Words received
	      SUBI T2,2			; Word count & word for ports
	      ANDGE. T1			; Error, give up
	      ANDG. T2			; Didn't get anything
	        LOAD T4,PIDO,(PKT)	; Internet offset
	        CAIGE T2,(T4)		; Probe packet must contain ports
	        ANSKP.			; Packet long enough for them
	          ADD T4,PKT		; Point to ports
	          LOAD T4,PSP,+PKTELI(T4) ; Get source port
	          LOAD T3,PISID,(PKT)	; Prober's id

	          DMOVE T1,PKTELI+$IPSH(PKT) ; Source/Destination, LJ
IF2 <IFN <$IPSH+1-$IPDH>,<PRINTX ? IP Header changed!>>
	          EXCH T1,T2		; For reply

	          CALL INTMOS		; Try to send report 

	          MOVE T1,CELL(INMPR,1,,INM) ; Minimum probe interval
	          ADD T1,TODCLK		; Next allowable time
	          MOVEM T1,CELL(INMTM,1,,INM)
	ENDIF.

	POP P,(P)			; Drop length

	SKIPE PKT
	  CALL RETPKT			; Return packet if any

	MOVE T1,MNTSW			; Get switches
	TXNE T1,MNS%MT			; Reporting via TCP and
	 SKIPLE CELL(INMCN,0,,INM)	; Have a connection?
INTMOY:	  SOS INTMLK			; No, Unlock monitoring buffer
	RET				; Yes, Utility fork will unlock it
					; when connection closes

; Copy the NCT chain pointed to by T4 into the monitoring area

NCTCPY:	DO.
	  JUMPE T4,R			; If end of list, all done

	  SKIPL T2,NTPSTI(T4)		; Have statistics area?
	  IFSKP.			; Yes
	    MOVEI T2,CELL(MNMNC,0,(T2))	; Monitoring NCT image area
	    HRL T1,T4			; NCT is source
	    HRR T1,T2			; Start address for NCT image
					; Min (VNCTSZ,MMNMNC)
	    BLT T1,VNCTSZ-1(T2)		; Copy NCT info
	  ENDIF.

	  LOAD T4,NTLNK,(T4)		; Link to next NCT
	  LOOP.
	ENDDO.
; /* Never reached */

;INTMOS	Finish building header for monitoring packet & send it off,

;T1/	Left justified Source address
;T2/	Left justified Destination address
;T3/	Right justified Sequence #
;T4/	Right justified destination port
;-1(P)	Length, words
;	CALL INTMOS
;Ret+1:	Always, T1 has error code or 0

INTMOS:	DMOVEM T1,INTMIP+$IPSH		; Addresses into buffer
	STOR T3,IPSID,+INTMIP		; Id into buffer
	MOVE T3,CELL(INMPT,1,,INM)	; Local port #
	STOR T3,PSP,+INTMDA		; Is Source
	STOR T4,PDP,+INTMDA		; Destination from prober

	LSHC T1,-4			; Right justify
	MOVEM T1,CELL(INMCB,.TCPLH,,INM) ; Set TCP Local host address
	MOVEM T2,CELL(INMCB,.TCPFH,,INM) ; Foreign host address
	MOVEM T3,CELL(INMCB,.TCPLP,,INM) ; Local port
	MOVEM T4,CELL(INMCB,.TCPFP,,INM) ; Foreign port

	MOVE T4,-1(P)			; Get length, words
	ADDI T4,1			; Count count word, too
	MOVEM T4,INTMIP-1		; SNDIN header
	LSH T4,2			; Octets
	STOR T4,IPPL,+INTMIP		; Packet length
	SETONE IPTTL,+INTMIP		; Maximum time to live

;If have a probe packet, release it (now ok to clobbered T1-T4)

	SKIPLE PKT			; Get a packet?
	  CALL RETPKT			; Yes, return it
INTMOR:
	MOVX T1,MNTX00			; Assume all ok
	MOVE T2,MNTSW			; Network switches
	TXNN T2,MNS%MP			; Send info via single datagram?
	IFSKP.				; Yes

; Send monitoring report via own protocol (Entry to resend last sample)

	  XMOVEI PKT,INTMIB		; Point to base area of packet
	  SETZB T1,T2			; No special first-hop routing
	  CALL SNDGAT			; Send the packet to the gateway
	  CAIE T1,MNTX00		; All ok?
	    AOS CELL(INMER,0,,INM)	; Count monitor reporting errors
	ENDIF.

; Send monitoring report via TCP

	MOVE T2,MNTSW			; Network switches
	TXNN T2,MNS%MT			; Send info via TCP protocol?
	IFSKP.				; Yes
	  SETOM CELL(INMCN,0,,INM)	; Lock

	  MOVX T1,^D255			; Set maximum time to live
	  HRLM T1,CELL(INMCB,.TCPIP,,INM) ; Set TCP parameter for IP
	  MOVX T1,TCP%PU		; Push it all
	  MOVEM T1,CELL(INMBH,.TCPBF,,INM)

	  MOVEI T1,INTMIP		; Data address (send IP header too)
	  MOVEM T1,CELL(INMBH,.TCPBA,,INM) ; Set TCP data pointer
	  LOAD T4,IPPL,+INTMIP		; IP packet length, bytes
	  MOVEM T4,CELL(INMBH,.TCPBC,,INM) ; Set TCP byte count

	  MOVEI T1,CELL(INMCB,0,,INM)	; Open connection to monitoring host
	  TXO T1,TCP%FS			; Actively
	  MOVX T2,^D<5*60>		; Try for 5 minutes
TCPMO2:	  MOVE T3,[1001,,^D15]		; Slow 15-second retransmission
	  OPEN%				; Don't bother waiting
	  ERJMP TCPMOU
	  TXO T1,<TCP%JS>		; Is JCN
	  MOVEM T1,CELL(INMCN,0,,INM)	; Save connection ID

	  MOVEI T2,CELL(INMBH,0,,INM)	; Address of buffer header
	  MOVE T3,[0]			; Don't change timeout
	  MOVE T4,[0]			; Don't change rx parameters
	  SEND%				; Send w/o waiting
	  ERJMP TCPMOE

	  MOVE T1,CELL(INMCN,0,,INM)	; Connection ID
	  CLOSE%			; Close the connection w/o waiting
	  ERJMP TCPMOE
	  MOVX T1,MNTX00		; All ok
	  ANSKP.			; Never, Collect ERJMPs here
TCPMOE:
TCPMOU:
	    AOS CELL(INMER,0,,INM)	; Count monitor reporting errors
jfcl;	    SETZM CELL(INMCN,0,,INM)	; Connection gone on error??
	    MOVX T1,MNTX34		; Error
	ENDIF.
	SETZ PKT,			; Nothing to return
	RET

   >;IFN IPMONF way back...		;CS147

	SUBTTL	Internet Cleanup Support Routines

;Routines are called with CX containing a BLT word to restore registers
;before the cleanup routine is called.  All registers (except P) have
;been saved; the called routines do not need to save anything (except P).


INTKJB::			; Protocol dependent kill job
	MOVX T1,.INTKJ
	JRST INTALL

INTKFK::			; Protocol dependent kill fork
	MOVX T1,.INTKF
	JRST INTALL

INTCZF::			; Protocol dependent close fork-relative files
	MOVX T1,.INTCZ
	JRST INTALL

INTALL:	PUSH P,CX		; BLT register to restore registers
	MOVE Q1,INTPIX		; Get # of protocols, size of each
	HRRZI Q2,-1(Q1)		; Size for AOBJN
	PUSH P,Q2
	HRRI Q1,INTPIX+1(T1)	; Locate first table at desired offset

	DO.
	  PUSH P,Q1		; Save AOBJN pointer
	  PUSH P,(Q1)		; Indirect pointer to cleanup routine
	  MOVE CX,-3(P)		; For BLT
	  BLT CX,CX		; Restore registers
	  CALL @(P)		; Call cleanup routine
	  POP P,(P)		; Drop routine
	  POP P,Q1		; Get AOBJN pointer back
	  ADD Q1,(P)
	  AOBJN Q1,TOP.		; Process next protocol
	ENDDO.
	ADJSP P,-2		; Clean up stack
	RET

	SUBTTL	Linkages to Multinet

; Setup higher level protocol code, local network net number, and
; local network interface address.

;HTBJFN/JFN for reading
;TERM/	Terminator from previous field
;P1/	NCT address
;	CALL ADxxP
;	...
;	CALLRET ADLNPA	with
;T1/	Pointer to ASCIZ error message, or 0 if ok
;T2/	Protocol code (NP.xxx)
;T3/	Interface Address
;T4/	Network number

;Internet protocol address

ADIPP::	HRROI T1,[ASCIZ /Address multiply specified/]
	SKIPL NTLADR(P1)	; Address already given?
	  CALLRET ADLNPA	; Yes, error if so

	HRROI T1,[ASCIZ /Invalid argument seperator/]
	MOVE T2,TERM		; Get terminator
	CAIE T2,":"		; Valid?
	  CALLRET ADLNPA	; No, give proper error

	CALL RDIPAD		; Read a host number
	JUMPN T1,ADLNPA		; Error
				; T3 has address

;Add to NLHOST table, also remember that NLHOST contains only IP format
;addresses.

	SETZ T2,		; Init an index
	  SKIPLE NLHOST(T2)	; Anything in this slot?
	    AOJA T2,.-1		; No, try next
	
	SKIPE NLHOST+1(T2)	; Must have at least one -1
	 SKIPL NLHOST(T2)	; Empty?
	  JRST NETFUL		; No, table overflow.
	MOVEM T3,NLHOST(T2)	; Save number

	NETNUM T4,T3		; Retrieve the (IP) net
	MOVEI T2,NP.IP		; Protocol type is IP
	SETZ T1,		; Ok
	JRST ADLNPA		; Setup NCT

NETFUL:	BUG.(CHK,NORMIA,IPIPIP,SOFT,
<NLHOST table full, local address ignored>,<<T3,ADR>>)
	HRROI T1,[ASCIZ /No room in NLHOST tables for local address/]
	JRST ADLNPA

;RDIPAD	Read IP host address (from SITE-ADDRESS.TXT file)
;Ret+1:	T1/ Pointer to ASCIZ error message, or 0 if ok
;	T3/ Standard form network address

NOBRAK==1B0			; Ok to not have square brackets

RDIPAD:	SAVEAC <FR,5,6,7>
	MOVX FR,NOBRAK		; Don't require square brackets
	MOVE T1,HTBJFN		; Input designator
	MOVX T2,NP.IP		; This protocol suite
	MOVX 7,<BIN%>		; Reads a file

	CALL NUM.IP		; Use PRONUM routine
	 TRNA			; Error
	  TXNN FR,GH%ADR	; Parse an address?
	   SKIPA T1,[-1,,[ASCIZ /Invalid host address format/]] ; No, error
	    SETZ T1,		; No error

	DMOVE T3,5		; Possible host address
	RET



;IPNET	Extract the network number from an IP host address (PRONET function).

;T1/	Internet address (with protocol type code)
;Ret+1:	Always, T1/ net number (with NP.IP code)

IPNET::	TXNN T1,IA%NET			; Already a net number?
	IFSKP.				; No
	  TXZ T1,FLD(-1,NA%PRO)		; Flush protocol code
	  NETNUM T1,T1			; Extract net number
	  TXO T1,FLD(NP.IP,NA%PRO)	; Put protocol code back
	ENDIF.	
	RET

;IPHST	Print an IP host address and optional port (PROHST function)

;0/	GTHST% Flags: GH%ADR, GH%PRT
;1,7/	Output designator & instruction
;5,6/	Host address & Optional port
;	CALL @PROHST+NP.IP
;Ret+1:	  IO error
;Ret+2:	Ok

IPHST::	ACVAR <HADR,HPRT,INST,BP>	; Beware register usage
	TXNN FR,GH%ADR			; Want address?
	IFSKP.				; Yes
	  MOVX T2,"["			; Begin numeric form of address
	  MOVX BP,<POINT 8,HADR,3>	; Pointer to first byte
	  MOVX T4,<-4,,0>		; Four decimal fields
	  DO.
	    XCT INST			; Output separator
	    ERJMP R

	    ILDB T2,BP			; Get next byte
	    CALL MNOUTD ;internal NOUT%	; Output it in decimal
	      RET			; Error
	    MOVX T2,"."			; Bytes separated by periods
	    AOBJN T4,TOP.		; Back for other bytes
	  ENDDO.

	  MOVX T2,"]"
	  XCT INST			; End numeric form of address
	  ERJMP R

	  MOVX T2," "			; Separate address and port
	  TXNE FR,GH%PRT		; Want port too?
	   XCT INST			; Yes
	    ERJMP R
	ENDIF.

	TXNN FR,GH%PRT			; Want port?
	IFSKP.				; Yes
	  MOVE T2,HPRT			; Get port
	  ANDI T2,177777		; Ports are 16 bits
	  CALL MNOUTD ;internal NOUT%	; Output in decimal
	    RET				; Error
	ENDIF.

	RETSKP

	ENDAV.

;IAD.IP	Convert host address into an inverted domain label (PROIAD function)

;1/	Destination designator
;3,4/	-1 first time
;5,6/	Address
;	CALL @PROIAD+NP.IP
;Ret+1:	  Another label to be done
;Ret+2:	All done

IAD.IP::
	SKIPGE T4			; First call?
	  MOVX T4,4			; Yes, four labels per address
	MOVE T2,Q1			; Get host number
	ANDI T2,377			; Mask off eight bits
	LSH Q1,-10			; Shift input number
	MOVX T3,1			; Compute number of digits
	CAILE T2,^D9
	  MOVX T3,2
	CAILE T2,^D99
	  MOVX T3,3
	IDPB T3,T1			; Output label length
	MOVX T3,^D10			; Output decimal numbers
	NOUT%				; Output number
	  ERJMP .+1
	SOSG T4				; More to be returned?
	  AOS (P)			; No, skip return
	RET

;NUM.IP	Parse an address string and optional port (PRONUM Function)

;0/	GTHST% Flags:	If GH%PRT is set, a port should be parsed
;1/	Source designator
;2/	Protocol suite id (NP.xxx)
;7/	Instruction to execute to get next input character
;	Call @PRONUM(T2)
;Ret+1:	  Failed,	1/ Updated source designator
;Ret+2:	Succeeded,	0/ GH%ADR, GH%PRT set if parsed
;			1/ Updated source designator
;			5/ Standard format network addess (GH%ADR is set)
;			6/ Port if GH%PRT was/is set

HADR==5		; Standard form network address
HPRT==6		; Port
INST==7		; Byte input instruction
NP.==10		; Protocol Suite Id

NUM.IP::
	SAVEAC <NP.>			; Beware register usage
	MOVE NP.,T2			; Save protocol suite code
	SETZB HADR,HPRT			; Assume no address

	CALL OVRWIT			; Skip over white space

	XCT INST			; Get character
	ERJMP R
	CAIN T2,"["			; Start of address?
	IFSKP.				; Maybe not
	  CALL BKRET
	  TXNE FR,NOBRAK		; Bracket required?
	  ANSKP.			; Yes, not an address
	    TXZ FR,GH%ADR		; No address present

	ELSE.				; Found a bracket, or not needed

	  MOVX T4,4			; Get four decimal fields
	  DO.				; Get each field
	    CALL GETDNM ;internal NIN	; Get a decimal number
	      EXIT.			; End of last field
	    ADD HADR,T3
	    LSH HADR,10			; Make room for next byte
	    SOJG T4,TOP.		; Back for next field
	    RET				; Too many fields
	  ENDDO.
	  ADD HADR,T3			; Last field

	  JUMPL HADR,R			; No digits is error
	  CAIE T4,3			; Bad number of fields
	   CAIN T4,2			; Also bad
	    RET				; Bad input

	  STOR NP.,NA%PRO,+HADR		; Protocol suite

	  XCT INST			; Get trailing ]
	  ERJMP R
	  CAIN T2,"]"			; Properly terminated?
	  IFSKP.
	    TXNN FR,NOBRAK		; No bracket ok?
	      RET			; No, fail
	    CALL BKRET			; Don't read too far
	  ENDIF.
	  TXO FR,GH%ADR			; Found an address
	ENDIF.

	SETZB HPRT,T3			; Assume no port

	TXNN FR,GH%PRT			; To parse a port?
	IFSKP.				; Yes
	  CALL OVRWIT			; Skip over white space

	  CALL GETDNM ;internal NIN%	; Get port
	  ANSKP.			; Ended with ".", get second field
	    LSH T3,10
	    MOVE HPRT,T3		; High byte
	    CALL GETDNM ;internal NIN%	; Get second byte
	    ANSKP.
	      RET			; Another ".", bad format
	ENDIF.

	ADD HPRT,T3			; Port or zero
	TXZE HPRT,1B0			; Get anything?
	  TXZ FR,GH%PRT			; No

	RETSKP

;All ...
;T1/	Source designator
;INST/	Instruction to get next charactrer
;PopRet:IO error

;OVRWIT	Skip over tabs and spaces

OVRWIT:	DO.				; Skip over white space
	  XCT INST			; Get a character
	  ERJMP RET2
	  CAIE T2," "			; White space?
	   CAIN T2,11
	    LOOP.			; Yes, look beyond
	ENDDO.

;BKRET	Backup source designator

BKRET:	BKJFN%				; Point at last char
	ERJMP RET2
	RET

;RET2	Pop and return on IO error

RET2:	POP P,(P)			; No return
	RET				; Error return


;GETDNM	Parse a decimal number
;Ret+1:	T3/ .ge. 0	Number parsed
;	    .lt. 0	No number present
;Ret+2:	Terminated by a dot

GETDNM:	MOVX T3,<1B0>			; Begin parse, nothing
	DO.				; Get digits in field
	  XCT INST			; Get digit
	  ERJMP RET2

	  CAIN T2,"."			; End of field?
	    EXIT.			; Yes

	  CAIL T2,"0"			; Digit?
	   CAILE T2,"9"
	    CALLRET BKRET		; No, backup and return error

	  TXZ T3,1B0			; Have a digit
	  IMULI T3,^D10			; Decimal bytes
	  ADDI T3,-"0"(T2)
	  LOOP.
	ENDDO.
	RETSKP				; Return ok, T3/ value

PURGE HADR,HPRT,INST,NP.
	SUBTTL	Internet Gateway

COMMENT	!

These routines link the Internet Protocol with Multinet (as NP.IP).

IP's input done routine, IPEIN, queues datagrams into the (FIFO)
IPIQ.  The main IP processing loop, INTBP1 (running in INTFRK),
calls the IP input dispatcher, INTDSP, to dispatch the datagrams
from IPIQ.  INTDSP, in turn, calls RCVGAT to get the next datagram
for delivery to the local host.  The datagram is examined to make
sure that it wasn't truncated (if it was, send ICMP Parameter Problem
pointing to (low) packet length field), that it is the correct
protocol version (if it isn't, send ICMP Parameter Problem pointing
to IP version field), and that the checksum is correct (if it isn't,
send ICMP Parameter Problem pointing to the checksum field).

The IP options are then processed (phase 1), with an error generating
an ICMP Parameter Problem pointing to the option in error.  The
datagram's destination address, which may have been changed by an IP
source routing option, is then examined.  If it is zero or the IP
broadcast address, it is mapped to an appropriate local host address.

If the resulting destination is not one of the local host's addresses,
or the datagram is being source routed, it is to be forewarded.  (If
the IPS%SC flag is set, or forewarding is being restricted (MNS%RF set)
and the <source NTHSH,destination NTHSH> pair is not in the forewarding
database (MNTFWT), forewarding is not allowed and an ICMP Destination
unreachable/source routing error message is returned to the source.)
If forewarding is permitted, the datagram is passed to the SNDGAT(2)
routine.

Otherwise, the packet is destined for the local host.  If there is
a Record route option with space available, the local host's address
is inserted into it (there cannot be another entry in a source routeing
option).  If the datagram is a fragment, the RCVFR routine is called
to process it.  If the datagram is the last fragment needed to complete
reassembly, RCVFR returns with the reassembled datagram, otherwise it
queues the fragment for subsequent reassembly.  If a complete datagram
is available, RCVGAT returns it to INTDSP so it can be dispatched to
the next higher level protocol.  If none is available, the process is
repeated for the next datagram in the IPIQ (if te queue is empty, RCVGAT
returns without any datagram).



Higher level protocols send datagrams by calling SNDGAT.  A first
hop destination is selected, any IP options are processed, the IP
header is completed, the datagram is fragmented if it is too big
for the selected interface, and the resulting packets are placed
into the appropriate output queue.  Packets destined for the local
host are "sent" via a special "loopback" device.

!



;The gateway routines share a block of variables allocated from the
;process stack and pointer to by IPGBLK.  The names and usage are:

;Common to all

;ERRC==0	; Error code to be returned, if any

;Common to SNDGAT/RCVGAT/IPOPT

;FHRUT==1	; First-hop destination (route)
;CTYPE==2	; 0 if receiving, -1 if sending
;SRP==3		; Pointer before our sending interface's address, or 0
;SRC==4		; Route option code (LSROPT or SSROPT) [temp:see RRTC]
;RRTP==5	; Pointer before our sending interface's address, or 0

;Local to IPOPT

;RRTC=6		; Current byte number for RRTOPT parameter problem message
;CURBYT==7	; Current byte number for parameter problem message
;OPTP==10	; Working pointer to next option byte
;GARB==11;,2	; Dummy pointer/count pair

;Local to RCVFR

;LASTFO==1
;KILLTM==2

;Local to SNDFR

;FHRUT==1
;OPK==2
;DPT==3
;FFR==4
;FRO==5
;OIN==6
;OOT==7
;SFR==10
;TPK==11
;DCT==12
;SIZ==13
;LFR==14
;OFC==15

IPGBLN==16	; Size of block

	SUBTTL	Internet Gateway - Input Completed - Interrupt Level

	RESCD	;ps Interrupt Level Routine

;IPEIN	Handle input completion on an IP packet.

;T1/	Extended pointer to top of packet buffer, PTPDT/PTPBZ set

IPEIN::
	SKIPGE INTON			; IP turned ON?
	IFSKP.				; No, discard the packet
MNTM5	  AOS CELL(INGIQ,1,,ING)	; IPEIN packets dropped (INTON off)
	  CALL BUFCHK ;(T1)		; General buffer?
	   TRNA				; No
	    CALLRET RETBUF ;(T1)	; Yes, ok at interrupt level
	  MOVE CX,T1			; Cannot release IP buffers at
	  PIOFF				; Interrupt level
	  EXCH CX,NTFRO+1		; Put at end of completed FIFO queue
	  SKIPN CX			; Anything there?
	    XMOVEI CX,NTFRO+0-$NBQUE	; No, this becomes only queue entry
	  STOR T1,NBQUE,(CX)		; Link old last to new last entry
	  PION
	  RET				; All done
	ENDIF.
					; IP is turned ON
	MOVE T2,T1			; Copy packet address for queueing
	PIOFF				; Protect the queues
	EXCH T1,IPIQ+1			; Packet at end of IP input FIFO queue
	SKIPN T1			; Was queue empty?
	  XMOVEI T1,IPIQ+0-$NBQUE	; Yes, this becomes only queue entry
	STOR T2,NBQUE,(T1)		; Link last end to new end

	AOS T1,CELL(INGIQ,0,,ING)	; One more in IP input queue, IPEIN
	CAMG T1,CELL(INGIQ,2,,ING)	; New max?
	IFSKP.
	  MOVEM T1,CELL(INGIQ,2,,ING)	; Yes
	  MOVE T1,TODCLK		; When
	  MOVEM T1,CELL(INGIQ,3,,ING)
	ENDIF.
	PION

	AOS INTFLG			; Wakeup the IP
	RET

	SWAPCD	;ps End interrupt level routine


	RESCD	;ps Fast access

;INTCKS	Compute Value for IP Checksum Field

;PKT/	Extended Pointer Packet
;	CALL INTCKS
;Ret+1:	Always.
;T1 has the checksum for the IP header

INTCKS::
MNTM5	AOS CELL(TCCAA,2,,TCC)	; INTCKS calls
	XMOVEI T3,PKTELI(PKT)	; Address of first byte
	LOAD T4,IPDO,(T3)	; # words
	LSH T4,2		; # bytes
	SETZ T2,		; No partial sum
	CALLRET GENCKS		; Compute checksum

	SWAPCD	;ps End of fast access

	SUBTTL	Internet Gateway - Packets from Network - Process Level

	RESCD	;ps PIOFF/PION

	%IPCKS (<;>)			; Get $IPCKS defined

;RCVGAT	Receive a packet from all networks.

;	CALL RCVGAT
;Ret+1:	Always.  PKT has pointer to packet or 0 if none available.

RCVGAT:	SAVEAC <VNCT>
MNTM5	AOS CELL(INGAA,11,,ING)		; RCVGAT calls
	TRVAR <<IPGBLK,IPGBLN>>		; Transient variables

ERRC==0		; Error code to be returned, if any
FHRUT==1	; First-hop destination (route)
CTYPE==2	; Call type == 0
SRP==3		; IDPB pointer for sending interface's address, or 0
SRC==4		; Route option code (LSROPT or SSROPT) [temp:see RRTC]
RRTP==5		; IDPB pointer for sending interface's address, or 0

RCVGAL:					; Top of loop
	MOVX T1,MNTX00			; No errors yet
	MOVEM T1,ERRC+IPGBLK
	SETZM FHRUT+IPGBLK		; No special first-nop address

	PIOFF
	MOVE PKT,IPIQ+0			; Get input queue output pointer
	JUMPE PKT,RCVGAY		; No packets queued (PKT is 0)
	LOAD T1,NBQUE,(PKT)		; Get successor, if any.
	SKIPN T1			; Zero if no sucessor
	  SETZM IPIQ+1			; Make empty queue
	MOVEM T1,IPIQ+0			; Set new output pointer
MNTM0	SOS CELL(INGIQ,0,,ING)		; IP input queue has one less, RCVGAT
	PION
;	JRST RCVGA0
;
;	SWAPCD	;ps End PIOFF/PION
;	RESCD	;ps Lets not waste time swapping this in
;
;RCVGA0:
	SETZRO NBQUE,(PKT)
	SETZRO QNEXT,+PKTQ(PKT)		; Packet not in a queue
	SETZRO QPREV,+PKTQ(PKT)

cwlfls:	JFCL [	LOAD T2,PIPRO,(PKT)	; Get protocol
		CAIE T2,12		; Flush SMS
		IFSKP.
		  CALL INTULK		; Unlock packet
		  CALL RETPKT
		  JRST RCVGAL
		ENDIF.

		CAIE T2,6		; TCP
		IFSKP.
		  LOAD T3,PIDO,(PKT)
		  ADD T3,PKT
		  LOAD T3,PDP,+PKTELI(T3)
		  CAIE T3,25		; Flush TCP FTP
		   CAIN T3,31		; Flush TCP SMTP
		  IFSKP.
		    CAIE T3,27;12345	; Flush TCP TELNET
		     CAIN T3,12345
		    ANSKP.
		  ELSE.
		    CALL INTULK		; Unlock packet
		    CALL RETPKT
		    JRST RCVGAL
		  ENDIF.
		ENDIF.
		JRST .+1]

	MOVX T1,PT%RGW			; Packet received from local net
	TDNE T1,MNTRAC			; Want trace?
	  CALL PRNPKI ;(T1,PKT)		; Yes

	CALL INTULK ;(PKT)		; Unlock packet


; Check to see that all of the packet has been received.
					; Format problem, ptr to PIPL
	MOVEI T4,[EXP PT%KIP,<0,,ICM%PP>,3,NE%DRP+MNTX34]
	LOAD T2,PTPBZ,(PKT)		; Length, octets, at transport level
	LOAD T3,PIPL,(PKT)		; Internet total length in bytes
	CAMGE T2,T3			; Got it all?
	  JRST RCVGA9			; No.  Flush it.


; Check to see if it is ok to look at the Internet leader.
					; Format problem, ptr to PIVER
	MOVEI T4,[EXP PT%KIP,<0,,ICM%PP>,0,NE%DRP+MNTX03]
	LOAD T3,PIVER,(PKT)		; Internet Version
	CAIE T3,.INTVR			; Right Internet Version?
	  JRST RCVGA9			; No.  Flush it.


; Check to see that IP checksum is correct.

	CALL INTCKS			; Compute the checksum
	IFN. T1				; Checksum is bad
MNTM5	  AOS CELL(INGIQ,1,,ING)	; IP packets w/ bad checksum
	  MOVEI T4,[EXP PT%KCS,<0,,ICM%PP>,<<4*$IPCKS>+2>,NE%DRP+MNTX03]
	  JRST RCVGA9			; Parameter problem at checksum
	ENDIF.


; Set info for next level

	PNTLDR T1,PTPDT,(PKT)		; Address of transport level leader
	LOAD T2,PIDO,(PKT)		; IP leader length, words
	ADD T1,T2
	STOR T1,PSSDT,(PKT)		; Address of session level leader
	LOAD T1,PIPL,(PKT)		; Transport level length
	LSH T2,2			; Bytes in transport level leader
	SUB T1,T2
	STOR T1,PSSBZ,(PKT)		; Session level length

; Process IP options

	SETZM CTYPE+IPGBLK		; Receiving
	CALL IPOPT			; Process options
	  JRST RCVGAO			; Option error

; Find where to send packet (may have been changed by routing option)

	LOAD T1,PIDH,(PKT)		; Get 32-bit internet destination
	IFE. T1				; 0 address is this host
	  MOVEI T1,NLHOST		; List of our addresses
	  LOAD T1,PISH,(PKT)		; Maybe help make decision
	  SETZ T2,
	  CALL BSTADR			; Find a good one
	    MOVE T2,NLHOST+0		; ??
	  MOVE T1,T2
	  STOR T1,PIDH,(PKT)		; Set it
	ENDIF.

; Check if packet is to this host, if so deliver, else forward it

	SKIPN SRP+IPGBLK		; Must forward if it has a route option
	 CALL LCLHST			; Is it one of us?
	  CAIA				; No, packet to be forwarded
	   JRST RCVGA7			; Yes, deliver a packet to host


; The packet is not to be processed on this host.  Forward it (to T1/)

RCVGA6:
MNTM5	AOS CELL(INGGY,1,,ING)		; Packets to be forwarded, RCVGAT

	IFQN. IPS%SC,+INPSW		; If site is secure don't allow it
	  MOVEI T4,[EXP PT%KIA,<DU%SRF,,ICM%DU>,-1,NE%DRP+MNTX25]
MNTM5	  AOS CELL(INGGY,2,,ING)	; Un-Forwarded packets, RCVGAT
	  CALL INGWER			; Drop & send Destination Unreachable
	ELSE.
	  MOVX CX,MNTX00		; No error
	  MOVEM CX,ERRC+IPGBLK
	  CALL SNDGA2			; Send packet to address in T1
jfcl;	  MOVEM T1,ERRC+IPGBLK		; Ignore errors here, cannot do much
	ENDIF.
	JRST RCVGAL			; Go process next packet

; Packet is for (one of) this host's address(es).

RCVGA7:	SKIPN T4,RRTP+IPGBLK		; Check if Record route
	  JRST RCVGA8			; No, skip following

; Have to insert host address for routing option

	LOAD T3,PIDH,(PKT)		; Us
	CALL INSHST			; Insert host name

; Should not be any remaining source routing if pkt to be delivered
;	SKIPE T4,SRP+IPGBLK	; If Source route
;	  CALL INSHST		; Insert host name

RCVGA8:					; See if packet is a fragment
	JE <PIMF,PIFO>,(PKT),RCVGAX	; Not a fragment, give to dispatcher
	CALL RCVFR			; Process fragment (and queue)
	JUMPN PKT,RCVGAX		; Packet was reassembled, to dispatcher
	JRST RCVGAL			; Fragment was queued, get next packet

RCVGAO:	MOVEI T4,[EXP PT%KIP]		; Invalid format
	CALL INGWEO			; Error
	JRST RCVGAL			; Process next packet

;T4/	Points to error vector

RCVGA9:	CALL INGWEP			; Process error
	JRST RCVGAL			; Process next packet

;	SWAPCD	;ps End lets not waste time swapping this in
;	RESCD	;ps PIOFF/PION

RCVGAY:	PION
RCVGAX:	MOVE T1,ERRC+IPGBLK		; Error code
MNTM5	SKIPE PKT			; Returning something?
MNTM5	  AOS CELL(INGGY,0,,ING)	; Packets received, RCVGAT
	RET

	PURGE FHRUT,CTYPE,SRP,SRC,RRTP

	SWAPCD	;ps End PIOFF/PION

;Routines to process errors in RCVGAT/RCVFR and SNDGAT/SNDFR/SNDPKT

;Option problem
;T2/	class,,error  or  0,,data for ICM%PP
;T4/	Address of error vector
;	CALL INGWEO (from SNDGAT(SNDGA4), from RCVGAT(RCVGAO) )

INGWEO:	HRRZ T3,T2			; Error code or pointer?
	TLNN T2,<-1>			; Skip if <class,,error> code
	  MOVX T3,<PP%PTR,,ICM%PP>	; This is error for pointer in T2
	PUSH P,T2
	PUSH P,T3
	MOVE T3,(T4)
	CAME T3,[PT%KIA]		; Skip count if output
	 CAMN T3,[PT%KIT]
	  CAIA
	   AOS BADPCT			; Count bad packets received
	MOVX T1,NE%DRP+MNTX22		; Protocol option error
	JRST INGWET			; Join below

;Something bad about this packet.  Flush it.

;T4/	Pointer to error vector contining
;	<Trace code>,<ICMP Code,,ICMP Type>,<Pointer or -1>,<ERRC error code>
;T2/	ICMP Pointer (for ICM%PP when 2(T4) contains -1)
;PKT/	(Extended) pointer to packet w/error. May have PPROG, not PINTL.
;	CALL INGWEP (from RCVGA9)  or  CALLret INGWER (SNDGAT(SNAGA3-+,5) )

INGWEP:	AOS BADPCT			; Count bad packets received
INGWER:	SKIPL T1,2(T4)			; T2 valid?
	  MOVE T2,T1			; No, use value from error vector
	PUSH P,T2			; Save pointer for ICM%PP
	PUSH P,1(T4)			; Save Type/Code
	MOVE T1,3(T4)			; Set error code to be returned
INGWET:					; Join from above
	MOVEM T1,ERRC+IPGBLK
	MOVE T1,(T4)			; Get trace code
REPEAT 0,<
	CAMN T1,[PT%KIA]		; Output?
	IFSKP.				; Yes
	ENDIF.
>
	LOAD CX,PTRAC,(PKT)		; Request to trace packet
	SKIPN CX			; Tracing packet, or
	 TDNE T1,MNTRAC			; Want trace?
	  CALL PRNPKI ;(T1,PKT)		; Yes
	POP P,T1			; Type/Code
	POP P,T2			; Pointer
	CALL ICMERR			; Report error & return pkt to free stg
	MOVE T1,ERRC+IPGBLK		; Error code to be returned
	RET
	ENDTV.		; To keep everybody happy - RCVFRS redefines them 
	PURGE ERRC
	SUBTTL	Internet Gateway - Reassembly

	COMMENT	\

RCVFLS	Flush timedout fragments.  Called from main IP loop at timeout time.

	CALL RCVFLS
Ret+1:	Always. Timedout fragments removed from IPRAQ and released; TODCLK of
	next call set into IPRAT.



RCVFR	Process a received fragment -- chain it, or reassemble it into a PKT.

PKT/	Extended fragment packet address
P6/	Address of IPGBLK frame
	CALL RCVFR
Ret+1:	Always.  PKT has extended address of reassembled packet, or 0.


While scanning received fragment chain (IPRAQ), drop any packets
whose Time To Live has expired.

Argument & return value

PKT	Extended pointer to fragment packet which just arrived.
During scan,	gt 0	Extended address of fragment to be inserted
		   0	If packet has been chained, but can't be RA'd
		lt 0	Extended address of first fragment of packet to be RA'd
On return,	Extended pointer to the reassembled packet, or
		   0	If couldn't reassemble anything


Global variables:

IPRAT	TODCLK of next time IPRAQ should be scanned for timedout packets.

IPRAN	Unique # for each packet to be RA'd; starts at 0, first fragment is 1
	(used to minimize comparisons of PISH, PIPRO, PIDH, & PISID).

IPRAQ	Extended pointer to first packet in reassembly chain, or 0 if empty.
	The chain through PKTQ and is sorted by source host (PISH), protocol
	(PIPRO), destination host (PIDH), segment id (PISID), and fragment
	offset (PIFO).

Fields in the packet header are used as follows (while in IPRAQ):

PKTQ	Chains fragments together in sorted order; it contains the extended
	packet address of the next packet in the chain.

PIPRA	Contains packet RA id (an IPRAN) when in IPRAQ.  It contains the
	reason for the fragment being killed when in KPK chain.  When PKT
	lt 0, PIPRA of the first fragment contains LASTFO of last fragment.

PIPRT	Contains the negative TODCLK when the packet was placed into the chain.

PIPTO	The TODCLK when the fragment's IP Time-to-live will expire.

PIPNF	The fragment offset of the next fragment (PIFO+(PIPL-4*PIDO)+7/8)


Local register variables are:

PPK	Extended pointer to previous packet in chain, or dummy at IPRAQ(-PKTQ)
	(needed to unlink packets).

CPK	Extended pointer to current packet being examined, 0 if at end of chain
	( PKTQ(PPK)=CPK ).

SAMEPK	   0 the packet pointed to by PKT is NOT part of that pointed to by CPK
	gt 0 the packet pointed to by PKT IS part of that pointed to by CPK AND
	     all fragments (so far) are present.  The value is a pointer to the
	     fragment BEFORE the first fragment of the packet to be
	     reassembled (e.g. a PPK).
	lt 0 the packet pointed to by PKT is part of that pointed to by CPK AND
	     all fragments (so far) are NOT present.

KPK	Chain through PKTQ of expired packets, or 0 if none.  PIPRA contains
	the trace code specifying why the fragment is being killed.

Local variables in the IPGBLK stack frame are:

KILLTM	TODCLK when fragment just received should be killed.

LASTFO	[When SAMEPK gt 0] Last value of fragment offset (all fragments up to
	it are present);  also used after scan is complete to save PKT.

	\

RCVFLS:	SETZ PKT,			; Flush fragments which have timedout
	TRVAR <<IPGBLK,IPGBLN>>		; Setup standard stack frame

RCVFR:	ACVAR <PPK,CPK,SAMEPK,KPK>	; Setup register variables

;ERRC==0	; Error code to be returned, if any
LASTFO==1
KILLTM==2

MNTM5	AOS CELL(INGFR,0,,ING)		; Calls to RCVFR+RCVFLS
	SETZB SAMEPK,KPK		; Initialize local variables
	SETZM LASTFO+IPGBLK		; No last fragment offset
	XMOVEI PPK,IPRAQ-PKTQ		; Point at dummy packet at head
					; See if have a fragment to process
	JUMPE PKT,RCVFRA		; No, just dropping timedout packets
					; Fill in packet variables
	SETZM PKTQ(PKT)			; Not yet chained
	SETZRO PIPRA,(PKT)		; No RA id

	LOAD T4,PITTL,(PKT)		; Get IP Time-to-live
	SUBI T4,1			; Processing time here
	JUMPLE T4,RCVFRT		; Kill it now
	IMULI T4,^D1000			; Lifetime in milliseconds
	ADD T4,TODCLK			; When to kill it
	STOR T4,PIPTO,(PKT)
	MOVEM T4,KILLTM+IPGBLK

	MOVN T4,TODCLK
	STOR T4,PIPRT,(PKT)		; When put into the reassembly chain

	LOAD T4,PIMF,(PKT)		; For check if last fragment
	LOAD T2,PIDO,(PKT)		; Header length (w)
	ASH T2,2			; (b)
	LOAD T3,PIPL,(PKT)		; Total packet length (b)
	SUB T3,T2			; Data length (b)
	SKIPE T4			; If not last fragment
	 TRNN T3,7			; Data must be multiple of 8 bytes
	  CAIA				; Ok
	   JRST RCVFRS			; Its a bad packet
	ADDI T3,7			; Round up
	ASH T3,-3			; Data length (f)
	LOAD T2,PIFO,(PKT)		; Get fragment offset
	ADD T3,T2			; Find fragment end
	STOR T3,PIPNF,(PKT)		; Save for later
	MOVX T1,.INFIN			; Plus infinity is
	MOVEM T1,IPRAT			; TODCLK of next fragment to timeout

					; See if IPRAQ is empty
	MOVE CPK,IPRAQ			; Locate first fragment
	JUMPN CPK,RCVFRC		; Begin scan if not empty

;Chain is empty: this packet becomes the only entry & PIPTO has next scan time

	MOVEM PKT,IPRAQ			; Begin a chain
	LOAD T4,PIPTO,(PKT)		; Kill time becomes
	MOVEM T4,IPRAT			; Next scan time
	AOSN T1,IPRAN			; Get next RA id
	 AOS T1,IPRAN			; Don't use 0 (Wow 2**36 packets?)
	STOR T1,PIPRA,(PKT)
	MOVX T1,PT%QIF			; Fragment chained
	TDNE T1,MNTRAC			; Want trace?
	  CALL PRNPKI ;(T1,PKT)		; Yes
	JRST RCVFRU			; All done

;Don't have a fragment (PKT=0), just want to purge expired fragments

RCVFRA:	MOVX T1,.INFIN			; Plus infinity is
	MOVEM T1,IPRAT			; Next IPRAT (so far)
	SKIPN CPK,IPRAQ			; Get first entry in chain
	  JRST RCVFRV			; None, all done
	JRST RCVFRC			; Begin with first fragment

;Top of main scanning loop, CPK processed, move to next entry in chain

RCVFRB:	JUMPE CPK,RCVFRV		; If reached end, all done
	MOVE PPK,CPK			; Current packet becomes previous
	MOVE CPK,PKTQ(CPK)		; Next packet becomes current
					; Loop when CPK and PPK are all set
RCVFRC:	JUMPE CPK,RCVFRG		; At end of Q, may have PKT to append
	LOAD T1,PIPTO,(CPK)		; Get packet kill time
	CAMLE T1,TODCLK			; Time to kill this fragment?
	IFSKP.				; Place the packet on kill list
MNTM5	  AOS CELL(INGFR,1,,ING)	; Count timedout fragments
MNTM5<	  LOAD T1,PIPRT,(PKT)>		; Negative time chained
MNTM5<	  ADD T1,TODCLK>		; Time since received
MNTM5<	  ADDM T1,CELL(INGFR,2,,ING)>	; Accumulate TTL chain time
	  MOVE T1,PKTQ(CPK)		; Remove this packet from
	  MOVEM T1,PKTQ(PPK)		; IP reassembly chain
	  MOVEM KPK,PKTQ(CPK)		; Put this packet into kill chain
	  MOVE KPK,CPK
	  MOVE CPK,T1			; Current packet is now the prior next
	  MOVX T1,PT%KIT		; Reassembly timeout tracing code
	  STOR T1,PIPRA,(KPK)
	  JRST RCVFRC			; New current packet to process
	ENDIF.

					; Still have a PKT fragment to insert?
	JUMPLE PKT,RCVFRO		; No, just continue scan

;See if fragment should be inserted between PPK and CPK (KILLTM=kill TODCLK)

	LOAD T1,PIPRA,(CPK)		; Get RA ids (this one is never 0)
	LOAD T2,PIPRA,(PKT)		; 0 if none assigned
	CAMN T2,T1			; Able to skip 4 tests (PIPRA set)?
	IFSKP.				; No

	  LOAD T1,PISH,(CPK)		; Get source addresses
	  LOAD T2,PISH,(PKT)
	  CAMLE T2,T1
	    JRST RCVFRB			; Cannot insert yet, move forward
	  CAME T2,T1
	    JRST RCVFRH			; Insert it here, may have RA id

	  LOAD T1,PIPRO,(CPK)		; Get protocols
	  LOAD T2,PIPRO,(PKT)
	  CAMLE T2,T1
	    JRST RCVFRB			; Cannot insert yet, move forward
	  CAME T2,T1
	    JRST RCVFRH			; Insert it here, may have RA id

	  LOAD T1,PIDH,(CPK)		; Get destination addresses
	  LOAD T2,PIDH,(PKT)
	  CAMLE T2,T1
	    JRST RCVFRB			; Cannot insert yet, move forward
	  CAME T2,T1
	    JRST RCVFRH			; Insert it here, may have RA id

	  LOAD T1,PISID,(CPK)		; Get packet ids
	  LOAD T2,PISID,(PKT)
	  CAMLE T2,T1
	    JRST RCVFRB			; Cannot insert yet, move forward
	  CAME T2,T1
	    JRST RCVFRH			; Insert it here, may have RA id

;Just found another fragment, must be sure to set SAMEPK & LASTFO & PIPTO

	  LOAD T1,PIPRA,(CPK)		; Get RA id
	  STOR T1,PIPRA,(PKT)		; For new fragment
	ENDIF.

	MOVE T4,KILLTM+IPGBLK		; TODCLK newly arrived frag. timesout
	STOR T4,PIPTO,(CPK)		; Update kill time (be liberal...)
	LOAD T1,PIFO,(CPK)		; Get fragment offsets
	LOAD T2,PIFO,(PKT)
	CAMLE T2,T1
	  JRST RCVFRJ			; Cannot insert yet, but part of packet
	CAME T2,T1
	  JRST RCVFRH			; Insert it here, have RA id

;Found a duplicate fragment, discard the smaller

	LOAD T2,PIPNF,(PKT)		; Get end fragment offsets
	LOAD T1,PIPNF,(CPK)
	CAMG T2,T1			; Which is bigger?
	IFSKP.				; New is longer than old, swap in new
	  MOVE T1,PKTQ(CPK)		; Tail
	  MOVEM T1,PKTQ(PKT)
	  MOVEM PKT,PKTQ(PPK)
	  MOVX T1,PT%QIF		; Chained for reassembly
	  TDNE T1,MNTRAC		; Want trace?
	    CALL PRNPKI ;(T1,PKT)	; Yes
	  EXCH CPK,PKT
	ENDIF.

MNTM5	AOS CELL(INGFR,3,,ING)		; Count duplicate fragments received
MNTM5<	LOAD T1,PIPRT,(CPK)>		; Negative time chained
MNTM5<	ADD T1,TODCLK>			; Time since received
MNTM5<	ADDM T1,CELL(INGFR,4,,ING)>	; Accumulate duplicate fragment q-time

	MOVEM KPK,PKTQ(PKT)		; Kill copy pointed to by PKT
	MOVE KPK,PKT
	SETZ PKT,			; PKT processed
	MOVX T1,PT%KDP			; Duplicate fragment rec'd & killed
	STOR T1,PIPRA,(KPK)
	JRST RCVFRO			; Go process current fragment

;Reached end of IPRAQ (CPK=0), may still have PKT to process

RCVFRG:	JUMPLE PKT,RCVFRV		; Packet already processed


;Insert PKT between PPK and CPK, may have RA id

RCVFRH:	IFQE. PIPRA,(PKT)		; Already have RA id for fragment?
	  AOSN T1,IPRAN			; No, get next RA id
	   AOS T1,IPRAN			; Don't use 0 (2**36 packets??)
	  STOR T1,PIPRA,(PKT)
	ENDIF.
					; Now have RA id
	MOVEM PKT,PKTQ(PPK)		; Insert PKT between PPK and CPK
	MOVEM CPK,PKTQ(PKT)
	MOVE CPK,PKT
	MOVX T1,PT%QIF			; Fragment chained
	TDNE T1,MNTRAC			; Want trace?
	  CALL PRNPKI ;(T1,PKT)		; Yes
	SETZ PKT,			; Fragment processed

;See if first fragment of a packet, if so, set SAMEPK & LASTFO

RCVFRJ:	IFE. SAMEPK			; Cannot be first fragment of packet
	  MOVE SAMEPK,PPK		; Flag is adr before first (to unlink)
	  LOAD CX,PIFO,(CPK)		; See if first fragment
	  SKIPE CX
	    TLO SAMEPK,400000		; First fragment missing, cannot RA
	  LOAD T1,PIPNF,(CPK)		; Next fragment offset
	  MOVEM T1,LASTFO+IPGBLK	; For continuity check
	  JRST RCVFRB			; Loop for next fragment in chain
	ENDIF.

;Process current fragment

RCVFRO:	LOAD T1,PIPTO,(CPK)		; Get fragment timeout
	CAMG T1,IPRAT			; Find minimum
	  MOVEM T1,IPRAT		; For next scan

	JUMPLE SAMEPK,RCVFRB		; Not part of a RA'able packet, move on

	LOAD T1,PIPRA,(CPK)		; Get RA ids
	LOAD T2,PIPRA,(PPK)
	CAMN T1,T2			; Part of same packet?
	IFSKP.				; No
	  SETZM SAMEPK			; End of match, cannot reassemble
	  JRST RCVFRB			; Go process next in chain
	ENDIF.
					; Check if current fragment is next
	LOAD T1,PIFO,(CPK)		; Its (beginning) fragment offset must
	CAMLE T1,LASTFO+IPGBLK		; Be .le. last's fragment end offset
	IFSKP.				; It is
	  LOAD T1,PIPNF,(CPK)		; Next fragment offset needed
	  MOVEM T1,LASTFO+IPGBLK	; Remember it
	ELSE.
	  TLO SAMEPK,400000		; Cannot RA
	ENDIF.
	MOVE T4,KILLTM+IPGBLK		; Update kill time in fragments to
	STOR T4,PIPTO,(CPK)		; That of recently arrived fragment

	JUMPLE SAMEPK,RCVFRB		; Don't look for last fragment, move on
	JN PIMF,(CPK),RCVFRB		; Not last fragment, move on

;Have all fragments for reassembly, remove them from the IPRAQ chain

	MOVE PPK,SAMEPK			; Points before first fragment
	MOVE PKT,PKTQ(PPK)		; First fragment to be reassembled
	LOAD T1,PIPNF,(CPK)		; # of fragment blocks in packet
	STOR T1,PIPRA,(PKT)		; Saved for RA
	SETZB SAMEPK,T1			; Just check timeouts in rest of scan
	EXCH T1,PKTQ(CPK)		; CPK is last fragment for reassembly
	MOVEM T1,PKTQ(PPK)		; Relink IPRAQ
	MOVE CPK,T1			; Next fragment to scan
	TLO PKT,400000			; Flag it so don't try to insert
	JRST RCVFRC			; Go process current item

;Argument packet is in error

RCVFRS:	SKIPA T1,[PT%KIP]		; Fragment not contain mod 8 octets
RCVFRT:	  MOVX T1,PT%KPT		; Fragment Time-to-live expired
	STOR T1,PIPRA,(PKT)
	MOVEM PKT,KPK			; Argument packet has expired
RCVFRU:	SETZ PKT,			; Nothing to be returned


;All done with scan of chain, first return any packets to be killed

RCVFRV:	MOVEM PKT,LASTFO+IPGBLK		; Save return value over local variable
	DO.				; While have something to be killed
	  JUMPE KPK,ENDLP.
	  MOVE PKT,KPK			; Head of expired packet chain
	  MOVE KPK,PKTQ(PKT)		; Get tail
	  SETZM PKTQ(PKT)
	  LOAD T1,PIPRA,(PKT)		; Reason for discarding
	  TDNE T1,MNTRAC		; Want trace?
	    CALL PRNPKI ;(T1,PKT)	; Yes; Finished with packet
	  CALL RETPKT			; Release storage
	  LOOP.
	ENDDO.
	MOVE PKT,LASTFO+IPGBLK		; Get return value back

;If PKT lt 0, then reassemble fragments

RCVRA:	JUMPGE PKT,R			; PKT = 0 means nothing to RA, done

	TLZ PKT,400000			; Get first fragment address
	MOVE KPK,PKT			; All fragments will be killed
	MOVE CPK,KPK			; Working ptr to move through fragments
					; Get storage for reassembled packet
	PNTLDR T1,PTPDT,(KPK)		; Address of transport (IP) leader
	SUB T1,KPK			; Words preceeding IP
	LOAD T2,PIDO,(KPK)		; Internet length (w) of first packet
	ADD T1,T2	
	LOAD T2,PIPRA,(KPK)		; Number of fragment blocks, all frags
	ASH T2,1			; At 2 words each
	ADD T1,T2
	MOVX T2,NP.IP			; IP protocol
	PUSH P,T1			; Save size of block
	CALL GETBLK			; Get storage for all
	POP P,T2			; Want size in T2 for CLRBLK
	MOVE PKT,T1			; Combined packet (may be zero)
	JUMPE PKT,RCVRAF ;CPK		; Error - killed due to no space
					; Enough room, copy first frag into pkt
	CALL CLRBLK			; Clear the block first
	LOAD T1,NBNCT,(KPK)		; Copy NCT
	STOR T1,NBNCT,(PKT)

	MOVE SAMEPK,PKT			; Working address in combined packet
MNTM5<	LOAD T1,PIPRT,(CPK)>		; Negative time chained
MNTM5<	ADD T1,TODCLK>			; Time since received
MNTM5<	ADDM T1,CELL(INGFR,10,,ING)>	; Accumulate frag reassembly q-time

	LOAD T1,PIPL,(KPK)		; Max packet length so far
	STOR T1,PMXSZ,(PKT)

	PNTLDR SAMEPK,PLNDT,(KPK)	; Address of local net leader, fragment
	MOVE T2,SAMEPK			; Source of copy
	SUB SAMEPK,KPK			; Words before it
	ADD SAMEPK,PKT			; Address of local net leader, new
	STOR SAMEPK,PLNDT,(PKT)		; Destination for copy

	LOAD T1,PIDO,(KPK)		; Transport header length (w)
	STOR T1,PTPBZ,(PKT)		; Incremental, words

	PNTLDR T3,PTPDT,(KPK)		; Address of transport leader, old
	SUB T3,T2			; Length local net leader
	STOR T3,PLNBZ,(PKT)		; Incremental, words
	ADD T1,T3			; To be copied
	ADD T3,SAMEPK
	STOR T3,PTPDT,(PKT)		; Address of transport leader, new
	MOVE T3,T1
	ADD T3,SAMEPK
	STOR T3,PSSDT,(PKT)		; Address of session leader, new

	LOAD T4,PIPNF,(KPK)		; Data length (f)
	MOVEM T4,LASTFO+IPGBLK		; Next fragment offset
	ASH T4,1			; In words
	ADD T1,T4			; Words for first copy

	JRST RCVRAP			; Into loop, (T1,T2,SAMEPK,CPK,PKT)

;Error returns

RCVRAE:	SETZM PKTFLG(PKT)		; Error, missing (last) fragment??
	CALL RETPKT			; Discard partially ra'ed packet
	SKIPA T1,[PT%KIT]		; Code for impossible error
RCVRAF:	  MOVX T1,PT%KIS		; Error, insufficient space to ra pkt
	DO.				; Put error code in T1 into fragments
	  STOR T1,PIPRA,(CPK)		; Code into fragment
MNTM5	  AOS CELL(INGFR,5,,ING)	; Count fragment killed due to space
MNTM5<	  LOAD T1,PIPRT,(CPK)>		; Negative time chained
MNTM5<	  ADD T1,TODCLK>		; Time since received
MNTM5<	  ADDM T1,CELL(INGFR,6,,ING)>	; Accumulate no space q-time
	  MOVE CPK,PKTQ(CPK)		; Move to next
	  JUMPN CPK,TOP.		; Back for all fragments
	ENDDO.
	JRST RCVFRU			; Back to kill them off

RCVRAL:	MOVE CPK,PKTQ(CPK)		; Get next fragment
	JUMPE CPK,RCVRAE		; Error? Last fragment missing
MNTM5<	LOAD T1,PIPRT,(CPK)>		; Negative time chained
MNTM5<	ADD T1,TODCLK>			; Time since received
MNTM5<	ADDM T1,CELL(INGFR,10,,ING)>	; Accumulate frag reassembly q-time

	LOAD T2,PMXSZ,(PKT)		; Max size so far
	LOAD T3,PIPL,(CPK)		; Size of this fragment
	CAMLE T3,T2			; New max?
	  STOR T3,PMXSZ,(PKT)		; Yes, remember it
	LOAD T2,PIDO,(CPK)		; Header length (w)
	MOVE T3,LASTFO+IPGBLK		; Next fragment to copy
	LOAD T1,PIPNF,(CPK)		; Data end fragment offset
	LOAD T4,PIFO,(CPK)		; Data start fragment offset

; Worry about overlap - beginning of fragment may already be copied

	CAMGE T3,T1			; If this fragment adds some
	  MOVEM T1,LASTFO+IPGBLK	; Save new last fragment
	SUB T3,T4			; Find # fragments of overlap
	JUMPL T3,RCVRAE			; Error, missing fragment??
	ASH T3,1			; In words
	SUB T1,T4			; Data length of CPK
	ASH T1,1			; In words
	ADDI T2,PKTELI(T3)		; Increase copy offset and
	SUB T1,T3			; Decrease copy length by overlap
	IFG. T1				; Anything required from this fragment?
	  ADD T2,CPK			; Start of data address
					; Copy T1 words from T2 into packet
RCVRAP:	  MOVX T4,PT%DIF		; Code for IP RA'd
	  STOR T4,PIPRA,(CPK)		; Into fragment
	  MOVE T3,SAMEPK		; Address in packet
	  ADD SAMEPK,T1			; Next address in packet
	  CALL XBLTA			; Copy words
	ENDIF.
	JN PIMF,(CPK),RCVRAL		; If more fragments, loop

;Done, correct internet header; find new packet length

	LOAD T1,PIPL,(CPK)		; Last fragment length (b)
	LOAD T2,PIDO,(CPK)		; Header length (w)
	ASH T2,2			; (b)
	SUB T1,T2			; Data length (b) of last fragment
	LOAD T2,PIFO,(CPK)		; Data length (f) of previous fragments
	ASH T2,3			; (b)
	ADD T1,T2			; Total data length (b)
	LOAD T2,PIDO,(PKT)		; Data offset (w)
	ASH T2,2			; (b)
	ADD T1,T2			; Total packet length (b)
	STOR T1,PIPL,(PKT)		; Into packet
	STOR T1,PSSBZ,(PKT)		; Length at session level
	LOAD T2,PTPBZ,(PKT)		; Words in transport leader
	LSH T2,2			; Bytes
	ADD T1,T2
	STOR T1,PTPBZ,(PKT)		; Length at transport level
	LOAD T2,PLNBZ,(PKT)		; Words in local net level leader
	LSH T2,2			; Bytes
	ADD T1,T2
	STOR T1,PLNBZ,(PKT)		; Length at local net level

	SETZRO <PIMF,PIFO>,(PKT)	; Should be zero
	LOAD T1,PIPTO,(PKT)		; Kill time
	SUB T1,TODCLK			; Remaining
	IDIVI T1,^D1000			; In seconds
	CAILE T1,377			; Clamp to 8 bits
	  MOVEI T1,377
	CAIGE T1,1
	  MOVEI T1,1
	STOR T1,PITTL,(PKT)		; Remaining Time To Live

	SETZRO PICKS,(PKT)		; Compute
	CALL INTCKS			; New header checksum
	STOR T1,PICKS,(PKT)

;Have a reassembled packet to return after release fragments

MNTM5	AOS CELL(INGFR,7,,ING)		; Count reassembled fragments
	MOVX T1,PT%IRA			; Packet reassembled
	TDNE T1,MNTRAC			; Want trace?
	  CALL PRNPKI ;(T1,PKT)		; Yes

	JRST RCVFRV			; Go kill fragments from KPK

	ENDAV.
	ENDTV.
	PURGE LASTFO,KILLTM

	SUBTTL	Internet Gateway - Packets to Network - Routing+Options

;SNDGAT	Send a packet into a Network.

;Send the packet to some host on a local net which is either the
;destination or a gateway presumed to be capable of getting the packet
;closer to the destination.

;PKT/	Extended pointer to packet to be sent
;T1/	Special first-hop address, or 0 if none
;	CALL SNDGAT
;Ret+1:	Always, packet given to driver, or released if error (and PFLGP(s)=0).
;	T1/ Error code (NE%DRP set if packet dropped), or MNTX00 if no error.

SNDGAT::
	SKIPGE INTON			; Internet ON?
	IFSKP.				; No, refuse packet
	  MOVX T1,<NE%DRP+MNTX17>	; Protocol not available
	  RET
	ENDIF.

	SAVEAC <VNCT>			; Save NCT register
	TRVAR <<IPGBLK,IPGBLN>>		; Transient variables

ERRC==0		; Error code to be returned, if any
FHRUT==1	; First-hop destination (route)
CTYPE==2	; Call type == -1
SRP==3		; IDPB pointer for sending interface's address, or 0
SRC==4		; Route option code (LSROPT or SSROPT) [temp:see RRTC]
RRTP==5		; IDPB pointer for sending interface's address, or 0

	MOVX CX,MNTX00			; Assume no errors
	MOVEM CX,ERRC+IPGBLK		; No errors yet
	MOVEM T1,FHRUT+IPGBLK		; Save first-hop address, or 0

MNTM5	AOS CELL(INGAA,12,,ING)		; SNDGAT calls
MNTM5	AOS CELL(INGGY,3,,ING)		; Packets to SNDGAT
	SETONE PLCLO,(PKT)		; Packet of local origin
	SETZRO PIPRA,(PKT)		; No (fragment) output chain
	MOVX T1,PT%RGI			; Packet received at gateway
	TDNE T1,MNTRAC			; Want trace?
	  CALL PRNPKI ;(T1,PKT)		; Yes (Note: Checksum invalid here)

;Normal, non-secure packet.

	SETOM CTYPE+IPGBLK		; Sending
	CALL IPOPT			; Do options
	  JRST SNDGA4			; Option error

;Find where to send packet (PIDH may have been changed by routing
;option.  Note that if changed, the TCP checksum is "wrong" until the
;the last gateway is reached and the original destination is restored.)

	LOAD T1,PIDH,(PKT)		; Get 32-bit internet destination
	IFE. T1				; 0 address is this host
	  MOVEI T1,NLHOST		; List of our addresses
	  LOAD T1,PISH,(PKT)		; Maybe help make decision
	  SETZ T2,
	  CALL BSTADR			; Find a good one
	    JRST SNDGA7			; ??
	  MOVE T1,T2
	  STOR T1,PIDH,(PKT)		; Set it
	ENDIF.

	SKIPE FHRUT+IPGBLK		; Special first-hop routing?
	  MOVE T1,FHRUT+IPGBLK		; Yes, use it instead

;PNLCL is set when a packet must be forced out to the net to the
;SOURCE. This is typically an ECHO-REPLY made by ICMP/GGP on this
;host but faked up to make it look like it came from remote gateway
;which, because it is dumb, can only forward the packet back to us.

	OPSTR SKIPE,PNLCL,(PKT)		; Special addressing?
	  LOAD T1,PISH,(PKT)		; Entire 32-bit gateway address

;SNDGA2
;Entry for RCVGAT to forward a packet

;T1/	32 bit destination address for which a route must be found
;PKT/	(Ext) pointer to packet
;P6/	Address of IPGBLK frame
;Ret+1:	Always, packet given to driver, or released if error (and PFLGP(s)=0).
;	T1/ Error code (NE%DRP set if packet dropped), or MNTX00 if no error.

SNDGA2:	SETZRO PIPRA,(PKT)		; No chain here
	PUSH P,T1			; Save dest in case Strict Source Route
	CALL GWYLUK			; Lookup gateway/interface (sets NCT)
	  JFCL				; Might be down, try to send it anyway
	POP P,T2			; Original Destination w/logical host
	XOR T2,T1			; First Hop same as original dest.?
	TDZ T2,NTNLHM(VNCT)		; Forget logical host mis-match
	MOVE T4,SRC+IPGBLK		; Get strict/lose flag
	CAIN T4,SSROPT			; Skip if not strict route
	  JUMPN T2,SNDGA3		; Jump if strict route failure
	JUMPN T1,SNDGA6			; Jump if packet has a first hop dest.
					; Nowhere to send packet
;cwl use DU%HST if local net?
					; Must be Interface down
	MOVEI T4,[EXP PT%KIA,<DU%NET,,ICM%DU>,0,NE%DRP+MNTX11]
	CALLRET INGWER			; Process error & return

;Strict Source Route failure
					; Source route failure
SNDGA3:	MOVEI T4,[EXP PT%KIA,<DU%SRF,,ICM%DU>,0,NE%DRP+MNTX25]
	CALLRET INGWER			; Process error & return

;Option problem

SNDGA4:	MOVEI T4,[EXP PT%KIA,,,NE%DRP+MNTX22] ; Trace code
	CALLRET INGWEO			; Process error & return

;Time-to-live exceeded
					; Time exceeded
SNDGA5:	MOVEI T4,[EXP PT%KIT,<TE%TTL,,ICM%TE>,10,NE%DRP+MNTX33]
	CALLRET INGWER

;Cannot find local host address

SNDGA7:	MOVEI T4,[EXP PT%KIA,<DU%HST,,ICM%DU>,0,NE%DRP+MNTX23]
	CALLRET INGWER			; Process error & return

;Forewarding not permitted

SNDGA9:	MOVEI T4,[EXP PT%KIA,<DU%SRF,,ICM%DU>,-1,NE%DRP+MNTX25]
MNTM5	AOS CELL(INGGY,2,,ING)		; Un-Forwarded packets, SNDGAT
	CALLRET INGWER			; Process error

;Routing and interface selection have been completed.

;T1/ First-hop destination on the selected local network (maybe w/logical host)
;VNCT/ NCT address ( 0,,NCT  or  loopback NCT,,sending NCT )

SNDGA6:
	MOVE CX,PKTFLG(PKT)		; Get packet flags
	MOVE T3,MNTSW			; Switches
	TXNN CX,PLCLO			; Packet to be forewarded, and
	 TXNN T3,MNS%RF			; Forewarding restricted?
	IFSKP.				; Yes, check for permission
	  LOAD T2,NBNCT,(PKT)		; Receiving NCT
	  LOAD T2,NTHSH,(T2)		; Receiving hash code
	  ADJBP T2,MNTFWT		; Pointer to receiving mask
	  LDB T2,(T2)			; Receiving mask
	  LOAD T3,NTHSH,(VNCT)		; Sending hash code
	  MOVNS T3			; For right shift
	  LSH T2,(T3)			; Relevant bit to LSB
	  TXNN T2,1			; Allow it?
	    JRST SNDGA9			; No, Drop & Destination Unreachable
	ENDIF.

;May have to insert host address into routing option

	MOVE T3,NTLADR(VNCT)		; Address sending packet
	SKIPE T4,RRTP+IPGBLK		; If have a Record route option,
	  CALL INSHST ;(saves T1)	; Insert sending interface's address
	SKIPE T4,SRP+IPGBLK		; If have a Source route option,
	  CALL INSHST ;(saves T1)	; Insert sending interface's address


;Decrement ttl, maybe killing packet

	LOAD T2,PITTL,(PKT)		; Original value
	SUBI T2,1			; Less one
	SKIPL T2			; Don't wrap around
	  STOR T2,PITTL,(PKT)		; Update packet
	JUMPL T2,SNDGA5			; Process error & return
					; Should TTL=0 be killed here or not?

;Decide if packet is too big for selected network, if so, fragment it

	LOAD T4,PIPL,(PKT)		; Get packet length
	MOVE T2,NTPSIZ(VNCT)		; Get maximum size for the interface
	TLNN VNCT,377777		; Double NCT?
	IFSKP.
MNTM5	  AOS CELL(INGGY,4,,ING)	; Loopedback packets, SNDGAT
	  HLRZ CX,VNCT			; Yes, get second NCT
	  CAMLE T2,NTPSIZ(CX)		; Compare to its maximum size
	    MOVE T2,NTPSIZ(CX)		; Take minimum for two interfaces
	ENDIF.
	CAMG T4,T2			; Check maximum size for the interface
	  CALLRET SNDPKT		; Send the packet, return error code

;Fragment packet too large for local network ...

	PURGE FHRUT,CTYPE,SRP,SRC,RRTP

	SUBTTL	Internet Gateway - Packets to Network - Fragmentation

	COMMENT	\

SNDFR	Fragment IP packet.

T1/	First-hop destination address
T2/	Max packet size (PIPL)
VNCT/	NCT address ( 0,,NCT  or  loopback NCT,,sending NCT )
P6/	Address of IPGBLK frame
PKT/	Packet address
	CALL SNDFR
Ret+1:	Always, packet passed to net, or if error and PFLGP(s)=0, released.


Local variables

BD	Data length for first fragment (bytes).

BO	Original data offset (bytes).

CNT	A count of option bytes in header left to process.

DCT	Number of data octets remaining in original packet.

DPT	Address in original packet for next data to be copied.

FFR	Address of packet containing first fragment, or zero if none.

FHRUT	First-hop destination address.

FRO	Fragment offset.

LFR	Extended address of the last fragment generated.

OIN	Byte pointer into original packet for next option byte (T2).

OFC	Possible fragment chain from packet being fragmented.

OLB	Option length.

OOT	Byte pointer into second fragment for next option byte (T3).

OPT	Option code.

OPK(V)	Extended address of the original packet being fragmented.

SFR	Address of packet containing second fragment (containing header &
	squeezed options), or zero if none.  NB: PPROG is set in this
	packet to make sure it stays around until all fragments have been
	generated; it is then cleared & if PFLGP are zero, freed.

SIZ	Maximum PIPL length for fragment.

TPK	If original PKT has PPROG zero, then PKT [RETPKT it]; else zero.

	\


SNDFR:	ACVAR <BDOL,BOOP,LPCT>		; Locals shouldn't overrun NCT
IFLE <VNCT-LPCT>,<DEFINE TELL(NCT,VAR)<
			PRINTX ?SNDFR overrunning NCT with local variables VAR>
TELL(\VNCT,\LPCT)>

	SAVEAC <PKT>

;ERRC==0	; Error code to be returned, if any
FHRUT==1
OPKV==2
DPT==3
FFR==4
FRO==5
OIN==6
OOT==7
SFR==10
TPK==11
DCT==12
SIZ==13
LFR==14
OFC==15

BD==:BDOL
BO==:BOOP
OPK==:LPCT

MNTM5	AOS CELL(INGFS,0,,ING)		; Calls to SNDFR/packets fragmented
	MOVEM T1,FHRUT+IPGBLK		; Save first-hop destination
	MOVEM T2,SIZ+IPGBLK		; Max PIPL allowed (bytes)
	MOVEM PKT,OPKV+IPGBLK		; Original packet for tracing, etc.
	LOAD T1,PIPRA,(PKT)		; Packet to be fragmented may have
	MOVEM T1,OFC+IPGBLK		; A chain, save it
	MOVE OPK,PKT			; Pointer to original packet
	SETZM FFR+IPGBLK		; No first fragment to be RETPKTed
	SETZM SFR+IPGBLK		; No second fragment to be RETPKTed
	SETZM LFR+IPGBLK		; No last fragment generated
	SETZM TPK+IPGBLK		; Assume PPROG eq 1 (do not release)
	IFQE. PPROG,(PKT)		; Assumption correct?
	  MOVEM PKT,TPK+IPGBLK		; No, release original packet when done
	ENDIF.


;Check if fragmention not allowed or time-to-live about to expire.

	IFQN. PIDF,(PKT)		; If packet has "Don't fragment"
MNTM5	  AOS CELL(INGFS,1,,ING)	; Count fragmentation required failures
	  MOVEI T4,[EXP PT%KDF,<DU%FRG,,ICM%DU>,0,NE%DRP+MNTX02]
	  JRST SNDFRY			; Go process error
	ENDIF.

	LOAD T1,PITTL,(PKT)		; Remaining time to live
	CAILE T1,2			; One for fragmentation & 1 to send
	IFSKP.				; Packet will expire
MNTM5	  AOS CELL(INGFS,2,,ING)	; Count Time-to-live 0 packets
	  MOVEI T4,[EXP PT%KPT,<TE%TTL,,ICM%TE>,0,NE%DRP+MNTX33]
	  JRST SNDFRY			; Go process error
	ENDIF.

;Compute storage required for first fragment

	LOAD T2,PIDO,(OPK)		; Data offset (w)
	MOVE BO,T2
	ASH BO,2			; Data offset (b)
	MOVE BD,SIZ+IPGBLK		; Max PIPL allowed (b)
	SUB BD,BO
	ANDI BD,777770			; Data octets (b)
	MOVE T1,BD
	ASH T1,-2			; Data (ew)
	ADDI T1,PKTELI(T2)		; Packet length (w)
	PUSH P,T1			; Save for copy
	MOVX T2,NP.IP			; Protocol code
	CALL GETBUF
	MOVE PKT,T1			; First fragment address (or 0)
	POP P,T1			; Copy length (w)
	JUMPLE PKT,SNDFRZ		; No room
	SUBI T1,NBHDRL
	XMOVEI T2,NBHDRL(OPK)		; Original packet
	XMOVEI T3,NBHDRL(PKT)		; First fragment
	CALL XBLTA			; Copy local+header+options+data
	MOVEM T2,DPT+IPGBLK		; Next data address
	LOAD T1,PIFO,(PKT)		; Save initial fragment offset
	MOVEM T1,FRO+IPGBLK
	LOAD T1,PIPL,(OPK)		; Initial packet length (b)
	SUB T1,BO			; Less header & options
	MOVEM T1,DCT+IPGBLK		; Is initial data length (negative)
	CAMG T1,BD			; Should be .gt. allowed data length
	IFSKP.
	  MOVE T1,BD			; Another fragment required
	  SETONE PIMF,(PKT)		; So set more fragments flag
	ENDIF.

SNDFRD:	SUBM T1,DCT+IPGBLK		; Update remaining data octets
	MOVNS DCT+IPGBLK
	MOVE T2,T1
	ASH T2,-3			; Fragment blocks in fragment
	ADDM T2,FRO+IPGBLK		; Next fragment offset
	ADD T1,BO			; Packet length (b)
	STOR T1,PIPL,(PKT)
	LOAD T1,PITTL,(PKT)		; Reduce time to live in first
	SUBI T1,1			; Fragment
	STOR T1,PITTL,(PKT)

	SKIPG DCT+IPGBLK		; Anything left?
	  JRST SNDFRV			; No, all done
	MOVEM PKT,FFR+IPGBLK		; Save frist frag until check options
	MOVE T1,INPSW			; IP switches
	TXNE T1,IPS%FR			; Skip if not fragment chaining
	IFSKP.
	  SETONE PPROG,(PKT)		; Don't let driver release on us
	ENDIF.

;Build second fragment, squishing options

	MOVE T1,SIZ+IPGBLK		; Max PIPL allowed (b)
	ASH T1,-2			; (W)
	ADDI T1,PKTELI
	MOVX T2,NP.IP			; Protocol code
	CALL GETBUF
	SKIPG PKT,T1			; Get space?
	  JRST SNDFRZ			; No
	MOVEI T1,<<MINIHS/4>+PKTELI>	; Local plus minimum internet header
	SUBI T1,NBHDRL
	XMOVEI T2,NBHDRL(OPK)		; Original packet
	XMOVEI T3,NBHDRL(PKT)		; First fragment
	CALL XBLTA

;T2/	Address of first original option byte
;T3/	Address where they go
;Selectively copy options, if present

	SETZ T1,			; New option length (w) if branch
PURGE BD,BO
OLB==:BDOL
OPT==:BOOP
CNT==:LPCT
	LOAD CNT,PIDO,(OPK)		; Original header+option length (w)
PURGE OPK
	SUBI CNT,<MINIHS/4>		; Minumum header size (w)
	JUMPLE CNT,SNDFRO		; No options
	ASH CNT,2			; # option bytes present
	MOVE T1,[POINT 8,(T2)]		; Get byte pointers to
	MOVEM T1,OIN+IPGBLK		; Read old options
	MOVE T1,[POINT 8,(T3)]		; And
	MOVEM T1,OOT+IPGBLK		; Write those copied

					; Process next option
	DO. (SNDFRG)
	  ILDB OPT,OIN+IPGBLK		; Get option code
	  CAIE OPT,ENDOPT		; End of options - go fill last word
	   CAIN OPT,ENDOPT+CPYOPT	; Watch out!
	    EXIT.
	  CAIN OPT,NOPOPT		; NOP - drop it
	  IFSKP.
	    CAIE OPT,NOPOPT+CPYOPT	; Watch out! (let the next IP die)
	    IFSKP.
	      IDPB OPT,OOT+IPGBLK	; Copy NOP...
	    ELSE.			; Process option with length
	      ILDB OLB,OIN+IPGBLK	; Get option length
	      CAIL CNT,2		; Was that a valid byte?
	       CAMGE CNT,OLB		; Make sure have enough bytes left
	        JRST SNDFRW		; Error, partial option
					; Check if to copy option to all frags
	      SUBI CNT,-1(OLB)		; Option bytes beyond this option(SOGJ)
	      TRNN OPT,CPYOPT		; Check copy on fragmentation flag
	      IFSKP.			; To be copied
	        IDPB OPT,OOT+IPGBLK	; Copy option code
	        IDPB OLB,OOT+IPGBLK	; And option length
	      ENDIF.
	      SUB CNT,OLB		; Option bytes beyond this option
	      ADDI CNT,1		; Will count 1 at end
	      SUBI OLB,2		; Count down length byte
	      ANDG. OLB			; If more bytes to be copied
	        DO.			; Copy them
	          ILDB T1,OIN+IPGBLK	; Get next octet
	          TRNE OPT,CPYOPT	; Check if copying
	            IDPB T1,OOT+IPGBLK	; Yes
	          SOJG OLB,TOP.		; Loop if more in option
	        ENDDO.
	    ENDIF.			; Option with length/copy NOP
	  ENDIF.			; Drop NOP
	  SOJG CNT,TOP.			; Loop if another option
	ENDDO.
	MOVX T2,ENDOPT			; Fill options to word boundary
	IDPB T2,OOT+IPGBLK
	IDPB T2,OOT+IPGBLK
	IDPB T2,OOT+IPGBLK
	IDPB T2,OOT+IPGBLK		; And leave it in free word
	HRRZ T1,OOT+IPGBLK		; RH has # words of options
	MOVEI T2,<<MINIHS+3>/4>(T1)
	STOR T2,PIDO,(PKT)		; New Data offset (w)
SNDFRO:

PURGE OPT,OLB,CNT

;Update PIPL and copy data into second fragment
;T1/	(New) option length (w)
;T3/	Address of first opt

	ADD T3,T1			; Where to copy to
	LOAD T4,PIDO,(PKT)		; New data offset (w)
	ASH T4,2			; (b)
	MOVE T1,SIZ+IPGBLK		; Max PIPL allowed (b)
	SUB T1,T4			; Max data length (b)
	ANDI T1,777770			; In fragment blocks
	CAMLE T1,DCT+IPGBLK		; Number of bytes left
	  MOVE T1,DCT+IPGBLK		; Last fragment
	SUBM T1,DCT+IPGBLK		; Update Data bytes left
	MOVNS DCT+IPGBLK
	ADD T4,T1			; New data+header (b)
	STOR T4,PIPL,(PKT)		; Packet length
	ADDI T1,3			; Round octets up to
	ASH T1,-2			; Data words to copy
	MOVE T2,FRO+IPGBLK		; Fragment offset for second frag
	STOR T2,PIFO,(PKT)		; Into header
	MOVE T2,T1
	ASH T2,-1			; Fragment blocks
	ADDM T2,FRO+IPGBLK
	MOVE T2,DPT+IPGBLK		; Where to copy from
	CALL XBLTA			; From original to second fragment
	MOVEM T2,DPT+IPGBLK		; For next time
	LOAD T1,PITTL,(PKT)		; Reduce time to live
	SUBI T1,1			; By fragmentation
	STOR T1,PITTL,(PKT)
	SETZM PKTQ(PKT)
	SETZM PKTFLG(PKT)
	SKIPG DCT+IPGBLK		; Need another fragment?
	IFSKP.				; Yes
	  MOVE T1,INPSW			; IP switches
	  TXNE T1,IPS%FR		; Skip if not fragment chaining
	  IFSKP.
	    SETONE PPROG,(PKT)		; Keep PKT to copy headers & options
	  ENDIF.
	  MOVEM PKT,SFR+IPGBLK		; Save packet address for copy
	  SETONE PIMF,(PKT)		; There are more fragments
	ENDIF.


	MOVE T1,INPSW			; IP switches
	TXNN T1,IPS%FR			; Skip if fragment chaining
	IFSKP.
	  MOVE T2,FFR+IPGBLK		; First fragment
	  MOVE T1,FHRUT+IPGBLK		; Restore first-hop destination
	  STOR T1,PFLAD,(T2)		; To whom packet is being sent
	  STOR VNCT,NBNCT,(T2)		; Interface(s) to be used
	  STOR T1,PFLAD,(PKT)		; To whom packet is being sent
	  STOR VNCT,NBNCT,(PKT)		; Interface(s) to be used
	  STOR PKT,PIPRA,(T2)		; Points to second
	  MOVEM PKT,LFR+IPGBLK		; Last fragment generated
	ENDIF.

;Process first two fragments

	PUSH P,PKT			; Save second fragment
	MOVE PKT,FFR+IPGBLK		; First fragment
MNTM5	AOS CELL(INGFS,4,,ING)		; Fragments created by SNDFR
	MOVX T1,PT%IFR			; Fragment created
	TDNE T1,MNTRAC			; Want trace?
	  CALL PRNPKI ;(T1,PKT)		; Yes

	MOVE T1,INPSW			; IP switches
	TXNE T1,IPS%FR			; Skip if not fragment chaining
	IFSKP.
	  MOVE T1,FHRUT+IPGBLK		; Restore first-hop destination
	  CALL SNDPKT			; Fragment to local interface
	  MOVEM T1,ERRC+IPGBLK		; Error code to be returned
	ENDIF.

	POP P,PKT			; Now process second
MNTM5	AOS CELL(INGFS,4,,ING)		; Fragments created by SNDFR
	MOVX T1,PT%IFR			; Fragment created
	TDNE T1,MNTRAC			; Want trace?
	  CALL PRNPKI ;(T1,PKT)		; Yes

	MOVE T1,INPSW			; IP switches
	TXNE T1,IPS%FR			; Skip if not fragment chaining
	IFSKP.
	  MOVE T1,FHRUT+IPGBLK		; Restore first-hop destination
	  CALL SNDPKT			; Fragment to local interface
	  MOVEM T1,ERRC+IPGBLK		; Error code to be returned
	ENDIF.

	SKIPG DCT+IPGBLK		; Anything left?
	  JRST SNDFRX			; All done

;Create third through last fragments

	DO. (SNDFRS)
	  MOVE T1,SFR+IPGBLK		; Packet with header+options
	  LOAD T4,PIDO,(T1)		; Data offset (w)
	  ASH T4,2			; (b)
	  MOVE T1,SIZ+IPGBLK		; Max PIPL allowed (b)
	  SUB T1,T4			; Max data length (b)
	  ANDI T1,777770		; In fragment blocks
	  CAMLE T1,DCT+IPGBLK		; Number of bytes left
	    MOVE T1,DCT+IPGBLK		; Last fragment
	  SUBM T1,DCT+IPGBLK		; Data bytes left
	  MOVNS DCT+IPGBLK
	  PUSH P,T1			; Save data length
	  ADDI T1,<<PKTELI*4>+3>(T4)	; Local+round up+header
	  ASH T1,-2			; Buffer length (w)
	  MOVX T2,NP.IP			; Protocol code
	  CALL GETBUF
	  SKIPG PKT,T1			; Get space?
	    JRST SNDFRA			; No

	  XMOVEI T3,NBHDRL(PKT)		; Empty buffer
	  MOVE T2,SFR+IPGBLK
	  LOAD T1,PIDO,(T2)		; Length header+options (w)
	  XMOVEI T2,NBHDRL(T2)		; Packet with local+header+options
	  ADDI T1,PKTELI-NBHDRL		; Plus local
	  CALL XBLTA			; (NB: this copies PIPRA, fix later)
	  POP P,T1			; Data length (b)
	  LOAD T4,PIDO,(PKT)		; Header length (w)
	  ASH T4,2			; (b)
	  ADD T4,T1
	  STOR T4,PIPL,(PKT)		; New length
	  ADDI T1,3			; Data bytes are
	  ASH T1,-2			; Rounded up words
	  MOVE T2,FRO+IPGBLK		; Fragment offset
	  STOR T2,PIFO,(PKT)		; Into packet
	  MOVE T2,T1
	  ASH T2,-1			; Fragment blocks
	  ADDM T2,FRO+IPGBLK		; Next fragment offset
	  MOVE T2,DPT+IPGBLK		; Next data address
	  CALL XBLTA
	  MOVEM T2,DPT+IPGBLK		; For next fragment
	  MOVE T2,OPKV+IPGBLK		; Get PIMF from
	  LOAD T4,PIMF,(T2)		; Original packet
	  SKIPLE DCT+IPGBLK		; If more data
	    MOVEI T4,1			; Set PIMF
	  STOR T4,PIMF,(PKT)		; Store result

MNTM5	  AOS CELL(INGFS,4,,ING)	; Fragments created by SNDFR

; (May enter here with first fragment in PKT, if fragmentation wasn't needed)

SNDFRV:
	  MOVE T1,INPSW			; IP switches
	  TXNN T1,IPS%FR		; Skip if fragment chaining
	  IFSKP.
	    MOVE T1,FHRUT+IPGBLK	; Restore first-hop destination
	    STOR T1,PFLAD,(PKT)		; To whom packet is being sent
	    STOR VNCT,NBNCT,(PKT)	; Interface(s) to be used
	    MOVE T2,LFR+IPGBLK		; Last fragment
	    STOR PKT,PIPRA,(T2)		; Points to this one
	    MOVEM PKT,LFR+IPGBLK	; This one becomes last
	    SETZRO PIPRA,(PKT)		; Fix for XBLTA
	  ENDIF.

	  MOVX T1,PT%IFR		; Fragment created
	  TDNE T1,MNTRAC		; Want trace?
	    CALL PRNPKI ;(T1,PKT)	; Yes

	  MOVE T1,INPSW			; IP switches
	  TXNE T1,IPS%FR		; Skip if not fragment chaining
	  IFSKP.
	    MOVE T1,FHRUT+IPGBLK	; Restore first-hop destination
	    CALL SNDPKT			; Fragment to local interface
	    MOVEM T1,ERRC+IPGBLK	; Error code to be returned
	  ENDIF.

	  SKIPLE DCT+IPGBLK		; More data?
	    LOOP.			; Yes
	ENDDO.

	MOVE T1,OFC+IPGBLK		; If original packet had a chain,
	STOR T1,PIPRA,(PKT)		; Put it at end (also fix for XBLTA)

	MOVE T1,INPSW			; IP switches
	TXNN T1,IPS%FR			; Skip if fragment chaining
	IFSKP.
	  SETZB PKT,SFR+IPGBLK		; No longer need second, if it exists
	  EXCH PKT,FFR+IPGBLK		; Get first fragment in chain
	  MOVE T1,FHRUT+IPGBLK		; Restore first-hop destination
	  CALL SNDPKT			; Fragment to local interface
	  MOVEM T1,ERRC+IPGBLK		; Error code to be returned
	ENDIF.

	JRST SNDFRX			; All done

;Error processing

;No space

SNDFRA:	POP P,(P)			; Drop data length
SNDFRZ:	MOVE PKT,OPKV+IPGBLK		; Original PKT
MNTM5	AOS CELL(INGFS,3,,ING)		; No space for fragment
	MOVEI T1,[EXP PT%KFS,<0,,ICM%SQ>,0,NE%DRP+MNTX24] ; Error vector


;Enter here with
;T4/	Error vector
;PKT/	Original packet

SNDFRY:	CALL INGWER			; Process error
	JRST SNDFWX			; Packet is gone


;Error while squishing options for second fragment

SNDFRW:	CALL RETPKT			; Get rid of bad packet (second frag)
	MOVE PKT,OPKV+IPGBLK		; Original packet
	MOVX T1,PT%KIO			; Error (not killing it though)
	TDNE T1,MNTRAC			; Want trace?
	  CALL PRNPKI ;(T1,PKT)		; Yes
	MOVX CX,PINTL			; Us
	ANDCAB CX,PKTFLG(PKT)
	TXNN CX,PFLGP			; Any others?
	  CALL RETPKT			; No, return packet

;Here after an ICMP error (original packet already returned)

SNDFWX:	SETZM TPK+IPGBLK		; Can only free original packet once


;Exit from packet fragmentation

SNDFRX:	SKIPG PKT,FFR+IPGBLK		; Still have first fragment (error)?
	IFSKP.
	  MOVX T1,<PKTELI-NBHDRL>	; Length of internal data
	  XMOVEI T2,NBHDRL(PKT)		; Internal data of fragment
	  MOVE T3,OPKV+IPGBLK		; Original packet
	  ADDI T3,NBHDRL		; At internal data area
	  CALL XBLTA			; Copy internal data back

	  MOVE T1,INPSW			; IP switches
	  TXNN T1,IPS%FR		; Skip if fragment chaining
	  IFSKP.
OPK==:LPCT
	    DO.
	      LOAD OPK,PIPRA,(PKT)	; Next in chain
	      CALL RETPKT
	      SKIPE PKT,OPK		; Another?
		LOOP.			; Yes
	    ENDDO.
PURGE OPK
	  ELSE.
	    MOVX CX,PPROG		; Us
	    ANDCAB CX,PKTFLG(PKT)
	    TXNN CX,PFLGP		; Any others?
	      CALL RETPKT		; No, return it
	  ENDIF.
	ENDIF.

	MOVE T1,INPSW			; IP switches
	TXNE T1,IPS%FR			; Skip if not fragment chaining
	IFSKP.
	  SKIPG PKT,SFR+IPGBLK		; Have second fragment?
	  IFSKP.
	    MOVX CX,PPROG		; Us
	    ANDCAB CX,PKTFLG(PKT)
	    TXNN CX,PFLGP		; Any others?
	      CALL RETPKT		; No, return packet
	  ENDIF.
	ENDIF.

	SKIPE PKT,TPK+IPGBLK		; Release original PKT?
	  CALL RETPKT			; Yes, PPROG was zero

	MOVE T1,ERRC+IPGBLK		; Error code to be returned
	RET

	ENDAV.

	PURGE FHRUT,OPKV,DPT,FFR,FRO,OIN,OOT,SFR,TPK,DCT,LFR;,ERRC,CTYPE

	SUBTTL	Internet Gateway - Packets to Network - Multinet Interface

;SNDPKT(SNDPKN)	Send a packet (clearing queue and flags).

;T1/	Local net (first-hop) destination address
;VNCT/	NCT address ( 0,,NCT  or  loopback NCT,,sending NCT )
;P6/	Address of IPGBLK frame
;PKT/	Entended pointer to packet
;	CALL SNDPKT
;Ret+1:	Always, packet given to driver, or released if error (and PFLGP(s)=0).
;	T1/ Error code (NE%DRP set if packet dropped), or MNTX00 if no error.
;	if ok, T2/ estimated length output queue, msec.

SNDPKN:	SETZM PKTQ(PKT)			; Zero queue
	SETZM PKTFLG(PKT)		; Zero flags

SNDPKT:	STOR T1,PFLAD,(PKT)		; To whom packet is being sent
	STOR VNCT,NBNCT,(PKT)		; Interface(s) to be used
	PUSH P,T1			; Save the host

	SETZRO PICKS,(PKT)		; Clear Internet checksum field
	CALL INTCKS			; Compute Internet checksum
	STOR T1,PICKS,(PKT)		; Enter in header

	LOAD T1,PIPL,(PKT)		; Packet length in bytes
	STOR T1,PTPBZ,(PKT)		; Transport level length
	XMOVEI T1,PKTELI(PKT)		; Where IP data starts
	STOR T1,PTPDT,(PKT)		; Transport level leader
	MOVX T1,NP.IP			; Protocol is IP
	STOR T1,NBPRO,(PKT)

	CALL INTLKB			; Lock down the packet (if needed)
	SETONE PINTL,(PKT)		; Say it has been given to int. level

	MOVX T1,PT%QLN			; Queued for local net
	TDNE T1,MNTRAC			; Want trace?
	  CALL PRNPKI ;(T1,PKT)		; Yes

	POP P,T1			; T1/ Has local net address
	MOVE T2,PKT			; T2/ Points to the packet
	LOAD T3,NBPRO,(T2)		; Get the protocol code	
	CALL NTSNDI			; Send an internet packet
	TXNE T1,NE%DRP			; Packet not sent - Error code in T1
	IFSKP.				; Packet sent, but may have error code
	  CAIN T1,MNTX00		; If not ok, return current error,
	    MOVE T1,ERRC+IPGBLK		; If ok, return earlier error code
	  RET				; Success (maybe with error code)
	ENDIF.				; T2/ est. length output queue, msec.
	MOVEM T1,ERRC+IPGBLK		; Local net level refused packet

	SETONE PICMP,(PKT)		; Giving packet to ICMP
	SETZRO PINTL,(PKT)		; Local level doesn't want it
MNTM5	AOS CELL(INGGY,5,,ING)		; Packets rejected by net, SNDPKT

	CALL INTULK			; Unlock since not queued for PI level

	MOVX T1,PT%KLN			; Refused by local net
	TDNE T1,MNTRAC			; Want trace?
	  CALL PRNPKI ;(T1,PKT)		; Yes

	HRRZ T3,ERRC+IPGBLK		; Get Multinet errror w/o flags+data
	SUBI T3,MNTX00			; Base
	SETZB T1,T2			; Just in case some unexpected code
	CAIG T3,MNTX34-MNTX00		; Known range
	  DMOVE T1,@[			; Get ICMP code,,type, aux info
	  IFIW [EXP 0,0]			;  0 OK
	  IFIW [EXP 0,0]			;  1 ADRINI
	  IFIW [EXP <PP%PTR*1B17+ICM%PP>,4]	;  2 Packet too long
	  IFIW [EXP <PP%PTR*1B17+ICM%PP>,-1]	;  3 Error in header
	  IFIW [EXP ICM%SQ,0]			;  4 Flow control
	  IFIW [EXP 0,0]			;  5 GWYINI
	  IFIW [EXP <DU%HST*1B17+ICM%DU>,0]	;  6 Host down
	  IFIW [EXP <PP%PTR*1B17+ICM%PP>,4*<$PIDH-$PIVER>] ; 7 Host unknown
	  IFIW [EXP 0,0]			; 10 HSTINI
	  IFIW [EXP <DU%NET*1B17+ICM%DU>,0]	; 11 Interface down
	  IFIW [EXP 0,0]			; 12 Invalid agrument
	  IFIW [EXP 0,0]			; 13 Invalid host or network
	  IFIW [EXP 0,0]			; 14 Invalid parameter of bit
	  IFIW [EXP 0,0]			; 15 Invalid value
	  IFIW [EXP <DU%NET*1B17+ICM%DU>,0]	; 16 Net down
	  IFIW [EXP <DU%PRO*1B17+ICM%DU>,0]	; 17 Protocol not available
	  IFIW [EXP <DU%PRO*1B17+ICM%DU>,0]	; 20 Protocol not supported
	  IFIW [EXP <DU%PRO*1B17+ICM%DU>,0]	; 21 Protocol not supp. on net
	  IFIW [EXP <PP%PTR*1B17+ICM%PP>,MINIHS] ; 22 Option problem
	  IFIW [EXP <DU%PRT*1B17+ICM%DU>,0]	; 23 Port unreachable
	  IFIW [EXP ICM%SQ,0]			; 24 Resource shortage
	  IFIW [EXP <DU%SRF*1B17+ICM%DU>,0]	; 25 Route invalid or failed
	  IFIW [EXP 0,0]			; 26 Route to host changed
	  IFIW [EXP 0,0]			; 27 Route to net changed
	  IFIW [EXP ICM%SQ,0]			; 30 Table overflow
	  IFIW [EXP <TE%TTL*1B17+ICM%TE>,0]	; 31 Transmission aborted
	  IFIW [EXP 0,0]			; 32 Transmission acknowledged
	  IFIW [EXP <TE%TTL*1B17+ICM%TE>,0]	; 33 Transmission timeout
	  IFIW [EXP <PP%PTR*1B17+ICM%PP>,-1]	; 34 Unspecified error
		](T3)
	SKIPN T1
	  DMOVE T1,[EXP <PP%PTR*1B17+ICM%PP>,-1] ;   Unspecified error
	CALL ICMERR			; Record the ICMP error & release pkt
	MOVE T1,ERRC+IPGBLK		; Return error
	RET

	PURGE ERRC
	ENDTV.
	SUBTTL	Internet Gateway - Output Completed - Interrupt Level

	RESCD	;ps Interrupt Level Routine

;IPODN	Handle output completion on an IP packet.

;T1/	Extended pointer to top of packet buffer, PTPDT/PTPBZ set

IPODN::
	SETZRO NBQUE,(T1)		; Not chained
	LOAD CX,PLNCR,(T1)		; Have a completion routine, or
	LOAD T2,PIPRA,(T1)		; Have a chain to be sent, or
	IOR T2,CX
	MOVE CX,PKTFLG(T1)		; Get flags
	SKIPN T2
	 TXNE CX,PTRAC			; Want trace?
	IFSKP. 				; No
	  MOVX CX,PINTL			; No longer needed by interrupt level
	  ANDCAB CX,PKTFLG(PKT)		; Update flags & see what's left
	  TXNE CX,PFLGP			; Any other levels need it?
	    RET				; Yes, end of line for output
	  CALL BUFCHK			; No, return buffer. General buffer?
	  IFSKP.			; Yes, may return it at interrupt level
MNTM5       AOS CELL(INPRP,2,,INP)	; Count general packet buffers returned
	    CALLRET RETBUF		; Return general buffer
	  ENDIF.			; Pass IP buffer to process level
	ELSE.
	  MOVX CX,PIPTR			; Tracing code wants this (or PLNCR)
	  IORM CX,PKTFLG(T1)		; (Flag is probably redundant w/PINTL)
	ENDIF.

	MOVE CX,T1			; Copy buffer address
	PIOFF
	EXCH CX,NTFRO+1			; Put on end of completed queue
	SKIPN CX			; Was anything there?
	  XMOVEI CX,NTFRO+0-$NBQUE	; No, this is only queue entry
	STOR T1,NBQUE,(CX)		; Link old last to this buffer
	PION
	RET

	SWAPCD	;ps Back to process level

	SUBTTL	Internet Gateway - Output Completed - Process Level

	RESCD	;ps PIOFF/PION

;INTNRB
;Now at process level - release packet buffers left by PI level (mostly
;empty output packets, but input if IP OFF).  Process trace and/or PLNCR.

;NTFRO,+1/	FIFO queue of output buffers to be returned
;	CALL INTNRB
;Ret+1:	Always

INTNRB:	SAVEAC <VNCT,PKT>
	TRVAR <<IPGBLK,IPGBLN>>		; Transient variables
	ACVAR <NPKTS,NXT,REST>
IFLE <VNCT-REST>,<DEFINE TELL(NCT,VAR)<
		PRINTX ?INTNRB overrunning NCT with local variables VAR>
TELL(\VNCT,\REST)>
	IFN IPLDSW,<STKVAR <NFBSV>>
MNTM5	AOS CELL(INPKT,0,,INP)		; INTNRB calls

	SETZB NXT,NPKTS
	PIOFF	
	EXCH NXT,NTFRO+0		; Get and clear completion queue
	SETZM NTFRO+1
	PION

	IFN IPLDSW,<MOVEM T4,NFBSV> ; save the head of the list if debuging
	DO.				; Process each buffer in chain
	  JUMPE NXT,ENDLP.		; Quit at end of chain
	  MOVE PKT,NXT			; Point at top of buffer

	  MOVX T1,PT%FIN		; Trace completed output packets
	  MOVE T2,PKTFLG(PKT)		; Flags
	  TXNN T2,PTRAC			; Trace packet, or
	   TDNE T1,MNTRAC		; Want trace?
	    CALL PRNPKI ;(T1,PKT)	; Yes

	  LOAD REST,PIPRA,(PKT)		; May have more to send
	  IFN. REST
	    SETZRO PIPRA,(PKT)		; Chain gone
;cwl copy hints
	  ENDIF.

	  LOAD T1,PLNCR,(PKT)		; Have a completion routine?
	  SKIPE T1
	    CALL (T1)			; Yes, call it

	  MOVE PKT,NXT			; Set standard pointer to packet
	  LOAD NXT,NBQUE,(NXT)		; Pointer to rest of list
	  CALL INTRBF			; Release packet buffer

	  IFN. REST
	    MOVE PKT,REST		; Next packet in chain
	    LOAD T1,PFLAD,(PKT)		; Original first hop
	    LOAD VNCT,NBNCT,(PKT)	; Use original NCT
	    CALL SNDPKT ;(T1,VNCT,P6,PKT) ; Send next item
	  ENDIF.

MNTM5	  AOS NPKTS			; Buffers processed by INTNRB
	  LOOP.
	ENDDO.

MNTM5	SKIPN NPKTS			; Any packets processed?
MNTM5	  AOS CELL(INPKT,1,,INP)	; Useless calls to INTNRB
MNTM5<	ADDM NPKTS,CELL(INPKT,2,,INP)>	; Packets processed by INTNRB
	RET

;	ENDTV.				; Leave IPGBLK definition for IPOPT
	ENDAV.

	SWAPCD	;ps Back to process level

;INTRBF	Release a packet to Internet free area.

;PKT/	Extended pointer to packet buffer
;Ret+1:	Always.

INTRBF:	CALL INTBCK ;(PKT)		; Internet packet?
	 TRNA				; No
	  CALL INTULK			; Yes, unlock the packet

	MOVX CX,PINTL+PIPTR		; No longer needed by interrupt level
	ANDCAB CX,PKTFLG(PKT)		; Update flags & see what's left
	TXNN CX,PFLGP			; Any other levels need it?
	  CALL RETPKT ;(PKT)		; No, release packet buffer
	RET				; Yes

	RESCD	;ps

;RETPKT	Release packet storage to proper free storage area.

;PKT/	Extended pointer to packet buffer
;	CALL RETPKT
;Ret+1:	Always.  Packet pointer invalid.

RETPKT::
MNTM5	AOS CELL(INPRP,0,,INP)		; RETPKT calls

	MOVE T1,PKT			; What to return
	CALL BUFCHK ;(T1)		; General buffer?
	IFSKP.				; Yes
MNTM5     AOS CELL(INPRP,2,,INP)	; Count general packet buffers returned
	  CALLRET RETBUF ;(T1)
	ENDIF.
	CALL INTBCK ;(PKT)		; Internet buffer?
	 TRNA				; No
	  CALLRET RETBLK ;(T1)		; Yes
	BUG.(CHK,INTUKB,IPIPIP,SOFT,<Unidentifiable packet buffer>,
<<T1,ADR>>,<
Cause:	An attempt is being made to release an IP packet buffer but the
	buffer's manager cannot be identified.  The address is probably
	bad.

Action:	Examine T1, the address, and where it is pointing.  Proceeding
	will cause the buffer to be lost.  If the problem reoccurs,
	something is going wrong; it might be advisable to notify users
	and reload the system, getting a dump for later analysis.

Data:	Address of purported buffer to be returned.

>)
MNTM5	AOS CELL(INPRP,1,,INP)		; Bad buffers given to RETPKT
	RET

	SWAPCD	;ps Back to process level	

	SUBTTL	Memory Management

;NOTE: whenever IP is changed to use general buffers exclusivly the
;following several routines can be removed.  But general buffers will
;have to support more that 777-NBHDRL word buffers first.



	RESCD	;ps Called from Interrupt Level


;INTBCK	Check whether a packet pointed to by PKT is from the internet pool.

;PKT/	Extended packet buffer
;	CALL INTBCK
;Ret+1:	  Buffer not from IP space.
;Ret+2: Buffer is from IP space.

INTBCK::
	CAML PKT,[INTFRE]
	 CAMLE PKT,[INTFRZ]
	  RET				; Not IP buffer
	RETSKP				; IP storage area


;INTLKB	Lock an Internet packet in memory to prevent page faults.

;PKT/	Extended pointer to packet, PTPDT/PTPBZ set
;	CALL INTLKB
;Ret+1:	Always.

INTLKB:	CALL INTBCK ;(PKT)		; Make sure from IP space
	  RET				; If not, should already be locked

	ACVAR <PKTLIM,PLC>

MNTM5	AOS CELL(INGLU,0,,ING)		; Count calls to INTLKB
	LOAD PKTLIM,PTPBZ,(PKT)		; Length at transport level
	ADDI PKTLIM,3			; Round up to
	LSH PKTLIM,-2			; Words
	PNTLDR CX,PTPDT,(PKT)		; Address of transport level leader
	ADD PKTLIM,CX			; End of transport data
	SUBI PKTLIM,1			; Full size of buffer-1
	IORI PKTLIM,PGSIZ-1		; Round up to top of page

	MOVE T1,PKT			; Start in T1
	SETZ PLC,			; Clear pages locked count
	DO.
	  PUSH P,T1			; Save core address
	  CALL MLKMA			; Lock monitor address in core
	  POP P,T1			; Get core address back
	  AOS PLC			; Count the locked page
MNTM5	  AOS CELL(INGLU,1,,ING)	; Count pages locked by INTLKB
	  ADDI T1,PGSIZ			; Move on to next page
	  CAMG T1,PKTLIM		; Done all of packet?
	    LOOP.			; No, do next page
	ENDDO.
	STOR PLC,PLPLC,(PKT)		; Save the page lock count
	SETONE PKLIM,(PKT)		; Packet is locked
	RET

	ENDAV.

	RESCD	;ps


;INTULK	Unlock an Internet packet from memory.

;PKT/	Pointer to packet
;	CALL INTULK
;Ret+1:	Always.  T1 preserved.

INTULK:	CALL INTBCK ;(PKT)		; Internet buffer?
	  RET				; No, so do nothing

MNTM5	AOS CELL(INGLU,2,,ING)		; INTULK calls
	MOVE CX,PKTFLG(PKT)		; Get flags
	TXNE CX,PKLIM			; If not locked or
	 TXNE CX,PKDUL			; Not suppose to unlock
MNTM5	  AOSA CELL(INGLU,4,,ING)	; Times INTULK found PKUDL or no PKLIM
MNTM5	   CAIA
	    RET				; Give up now

	ACVAR <PLC>

	LOAD PLC,PLPLC,(PKT)		; Get pages locked count
	SETZRO PKLIM,(PKT)		; Unlocking packet
	MOVE T1,PKT			; Start in T1
	DO.
	  PUSH P,T1			; Save core address
	  CALL MULKSP			; Unlock monitor address
	  POP P,T1			; Get core address back
MNTM5	  AOS CELL(INGLU,3,,ING)	; Count pages unlocked by INTULK
	  ADDI T1,PGSIZ			; Move on to next page
	  SOJG PLC,TOP.			; Loop if more pages
	ENDDO.
	RET

	ENDAV.

	SUBTTL Lock Handling - Event Tracking

; IP Buffer Lock Manipulation Debugging code and storage

IFN IPLDSW,<

;	Queue event ring buffer entries have the following format

	.IPLFX==0		; word 0/ 525252,,FORKX
	.IPLBA==1		; word 1/ Buffer Address
	.IPLPC==2		; work 2/ Calling PC
	.IPLSZ==3		; word 3/ Buffer Size
	.IPLHP==4		; word 4/ HP time value
	IPLLEN==.IPLHP-.IPLFX+1 ; Length of ring entry
	IPLRNN==^D500		; number of entries in ring buffer

RS IPLRNG,<IPLRNN*IPLLEN>	; QUEUE EVENT RING BUFFER
RS IPLADR,1			; CURRENT RING BUFFER ADDRESS

IPLTRK:				; TRACK IP QUEUE EVENTS
	PUSH P,T2		; SAVE T2
	PUSH P,T3		; SAVE T3
	PUSH P,T4		; SAVE T4
	SETO T2,		; ASSUME PI IS ON
	CONSO PI,PIPION		; IS PI ON?
	 TDZA T2,T2		; NO SO TURN OFF FLAG
          PIOFF			; YES SO MAKE THE MACHINE MINE
	MOVE T3,IPLADR		; GET CURRENT RING BUFFER POINTER
	ADDI T3,IPLRNG		; OFFSET BY BASE ADDRESS
	MOVE T4,FORKX		; GET FORKX
	HRLI T4,525252		; GET MAGIC NUMBER
	MOVEM T4,.IPLFX(T3)	; SAVE FORKX
	MOVEM T1,.IPLBA(T3)	; SAVE THE BUFFER ADDRESS
	LOAD T4,NBBSZ,(T1)	; GET THE SIZE
	MOVEM T4,.IPLSZ(T3)	; SAVE THE SIZE
	MOVE T4,-6(P)		; GET THE CALLING PC
	MOVEM T4,.IPLPC(T3)	; SAVE THE PC
	PUSH P,T1		; SAVE T1
	PUSH P,T2		; SAVE T2
	JSP T4,MTIME		; GET THE HPTIM
	MOVE T4,T1		; GET TIME IN PROPER PLACE
	POP P,T2		; RESTORE T2
	POP P,T1		; RESTORE T1
	MOVEM T4,.IPLHP(T3)	; SAVE THE HPTIM
	MOVE T3,IPLADR		; GET THE RING ADDRESS AGAIN
	ADDI T3,IPLLEN		; BUMP THE RING POINTER
	CAIL T3,<IPLLEN*IPLRNN>	; SHOULD THE POINTER LOOP AROUND?
	 SETZ T3,		; YES SO MAKE IT LOOP
	MOVEM T3,IPLADR		; SAVE THE NEW RING POINTER
	SKIPE T2		; SHOULD WE GO PION?
         PION			; YES SO GIVE BACK THE MACHINE
	POP P,T4		; RESTORE ACS
	POP P,T3
	POP P,T2
	RET			; AND RETURN
>				; end of IPLDSW
	SWAPCD	;ps Back to process level

	SUBTTL	Internet Option Routines

;IPOPT
;Process IP Options - Phase 1, before routing.

;In IPGBLK:
;ERRC==0	; Error code to be returned, if any
;FHRUT==1	; First-hop destination (route)
CTYPE==2	; 0 if receiving, -1 if sending
SRP==3		; Pointer before our sending interface's address, or 0
SRC==4		; Route option code (LSROPT or SSROPT) [temp:see RRTC]
RRTP==5		; Pointer before our sending interface's address, or 0
RRTC==6		; Current byte number for RRTOPT parameter problem message
CURBYT==7	; Current byte number for parameter problem message
OPTP==10	; Working pointer to next option byte
GARB==11;,2	; Dummy pointer/count pair

;PKT/		(Ext) pointer to packet
;	CALL IPOPT
;Ret+1:	  Option error, T2 has code
;Ret+2:	OK

IPOPT:	SETZM SRP+IPGBLK		; No Source Route
	SETOM SRC+IPGBLK		; Invaild option code
	SETZM RRTP+IPGBLK		; No Record Route
	SETZM CURBYT+IPGBLK		; No Parameter problem error pointer
	LOAD T2,PIDO,(PKT)		; Get size of IP header
	LSH T2,2			; In bytes
	SUBI T2,MINIHS			; Option length, bytes
	JUMPLE T2,RSKP			; Good, No options (CURBYT is 0)
	ACVAR <OPLB,REMB>
	MOVEM T2,REMB			; # Option bytes to process
MNTM5	SKIPE CTYPE+IPGBLK		; Which type?
MNTM5	 AOSA CELL(INGOS,1,,ING)	; Count packets being sent with options
MNTM5	  AOS CELL(INGOR,1,,ING)	; Count packets received with options
	MOVX T2,MINIHS			; Byte offset to options
	MOVEM T2,CURBYT+IPGBLK		; First option byte
	AOS CURBYT+IPGBLK		; Start with one??
	ADJBP T2,<[POINT 8,PKTELI(PKT),7]>	; From IP header
	MOVEM T2,OPTP+IPGBLK		; Save pointer
					; Process next option from header
NXTOP:	MOVE T1,OPTP+IPGBLK		; Pointer at option for subroutines
	MOVX OPLB,1			; Assume single byte option length
	LDB T4,OPTP+IPGBLK		; Get option
	TRZ T4,CPYOPT			; Drop copy flag
	MOVE T2,CTYPE+IPGBLK		; 0:Receive/-1:Send
	CALL IPOPHS			; Histogram them
	SETZ T2,			; No parameter problems

	CAIN T4,<ENDOPT&<^-CPYOPT>>	; END of options?
	  JRST DONOP			; Yes, quit
	CAIN T4,<NOPOPT&<^-CPYOPT>>	; NOP?
	  JRST FINOP			; Yes, on to next

					; Option with length
	MOVX T2,1			; Parameter problem - option length
	CAIGE REMB,2			; Enough remaining for length?
	  JRST DONOP			; No, error
	ILDB OPLB,OPTP+IPGBLK		; Get length
	CAMLE OPLB,REMB			; Exceed remaining header length?
	  JRST DONOP			; Yes, error
	MOVE T2,CURBYT+IPGBLK		; Count at option (useful parameter)
	XMOVEI T3,SRP+IPGBLK
	CAIE T4,<LSROPT&<^-CPYOPT>>	; Lose Source Route?
	 CAIN T4,<SSROPT&<^-CPYOPT>>	; Strict Source Route?
	  CALL RUTOP
	JUMPE T3,FINOP			; Found it, T2 may indicate error
	XMOVEI T3,RRTP+IPGBLK
	CAIN T4,<RRTOPT&<^-CPYOPT>>	; Record Route?
	  CALL RUTOP
	JUMPE T3,FINOP			; Found it, T2 may indicate error
	XMOVEI T3,GARB+IPGBLK
	CAIN T4,<TSPOPT&<^-CPYOPT>>	; Time Stamp?
	  CALL DOTSP			; Yes, process it now (save T1)
	JUMPE T3,FINOP			; Found it, T2 may indicate error
					; Uninteresting or unknown option
	SETZ T2,			; No parameter problem
FINOP:	JUMPN T2,DONOP			; Parameter problem
	SUB REMB,OPLB			; Bytes remaining in header
	ADDM OPLB,CURBYT+IPGBLK		; Count for next option
	ADJBP OPLB,T1			; Point at next option
	MOVEM OPLB,OPTP+IPGBLK		; Reset pointer
	JUMPG REMB,NXTOP		; Loop if more
DONOP:	TLNE T2,<-1>			; Non-zero left half is <class,,error>
	  SETZM CURBYT+IPGBLK		; Error code will replace count
	ADDM T2,CURBYT+IPGBLK		; Done processing options
	SKIPN T2			; Any errors?
	  SETZM CURBYT+IPGBLK		; No errors
	MOVE T2,CURBYT+IPGBLK		; Return code
	SKIPN T2			; Look for error in options
	  AOS (P)			; All ok, skip return
	RET

	ENDAV.
	ENDTV.
	PURGE ERRC,FHRUT,CTYPE,SRP,SRC,RRTP,RRTC,CURBYT,OPTP,GARB

;RUTOP
;Routing Options

;T1/	Pointer at Option type code
;T2/	Count of Option type code byte
;T3/	Address for pointer & count
;T4/	Option code w/o CPYOPT
;	CALL RUTOP
;Ret+1:	Always,  Parameter problem if T2 non-zero (relative offset, or error)
;	T1/ unchanged, T3/0


RUTOP:	SKIPE (T3)			; Already have this option?
	  JRST RUTZ			; Yes, error
	DMOVEM T1,(T3)			; No, Save pointer and curbyt
	ACVAR <OPT,OPTP,OPTL,CPTR>
	PUSH P,T1
	MOVEM T1,OPTP			; Set working pointer
	MOVEM T4,OPT			; Masked option
	ILDB OPTL,OPTP			; Option length
	MOVX T2,1			; In case error
	CAIGE OPTL,7			; Header + one id
	  JRST RUTY			; Lose
	CAIN OPT,<RRTOPT&<^-CPYOPT>>	; Record route?
	  JRST RUTEX			; Yes, skip following
	JN PLCLO,(PKT),RUTEX		; Jump if we generated packet
	LOAD T1,PIDH,(PKT)		; Immediate destination
	CALL LCLHST			; To one of us?
	 CAIA				; No
	  JRST RUTEX			; Yes, go look for next hop

;We  received a packet for which we are not the destination specified
;in the packet destination field. This is a route failure for  Strict
;Source Routes, but is OK for Loose Routes.

	CAIE OPT,<SSROPT&<^-CPYOPT>>	; Strict route?
	  JRST RUTK			; No. Ignore route option,
					; Use full routing
	MOVX T2,<DU%SRF,,ICM%DU>	; Yes, Different error message
	JRST RUTY			; For route failure

;We  recieved  a packet for which we are the destination specified in
;the packet destination field.

RUTEX:

; Check if the Route option has been exhausted or not.

	ILDB CPTR,OPTP			; Current pointer offset
	CAIG OPTL,(CPTR)		; Already full?
	  JRST RUTK			; Yes, ignore option, send to dest
	MOVX T2,2			; Parameter problem with pointer
	CAIGE OPTL,4-1(CPTR)		; Enough room for another entry?
	  JRST RUTY			; No, fail
	MOVEI T2,-4(CPTR)		; Bytes to before our slot
	ADDI CPTR,4			; Update pointer
	DPB CPTR,OPTP			; In option header
	ADDM T2,1(T3)			; Updated count in case error
	ADJBP T2,OPTP			; Pointer before our sending
	MOVEM T2,OPTP			; Address slot
	MOVEM T2,(T3)			; To be filled in later
	CAIN OPT,<RRTOPT&<^-CPYOPT>>	; Record route option?
	  JRST RUTX			; Yes, don't update packet destination

; Extract next destination from route and put it in packet header

	MOVX T1,17			; Unused bits
	 ILDB T2,OPTP			; Get id byte
	 LSH T2,^D<36-8>		; Left justify
	 LSHC T1,^D8			; & pack
	 JUMPGE T1,.-3			; 4 bytes
	STOR T1,PIDH,(PKT)		; Next destination for packet
	MOVEM OPT,1(T3)			; Save Strict/Loose code
	JRST RUTX			; Done for now, no errors
RUTK:	SETZM (T3)			; Ignore this option
	SETZM 1(T3)
RUTX:	SETZ T2,			; No errors
RUTY:	POP P,T1			; Error, T2 has <0,,relative offset>,
	SETZ T3,			; Or <class,,error>, Option processed
	RET

	ENDAV.

; Duplicate route option is an error

RUTZ:	MOVEM T2,1(T3)			; Error pointer
	SETZ T3,			; Option processed
	RET


;INSHST
;Insert out-going host id in packet.

; Second Phase 2 of route option
;T3/	Host id to be inserted
;T4/	Pointer before slot
;	CALL INSHST
;Ret+1:	Always, T1,T2 preserved

INSHST:	ROT T3,^D<4+8>			; First byte right justified
	IDPB T3,T4			; Pack them in
	ROT T3,^D8
	IDPB T3,T4
	ROT T3,^D8
	IDPB T3,T4
	ROT T3,^D8
	IDPB T3,T4
	RET

;DOSTP	Time Stamp Option.

;T1/	Pointer at TSPOPT
;	CALL DOTSP
;Ret+1:	Always,  Parameter problem if T2 non-zero (relative offset)
;	T1/ unchanged, T3/0

DOTSP:	SAVEAC <T1>
	ACVAR <OPTP,OPTL,CPTR,SAVPTR>
	MOVE OPTP,T1			; Set working pointer
	ILDB OPTL,OPTP			; Option length
	MOVX T2,1			; In case error
	CAIGE OPTL,8			; Header + one timestamp
	  JRST DOTSY			; Lose
	ILDB CPTR,OPTP			; Current pointer offset
	MOVEM OPTP,SAVPTR		; Save length for later update
	CAIG OPTL,(CPTR)		; Already full?
	  JRST DOTSF			; Yes
	SUBI CPTR,1+1			; Begins at 1 not 0 & ILDB not LDB
	ILDB T3,OPTP			; Get Overflow/Type
	ANDI T3,17			; Type field
					; 4-byte options
	MOVX T4,4			; Assumed required length
	CAIGE OPTL,4(CPTR)		; Enough room for us?
	  JRST DOTSY			; No, parameter problem
	CAIN T3,0			; Is it Type 0?
	  JRST DOTS0			; Yes
					; 8-byte options
	MOVX T4,8			; Required length
	CAIGE OPTL,8(CPTR)		; Enough room for us?
	  JRST DOTSY			; No, parameter problem
	CAIN T3,1			; Is it Type 1?
	  JRST DOTS1			; Yes
	CAIN T3,3			; Is it Type 3?
	  JRST DOTS3			; Yes

; Unknown type - may be protocol extension we don't know about,
; so just skip whole option

	JRST DOTSX

DOTS3:	; Type 3: Add time if we are next Id

	ADJBP CPTR,T1			; Point before our slot
	MOVX T1,17			; Used to count bytes
	DO.
	  ILDB T2,CPTR			; Get id byte
	  LSH T2,^D<36-8>		; Left justify
	  LSHC T1,^D8			; & pack
	  JUMPGE T1,TOP.		; 4 bytes
	ENDDO.
	TXZ T1,<740000,,0>		; Mask to 32 bits
	CALL LCLHST			; Is it one of us?
	  JRST DOTSX			; No, skip option
	JRST DOTST			; Yes, Go add time

DOTS1:	; Type 1: Add our Id and current time since midnight to list

	ADJBP CPTR,T1			; Point before our slot
;cwl bstadr? pish is foreign, pidh is local initial?
	XMOVEI T1,NLHOST
	CALL FHPADR
	MOVE T2,T1			; Our default Id
	LSH T2,4			; Unused bits
	MOVX T1,17			; Unused bits in word
	DO.
	  LSHC T1,^D8			; Next byte
	  IDPB T1,CPTR			; Into header
	  JUMPG T1,TOP.
	ENDDO.
	JRST DOTST

DOTS0:	; Type 0: Add current time since midnight to list

	ADJBP CPTR,T1			; Point before our slot
DOTST:	CALL INETUT			; Get current msec since midnight
	LSHC T1,^D<-32>			; Left justify into T2
	MOVX T1,17			; Unused bits in word
	DO.
	  LSHC T1,^D8			; Next byte
	  IDPB T1,CPTR			; Into header
	  JUMPG T1,TOP.
	ENDDO.
DOTSU:	LDB T1,SAVPTR			; Get old pointer
	ADD T1,T4			; Plus length we used
	DPB T1,SAVPTR			; Back into header
	JRST DOTSX			; All done without error

; Full

DOTSF:	ILDB T1,SAVPTR			; Get Ovfl/Type
	ADDI T1,20			; Bump Ovfl
	MOVX T2,3			; Parameter problem, Ovfl
	CAIL T1,400			; Field too large?
	  JRST DOTSY			; Yes, lose
	DPB T1,SAVPTR			; Update Ovfl
DOTSX:	SETZ T2,			; No error (parameter problem offset)
DOTSY:					; Error exit with T2 set
	SETZ T3,
	RET

	ENDAV.


;INETUT
;Get universal time since midnight.

;	CALL INETUT
;Ret+1:	Always, T1 contains 32-bit time since midnight

INETUT:	SAVEAC <T2>
MNTM5	AOS CELL(INPAA,1,,INP)		; INETUT calls
	CALL LGTAD			; Get current day,,fraction
	HRRZS T1			; Just fraction
	MUL T1,[^D<24*60*60*1000>]	; To msec since midnight
	ASHC T1,^D<18-1>		; Right justify into T1
	RET


;IPOPHS
;Histogram options

;T2/	0:Receive/-1:Send
;T4/	Option code w/o CPYOPT
;	CALL IPOPHS
;Preserves all

IPOPHS:	PUSH P,T2
	PUSH P,T1

MNTM5<	MOVEI T1,CELL(INGOR,0,,ING)>	; IP options received
MNTM5	SKIPE T2			; Correct?
MNTM5<	  MOVEI T1,CELL(INGOS,0,,ING)>	; IP options sent
MNTM5	INHIST(,,T4,T1,T2)		; Histogram IP options (CELL(INGOr/s)

	POP P,T1
	POP P,T2
	RET

	SUBTTL	Gateway Table Accessing and Updating Routines

COMMENT !

Routing to an Internet address is performed by first checking the ROUTE
tables to see if a route to the target Internet address is already known.
If an entry is found, the corresponding route (first-hop address) is
returned.  If an entry for the address is not found, the table is examined
for a network entry corresponding to the Internet address.  If the net
entry is found, the corresponding route (first-hop address) is returned.
If no net entry exists, the gateway table is searched for an entry which
should be able to reach the desired network.  If a gateway is found, a net
entry is added to the routing table specifying the gateway as a route, and
the gateway's address is returned as the route.  If no gateway capable of
reaching the desired net is found, a routing gateway is selected and entered
into the routing table;  if it is not the "correct" gateway, an ICMP
redirect message should be received which will correct the entry in the
routing table.  Other ICMP redirect messages may also add or change entries
in the routing table.  ICMP destination unreachable messages may cause
entries to be removed.


Data bases

NETHSZ=n		; Entries in table
NETHES=1		; Size of an entry

NXTGWY/	-# GW,,i	; Where to begin gateway search, 0 .le. i .lt. MAXGWY

NETHTB[NETHSZ*NETHES]		< 0  Freed (keep searching)
NETHTB-NETHTB(a=NETHSH(net))	= 0  Free  (stop searching)
				> 0  Internet Address of Net or Host
;<macth brackets
If NETHTB > 0, then

NETGWY[NETHSZ*NETHES]		< 0  Error
NETGWY-NETHTB(a=NETHSH(net))	= 0  Entry deleted
				> 0  First-hop Internet Address

NETIFC[NETHSZ*NETHES]		< 0  Error
NETIFC-NETHTB(a=NETHSH(net))	= 0  Unused
				> 0  0,,NCT to be used for first-hop address

NETWHO

NETWHN

!

	SUBTTL	Internet Routing Routines

;BSTADR
;See if a foreign host is using the best address to reach us.  Can also
;be used to find the best local address to use on a new connection
;(by leaving T2/ 0).

;T1/	Foreign address
;T2/	Local address
;	CALL BSTADR
;Ret+1:   If local address is optimal.
;Ret+2: T2 has better local address.
;T1/	Error code, e.g. foreign address was recently reported down.

BSTADR::
	SAVEAC <VNCT>			; Save NCT AC
	ACVAR <FGN,LCL>
	MOVE FGN,T1			; Save foreign address
	MOVE LCL,T2

	NETNUM T1,FGN			; Get the net number
	CALL NETLUK			; Have we an (up) interface there?
	SKIPLE VNCT,T1			; 0 - None, 0,,NCT - Up, 1B0+NCT - Down
	IFSKP.				; No
	  MOVE T1,FGN			; Destination address
	  CALL GWYLUK			; Try to find the gateway we'll use
	    JFCL			; Might be down
	  IFSKP.
jfcl;cwl been down
	  ENDIF.
	  IFN. T1			; Found one
	    SKIPG T2,NTLADR(VNCT)	; Get local address on that interface
	    ANSKP.			; Beware loopback (& logical hosts)
					; All set, have a local address
	  ELSE.
	    XMOVEI T1,NLHOST
	    CALL FHPADR			; Find the best address that is up
	    MOVE T2,T1
	  ENDIF.
	ELSE.
	  MOVE T2,NTLADR(VNCT)		; Get connected net address
	ENDIF.
	MOVX T1,MNTX00

;Now T2 holds the 'best' address to use

	CAME T2,LCL			; That the one we're using?
	  AOS (P)			; No, skip return
	RET				; Yes, no skip return

	ENDAV.

;GWYLUK
;Find the first-hop address & NCT for given destination.
;Called by BSTADR and SNDGAT/2.

;T1/	Destination Internet address.
;	CALL GWYLUK
;Ret+1:	Destination might not be up.
;Ret+2:	Destination persumed to be up.
;T1/	0 if no path to the destination, or first-hop destination address
;	(might be original argument or a gateway).
;VNCT/	0 if no path to the destination, or [1B0]0,,NCT to use for first-hop,
;	or NCTq,,NCTn where NCTn has "net" parameters but NCTq (loopback NCT)
;	should be used to send the packet (in NCT when NTSNDI is called).

GWYLUK::
MNTM5	AOS CELL(INGGL,0,,ING)		; Count calls to GWYLUK

;NB: LCLHST and NETHSH preserve T1.

;Special processing associated with host addresses - local or special route.

	MOVE T2,T1			; Get argument for NETHSH
	TXNN T1,IA%NET			; If Internet address, net byte not 0
	IFSKP.				; Given host address
;cwl disabling switch?
	  CALL LCLHST ;(T* preserved)	; Is it a local host address?
	  IFSKP.			; Yes
					; NCT addresses must have IFIW bit set
					; so double NCT will work. Check it.
	    MOVE VNCT,LUPNCT
	    IFG. VNCT			; Have loopback NCT, and
	      TRNE VNCT,400000		; 1B0 will mask NCT in left half
	       SKIPL NTORDY(VNCT)	; Loopback ready to go?
	      ANSKP.			; Yes
	        NETNUM T2,T2		; Get local net number
	        CALL NETHSH		; Find sending interface (IP options!)
	          JRST GWYNIT		; Very unusual
	        SKIPN VNCT,NETIFC-NETHTB(T2) ; 0,,.NCTi, or 0
	          JRST GWYNIT		; Deleted (or not yet filled in)
	        SKIPE T2,NETGWY-NETHTB(T2) ; Expect 0 (argument is first-hop)
	          MOVE T1,T2		; Return first hop??
	        HRL VNCT,LUPNCT		; Double NCT, with IFIW (1B0) set
	        JRST GWYLUG		; Go count success
	    ENDIF.			; Loopback useable
	  ENDIF.			; Local host address
					; Check for special host entry
	  TXZ T2,NA%FLG			; Do not add host address if not there
	  CALL NETHSH ;(T2:T2, killing 3,4) ; Look for special host route
	   TRNA				; None, go process net
	    JRST GWYLUF			; Found special route, join below
	  NETNUM T2,T1			; Look for route to net
	ENDIF.				; Given host address

;Look for route to destination net

	TXO T2,NA%FLG			; Add route to net if not there
	CALL NETHSH ;(T2:T2, killing 3,4) ; Look for route to net
	  JRST GWYNIT			; No route for net, either

;Found entry (implies that haven't recently heard it is down)

GWYLUF:	HRRZ VNCT,NETIFC-NETHTB(T2)	; 0,,.NCTi, or 0
	JUMPE VNCT,GWYNIT		; Deleted (or not yet filled in)
	SKIPE T2,NETGWY-NETHTB(T2)	; Get first hop, or 0 (return argument)
	  MOVE T1,T2			; Return first hop
GWYLUG:
MNTM5	AOS CELL(INGGL,4,,ING)		; Count routes from GWYLUK
	RETSKP


;There is no entry in the network routing tables for destination net.
;T1/ destination,  T2/ net hash index of empty slot in routing tables.

GWYNIT:	PUSH P,T2			; Save routing table index
	PUSH P,T1			; Save destination (** used below)
	PUSH P,[5]			; Failure/retry limit, seconds
	DO.
	  MOVE T1,-1(P)			; Get destination address
MNTM5	  AOS CELL(INGGL,1,,ING)	; Count FNDGWY calls by GWYLUK
	  CALL FNDGWY			; Find a gateway
	  JUMPE T1,GWYNIY		; None, means "down"
	  MOVE T4,T1			; Save gateway address
	  NETNUM T1,T4			; Net number into T1
	  CALL NETLUK ;(T3,4 saved)	; Try to find it
	  IFG. T1			; Useable interface
	    ADJSP P,-2			; Drop failure counter/destination
	    POP P,T2			; Restore NETHTB address
	    MOVEM T4,NETGWY-NETHTB(T2)	; Place gateway/host into table
	    HRRZM T1,NETIFC-NETHTB(T2)	; Save interface's NCT address
	    HRRZ VNCT,T1		; Return 0,,NCT and
	    MOVE T1,T4			; Gateway address
	    RET				; Don't skip here, caller may want
	  ENDIF.			; to check HSTSTS
					; Not connected or down
MNTM5	  AOS CELL(INGGL,2,,ING)	; Count unconnected gwy from FNDGWY
	  MOVX T1,^D1000		; Wait a sec for things to stabalize
	  DISMS%			; Bad way to handle the problem
	  SOSLE (P)			; Try again?
	    LOOP.			; Yes
	ENDDO.

	BUG.(INF,GWYFNB,IPIPIP,SOFT,
<FNDGWY returned unconnected gateway - host/gw>,<<-1(P),D>,<T4,D>>,<

Cause:	The routine for finding a gateway to a network returned an
	address which uses a non-existent or disabled local interface.

Action:	This can happen legitimately due to race conditions when
	an interface goes down. The system should recover if this
	is the case. If the bug happens consistently when
	interfaces are stable look for another problem, e.g. a
	bad gateway table (SYSTEM:INTERNET.GATEWAYS).

Data:	Destination host internet address, gateway internet address.

>)

GWYNIY:	ADJSP P,-3			; Clean up stack
MNTM5	AOS CELL(INGGL,3,,ING)		; Count FNDGWY failures in GWYLUK
	RET				; Return unsucessfully
	ENDAV.

;FNDGWY
;Find a gateway which can relay to a given Internet address.
;Called by GWYLUK/GWYNIT.

;T1/	Destination Internet address.
;	CALL FNDGWY
;Ret+1: Always.
;T1/	Internet address of a gateway to the argument's net (if no directly
;	connected gateway can be found, then a PRIME gateway is selected).
;	If no gateways or interfaces are up, returns 0.
;Kills	T2,T3,T4

FNDGWY::
	ACVAR <GWT,I,DEFGW,DEFTY>
	NETNUM T2,T1			; Get the network number
	SETZ T1,			; No way there
	HLLZ I,GWCNT0			; Number of gateways
	JUMPGE I,R			; No gateways!

	HRR I,NXTGWY			; AOBJN starting at i-th entry
	SETZB DEFGW,DEFTY		; No default gateway yet
	PUSH P,T2			; Save net number for compares
FNDGWL:	DO.				; Scan all gateways
	  HRRZ GWT,I			; Get offset
	  ADD GWT,GWTAB			; Point into table
	  SKIPE GWT,(GWT)		; Get entry (if any)
	  IFSKP.
	    HLLZS I			; Slot is empty, back to top
	    LOOP.
	  ENDIF.

;cwl actually, check if recently told it is down, otherwise try it
	  IFQN. GWUP,(GWT) 		; Gateway is up
	    MOVE CX,.GWILS(GWT)		; Gateway's address on local net
	    NETNUM T1,CX		; Extract it's net number
	    CALL NETCHK			; Is interface to that net up?
	  ANSKP.			; Both gateway and interface are UP

	    DO.				; Check if this is a better candidate
	      CAIN DEFTY,GW%PRM		; Is our default a prime gateway?
	        EXIT.			; Stop checking
	      LOAD T3,GWTYP,(GWT)	; Get type
	      CAIN T3,GW%PRM		; PRIME?
	      IFSKP.			; Else set default to prime
	        CAIN DEFTY,GW%DUM	; If default is dumb
	          EXIT.			; Stop checking
	        CAIN T3,GW%DUM		; If current is dumb and default isn't
	        ANSKP.			; Else set default to dumb
	          CAIN DEFTY,GW%AUP	; If default is always up..
	            EXIT.		; Stop checking
	          CAIN T3,GW%AUP	; If current is aup and default isn't
	          ANSKP.		; Else set default to always up
	            CAIN DEFTY,GW%HST	; If default is host
	              EXIT.		; Stop checking
	            ANSKP.		; Else set default to host
	      ELSE.
	        MOVE DEFGW,.GWILS(GWT)	; Get the accessible address
	        MOVE DEFTY,T3		; Remember type of gateway
	      ENDIF.
	    ENDDO.

	    LOAD T3,GWICT,(GWT)		; Get the interface count
	    XMOVEI T4,.GWILS(GWT)	; Point to interface Internet addresses
FNDGW5:	    DO.
	      MOVE T1,(T4)		; Get Internet address
	      NETNUM T1,T1		; Get it's net number
	      CAME T1,(P)		; Desired network?
	      IFSKP.
	        MOVE DEFGW,.GWILS(GWT)	; Yes, get the accessible address
	        SETZ I,			; Stop searching gateways
	        EXIT.			; Stop searching gateway address list
	      ENDIF.
	      AOS T4			; Point to the next entry
	      SOJG T3,TOP.		; And loop through this gateway
	    ENDDO.
	  ENDIF.
	  AOBJN I,TOP.			; Back if another candidate
	ENDDO.

	MOVE T1,DEFGW			; Get default gateway (0 if none)
	MOVE I,NXTGWY			; Start with next next time
	AOBJN I,.+2
	  HLLZ I,GWCNT0			; Back to top
	MOVEM I,NXTGWY
	POP P,(P)			; Drop destination net
	RET				; No gateway found
	ENDAV.

	SUBTTL	Internet Host/Net Status Update Routines

;INTDWN
;Signal that an interface has gone down.

;VNCT/	Address of NCT for the interface.
;	CALL INTDWN
;Ret+1:	Always.

INTDWN::
	SAVET
MNTM5	AOS CELL(INGAA,1,,ING)		; INTDWN calls

	MOVE T1,NTLADR(VNCT)		; We are down
	MOVE T2,T1			; We are saying so
	MOVX T3,RTCRLN			; We are very reliable
	TXO T3,1B0			; This is INTDWN
	MOVE T4,TODCLK			; When it went down
	MOVX CX,PT%IDN
	CALL MNTRAP			; Record event
	CALL HSTDWN			; Update tables
	  RET				; Already knew it

	RET


;HSTDWN
;Mark an Internet address down.  Paths using this address are erased.

;T1/	Internet address.
;T2/	Reporting entity.
;T3/	Credibility; 1B0 set if INTDWN call
;T4/	TODCLK, or 0 if now
;	CALL HSTDWN
;Ret+1:	  Already was down
;Ret+2:	Marked it down

HSTDWN::
	SKIPG T1			; Have Internet address?
	  RETSKP			; No, skip it
	ACVAR <DIA,RID,RCR,RTM>		; *** RTM clobbers NCT
	PUSH P,VNCT			; Save NCT for access below
MNTM5	AOS CELL(INGAA,2,,ING)		; HSTDWN calls
	DMOVEM T1,DIA
	SKIPG T4			; Time specified?
	  MOVE T4,TODCLK		; No, use now
	DMOVEM T3,RCR

	TXO T1,FLD(NP.IP,NA%PRO)
	TXNN T1,IA%NET			; Net or Host address?
	 TXOA T2,1B0			; Net, T2 negative and skip
	  CALL HSTHSH			; In our tables?
	   NOP
	IFGE. T2			; Already there or can add it
	  MOVEM DIA,<HOSTNN&777777>(T2)	; Internet address (maybe new entry)
	  MOVE T3,<HSTSTS&777777>(T2)	; Get old status
	  MOVX T4,HS%UP
	  ANDCAM T4,<HSTSTS&777777>(T2)	; Down
	  MOVX T4,HS%VAL
	  TXNN T1,IA%NET		; Net or Host address?
	    TXO T4,HS%NET		; Net, so flag it as such
	  IORB T4,<HSTSTS&777777>(T2)	; Valid, get status for MNTRAP
;	  MOVEM RID,xxx(T2)
;	  MOVEM RCR,xxx(T2)
;	  MOVEM RTM,xxx(T2)
	  TXC T3,HS%VAL
	  TXNE T3,HS%UP+HS%VAL		; Already know it was down?
	ENDIF.
	    TXO T3,HS%VAL		; No, just found out (or no room)
	TXNN T3,HS%VAL			; Which was it again?
	  JRST HSTDWX			; Was down, nothing more to be done
	TXC T3,HS%VAL			; Old status back
					; Was up, now down, work to do ...
MNTM5	AOS CELL(INGAA,3,,ING)		; Useful HSTDWN calls
	MOVX CX,PT%HDN
	CALL MNTRAP			; Log event


;Flush routes which used the down host/gateway or which use failed interface

	SETO T4,			; Assume not called by INTDWN
	TXZE RCR,1B0			; Correct?
	  HRRZ T4,(P)			; No, INTDWN called, check NCT too
	PUSH P,T4			; 0,,NCT  or -1 to force no matches

	MOVEI T2,NETHTB
	HRLI T2,-<NETHSZ>		; # entries in the routing table
	DO.
	  SKIPG T3,NETHTB-NETHTB(T2)	; Check if entry used
	  IFSKP.			; In use
	    CAMN T3,DIA			; Spcl entry for dead Internet address
	    IFSKP.			; No, maybe it is the first-hop gateway
	      CAME DIA,NETGWY-NETHTB(T2) ; Route use dead Internet address?
	       CAMN T4,NETIFC-NETHTB(T2) ; Route use dead interface?
	      ANSKP.			; Neither of those
					; None of the above, entry is ok
	    ELSE.			; One of the above, delete route entry
	      MOVX T1,NA%FLG		; Flag deleted
	      IORB T1,NETHTB-NETHTB(T2)	; Delete whole entry (for diagnostics)
	      MOVE T3,NETGWY-NETHTB(T2)
	      MOVE T4,NETIFC-NETHTB(T2)
	      MOVX CX,PT%GDN
	      CALL MNTRAP		; Log event
	      MOVE T4,(P)		; Restore
	      MOVEM RID,NETWHO-NETHTB(T2) ; Record who reported it down
	      STOR RTM,HS%WHN,+NETWHN-NETHTB(T2) ; When reported down
	      STOR RCR,HS%CRD,+NETWHN-NETHTB(T2) ; Reliability of reporter
	    ENDIF.
	  ENDIF.			; In use
	  ADDI T2,<NETHES-1>		; Words in entry-1
	  AOBJN T2,TOP.			; Loop through the table
	ENDDO.
	POP P,(P)			; Drop check NETIFC flag
	AOS -1(P)			; Call may have something to do
HSTDWX:	POP P,VNCT
	RET

	ENDAV.


;INTUP
;Signal that an interface has come up.

;VNCT/	Address of NCT for the interface.
;	CALL INTUP
;Ret+1:	Always.


INTUP::
MNTM5	AOS CELL(INGAA,4,,ING)		; INTUP calls

; Set route to local net served by interface

	MOVE T2,NTNET(VNCT)		; Get network number
	TXO T2,NA%FLG			; Add it if not there
	CALL NETHSH			; Hash the entry
	 TDZA T1,T1			; Remember to add it
	  SETO T1,			; Must check

	MOVX T3,RTCRLN			; We are very reliable
	MOVE T4,TODCLK			; When it went down

REPEAT 0,<
	IFN. T1				; Must check
	  SKIPG NETIFC-NETHTB(T2)	; Already have route for net
	  ANSKP.
					; Already have route, don't change it
	ELSE.				; Update entry
>
	  SETZM NETGWY-NETHTB(T2)	; First-hop on local net is destination
	  HRRZM VNCT,NETIFC-NETHTB(T2)	; Save NCT
	  MOVE T1,NTLADR(VNCT)		; Get interface address
	  MOVEM T1,NETWHO-NETHTB(T2)	; Record who reported it up
	  STOR T4,HS%WHN,+NETWHN-NETHTB(T2) ; When reported up
	  STOR T3,HS%CRD,+NETWHN-NETHTB(T2) ; Caller is most reliable
REPEAT 0,<
	ENDIF.
>
	MOVE T1,NTLADR(VNCT)		; We are down
	MOVE T2,T1			; We are saying so
	MOVX CX,PT%IUP
	CALL MNTRAP
	CALL HSTUP			; Call HSTUP, same T3, T4
	  JFCL
	RET


;HSTUP
;Mark an Internet address up.

;T1/	Internet address.
;T2/	Reporting entity.
;T3/	Credibility.
;T4/	TODCLK, or 0 if now
;	CALL HSTUP
;Ret+1:	  Already was up
;Ret+2:	Marked it up

HSTUP::	SKIPLE T1			; Make sure have Internet address
	 TXNN T1,IA%NET			; Host or net?
	  RETSKP			; Net, ignore call

	ACVAR <UIA,RID,RCR,RTM>		; (Dont' need NCT here)
MNTM5	AOS CELL(INGAA,5,,ING)		; HSTUP calls
	DMOVEM T1,UIA
	SKIPN T4			; Time specified?
	  MOVE T4,TODCLK		; No, use now
	DMOVEM T3,RCR

	TXO T1,FLD(NP.IP,NA%PRO)
	CALL HSTHSH			; In our tables?
	  NOP
	IFGE. T2			; Have (room for) an entry
	  MOVEM UIA,<HOSTNN&777777>(T2)	; Internet address
	  MOVE T3,<HSTSTS&777777>(T2)	; Get old status
	  MOVX T4,HS%UP+HS%VAL
	  TXNN T1,IA%NET		; Net or Host address?
	    TXO T4,HS%NET		; Net, so flag it as such
	  IORB T4,<HSTSTS&777777>(T2)	; Up and valid, get status for MNTRAP
;	  MOVEM RID,xxx(T2)
;	  MOVEM RCR,xxx(T2)
;	  MOVEM RTM,xxx(T2)
	  TXC T3,HS%UP+HS%VAL
	  TXNE T3,HS%UP+HS%VAL		; Already know it was up?
	ENDIF.
	    TXO T3,HS%VAL		; No, just found out (or no room)
	TXNN T3,HS%VAL			; Which was it again?
	  RET				; Was up, nothing more to be done
	TXC T3,HS%UP+HS%VAL
					; Was down, now up, work to do ...
MNTM5	AOS CELL(INGAA,6,,ING)		; Useful HSTUP calls
	MOVX CX,PT%HUP
	CALL MNTRAP

; Update entries in routing table

	MOVEI T2,NETHTB
	HRLI T2,-<NETHSZ>		; # entries in the routing table
	DO.
	  SKIPG T3,NETHTB-NETHTB(T2)	; Check if entry used
	  IFSKP.			; In use
	    CAMN T3,UIA			; Spcl entry for up Internet address
	    IFSKP.			; No
	      SKIPE T3,NETGWY-NETHTB(T2) ; Check if entry has route
	       CAME T3,UIA		; Route use up Internet address?
	      ANSKP.			; Neither
					; Don't change anything
	    ELSE.
	      LOAD T3,HS%CRD,+NETWHN-NETHTB(T2) ; Creaibility of entry
	      CAMG RTM,NETWHN-NETHTB(T2) ; If info is newer than previous, or
	       CAML RCR,T3		; Reporter at least as reliable
	      ANNSK.			; Update info
	        MOVEM RID,NETWHO-NETHTB(T2) ; Yes, record who reported it up
	        STOR RTM,HS%WHN,+NETWHN-NETHTB(T2) ; When reported up
	        STOR RCR,HS%CRD,+NETWHN-NETHTB(T2) ; Reliability of reporter
	    ENDIF.
	  ENDIF.			; In use
	  ADDI T2,<NETHES-1>		; Words in entry-1
	  AOBJN T2,TOP.			; Loop through the table
	ENDDO.

; Update entries in gateway table

	MOVSI T3,-MAXGWA		; Maximum number of gateways
	DO.
	  HRRZ T2,T3			; Get offset
	  ADD T2,GWTAB			; Point into table
	  SKIPLE T2,(T2)		; Get entry (if any)
	   CAME UIA,.GWILS(T2)		; Accessible address match?
	  IFSKP.			; No, or slot is empty
	    SETONE GWUP,(T2)		; Gateway is up
	    STOR RID,GWWHO,(T2)		; Record who reported it up
	    STOR RTM,GWWHN,(T2)		; When reported up
	    STOR RCR,GWCRD,(T2)		; Reliability of reporter
	    MOVX CX,PT%GUP
	    CALL MNTRAP
	  ENDIF.
	  AOBJN T3,TOP.			; Loop through all gateway blocks
	ENDDO.

; Signal applications that something is up

	MOVE T1,UIA			; Who is up
jfcl;	CALL xxx

	RET

	ENDAV.

;NETHSH	Look up a network number in the hash tables.

;T2/	Network number or Internet address.
;	Flags in T2:  NA%FLG - Add this argument if it isn't in tables.
;	CALL NETHSH	(may be NOSKED)
;Ret+1:	  If no entry currently there, (the slot is reserved in that case).
;Ret+2:	If that network already has a slot in the tables.
;T2/	Ext address of entry in the table for argument.
;Preserves T1.
;Kills	T3, T4.
;cwl nfephy wants to call at interrupt level

NETHSH::
	ACVAR <NET,DELETED>		; Net number
MNTM5	AOS CELL(INGAA,10,,ING)		; NETHSH calls
	MOVE NET,T2			; Save it here, with flag
	TXZ T2,NA%FLG			; Remove flag
	MOVE T4,T2			; For CAMs
	IDIVI T2,NETHSZ			; Make the initial probe
	IMULI T3,NETHES			; Size of an entry
	MOVEI T2,NETHTB(T3)		; (Sect-0) probe address (for CAI)
	NOSKED				; Protect the table

;The following is an optimization for the (hopefully common) case where
;there is no collision and/or the entry is already in the table.

	CAMN T4,NETHTB-NETHTB(T2)	; Same entry?
	  JRST NETHSS			; Success, go use it
	SKIPN CX,NETHTB-NETHTB(T2)	; Slot in use?
	  JRST NETHSF			; Yes, first probe found empty entry
	SETZ DELETED,			; Not found a deleted entry
	SKIPG CX			; This entry deleted?
	  MOVE DELETED,T2		; Yes, remember position
	MOVSI T3,-NETHSZ+1		; # remaining entries in the table

;At this point T2 holds the initial probe and T3 is an AOBJN counter.
;The current table slot is not the desired entry.

NETHSL:	DO.
	  ADDI T2,NETHES		; Next entry
	  CAIL T2,<NETHSZ*NETHES>+NETHTB ; Overflow?
	    MOVEI T2,NETHTB		; Yes, back to top
	  CAMN T4,NETHTB-NETHTB(T2)	; Same net?
	    JRST NETHSS			; Found it
	  SKIPN CX,NETHTB-NETHTB(T2)	; Entry in use?
	  IFSKP.			; In use or deleted
	    SKIPL CX			; Deleted entry?
	    IFSKP.			; Yes
	      SKIPN DELETED		; Already have deleted entry?
	        MOVE DELETED,T2		; No, remember this one
	    ENDIF.
	    AOBJN T3,TOP.		; Loop through the table
	  ENDIF.	
	ENDDO.

;Key not found, either entry unused (CX=0) or table full (T3.ge.0)

	JUMPGE NET,NETHSF;NA%FLG	; Leave if not going to add entry
	SKIPN DELETED			; Have we a deleted entry?
	IFSKP.
	  MOVE T2,DELETED		; Yes, use it
	  JRST NETHSF
	ELSE.
	  JUMPL T3,NETHSF		; Found a slot
	ENDIF.

;Here if the table is full.  Reinitialize the table, since it is assumed
;to be large enough to hold all networks with active connections.

	PUSH P,T1
	CALL NETHSI			; Re-init the table
	POP P,T1
	MOVE T2,NET			; Get the network number back, w/flag
	CALL NETHSH			; Hash it
	  NOP				; Should always fail
	OKSKED
	RET				; Do the plus one return

;Here if the entry was found.

NETHSS:	OKSKED				; Allow scheduling again
	RETSKP				; Return success

;Here if there is no entry for the net.

NETHSF:	TXZN NET,NA%FLG			; Entry to be added? (clear flag)
	IFSKP.
	  MOVEM NET,NETHTB-NETHTB(T2)	; Yes, reserve slot
	  SETZM NETIFC-NETHTB(T2)	; No interface
	  SETZM NETGWY-NETHTB(T2)	; Nor route yet
	  SETZM NETWHO-NETHTB(T2)	; Nor a reporter
	  SETZM NETWHN-NETHTB(T2)	; Nor a time reported nor credability
	ENDIF.
	OKSKED
	RET				; Return failure

	ENDAV.

;NETHSI	Initialize the routing table.
;	CALL NETHSI	(may be NOSKED)
;Ret+1:	Always.
;Kills	T1, T2, T3.

;Called at system startup, whenever the routing table overflows, and
;periodically to flush unused table entries.

NETHSI::
	SAVEAC <VNCT>
MNTM5	AOS CELL(INGAA,7,,ING)		; NETHSI calls
	NOSKED				; Take over the machine

	SETZM NETHTB			; Clear
	MOVE T1,[XWD NETHTB,NETHTB+1]
	BLT T1,NETHTB+<NETHSZ*NETHES>-1	; The entire table
IFE NETHES-1,<
	SETZM NETGWY			; And
	MOVE T1,[XWD NETGWY,NETGWY+1]
	BLT T1,NETGWY+NETHSZ-1		; The parallel table
	SETZM NETIFC			; And
	MOVE T1,[XWD NETIFC,NETIFC+1]
	BLT T1,NETIFC+NETHSZ-1		; The parallel table
>

	MOVEI VNCT,NCTVT-$NTLNK		; Point to the table (sec 0)
	DO.
	  LOAD VNCT,NTLNK,(VNCT)	; Get next in chain
	  JUMPE VNCT,ENDLP.		; Done
	  SKIPL NTORDY(VNCT)		; If this network is usable
	  IFSKP.
	    LOAD T2,NTPRO,(VNCT)	; Get protocol type for this interface
	    CAIE T2,NP.IP		; DOD IP?
	      LOOP.			; No, onward
	    MOVE T2,NTNET(VNCT)		; Get the net number
	    TXO T2,NA%FLG		; Add it if not there
	    CALL NETHSH			; Hash it into tables
	      NOP			; Ok if wasn't there
	    SETZM NETGWY-NETHTB(T2)	; First-hop on local net is destination
	    HRRZM VNCT,NETIFC-NETHTB(T2) ; Remember NCT also
	    MOVE T1,NTLADR(VNCT)	; Who says its up
	    MOVEM T1,NETWHO-NETHTB(T2)
	    MOVE T1,TODCLK		; Time reported
	    STOR T1,HS%WHN,+NETWHN-NETHTB(T2)
	    MOVX T1,RTCRLN		; Local interface is reliable
	    STOR T1,HS%CRD,+NETWHN-NETHTB(T2)
	  ENDIF.
	  LOOP.				; And loop through all interfaces
	ENDDO.

	OKSKED				; Allow use of the machine
	RET				; Return when done

	SUBTTL	Internet Control Message Protocol

COMMENT	!

These  routines implement the Internet Control Message Protocol.

!

					; Local top-level AC usage

;DEFACY(GW,BFR);ps			; Points to a gateway block
GW==BFR
;DEFACY(CPKT,TPKT);ps		; Index register to point to ICMP pkt
CPKT==TPKT
				; (Gateways and multi-homed hosts)
;The file name to use:

	GWFILE:	ASCIZ "SYSTEM:INTERNET.GATEWAYS"

;ICMP packet is pointed to by CPKT, structure as defined in ANAUNV.

MINICW==PKTELI+<<MINIHS+3>/4>+2	; Minimum ICMP packet size, words with local
MINIHB==<MINICW-PKTELI>*4	; Usual header size, w/o imbedded pkt




ICMKJB==:R	; No job cleanup routine
ICMKFK==:R	; No fork cleanup routine
ICMCZF==:R	; No files to be cleaned up


;ICMINI	Initialize ICM Protocol.

;	CALL ICMINI
;Ret+1:	Always.

ICMINI::
	SETZM PNGTM			; Do Pings now
	SETZM ICMTIM			; Run ICMP now

	SKIPE ICMIPQ			; Already have a queue head?
	IFSKP.
	  MOVEI T1,CELL(ICMIQ,0,,ICM)	; Address of ICMP queue head
	  MOVEM T1,ICMIPQ		; Put where we can find it
	  CALL INITQ			; Initialize it
	ENDIF.

	MOVE T1,NTHT0			; Get hash table clear interval
	ADD T1,TODCLK			; Add to now
	MOVEM T1,NTHTM			; When to clear them again

	HRRE T1,ICMON			; Want ICMP up? (1B18 implies yes)
	TRZ T1,-1			; Initialization complete
	MOVEM T1,ICMON			; ON is -1,,0,  OFF is 0

;	CALLRET GWYINI			; Initialize gateway tables

	SUBTTL	Gateway Table Initialization

;GWYINI	Initialize the gateway tables.

;	CALL GWYINI
;Ret+1:	Always, T1/ MNTX00 if ok, or error code MNTX05 (file missing)

GWYINI::
	SE1CAL				; In case called from MDDT
	SAVEAC <GW>
	ACVAR <I>
MNTM0<	SETZM CELL(ICMPG,2,,ICM)>	; Reset # gateways being pinged
	SETZ I,				; No gateways for a little while
	EXCH I,GWCNT0			; Get present number of gateways

	SKIPE GWTAB			; Is this a reinit?
	IFSKP.				; First time init

	  MOVEI T1,MAXGWA+1		; Size of table
	  CALL GETBLK			; Get a block of storage
	  JUMPE T1,GWYIN9		; Crash
	  MOVEM T1,GWTAB
	  MOVEI T2,MAXGWA+1		; Size of table (zero at end)
	  CALL CLRBLK			; Clear it out

	ELSE.				; Reinit

	  SETZM NXTGWY			; No gateways for a while
	  HLLZS I			; AOBJN to scan GWTAB (may be 0)
	  DO.
	    MOVE GW,GWTAB		; Base address
	    ADDI GW,(I)			; Point to actual entry
	    SETZ T1,			; Get a zero
	    EXCH T1,(GW)		; Flush entry, get previous value
	    IFN. T1			; Was there one?
	      PUSH P,T1			; Save the block
	      MOVE T1,.GWILS(T1)	; Get local address of this gateway
	      MOVE T2,NLHOST+0		; Get a random address for us
	      MOVX T3,RTCRI0
	      MOVE T4,TODCLK
	      CALL HSTDWN		; Signal that it's gone away
	        JFCL
	      POP P,T1			; Restore block address
	      CALL RETBLK		; Yes.  Give back storage
	    ENDIF.
	  AOBJN I,TOP.			; Do all GW blocks
	  ENDDO.
	ENDIF.


	CALL LODFIL			; Load the gateway file
	PUSH P,T1			; Save error code

	CALL NETHSI			; Clear the gateway cache
	SETZM PNGTM			; Make sure PINGER gets started

	POP P,T1			; Return error code
	RET



GWYIN9:	BUG.(HLT,INGGP0,IPIPIP,SOFT,
<GWYINI: Crucial storage missing - MAXGWY words>,<<MAXGWA+1,D>>,<

Cause:	During initialization of the ICMP protocol, there was not enough
	Internet free storage to create the gateway tables.  Something
	has probably clobbered memory.

Action:	Get a dump for later analysis.

Data:	The amount of free storage which was not available.

>)
	MOVX T1,MNTX24			; Resource shortage
	RET

	ENDAV.


;LODFIL	Load the gateway file.

;	CALL LODFIL
;Ret+1:	Always, T1/ MNTX00 if ok, or error code MNTX05 (file missing).

LODFIL:	ACVAR <JFH,CHNS>
	SETO JFH,			; Indicate nothing to release

	MOVEI T1,.FHSLF			; This fork
	RCM%				; Get channels which are on
	MOVEM T1,CHNS			; Save for restoring

	MOVEI T1,.FHSLF
	MOVX T2,1B<.ICEOF>		; End of file channel
	DIC%				; Prevent unwanted interrupt

	MOVX T1,GJ%OLD+GJ%SHT		; Want existing file
	HRROI T2,GWFILE			; Pointer to filename string
	MOVX T4,MNTX05			; Assume failure
	GTJFN%				; Locate file
	IFSKP.
	  MOVEM T1,JFH			; Save JFN
	  MOVX T2,<FLD(7,OF%BSZ)+OF%RD>
	  OPENF%			; Open it for reading
	  ANSKP.
	    CALL PRCLIN			; Process lines in the file
	    CLOSF%			; Close file
	     JFCL
	    MOVX T4,MNTX00		; Ok
	ENDIF.

	SKIPL T1,JFH			; If have a JFN, release it
	 RLJFN%
	  JFCL

	MOVEI T1,.FHSLF			; Restore channels
	MOVE T2,CHNS
	AIC%

	MOVE T1,T4			; Error code
	RET

	ENDAV.

;PRCLIN	Process lines of the gateway file.

;T1/	JFH of the file
;	CALL PRCLIN
;Ret+1:	Always.  T1 still has the JFH

PRCLIN::
	ACVAR <JFH,BOL,ERRPNT,ERRCOL>
	MOVEM T1,JFH			; Stash JFH in a save place
					; Top of main per-line loop:
PRCLI1:	MOVE T1,JFH			; Get the file JFH
	RFPTR%				; Find where in file line is
	 JFCL
	MOVEM T2,BOL			; Save beginning of line
	CALL GETC			; First character of line
	JUMPE T2,PRCLIX			; Get out if end of file
	CAIN T2,12			; Linefeed?
	 JRST PRCLI1			; Ignore blank lines
	CAIN T2,";"
	 JRST PRCLI8			; Flush comment line
	CAIN T2,"C"
	 JRST PRCLI7			; Go do CREATION command
	BKJFN%				; Back so  LOADGW read 1st chr
	 JFCL				; BIN% will ITRAP if error in T1
	CALL LOADGW			; Load a gateway description
	JUMPE T2,PRCLI1			; Do next if no error

; Here when error detected in current line (pointer to message in T2)

PRCLI2:	MOVEI T1,.PRIOU
	SETZ T3,
	SOUT%
				; Type the error string
	HRROI T2,[ASCIZ " in file: "]
	SOUT%
	MOVE T2,JFH
	JFNS%				; And the actual file name
	HRROI T2,[ASCIZ "
"]
	SOUT%				; And a carriage return
	MOVE T1,JFH
	RFPTR%				; Find out where to read
	 JFCL
	SOS ERRPNT,T2			; Save the error point
	MOVE T2,BOL			; Beginning of the bad line
	SFPTR%
	 JFCL
	SETOM ERRCOL			; Maybe nothing read of line

; Top of loop that types out a bad line

PRCLI3:	MOVE T1,JFH
	RFPTR%				; Get the file pointer
	 JFCL
	CAME T2,ERRPNT			; Up to the point of the error
	 JRST PRCLI4			; No.  Dont save column yet
	MOVEI T1,.PRIOU
	RFPOS%
	HRRZM T2,ERRCOL			; Column where to show error
PRCLI4:	MOVE T1,JFH
	CALL GETC			; Get a character from bad line
	SKIPN T2			; End of file?
	 MOVEI T2,12			; Yes.  Use linefeed.
	CAIN T2,12			; End of line?
	 JRST PRCLI5			; Yes. Done
	MOVEI T1,.PRIOU
	BOUT%				; Type a character
	JRST PRCLI3			; Do next one

PRCLI5:	MOVEI T1,.PRIOU
	HRROI T2,[ASCIZ "
"]
	SETZ T3,
	SOUT%				; Type and end of line terminal
	JUMPLE ERRCOL,PRCLI6		; Know where to show the error?
	MOVEI T2," "			; Yes.  Space over to it.
	BOUT%
	SOJG ERRCOL,.-1			; All the way.
PRCLI6:	HRROI T2,[ASCIZ "^
"]
	SOUT%
	JRST PRCLI1			; Try to finish the file

					; Do CREATION command
PRCLI7:	CALL GETC			; Skip stuff following the C
	MOVE T3,T2			; Free up T2
	HRROI T2,[ASCIZ "% INCMP: Premature EOF"]
	JUMPE T3,PRCLI2			; Go do the error if need be
	CAIE T3," "			; One space is required
	 JRST PRCLI7			; Loop til it is found
	SETZ T2,			; Default flags
	IDTIM%				; Input the time and date
	 SKIPA T2,[-1,,[ASCIZ "% INCMP: Bad format in creation date"]]
	  MOVEM T2,GFCTAD		; Save file creation date
	JUMPL T2,PRCLI2			; Do error if need be
	JRST PRCLI1			; Do another command

					; Here to flush a comment line
PRCLI8:	CALL GETC			; Get a character
	JUMPE T2,PRCLIX			; Get out if end of file
	CAIE T2,12			; End of line?
	 JRST PRCLI8			; No.
	JRST PRCLI1			; Go read the next line.

PRCLIX:	MOVE T1,JFH			; Preserve JFH as promised
	RET
	ENDAV.


;LOADGW	Load one gateway desciption and add to table.

;T1/	JFH
;	CALL LOADGW
;Ret+1:	Always. T2 has 0 if no error or -1,,errorstring. T1 preserved.

LOADGW:	SAVEAC <GW>
	ACVAR <JFH,EOLFLG>
	TRVAR <<GWTMP,GWBKSZ>>		; Temp gateway block storage
	MOVEM T1,JFH
	XMOVEI T1,GWTMP			; Point to the temp block
	MOVE GW,T1
	MOVEI T2,GWBKSZ			; Size thereof
	CALL CLRBLK			; Clear it
	SETZM EOLFLG			; End of line not seen
LOADG1:	MOVE T1,JFH			; Top of per-keyword loop:
	CALL GETC			; Get a character
	JUMPE T2,LOADG8			; Oops.  End of file.
	CAIE T2,"."			; Decimal number separator
	 CAIN T2," "			; Space (control, etc)
	  JRST LOADG1			; Yes.  Flush it.
	CAIL T2,"0"
	 CAILE T2,"9"
	  JRST LOADG4			; Non-digit.  Must be keyword

;Here to input an interface address in  N H L I form.

LOADG2:	SETZM T4			; Clear the number accumulator
	BKJFN%				; Reread the digit
	 JFCL
LODG2A:	MOVEI T3,^D10			; Decimal
	NIN%
	 JRST LOADG7			; Null number?
	LSH T4,^D8			; Make room for another byte
	ADD T4,T2			; Add it in
	BKJFN%				; Reread the terminator
	 JFCL
	BIN%
	CAIN T2,15			; Happens on TENEX
	 BIN%				; Get line feed, like TOPS20
	JUMPE T2,LOADG8			; Jump if EOF encountered
	CAIE T2,"."			; Dots separate bytes
	 CAIN T2," "			; Another byte follows space
	  JRST LODG2A			; Go get it
	CAIN T2,12			; End of line?
	 SETOM EOLFLG			; Yes.  Remember to exit later.
	CAIE T2,12			; End of line
	 CAIN T2,","			; End of address expression?
	  JRST LOADG3			; Yes.  Go enter into GW block
	JRST LOADG7			; Anything else is bad format.

					; Put address in temp GW block.
LOADG3:	LOAD T3,GWICT,(GW)		; Get current count
	CAIL T3,MXGWIC			; Room for another?
	 JRST LOAD65			; No.
	ADDI T3,1			; Bump the count
	STOR T3,GWICT,(GW)		; Store back
	ADDI T3,.GWILS-1		; Offset to first empty slot
	ADD T3,GW			; Where to store the address
	MOVEM T4,0(T3)			; Interface address in GW block
	SKIPN EOLFLG			; Read entire GW spec?
	 JRST LOADG1			; No.  Get another keyword/addr
	JRST LOADG6			; Yes.  Go tie off this block

					; Process a keyword
LOADG4:	SETO T3,			; Keyword error flag
	CAIN T2,"P"			; "PRIME"
	 MOVX T3,GW%PRM
	CAIN T2,"D"			; "DUMB"
	 MOVX T3,GW%DUM
	CAIN T2,"H"			; "HOST"
	 MOVX T3,GW%HST
	CAIN T2,"A"
	 MOVX T3,GW%AUP			; "ALLWAYS-UP"
	HRROI T2,[ASCIZ "% LOADGW: Unknown keyword "]
	JUMPL T3,LOADGX			; Give error if invalid keyword
	HRROI T2,[ASCIZ "% LOADGW: Too many gateway type specs."]
	JN GWTYP,(GW),LOADGX		; Error if already have spec
	STOR T3,GWTYP,(GW)		; Set type into GW block

;Here to skip over the rest of the current keyword

LOADG5:	CALL GETC			; Get a character
	JUMPE T2,LOADG8			; End of file?
	CAIN T2,12			; End of line?
	 JRST LOADG6			; Yes.  Go tie it off.
	CAIE T2," "			; Space
	CAIN T2,","			; Or comma will end it
	 JRST LOADG1			; Go read next keyword
	JRST LOADG5			; Keep reading rest of this one

;Here to tie off the block which has been accumulating

LOADG6:	CALL DEFGWY			; Create real gateway blocks
	JRST LOADGX			; Return with the result

;Error returns

LOAD65:	CALL DEFGWY			; Create real gateway blocks
	SKIPN T2			; Double error
	  HRROI T2,[ASCIZ /% INCMP: Too many addresses in gateway description./]
	JRST LOADGX			; Return with the result

LOADG7:	SKIPA T2,[-1,,[ASCIZ "% INGGP: Bad format "]]
LOADG8:	  HRROI T2,[ASCIZ "% INGGP: Premature end of file "]

LOADGX:	MOVE T1,JFH
	RET
	ENDAV.
	ENDTV.

;DEFGWY	Create real gateway blocks.

;Given a gateway block pointer in GW, creates a real gateway block
;for each interface on a network we have in common with the gateway.

;GW/	(Ext) pointer to gateway block (in stack)
;	CALL DEFGWY
;Ret+1:	Always, T2/	0 if ok, or  -1,,pointer to error msg

DEFGWY:	ACVAR <CIDX,CCNT,CSLT>
	XMOVEI CIDX,.GWILS(GW)		; Point to the interface list
	LOAD CCNT,GWICT,(GW)		; Interface count
	HRROI T2,[ASCIZ /% INCMP: DEFGW -- No interfaces for gateway/]
	JUMPE CCNT,R			; None (?)
	HRROI T2,[ASCIZ /% INCMP: DEFGW -- No gateway type specified/]
	JE GWTYP,(GW),R			; No type specified

DEFGW0:	DO.				; Top of the per-network loop
	  NETNUM T1,(CIDX)		; Get network number from address
	  TXO T1,<FLD(NP.IP,NA%PRO)>	; Insert address domain
	  CALL NETLUK			; Have we an interface on the same net?
	  IFN. T1			; Yes, find slot for the gateway block
	    HRROI T2,[ASCIZ /% INCMP: DEFGW -- GWTAB full/]
	    HRRZ CSLT,GWCNT0		; Current number of gateways is offset
	    CAIL CSLT,MAXGWA		; Table full?
	      RET			; Yes
	    ADD CSLT,GWTAB		; Point to free gateway table entry

	    MOVEI T1,GWBKSZ		; Size of a gateway block
	    CALL GETBLK			; Get storage
	    HRROI T2,[ASCIZ /% INCMP: DEFGW -- No free storage for gateway block/]
	    JUMPE T1,R			; No storage
	    MOVEI T2,GWBKSZ		; Size of the block
	    PUSH P,T1			; Save block address
	    CALL CLRBLK			; Clear it
	    POP P,T1			; Get block address back

					; T1/ Extended address of empty block
	    SETONE <GWDN,GWHIS>,(T1)	; Init history bits, state unknown
	    MOVEI T2,WID(GWHIS)		; Number of bits in ping history
	    STOR T2,GWSPC,(T1)		; Set succesfull ping count to match
	    LOAD T2,GWTYP,(GW)		; Get gateway type
	    STOR T2,GWTYP,(T1)		; And save it

	    MOVX T3,.GWUP		; Assume UP

	    CAIE T2,GW%HST		; "HOST" or
	     CAIN T2,GW%AUP		; "ALLWAYS-UP"?
	    IFSKP.
	      SETONE GWPNG,(T1)		; Ping this gateway
MNTM0<	      AOS CELL(ICMPG,2,,ICM)>	; Neither, count # gateways pinged
	    ELSE.
	      CAIN T2,GW%HST
	        MOVX T3,.GWUN		; Unknown status for HOST
	    ENDIF.

	    STOR T3,GWSTS,(T1)		; Set initial state
	    MOVE T2,(CIDX)		; Get interface we can reach
	    MOVEM T2,.GWILS(T1)		; Save
	    LOAD T3,GWICT,(GW)		; Interface count
	    STOR T3,GWICT,(T1)		; Save here also

	    XMOVEI T2,.GWILS(GW)	; Point to the list
	    PUSH P,T1			; Save block
	    XMOVEI T1,.GWILS+1(T1)	; Point to interface list
DEFGW3:	    DO.
	      CAMN CIDX,T2		; Same as current?
	      IFSKP.
	        MOVE T4,(T2)		; No, get an interface
	        MOVEM T4,(T1)		; Save in block
	        XMOVEI T1,1(T1)		; Increment block pointer
	      ENDIF.
	      XMOVEI T2,1(T2)		; Increment source pointer
	      SOJG T3,TOP.		; Loop
	    ENDDO.
	    POP P,T1			; Restore block pointer
	    MOVEM T1,(CSLT)		; Save block in gateway table

	    MOVX T1,<-1,,1>		; Another gateway now exists
	    ADDM T1,GWCNT0
	  ENDIF.			; Have common local network	

	  AOS CIDX			; Move to next gateway address
	  SOJG CCNT,TOP.		; Try the next interface
	ENDDO.
	SETZ T2,			; Return good
	RET				; Return when done

	ENDAV.

;GETC	Get a character from a file.

;T1/	JFH of the file
;	CALL GETC
;Ret+1:	T1 preserved.  T2 has the chr or 0 if end of file

GETC:	BIN%				; Read the file
	JUMPN T2,GETC2			; Jump if a character gotten
	GTSTS%				; Read a null.
	TXNN T2,GS%EOF			; At end of file?
	 JRST GETC			; No.  Just flush the null
	MOVEI T2,0			; Set to return the EOF code
	JRST GETCX

GETC2:	CAIE T2,14			; Formfeed?
	CAIN T2,37			; TENEX EOL?
	 MOVEI T2,12			; Convert to linefeed
	CAIN T2,12			; Linefeed?
	 JRST GETCX			; Return that
	CAIGE T2," "			; Other control?
	 JRST GETC			; Yes.  Flush
	CAIL T2,"a"
	CAILE T2,"z"
	 CAIA				; Not lowercase
	 SUBI T2,"a"-"A"		; Raise lowercase
GETCX:	RET

	SUBTTL	Gateway Pinger

;PINGER	Ping gateways to see if they are up.

;	CALL PINGER
;Ret+1:	Always.  PNGTM reset for next run.

PINGER:	SAVEAC <GW>
MNTM5	AOS CELL(ICMPG,0,,ICM)		; PINGER calls
	DO.
	  HRRZ GW,PNGIX			; Get offset into table
	  ADD GW,GWTAB			; Add base pointer
	  AOS PNGIX			; Gateway to be pinged next time
;	  SKIPN INTSCR			; If secure or
	   SKIPN GW,0(GW)		; Get pointer to gateway block
	  IFSKP.		; Update ping history and successful ping count
	    LOAD T1,GWHIS,(GW)		; Get the history bits
	    LOAD T2,GWSPC,(GW)		; Get the successful ping count
	    TRNE T1,<1_<WID(GWHIS)-1>>	; Test bit about to be forgotten
	      SUBI T2,1			; Forgetting a success
	    SKIPGE T2			; Avoid negative while down
	      MOVEI T2,0		; This is as bad as you can get
	    LOAD T3,GWPIP,(GW)		; Previous ping still in progress?
	    XORI T3,1			; Flip sense to indicate success
	    LSH T1,1			; Flush the oldest history bit
	    IOR T1,T3			; Include in history bits
	    SKIPE T3			; Did we add a success to the list
	      ADDI T2,1			; Yes.  Count it up
	    CAILE T2,WID(GWHIS)		; Check for overflow
	      MOVEI T2,WID(GWHIS)	; Limit to max
	    STOR T2,GWSPC,(GW)		; Store back the count
	    STOR T1,GWHIS,(GW)		; Store back the bits
				; See if gateway came up or went down
	    MOVE T4,T3			; Find new GWSTS
	    CAMG T2,PNGDN		; So few that it is down?
	    IFSKP.
	      ADDI T4,1(T3)		; No
	      CAML T2,PNGUP		; Enough success to say it's up?
	        MOVNI T4,-3(T3)		; Yes
	    ENDIF.			; (.GWUP,.GWTY,.GWUN,.GWDN)

;cwl needs work

	    LOAD T1,GWSTS,(GW)		; Old state
	    STOR T4,GWSTS,(GW)		; New state
	    XOR T1,T4
	    TRNE T1,2			; UP bit change?
	    IFSKP.
	      MOVE T1,.GWILS(GW)	; Change, get the relevant interface
	      LOAD T2,GWWHO,(GW)	; Who said it is down
	      MOVX T3,RTCRPG		; Reporter's reliability
	      TRNE T4,2			; Go up or come down?
	      IFSKP.
	        MOVE T4,TODCLK		; Now
	        CALL HSTDWN		; Gateway seems down
MNTM5	         CAIA			; Nothing new
MNTM5	          AOS CELL(ICMPG,4,,ICM); Count gateways going down
	           JFCL			; Beware missing instructions
	      ELSE.
	        MOVE T4,TODCLK		; Gateway seems up
	        CALL HSTUP		; Say its back
MNTM5	         CAIA			; Already was?
MNTM5	          AOS CELL(ICMPG,3,,ICM); Count gateways coming up
	           JFCL			; Beware missing instructions
	      ENDIF.
	    ENDIF.

	    LOAD T1,GWTYP,(GW)		; Gateway type code
	    CAIE T1,GW%HST		; Host?
	    IFSKP.
	      MOVX T1,.GWUN		; Don't know
	      STOR T1,GWSTS,(GW)
	      LOOP.			; No ping, try next gateway
	    ENDIF.
	    CAIE T1,GW%AUP		; Always up?
	    IFSKP.
	      NETNUM T1,.GWILS(GW)	; Accessible net
	      CALL NETLUK		; Local interface up?
	      MOVX T2,.GWUP		; Assume up
	      SKIPG T1
	        MOVX T2,.GWDN		; Not useable if interface down
	      STOR T2,GWSTS,(GW)
	      LOOP.			; No ping, try next gateway
	    ENDIF.
	    IFQE. GWPNG,(GW)
	      LOOP.			; Don't ping this gateway
	    ENDIF.
	    CALL PNGWAY			; Send a ping to gateway in GW
	  ELSE.				; No entry (or secure) means
	    SETZM PNGIX			; End of table, start at top next time
	  ENDIF.
	ENDDO.

PINGE8:	MOVE T1,PNGT0			; Gateway ping interval
MNTM0<	SKIPN T2,CELL(ICMPG,2,,ICM)>	; # gateways being pinged (may be 0)
	 TXOA T1,1B1			; None, + infinity (w/burried "now")
	  IDIV T1,T2			; Compute inter-ping interval
	CAMGE T1,PNGMN			; Don't ping too fast
	  MOVE T1,PNGMN
	ADD T1,TODCLK			; Time of next ping/check
	MOVEM T1,PNGTM			; Save for scheduling
	RET

;PNGWAY	Send a ping message to a gateway.

;This is an ECHO message if we are sending to a PRIME gateway, or an
;ECHO REPLY addressed to ourself if testing a DUMB gateway.  Net
;result is that we get back only ECHO REPLIES.

;GW/	Pointer to gateway block
;	CALL PNGWAY
;Ret+1:	Always.

PNGWAY:
MNTM5	AOS CELL(ICMPG,1,,ICM)		; Count calls to PNGWAY
	SETONE GWPIP,(GW)		; Set ping-in-progress bit
	NETNUM T1,.GWILS(GW)		; Get network number from address
	TXO T1,<FLD(NP.IP,NA%PRO)>	; Insert address domain
	CALL NETLUK			; Find local interface for that net

	MOVE T4,TODCLK			; Current time
	IFLE. T1			; Local interface is down (non-exist)
MNTM5	  AOS CELL(ICMPG,5,,ICM)	; PNGWAY found local net down
	  JE GWSTS,(GW),R		; Leave old information if was down
	  SETZRO GWSTS,(GW)		; Gateway is unuseable
	  TXZ T1,1B0			; Clear down flag
	  MOVE T2,NTLADR(T1)		; Get local address on that net
	  STOR T2,GWWHO,(GW)		; Who said it is down (if no reply)
	  STOR T4,GWWHN,(GW)		; Down as of now
	  MOVX T3,RTCRLN		; Local net said so
	  STOR T3,GWCRD,(GW)
	  RET
	ENDIF.

	LOAD T2,GWTYP,(GW)		; Get gateway type
	CAIE T2,GW%HST
	IFSKP.				; If a HOST, don't really ping it
MNTM5	  AOS CELL(ICMPG,6,,ICM)	; PNGWAY didn't ping HOST
	  JN GWSTS,(GW),R		; Leave old status
	  MOVX T2,.GWUN			; Unknown state
	  STOR T2,GWSTS,(GW)
	  STOR T4,GWWHN,(GW)		; Back as of now
	  MOVX T3,RTCRPG		; Pinger said so
	  STOR T3,GWCRD,(GW)
	  RET
	ENDIF.

	SAVEAC <VNCT,PKT,CPKT>
	HRRZ VNCT,T1			; Save NCT

	MOVX T1,MINICW			; Size of echo packet
	MOVX T2,NP.IP			; Protocol code
	CALL GETBUF ;(T1:T1,T2)		; Get packet buffer to put it in
	IFE. T1
MNTM5	  AOS CELL(ICMPG,7,,ICM)	; PNGWAY couldn't get buffer
	  RET
	ENDIF.
	MOVE PKT,T1			; Have a packet

; No application level

	XMOVEI CPKT,MINICW(PKT)		; Address of application level data
	STOR CPKT,PAPDT,(PKT)
	SETZRO PAPBZ,(PKT)		; No data

; Build ICMP session level leader

	SUBI CPKT,.CMINH		; Address of session level leader
	STOR CPKT,PSSDT,(PKT)
	MOVX T4,<.CMINH*4>		; Session level leader length
	STOR T4,PSSBZ,(PKT)

	MOVEI T3,ICM%EC			; Echo type
	LOAD CX,GWTYP,(GW)		; Get type
	CAIE CX,GW%DUM			; Dumb?
	IFSKP.				; Yes, have gateway foreward ping back
	  MOVEI T3,ICM%ER		; ECHO-REPLY code
	  SETONE PNLCL,(PKT)		; No local delivery allowed
	ENDIF.
	STOR T3,CMTYP,(CPKT)		; Set into ICMP section
	SETZRO <CMCOD,CMCKS>,(CPKT)	; Clear code and checksum
	SETONE CMID,(CPKT)		; (ID -1 is reserved for system use)
	AOS T2,ICMSID			; Get a sequence number
	STOR T2,CMSEQ,(CPKT)
	CALL ICCKSM			; Compute checksum
	STOR T1,CMCKS,(CPKT)		; Insert in packet

	LOAD T4,CMSEQ,(CPKT)		; Get sequence number for IP ID

; Build IP transport level leader

	MOVX T2,<<MINIHS+3>/4>		; Length of IP header, words
	SUB CPKT,T2			; Address of transport level leader
	STOR CPKT,PTPDT,(PKT)	
	STOR T2,IPDO,(CPKT)		; Length of IP leader
	LSH T2,2			; Bytes in transport level leader
	LOAD T3,PSSBZ,(PKT)		; Session level length
	ADD T2,T3
	STOR T2,PTPBZ,(PKT)		; Length at transport level
	STOR T2,IPPL,(CPKT)		; IP packet length

	STOR T4,IPSID,(CPKT)		; IP ID is ICMP sequence number
	SETZRO <IPFLG,IPFO>,(CPKT)	; Clear fragmentation info

	MOVX T1,.INTVR			; Set IP version
	STOR T1,IPVER,(CPKT)
	SETZRO IPTOS,(CPKT)
	MOVE T1,PNGTL			; Ping "lifetime"
	STOR T1,IPTTL,(CPKT)
	MOVEI T1,.ICMFM			; Protocol is ICMP
	STOR T1,IPPRO,(CPKT)

	MOVE T3,NTLADR(VNCT)		; Get interface address (source)
	MOVE T4,.GWILS(GW)		; Address of gateway being pinged
	LOAD T1,GWTYP,(GW)		; Get type
	CAIN T1,GW%DUM			; Dumb?
	  EXCH T3,T4			; Swap source and destination
	STOR T3,IPSH,(CPKT)		; Make it come from here
	STOR T4,IPDH,(CPKT)		; Make it go there

	PNTLDR CPKT,PSSDT,(PKT)
	CALL ICMOST			; ICMP output statistics

	SETZB T1,T2			; No special first-hop routing
	CALL SNDGAT			; Send it off
MNTM5<	TXNN T1,NE%DRP>			; Did it get accepted?
MNTM5	  AOS CELL(ICMPG,10,,ICM)	; PNGWAY actualy sent ping
	RET

	SUBTTL	Main ICMP Processing Routine

;ICMPRC	Top level ICMP Processing routine.  Called from main Internet fork.

;	CALL ICMPRC
;Ret+1:	Always.

ICMPRC::
	SETZM ICMFLG			; Clear run request flag

	MOVE T2,ICMIPQ			; Locate Queue head
	LOAD T1,QNEXT,(T2)		; Get first thing
	CAME T1,T2			; Have packets?
	  CALL ICMDSP			; Yes, Dispatch any waiting msgs

	MOVE T1,PNGTM			; Time of next ping
	CAMGE T1,TODCLK			; Over due?
	  CALL PINGER			; Yes.  Do ping stuff.

	MOVE T1,NTHTM			; Time to flush old routes?
	CAML T1,TODCLK
	IFSKP.
	  CALL NETHSI			; Yes, clear the tables
	  SKIPG T1,NTHT0		; Do it periodically?
	    MOVX T1,.INFIN		; No, plus infinity is next time
	  ADD T1,TODCLK			; Get time now
	  MOVEM T1,NTHTM		; Save
	ENDIF.

	CAML T1,PNGTM			; Use the minimum time
	  MOVE T1,PNGTM			; Get time of next ping
	MOVEM T1,ICMTIM			; Save as when we have to run
	RET


;ICMCHK	Check Routine for ICMP Tells when to run next.

;T1/	A TODCLK
;	CALL ICMCHK
;Ret+1:	Always.  T1 has min of input T1 and when we should run next.

ICMCHK::
	CAMLE T1,ICMTIM			; Check against our next timeout
	 MOVE T1,ICMTIM			; That is sooner
	RET

;ICMDSP	Dispatch on ICMP message type.

;	CALL ICMDSP
;Ret+1:	Always.

ICMDSP:	SAVEAC <VNCT,CPKT,PKT,TCB>
	ACVAR <NPKTS>
MNTM5	AOS CELL(ICMPF,0,,ICM)		; Count calls to ICMDSP
	SETZB TCB,NPKTS
	DO.				; While more received packets
	  MOVE CX,ICMIPQ		; Pointer to input queue head
	  LOAD T1,QNEXT,(CX)		; Get first thing on queue
	  CAMN T1,CX			; Pointer to head means empty
	    EXIT.			; Empty
	  AOS NPKTS			; Processing another packet
	  XMOVEI PKT,-PKTQ(T1)		; What to dequeue
	  CALL DQ ;(T1)			; Get it off queue (NOSKED not needed)
	  MOVX T1,PT%CDI		; ICMP dequeued from input queue
	  TDNE T1,MNTRAC		; Want trace?
	    CALL PRNPKI ;(T1,PKT)	; Yes
	  PNTLDR CPKT,PSSDT,(PKT)	; Locate ICMP leader
	  CALL ICMCKS			; Check ICMP Checksum
	  JUMPN T1,ICMDSC		; Jump if bad
	  CALL ICMIST			; Record type/code received
	  LOAD T1,CMTYP,(CPKT)		; What kind of message it is
	  MOVSI T2,-NICMPT		; Number of messages we know about
	  DO.
	    CAME T1,ICMTTB(T2)		; Matches this one?
	      AOBJN T2,TOP.		; No.  Try next.
	  ENDDO.
	  JUMPGE T2,ICMDST		; Jump if not found
	  LOAD T3,PIPL,(PKT)		; Packet length in bytes
	  LOAD T4,PIDO,(PKT)		; Internet data offset in words
	  ASH T4,2			; Make that bytes
	  SUB T3,T4			; Number of bytes in ICMP part
	  SUB T3,ICMMDC(T2)		; Minus min number req'd for this type
	  JUMPL T3,ICMDSS		; Enough in packet?
	  CALL @ICMRTB(T2)		; Yes, call routine; skips if keeps pkt
ICMDS8:	    CALL RETPKT			; Return the packet to free storage
	  LOOP.				; Loop through rest of Q
	ENDDO.

					; Update input queue stats for this run
MNTM5<	SKIPGE T4,ICMIPQ-.INTPQ+.INTPM>	; Get pointer to input queue stats
MNTM5<	 CAMG T4,[-5,,0]>		; Big enough
MNTM5	  JRST ICMDSZ			; No
MNTM5<	MOVN T1,NPKTS>			; To decrement queue length
MNTM5<	ADDM T1,XCELL(.INTPM,0,(T4))>	; "Zero" ICMIPQ queue length
MNTM5<	ADDM NPKTS,XCELL(.INTPM,4,(T4))>; Total packets processed by ICMDSP
MNTM5	SKIPN NPKTS			; Queue empty?
MNTM5	  AOS XCELL(.INTPM,1,(T4)) 	; Unnecessary ICMDSP runs
ICMDSZ:	RET




;cwl traps here
					; Errors
ICMDSC:	MOVX T1,PT%CKC			; Checksum failure
MNTM5	AOS CELL(ICMPF,1,,ICM)		; Count checksum failed in ICMDSP
MNTM2	AOS CELL(ICMAB,1,,ICM)		; Input packet flushed due to error
	JRST ICMDS9

ICMDSS:	MOVX T1,PT%CKS			; Short packet
MNTM5	AOS CELL(ICMPF,3,,ICM)		; Count short packet in ICMDSP
MNTM2	AOS CELL(ICMAB,1,,ICM)		; Input packet flushed due to error
	JRST ICMDS9

ICMDST:	MOVX T1,PT%CKT			; Unknown type
MNTM5	AOS CELL(ICMPF,2,,ICM)		; Count unknown type in ICMDSP

ICMDS9:	TDNE T1,MNTRAC			; Want trace?
	  CALL PRNPKI ;(T1,PKT)		; Yes
	AOS BADPCT			; Increment bad packet count
	JRST ICMDS8			; And loop

	ENDAV.

;Table of type codes (ordered by frequency):

ICMTTB:	ICM%ER				; Echo reply
	ICM%EC				; Echo
	ICM%DU				; Destination unreachable
	ICM%RD				; Redirect output
	ICM%SQ				; Source quench
	ICM%PP				; Parameter problem
	ICM%TE				; Time exceeeded
	ICM%TM				; Time stamp
	ICM%TR				; Time stamp reply
	ICM%IQ				; Information request
	ICM%IR				; Information reply
NICMPT==.-ICMTTB			; Number of types we know about

;Action routines table parallel to the above:

ICMPTR==ICMUSR
ICMPIR==ICMUSR

ICMRTB:	IFIW!ICMPER			; Process echo reply
	IFIW!ICMPEC			; Process echo
	IFIW!ICMPDU			; Process destination unreachable
	IFIW!ICMPRD			; Process redirect
	IFIW!ICMUSR			; Process source quench
	IFIW!ICMUSR			; Process parameter problem
	IFIW!ICMUSR			; Process time exceeded
	IFIW!ICMPTM			; Process timestamp request
	IFIW!ICMPTR			; Process timestamp reply
	IFIW!ICMPIQ			; Process information request
	IFIW!ICMPIR			; Process information reply
IFN .-ICMRTB-NICMPT,<PRINTX ? ICMP dispatch tables have wrong size>


;Table of minimum data counts in bytes.  If greater than 8+24, then an
;internet header and 64 bits of data is part of the packet.

ICMMDC:	^D8				; Echo reply length
	^D8				; Echo length
	^D8+MINIHS+^D8			; Destination unreachable
	^D8+MINIHS+^D8			; Redirect
	^D8+MINIHS+^D8			; Source quench
	^D8+MINIHS+^D8			; Parameter problem
	^D8+MINIHS+^D8			; Time exceeded
	^D8+^D12			; Timestamp request
	^D8+^D12			; Timestamp reply
	^D8				; Information request
	^D8				; Information reply
IFN .-ICMMDC-NICMPT,<PRINTX ? ICMP tables screwed up>


					; Process an ECHO message:
ICMPEC:	MOVX T1,ICM%ER			; Echo reply code
	JRST ICMPEX			; Swap & send

					; Process Timestamp request
ICMPTM:	NOSKED
	CALL INETUT			; Get universal time
	MOVE T2,TODCLK			; Msec up
	OKSKED
	STOR T1,CMTST,(CPKT)		; Transmission time
	LOAD T3,PLNDE,(PKT)		; Msec when received
	SUB T2,T3			; Msec since received
	SUB T1,T2			; UT when received
	SKIPGE T1			; Beware underflow
	  ADD T1,[^D<24*60*60*1000>]	; Mod a day
	STOR T1,CMTSR,(CPKT)		; UT when received, 0 to max
	MOVX T1,ICM%TR			; Timestamp reply code
	JRST ICMPEX			; Swap & send

					; Process Information request
ICMPIQ:	LOAD T1,PISH,(PKT)		; Get source
	SETZ T2,
	CALL BSTADR			; find best address to that host
	  NOP				; Shouldn't happen
	MOVX T1,ICM%IR			; Information reply code
	JRST ICMPEY

					; Common exit for replies
ICMPEX:	LOAD T2,PIDH,(PKT)		; Destination (us)
ICMPEY:	LOAD T3,PISH,(PKT)		; Source (who wants echo)
	STOR T1,CMTYP,(CPKT)		; Set as the ICMP type code
	STOR T2,PISH,(PKT)		; We are the echoer
	STOR T3,PIDH,(PKT)		; Sender is the echoee
	SETZRO CMCKS,(CPKT)		; Clear checksum
	CALL ICMCKS			; Do checksum
	STOR T1,CMCKS,(CPKT)		; Set it
	CALL ICMOST			; ICMP output statistics
	SETZB T1,T2			; No special first-hop routing
	CALL SNDGAT			; Send it back
	RETSKP				; Error check?

					; Process an ECHO-REPLY message:
ICMPER:	SAVEAC <GW>
	LOAD T1,PISH,(PKT)		; Who it appears to be from (maybe us)

	HLLZ T2,GWCNT0			; Maximum # of gateways (may be 0)
	DO.
	  MOVE GW,GWTAB			; Base address
	  ADDI GW,(T2)			; Point to actual entry
	  SKIPE GW,(GW)			; Get pointer to gateway block
	   CAMN T1,.GWILS(GW)		; This gateway?
	    EXIT.			; Found GW, or end of table
	  AOBJN T2,TOP.			; Try next gateway
	  MOVEI GW,0			; Indicate failure
	ENDDO.

	IFN. GW				; Found gateway block
	  SETZRO GWPIP,(GW)		; Clear ping-in-progress bit
	  LOAD T1,PISH,(PKT)		; Who sent reply
	  STOR T1,GWWHO,(GW)		; Record who reported it up
	  MOVE T1,TODCLK
	  STOR T1,GWWHN,(GW)		; When reported up
	  MOVX T1,RTCRIC
	  STOR T1,GWCRD,(GW)		; Reliability of reporter
	ENDIF.

	MOVX T1,<.RTJST(-1,CMID)>	; We set it to -1
	LOAD T2,CMID,(CPKT)		; What's in packet?
	CAME T1,T2			; Reply for us or a user?
	  CALLRET ICMUSR		; Not one PNGWAY sent, give to user
	RET


;ICMPRD	Process a REDIRECT message.

;The destination that triggered the message is in the included packet.

ICMPRD:
	LOAD T1,CMCOD,(CPKT)		; Get the code
	CAIE T1,RD%NET			; Re-direct net?
	IFSKP.
	  LOAD CX,CMGWA,(CPKT)		; Get the correct gateway address
	  NETNUM T1,CX			; Extract it's network number
	  CALL NETLUK			; Find interface on that net
	  IFG. T1			; Have interface which is up?
	    ACVAR <IFC,GWY>
	    MOVE IFC,T1			; Save NCT address
	    LOAD GWY,CMGWA,(CPKT)	; Save gateway's Internet address
	    LOAD T1,PIDH,-PKTELI+.CMINH(CPKT) ; Host to be redirected
	    NETNUM T2,T1		; It's network number
;cwl should it be added if its not there?
	    TXZ T2,NA%FLG		; Do not add it if not there
	    CALL NETHSH			; Hash it
	     CAIA			; Not currently in tables
					; Local net unreachable
	      HRRZM IFC,NETIFC-NETHTB(T2) ; Save NCT address of interface
	    SKIPE NETGWY-NETHTB(T2)	; A local net?
	      MOVEM GWY,NETGWY-NETHTB(T2) ; No, set this as the gateway
	  ENDIF.
	ENDIF.
	CALLRET ICMUSR			; Pass to user

	ENDAV.

;Process an UNREACHABLE message

;This means that all paths into the indicated network (host, port etc.) are
;broken.  There is no need to change the routing tables, since they would
;be re-created anyway, and if the net comes back via another path another
;redirect message will be received.  Thus all we need to do is notify the user.

ICMPDU:	LOAD T4,CMCOD,(CPKT)		; Get the code
	CAIE T4,DU%NET			; Net unreachable or
	 CAIN T4,DU%HST			; Host unreachable?
	IFNSK.
	  LOAD T1,PIDH,-PKTELI+.CMINH(CPKT) ; Get the included destination
	  CAIE T4,DU%NET		; Net unreachable?
	  IFSKP.
	    NETNUM T1,T1		; Extract net number
	  ENDIF.
	  LOAD T2,PISH,(PKT)		; Who said it is down
	  MOVX T3,RTCRIC		; Reporter's reliability
	  MOVE T4,TODCLK		; Now
	  CALL HSTDWN			; Say it went away
	    JFCL
	ENDIF.

	CALLRET ICMUSR


;ICMUSR	Give an ICMP message to the user.

;There are two possibilities: If the message is in response to a user
;Q  message,  we  simply  stick it on that Q's recieve Q (and let the
;user process it) If the message is in response to a monitor protocol
;(TCP) then we have to call the proper routines for handling it.  (at
;all  times,  if  we  reach  this routine, the ICMP data contains the
;Internet header that triggered the message starting at .CMINH(CPKT) )

;PKT/	Packet pointer
;CPKT/	ICMP portion
;	CALL ICMUSR
;Ret+1:	Always.

ICMUSR:	ACVAR <IIX,ITB,ITL>
	MOVEI ITB,INTPIX+1		; Locate tables
	MOVE IIX,INTPIX			; # protocols
	HRRZ ITL,IIX			; Table length
	LOAD T1,PIPRO,-PKTELI+.CMINH(CPKT); Get triggering protocol
	DO.
	  SKIPL .INTPO(ITB)		; Protocol on?
	  IFSKP.			; Yes
	    SKIPL T2,.INTPL(ITB)	; Take any protocol?
	     CAMN T1,T2			; Or match?
	    ANNSK.
MNTM5	      INHSTI(ICMRP,ICM,T1,T4,T2) ; Histogram Protocol number (CELL(T1)
	      CALLRET @.INTPE(ITB)	; Ret+1: didn't dispose of packet
	  ENDIF. 			; Ret+2: disposed of packet (to ICMDS8)
	  ADD ITB,ITL			; Increment pointer
	  AOBJN IIX,TOP.		; And loop
	ENDDO.				; Here if nobody to accept the packet
MNTM5	AOS CELL(ICMRP,3,,ICM)		; Count packets dropped by ICMUSR
	RET				; Return so it will be released.



; Process an ICMP message for ICMP

ICMICM::
	JRST INQICM			; Pass it on to a User Queue

	ENDAV.

;ICMERR	Report an error via ICMP.

;T1/	ICMP error code (LH == subcode if any)
;T2/	Additional info, if any (parameter problem pointer)
;PKT/	Erring packet
;	CALL ICMERR
;Ret+1: Always, packet returned if no other processes have it locked.

ICMERR::
	ACVAR <ICMIDX,INFO>		; AC variables
	TRVAR <ERROR,HDRSIZ>		; Stack variables
MNTM5	AOS CELL(ICMAA,1,,ICM)		; Calls to ICMERR
	PUSH P,CPKT			; Save register we clobber

	IFQN. PLCLO,(PKT)		; Locally originated packet and
	  MOVE CX,INPSW			; Switches
	  TXNE CX,IPS%IL		; Report errors via ICMP to self
	  ANSKP.			; No
MNTM5	    AOS CELL(ICMAA,2,,ICM)	; Calls to ICMERR omitting local msgs
	    JRST ICMERX
	ENDIF.

	SETZ CPKT,			; Clear
	MOVEM T1,ERROR			; Save erorr code
	MOVEM T2,INFO			; And additional info
	SETONE PICMP,(PKT)		; Reader of packet

	LOAD T2,PIPRO,(PKT)		; Get protocol
	CAIE T2,.ICMFM			; Internet control message format?
	IFSKP.				; Yes...
	  LOAD T2,PIDO,(PKT)		; Get data offset
	  ADD T2,PKT			; Add PKT into it
	  LOAD T2,CMTYP,+PKTELI(T2)	; Get type
	  CAIG T2,IF%MAX		; If legal value
	   SKIPL ICMPFE(T2)		; Get flags
	  ANNSK.
MNTM5	    AOS CELL(ICMAA,3,,ICM)	; Bad ICMP Type in ICMERR, omit err msg
	    JRST ICMERX			; Ignore the packet
	ENDIF.
	HRRZS T1			; Keep only the ICMP type
	MOVSI ICMIDX,-NICMPT		; Number of ICMP types we handle
	DO.
	  CAME T1,ICMTTB(ICMIDX)	; Same?
	    AOBJN ICMIDX,TOP.		; Loop through the table
	ENDDO.

	IFGE. ICMIDX			; Invalid code, internal error
	  BUG.(CHK,ICMBDE,IPIPIP,SOFT,<ICMERR -- Bad type code>,<<T1,D>>,<

Cause:	Some module which is attempting to report an error via the ICMP
	protocol has specified an unknown error code.  Maybe a new error
	code has been defined -- if so, the internal tables should be
	updated to include it.

Action:	Proceed from the BUGCHK and notify the software staff so
	corrective action can be taken.

Data:	The unknown error code.

>)
MNTM5	  AOS CELL(ICMAA,3,,ICM)	; Calls to ICMERR with bad code
	  JRST ICMERX			; Forget about reporting
	ENDIF.

	SETZM HDRSIZ			; Assume don't include header
	MOVX T1,^D<8+24>		; Size of data if no header, bytes
	CAMLE T1,ICMMDC(ICMIDX)		; Same?
	IFSKP.				; No
	  LOAD T1,PIDO,(PKT)		; Get data offset
	  ADDI T1,2			; Plus 64 bits of data
	  MOVEM T1,HDRSIZ		; Remember it (words)
	ENDIF.
	MOVX T1,MINICW			; Buffer size w/o header
	ADD T1,HDRSIZ			; Plus size of header (if needed)

	MOVE T2,PKTFLG(PKT)		; Flag bits indicate readers
;TEMP - always get new storage
jfcl;	TXNE T2,<PFLGP&<^-<PICMP>>>	; Anyone else?
	IFSKP.				; No, reuse packet
	  LOAD T2,PIPL,(PKT)		; This buffer big enough to reuse?
	  LSH T2,-2			; Its size, words, rounded down
	  MOVE T3,HDRSIZ		; Beware BLT over self
	  CAIG T3,<<MINIHS+3>/4>+.CMINH	; Vs first word written
	   CAILE T1,PKTELI(T2)		; Req'd vs actual
	  ANSKP. 			; Need more than have or overwrite
	    MOVE CPKT,PKT		; Re-use the packet buffer
	ELSE.				; Must get buffer for ICMP message
	  MOVX T2,NP.IP			; Protocol code
	  CALL GETBUF ;(T1:T1,T2)	; Get new packet
	  SKIPE CPKT,T1			; Working pointer
	  IFSKP.			; No storage
MNTM5	    AOS CELL(ICMAA,4,,ICM)	; Calls to ICMERR, no buffer
	    JRST ICMERX			; No storage, do nothing
	  ENDIF.
	ENDIF.

;NB: CPKT is not pointing at ICMP header, but at packet

	SKIPN T1,HDRSIZ			; Include header?
	IFSKP.				; Yes
	  XMOVEI T2,PKTELI(PKT)		; Start of internet leader
	  XMOVEI T3,PKTELI+<<MINIHS+3>/4>+.CMINH(CPKT); Where to stash it
	  CALL XBLTA			; Move the data
	ENDIF.
	LOAD CX,PTRAC,(PKT)		; Copy trace code in erring packet to
	STOR CX,PTRAC,(CPKT)		; Error packet
	LOAD T1,PISH,(PKT)		; Get the packet source host
	STOR T1,PIDH,(CPKT)		; Save as error destination
	LOAD T1,PIDH,(PKT)		; How we were addressed
	CALL LCLHST			; Vaild (receiver may be filtering)
	IFNSK.				; No
	  LOAD T1,PISH,(PKT)		; Get the packet source host
	  SETZ T2,
	  CALL BSTADR			; Find best address to that
	    NOP				; shouldn't happen
;better choice?
	  MOVE T1,T2			; Our best address
	ENDIF.
	STOR T1,PISH,(CPKT)		; Set our address

	MOVE T1,[BYTE (4).INTVR,<<MINIHS+3>/4>(8)0,0,0]	; First word of packet
	MOVEM T1,PKTELI+$IPVER(CPKT)	; Save
	SETZM PKTELI+$IPSID(CPKT)	; Clear segmentation info
	MOVE T1,[BYTE (8)12,.ICMFM,0,0] ; Time to live, protocol
	MOVEM T1,PKTELI+$IPPRO(CPKT)	; Save it
	MOVE T1,HDRSIZ			; Get header size included
	ADDI T1,<<MINIHS+3>/4>+.CMINH	; Plus Internet & ICMP header
	ASH T1,2			; Convert to bytes
	STOR T1,PIPL,(CPKT)		; Save packet length

	PUSH P,PKT			; Save old packet
	PUSH P,CPKT
	MOVE PKT,CPKT			; Get new
	ADDI CPKT,PKTELI+<MINIHS+3>/4	; Point to the ICMP section

;CKPT now points at ICMP header

	HRRZ T1,ERROR			; Get error type
	STOR T1,CMTYP,(CPKT)		; Save type
	HLRZ T2,ERROR			; Get code
	STOR T2,CMCOD,(CPKT)		; Save it
	SETZM 1(CPKT)			; Unused word

	CAIN T1,ICM%PP			; Parameter problem?
	 CAIE T2,PP%PTR			; With pointer?
	  TRNA
	   STOR INFO,CMPTR,(CPKT)	; Yes, set pointer

	CAIE T1,ICM%TM			; Time request?
	IFSKP.
	  CALL INETUT			; Get time
	  STOR T1,CMTSO,(CPKT)
	  SETZRO CMTSR,(CPKT)
	  SETZRO CMTST,(CPKT)
	  MOVX T1,<MINIHS+5*4>
;	  LOAD T1,PIPL,(PKT)
	  STOR T1,PIPL,(PKT)
	ENDIF.

	AOS T1,ICMSID			; Get an Id
	STOR T1,CMSEQ,(CPKT)
	STOR T1,PISID,(PKT)
	SETZRO CMCKS,(CPKT)		; Clear checksum field
	CALL ICMCKS			; Checksum the packet
	STOR T1,CMCKS,(CPKT)		; Save it also
	LOAD T1,PIDH,(PKT)		; Get Destination Host
	CALL LCLHST			; Local?
	IFSKP.
	  CALL ICMSST			; ICMP output stats sent to self
	ELSE.
	  CALL ICMOST			; ICMP output statistics
	ENDIF.
	SETZB T1,T2			; No special first-hop routing
	CALL SNDGAT			; Send it off
					; Error check?
MNTM5	AOS CELL(ICMAA,5,,ICM)		; ICMERR messages sent
	POP P,CPKT			; Restore old contents
	POP P,PKT			; Restore old contents

ICMERX:	MOVX T2,PICMP			; Our flag bit
	ANDCAB T2,PKTFLG(PKT)		; We're done,
	TXNE T2,PFLGP			; Anyone else left?
	IFSKP.				; No
	  CAME PKT,CPKT			; Don't release if re-used
	    CALL RETPKT			; Return storage
	ENDIF.
	POP P,CPKT			; Restore
	RET				; Return

	ENDAV.
	ENDTV.

;ICMIST	Record ICMP input statistics.
;ICMOST	Record ICMP output statistics.
;ICMSST Record ICMP output statistics set to self

;CPKT/	Extended pointer to ICMP packet being received/sent.
;	CALL ICMxST
;Ret+1:	Always.


ICMSST:
MNTM5<	MOVEI T4,CELL(ICMSS,0,,ICM)>  ;Sent to self
MNTM5	SKIPA

ICMIST:
MNTM5<	MOVEI T4,CELL(ICMTR,0,,ICM)>	; Receive Statistics variable
MNTM5	SKIPA

ICMOST:
MNTM5<	  MOVEI T4,CELL(ICMTS,0,,ICM)>	; Send Statistics variable
MNTM5<	LOAD T1,CMTYP,(CPKT)>		; Get type
MNTM5	INHSTI(,,T1,T4,T2,2)		; Hist T1 to T4, using T2 (CELL(ICMTrs)
MNTM5<	SKIPN T4,XCELL(ICMTrs,1,(T4))>	; Want codes?
MNTM5	  JRST ICMST8			; No
MNTM5<	LOAD T1,CMCOD,(CPKT)>		; Code
MNTM5	INHSTI(,,T1,T4,T2)		; Hist T1 to T4, using T2 (CELL(ICMTrs)
ICMST8:
	RET


;ALTADR	This routine is used to help out remote hosts that are using the
;"wrong" address to get to us (i.e. one that is less than efficent).

;Currently it just sends a "redirect host", this is fine if the two are
;on the same net, but not if we're trying to re-direct across nets.
;There is no defined way to do that (short of source routing, which is
;probably slow enough so as to be no help).

;T1/	Protocol number
;T2/	Pointer to data block
;	Data block format is
;	0:	Foreign address
;	1:	local address
;	2:	foreign port (0 for portless protocol)
;	3:	local port   (1 for portless protocol)
;	CALL ALTADR
;Ret+1	Always.

ALTADR::
	RET				; Null routine for now
	SAVEAC <PKT,CPKT>
	ACVAR <PRO,BLK,NEW>
	MOVEM T1,PRO			; Save protocol
	MOVEM T2,BLK			; And connection block
	MOVE T1,0(BLK)			; Get foreign address
	JUMPE T1,R			; If a wild connection, do nothing.
	MOVE T2,1(BLK)			; And local he's using
	CALL BSTADR			; Find the best local address
	  RET				; He's already using it
	MOVEM T1,NEW			; Remember address

;Other host is using bad address, construct "re-direct host" and send it off.

	MOVX T1,MINICW+5		; Size of ICMP packet
	MOVX T2,NP.IP			; Protocol code
	CALL GETBUF ;(T1:T1,T2)		; Get storage
	JUMPE T1,R			; No storage
	MOVE PKT,T1			; skip buffer header

	XMOVEI T1,NBHDRL(PKT)		; IP portion of packet
	MOVEI T2,MINICW+5-NBHDRL	; Size again
	CALL CLRBLK			; Zero it

	XMOVEI CPKT,PKTELI+<<MINIHS+3>/4>(PKT) ; Point to ICMP section
					; Construct IH
	MOVE T1,[BYTE (4).INTVR,<<MINIHS+3>/4>(8)0,0,<MINIHS+MINIHS+8+4>]
	MOVEM T1,PKTELI+$IPVER(PKT)	; Save
	SETZM PKTELI+$IPSID(PKT)	; Clear segmentation info
	MOVE T1,[BYTE (8)12,.ICMFM,0,0] ; Time to live, protocol
	MOVEM T1,PKTELI+$IPPRO(PKT)	; Save it
	MOVE T1,0(BLK)			; Dest host
	STOR T1,PIDH,(PKT)
	MOVE T1,1(BLK)			; My address
	STOR T1,PISH,(PKT)
					; Construct ICMP section
	MOVE T1,[BYTE (8)ICM%RD,RD%HST,0,0]
	MOVEM T1,(CPKT)			; Redirect host
	MOVE T1,NEW
	STOR T1,CMGWA,(CPKT)		; To this "gateway"

					; Construct fake IP header in packet
	MOVEI T1,[BYTE (4).INTVR,<<MINIHS+3>/4>(8)0,0,<MINIHS+4>]
	MOVEM T1,$IPVER+.CMINH(CPKT)
	SETZM $IPSID+.CMINH(CPKT)
	SETZM $IPPRO+.CMINH(CPKT)
	MOVE T1,PRO			; Get protocol number
	STOR T1,IPPRO,+.CMINH(CPKT)
	MOVEI T1,^D255
	STOR T1,IPTTL,+.CMINH(CPKT)
	MOVE T1,0(BLK)			; "From"
	STOR T1,IPSH,+.CMINH(CPKT)
	MOVE T1,1(BLK)			; "Dest"
	STOR T1,IPDH,+.CMINH(CPKT)
	MOVE T1,2(BLK)			; "Source port"
	DPB T1,[POINT 16,.CMINH+<<MINIHS+3>/4>(CPKT),15]
	MOVE T1,3(BLK)			; "Dest port"
	DPB T1,[POINT 16,.CMINH+<<MINIHS+3>/4>(CPKT),31]

	SETZRO CMCKS,(CPKT)
	CALL ICMCKS			; Checksum the packet
	STOR T1,CMCKS,(CPKT)		; Save it also
	
	CALL ICMOST			; ICMP output statistics
	SETZB T1,T2			; No special first-hop routing
	CALLRET SNDGAT			; Send it off
					; Error check
	ENDAV.


; Keep this resident for speed of access

	RESCD	;ps Fast access

;ICMCKS	Compute Value for ICMP Checksum Field

;PKT/	Extended Pointer to Packet
;	CALL ICMCKS
;Ret+1:	Always.
;T1 has the checksum for the ICMP packet
;Can be used to checksum the data portion of any IP packet.

;cwl icmcks ought to be phased out after make sure PSSBZ/DT are always right
ICMCKS:
MNTM5	AOSA CELL(TCCAA,3,,TCC)	; ICMCKS calls

DATCKS::
MNTM5	  AOS CELL(TCCAA,1,,TCC)	; DATCKS calls
	XMOVEI T3,PKTELI(PKT)	; Address of IP header
	LOAD T1,IPDO,(T3)	; # words in IP header
	LOAD T4,IPPL,(T3)	; # bytes in packet
	ADD T3,T1		; Address of first byte
	LSH T1,2		; # bytes in IP header
	SUB T4,T1		; # data bytes to checksum
	SETZ T2,		; No partial sum
	CALLRET GENCKS		; Compute checksum



;ICCKSM	Compute Value for ICMP Checksum Field

;PKT/	Extended Pointer to Packet
;	CALL ICCKSM
;Ret+1:	Always.
;T1 has the checksum for the ICMP packet
;Can be used to checksum the data portion of any IP packet.

ICCKSM:
MNTM5	AOS CELL(TCCAA,3,,TCC)	; ICCKSM calls
	SETZ T2,		; No partial sum
	PNTLDR T3,PSSDT,(PKT)	; Address of first byte
	LOAD T4,PSSBZ,(PKT)	; Number of bytes to be summed
	CALLRET GENCKS		; Compute checksum

	SWAPCD	;ps End of fast access

;End of ICMP

;DEFACY(BFR,GW)	;ps			; Terminate special definition
;DEFACY(TPKT,CPKT)
PURGE GW,CPKT

	SUBTTL 	Internet User Queues

COMMENT !

These  routines  implement  the user interface to the Internet world.
Once assigned, an Internet queue may be  used  to  send  and  receive
messages to Internet hosts. The buffer in user space has only a count
word,  an  Internet  header and Internet text. The gateway selects an
appropriate hardware interface, generates the required  local  header
for that network and sends the packet out.

!


					; User Queue local top-level AC usage

;DEFACY(IQ,TCB);ps			; User Queue Handle
IQ==TCB


INQKFK==:R	; No fork cleanup routine

INQCZF==:R	; No files to be cleaned up



;INTLGO	Internet logout routine -- called by each job as it logs out.

INQKJB::
INTLGO::
MNTM5	AOS CELL(INUAA,1,,INU)		; INTLGO calls
	SETO T1,			; Say all Internet Queues
	RELIQ%				; Release them
	 JFCL
	RET


;User Queue Monitor Tables:			    Monitor Table
;		Waiting FORKX,,Owner's FORKX		INQFK
;		Pointer to Queue head table		INQHD
;		<ASNIQ Flags,,JOBNO> or <-1> if free	INQJB
;		Lock for INQxx				INQLK
;		# datagrams received,,# datagrams sent	INQRS
;		# received packets in INQHD+Q list	INQSP
;			(linked via PKTQ)
;		Receive Timeout or when last accessed	INQTM
;
;QDB format	Left justified bytes
;  QDB+.IQPRV	00.00.lh.pr.0	Logical host, Protocol	INQV0
;  QDB+.IQFHV	fh.ad.dr.es.0	Foreign host address	INQV1
;  QDB+.IQSHV	lh.ad.dr.es.0	Local host address	INQV2
;  QDB+.IQPTV	lo.cl.fo.rn.0	Local/Foreign ports	INQV3
;   or (AQ%SPT)	po.rt.00.00.0	or Single port
;  QDB+.IQPRM	00.00.xx.-1.0	Log.Host, Protocol mask	INQM0
;  QDB+.IQFHM	-1.-1.-1.-1.0	Foreign mask		INQM1
;  QDB+.IQSHM	-1.-1.-1.-1.0	Local mask		INQM2
;  QDB+.IQPTM	-1.-1.-1.-1.0	Ports mask		INQM3
;   or (AQ%SPT)	-1.-1.00.00.0	or Single port mask
;	.IQLEN

	SUBTTL	ASNIQ%	Assign Internet Queue JSYS.

;T1/	Flags,,pointer to QDB
;	AQ%SCR==1B0	; B0: Use secure interface.
;	AQ%SPT==1B1	; B1: Single(local) port protocol
;	AQ%ICM==1B2	; B2: Allow sending and receiving ICMP messages
;	(Other flag bits must be 0)
;T2/	(Not currently used.  Must be 0)
;T3/	(Not currently used.  Must be 0)
;	ASNIQ%	 Note: Must have Net Wiz enabled.
;Ret+1:	 Failed.  Error code in T1.
;	NTWZX1		"Net Wizard capability required"
;	ASNSX1		"All queues in use"
;	ASNSX2		"Queue already in use" T2 has conflicting job number
;Ret+2:	OK.  Internet queue handle in T1.  Max buffer count in T2.

.ASNIQ::
	MCENT				; Enter monitor
	TXNE T1,<777700000000-AQ%SCR-AQ%SPT-AQ%ICM>
	  RETERR(ARGX22)		; Illegal control bit
	CALL ASNIQA			; Get arguments & call ASNIQ0
	UMOVEM T2,2			; Return Max size before frag/job#
	UMOVEM T1,1			; Return Queue Handle/xxx


; General User Queue Exit

IQEXIT:	SKIPL T1			; -1,,Error ?
	  SMRETN			; No, ok return
	HRRZS T1			; Just error code
	RETERR ()			; Fail return with error code


; Subroutine so can use TRVAR

ASNIQA:	TRVAR <<USRARG,1+.IQLEN>>	; Flags & copy of QDB
	MOVEM T1,USRARG			; Save flags
	XMOVEI T3,1+USRARG		; For local QDB copy
	HRRZ T2,T1			; User QDB address
	MOVEI T1,.IQLEN			; QDB length
	CALL BLTUM			; Copy QDB
	XMOVEI T1,USRARG		; Address of arguments
	MOVX T4,<BYTE (8)-1,-1,-1,0(4)0> ; Logical host mask
	TDNN T4,.IQPRV+1(T1)		; Any logical host and
	 TDNE T4,.IQPRM+1(T1)		; Mask specified?
	  TRNA				; Yes, leave it alone
	   IORM T4,.IQPRM+1(T1)		; No, default to logical host 0

	CALLRET ASNIQ.			; Common routine

	ENDTV.

;ASNIQ.	Internally callable ASNIQ%.

;T1/	(Ext) address of caller's T1, QDB
;	CALL ASNIQ.
;Ret+1:	Always, T1 & T2 have: Q Handle & Siz,  or  -1,,err & Job#
;	-1,,NTWZX1	"Net Wizard capability required"
;	-1,,ASNSX1	"All queues in use"
;	-1,,ASNSX2	"Queue already in use", T2/ conflicting job number
;	-1,,ASNSX3
;	    "Insufficient capabilities to assign system reserved port numbers"

ASNIQ.::
	MOVE T3,T1			; Save Pointer for LCKCAL
	SETZ T2,			; Assume Job0 conflict
	HRROI T1,ASNSX1			; Error
	SKIPL INQON			; User Queues ON?
	  RET				; No, Cannot have queue

IFN .IQLEN-.IQPTM-1,<PRINTX ?Fix call to GTOKM in ASNIQ.>

	SKIPN ACJFN		; ACJ (Access Control Job) fork present?
	IFSKP.			; Yes...	Pass entire QDB to the ACJ
	  GTOKM(.GOAIQ,<.IQPRV+1(T3),.IQFHV+1(T3),.IQSHV+1(T3),.IQPTV+1(T3),
.IQPRM+1(T3),.IQFHM+1(T3),.IQSHM+1(T3),.IQPTM+1(T3)>,
<[	    HRROI T1,ASNSX3	; Error code
	    RET]>)		; Ask ACJ if it is OK
	ELSE.			; No, ACJ not present, do our own check
	  LOAD T1,IQSPV,+1(T3)  ; Get Local Port Value
	  LOAD T4,IQSPM,+1(T3)  ; Get Local Port Mask
	  AND T1,T4		; Make minimum value
	  CAIL T1,^D256		; Smaller than 256?
	  ANSKP.		; Yes, see if user has caps
	    MOVX T1,SC%WHL!SC%OPR!SC%NWZ!SC%NAS	 ; Wheel, Operator,
	    TDNE T1,CAPENB	; Net-Wizard, or Abs-Ana-Skts caps enabled?
	    ANSKP.		; No, see if non-system-reserved logical host
	      LOAD T2,IQLHV,+1(T3)  ; Get Logical Host Value
	      LOAD T4,IQLHM,+1(T3)  ; Get Logical Host Mask
	      AND T2,T4		; Make minimum value
	      HRROI T1,ASNSX3	; Error code
	      CAMG T2,INTLHX	; Larger than system reserved value?
		RET		; No, return error
	ENDIF.
MNTM5	AOS CELL(INUAQ,0,,INU)		; ASNIQ% after INQON/Capabilities check
	SAVEAC <IQ>
	XMOVEI T1,INQLK			; The lock to lock
	XMOVEI T2,ASNIQ0		; Function to call
	TXO T2,<261B8>			; Our ID
	CALL LCKCAL			; Call work routine while lock set
	JUMPL T1,R			; Finish up and give error return
	MOVE T2,INXPW			; Biggest count word user can give
	MOVEI T2,-PKTELI+1(T2)		; (without fragmentation)
	RET

;ASNIQ0	Guts of ASNIQ JSYS.

;T1/	(Ext) pointer to user T1, QDB copy
;INQLK/	Locked		NOINT
;	CALL ASNIQ0
;Ret+1:	Always.  T1 has queue handle, or error code
;	-1,,ASNSX1	"All queues in use"
;	-1,,ASNSX2	"Queue already in use", T2/ conflicting job number

ASNIQ0:	ACVAR <QDB,QX,FLGS>
	XMOVEI QDB,1(T1)		; Local copy of QDB
	MOVE FLGS,(T1)			; Get user flags

	MOVSI T1,-.IQLEN		; Set to scan the QDB
	HRR T1,QDB			; AOBJN pointer
	MOVEI T2,17			; Right four bits must be cleared
	DO.
	  ANDCAM T2,0(T1)
	  AOBJN T1,TOP.
	ENDDO.

; Special checks for ICMP -- Must be single "port", where "port" is ID field
; Note: "port" -1 is reserved by system (reporting errors, diagnostics, etc)

	MOVE T1,.IQPRV(QDB)		; Protocol
	CAIE T1,<BYTE (8)0,0,0,.ICMFM(4)0> ; ICMP?
	IFSKP.				; Yes
	  TXO FLGS,AQ%SPT		; Single port is CMID field
	  MOVE T2,.IQPTV(QDB)		; User-specified port value
	  TXC T2,CMID			; XOR with -1
	  AND T2,.IQPTM(QDB)		; User-specified port mask
	  TXNN T2,CMID			; User's values differ from reserved?
	    JRST ASNIQE			; No, don't allow it
	ENDIF.

	MOVX T1,<-1B15>			; Mask for single port
	TXNE FLGS,AQ%SPT		; Single port protocol?
	  ANDM T1,.IQPTM(QDB)		; Yes. Flush comparison on foreign port

	MOVSI QX,-NIQ			; Set to scan the queue tables
	MOVEI IQ,0			; Indicate no free slot found yet
	DO. (ASNIQ4)
	  MOVE T1,INQJB(QX)		; Get owner
	  CAME T1,[-1]			; Free?
	  IFSKP.			; Yes
	    SKIPN IQ			; Already know of a free slot?
	      MOVE IQ,QX		; No so save this one.
	  ELSE.				; Assigned, check for conflict
	    MOVE T1,.IQPRM(QDB)		; Get protocol mask from user's blk
	    AND T1,INQM0(QX)		; Compute least specific mask
	    MOVE T2,.IQPRV(QDB)		; Get value word
	    XOR T2,INQV0(QX)		; Compare against this queue
	    TDNE T1,T2			; But only in the bits that matter
	    ANSKP.			; Difference is OK.  Try next.
	      MOVE T1,.IQFHM(QDB)	; Same for foreign host
	      AND T1,INQM1(QX)
	      MOVE T2,.IQFHV(QDB)
	      XOR T2,INQV1(QX)
	      TDNE T1,T2
	      ANSKP.			; Difference is OK.  Try next.
	        MOVE T1,.IQSHM(QDB)	; Same for local host
	        AND T1,INQM2(QX)
	        MOVE T2,.IQSHV(QDB)
	        XOR T2,INQV2(QX)
	        TDNE T1,T2
	        ANSKP.			; Difference is OK.  Try next.
	          MOVE T1,INQJB(QX)	; Get flags
	          XOR T1,FLGS		; Compare with request
	          TXNE T1,AQ%SPT	; Differ only in 1/2 port spec?
	          IFSKP.		; No
	            MOVE T1,.IQPTM(QDB)	; Compare port word
	            AND T1,INQM3(QX)
	            MOVE T2,.IQPTV(QDB)
	            XOR T2,INQV3(QX)
	            TDNN T1,T2
	            ANSKP.
					; Have a difference, this queue ok
	          ELSE.			; Give fail return due to conflict
	            HRRZ T1,INQJB(QX)	; Get job number owning this queue
IFN REL6,<				; Only if we are release 6
	            CALL LCL2GL		; Get the global job number
	              SETZ T1,>		; in case of error return
	            MOVE T2,T1
	            HRROI T1,ASNSX2	; "Queue already in use"
MNTM5	            AOS CELL(INUAQ,2,,INU) ; ASNIQ q-in-use (not ICMP)
	            RET			; Return failure
	          ENDIF.
	  ENDIF.			; Doesn't conflict with this queue
	  AOBJN QX,TOP.			; Try next
	ENDDO.

	IFE. IQ				; Find an unused queue?
	  SETZ T2,			; No
	  HRROI T1,ASNSX1		; "All queues in use"
MNTM5	  AOS CELL(INUAQ,1,,INU)	; ASNIQ no-free-q failures
	  RET
	ENDIF.
					; Assign queue to user
	HRRZS IQ			; Just queue index for section-0 access
	MOVE T1,JOBNO			; Our job number
	MOVEM T1,INQJB(IQ)		; Assign queue to job (so can purge it)
	CALL REL1IQ ;(IQ)		; Flush old packets (and deassign it)
				;****	  REL1IQ must proceed setting INQJB
	MOVE T1,JOBNO			; Our job number
	HLL T1,FLGS			; Merge in the flags
	MOVEM T1,INQJB(IQ)		; Assign queue to this job

	MOVE T1,FORKX			; Fork ID of creator
	HRROM T1,INQFK(IQ)		; No fork waiting,,owner's FORKX
					; (Fork for RCVIN% interrupt & support)

	MOVE T1,.IQPRM(QDB)		; Copy into queue tables
	MOVEM T1,INQM0(IQ)
	AND T1,.IQPRV(QDB)		; Save value bits corresponding to mask
	MOVEM T1,INQV0(IQ)
	MOVE T2,.IQFHM(QDB)
	MOVEM T2,INQM1(IQ)
	AND T2,.IQFHV(QDB)
	MOVEM T2,INQV1(IQ)
	MOVE T3,.IQSHM(QDB)
	MOVEM T3,INQM2(IQ)
	AND T3,.IQSHV(QDB)
	MOVEM T3,INQV2(IQ)
	MOVE T4,.IQPTM(QDB)
	MOVEM T4,INQM3(IQ)
	AND T4,.IQPTV(QDB)
	MOVEM T4,INQV3(IQ)

	MOVE T1,IQ			; Get the queue handle for user
	RET				; Success return

ASNIQE:	SETZ T2,			; Conflict w/ Job0 (reserved by system)
	HRROI T1,ASNSX2			; "Queue already in use"
MNTM5	AOS CELL(INUAQ,2,,INU)		; ASNIQ q-in-use (ICMP/lgl hst)
	RET				; Return failure

	ENDAV.

	SUBTTL	RELIQ%	Release Internet Queue JSYS.

;T1/	Internet Queue Handle or -1 for all owned by this job or
;	(multiple) fork handle for all owned by requested fork(s).
;	RELIQ%
;Ret+1:	 Failure.  Error code in T1
;	SQX1		"Special network queue handle out ot range"
;	SQX2		"Special network queue not assigned" to this job
;			or networks not initialized
;Ret+2:	Success

.RELIQ::
	MCENT				; Enter monitor
	SKIPLE INQON			; Are User Queues initialized?
	  RETERR(SQX2)			; No, can't be assigned
					; Allow deassign if turned OFF
MNTM5	AOS CELL(INUAA,2,,INU)		; Count RELIQ JSYS
	MOVE IQ,T1			; Assume queue handle or -1
	AOSN T1				; Check for -1
	IFSKP.
	  HRRZ T1,IQ			; No, check RH only
	  CAIGE T1,NIQ			; Is it a queue handle?
	  ANSKP.			; No, check for multiple fork handle
	    CAIL T1,.FHJOB		; Multiple handle?
	    IFSKP.
	      CAIL T1,.FHSLF		; No, Job relative handle?
	       CAIL T1,.FHSLF+NLFKS
	        RETERR (SQX1)		; Neither, bad IQ handle error
	    ENDIF.			; Job relative handle, continue
	    CALL FLOCK			; Lock fork structure
	    MOVX T2,<CALL RLIQFK>	; Call this routine
	    CALL MAPFKH ;(T1,T2)	; Per fork
	      NOP			; Never blocks
	    CALL FUNLK			; Unlock fork structure
	    SMRETN			; All done
	ENDIF.
					; Arg was -1, or Queue Handle
	XMOVEI T1,INQLK			; The lock to lock
	XMOVEI T2,RELIQ0 ;(IQ)		; Function to call
	TXO T2,<271B8>			; Our ID
	CALL LCKCAL
	JRST IQEXIT


;Lock INQLK and do work per fork.  LCKCAL of INQLK needs to be here
;so MAPFKH won't ITRAP with INQLK locked.  Arg in T1

RLIQFK:	MOVE T3,T1			; Place FORKN for LCKCAL
	XMOVEI T1,INQLK			; The lock to lock
	XMOVEI T2,RLIQF0		; Function to call
	TXO T2,<272B8>			; Our ID
	CALL LCKCAL			; LCKCAL of INQLK needs to be here so
	RET				; MAPFKH won't ITRAP with INQLK locked.

; Work routine for RLIQFK. Called with T1 a FORKN & INQLK locked

RLIQF0:	ACVAR <FKX>			; Get FORKX corresponding
	HRRZ FKX,SYSFK(T1)		; to MAPFKH's FORKN
	MOVSI IQ,-NIQ			; Scan all queues
	DO.
	  CALL CHKIQ ;(IQ)		; Check if owned by this job
	  IFGE. T1			; Yes
	    HRRZ T1,INQFK(IQ)		; Get owning FORKX
	    CAME T1,FKX			; Owned by this fork?
	    ANSKP.
	      HRRZ T1,IQ		; Yes
	      JFCL	;CALL		; User Queue Accouting Functions
	      CALL REL1IQ ;(IQ)		; Release it and deassign it
	  ENDIF.
	  AOBJN IQ,TOP.			; Loop through all queues
	ENDDO.
	RET

	ENDAV.

;RELIQ0	Innards of RELIQ.

;IQ/	Queue Handle or -1 for all
;INQLK/	Locked	NOINT
;	CALL RELIQ0
;Ret+1:	Always.  (T1 eq 0)

RELIQ0:	CAME IQ,[-1]			; Asked to do all for this job? (-1)
	 TLOA IQ,-1			; No.  Set AOBJN ptr to do just one
	  MOVSI IQ,-NIQ			; Yes.  Set up for all
	DO.
	  CALL CHKIQ ;(IQ)		; Check access.
	  IFGE. T1
	    HRRZ T1,IQ
	    JFCL	;CALL		; User Queue Accouting Functions
	    CALL REL1IQ ;(IQ)		; Flush packets in queue & deassign it
	  ENDIF.
	  AOBJN IQ,TOP.
	ENDDO.
	SETZ T1,			; Always successful
	RET


;REL1IQ Flush packets in and deassign queue if it is owned by calling job.

;IQ/	Internet Queue Handle (LH may be negative)
;INQLK/	Locked		NOINT
;	CALL REL1IQ
;Ret+1:	Always.  INQJB set to -1, INQSP to 0, and INQTM to TODCLK

REL1IQ:	SAVEAC <PKT>
	HRRZ T2,INQJB(IQ)		; Which job owns this one
	CAME T2,JOBNO			; Us?
	  RET				; No.
	DO.
	  CALL INQGET ;(IQ)		; Get a message if possible
	  IFGE. T1			; IF got a packet
	    MOVE PKT,T1			; Argument for RETPKT
	    CALL RETPKT			; Return the storage to free area
	    LOOP.			; Loop til queue empty
	  ENDIF.
	ENDDO.
	SETOM INQJB(IQ)			; Deassign the queue
	SETZM INQSP(IQ)			; Make sure no messages
	SETZM INQRS(IQ)			; Nothing sent/received
	MOVE T1,TODCLK			; Record when queue
	MOVEM T1,INQTM(IQ)		; was deassigned
	RET

	SUBTTL	RCVIN%	Receive an Internet Segment JSYS.

;T1/	Flags,,Internet Queue Handle
;		RIQ%NW On to give error return instead of waiting
;T2/	Buffer pointer/ <act,,max, inc this>,<IP header>,<IP data>
;T3/	(Not currently used.  Must be 0)
;	RCVIN%
;Ret+1:	 Failed.  Code in T1.
;	SQX1		"Special network queue handle out ot range"
;	SQX2		"Special network queue not assigned" to this job
;			or off
;	-1		No datagram available & RIQ%NW was set
;	SNDIX1		"Invalid message size" (truncated message returned)
;Ret+2:	Success.

.RCVIN::
	MCENT				; Enter the monitor
MNTM5	AOS CELL(INURM,0,,INU)		; Count RCVIN% JSYS
	CALL RCVN.			; Want local variables
	JRST IQEXIT

RCVN.:	SKIPL INQON			;CS147 IQ on?
	 JRST [	HRROI T1,ASNSX1		;CS147 No.
		RET]			;CS147 Reject accordingly
	ACVAR <BUF,ERC>
	MOVEM T2,BUF
	XCTU [HRRZ T2,0(BUF)]		; Get user's buffer size
	CALL RCVIN.			; Do work
	MOVE ERC,T1			; Save error code
	IFGE. T1			; No error
	  XCTU [HRLM T2,0(BUF)]		; Tell user what's needed/present
	  SOSG T1,T3			; Don't count the count word
	    AOS ERC			; User area too small??
	  XMOVEI T2,PKTELI(PKT)		; First word in Internet part
	  MOVEI T3,1(BUF)		; First word in user's data area
	  SKIPLE T1			; No room for data
	    CALL BLTMU			; Transfer it to the user
	ENDIF.
	SKIPLE PKT			; If have a packet,
	  CALL RETPKT			; Return the packet storage
	SKIPN T1,ERC			; Error code
	  RET				; No error
	IFG. T1
	  HRROI T1,SNDIX1		; Size error
MNTM5	  AOS CELL(INURM,4,,INU)	; RCVIN% truncation error
MNTM5	  RET
	ENDIF.
MNTM5<	CAMN T1,[-1]>			; Nothing waiting error (RIQ%NW was 1)
MNTM5	 AOSA CELL(INURM,2,,INU)	; RCVIN% with empty user queue
MNTM5	  AOS CELL(INURM,1,,INU)	; RCVIN% user errors
	RET
	ENDAV.

;RCVIN.	Internal RCVIN% routine.

;T1/	Flags+Queue Handle
;T2/	User's (max) buffer size
;	CALL RCVIN.
;Ret+1:	Always, T2/  Actual size for user,  T1 eq 0 if ok, or	
;	-1		No datagram available & RIQ%NW was set
;	-1,,SQX1	"Special network queue handle out ot range"
;	-1,,SQX2	"Special network queue not assigned" to this job
;	0,,SNDIX1	"Invalid message size"
;	T3/ transfer size (Min(T2,SIZ)  PKT/ Extended packet pointer, or 0

RCVIN.::
	SAVEAC <IQ>
	ACVAR <RIQFLG,SIZE>
	HRRZ IQ,T1			; Save Queue handle & available size
	DMOVE RIQFLG,T1			; Save flags and size
	SETZ PKT,			; No packet
	DO.
	  NOINT
	  CALL CHKIQ ;(IQ)		; See if we have access to it
	  SETZ T3,			; Nothing to return if no access
	  JUMPL T1,RCVINX		; Jump if no access (T1/ SQX1 or SQX2)
	  CALL INQGET ;(IQ)		; Try to get a segment from that queue
	  JUMPG T1,ENDLP.		; If T1 has extended packet pointer
	  TXNE RIQFLG,RIQ%NW		; Check the "don't wait" flag
	    JRST RCVINX			; Don't wait, return -1 (from INQGET)
	  MOVE T1,FORKX			; Must wait.  Get our fork number
	  HRLM T1,INQFK(IQ)		; Leave it for when segment arrives
	  OKINT
	  XMOVEI T1,INQFK(IQ)		; The cell to wait on
	  CALL DISL			; Wait for it to be cleared
	  LOOP.				; Go try again
	ENDDO.				; Still NOINT,  T1/ Ext packet pointer

MNTM5	AOS CELL(INURM,3,,INU)		; RCVIN% datagrams recv (trunc=INURM,1)
	MOVX CX,<1,,0>
	ADDM CX,INQRS(IQ)		; Count datagrams received by RCVIN.
	MOVE PKT,T1			; Put packet pointer in proper place
	LOAD T2,PIPL,(PKT)		; Get the Internet pkt length in bytes
	ADDI T2,4+3			; Allow for bfr length word.  Round up.
	ASH T2,-2			; Number wrds needed, incl count wrd

	SETZ T1,			; Assume no truncation error
	MOVE T3,SIZE			; So transfer it all
	CAMG T2,T3			; Enough space available?
	 SKIPA T3,T2			; Yes.  No error, return it all
	  HRRZI T1,SNDIX1		; No. Give error & return portion

RCVINX:	OKINT				; For fatal error returns
	RET

	ENDAV.
	SUBTTL	SNDIN%	Send an Internet User Queue Datagram JSYS.

;T1/	Flags,,Internet Queue Handle (No flags defined.  Must be 0)
;T2/	Buffer Address/ <words, inc this>,<IP header>,<IP data>
;T3/	Local net address for source route
;	SNDIN%
;Ret+1:	 Failed.  Error code in T1.
;	ASNSX1		"All queues in use", ie, shut off
;	SQX1		"Special network queue handle out ot range"
;	SQX2		"Special network queue not assigned" to this job
;	SNDIX1		"Invalid message size"
;	SNDIX2		"Insufficient system resources (No buffers)"
;	SNDIX4		"Invalid header value for this queue"
;Ret+2:	Success.

RUT==Q1
BUF==Q2
SIZ==Q3

.SNDIN::
	MCENT				; Enter monitor
MNTM5	AOS CELL(INUSM,0,,INU)		; SNDIN% JSYS
	MOVE IQ,T1
	MOVE BUF,T2
	MOVE RUT,T3
	XCTU [HRRZ SIZ,0(BUF)]		; Get size of user's buffer area

	HRROI T1,ASNSX1			; Assume error
	SKIPL INQON			; User Queues ON?
	  JRST IQEXIT			; No, Cannot send

	CAILE SIZ,<<MINIHS+3>/4>	; Must have size word & min IP header
	IFSKP.
	  HRROI T1,SNDIX1		; "Invalid message size"
MNTM5	  AOS CELL(INUSM,1,,INU)	; SNDIN user failures
	  JRST IQEXIT
	ENDIF.

	MOVEI T1,PKTELI-1(SIZ)		; Size of buffer required (for GETBUF)
	CAMLE T1,INXPW			; Must fit in our biggest packets
	IFSKP.
	  MOVX T2,NP.IP			; Protocol code
	  CALL GETBUF ;(T1:T1,T2)	; Get a chunk of free storage
	ELSE.				; Very large packet will be fragmented
	  CALL GETBLK			; Get buffer large buffers
	  SKIPG PKT,T1			; Address or zero
	  ANSKP.			; Got it
	    MOVE T1,PROOVH+NP.IP	; Protocol's overhead, words
	    CAILE T1,PKTELI-1(SIZ)	; Make sure don't exceed allocation
	      MOVEI T1,PKTELI-1(SIZ)	; Shouldn't ever get here with big buf
	    MOVE T2,PKT			; Address of buffer
	    XMOVEI T3,1(T2)		; Destination for clearing
	    SETZM (T2)			; Zero first word
	    CALL XBLTA			; Zero the rest

	    MOVEI T1,PKTELI-1(SIZ)	; Does, so use actual allocation
	    STOR T1,NBSIZ,(PKT)		; Allocated words in buffer
	    MOVEI T2,NP.IP		; Protocol code
	    STOR T2,NBPRO,(PKT)
	    MOVE T1,PKT			; Have it
	ENDIF.
	SKIPE PKT,T1			; Remenber address
	IFSKP.
	  HRROI T1,SNDIX2		; "Insufficient sys res (No buffers)"
MNTM5	  AOS CELL(INUSM,2,,INU)	; SNDIN no-space failures
	  JRST IQEXIT
	ENDIF.

	MOVEI T1,-1(SIZ)		; Number of data words in user's area
	LSH T1,2			; Bytes	
	STOR T1,PTPBZ,(PKT)		; Length at transport level
	MOVEI T1,-1(SIZ)		; Number of data words in user's area
	MOVEI T2,1(BUF)			; First user data word
	XMOVEI T3,PKTELI(PKT)		; First address in monitor area	
	CALL BLTUM			; Move it into the monitor

	MOVE T1,IQ			; Queue handle
	MOVE T2,RUT			; Route or 0
	CALL SNDIN.			; Do work
	JRST IQEXIT

	PURGE RUT,BUF,SIZ


;SNDIN.	User/monitor callable routine to send internet datagrams.

;T1/	Queue Handle
;T2/	Route or 0  *** NB: first hop address MUST also be in Caller's 3 ***
;PKT/	(Ext) packet pointer
;	CALL SNDIN.
;Ret+1:	Always, T1 has -1,,err if error
;	-1,,SQX1	"Special network queue handle out ot range"
;	-1,,SQX2	"Special network queue not assigned" to this job
;	-1,,SNDIX1	"Invalid message size"
;	-1,,SNDIX4	"Invalid header value for this queue"

SNDIN.::
	SAVEAC <VNCT,IQ>
MNTM5	AOS CELL(INUSM,3,,INU)		; Count SNDIN. calls (.SNDIN+internal)
	ACVAR <RUT>
	NOINT
	HRRZ IQ,T1
	MOVE RUT,T2

	CALL CHKIQ ;(IQ)		; See if we have access to it
	JUMPL T1,SNDIN9			; Jump if not

	LOAD T1,PIVER,(PKT)		; Pick up the Internet version
	CAIE T1,.INTVR			; Is that right?
	  JRST SNDIN8			; No, Invalid header error

;Make sure the local source address is there

	LOAD T1,PISH,(PKT)		; Get packet source
	IFE. T1				; User didn't specify local address
	  LOAD T1,PIDH,(PKT)		; Destination may tell which interface
	  SETZ T2,
	  CALL BSTADR			; Find best address to use
	   NOP				; Shouldn't happen
;cwl error code back
	  MOVE T1,T2
	  LSH T1,4			; Left justify
	  ANDCM T1,INQM2(IQ)		; Keep local bits which may vary
	  MOVE T2,INQV2(IQ)		; Get fixed local bits
	  AND T2,INQM2(IQ)		; Only the fixed bits
	  IOR T1,T2			; Put them together
	  LSH T1,-4			; Right justify
	  STOR T1,PISH,(PKT)		; Hope its legit
	ENDIF.
	CALL LCLHST			; Is it one of us?
	  JRST SNDIN8			; No, Bad address


; Validate datagram is from the queue

	SETO T1,			; Send direction
	CALL VALIPQ			; Is datagram for this queue?
	  JRST SNDIN7			; +1 Error, IPPL
	  JRST SNDIN8			; +2 Error, CMTYP
	  JRST SNDIN8			; +3 No
					; +4 Yes
;Allow the datagram to be sent.

	MOVE T1,INQJB(IQ)		; Get flags
	TXNN T1,AQ%SCR			; RPI desired?
	IFSKP.				; Yes
	  SETONE PSCR,(PKT)		; Flag the packet for that interface
	ENDIF.

	MOVE T1,RUT			; Special first-hop routing
	CALL SNDGAT			; Send it. Low lvl code will return stg
	SETZ PKT,
	TXNE T1,NE%DRP			; Drop packet?
	IFSKP.
	  AOS INQRS(IQ)			; Count packets sent for this queue
MNTM5	  AOS CELL(INUSM,5,,INU)	; Total User-Q packets sent by SNDIN
	ENDIF.
	CAIN T1,MNTX00			; OK?
	 TDZA T1,T1			; Yes
	  TXO T1,1B0			; Negative for error code
	JRST SNDINX
					; Error returns
SNDIN7:	HRROI T1,SNDIX1			; "Invalid message size"
	JRST SNDIN9			; Header size problem: SIZ, PIPL

SNDIN8:	HRROI T1,SNDIX4			; "Invalid header value for this queue"
					; PIDO, ports, PIVER, PIPRO, S, D
SNDIN9:	PUSH P,T1			; -1,,SQX1 or -1,,SQX2
	CALL RETPKT			; Return storage used for packet
	SETZ PKT,
	POP P,T1
MNTM5	AOS CELL(INUSM,4,,INU)		; SNDIN user failures

SNDINX:	OKINT
	RET

	ENDAV.
	SUBTTL	User Queue Support routines

;INQGET	Get a message (Internet segment) from specified queue.

;IQ/	Internet Queue Handle (LH may be negative)
;INQLK/ Locked		NOINT
;	CALL INQGET
;Ret+1:	Always.  T1 has pointer to message if any, or is -1 if none

INQGET:	HRRZ T1,IQ
IFE QSZ-2,<LSH T1,1>			; * QSZ
IFG QSZ-2,<IMULI T1,QSZ>
	NOSKED				; Prevent simultaneous access to Q
	ADD T1,INQHD			; Compute address of queue head
	MOVE T2,T1
	LOAD T1,QNEXT,(T2)		; Get first thing on queue
	CAMN T1,T2			; If that is the queue head itself,
	IFSKP.				; Queue isn't empty
	  CALL DQ			; Dequeue the message and return in T1
IFN PKTQ,<XMOVEI T1,-PKTQ(T1)>		; Point to top of structure
	  SOS INQSP(IQ)			; Credit space to queue
					; Success return. T1 has the message
	ELSE.				; Queue empty
	  SETO T1,			; Fail return.
	ENDIF.
	OKSKED
	MOVE T2,TODCLK			; "Now"
	SKIPLE INQSP(IQ)		; Messages remaining?
	  ADD T2,INQT0			; Yes, Bump no-activity time out
	MOVEM T2,INQTM(IQ)		; Otherwise record when examined
	RET

;LHCEK	Check non-zero logical host values.

;T1/	Masked logical host field (e.g. 32-bit address & mask)
;T2/	Protocol code
;VNCT/	Pointer to NCT
;	CALL LHCEK
;Ret+1:	Always, if for a logical host, T2/ <log.ical.host.protocol>)

LHCEK:	LDB T3,NTNLHB(VNCT)		; Get logical host field
	CAMG T3,INTLHX			; Deliver to protocol or user queue?
	  RET				; Protocol
	LSH T3,<WID(PIPRO)>
	IOR T2,T3			; Logical Host,Protocol
	RET				; User Queue(Make protocol checks fail)



;VALIPQ	See whether packet pointed to by PKT belongs to User Queue IQ.

;T1/	0 - received packet, nz - packet to be sent
;PKT/	Extended pointer to a packet.
;IQ/	User queue handle/index
;	CALL VALIQP
;Ret+1:	  Length error - packet too short to hold all transport layer data
;Ret+2:	  Bad ICMP type code
;Ret+3:   Not for user queue, T1/ ICMP destination unreachable error code,,type
;Ret+4:	For this user queue

VALIPQ:
	PUSH P,T1			; Save direction flag
	LOAD T2,PIPRO,(PKT)		; Internet protocol (physical)
	LOAD T3,PISH,(PKT)		; Sender's local address
	SKIPN (P)			; Packet to be sent?
	  LOAD T3,PIDH,(PKT)		; No, received
	NETNUM T1,T3			; Find local address's NCT
	CALL NETNCT ;(T1:VNCT)		; Find desired local interface
	 TDZA T3,T3			; None ???
	  AND T3,NTNLHM(VNCT)		; Logical host mask for that net
	SKIPE T1,T3			; Logical host 0 uses system protocols
	  CALL LHCEK ;(T1,T2:T1,T2)	; Check non-zero logical host values
	MOVE T1,T2			; Log.ical.host.protocol

	LOAD T3,PIPL,(PKT)		; Packet length in bytes
	ADDI T3,3			; Set to round up
	ASH T3,-2			; Number of words which must be present

	LOAD T2,PIDO,(PKT)		; Get data offset in 32-bit words
	LOAD T4,PTPBZ,(PKT)		; Length at transport (IP) level
	ADDI T4,3			; Set to round up
	LSH T4,-2
	CAMG T3,T4			; PIPL words .lt. data words
	 CAIGE T2,<MINIHS+3>/4		; PIDO .ge. a full header
	  JRST VALIPX			; No.  Length error, +1 return

	SKIPE INQM3(IQ)			; Filtering on ports?
	 CAIGE T2,0(T3)			; Yes, PIDO+1 le PIPL w(need port(s))
	  CAILE T2,0(T3)		; No, PIDO le PIPL w(need min header)
	   JRST VALIPX			; Don't, length error, +1 return

	AOS -1(P)			; Skip at least one (+2, +3, +4)
	ADD T2,PKT			; Pointer to packet+c(IPDO)

;Case 1, Not ICMP
;T1/ Logical host,Protocol, T2/ Packet @ IP "data", T4(LF)/ports

	MOVE T4,PKTELI(T2)		; Get (case 1) port word
	LOAD T3,PIPRO,(PKT)		; Internet protocol (physical)
	CAIE T3,.ICMFM			; ICMP?
	IFSKP.				; Yes

;Case 2 or 3:  An ICMP packet.  The ICMP Type implies whether or not an
; IP header is included in the ICMP message.

	  LOAD T3,CMTYP,+PKTELI(T2)	; Get ICMP Type
	  CAIG T3,IF%MAX		; Valid Type?
	   SKIPN T3,ICMPFD(T3)		; Yes, Get fields for this Type
	    JRST VALIPX			; No, or no fields, error

;Case 2, ICMP w/o included packet
;T1/ ICMP, T2/ Packet @ IP "data" = ICMP header, T4(LF)/CMID

	  MOVE T4,PKTELI+$CMID(T2)	; (Case 2) CMID is used for port word
	  TXNN T3,IF%INH		; This Type have included IP header?
	  ANSKP.			; No, Case 2

;Case 3, ICMP w/ included packet.
;Make sure ICMP messages are enabled, then check the protocol and ports
;in the included IP header.  Beware routing options (omit checks).

	    MOVX T1,<DU%PRO,,ICM%DU>	; Protocol unreachable if not enabled
	    MOVE T3,INQJB(IQ)		; Get flags
	    TXNN T3,AQ%ICM		; ICMP messages enabled?
	      JRST VALIPN		; No, return a failure, +3 return

	    LOAD T1,PIPRO,+.CMINH(T2)	; Get protocol from the included header
	    LOAD T4,PIDO,+.CMINH(T2)	; Get included header's length
	    ADD T4,T2			; Add base pointer (less PKTELI+.CMINH)
	    MOVE T4,PKTELI+.CMINH(T4)	; Get included port word.

;If this is a two-port protocol, the included packet port word has For/Loc
;which must be swapped.

	    TXNE T3,AQ%SPT		; Single port?
	    IFSKP.			; No, two so have to swap port fields
	      MOVE T3,T4		; Both have F,L,0
	      LSH T3,-4			; Right justify L
	      LSHC T3,-20		; L,F,x
	    ENDIF.

	    LOAD T3,PIDO,+.CMINH(T2)	; Get included data offset
	    CAIE T3,<<MINIHS+3>/4>	; Any options
	    ANSKP.			; No (included addresses may be in
					; routing options, omit checking them)
;We can also check that the included packet's Src(F) and Dst(L) are ok for Q.

	      MOVE T3,PKTELI+.CMINH+$IPSH(T2) ; Source is foreign
	      MOVE T2,PKTELI+.CMINH+$IPDH(T2) ; Destination is local
	ELSE.
	  MOVE T2,PKTELI+$IPSH(PKT)	; Get source/local
	  MOVE T3,PKTELI+$IPDH(PKT)	; And destination/foreign
	ENDIF.

;T1/Logical host,Protocol,  T2/Local address,  T3/Foreign address,  T4/Port(s).

	SKIPE (P)			; Send or receive
	IFSKP.				; Receive, must switch foreign/local
	  EXCH T2,T3			; Host addresses
	    MOVE CX,INQJB(IQ)		; Get flags
	    TXNE CX,AQ%SPT		; Single port?
	    ANSKP.			; No, two so have to swap port fields
	      MOVE CX,T3
	      MOVE T3,T4		; Both have L,F,0
	      LSH T3,-4			; Right justify F
	      LSHC T3,-20		; F,L,x
	      MOVE T3,CX
	ENDIF.

	AOS -1(P)			; Assume +3 return - not for queue
	CALL TSTIQP ;(T1-T4,IQ)		; All good for this Q?
	 TRNA				; Not this queue (+3 return, T1 set)
VALIPN:	  AOS -1(P)			; +4 return (+3 if enter at label)
VALIPX:	POP P,(P)			; Drop direction flag
	RET

;Table of ICMP packet Fields by message Type.


;Get $CMID defined.
	%CMID (<;>)


;Following macro gets called for each ICMP Type with a list of its fields.
;It calls ICMPFD to set ..IF% to the configuration word for a Type.

DEFINE ICMPTP(nam,sym,val,cod,fields,codsym,a1,a2)<
IFG <val&177777>-IF%MAX,<IF%MAX==<val&177777>>	; Get max table length
..IF%==0				; Initialize configuration value
IRP fields,<ICMPF0 fields>		; Set bits in it
	RELOC ICMPFD+<val&177777>	; Move to proper position in table
	EXP ..IF%			; Configuration word
> ;; End of DEFINE ICMPTP


;Strip off brackets.

DEFINE ICMPF0(arg)<ICMPF1(arg)>		; Separate <field name,length> pair


;For each field, define the field name (if it isn't) and OR its bit into ..IF%

DEFINE ICMPF1(icfld,iclen)<
IFNDEF IF%'icfld,<IF%'icfld==NXTBIT	; Define a symbol for each field name
		  NXTBIT==NXTBIT/2>	; Bit for next name
..IF%==..IF%+IF%'icfld			; Set bit in configuration value
> ; End of DEFINE ICMPF1


;Now build the table.

IF%MAX==0				; Max Type defined
NXTBIT==200000000000			; First bit (Positive for divide)

ICMPFD:	ICMPDF				; Table of ICMP packet fields by Type

	RELOC ICMPFD+IF%MAX+1		; Location after table

; Now build the table indexed by type code that says we can send an ICMP
;message about an ICMP message.
DEFINE ICMPTP(nam,sym,val,cod,fields,codsym,a1,a2)<
	RELOC ICMPFE+<val&177777>
	EXP val&1b0;;1B0 means we can send ICMP messages about ICMP messages 
> ;; End of DEFINE ICMPTP

ICMPFE:	ICMPDF

	RELOC ICMPFE+IF%MAX+1		; Location after table

	PURGE ..IF%,NXTBIT


;TSTIQ	Check that parameters match a User Queue, excluding ports.
;TSTIQP	Same, but ports are also checked.

;T1/	Protocol, right justified
;T2/	Local host, left justified
;T3/	Foreign host, left justified
;T4/	Port word (Local,Foreign or Single), left justified
;IQ/	Queue handle
;	CALL TSTIQ(P)
;Ret+1:	  Error, not match queue,  T1/ ICMP error code
;Ret+2:	Paremeters match the given Q

TSTIQP:	CALL TSTIQ			; Make higher level checks first
	  RET				; Not for host or protocol, T1 set
	XOR T4,INQV3(IQ)		; Ports
	TDNN T4,INQM3(IQ)		; Match?
	  RETSKP			; Yes
	MOVX T1,<DU%PRT,,ICM%DU>	; No, port unreachable
	RET


TSTIQ:	XOR T2,INQV2(IQ)		; Local
	XOR T3,INQV1(IQ)		; Foreign

	TDNN T2,INQM2(IQ)		; Local host match and
	 TDNE T3,INQM1(IQ)		; Foreign host match
	IFSKP.				; Yes
	  LSH T1,4			; Shift
	  XOR T1,INQV0(IQ)		; Logical host/protocol
	  TDNN T1,INQM0(IQ)		; Logical host/protocol match?
	    RETSKP			; All match
	  AND T1,[BYTE (8)-1,-1,-1,0]	; Just logical host
	  TDNE T1,INQM0(IQ)		; Host match?
	  ANSKP.			; Yes
	    MOVX T1,<DU%PRO,,ICM%DU>	; Protocol unreachable
	ELSE.
	  MOVX T1,<DU%HST,,ICM%DU>	; Host unreachable
	ENDIF.
	RET				; Mismatch

	SUBTTL	User Queue Process

;INQPRC	Internet User Queue Process.

;Dispatch Internet messages to a user-assigned queue.
;Find next run time (when a queue timesout).

;	CALL INQPRC
;Ret+1:	Always. Packets queued to user or flushed; INQTIM set

INQPRC::
	SAVEAC <VNCT,PKT,IQ>
MNTM5	AOS CELL(INUAA,3,,INU)		; INQPRC calls
	ACVAR <NPKTS>
	SETZB NPKTS,INQFLG		; No pkts processed nor rerun required
	SKIPL INQON			; User Queues ON?
	  JRST INQPRX			; No??
	DO.				; Pass out all packets
	  MOVE T2,INQIPQ		; Locate Queue head
	  NOSKED
	  LOAD T1,QNEXT,(T2)		; Get first thing
	  CAMN T1,T2			; Empty?
	    EXIT.			; Yes
	  CALL DQ
	  OKSKED
	  AOS NPKTS			; Count packets processed this run
	  XMOVEI T3,-PKTQ(T1)		; Arg for routine is packet
	  XMOVEI T1,INQLK		; Internet queue lock
	  XMOVEI T2,INQDSP		; Routine to call
	  TXO T2,<221B8>		; Our ID
	  CALL LCKCAL			; Call routine while lock set
	  LOOP.				; Get rest
	ENDDO.
	OKSKED
	XMOVEI T1,INQLK			; Lock to lock
	XMOVEI T2,INQCH0		; Function to call
	TXO T2,<222B8>			; Our ID
	CALL LCKCAL
					; Histogram reschedule interval
MNTM5<	MOVE T2,T1>			; Scheduled time
MNTM5<	SUB T2,TODCLK>			; Time from now
MNTM5	INHIST(INUHS,INU,T2,T4,T3)	; INQPRC reschedule histogram, CELL(

	MOVE T2,TODCLK
	ADDI T2,100			; Minimum time
	CAMGE T1,T2			; Take larger
	  MOVE T1,T2
	MOVEM T1,INQTIM			; Next timeout
INQPRX:

					; Update input queue stats for this run

MNTM5<	SKIPGE T4,INQIPQ-.INTPQ+.INTPM> ; Get pointer to input queue stats
MNTM5<	 CAMG T4,[-5,,0]>		; Big enough
MNTM5	  JRST INQPRZ			; No
MNTM5<	MOVN T1,NPKTS>			; To decrement queue length
MNTM5<	ADDM T1,XCELL(inqipq,0,(T4))>	; "Zero" queue length
MNTM5<	ADDM NPKTS,XCELL(inqipq,4,(T4))>; Count total packets processed
MNTM5	SKIPN NPKTS			; Queue empty?
MNTM5	  AOS XCELL(inqipq,1,(T4))	; Yes, count unnecessary runs
INQPRZ:	RET

	ENDAV.




;CHKIQ	Check that the calling job has access an Internet Queue.

;IQ/	Internet Queue Handle (LH may be negative)
;     	NOINT
;	CALL CHKIQ
;Ret+1:	Always.  T1 ge 0 if ok, or error code 
;	-1,,SQX1	"Special network queue handle out ot range"
;	-1,,SQX2	"Special network queue not assigned" to this job

CHKIQ:	HRRZ T1,IQ
	CAIGE T1,NIQ			; Range check the handle
	IFSKP.
	  HRROI T1,SQX1			; Bad handle
	ELSE.
	  HRRZ T1,INQJB(T1)		; Get JOBNO which owns this queue
	  CAMN T1,JOBNO			; Is that this job?
	  ANSKP.			; Yes.  T1 still has the Q index
	    HRROI T1,SQX2		; Owned by some other job
	ENDIF.
	RET

;INQDSP	Do work for INQPRC.

;T1/	Pointer to packet
;INQLK/	Locked		NOINT	NCT & IQ saved
;	CALL INQDSP
;Ret+1:	Always.  Packet queued or flushed.

INQDSP:	ACVAR <IQERR,IQER2>
MNTM5	AOS CELL(INUQD,0,,INU)		; INQDSP calls
	MOVE PKT,T1
	MOVX IQERR,<DU%HST,,ICM%DU>	; Assume least specific - no host
	MOVSI IQ,-NIQ			; Set to scan them
	DO.
	  MOVE T1,INQJB(IQ)		; Get owner of queue
	  CAMN T1,[-1]			; Assigned?
	  IFSKP.			; Yes
					; Pkt and queue secure flags must match
	    LOAD T2,AQ%SCR,+T1		; Secure queue?
	    LOAD T3,PSCR,(PKT)		; Get interface class (secure or not)
	    CAME T2,T3			; Packet class matches queue?
	    ANSKP.			; Yes
	      SETZ T1,			; Receive direction
	      CALL VALIPQ		; Validate packet for queue
	        JRST INQDS3		; +1 Bad IPPL, etc
	        JRST INQDS4		; +2 Bad ICMP type
	        TRNA			; +3 Not for queue
	          CALLRET INQDS6 ;(IQ)	; +4 Yes, it gets the packet
	        CAMG IQERR,T1		; No, Had a better match?
	          MOVE IQERR,T1		; No, this is a better error msg
	  ENDIF.
	  AOBJN IQ,TOP.			; Back for another queue
	ENDDO.
	JRST INQDS9			; No queue, flush it, IQERR has error


INQDS3:	DMOVE IQERR,[EXP ICM%PP,3]	; IPPL
	JRST INQDS9			; Error code set

INQDS4:	MOVX IQERR,<ICM%PP>		; ICMP Type
	LOAD IQER2,PIPL,(PKT)
	LSH IQER2,2			; Bytes in IP header
	ADDI IQER2,0			; Position of CMTYP
	JRST INQDS9			; Error code set


;INQDS6	Put datagram into a user queue.  Check for queue overflow.
;*ENTRY for INQICM	NB: All callers must have ACVAR <IQERR,..>
;IQ/	Queue handle
;PKT/	Extended pointer to packet

INQDS6:	MOVE T1,INQSP(IQ)		; Number of datagrams in this queue
	CAML T1,INQMX			; Less than number allowed?
	IFSKP.				; Yes, deliver it

; Deliver datagram to user queue & set queue timeout

	  AOS INQSP(IQ)			; Count space
MNTM5	  AOS CELL(INUQD,1,,INU)	; Datagrams to user-q by INQDSP/ICM

	  MOVE T3,TODCLK		; "Now"
	  ADD T3,INQT0			; Timeout interval
	  HRRZ T2,IQ			; Queue index
IFE QSZ-2,<LSH T2,1>			; * QSZ
IFG QSZ-2,<IMULI T2,QSZ>
	  ADD T2,INQHD			; Get pointer to the queue head
	  LOAD T1,QNEXT,(T2)		; Get first thing on queue
	  CAMN T1,T2			; If the head itself, queue is empty.
	    MOVEM T3,INQTM(IQ)		; Keep away the grim reaper

	  XMOVEI T1,PKTQ(PKT)		; What to enqueue.  T2 has queue head
	  NOSKED
	  CALL NQ
	  OKSKED
	  PUSH P,7			; Protect critical AC
	  SKIPGE 7,INQFK(IQ)		; See if a fork is waiting on queue
	  IFSKP.
	    HRROS INQFK(IQ)		; Yes, remove it & complete its wait
	  ENDIF.
	  POP P,7
	  RET				; Try for another segment
	ENDIF.
					; Errors
	MOVX IQERR,ICM%SQ		; Source Quench, queue is full
MNTM5	AOSA CELL(INUQD,3,,INU)		; User-q overflow, INQDSP/INQICM
INQDS9:
MNTM5	  AOS CELL(INUQD,2,,INU)	; User-q no-q, INQDSP/INQICM
	MOVX T1,PT%UKQ
	CAIN IQERR,ICM%SQ		; Was error Source Quench?
	  MOVX T1,PT%UKS
	TDNE T1,MNTRAC			; Want trace?
	  CALL PRNPKI ;(T1,PKT)		; Yes
	DMOVE T1,IQERR			; Report error
	CALLRET ICMERR			; (Releases storage)

	ENDAV.

;INQICM	Give an ICMP message to a user Q.

;PKT/	Extended pointer to datagram
;	CALL INQICM
;Ret+1:	Always

INQICM::
MNTM5	AOS CELL(INUIC,0,,INU)		; INQICM calls
	XMOVEI T1,INQLK			; Point to lock
	XMOVEI T2,INQIC0		; Routine to call
	TXO T2,<231B8>			; Our ID
	CALL LCKCAL			; Lock and call the routine
	RETSKP				; (Packet taken or flushed)

					; Workhorse routine
INQIC0:	SAVEAC <VNCT,IQ>
	ACVAR <IQERR,CPK2>		; IQERR must match that at INQDSP
	LOAD CPK2,PIDO,(PKT)		; Get packet data offset
	ADD CPK2,PKT			; Add in to get to ICMP packet
	ADDI CPK2,.CMINH		; And point to the IP header therein
	MOVSI IQ,-NIQ			; Number of user Q's
	DO.
	  MOVE T2,INQJB(IQ)
	  CAME T2,[-1]			; Is this Q in use?
	   TXNN T2,AQ%ICM		; Yes, ICMP messages allowed on this Q?
	  IFSKP.			; Yes
					; Should we check for secure here???
	    MOVX T1,0			; Received packet
	    CALL VALIPQ			; Validate if packet is for this queue
	      JFCL			; +1 Error, IPPL
	      JFCL			; +2 Error, CMTYP
	    ANSKP.			; +3 No
					; +4 Yes Deliver packet to user queue
MNTM5	      AOS CELL(INUIC,1,,INU)	; ICMP msg delivered to user-q, INQICM
	      CALLRET INQDS6 ;(PKT,IQ)	; Go put packet on Q
	  ENDIF.
	  AOBJN IQ,TOP.			; Loop through
	ENDDO.				; No user queue wants packet
MNTM5	AOS CELL(INUIC,2,,INU)		; ICMP msg discarded, INQICM
	CALLRET RETPKT			; Nothing matches, flush

	ENDAV.

;INQCH0	Find next timeout over all queues, and flush timedout packets.

;INQLCK/ Locked		NOINT	IQ saved
;	CALL INQCH0
;Ret+1:	Always. Next timeout todclk in T1.

INQCH0:	ACVAR <TOD,NXT,NPKTS>
MNTM5	AOS CELL(INUCK,0,,INU)		; INQCH0 calls
MNTM5<	SETZ NPKTS,>
	MOVX NXT,.INFIN
	MOVE TOD,TODCLK			; "Now"
	MOVSI IQ,-NIQ			; Set to scan all queues
	DO.
	  MOVE T1,INQJB(IQ)		; Get owner
	  CAME T1,[-1]			; Is this queue assigned?
	   SKIPG INQSP(IQ)		; And have received packets?
	  IFSKP.			; Yes
	    CAMLE TOD,INQTM(IQ)		; Has user forgotten it?
	    IFSKP.
	      CAMLE NXT,INQTM(IQ)	; No, Min next check against timeout
	        MOVE NXT,INQTM(IQ)
	    ELSE.			; Yes, forgotten queue gets flushed
	      DO.
	        HRRZ T1,IQ		; Get the queue handle
	        CALL INQGET		; Get a message from that queue
	        JUMPL T1,ENDLP.		; Jump if none left
MNTM5	        AOS NPKTS		; Count timedout packets
	        MOVE PKT,T1		; For trace
	        MOVX T1,PT%UKT		; Delivery time exceeded
	        TDNE T1,MNTRAC		; Want trace?
	          CALL PRNPKI ;(T1,PKT)	; Yes
	        LOAD T2,PIPRO,(PKT)	; No ICMP messages are sent
	        CAIN T2,.ICMFM		; For ICMP messages
	        IFSKP.			; Not ICMP, send ICMP msg
	          MOVX T1,<TE%TTL,ICM%TE> ; Report Error
	          CALL ICMERR		; (Releases storage)
	        ELSE.			; ICMP
	          CALL RETPKT		; Drop ICMP datagam
	        ENDIF.
	        LOOP.			; Loop over the whole queue
	      ENDDO.
	      SETZM INQSP(IQ)		; Better be zero if all flushed
	      MOVE T1,TODCLK
	      MOVEM T1,INQTM(IQ)	; Remember when flushed
	    ENDIF.			; Forgotten or not
	  ENDIF.			; In use with received packets
	  AOBJN IQ,TOP.			; Loop over all queues
	ENDDO.

MNTM5<	ADDM NPKTS,CELL(INUCK,2,,INU)>	; User-q msgs timedout, INQCH0
MNTM5	SKIPN NPKTS			; Any there?
MNTM5	  AOS CELL(INUCK,1,,INU)	; Count useless INQCH0 runs
	MOVE T1,NXT			; Value to return
	RET

	ENDAV.





;INQCHK	See if user queues are next thing to go.

;T1/	TODCLK of when next check is needed by checkers run so far
;	CALL INQCHK
;Ret+1:	Always.  T1 has TODCLK when to check next.

INQCHK::
	SKIPL INQON
	  RET
	CAMLE T1,INQTIM			; Clock to check
	  MOVE T1,INQTIM		; Next time something timesout
	RET

;Internet User Queue Initialization:

INQINI::
	SAVEAC <IQ>

	MOVX T1,<.INFIN>
	MOVEM T1,INQTIM			; Don't need to be run
	SETZM INQFLG
	SETOM INQPCL			; Protocol -1 to accept anything

MNTM0<	MOVEI T1,CELL(INQIQ,0,,INQ) >	; Address of user queue input queue
	MOVEM T1,INQIPQ			; Set pointer to it
	CALL INITQ			; Initialize it

	MOVEI T1,NIQ			; Number of queues
IFE <QSZ-2>,<LSH T1,1>			; * QSZ
IFG <QSZ-2>,<IMULI T1,QSZ>
	CALL GETBLK			; Get a block of free storage for heads
	JUMPLE T1,INQIN0		; No space
	MOVEM T1,INQHD

	MOVSI IQ,-NIQ			; Set to scan the queue heads
	DO.
	  HRRZ T1,IQ			; Current index
IFE <QSZ-2>,<LSH T1,1>			; * QSZ
IFG <QSZ-2>,<IMULI T1,QSZ>	
	  ADD T1,INQHD			; Plus base is the queue head
	  CALL INITQ			; Initialize that queue
	  SETOM INQJB(IQ)		; Say queue not owned
	  SETZM INQTM(IQ)
	  AOBJN IQ,TOP.			; Loop through all
	ENDDO.

	XMOVEI T1,INQLK			; Pointer to the lock
	CALL CLRLCK			; Initialize it
	IFGE. T1			; Got lock initialized
	  HRRE T1,INQON			; Want User Queues up? (1B18 if yes)
	  TRZ T1,-1			; Initialization complete
	  MOVEM T1,INQON		; ON is -1,,0,  OFF is 0
	  RET
	ENDIF.

					; No wait bit available
	BUG.(HLT,INGWA2,IPIPIP,SOFT,
<INQINI: Wait bit not available for lock>,<<INTFSP,D>>,<

Cause:	Each lock has an associated wait bit used for scheduler tests.
	There were none available for the Internet User Queue lock.
	Since this is an initialization routine, the problem should
	not occur.  Perhapse memory has been clobbered around INTBFF.
	It should be several words of 777777,,777720.

Action:	Check INTBFF and following words.

Data:

>)
	RET


INQIN0:	  BUG.(HLT,INGWA1,IPIPIP,SOFT,
<INQINI: Free storage gone. Free space>,<<INTFSP,D>>,<

Cause:	Insufficient free storage for either Internet User Queue input
	queue head, or for User Queue heads.  This shouldn't happen as
	there should be plenty of space to get the protocols initialized.

Action:	Check for a bad argument to GETBLK, or trashed free storage
	variables.

Data:

>)
	RET

;DEFACY(TCB,IQ)	;ps			; Terminate special definition
PURGE IQ

	SUBTTL	Internet utility fork top level


;Unexpected interrupt

INTU2I:	BUG.(CHK,INTMA3,IPIPIP,SOFT,<Internet utility fork: unexpected interrupt>,,<

Cause:	The Internet utility fork has encountered an unexpected interrupt.

Action:

Data:

>)

	SE1ENT				; Enter section 1
	MCENTR
	DO. (INTUT1)			; Entered here from initialization

; Remove old routes from routing tables

	  MOVX T4,1B0			; Unused flag
	  MOVE T3,TODCLK		; Current time
	  SUB T3,NTHT0			; Old time
	  MOVE T1,NETHTB		; Get first entry, contit follows
	  MOVEI T2,NETHTB+<<NETHSZ-1>*NETHES> ; Last entry

	  NOSKED			; Protect table
	  DO. (NETPUL)
	    SKIPE NETHTB-NETHTB(T2)	; If entry is zero, leave it alone
	     CAMG T3,NETWHN-NETHTB(T2)	; Old entry?
	      TRNA			; Either zero or recent entries remain
	       IORM T4,NETHTB-NETHTB(T2) ; Flush old entry
	    SKIPN T1			; Is next entry free and
	     SKIPL T1,NETHTB-NETHTB(T2)	; This entry freed?
	      SKIPA T1,NETHTB-NETHTB(T2) ; No, get this entry for loop
	       SETZB T1,NETHTB-NETHTB(T2) ; Yes, freed slot becomes free
	    SUBI T2,NETHES		; Move to previous slot
	    CAIL T2,NETHTB		; Done whole table?
	      LOOP.			; No, back for next slot
	  ENDDO.
	  OKSKED


IFN IPMONF,<				;CS147
; Abort monitoring connection if its done
	  MOVE T1,MNTSW			; Get switches
	  TXNE T1,MNS%MT		; Monitoring via TCP?
tcpmoq:	   SKIPE INTMLK			; -1 unlocked, 0 locked
	  IFSKP.			; Yes, Check on TCP monitoring conn.
	    SKIPE T1,CELL(INMCN,0,,INM)	; TCP connection ID
	     CAMN T1,[-1]
	    IFSKP.			; Neither -1 nor 0 is valid
	      TXO T1,<TCP%JS+TCP%SY>	; Setup for STAT%
	      MOVE T2,[-3,,[ASCII /TERR/ ; Info to be returned
			    ASCII /TRSYN/
			    ASCII /TSSYN/]]
	      MOVE T3,[-3,,Q1]		; Put it in Q1-Q3
	      STAT%
	      ERJMP TCPMO6

	      IFE. Q1			; If error, or
	      CAIE Q2,TIMWAT		; Receive side is either TIMWAT or
	       CAIN Q2,NOTSYN		; Closed, and
	        CAIE Q3,NOTSYN		; Send side is closed
	      ANNSK.			; No error and not yet closed
	        MOVE T1,CELL(INMTM,0,,INM) ; Time scheduled to report
	        CAMLE T1,TODCLK		; Been updated yet?
	          SUB T2,CELL(INMPR,0,,INM) ; Yes, undo it by report period
	        ADD T1,[^D<10*60*1000>]	; Give it 10 minutes to get through
	        CAMGE T1,TODCLK		; Taking too long?
	        ANSKP.			; No
					; Wait longer for it to close
	      ELSE.			; Error or closed or too slow
tcpmo6:	        MOVE T1,CELL(INMCN,0,,INM) ; Connection id is
	        TXO T1,<TCP%JS>		; JCN
	        ABORT%			; Abort connection now
	        ERJMP .+1
	        SETZM CELL(INMCN,0,,INM) ; Done, Unlock, connection id gone
	        SOS INTMLK		; Unlock monitoring buffer
	      ENDIF.
	    ELSE.			; Bad connection id, trash it
	      SETZM CELL(INMCN,0,,INM)	; Done, Unlock, connection id gone
	      SOS INTMLK		; Unlock monitoring buffer
	    ENDIF.
	  ENDIF.
   >;IFN IPMONF				;CS147
	  MOVE T1,INFT0+1		; Utility check interval
	  DISMS%			; Check back in a minute
	  LOOP.
	ENDDO.
; Never reached
;DEFACY(P1,VNCT);ps			; 10 Terminate special AC definition
PURGE VNCT
	TNXEND
	END
