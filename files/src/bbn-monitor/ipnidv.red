REDIT 1(104) COMPARE by user CLYNN, 10-Feb-86 18:56:27
File 1: CWL:<DEC-6-1-BASE>IPNIDV.MAC.1
File 2: CWL:<5-4-NET>IPNIDV.MAC.8
***** CHANGE #1; PAGE 4, LINE 9; PAGE 4, LINE 9
	EMINPL==^D46		;MINIMUM ETHERNET PACKET LENGTH
	MINPKT==EMINPL+4	;MINIMUM ETHERNET PACKET LENGTH PLUS CRC BYTES
	GH.EN1==.NIEN1-1	;GHTAR2 ETHERNET ADR HIGH ORDER BYTES
	GH.EN2==.NIEN2-1	;GHTAR2 ETHERNET ADR LOW ORDER BYTES
	GH.GCF==.NIGCF-1	;GHTAR2 GATEWAY CONTROL FLAGS
	GH2MDL==NIHMDL-1	;LENGTH OF AN AREA 2 ENTRY
	NI.HOP==.NBLD1		;ROUTING ADRESS IS KEPT IN THE LEADER
	SRCMAX==^D10		;MAX ENTRIES IN GHT BEFORE USING BINARY SEARCH
 ---------------------------------
	EMINPL==^D46		;MINIMUM ETHERNET PACKET LENGTH
	MINPKT==EMINPL+4	;MINIMUM ETHERNET PACKET LENGTH PLUS CRC BYTES
	GH.EN1==.NIEN1-1	;GHTAR2 ETHERNET ADR HIGH ORDER BYTES
	GH.EN2==.NIEN2-1	;GHTAR2 ETHERNET ADR LOW ORDER BYTES
	GH.GCF==.NIGCF-1	;GHTAR2 GATEWAY CONTROL FLAGS
	GH2MDL==NIHMDL-1	;LENGTH OF AN AREA 2 ENTRY
repeat 0,<
	NI.HOP==.NBLD1		;ROUTING ADRESS IS KEPT IN THE LEADER
> ; end of repeat 0
	SRCMAX==^D10		;MAX ENTRIES IN GHT BEFORE USING BINARY SEARCH

***** CHANGE #2; PAGE 5, LINE 43; PAGE 5, LINE 43

	AR.WRD==<MINPKT/4>+4	;WORD SIZE OF ARP PACKET (PLUS A COUPLE)
	AR.LEN==EMINPL  	;BYTES IN ARP PACKET ARE ETHERNET MINIMUM
	AR.MAX==MINPKT+4	;MAX BFR SIZE WITH ETHERNET CRC (PLUS 4)

  >

 ---------------------------------

	AR.WRD==<MINPKT/4>+4	;WORD SIZE OF ARP PACKET (PLUS A COUPLE)
	AR.LEN==EMINPL  	;BYTES IN ARP PACKET ARE ETHERNET MINIMUM
	AR.MAX==MINPKT+4	;MAX BFR SIZE WITH ETHERNET CRC (PLUS 4)

  >
	SUBTTL NCT format for an NI interface

;
; Note that the code in this module currently only supports a single
; NI.
DEFHDR(<NCT EXTENSIONS>,NCTBAS,0)	; Start after basic NCT
NCTLEN==..OFST


***** CHANGE #3; PAGE 6, LINE 37; PAGE 7, LINE 37
	  TABENT NU.CLO,<IFIW!RSKP>	;CLOSE COMPLETED
	  TABENT NU.RCV,<IFIW!TRLCDR>	;RECEIVED A DATAGRAM
	  TABENT NU.RCI,<IFIW!RSKP>	;CHANNEL STATE CHANGE
	  TABENT NU.SCA,<IFIW!RSKP>	;ADDRESS CHANGE
	TABEND


	SUBTTL Initialization Routines

;NIPINI - INITIALIZATION 
 ---------------------------------
	  TABENT NU.CLO,<IFIW!RSKP>	;CLOSE COMPLETED
	  TABENT NU.RCV,<IFIW!TRLCDR>	;RECEIVED A DATAGRAM
	  TABENT NU.RCI,<IFIW!RSKP>	;CHANNEL STATE CHANGE
	  TABENT NU.SCA,<IFIW!RSKP>	;ADDRESS CHANGE
	TABEND

	SUBTTL NI Protocol and Hardware vectors

; NIPVEC - protocol vector
NIPVEC::
	NCTVEC(NIPVEC,RSKP,NTPKIL)	; Protocol specific kill function
	NCTVEC(NIPVEC,R,NTPERR)		; Protocol specific error handler
	NCTVEC(NIPVEC,MNTEIN,NTIDUN)	; Done with input
	NCTVEC(NIPVEC,MNTODN,NTODUN)	; Done with output
	NCTVEC(NIPVEC,NIPHDR,NTLLDR)	; Local leader routine
	NCTVEC(NIPVEC,RSKP,NTPINI)	; Protocol initialization
	NCTVEC(NIPVEC,R,NTPMNT)		; Protocol maintainence
	NCTVEC(NIPVEC,R,NTPRMV)		; Release protocol resources

; NIHVEC - Hardware interface vector
NIHVEC::
	NCTVEC(NIHVEC,NIPKIL,NTHKIL)	; Shutdown 
	NCTVEC(NIHVEC,NIPRST,NTRSRT)	; Hardware restart
	NCTVEC(NIHVEC,NIPSRV,NTISRT)	; Input start (sic)
	NCTVEC(NIHVEC,NIPSTO,NTOSRT)	; Output start
	NCTVEC(NIHVEC,NIPSTA,NTSCHK)	; Status check
	NCTVEC(NIHVEC,R,NTHRMV)		; Release hardware resources

	SUBTTL Initialization Routines

; NI NCT initialization vector
	SWAPCD
NINCT::
	FLD(NCTLEN,IVLEN)+FLD(NUMINI,IVINI)
	XWD NTPVEC,[XWD MSEC1,NIPVEC]	; NI protocol vector
	XWD NTHVEC,[XWD MSEC1,NIHVEC]	; NI hardware vector
	XWD NTPSIZ,[^D1500]		; Max ethernet data size
NUMINI==.-NINCT-1
; Start of initialization code
; Called from MNTINI when reading interface configuration file
; NCT/ NCT address 
;
; Returns + 2 always 

	MOVEM NCT,NIPNCT	;SAVE OUR NCT FOR THE CALLBACK ROUTINE
	MOVEI T1,NH.NI		;Hardware is NI
	STOR T1,NTDEV,(P1)

 	RETSKP

repeat 0,<
;NIPINI - INITIALIZATION 

***** CHANGE #4; PAGE 7, LINE 17; PAGE 9, LINE 38

	SWAPCD

NIPINI::MOVEM NCT,NIPNCT	;SAVE OUR NCT FOR THE CALLBACK ROUTINE
	SETZM HSTGDM(NCT)	;CANCEL GOING DOWN MESSAGES
 	RET


 ---------------------------------

	SWAPCD

NIPINI::MOVEM NCT,NIPNCT	;SAVE OUR NCT FOR THE CALLBACK ROUTINE
	SETZM HSTGDM(NCT)	;CANCEL GOING DOWN MESSAGES
 	RET
> ; end of repeat 0



***** CHANGE #5; PAGE 8, LINE 39; PAGE 11, LINE 39
	IFSKP.
	 CALL TRLINI		;YES
	  BUG.(CHK,IPTRLE,IPNIDV,SOFT,<Trailer detection code did not initialize>,<<T1,ERROR>>)
	ENDIF.
	CALL INTUP		;INTERFACE IS UP
	CALL NIPSTO		;START OUTPUT IF NEEDED
	AOS JB0FLG		;NOTE NETWORK CHANGE
	CALL WERHER		;TELL EVERYONE THAT WE ARE NOW HERE
	RET

 ---------------------------------
	IFSKP.
	 CALL TRLINI		;YES
	  BUG.(CHK,IPTRLE,IPNIDV,SOFT,<Trailer detection code did not initialize>,<<T1,ERROR>>)
	ENDIF.
	CALL INTUP		;INTERFACE IS UP
	CALL NIPSTO		;START OUTPUT IF NEEDED

	CALL MNTWAK		;Wake multinet fork to note change
repeat 0,<
	AOS JB0FLG		;NOTE NETWORK CHANGE
> ; end of repeat 0
	CALL WERHER		;TELL EVERYONE THAT WE ARE NOW HERE
	RETSKP


***** CHANGE #6; PAGE 9, LINE 25; PAGE 12, LINE 25
	   JRST RST2		;YES - ALLOW US TO GO ON
	  ENDIF.
	  CALL NIPKIL		;DON'T ALLOW THE INTERFACE TO COME UP
	  RETBAD              	;GET BACK THE ERROR CODE
	 ENDIF.
	ENDIF.
RST2:	CALL NIPGIB		;GRAB A BUNCH OF INPUT BUFFERS
	MOVE T1,NIPON		;GET "ON" FLAGS
 ---------------------------------
	   JRST RST2		;YES - ALLOW US TO GO ON
	  ENDIF.
	  CALL NIPKIL		;DON'T ALLOW THE INTERFACE TO COME UP
	  RETBAD              	;GET BACK THE ERROR CODE
	 ENDIF.
	ENDIF.
RST2:
repeat 0,<
	CALL NIPGIB		;GRAB A BUNCH OF INPUT BUFFERS
> ; end of repeat 0
	MOVE T1,NIPON		;GET "ON" FLAGS

***** CHANGE #7; PAGE 11, LINE 51; PAGE 14, LINE 51
	IFNSK.
	 SETOM NIPSHT		;FLAG CHANGE TO SHUT KLNI DOWN
	 RETBAD <NI.ER9>
	ENDIF.
	SKIPN NIPON		;STATUS IS UP. ARE WE INIT'D
	RETBAD			;NO 
	AOS NIPRSF		;TELL THE INTERNET FORK TO RESTART IPNI
	AOS INTFLG		;WE WANT THE INTERNET FORK TO RUN
	RETSKP			;GIVE A GOOD RETURN
 ---------------------------------
	IFNSK.
	 SETOM NIPSHT		;FLAG CHANGE TO SHUT KLNI DOWN
	 RETBAD <NI.ER9>
	ENDIF.
	SKIPN NIPON		;STATUS IS UP. ARE WE INIT'D
	RETBAD			;NO 

	AOS NIPRSF		;TELL THE MULTINET FORK TO RESTART IPNI
	CALL MNTWAK		;Want multinet fork to run
repeat 0,<
	AOS NIPRSF		;TELL THE INTERNET FORK TO RESTART IPNI
	AOS INTFLG		;WE WANT THE INTERNET FORK TO RUN
> ; end of repeat 0
	RETSKP			;GIVE A GOOD RETURN

***** CHANGE #8; PAGE 13, LINE 9; PAGE 16, LINE 9
;NIPHDR - BUILD HEADER 
;
; Called from Multinet to build a header for the local transport
; layer. In our case, the only essential information is the host
; number of the next node which can route the packet.
;
; T1/  local address to send to
; T2/  address of buffer
; NCT/  NCT address
;
; Returns + 1 always

	SWAPCD

NIPHDR::MOVEM T1,NI.HOP(T2)	;STORE DESTINATION ADDRESS
	RET
 ---------------------------------
;NIPHDR - BUILD HEADER 
;
; Called from Multinet to build a header for the local transport
; layer. In our case, the only essential information is the host
; number of the next node which can route the packet.
;
; T1/  Local net destination address
; T2/  extended pointer to packet
; T3/ Protocol code (assumes IP for now)
; NCT/  NCT address
;
; Ret+1: Always; error code in T1

NIPHDR:	CAIN T3,NP.IP			; IP protocol?
	IFSKP.
	  MOVX T1,<NE%DRP+MNTX20>	; Protocol not supported
	  RET
	ENDIF.

	STOR T1,PFLAD,(T2)		; Save first hop address
	SETZM PLNBZ,(T2)		; Claim local leader length 0

	LOAD T1,PTPBZ,(T2)		; Transport level length
	STOR T1,PLNBZ,(T2)		; Local net level length

	PNTLDR T1,PTPDT,(T2)		; Transport level leader
	STOR T1,PLNDT,(T2)		; Pointer to local leader

	MOVX T1,MNTX00			; No error
repeat 0,<
	MOVEM T1,NI.HOP(T2)	;STORE DESTINATION ADDRESS
> ; end of repeat 0
	RET

***** CHANGE #9; PAGE 14, LINE 8; PAGE 17, LINE 8

;NIPSTO - START OUTPUT
;
; Called to send an output buffer.
;
; NCT/ NCT address 
; NTIOBO/ pointer to the list of internet buffers to send 
; NTIOBI/ tail end of the list
;
 ---------------------------------

;NIPSTO - START OUTPUT
;
; Called to send an output buffer.
;
; NCT/ NCT address 
;

***** CHANGE #10; PAGE 14, LINE 17; PAGE 17, LINE 15
; Returns +1 always

	RESCD 

NIPSTO::SAVEAC <SRV,UNB,RID>	
NIPOS1:	SKIPN RID,NTIOBO(NCT)	;ANY INTERNET OUTPUT WAITING?
 ---------------------------------
; Returns +1 always

	RESCD 

NIPSTO::SAVEAC <SRV,UNB,RID>	

	DO.
	  CALL MNTUNQ		; Get next buffer
	   RET			; none to process
	  MOVE RID,T1		; Put buffer pointer here
	  MOVEI SRV,NI.INT	;TYPE OF SERVICE IS INTERNET
	  CALL NISEND		;NO. SEND TO NISRV
	   RETBAD                 ;ERROR
	  SETZM NTTOUT(NCT)	;CLEAR OUTPUT HUNG TIMEOUT
	  LOOP.			;TRY FOR MORE
	ENDDO.
;/*NOTREACHED*/
repeat 0,<
NIPOS1:	SKIPN RID,NTIOBO(NCT)	;ANY INTERNET OUTPUT WAITING?

***** CHANGE #11; PAGE 14, LINE 34; PAGE 17, LINE 45
	SETZRO NBQUE,(RID)	;DEQUEUE BUFFER FROM ITS OLD CHAIN
 	OKSKED			;ALLOW INTERRUPTS AGAIN
	CALL NISEND		;NO. SEND TO NISRV
	 RETBAD                 ;ERROR
	SETZM NTTOUT(NCT)	;CLEAR OUTPUT HUNG TIMEOUT
	JRST NIPOS1		;TRY FOR MORE

 ---------------------------------
	SETZRO NBQUE,(RID)	;DEQUEUE BUFFER FROM ITS OLD CHAIN
 	OKSKED			;ALLOW INTERRUPTS AGAIN
	CALL NISEND		;NO. SEND TO NISRV
	 RETBAD                 ;ERROR
	SETZM NTTOUT(NCT)	;CLEAR OUTPUT HUNG TIMEOUT
	JRST NIPOS1		;TRY FOR MORE
> ; end of repeat 0


***** CHANGE #12; PAGE 15, LINE 16; PAGE 18, LINE 16
;
; Returns + 1 on error
;	  + 2 on success

	SWAPCD

NISEND:	XMOVEI T2,-LCLPKT(RID)	;POINT TO RIGHT LOCATION TO PICK UP PIDH
	LOAD T3,PIDH,(T2)	;GET THE DESTINATION HOST #
	CAMN T3,NTLADR(NCT)   	;DESTINED FOR US ?
	CALLRET NILCAL		;YES
	MOVE T2,NI.HOP(RID)	;GET THE ROUTING ADDRESS
	CALL INTSRC		;GO FIND HOST # IN GHT
 ---------------------------------
;
; Returns + 1 on error
;	  + 2 on success

	SWAPCD

NISEND:
	LOAD T2,PFLAD,(RID)	; Get the destination host #
	CAMN T2,NTLADR(NCT)   	;DESTINED FOR US ?
	 CALLRET NILCAL		;YES
repeat 0,<
	XMOVEI T2,-LCLPKT(RID)	;POINT TO RIGHT LOCATION TO PICK UP PIDH
	LOAD T3,PIDH,(T2)	;GET THE DESTINATION HOST #
	CAMN T3,NTLADR(NCT)   	;DESTINED FOR US ?
	CALLRET NILCAL		;YES
	MOVE T2,NI.HOP(RID)	;GET THE ROUTING ADDRESS
> ; end of repeat 0
	CALL INTSRC		;GO FIND HOST # IN GHT

***** CHANGE #13; PAGE 15, LINE 35; PAGE 18, LINE 41
	CALL INTUNB		;GET A UN BLOCK TO USE
	 CALLRET NISND1		;NO UN BLOCK, DROP THE PACKET AND BUGINF
	DMOVE T3,GH.EN1(T2)	;GET BOTH WORDS OF ETHERNET ADDRESS
	STOR T3,UNDAD,(UNB)	;SAVE THEM IN THE UN BLOCK
	STOR T4,UNDAD,+1(UNB)	
	STOR RID,UNRID,(UNB)	;SAVE BUFFER ADR AS REQUEST ID
	XMOVEI T2,-LCLPKT(RID)	;POINT TO RIGHT LOCATION TO PICK UP LENGTH
	LOAD T1,PIPL,(T2)	;GET PACKET LENGTH 
	CAIGE T1,EMINPL		;LESS THAN THE MINIMUM ETHERNET REQUIREMENT?
	IFSKP.
	 STOR T1,UNBSZ,(UNB)	;NO - DON'T NEED MSD'S - SAVE LENGTH FOR NISRV 
	 XMOVEI T3,MAXLDR(RID)	;POINTER TO IP PACKET 
	 TXO T3,<OWGP. 8,>	;FORM BYTE POINTER TO BUFFER
 ---------------------------------
	CALL INTUNB		;GET A UN BLOCK TO USE
	 CALLRET NISND1		;NO UN BLOCK, DROP THE PACKET AND BUGINF
	DMOVE T3,GH.EN1(T2)	;GET BOTH WORDS OF ETHERNET ADDRESS
	STOR T3,UNDAD,(UNB)	;SAVE THEM IN THE UN BLOCK
	STOR T4,UNDAD,+1(UNB)	
	STOR RID,UNRID,(UNB)	;SAVE BUFFER ADR AS REQUEST ID

	LOAD T1,PLNBZ,(RID)	;Packet length in bytes at local level
repeat 0,<
	XMOVEI T2,-LCLPKT(RID)	;POINT TO RIGHT LOCATION TO PICK UP LENGTH
	LOAD T1,PIPL,(T2)	;GET PACKET LENGTH 
> ; end of repeat 0
	CAIGE T1,EMINPL		;LESS THAN THE MINIMUM ETHERNET REQUIREMENT?
	IFSKP.
	 STOR T1,UNBSZ,(UNB)	;NO - DON'T NEED MSD'S - SAVE LENGTH FOR NISRV 

	 PNTLDR T3,PLNDT,(RID)	;Get pointer to local leader	 
repeat 0,<
	 XMOVEI T3,MAXLDR(RID)	;POINTER TO IP PACKET 
> ; end of repeat 0
	 TXO T3,<OWGP. 8,>	;FORM BYTE POINTER TO BUFFER

***** CHANGE #14; PAGE 15, LINE 53; PAGE 18, LINE 67
	 XMOVEI T4,MSD2(UNB)	;GET POINTER FOR 2ND MSD
	 STOR T3,UNBFA,(UNB)	;SAVE POINTER TO 1ST MSD IN UN BLOCK
	 STOR T1,MDBYT,(T3)	;SAVE PACKET BYTE COUNT IN MSD 1
	 MOVEI T2,EMINPL	;GET MINIMUM ETHERNET PACKET SIZE
	 SUB T2,T1		;COMPUTE # OF BYTES NEEDED FOR PADDING
	 STOR T2,MDBYT,(T4)	;SAVE PAD BYTE COUNT IN 2ND MSD
	 XMOVEI T2,MAXLDR(RID)	;POINTER TO IP PACKET 
	 STOR T2,MDALA,(T3)	;SAVE AS BUFFER ADDRESS IN MSD 1
 ---------------------------------
	 XMOVEI T4,MSD2(UNB)	;GET POINTER FOR 2ND MSD
	 STOR T3,UNBFA,(UNB)	;SAVE POINTER TO 1ST MSD IN UN BLOCK
	 STOR T1,MDBYT,(T3)	;SAVE PACKET BYTE COUNT IN MSD 1
	 MOVEI T2,EMINPL	;GET MINIMUM ETHERNET PACKET SIZE
	 SUB T2,T1		;COMPUTE # OF BYTES NEEDED FOR PADDING
	 STOR T2,MDBYT,(T4)	;SAVE PAD BYTE COUNT IN 2ND MSD

	 PNTLDR T2,PLNDT,(RID)	;Pointer to packet data
repeat 0,<
	 XMOVEI T2,MAXLDR(RID)	;POINTER TO IP PACKET 
> ; end of repeat 0
	 STOR T2,MDALA,(T3)	;SAVE AS BUFFER ADDRESS IN MSD 1

***** CHANGE #15; PAGE 16, LINE 5; PAGE 19, LINE 5

	SUBTTL Output Routines - Local Message Handling

;NILCAL - LOCAL LOOPBACK
;
; Called  from NISEND to handle a message to ourself. We reserve
; a input buffer and copy the IP packet into it, queue  it,  and
; release  the  old  packet.  This routine is needed because the
; KLNI only has one CRC generator and two are needed to send and
; receive a packet at the same time.
;
 ---------------------------------

	SUBTTL Output Routines - Local Message Handling

;NILCAL - LOCAL LOOPBACK
;
; Called  from NISEND to handle a message to ourself. 
; Use the loopback NCT code to perform the actual transfer.
; Note that normally the loopback code would be invoked before
; we even reach this point.
; This routine is needed because the KLNI only has one CRC generator
; and two are needed to send and receive a packet at the same time.
;

***** CHANGE #16; PAGE 16, LINE 19; PAGE 19, LINE 20
; NCT/ address of the NCT
;
; Returns via NIRELB

	SWAPCD

NILCAL:	STKVAR <BFA>
	CALL NIPGIB		;MAKE SURE WE HAVE ENOUGH BUFFERS
 ---------------------------------
; NCT/ address of the NCT
;
; Returns via NIRELB

	SWAPCD

NILCAL:
	SAVEAC <NCT>
; Send packet via the loppback NCT
	MOVE T1,T2		; local dest
	MOVE T2,RID		; buffer address
	MOVX T3,NP.IP		; assume protocol code always IP
	HRL NCT,LUPNCT		; send via loopback NCT
	CALLRET NTSNDI		; send it off
repeat 0,<
	STKVAR <BFA>
	CALL NIPGIB		;MAKE SURE WE HAVE ENOUGH BUFFERS

***** CHANGE #17; PAGE 16, LINE 39; PAGE 19, LINE 49
	CALL XBLTA		;COPY IP HEADERS
	MOVE T1,BFA       	;POINT AT RCV BUFFER
	CALL NIPQUE		;GIVE THE BUFFER TO INTERNET
	CALLRET NIRELB		;RELEASE OLD BUFFER 

	ENDSV.

 ---------------------------------
	CALL XBLTA		;COPY IP HEADERS
	MOVE T1,BFA       	;POINT AT RCV BUFFER
	CALL NIPQUE		;GIVE THE BUFFER TO INTERNET
	CALLRET NIRELB		;RELEASE OLD BUFFER 

	ENDSV.
> ; End of repeat 0


***** CHANGE #18; PAGE 17, LINE 26; PAGE 20, LINE 26
	RESCD

IPCBDS:	MOVE UNB,T2		;SAVE UN BLOCK ADDRESS
	LOAD T1,UNRID,(UNB)	;GET THE BUFFER ADDRESS TO RELEASE
	LOAD SRV,UNUID,(UNB)	;GET USERID
	HRRZS SRV		;BUT USE ONLY TYPE OF SERVICE PORTION
CBDS1:	MOVE T2,T1		;COPY FOR INDEXING
 ---------------------------------
	RESCD

IPCBDS:	MOVE UNB,T2		;SAVE UN BLOCK ADDRESS
	LOAD T1,UNRID,(UNB)	;GET THE BUFFER ADDRESS TO RELEASE
	LOAD SRV,UNUID,(UNB)	;GET USERID
	HRRZS SRV		;BUT USE ONLY TYPE OF SERVICE PORTION

	MOVEM T1,NTOB(NCT)	;Save buffer pointer
	MOVX T1,PT%SLN		;Packet sent on local net
	CALL MNTODN		;Do output done processing
	RETSKP

CBDS1:
CDSERR:	AOS NIOCNT		;BUMP THE OUTPUT ERROR COUNT
	BUG.(CHK,IPDWNS,IPNIDV,SOFT,<Datagram was not sent>,
<<T3,ERROR>,<SRV,SERVICE>>)
	MOVEM T3,NIPERR
	MOVEM T1,NTOB(NCT)	;Where code expects to find it
	MOVX T1,PT%KOL		;Packet killed at interface
	CALL MNTODN
	RETBAD
repeat 0,<
CBDS1:	MOVE T2,T1		;COPY FOR INDEXING

***** CHANGE #19; PAGE 17, LINE 39; PAGE 20, LINE 55
	SKIPN T1,T3          	;NO, GET THE CHANNEL STATUS
	RETSKP			;NO ERRORS DETECTED  
CDSERR:	AOS NIOCNT		;BUMP THE OUTPUT ERROR COUNT
	BUG.(CHK,IPDWNS,IPNIDV,SOFT,<Datagram was not sent>,<<T1,ERROR>,<SRV,SERVICE>>)
	MOVEM T1,NIPERR
	RETBAD

 ---------------------------------
	SKIPN T1,T3          	;NO, GET THE CHANNEL STATUS
	RETSKP			;NO ERRORS DETECTED  
CDSERR:	AOS NIOCNT		;BUMP THE OUTPUT ERROR COUNT
	BUG.(CHK,IPDWNS,IPNIDV,SOFT,<Datagram was not sent>,<<T1,ERROR>,<SRV,SERVICE>>)
	MOVEM T1,NIPERR
	RETBAD
> ; end of repeat 0

***** CHANGE #20; PAGE 19, LINE 19; PAGE 22, LINE 19
;	  + 2 on success

	RESCD

NIPOST:	SKIPN T1		;ZERO IF NIPBFR COULDN'T GET A BUFFER
	RETBAD <NI.ER1>		;RETURN THE ERROR
	LOAD T3,NBBSZ,(T1) 	;GET BUFFER SIZE
	SUBI T3,LCLPKT+MAXLDR	;DON'T INCLUDE LEADER SIZE
	LSH T3,2		;MAKE WORDS INTO BYTES
	STOR T3,UNBSZ,(UNB)	;SAVE IT AS RECEIVE BUFFER SIZE
	STOR T1,UNRID,(UNB)	;SAVE INPUT BUFFER ADR AS REQUEST ID
	ADDI T1,MAXLDR		;POINT PAST LEADER FOR START OF IP HEADER
	TXO T1,<OWGP. 8,>	;FORM BYTE POINTER TO BUFFER
 ---------------------------------
;	  + 2 on success

	RESCD

NIPOST:	SKIPN T1		;ZERO IF NIPBFR COULDN'T GET A BUFFER
	RETBAD <NI.ER1>		;RETURN THE ERROR

	LOAD T3,PLNBZ,(T1)
repeat 0,<
	LOAD T3,NBBSZ,(T1) 	;GET BUFFER SIZE
	SUBI T3,LCLPKT+MAXLDR	;DON'T INCLUDE LEADER SIZE
	LSH T3,2		;MAKE WORDS INTO BYTES
> ; end of repeat 0
	STOR T3,UNBSZ,(UNB)	;SAVE IT AS RECEIVE BUFFER SIZE
	STOR T1,UNRID,(UNB)	;SAVE INPUT BUFFER ADR AS REQUEST ID

	ADD T1,PROOVH+NP.IP	;Fixed point for IP data start
repeat 0,<
	ADDI T1,MAXLDR		;POINT PAST LEADER FOR START OF IP HEADER
> ; end of repeat 0
	TXO T1,<OWGP. 8,>	;FORM BYTE POINTER TO BUFFER

***** CHANGE #21; PAGE 19, LINE 45; PAGE 22, LINE 53
	LOAD T2,UNUID,(UNB)	;GET THE USERID
	HRRZS T2		;KEEP ONLY THE SERVICE TYPE
	SKIPN NIPON		;INTERNET UP ?
	BUG. (CHK,IPPSTE,IPNIDV,SOFT,<Couldn't post a buffer>,<<T1,ERROR>,<T2,SERVICE>>)
	CAIN T2,NI.INT		;INTERNET SERVICE POSTING ERROR ?
	IFSKP.
	 LOAD T2,UNRID,(UNB)	;YES - GET BUFFER ADDRESS BACK
	 CALL NIPQIB		;PUT BUFFER BACK ON FREE QUEUE
	ENDIF.
 ---------------------------------
	LOAD T2,UNUID,(UNB)	;GET THE USERID
	HRRZS T2		;KEEP ONLY THE SERVICE TYPE
	SKIPN NIPON		;INTERNET UP ?
	BUG. (CHK,IPPSTE,IPNIDV,SOFT,<Couldn't post a buffer>,<<T1,ERROR>,<T2,SERVICE>>)
	CAIN T2,NI.INT		;INTERNET SERVICE POSTING ERROR ?
	IFSKP.

	 LOAD T1,UNRID,(UNB)	;YES - GET BUFFER ADDRESS BACK
	 CALL RETBUF		;get rid of it
repeat 0,<
	 LOAD T2,UNRID,(UNB)	;YES - GET BUFFER ADDRESS BACK
	 CALL NIPQIB		;PUT BUFFER BACK ON FREE QUEUE
> ; end of repeat 0
	ENDIF.

***** CHANGE #22; PAGE 20, LINE 17; PAGE 23, LINE 17
;
; Returns + 1 on error
;	  + 2 on success

	RESCD

IPCBDR:	STKVAR <UNBLK,STS>
	SOS NICNTP		;DECREMENT # OF BUFFERS POSTED NOW
	MOVEM T2,UNBLK		;SAVE THE UN BLOCK ADR
	MOVEM T3,STS		;SAVE THE ERROR STATUS
	LOAD T1,UNRID,(T2)	;GET THE ADDRESS OF THE BUFFER
	JUMPN T3,CBDRCK		;PROBLEMS ?
	CALL NIPQUE 		;GIVE THE BUFFER TO INTERNET
	CALL NIPBFR		;GET ANOTHER BUFFER
 ---------------------------------
;
; Returns + 1 on error
;	  + 2 on success

	RESCD

IPCBDR:	SAVEAC <NCT>
	STKVAR <UNBLK,STS>
	MOVE NCT,NIPNCT		; make sure NCT register is good
	SOS NICNTP		;DECREMENT # OF BUFFERS POSTED NOW
	MOVEM T2,UNBLK		;SAVE THE UN BLOCK ADR
	MOVEM T3,STS		;SAVE THE ERROR STATUS

	MOVX T1,NP.IP
	LOAD T2,UNRID,(T2)	;GET THE ADDRESS OF THE BUFFER
	JUMPN T3,CBDRCK		;PROBLEMS ?
;	MOVEI T3,0		; Local leader length is 0
	CALL MNTEIN		; do end of input processing
repeat 0,<
	LOAD T1,UNRID,(T2)	;GET THE ADDRESS OF THE BUFFER
	JUMPN T3,CBDRCK		;PROBLEMS ?
	CALL NIPQUE 		;GIVE THE BUFFER TO INTERNET
> ; end of repeat 0
	CALL NIPBFR		;GET ANOTHER BUFFER

***** CHANGE #23; PAGE 20, LINE 30; PAGE 23, LINE 40
	MOVE UNB,UNBLK		;PICK UP THE UN BLOCK TO USE
	CALL NIPOST		;POST IT
	 RETBAD                 ;GOT AN ERROR 
	RETSKP			;GIVE GOOD RETURN

 ---------------------------------
	MOVE UNB,UNBLK		;PICK UP THE UN BLOCK TO USE
	CALL NIPOST		;POST IT
	 RETBAD                 ;GOT AN ERROR 
	RETSKP			;GIVE GOOD RETURN


***** CHANGE #24; PAGE 20, LINE 50; PAGE 24, LINE 20
	MOVE UNB,UNBLK		;GET THE UNBLOCK
	LOAD T1,UNRID,(UNB)	;GET BUFFER ADDRESS AGAIN
	CALL NIPOST		;POST IT
	 RETBAD <>,<MOVE T1,STS> ;GOT AN ERROR BUT USE ORIGINAL ERROR CODE
	RETSKP			;GIVE GOOD RETURN
CBDRC2:				;HERE WHEN ERROR WAS NOT DATAGRAM TOO LONG
	MOVE T2,T1		;PUT ADDRESS WHERE NIPQIB WANTS IT
	CALL NIPQIB		;PUT ON FREE BUFFER QUEUE
	RETSKP			;TAKE GOOD RETURN
 ---------------------------------
	MOVE UNB,UNBLK		;GET THE UNBLOCK
	LOAD T1,UNRID,(UNB)	;GET BUFFER ADDRESS AGAIN
	CALL NIPOST		;POST IT
	 RETBAD <>,<MOVE T1,STS> ;GOT AN ERROR BUT USE ORIGINAL ERROR CODE
	RETSKP			;GIVE GOOD RETURN
CBDRC2:				;HERE WHEN ERROR WAS NOT DATAGRAM TOO LONG
	CALL RETBUF		; return the buffer to free space
repeat 0,<
	MOVE T2,T1		;PUT ADDRESS WHERE NIPQIB WANTS IT
	CALL NIPQIB		;PUT ON FREE BUFFER QUEUE
> ; end of repeat 0
	RETSKP			;TAKE GOOD RETURN

***** CHANGE #25; PAGE 22, LINE 22; PAGE 26, LINE 22
	IOR T1,NTORDY(NCT)
	SETZM NTTOUT(NCT)	;CLEAR OUTPUT HUNG TIMEOUT
	JUMPE T1,NIPKLD		;NOTHING CHANGED SO EXIT QUIETLY
	SETZM NTRDY(NCT)	;NI OFF
	SETZM NTORDY(NCT)	;OUTPUT OFF
 	AOS NTSTCH(NCT)		;JUST CHANGED STATE
	AOS JB0FLG		;NOTE THE NETWORK CHANGE
	CALL NIOFF		;SHUT DOWN THE INTERNET PROTOCOL
 ---------------------------------
	IOR T1,NTORDY(NCT)
	SETZM NTTOUT(NCT)	;CLEAR OUTPUT HUNG TIMEOUT
	JUMPE T1,NIPKLD		;NOTHING CHANGED SO EXIT QUIETLY
	SETZM NTRDY(NCT)	;NI OFF
	SETZM NTORDY(NCT)	;OUTPUT OFF
 	AOS NTSTCH(NCT)		;JUST CHANGED STATE

	CALL MNTWAK		;wake fork to notice it
repeat 0,<
	AOS JB0FLG		;NOTE THE NETWORK CHANGE
> ; end of repeat 0
	CALL NIOFF		;SHUT DOWN THE INTERNET PROTOCOL

***** CHANGE #26; PAGE 24, LINE 5; PAGE 28, LINE 5

	SUBTTL Internet Fork Background Service

;NIPSRV - GENERAL BACKGROUND SERVICE 
;
; Called   from  the  Internet  fork  to  service  miscellaneous
; requests.
;
; Returns + 1 always

	SWAPCD

NIPSRV::SAVEAC <NCT,UNB,RID> 	;SAVE THE NCT AC
	SKIPE NCT,NIPNCT	;GET OUR NCT
 ---------------------------------

	SUBTTL Internet Fork Background Service

;NIPSRV - GENERAL BACKGROUND SERVICE 
;
; Called   from  the  Multinet  fork  to  service  miscellaneous
; requests.
; Note that this is called through the NTISRT entry in the
; hardware vector since that isn't really used.
; Returns + 1 always

	SWAPCD

NIPSRV:	SAVEAC <NCT,UNB,RID> 	;SAVE THE NCT AC
	SKIPE NCT,NIPNCT	;GET OUR NCT

***** CHANGE #27; PAGE 24, LINE 31; PAGE 28, LINE 32
	ENDIF.
	CALL INTUNB		;GET A UNB BLOCK 
	 RET			;COULDN'T
	CALL NIPPIB		;SEE IF ANY INPUT BUFFERS WATNED
	 JFCL			;IGNORE THE ERROR, BUGINFS HAVE BEEN ISSUED
	CALL RETUNB		;RETURN THE UN BLOCK
	SKIPE NTLOBO(NCT)	;ANY ARP MESSAGES TO PROCESS
	CALL ARPPRC		;YES
	SKIPE NIPSRQ		;ANY REQUESTS FOR READ PORTAL COUNTERS ?
	CALL NIPRPC		;YES
	SKIPE ARPSRQ		;ANY REQUEST FOR ARP COUNTERS ?
	CALL ARPRPC		;YES
	RET
 ---------------------------------
	ENDIF.
	CALL INTUNB		;GET A UNB BLOCK 
	 RET			;COULDN'T
	CALL NIPPIB		;SEE IF ANY INPUT BUFFERS WATNED
	 JFCL			;IGNORE THE ERROR, BUGINFS HAVE BEEN ISSUED
	CALL RETUNB		;RETURN THE UN BLOCK

	SKIPE ARPIQO		;ANY ARP MESSAGES TO PROCESS?
repeat 0,<
	SKIPE NTLOBO(NCT)	;ANY ARP MESSAGES TO PROCESS
> ; end of repeat 0
	 CALL ARPPRC		;YES
	SKIPE NIPSRQ		;ANY REQUESTS FOR READ PORTAL COUNTERS ?
	 CALL NIPRPC		;YES
	SKIPE ARPSRQ		;ANY REQUEST FOR ARP COUNTERS ?
	 CALL ARPRPC		;YES

	RET

***** CHANGE #28; PAGE 25, LINE 37; PAGE 29, LINE 37
;
; Returns via NIRELB routine

	SWAPCD

NIUNKA:	SKIPN ARPON 		;IS ARP ON ?
	JRST NSND2A		;NO - BYPASS THE ARP CODE
	CALL ARPSND		;YES - GENERATE AN ARP PACKET
	 JFCL			;IGNORE THE ERROR
NSND2A:	MOVE T2,NI.HOP(RID)	;GET THE ROUTING ADDRESS
	XMOVEI T1,-LCLPKT(RID)	;POINT TO RIGHT LOCATION TO PICK UP PIDH
 ---------------------------------
;
; Returns via NIRELB routine

	SWAPCD

NIUNKA:	SKIPN ARPON 		;IS ARP ON ?
	 JRST NSND2A		;NO - BYPASS THE ARP CODE
	CALL ARPSND		;YES - GENERATE AN ARP PACKET
	 JFCL			;IGNORE THE ERROR
NSND2A:
	CALLRET NIRELB		;RELEASE THE BUFFER
repeat 0,<
	MOVE T2,NI.HOP(RID)	;GET THE ROUTING ADDRESS
	XMOVEI T1,-LCLPKT(RID)	;POINT TO RIGHT LOCATION TO PICK UP PIDH

***** CHANGE #29; PAGE 25, LINE 49; PAGE 29, LINE 52
	LOAD T3,PIDH,(T1)	;GET THE DESTINATION HOST #
	SKIPN ARPON		;ARP BEING USED ?
	 CAMN T3,T2		;DOES IT MATCH ROUTING ADDRESS
	  SKIPA
	   BUG.(INF,IPRANF,IPNIDV,SOFT,<Routing address not found>,<<T2,RTE>,<T3,DEST>>)
	CALLRET NIRELB		;RELEASE THE BUFFER



 ---------------------------------
	LOAD T3,PIDH,(T1)	;GET THE DESTINATION HOST #
	SKIPN ARPON		;ARP BEING USED ?
	 CAMN T3,T2		;DOES IT MATCH ROUTING ADDRESS
	  SKIPA
	   BUG.(INF,IPRANF,IPNIDV,SOFT,<Routing address not found>,<<T2,RTE>,<T3,DEST>>)
	CALLRET NIRELB		;RELEASE THE BUFFER
> ; end of repeat 0


repeat 0,<


***** CHANGE #30; PAGE 26, LINE 24; PAGE 30, LINE 25
	SKIPA
CBDRQ1:	STOR T1,NBQUE,(T3)
	MOVEM T1,INTIBI		;NEW POINTER
	AOS INTFLG		;CAUSE INTERNET TO NOTICE IT.
	PION
	RET


 ---------------------------------
	SKIPA
CBDRQ1:	STOR T1,NBQUE,(T3)
	MOVEM T1,INTIBI		;NEW POINTER
	AOS INTFLG		;CAUSE INTERNET TO NOTICE IT.
	PION
	RET
> ; end of repeat 0


***** CHANGE #31; PAGE 27, LINE 3; PAGE 31, LINE 3
NIICMP:	RET			;JUST A STUB FOR NOW


	SUBTTL Buffer Management Routines

;NIPGIB - GET INPUT BUFFERS.
 ---------------------------------
NIICMP:	RET			;JUST A STUB FOR NOW


	SUBTTL Buffer Management Routines

repeat 0,<

;NIPGIB - GET INPUT BUFFERS.

***** CHANGE #32; PAGE 27, LINE 45; PAGE 31, LINE 47

;Here when no buffers available
NIPGB3:	MOVE T1,NIPNFI		;GET NUMBER OF BUFFERS AVAILABLE
	CAIGE T1,NNIPTH		;BELOW THE THRESHOLD LEVEL ?
	BUG.(CHK,IPNBFA,IPNIDV,SOFT,<No IPNI input buffers available.>,<<T1,BFRCNT>>)
	RET

 ---------------------------------

;Here when no buffers available
NIPGB3:	MOVE T1,NIPNFI		;GET NUMBER OF BUFFERS AVAILABLE
	CAIGE T1,NNIPTH		;BELOW THE THRESHOLD LEVEL ?
	BUG.(CHK,IPNBFA,IPNIDV,SOFT,<No IPNI input buffers available.>,<<T1,BFRCNT>>)
	RET
> ; End of repeat 0

***** CHANGE #33; PAGE 29, LINE 13; PAGE 33, LINE 13
;
; Returns + 1 on error
;	  + 2 on success

	SWAPCD

NIPPIB:	CALL NIPGIB		;MAKE SURE WE HAVE ENOUGH BUFFERS
PIB1:	MOVE T1,NIPNIB		;GET # OF BUFFERS WE SHOULD HAVE
 ---------------------------------
;
; Returns + 1 on error
;	  + 2 on success

	SWAPCD

NIPPIB:
	DO.
	  MOVE T1,NIPNIB	;GET # OF BUFFERS WE SHOULD HAVE
	  LSH T1,-1		;MAKE # OF BUFFERS THAT WE WANT TO BE POSTED
	  CAMG T1,NICNTP	;REACHED THAT LEVEL ?
	   RETSKP		;YES

	  CALL NIPBFR		;GET A RECEIVE BUFFER READY
	  CALL NIPOST		;GO POST THE RECIEVE BUFFER
	   RETBAD
	  LOOP.
	ENDDO.
;/*NOTREACHED*/

repeat 0,<
	CALL NIPGIB		;MAKE SURE WE HAVE ENOUGH BUFFERS
PIB1:	MOVE T1,NIPNIB		;GET # OF BUFFERS WE SHOULD HAVE

***** CHANGE #34; PAGE 29, LINE 23; PAGE 33, LINE 38
	CAMG T1,NICNTP		;REACHED THAT LEVEL ?
	RETSKP			;YES
	CALL NIPBFR		;GET A RECEIVE BUFFER READY
	CALL NIPOST		;GO POST THE RECIEVE BUFFER
	 RETBAD
	JRST PIB1		;TRY TO GET MORE


 ---------------------------------
	CAMG T1,NICNTP		;REACHED THAT LEVEL ?
	RETSKP			;YES
	CALL NIPBFR		;GET A RECEIVE BUFFER READY
	CALL NIPOST		;GO POST THE RECIEVE BUFFER
	 RETBAD
	JRST PIB1		;TRY TO GET MORE
> ; End of repeat 0


***** CHANGE #35; PAGE 29, LINE 32; PAGE 34, LINE 8
;NIPBFR - GET AN INPUT BUFFER
;
; Returns + 1 always with T1 containing the buffer address

	RESCD

NIPBFR:	PIOFF
	SOSL T1,NIPNFI		;COUNT DOWN NUMBER OF FREE INTERNET BUFS
 ---------------------------------
;NIPBFR - GET AN INPUT BUFFER
;
; Returns + 1 always with T1 containing the buffer address

	RESCD

NIPBFR:
	LOAD T1,NTPSIZ,(NCT)	; get packet size for network
	ADDI T1,3
	LSH T1,-2		; convert to word count
	MOVX T2,NP.IP		;Protocol code is IP
	ADD T1,PROOVH(T2)	;Add in protocol overhead
	CALL GETBUF ; (T1,T2;T1)	; try to get storage
	IFE. T1
	  ;; Failed
	  CALL MNTWAK		; Get multinet fork to run later
	  SETZ T1,
	ENDIF.
	RET			; return with buffer address in T1

repeat 0,<
	PIOFF
	SOSL T1,NIPNFI		;COUNT DOWN NUMBER OF FREE INTERNET BUFS

***** CHANGE #36; PAGE 29, LINE 55; PAGE 34, LINE 46
        SETSEC T1,INTSEC	;YES SO SET THE SECTION NUMBER
	SETZRO NBQUE,(T2)	;CLEAR LIST POINTER
	MOVEM T1,NIPFRI		;BECOMES HEAD OF LIST
	PION
	MOVE T1,T2		;PUT THE ADDRESS WHERE IT'S EXPECTED
	RET

 ---------------------------------
        SETSEC T1,INTSEC	;YES SO SET THE SECTION NUMBER
	SETZRO NBQUE,(T2)	;CLEAR LIST POINTER
	MOVEM T1,NIPFRI		;BECOMES HEAD OF LIST
	PION
	MOVE T1,T2		;PUT THE ADDRESS WHERE IT'S EXPECTED
	RET
> ; End of repeat 0


***** CHANGE #37; PAGE 35, LINE 18; PAGE 40, LINE 18
; 	  + 2 on success

	SWAPCD

NICHK1:	MOVE T1,INTJFN		;PICK UP THE JFN
	MOVE T2,[POINT 36,INTBLK] ;PUT DATA INTO TEMP AREA
	MOVEI T3,NIHMDL		;READ HOST MAX DATA LENGTH WORDS
	SIN			;READ A WORD FROM THE FILE
 ---------------------------------
; 	  + 2 on success

	SWAPCD

NICHK1:	MOVE T1,INTJFN		;PICK UP THE JFN
	MOVE T2,[POINT 36,INTBLK] ;PUT DATA INTO TEMP AREA

	MOVNI T3,NIHMDL		;READ HOST MAX DATA LENGTH WORDS
repeat 0,<; Bug, T4 isn't setup...
	MOVEI T3,NIHMDL		;READ HOST MAX DATA LENGTH WORDS
> ; End of repeat 0
	SIN			;READ A WORD FROM THE FILE

***** CHANGE #38; PAGE 36, LINE 25; PAGE 41, LINE 25
	MOVX T2,^D36B5!OF%RD	;36 BIT READ ACCESS 
	OPENF%			;OPEN UP THE JFN
	 ERJMP R		;ERROR 
	MOVEM T1,INTJFN		;SAVE THE JFN
	MOVEI T2,HDRS		;POINT TO TEMP HEADER STORAGE
	IOR T2,[POINT 36,]	;FORM BYTE POINTER TO HEADERS
	MOVEI T3,NIHMHL 	;READ THE WHOLE HEADER
        SIN
 ---------------------------------
	MOVX T2,^D36B5!OF%RD	;36 BIT READ ACCESS 
	OPENF%			;OPEN UP THE JFN
	 ERJMP R		;ERROR 
	MOVEM T1,INTJFN		;SAVE THE JFN
	MOVEI T2,HDRS		;POINT TO TEMP HEADER STORAGE
	IOR T2,[POINT 36,]	;FORM BYTE POINTER TO HEADERS

	MOVNI T3,NIHMHL 	;READ THE WHOLE HEADER
repeat 0,<; Bug, T4 isn't setup...
	MOVEI T3,NIHMHL 	;READ THE WHOLE HEADER
> ; End of repeat 0
        SIN

***** CHANGE #39; PAGE 36, LINE 33; PAGE 41, LINE 37
	 ERJMP R		;ERROR 
	XMOVEI T1,HDRS		;POINT AT TEMP HEADER AREA AGAIN
	MOVE T2,.NICHK(T1)	;GET THE FILE CHECKSUM
        MOVEM T2,INTCKS 	;AND SAVE IT AWAY
	MOVE T2,.NILEN(T1)	;GET NUMBER OF WORDS LEFT
        MOVEM T2,GHTLEN 	;SAVE THE COUNT
 ---------------------------------
	 ERJMP R		;ERROR 
	XMOVEI T1,HDRS		;POINT AT TEMP HEADER AREA AGAIN
	MOVE T2,.NICHK(T1)	;GET THE FILE CHECKSUM
        MOVEM T2,INTCKS 	;AND SAVE IT AWAY
	MOVE T2,.NILEN(T1)	;GET NUMBER OF WORDS LEFT
;cwl GHTLEN doesn't seem to ever be used, but it gets clobbered here if RETBAD
        MOVEM T2,GHTLEN 	;SAVE THE COUNT

***** CHANGE #40; PAGE 37, LINE 14; PAGE 42, LINE 14
; 	  + 2 on success, address of block in T1

	SWAPCD

NIHSPC:	STKVAR <GHSIZ>
	MOVE T1,NIMAXH		;GET MAX HOSTS IN GHT
	IMULI T1,NIHMDL+1	;COMPUTE SPACE FOR AREA 2
 ---------------------------------
; 	  + 2 on success, address of block in T1

	SWAPCD

NIHSPC:	STKVAR <GHSIZ>
	MOVE T1,NIMAXH		;GET MAX HOSTS IN GHT
;cwl don't you mean NIHMDL-1 == GH2MDL
	IMULI T1,NIHMDL+1	;COMPUTE SPACE FOR AREA 2

***** CHANGE #41; PAGE 42, LINE 46; PAGE 47, LINE 46
	STOR T3,CMTYP,(CPKT)	; Set into ICMP message type field
	SETZRO CMCOD,(CPKT)	; Clear code word
	SETONE CMID,(CPKT)	; (Make field non-zero)
	AOS T1,ICMSID		; Get an Id
	STOR T1,CMSEQ,(CPKT)	; Set ICMP sequence number
	STOR T1,PISID,(PKT)	; Set IP sequence number
	CALL ICMCKS		; Compute checksum of the packet
	STOR T1,CMCKS,(CPKT)	; Insert in packet
 ---------------------------------
	STOR T3,CMTYP,(CPKT)	; Set into ICMP message type field
	SETZRO CMCOD,(CPKT)	; Clear code word
	SETONE CMID,(CPKT)	; (Make field non-zero)
	AOS T1,ICMSID		; Get an Id
	STOR T1,CMSEQ,(CPKT)	; Set ICMP sequence number
	STOR T1,PISID,(PKT)	; Set IP sequence number
	CALL DATCKS;ICMCKS	; Compute checksum of the packet
	STOR T1,CMCKS,(CPKT)	; Insert in packet

***** CHANGE #42; PAGE 46, LINE 25; PAGE 51, LINE 25
	RET


;ARPBUF - GET A BUFFER 
;
; Called  to  get  a buffer. One buffer should hold aprox 16 ARP
; packets based on a MAXWPM set to 370 words as buffer size.
;
 ---------------------------------
	RET


;ARPBUF - GET A BUFFER 
;
; Called  to  get  a buffer. One buffer should hold aprox 16 ARP
; packets.
;

***** CHANGE #43; PAGE 46, LINE 34; PAGE 51, LINE 34
; Returns + 1 always, T1/ beginning address of the buffer
;		      T2/ number of ARP buffers available

	SWAPCD

ARPBUF:	SKIPN T1,ABUFFR		;ALREADY HAVE A BUFFER ?
	IFSKP.
 ---------------------------------
; Returns + 1 always, T1/ beginning address of the buffer
;		      T2/ number of ARP buffers available

	SWAPCD

ARPBUF:	SKIPN T1,ABUFFR		;ALREADY HAVE A BUFFER ?

	 JRST ARPBF1
	MOVX T1,AR.TNB*AR.WRD	; get a block from IP free space
; This isn't really correct, we should get it from
; some general free space, but currently the only general free space
; is in section 0 and this saves some address space there...
	CALL GETBLK
	IFE. T1
	  BUG. (CHK,IPNARP,IPNIDV,SOFT,<No buffer space for ARP>)
	  RET
	ENDIF.
	MOVX T2,AR.TNB*AR.WRD	; Size of the block again
	CALL NIPLKB		; Lock it down
ARPBF1:	MOVX T2,AR.TNB		; Number of buffers in block
	RET

repeat 0,<
	IFSKP.

***** CHANGE #44; PAGE 46, LINE 53; PAGE 51, LINE 70
	ADDI T1,MAXLDR		;FOR CONSISTENCY WITH OTHER BUFFERS
	IDIVI T2,AR.WRD		;GET NUMBER OF BUFFERS
	CAIL T2,AR.TNB		;GET ENOUGH BUFFERS ?
	RET			;YES
	BUG. (INF,IPFRAB,IPNIDV,SOFT,<Fewer than required ARP buffers assigned>)
	RET

 ---------------------------------
	ADDI T1,MAXLDR		;FOR CONSISTENCY WITH OTHER BUFFERS
	IDIVI T2,AR.WRD		;GET NUMBER OF BUFFERS
	CAIL T2,AR.TNB		;GET ENOUGH BUFFERS ?
	RET			;YES
	BUG. (INF,IPFRAB,IPNIDV,SOFT,<Fewer than required ARP buffers assigned>)
	RET
> ; end of repeat 0


***** CHANGE #45; PAGE 47, LINE 20; PAGE 52, LINE 20
	  PION			;MAKE SURE INTERRUPTS ARE BACK ON
	  BUG.(CHK,IPABFL,IPNIDV,SOFT,<ARP input buffer list fouled.>)
	  SETZ T1,		;FLAG TO NIPOST THAT WE HAVE NO BUFFER
	  RETBAD		;TRY TO RECOVER
	 ENDIF.
	LOAD T1,ARPNT,(T2)	;NEXT INTERNET FREE BUFFER
        SETSEC T1,INTSEC	;YES SO SET THE SECTION NUMBER
	SETZRO ARPNT,(T2)	;CLEAR LIST POINTER
 ---------------------------------
	  PION			;MAKE SURE INTERRUPTS ARE BACK ON
	  BUG.(CHK,IPABFL,IPNIDV,SOFT,<ARP input buffer list fouled.>)
	  SETZ T1,		;FLAG TO NIPOST THAT WE HAVE NO BUFFER
	  RETBAD		;TRY TO RECOVER
	 ENDIF.
	LOAD T1,ARPNT,(T2)	;NEXT INTERNET FREE BUFFER
;       SETSEC T1,INTSEC	;YES SO SET THE SECTION NUMBER
	SETZRO ARPNT,(T2)	;CLEAR LIST POINTER

***** CHANGE #46; PAGE 48, LINE 28; PAGE 53, LINE 28
ARPSND:	SAVEAC <SRV,ARP,NCT,UNB,RID>
	MOVE NCT,NIPNCT		;GET THE NCT ADDRESS
	MOVE UNB,AUNBLK		;GET THE UN BLOCK POINTER
	CALL ARPBFR		;GET A BUFFER TO USE
	JUMPE T1,R     		;NONE AVAILABLE IF ZERO, ARPBFR BUGINF'D
	MOVE ARP,T1		
	MOVE T2,NI.HOP(RID)	;PROTOCOL TARGET ADR IS INTERNET ROUTING ADR
	STOR T2,AR$TA,(ARP)
	MOVX T2,AR.REQ		;OPCODE IS REQUEST
	STOR T2,AR$OP,(ARP)
ARPSD1:	DMOVE T2,ETHADR		;GET OUR CURRENT ETHERNET ADDRESS
	LSH T2,-4		;SHIFT RIGHT BECAUSE ETHADR IS FULL WORD
	STOR T2,AR$S1,(ARP)	; AND AR$S1 IS 32 BITS.  SAVE IT
	LSH T3,-^D20		;SHIFT RIGHT BECAUSE ETHADR+1 IS FULL WORD
	STOR T3,AR$S2,(ARP)	; AND AR$S2 IS 16 BITS.  SAVE IT
	MOVE T2,NTLADR(NCT)	;GET OUR INTERNET HOST NUMBER
 ---------------------------------
ARPSND:	SAVEAC <SRV,ARP,NCT,UNB,RID>
	MOVE NCT,NIPNCT		;GET THE NCT ADDRESS
	MOVE UNB,AUNBLK		;GET THE UN BLOCK POINTER
	CALL ARPBFR		;GET A BUFFER TO USE
	JUMPE T1,R     		;NONE AVAILABLE IF ZERO, ARPBFR BUGINF'D
	MOVE ARP,T1		

	LOAD T2,PFLAD,(RID)	;PROTOCOL TARGET ADR IS INTERNET ROUTING ADR
repeat 0,<
	MOVE T2,NI.HOP(RID)	;PROTOCOL TARGET ADR IS INTERNET ROUTING ADR
> ; end of repeat 0
	STOR T2,AR$TA,(ARP)
	MOVX T2,AR.REQ		;OPCODE IS REQUEST
	STOR T2,AR$OP,(ARP)
	MOVE T2,NTLADR(NCT)	;GET OUR INTERNET HOST NUMBER

***** CHANGE #47; PAGE 48, LINE 43; PAGE 53, LINE 42
	LSHC T2,-^D16		;HIGH 2 BYTES IN T2
	LSH T3,-^D20		;LOW 2 BYTES IN T3
	STOR T2,AR$P1,(ARP)
	STOR T3,AR$P2,(ARP)
	NOSKED			;DON'T LET OTHERS IN HERE
 ---------------------------------
	LSHC T2,-^D16		;HIGH 2 BYTES IN T2
	LSH T3,-^D20		;LOW 2 BYTES IN T3
	STOR T2,AR$P1,(ARP)
	STOR T3,AR$P2,(ARP)
ARPSD1:	DMOVE T2,ETHADR		;GET OUR CURRENT ETHERNET ADDRESS
	LSH T2,-4		;SHIFT RIGHT BECAUSE ETHADR IS FULL WORD
	STOR T2,AR$S1,(ARP)	; AND AR$S1 IS 32 BITS.  SAVE IT
	LSH T3,-^D20		;SHIFT RIGHT BECAUSE ETHADR+1 IS FULL WORD
	STOR T3,AR$S2,(ARP)	; AND AR$S2 IS 16 BITS.  SAVE IT
	NOSKED			;DON'T LET OTHERS IN HERE

***** CHANGE #48; PAGE 52, LINE 23; PAGE 57, LINE 23
ARPCDR:	LOAD T1,UNRID,(T2)	;GET THE ADDRESS OF THE BUFFER
	JUMPN T3,[CAIN T3,UNRAB% ;CHANNEL SHUTTING DOWN ?
	 	  RETBAD <>,<MOVE T1,T3> ;YES - DO NOTHING
	          AOS NIICNT	;NO. BUMP THE INPUT ERROR COUNTER
		  MOVE UNB,T2	;USE NISRV UN BLOCK TO REPOST BUFFER
	          CALLRET ARPOST] ;USE THIS BUFFER OVER
	MOVE NCT,NIPNCT		;GET OUR NCT
 ---------------------------------
ARPCDR:	LOAD T1,UNRID,(T2)	;GET THE ADDRESS OF THE BUFFER
	JUMPN T3,[CAIN T3,UNRAB% ;CHANNEL SHUTTING DOWN ?
	 	  RETBAD <>,<MOVE T1,T3> ;YES - DO NOTHING
	          AOS NIICNT	;NO. BUMP THE INPUT ERROR COUNTER
		  MOVE UNB,T2	;USE NISRV UN BLOCK TO REPOST BUFFER
	          CALLRET ARPOST] ;USE THIS BUFFER OVER

	PIOFF			;DON'T ALLOW US TO BE INTERRUPTED
	MOVE T3,ARPIQI		; Queue for processing later
	IFE. T3
	  MOVEM T1,ARPIQO	;ONLY THIS ITEM IN THE LIST
	ELSE.
	  STOR T1,ARPNT,(T3)	;Link it in
	ENDIF.
	MOVEM T1,ARPIQI		;NEW POINTER
	PION
	CALL MNTWAK		;Wake up multinet fork to process it (NIPSRV)
	RETSKP			;GIVE GOOD RETURN

RS(ARPIQI)			;Input and output pointers for received ARP
RS(ARPIQO)

repeat 0,<
	MOVE NCT,NIPNCT		;GET OUR NCT

***** CHANGE #49; PAGE 52, LINE 35; PAGE 57, LINE 52
	SKIPA
ACDRQ1:	STOR T1,ARPNT,(T3)	;LINK IT IN
	MOVEM T1,NTLOBI(NCT)	;NEW POINTER
	AOS INTFLG		;CAUSE INTERNET TO NOTICE IT.
	PION
	RETSKP			;GIVE GOOD RETURN

	SUBTTL ARP Processing by the Internet Fork 

 ---------------------------------
	SKIPA
ACDRQ1:	STOR T1,ARPNT,(T3)	;LINK IT IN
	MOVEM T1,NTLOBI(NCT)	;NEW POINTER
	AOS INTFLG		;CAUSE INTERNET TO NOTICE IT.
	PION
	RETSKP			;GIVE GOOD RETURN
> ; end of repeat 0

	SUBTTL ARP Processing by the Multinet Fork 


***** CHANGE #50; PAGE 53, LINE 9; PAGE 58, LINE 9
;ARPPRC - ARP PACKET PROCESSOR
;
; Called by NIPSRV by the internet fork to process any ARP
; packets that have been sent to us.  After the packet has 
; been processed, the input buffer is given back to NISRV.
;
; NTLOBO/ Local network (ARP) list head pointer
; NTLOBI/ Tail pointer
;
 ---------------------------------
;ARPPRC - ARP PACKET PROCESSOR
;
; Called by NIPSRV by the internet fork to process any ARP
; packets that have been sent to us.  After the packet has 
; been processed, the input buffer is given back to NISRV.
;
; ARPIQI/ Local network (ARP) list head pointer
; ARPIQO/ Tail pointer
;

***** CHANGE #51; PAGE 53, LINE 18; PAGE 58, LINE 18
; Returns + 1 always

	RESCD

ARPPRC:	SAVEAC <SRV,ARP,RID,NCT,UNB>
	MOVE NCT,NIPNCT		;GET OUR NCT ADDRESS
	MOVE UNB,AUNBLK		;GET THE ARP UN BLOCK POINTER
ARPRO1:	SKIPN ARP,NTLOBO(NCT)	;ANY INTERNET OUTPUT WAITING?
	RET             	;NO
	PIOFF			;NO INTERRUPTS
	LOAD T2,ARPNT,(ARP)	;GET ITS SUCCESSOR
	SKIPN T2        	;SKIP IF NOT LAST ONE
	SETZM NTLOBI(NCT)	;YES.  MAKE QUEUE NULL
	MOVEM T2,NTLOBO(NCT)	;UPDATE OUTPUT POINTER
	SETZRO ARPNT,(ARP)	;DEQUEUE BUFFER FROM ITS OLD CHAIN
 ---------------------------------
; Returns + 1 always

	RESCD

ARPPRC:	SAVEAC <SRV,ARP,RID,NCT,UNB>
repeat 0,<
	MOVE NCT,NIPNCT		;GET OUR NCT ADDRESS
> ; end of repeat 0
	MOVE UNB,AUNBLK		;GET THE ARP UN BLOCK POINTER
ARPRO1:
	SKIPN ARP,ARPIQO	;ANY ARP INPUT WAITING?
repeat 0,<
	SKIPN ARP,NTLOBO(NCT)	;ANY INTERNET OUTPUT WAITING?
> ; end of repeat 0
	 RET             	;NO
	PIOFF			;NO INTERRUPTS
	LOAD T2,ARPNT,(ARP)	;GET ITS SUCCESSOR
	SKIPN T2        	;SKIP IF NOT LAST ONE

	 SETZM ARPIQI		;Yes, make queue null.
	MOVEM T2,ARPIQO		;UPDATE OUTPUT POINTER
repeat 0,<
	SETZM NTLOBI(NCT)	;YES.  MAKE QUEUE NULL
	MOVEM T2,NTLOBO(NCT)	;UPDATE OUTPUT POINTER
> ; end of repeat 0
	SETZRO ARPNT,(ARP)	;DEQUEUE BUFFER FROM ITS OLD CHAIN

***** CHANGE #52; PAGE 54, LINE 19; PAGE 59, LINE 19
;
; Returns + 1 on error with T1/ error code
;	  + 2 on success

	SWAPCD

ARPRCV:	TRVAR <AREA1,AREA2,SPADR,<SHADR,2>>
	SAVEAC <ARP>		;SAVE THE CURRENT ARP POINTER 
 ---------------------------------
;
; Returns + 1 on error with T1/ error code
;	  + 2 on success

	SWAPCD

ARPRCV:	TRVAR <AREA1,AREA2,SPADR,<SHADR,2>,RPADR>
	SAVEAC <ARP>		;SAVE THE CURRENT ARP POINTER 

***** CHANGE #53; PAGE 55, LINE 21; PAGE 60, LINE 21
; NCT/ NCT address
; UNB/ address of the UN block given to us by NISRV

	SWAPCD

ARPRC2:	LOAD T1,AR$TA,(ARP)	;GET THE TARGET INTERNET ADDRESS
	CAME T1,NTLADR(NCT)	;WAS THE PACKET FOR US ?
	RET         		;NO, IGNORE IT
	SKIPE AREA2 		;SHOULD THIS INFORMATION BE INSERTED ?
 ---------------------------------
; NCT/ NCT address
; UNB/ address of the UN block given to us by NISRV

	SWAPCD

ARPRC2:	LOAD T1,AR$TA,(ARP)	;GET THE TARGET INTERNET ADDRESS
	MOVEM T1,RPADR		;Save local address used by sender
	XOR T1,NTLADR(NCT)	;Mis-match address bits
	TDZ T1,NTNLHM(NCT)	;Ignore logical host bits
	JUMPN T1,R		;Not a match, ignore it
	SKIPE AREA2 		;SHOULD THIS INFORMATION BE INSERTED ?

***** CHANGE #54; PAGE 55, LINE 38; PAGE 60, LINE 40
;ARPRC3 - STEP 3 IN PROCESSING AN ARP PACKET
;
; Here to send a reply ARP packet
;
; ARP/ address of the ARP packet
; SPADR/ sender protocol address
; UNB/ address of the UN block given to us by NISRV
 ---------------------------------
;ARPRC3 - STEP 3 IN PROCESSING AN ARP PACKET
;
; Here to send a reply ARP packet
;
; ARP/ address of the ARP packet
; SPADR/ sender protocol address
; RPADR/ receiver protocol address
; UNB/ address of the UN block given to us by NISRV

***** CHANGE #55; PAGE 55, LINE 51; PAGE 60, LINE 54

ARPRC3:	CALL ARPBFR		;GET SEND BUFFER TO USE
	JUMPE T1,R     		;NONE AVAILABLE IF ZERO, ARPBFR BUGINF'D
	MOVE ARP,T1		
	MOVE T1,SPADR		;GET THE INTERNET ADDRESS OF SENDER
	STOR T1,AR$TA,(ARP)	;SAVE THIS AS THE TARGET ADDRESS
	MOVEI T1,AR.REP		;SET OPCODE TO REPLY
 ---------------------------------

ARPRC3:	CALL ARPBFR		;GET SEND BUFFER TO USE
	JUMPE T1,R     		;NONE AVAILABLE IF ZERO, ARPBFR BUGINF'D
	MOVE ARP,T1		
	MOVE T1,SPADR		;GET THE INTERNET ADDRESS OF SENDER
	STOR T1,AR$TA,(ARP)	;SAVE THIS AS THE TARGET ADDRESS
	MOVE T2,RPADR		;Reciever protocol address
	LSHC T2,-^D16		;High 2 bytes in T2
	LSH T3,-^D20		;Low 2 bytes in T3
	STOR T2,AR$P1,(ARP)
	STOR T3,AR$P2,(ARP)
	MOVEI T1,AR.REP		;SET OPCODE TO REPLY

***** CHANGE #56; PAGE 58, LINE 18; PAGE 63, LINE 18
;	  + 2 on success

	RESCD

TRPOST:	SKIPN T1		;ZERO IF NIPBFR COULDN'T GET A BUFFER
	RETBAD <NI.ER1>		;RETURN THE ERROR
	LOAD T3,NBBSZ,(T1) 	;GET BUFFER SIZE
	SUBI T3,LCLPKT+MAXLDR	;DON'T INCLUDE LEADER SIZE
	LSH T3,2		;MAKE WORDS INTO BYTES
	STOR T3,UNBSZ,(UNB)	;SAVE IT AS RECEIVE BUFFER SIZE
	STOR T1,UNRID,(UNB)	;SAVE INPUT BUFFER ADR AS REQUEST ID
	ADDI T1,MAXLDR		;POINT PAST LEADER FOR START OF IP HEADER
	TXO T1,<OWGP. 8,>	;FORM BYTE POINTER TO BUFFER
 ---------------------------------
;	  + 2 on success

	RESCD

TRPOST:	SKIPN T1		;ZERO IF NIPBFR COULDN'T GET A BUFFER
	RETBAD <NI.ER1>		;RETURN THE ERROR

	LOAD T3,PLNBZ,(T1)	;Get size in bytes
repeat 0,<
	LOAD T3,NBBSZ,(T1) 	;GET BUFFER SIZE
	SUBI T3,LCLPKT+MAXLDR	;DON'T INCLUDE LEADER SIZE
	LSH T3,2		;MAKE WORDS INTO BYTES
> ; end of repeat 0
	STOR T3,UNBSZ,(UNB)	;SAVE IT AS RECEIVE BUFFER SIZE
	STOR T1,UNRID,(UNB)	;SAVE INPUT BUFFER ADR AS REQUEST ID

	PNTLDR T1,PLNDT,(T1)	;Point to data region
repeat 0,<
	ADDI T1,MAXLDR		;POINT PAST LEADER FOR START OF IP HEADER
> ; end of repeat 0
	TXO T1,<OWGP. 8,>	;FORM BYTE POINTER TO BUFFER

***** CHANGE #57; PAGE 63, LINE 5; PAGE 68, LINE 5



	TNXEND
	END



 ---------------------------------



	TNXEND
	END

