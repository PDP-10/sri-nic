REDIT 1(104) COMPARE by user CLYNN, 10-Feb-86 18:58:46
File 1: CWL:<DEC-6-1-BASE>PAGEM.MAC.1
File 2: CWL:<5-4-NET>PAGEM.MAC.5
***** CHANGE #1; PAGE 6, LINE 39; PAGE 6, LINE 39
	STOR T2,IPPGN,T3
	MOVEM T3,MSECTB+IDXSEC	;SET IDX SECTION
	MOVE T4,[IFIW FPTA7]	;IDX ADDRESS
	MOVEM T4,FPTABL+IDXSEC	;TO THE TABLE
	MOVE T4,[IFIW FPTA8]	;BIT TABLE HANDLER
	MOVEM T4,FPTABL+BTSEC	;TO THE TABLE
	MOVE T4,[IFIW FPTINT]	;INTERNET SECTION
	SKIPE [INTSEC]		;SPECIAL INTERNET SECTION?
	 MOVEM T4,FPTABL+INTSEC	;YES SO PUT IT IN THE TABLE
	MOVE T4,[IFIW FPTACI]	;SET LCS AND CI SECTION
 ---------------------------------
	STOR T2,IPPGN,T3
	MOVEM T3,MSECTB+IDXSEC	;SET IDX SECTION
	MOVE T4,[IFIW FPTA7]	;IDX ADDRESS
	MOVEM T4,FPTABL+IDXSEC	;TO THE TABLE
	MOVE T4,[IFIW FPTA8]	;BIT TABLE HANDLER
	MOVEM T4,FPTABL+BTSEC	;TO THE TABLE

	MOVE T4,[IFIW FPTMNT]	; Multinet section
	SKIPN [MNTSEC]
	IFSKP.
	  MOVEM T4,FPTABL+MNTSEC
	  CALL ASSPT		;GET AN SPT SLOT
	  MOVE T2,SHRPTR	;GET A PROTOTYPE SHARE POINTER
	  STOR T1,SPTX,T2	;BUILD THE PAGE MAP POINTER
	  MOVEM T2,MSECTB+MNTSEC ;PUT THE POINTER IN THE SECTION TABLE
	  MOVEI T2,MNTIX/PGSIZ	;GET THE PAGE NUMBER OF THE MAP MAP
	  MOVEM T2,SPT(T1)	;SET THE POINTER FOR THE SPT
	  CALL UPSHR		;Init share count
	ENDIF.

	MOVE T4,[IFIW FPTDM1]	; Set Domain section 1
	SKIPE [DOMSEC]
	  MOVEM T4,FPTABL+DOMSEC ; Into table

	MOVE T4,[IFIW FPTDM2]	; Set Domain section 2
	SKIPE [DM2SEC]
	  MOVEM T4,FPTABL+DM2SEC ; Into table

	MOVE T4,[IFIW FPTACI]	;SET LCS AND CI SECTION

***** CHANGE #2; PAGE 12, LINE 29; PAGE 12, LINE 29
	SETZM .JBSYM		;THESE WILL BE INVALID AFTER CALLING PGRON
	SETZM .JBUSY		;  ..


;SET TO KNOWN UPT SO NXM FAULTS BELOW WILL WORK

PGRI8:
	SKIPN [INTSEC]		;SPECIAL INTERNET SECTION?
	 JRST PGRI80		;NO SO SKIP THIS STUFF
	CALL ASSPT		;GET AN SPT SLOT
	MOVE T2,SHRPTR		;GET A PROTOTYPE SHARE POINTER
	STOR T1,SPTX,T2		;BUILD THE PAGE MAP POINTER
	MOVEM T2,MSECTB+INTSEC	;PUT THE POINTER IN THE SECTION TABLE
	MOVEI T2,INTIX/PGSIZ	;GET THE PAGE NUMBER OF THE MAP MAP
	MOVEM T2,SPT(T1)	;SET THE POINTER FOR THE SPT
PGRI80:
	CALL SETPSK		;SET TO SCHED CONTEXT
	CALL PGRON		;ENABLE PAGER
 ---------------------------------
	SETZM .JBSYM		;THESE WILL BE INVALID AFTER CALLING PGRON
	SETZM .JBUSY		;  ..


;SET TO KNOWN UPT SO NXM FAULTS BELOW WILL WORK

PGRI8:	CALL SETPSK		;SET TO SCHED CONTEXT
	CALL PGRON		;ENABLE PAGER

***** CHANGE #3; PAGE 42, LINE 10; PAGE 42, LINE 10
;	CALL RELOFN/DELPT
; RETURN +1 ALWAYS, A/ PAGE COUNT IN XB IF FILE COMPLETELY CLOSED,
;		-1 IF FILE NOT COMPLETELY CLOSED.

DELOF==1B0			;LOCAL FLAG IN Q1 FOR DELETE/RELEASE

DELPT::	SAVEQ
	MOVX Q1,DELOF		;SAY DELETE
 ---------------------------------
;	CALL RELOFN/DELPT
; RETURN +1 ALWAYS, A/ PAGE COUNT IN XB IF FILE COMPLETELY CLOSED,
;		-1 IF FILE NOT COMPLETELY CLOSED.

DELOF==1B0			;LOCAL FLAG IN Q1 FOR DELETE/RELEASE

DELPT::	SAVEPQ
	MOVX Q1,DELOF		;SAY DELETE

***** CHANGE #4; PAGE 89, LINE 29; PAGE 89, LINE 29

;DECREMENT SHARE COUNT

DWNSHR::SAVEAC <Q1,Q2>		;GET A WORK REGISTER
	HRRZ Q1,T1		;GET SPT INDEX
	CAIL Q1,NOFN		;AN OFN
	JRST [	DECR SPTSHC,(Q1) ;NO. DECREMENT SPT SHARE COUNT
		RET]		;AND DONE
 ---------------------------------

;DECREMENT SHARE COUNT

DWNSHR::SAVEAC <Q1,Q2>		;GET A WORK REGISTER
	HRRZ Q1,T1		;GET SPT INDEX
	CAIL Q1,NOFN		;AN OFN
	JRST [	MOVX CX,-USHR	;No, Share count field
		TDNN CX,SPT(Q1)	;Already zero?
		  BUG.(HLT,SPTSHD,PAGEM,SOFT,
<DWNSHR-SPT SHARE COUNT UNDERFLOW>,,<

Cause:	The share count for an SPT slot (not an OFN) is about to be
	decremented below zero.  (This might be caused by a pathological
	program.)
>)
		DECR SPTSHC,(Q1) ;NO. DECREMENT SPT SHARE COUNT
		RET]		;AND DONE

***** CHANGE #5; PAGE 95, LINE 28; PAGE 95, LINE 28

;Section reserved for bittable. Return (OFN for currently mapped bittable,,PN)

FPTA8:	HRRZ T1,MSECTB+BTSEC	;FIND BITMAP
	JRST FPTAS		;GO FINISH UP

FPTINT:	HRRZ T1,MSECTB+INTSEC	;FIND INTERNET DATA MAP
	JRST FPTAS		;GO FINISH UP

 ---------------------------------

;Section reserved for bittable. Return (OFN for currently mapped bittable,,PN)

FPTA8:	HRRZ T1,MSECTB+BTSEC	;FIND BITMAP
	JRST FPTAS		;GO FINISH UP

FPTMNT:	HRRZ T1,MSECTB+MNTSEC	; Multinet section map
	JRST FPTAS

FPTDM1:	HRRZ T1,MSECTB+DOMSEC	;Share pointer to domain index page 1
	JRST FPTAS

FPTDM2:	HRRZ T1,MSECTB+DM2SEC	;Share pointer to domain index page 2
	JRST FPTAS


***** CHANGE #6; PAGE 99, LINE 24; PAGE 99, LINE 24
	AOS LOKPGS		;NO, COUNT IT
	AOS BALSHC
	AOS SUMNR
	AOS SUMBNR
	TLO 2,(1B0)		;SET LOCAL FLAG FOR TEST BELOW
MLKPG3:	MOVSI 1,(PLKV)
	ADDM 1,CST1(2)		;INCREMENT LOCK COUNT
	AOS LOKSUM
 ---------------------------------
	AOS LOKPGS		;NO, COUNT IT
	AOS BALSHC
	AOS SUMNR
	AOS SUMBNR
	TLO 2,(1B0)		;SET LOCAL FLAG FOR TEST BELOW
MLKPG3:	MOVSI 1,(PLKV)
	ADDB 1,CST1(2)		;INCREMENT LOCK COUNT
	TXNN T1,-PLKV		; Did lock overflow?
	 BUG.(HLT,MLKOVF,PAGEM,SOFT,<SPT share count overflow>,<<T2,SPTX>>,<

Cause:	A page's share count has been incremented too many times.

Action:	Determine why.

Data:	SPT index of page involved.

>)
	AOS LOKSUM

***** CHANGE #7; PAGE 111, LINE 43; PAGE 111, LINE 43
		LOAD 2,STGADR,SPT(1) ;AND ADDRESS FROM SPT
		JRST .+1]
PREPG5:	TLNE 2,(NCORTM)		;PAGE NOW IN CORE?
	JRST [	TLNN 2,(DSKAB+DRMAB) ;PAGE IS ASSIGNED?
		JRST PREPG2	;NO
;**;[2895] Replace line deleted by 2893	PED	10-JAN-83
		SKIPLE NRPLQ
		CALL SWPIN	;YES, SWAP IT IN
 ---------------------------------
		LOAD 2,STGADR,SPT(1) ;AND ADDRESS FROM SPT
		JRST .+1]
PREPG5:	TLNE 2,(NCORTM)		;PAGE NOW IN CORE?
	JRST [	TLNN 2,(DSKAB+DRMAB) ;PAGE IS ASSIGNED?
		JRST PREPG2	;NO
;**;[2895] Replace line deleted by 2893	PED	10-JAN-83
		SKIPLE NRPLQ	;FREE PAGE AVAILABLE?
		CALL SWPIN	;YES, SWAP IT IN

***** CHANGE #8; PAGE 190, LINE 33; PAGE 190, LINE 33
TSTSPT:	LOAD T2,STGADR,SPT(T1) ;GET ADDRESS
	TXNE T2,NCORTM		;IN MEMORY?
	RETSKP			;NO. NOT IN TRANSITION THEN
	JE CSTPST,(T2),RSKP	;IN TRANSITION?
	RET			;YES.

	TNXEND
 ---------------------------------
TSTSPT:	LOAD T2,STGADR,SPT(T1) ;GET ADDRESS
	TXNE T2,NCORTM		;IN MEMORY?
	RETSKP			;NO. NOT IN TRANSITION THEN
	JE CSTPST,(T2),RSKP	;IN TRANSITION?
	RET			;YES.


;
; Routines to get memory without going through page trap
; and swapping overhead. Used by the network buffer routines

; STEALP - steal a page from the system free list
; Called NOSKED
;	T1/	Virtual address
;		Must not have a page allocated
;		Must be a monitor address, no indirection in page table
; Returns +1 always
;
STEALP::
	CALL	FPTA		; -> PT.PN
	CALLRET MLKPG
; This needs to be written
	IFE. T1
	 JSR	BUGHLT		; If no such section
	ENDIF.
	HLRZ	T2,T1		; get PT
	HRRZ	T2,SPT(T2)	; and SPT index
	LSH	T2,^D9		; shift to page index
	ADDI	T2,(T1)		; address of PTE
	SKIPN	(T2)		; page must not exist
	IFSKP.
	  JSR	BUGHLT		; error
	ENDIF.

; RETRNP - Return a page to the free list
; Called PIOFF
;	T1/	Virtual address
RETRNP::
	CALLRET	MULKSP

	TNXEND

