;SMPCNT
;NPKTP

;bug - histogram of protocol codes looses when packet is a local net (RFNM)
	TITLE PKTPRN.MAC	;Format a binary packet trace file
	SUBTTL Definitions

IFNDEF VRSN,<VRSN==10>
VMAJOR=VRSN

DEFINE TELL(V)<IF1<PRINTX % Assembling for version V>>
	TELL (\VMAJOR)

; Version support macros

; "IF OLDER THAN VERSION n"

DEFINE IFO(V,STUFF)<IFL <VMAJOR-V>,<STUFF>>

; "IF VERSION n"

DEFINE IFVR(V,STUFF)<IFE <VMAJOR-V>,<STUFF>>

; "IF VERSION n OR LATER"

DEFINE IFV(V,STUFF)<IFGE <VMAJOR-V>,<STUFF>>


	SEARCH ANAUNV,MONSYM,MACSYM
	SALL

VWHO==10
;10=JDelSignore
;7=by CLynn

;VMAJOR==1	;Changes in items traced/listed, etc.
VMINOR==2	;Format for DEC 5.3 ff
;VMINOR==1	;Number of old trace file formats supported - new format when
		;tracing file format changes in ways other than "symbol defs"
VEDIT==165	;28-May-85 CLynn Add UDP, fix extract summary bug, pro->tocols
;164	; 840215 CLynn Add EXTRACT
;163	; 840213 CLynn Use double precision in XRTCMP, bug fixes
;162	; 840212 CLynn Actual version #; added DRIVER-UTILIZATION
;EDIT 13 Massive overhaul, shrink to 1 version only, add TCB support
;EDIT 12 Fixed for canned interrupt samples, magnitudes, option lengths
;EDIT 11 Combined versions using VMAJOR, added conditionals
;EDIT 10 Added Buffer header and Register samples
;EDIT 07 Much expanded, new packet printer trace format
;EDIT 06 Ports only if TCP, some ICMP support
;EDIT 05 Modify for larger trace packets with new TCPPP.MAC
;EDIT 04 Modify for larger trace packets with new TCPPP.MAC
;EDIT 03 Add print options, etc.
;EDIT 02 ADD LEFT-HALF OF (PKT) AS NOTE
;EDIT 01 ADD PACKET ADDRESS


;AC Definitions

F==0
; Reading input file
 F%EOF== 400000,,0	; Saw input EOF
; LISTing packets
 F%GB==  200000,,0	; Print garbage octets
 F%FILP==100000,,0	; FILE-POSITION
 F%NDAT==040000,,0	; No data
 F%OMIT==020000,,0	; Print omitted count
 F%LLDR==010000,,0	; Print local leaders
 F%BIN== 004000,,0	; Print TCP data as BINARY
 F%NIP== 002000,,0	; Not an IP traced packet
 F%NNIP==001000,,0	; Next F%NIP
 F%PG==  000400,,0	; Paginate
 F%NOPY==000200,,0	; No parity bit
 F%SF==  000100,,0	; Use short format
 F%TMP=  000040,,0	; Temp bit for local usage
 F%TX==  000020,,0	; Print TCP data as ASCII
 F%0PKT==000010,,0	; No packet in PACKET
 F%FCOR==000004,,0	; Input file is from core dump
 F%CORD==000002,,0	; Data is core, not packet
 F%INTL==000001,,0	; List internal fields
; DRIVER UTILIZATION
 F%FILP==100000,,0	; FILE-POSITION
 F%NDAT==040000,,0	; No (detail) data
 F%SF==  000100,,0	; Use short format (graph)
 FNSEQ%==000040,,0	; Packets not sequential

; Parsing
TMPFLG==777		; Temporary flags
 F.NO==  0,,000001	; Saw "NO"



T1=1			; After LOOP:, output jfn
T2=2
T3=3
T4=4
T5=5

; During DRIVER UTILIZATION processing
TQD==5		; Current packet's TODCLK Queued
TDB==6		; Current packet's TODCLK Driver Began
TDE==7		; Current packet's TODCLK Driver Ended

;Q1==5
;PTR==5	;Saved address of NCTiG
;Q2==6
;LEN==6	;Ring buffer length from 0(Q1)
;CUR==7	;Current pointer from 1(Q1)
;WRP==10 ;Contains the last address in the ring buffer for wrap around comp.
;IDX==11 ;Pseudo "AOBJN" pointer into ring buffer
;HST=12		; Histogram address

; During parameter parsing
EST=10		; Command parser error string, or 0
FCT=11		; Command Keyword Variable
HST=12		; Command Host Address
PRT=13		; Command Port Number
;STP=15		; Command Temp used by ANYOF routine
TMP=14		; Temporary

TA=6		; Used by Filter command
TI=7

; During packet LISTing
OP=10		; Byte pointer into packet
PL=11		; # bytes remaining from trace info
VL=12		; # bytes remaining from full packet
COD=13
TPKT=14		; Points to (included) (session level) TCP header
IPKT=15		; Points to (included) IP header (-PKTELI)

CX=16		; Very temp
P=17		; Stack pointer
; Parameters

;Function vector
FCTOF.==5	; Output file size, etc.
FCTGI.==4	; Instruction to init function before parsing commands
FCTCM.==3	; Instruction to complete processing of function line
FCTPR.==2	; Instruction to init before scanning data
FCTPS.==1	; Instruction to report results after scanning data
FCTDT.==0	; Routine to process sample

DECRAD==12
OCTRAD==10
C.LF==12
PDLL==200		; Length of stack

MAXSAV==20

FLDEF==1B18		; Field bit for "DEFAULT"
FLDNO==1B19		; Field bit for "NO"
FLRTN==1B20		; Field bit for routine to be called

PT%%VN==0	; obsolete


DEFINE	GREET	(MJ,MN,ED)<
	HRROI T1,[ASCIZ /
TCP Packet Trace Listing Program   V'MJ'.'MN(ED)/]>


	DEFINE LOADI (AC,STR,Y)<
	..STR0 (..LDI,AC,STR,Y)>

	DEFINE ..LDI (AC,LOC,MSK)<
	MOVEI AC,LOC>

; UDP Header Information

.UDPFM==^D17		; UDP protocol not in MONSYM
DEFSTR UDPSP,0,15,16	; UDP source port
DEFSTR UDPDP,0,31,16	; UDP destination port
DEFSTR UDLEN,1,15,16	; UDP length, including 8-byte UDP header
DEFSTR UDCKS,1,31,16	; UDP checksum (incl. PISH, PIDH, =.UDPFM, UDLEN)
 .UDPBZ==^D8		; Legnth UDP header, bytes

; Domain header information

DEFSTR DOMID,0,15,16	; ID
DEFSTR DOMRP,0,16,1	; Reply
DEFSTR DOMCD,0,20,4	; Opcode
 .DMSTD==0		; Standard
 .DMINV==1		; Inverse
 .DMCM==2		; Completion multiple
 .DMCU==3		; Completion unique
DEFSTR DOMAA,0,21,1	; Authoritative
DEFSTR DOMTC,0,22,1	; Truncated
DEFSTR DOMRD,0,23,1	; Recursion desired
DEFSTR DOMRA,0,24,1	; Recursion available
DEFSTR DOMUN,0,27,3	; Unused
DEFSTR DOMRC,0,31,4	; Reply code
 .DMEOK==0		; Ok
 .DMEFE==1		; Format error
 .DMESF==2		; Server failure
 .DMENE==3		; Name error
 .DMENI==4		; Not implemented
 .DMERF==5		; Refused
DEFSTR DOMQD,1,15,16	; QD count
DEFSTR DOMAN,1,31,16	; AN count
DEFSTR DOMNS,2,15,16	; NS count
DEFSTR DOMAR,2,31,16	; AR count
 .DMQST==3		; Offset to question


DEFSTR(PKTQ.,0,35,36)

DEFINE PNTR(ac,of,ms)<POINTR of,ms>

;	PFIELD	<PIPL,PITTL>,(4)

DEFINE	PFIELD(lst,of)<
	IRP lst,< %'lst(PNTR,,of,lst)	>
> ; End of DEFINE PFIELD


DEFINE XNOUT(fmt)<
	MOVX T3,<fmt>
	NOUT
	  JFCL
>

DEFINE SSOUT(string)<
	HRROI T2,[ASCIZ \string\]
	SETZ T3,
	SOUT
>

DEFINE TEXT(string,no<0>,yes<0>)<CM%FW+FLD(no,NOKY)+FLD(yes,OKKY)
	ASCIZ \string\>

; Begin a COMND% JSYS (TBLUK% JSYS) style table
DEFINE TBBEG(TABLE)<
	..TBS==.;;		Remember start address
IFNB <TABLE>,<
TABLE:>;;			Define tag if supplied
	0,,0;;			Allocate slot for header
	..TBX==0;;		Init counter
>
; Generate a table entry
DEFINE TB(TXT,ENT)<
	TXT,,ENT;;		Generate the entry
	..TBX==..TBX+1;;	Count it
>
; End a table
DEFINE TBEND(TABLE<..TBS>)<
	LOC TABLE;;		Get to the start of the table
	..TBX,,..TBX;;		Generate the entry
	LOC;;			Back to where we were
>

;	XX (Lnam,bit,oct,title,nam,off,fmt)
LSTBIT==0
LSTLTH==1
LSTTTL==2
LSTT2==3
LSTT3==4
LSTSIZ==5

; lab		optional label for item
; bit		1B<?> bit corresponding to item
; oct		# octets required to have item in sample
; ttl		<string> for long form item title
; nam,off	blank		off is address of word	LSTT2 is LDB pointer
;		structure name	off is optional offset	LSTT2 is LDB pointer
;		<string>	off is unused		LSTT2 is [ASCIZ /.../]
; fmt		0 if		nam is <string>		LSTT3 is 0
;		routine to be called			LSTT3 is routine
;		NOUT format specification		LSTT3 is NOUT format

DEFINE XX(lab,bit,oct,ttl,nam,off,fmt)<
IFNB <lab>,<lab:>
	EXP bit,oct
IFNB <ttl>,<	[ASCIZ \ttl\]>
IFB  <ttl>,<	[ASCIZ \ \]>
IFB  <nam>,<			POINT 36,off,35>
IFNB <nam>,<	IFDEF  %'nam,<	%'nam (PNTR,,<off>,nam)	>
		IFNDEF %'nam,<	[ASCIZ \off\]>>
	EXP fmt
.XX==.XX+1
> ; End of DEFINE XX

	SUBTTL	Interrupt Tables
	LOC 2000

LEVTAB:	EXP 0,0,RETPC3

CHNTAB:	EXP 0,0,0,0,0,0		; 0-5
	0			; 6  Arithmetic Overflowl/nodiv
	0			; 7  Floating Point overflow/FXU
	0			; 8
	0			; 9  PDLOV
	0			; 10 EOF
	0			; 11 IO Data Error
	0			; 12 Quota Exceeded
	0			; 13
	0			; 14 Time of Day
	0			; 15 Illeg Instruction Int
	0			; 16 Illeg Memory Read
	0			; 17 Illeg Memory Write
	0			; 18 Illeg Memory Execute
	0			; 19 Fork Term
	0			; 20 Machine size exceeded (Disk/Drum??)
	0			; 21 Trap to User
	0			; 22 New Page
	0			; 23
	0			; 24
CGICHN==.-CHNTAB		; Bell typed
	3,,CTGINT		; 25
CTICHN==.-CHNTAB		; Control-T interrupt
	3,,CTTINT		; 26
	0			; 27
	EXP 0,0,0,0,0,0,0,0	; 28-35
IFN <.-44-CHNTAB>,<PRINTX ; CHNTAB not 36 long>

RETPC3:	BLOCK 1			; Level 3 saved PC
PI3AC:	BLOCK 20		; Level 3 saved ACs

; Version 0 constants

PTDTAL==5		; Length of tracer data
PTDTAO==44		; Offset to tracer data
IPTRSZ:	62		; Size of packets from IP/TCP packet printer
;MAXPKT==62+LCLPKT+20	; 20 should be unused
MAXPKT=777-<NPACKET-NPKTN>

; Parameters

DMXDL==20		; Default # bytes to list

;Variables

CORADR:	BLOCK 1		; Core address
DFN:	BLOCK 10	; Default file name
DMPLTH:	0		; Length of dump block
CORCNT:	-DMXDL		; # words to list in core blocks

DATDLN:	DMXDL		; # data octets to be listed

FBFR:	DBFR		; Bits for Buffer Header information
FREG:	DREG		; Bits for Register information
FINT:	DFINT		; Bits for Internal packet information
FLN:	DFLN		; Bits for Local Net Leader to be listed
FIP:	DFIP		; Bits for IP Header fields to be listed
FICMP:	DFICMP		; Bits for ICMP Header fields to be listed
FTCP:	DFTCP		; Bits for TCP Header fields to be listed
FTCB:	DFTCB		; Bits for TCB Header fields to be listed
 FTBDED:DFTDED		;   Bits for sub-field DEAD-TCB-FIELDS
 FTBDEC:DFTDEC		;   Bits for sub-field DEC-TCB-FIELDS
 FTBERR:DFTERR		;   Bits for sub-field ERROR-FIELDS
 FTBFLO:DFTFLO		;   Bits for sub-field FLOW-CONTROL-FIELDS
 FTBIDF:DFTIDF		;   Bits for sub-field IDENTIFYING-FIELDS
 FTBINT:DFTINT		;   Bits for sub-field INTERRUPT-FIELDS
 FTBOPT:DFTOPT		;   Bits for sub-field OPTION-FIELDS
 FTBRSC:DFTRSC		;   Bits for sub-field R-S-COUNT-FIELDS
 FTBRCV:DFTRCV		;   Bits for sub-field RECEIVE-FIELDS
  FTBRX:DFTRX		;   Bits for sub-field RETRANSMISSION-FIELDS
 FTBROU:DFTROU		;   Bits for sub-field ROUTE-FIELDS
 FTBSND:DFTSND		;   Bits for sub-field SEND-FIELDS
 FTBTIM:DFTTIM		;   Bits for sub-field TIME-FIELDS
FUDP:	DFUDP		; Bits for UDP Header fields to be listed

FP53:	DFP53		; Bits for Domain (Port 53) fields

EXECFH:	0		; Inferior EXEC's fork handle
FUNCT:	IFIW+.DOSAM	; Function to be performed

JFNI:	0		; Binary input jfn
JFNO:	0		; Ascii output jfn (usually in T1)
JFNT:	0		; Trash JFN from .CMFIL
OLDTIM:	0		; Time of last packet
FILBYT:	0		; Position of sample in input file
HDRCNT:	0		; # of header lines listed
LOSTLN:	0		; before sample #,,# samples lost
LOSTOT:	0		; # gaps,,total samples lost
PAGCNT:	0		; Count down lines in page
PAGE:	0		; Page #
PAT:	BLOCK 100	; Patch area
PDLP:   IOWD PDLL,PDL
PDL:	BLOCK PDLL	; Stack
PTVSRT:	0		; -1 if PTVALS has been sorted w/o error
OTITLE:	BLOCK 50	; Page heading
SKPCNT:	0		; Number of initial samples to skip
SMPCNT:	0		; # samples listed
STRING:	BLOCK 100
STRTOF:	0		; Starting offset in samples
TDATA:	0		; Points to TCP data
TAKJFN:	0		; Holds current TAKE JFN
TAKLVL:	0		; Current TAKE nesting level
CMDIOJ:	0		; COMND Input/Output JFN
VERSUN:	VMINOR		; Trace file format
WATCNT:	-1		; Sample number before which to wait


	LOC <<.+777>/1000>*1000
NPKTN:	0		; Sample # in npacket
NFLBYT:	0		; Offset of sample in input file
NLDOCT:	0		; # leader octets in sample (back from PKTELI)
NTPBZ:	0		; # transport octets in sample (foreward from PKTELI)
NPTDTA:	BLOCK PPPKTO	; Trace info
CORWRD:	BLOCK 1
NPACKET:BLOCK 1000	; Next packet


	
	LOC <<.+777>/1000>*1000
PKTN:	0		; Sample # in packet
FLBYT:	0		; Offset of sample in input file
LDOCT:	0		; # leader octets in sample (back from PKTELI)
TPBZ:	0		; # transport octets in sample
PTDTA:	BLOCK PPPKTO	; Trace info
	BLOCK 1
PACKET:	BLOCK 1000	; Binary trace data

; Version 10 format

PPKT==PTDTA

;Name		IP/TCP Sample Format	Local Net Sample (PT%%NT=1 in DPTRC)
;=======	=====================	====================================
;DLENW	  =	Length of sample	Length of sample
;DPTRC	  =	Trace code		Trace code
;DTIME	  =	TODCLK			TODCLK
;DSTAT	  =	TCB TSTAT word flags	PKTFLG
;DAUXI	  =	Lost samples		Lost samples
;DPKTP	BFR/na	Packet address		Packet address
;DTYPE	  =	Data type of item sampled (ie. ND.xxx)
;DTCBN	  =	TCB Number of words sampled
;DTCBO	  =	TCB Offset of the first word sampled
;PPPKTO	BFR/REG	Info @ Packet address	Info @ Packet address + SAMPKT
;		...			(SAMPKT to LCLPKT 0 for NCP pkts)


	LOC <<.+777>/1000>*1000

ENTVEC:	JRST START
	JRST RENTR
	<VWHO>B2+<VMAJOR>B11+<VMINOR>B17+VEDIT


; Parameter parsing

CMDBSZ==50		; Length (words) of COMND input buffer
ATMBSZ==10		; Length (words) of COMND atom buffer
CMDSZ==.CMGJB+1		; Length of COMND State Block
GJFNSZ==.GJATR+1	; Length of GTJFN Block
ERMSGS==10		; Words in error string buffer

MSKSTR	(NXFDB,.CMFNP,777777)	; Addess of next Function Descriptor Block

DEFSTR	(NOKY,0,23,4)	; Flags for NO ...
DEFSTR	(OKKY,0,29,4)	; Flags for ...
DEFSTR	(CRKY,0,35,4)	; Current falgs: CM%ABR, CM%NOR, CM%INV


CMDBUF:	BLOCK CMDBSZ	; COMND input buffer
ATMBUF:	BLOCK ATMBSZ	; COMND atom buffer

CMD:	BLOCK CMDSZ	; Command State Block
GJFN:	BLOCK GJFNSZ	; Long-form GTJFN Block

CURFDB: 0		;Current FLDDB, Address
CURP:   0		;Current Stack Pointer
CURPMT: 0		;Current Prompter Pointer
LSTFDB: 0		;Last FDB used by NOCMD

ERMSG:	ASCII /     /	; For system error string
	BLOCK ERMSGS-1

FORHST:	0,0		;Foreign address/mask, etc
FORPRT:	0,0
LCLHST:	0,0
LCLPRT:	0,0

	0			; Parallel HELP keywords
	JFCL			; Reparse instruction
DECFDB:	FLDDB.	(.CMNUM,,DECRAD,,,)

OCTFDB:	FLDDB. (.CMNUM,,OCTRAD,,0,)



; HELP Text

HALL:	ASCIZ	/Process all items./
HELPTX:	ASCIZ	/HELP    displays information about the commands which may be
specified.  Information about a particular topic is obtained by typing
HELP ,  then pressing RETURN and entering a topic name./
HEXIT:	ASCIZ	/EXIT returns to the EXEC./
HGO:	ASCIZ	/GO begins processing the data file./
HINPUT:	ASCIZ	/INPUT specifies the file containing the binary trace data./
HOUTPU:	ASCIZ	/OUTPUT specifies the file for the listing output./


TX1822:	TEXT <1822>
TX1TY:	TEXT <1822-TYPE>
TXAPDT:	TEXT <A-ADDRESS>
TXAPBZ:	TEXT <A-LENGTH>
TXACK:	TEXT <ACK>
TXACKS:	TEXT <ACK-SEQUENCE>
TXNAM:	TEXT <ACTUAL-TRANSMISSION-TIME>
TXADR:	TEXT <ADDRESS>
TXALL:	TEXT <ALL>,CM%NOR
TXASC:	TEXT <ASCII>
TXANXX:	TEXT <AN20>
TXAFM:	TEXT <AUGMENT-FILE-MOVER>
TXBFLD:	TEXT <B-FIELDS>
TXSTBM:	TEXT <BACKROOM-SATNET-MONITORING>,CM%NOR
TXRCC:	TEXT <BBN-RCC-MONITORING>,CM%NOR
TXBCNT:	TEXT <BCNT>
TXBDAD:	TEXT <BDADR>
TXBDSP:	TEXT <BDSPT>
TXBFRL:	TEXT <BFRFLG>
TXBFRK:	TEXT <BFRKX>
TXBFRM:	TEXT <BFRMN>
TXBFRO:	TEXT <BFROPT>
TXBFRQ:	TEXT <BFRQ>
TXBFSR:	TEXT <BFSRC>
TXBHAD:	TEXT <BHADR>
TXBHSP:	TEXT <BHSPT>
TXBICN:	TEXT <BICNT>
TXBIDX:	TEXT <BIDX>
TXBIN:	TEXT <BINARY>
TXBPTR:	TEXT <BPTR>
TXBTCB:	TEXT <BTCB>
TXBTS:	TEXT <BTS>
TXBFRD:	TEXT <BUFFER-FIELDS>
TXBFRS:	TEXT <BUFFER-SAMPLES>,CM%NOR
TXCHAS:	TEXT <CHAOS>,CM%NOR
TXCHKS:	TEXT <CHECKSUM>
TXCKSM:	TEXT <CHECKSUM>,CM%NOR
TXCLER:	TEXT <CLEAR>,CM%NOR
TXCMCC:	TEXT <CMCC-GATEWAY-MONITORING-MSG>,CM%NOR
TXCODE:	TEXT <CODE>
TXCODS:	TEXT <CODES>
TXCMPR:	TEXT <COMPLETION-ROUTINE>
TXCONT:	TEXT <CONTINUE>,CM%NOR
TXCNTL:	TEXT <CONTROL>
TXCORF:	TEXT <CORE-INPUT-FILE>
TXCSMP:	TEXT <CSNET-MAILBOX-NAME-SERVER-PROGRAM>
TXCSMT:	TEXT <CSNET-MAILBOX-NAME-SERVER-TELNET>
TXDATP:	TEXT <DATA-ADDRESS>
TXDATA:	TEXT <DATA-OCTETS>
TXDATO:	TEXT <DATA-OFFSET>
TXDC:	TEXT <DATACOMPUTER>
TXDCCA:	TEXT <DATACOMPUTER-CCA>
TXDCS:	TEXT <DATACOMPUTER-STATUS>
TXDAT:	TEXT <DATE-TIME>
TXDCN:	TEXT <DCN>,CM%NOR
TXDEDF:	TEXT <DEAD-TCB-FIELDS>
TXDECF:	TEXT <DEC-TCB-FIELDS>
TXDCT:	TEXT <DESTROY-TIME>
TXDFLT:	TEXT <DEFAULT>,CM%NOR
TXDEST:	TEXT <DESTINATION>
TXDSTP:	TEXT <DESTINATION-PORT>
TXDTUN:	TEXT <DESTINATION-UNREACHABLE>
TXDCP:	TEXT <DEVICE-CONTROL-PROTOCOL>
TXDROP:	TEXT <DISCARD>
TXDONE:	TEXT <DONE>,CM%NOR
TXDONF:	TEXT <DONT-FRAGMENT>
TXDRVU:	TEXT <DRIVER-UTILIZATION>,CM%NOR
TXDRVB:	TEXT <DRV-BEGIN>
TXDRVE:	TEXT <DRV-END>
TXECHO:	TEXT <ECHO>
TXECRP:	TEXT <ECHO-REPLY>
TXESE:	TEXT <END-SEQUENCE>
TXENTR:	TEXT <ENTER>,CM%NOR
TXERRF:	TEXT <ERROR-FIELDS>
TXNEM:	TEXT <ESTIMATED-TRANSMISSION-TIME>
TXEXIT:	TEXT <EXIT>,CM%NOR
TXEXTR:	TEXT <EXTRACT>,CM%NOR
TXFILE:	TEXT <FILE-POSITION>
TXFLOC:	TEXT <FLOW-CONTROL>
TXFLOF:	TEXT <FLOW-CONTROL-FIELDS>
TXFILT:	TEXT <FILTER>,CM%NOR
TXFIN:	TEXT <FIN>
TXFNGR:	TEXT <FINGER>
TXFLAG:	TEXT <FLAGS>
TXFRMT:	TEXT <FORMAT>,CM%NOR
TXFRGO:	TEXT <FRAGMENT-OFFSET>
TXFTP:	TEXT <FTP>,CM%NOR
TXFTPD:	TEXT <FTP-DATA>
TXFUNC:	TEXT <FUNCTION>,CM%NOR
TXGARB:	TEXT <GARBAGE-OCTETS>
TXGATW:	TEXT <GATEWAY>
TXGWIN:	TEXT <GATEWAY-INPUT>,CM%NOR
TXGWOU:	TEXT <GATEWAY-OUTPUT>,CM%NOR
TXGGP:	TEXT <GGP-PACKETS>,CM%NOR
TXGO:	TEXT <GO>,CM%NOR
TXGRPH:	TEXT <GRAPHICS>
TXHTY:	TEXT <HANDLING-TYPE>
TXHELP:	TEXT <HELP>,CM%NOR
TXHIRE:	TEXT <HI-RELIABILITY>
TXHITR:	TEXT <HI-THROUGHPUT>
TXHINT:	TEXT <HINT>
TXHOST:	TEXT <HOST>
TXHSTP:	TEXT <HOSTS-PORTS>
TXHST2:	TEXT <HOSTS2-NAME-SERVER>
TXINPU:	TEXT <INPUT>
TAINTF:	TEXT <I-FIELDS>
TAINTL:	TEXT <I-LEADERS>
TXICMF:	TEXT <ICMP-FIELDS>,CM%NOR
TXICMP:	TEXT <ICMP-PACKETS>,CM%NOR
TXID:	TEXT <IDENTIFIER>
TXIDF:	TEXT <IDENTIFYING-FIELDS>
TXIDS:	TEXT <IDs>
TXIHOS:	TEXT <IHHOST>
TXITRA:	TEXT <IHTRACE>
TXIMP:	TEXT <IMP>
TXIMPX:	TEXT <IMP10>
TXINCL:	TEXT <INCLUDED>,CM%NOR
TXIRP:	TEXT <INFORMATION-REPLY>
TXIRQ:	TEXT <INFORMATION-REQUEST>
TXIFAC:	TEXT <INTERFACE>
TXINT:	TEXT <INTERNAL-FIELDS>
TXINTL:	TEXT <INTERNAL-LEADERS>
TXPKCU:	TEXT <INTERNET-PACKET-CORE-UTILITY>,CM%NOR
TXINTF:	TEXT <INTERRUPT-FIELDS>
TXIOSS:	TEXT <IO-STATION-SPOOLER>
TXIP:	TEXT <IP>
TXIPF:	TEXT <IP-FIELDS>,CM%NOR
TXGRPL:	TEXT <ISI-GRAPHICS-LANGUAGE>
TXJOBS:	TEXT <JOBs>
TXNDT:	TEXT <L-ADDRESS>
TALCF:	TEXT <L-FIELDS>
TXHN2:	TEXT <L-HINT>
TALCL:	TEXT <L-LEADERS>
TXNBZ:	TEXT <L-LENGTH>
TXBYT:	TEXT <LAST-BYTE>
TXLDF:	TEXT <LEADER-FLAGS>
TXLENB:	TEXT <LENGTH-BITS>
TXLENO:	TEXT <LENGTH-OCTETS>
TXLINK:	TEXT <LINK>
TXLNK:	TEXT <LINK>
TXLNKP:	TEXT <LINK-PROTOCOL>
TXLIST:	TEXT <LIST-PACKETS>,CM%NOR
TXLCF:	TEXT <LOCAL-FIELDS>
TXLCL:	TEXT <LOCAL-LEADERS>
TXLNAL:	TEXT <LOCAL-NET-ALL>,CM%NOR
TXLNIN:	TEXT <LOCAL-NET-INPUT>,CM%NOR
TXLNOU:	TEXT <LOCAL-NET-OUTPUT>,CM%NOR
TALONG:	TEXT <LO>,CM%NOR!CM%ABR!CM%INV,CM%ABR!CM%INV
TXLODY:	TEXT <LO-DELAY>
TXLONG:	TEXT <LONG-FORMAT>,CM%NOR
TXMASK:	TEXT <MASK:>
TXMXDL:	TEXT <MAXIMUM-DATA-LENGTH>
TXMETR:	TEXT <METAGRAM-RELAY>
TXMITD:	TEXT <MIT-DOVER-SPOOLER>
TXMIT1:	TEXT <MIT-ML-DEVICE-1>
TXMIT2:	TEXT <MIT-ML-DEVICE-2>
TXMIT:	TEXT <MIT-SUBNET-SUPPORT>,CM%NOR
TXMORF:	TEXT <MORE-FRAGMENTS>
TXMPMR:	TEXT <MPM-RECEIVE>
TXMPMS:	TEXT <MPM-SEND>
TXMHT:	TEXT <MSB-HANDLING-TYPE>
TXMSGA:	TEXT <MSG-AUTHENTICATION>
TXMSGI:	TEXT <MSG-ICP>
TXMSID:	TEXT <MSG-ID>
TXMSST:	TEXT <MSG-SUB-TYPE>
TXMSTY:	TEXT <MSG-TYPE>
TXMPLX:	TEXT <MULTIPLEXING>,CM%NOR
TXNAMS:	TEXT <NAME-SERVER>
TXNBBS:	TEXT <NBBSZ>
TXNBQU:	TEXT <NBQUE>
TXNCT:	TEXT <NCT-ADDRESS>
TXNET:	TEXT <NET>
TXNRJ1:	TEXT <NETRJS-1>
TXNRJ2:	TEXT <NETRJS-2>
TXNRJ3:	TEXT <NETRJS-3>
TXNRJ4:	TEXT <NETRJS-4>
TXNSTS:	TEXT <NETSTAT>
TXNTST:	TEXT <NETSTAT>,CM%NOR
TXNETD:	TEXT <NETWORK-DRIVER>
TXNFE:	TEXT <NETWORK-FRONT-END>
TXNNAM:	TEXT <NIC-HOST-NAME-SERVER>
TXNIFT:	TEXT <NIFTP>
TXNIML:	TEXT <NIMAIL>
TXNO:	TEXT <NO>,CM%NOR
TXNOT:	TEXT <NOT>,CM%NOR
TXNSW:	TEXT <NSW>,CM%NOR
TXNSWU:	TEXT <NSW-USER-SYSTEM-FE>
TXNVP:	TEXT <NVP>,CM%NOR
TXOFTP:	TEXT <OLD-FTP>
TXOTN:	TEXT <OLD-TELNET>
TXOMIT:	TEXT <OMITTED-COUNT>
TXOPTF:	TEXT <OPTION-FIELDS>
TXOUTP:	TEXT <OUTPUT>
TXPKTQ:	TEXT <PACKET-QUEUE>
TXPGLK:	TEXT <PAGES-LOCKED>
TXPAGE:	TEXT <PAGINATE-LISTING>
TXPARI:	TEXT <PARITY-BIT>
TXPARP:	TEXT <PARAMETER-PROBLEM>
TXPLRB:	TEXT <PLURIBUS>,CM%NOR
TXPNTR:	TEXT <POINTER>
TXPREC:	TEXT <PRECEDENCE>
TXPRJE:	TEXT <PRIVATE-RJE-SERVER>
TXPROA:	TEXT <PRO>,CM%ABR,CM%ABR
TXPROT:	TEXT <PROTOCOL>
TXPRSU:	TEXT <PROTOCOL-SUITE>
TXPROS:	TEXT <PROTOCOLS>
TXPSUI:	TEXT <PSUITE>
TXPUP:	TEXT <PUP>,CM%NOR
TXPUSH:	TEXT <PUSH>
TXQUE:	TEXT <QUEUE>
TXRSCF:	TEXT <R-S-COUNT-FIELDS>
TXIPTO:	TEXT <RA-TIMEOUT>
TXREAS:	TEXT <REASSEMBLY>
TXRCVF:	TEXT <RECEIVE-FIELDS>
TXPRT:	TEXT <RECEIVED-TIME>
TXREDR:	TEXT <REDIRECT>
TXREGS:	TEXT <REGISTER-SAMPLES>,CM%NOR
TXRTN:	TEXT <REMOTE-TELNET-SERVICE>
TXREST:	TEXT <RESET>
TXRXF:	TEXT <RETRANSMISSION-FIELDS>
TXRXI:	TEXT <RETRANSMIT-INTERVAL>
TXRFB:	TEXT <RFNM-BLOCK-CNT>
TXRJE:	TEXT <RJE>
TXROUT:	TEXT <ROUTE>
TXROUF:	TEXT <ROUTE-FIELDS>
TXSHNT:	TEXT <S-HINT>
TXSBZ:	TEXT <S-LENGTH>
TXSDT:	TEXT <S-ADDRESS>
TXSATB:	TEXT <SATNET-BACKROOM-EXPAK>,CM%NOR
TXSATM:	TEXT <SATNET-MONITORING>,CM%NOR
TXSCR:	TEXT <SECURE>,CM%NOR
TXSGID:	TEXT <SEGMENT-ID>
TXSNDF:	TEXT <SEND-FIELDS>
TXSNDR:	TEXT <SEND-RIGHT>
TXSEQN:	TEXT <SEQUENCE>
TXSHRT:	TEXT <SHORT-FORMAT>,CM%NOR
TXSHOW:	TEXT <SHOW>,CM%NOR
TXSKIP:	TEXT <SKIP>,CM%NOR
TXSMTP:	TEXT <SMTP>
TXSORC:	TEXT <SOURCE>
TXSOUP:	TEXT <SOURCE-PORT>
TXSRCQ:	TEXT <SOURCE-QUENCH>
TXST:	TEXT <ST>,CM%NOR
TXSMGY:	TEXT <SU-MIT-TELNET-GATEWAY>
TXSPDP:	TEXT <SUPDUP>
TXSURM:	TEXT <SURVEY-MEASUREMENT>
TXSYN:	TEXT <SYN>
TXSYST:	TEXT <SYSTAT>
TXTAC:	TEXT <TAC-MONITORING>,CM%NOR
TXTAKE:	TEXT <TAKE>,CM%NOR
TXTCBS:	TEXT <TCB-SAMPLES>
TXTCBF:	TEXT <TCB-FIELDS>,CM%NOR
TXTCPF:	TEXT <TCP-FIELDS>,CM%NOR
TXTCP:	TEXT <TCP-PACKETS>,CM%NOR
TXTELE:	TEXT <TELENET>,CM%NOR
TXTELN:	TEXT <TELNET>,CM%NOR
TXTERM:	TEXT <TERMINAL-LINK>
TXTEXT:	TEXT <TEXT-MESSAGE>
TXTFTP:	TEXT <TFTP>
TXTPDT:	TEXT <T-ADDRESS>
TXTG:	TEXT <T-GENERATED>
TXTPBZ:	TEXT <T-LENGTH>
TXTO:	TEXT <T-ORIGINATE>
TXTQ:	TEXT <T-QUEUED>
TXTR:	TEXT <T-RECEIVE>
TXTRX:	TEXT <T-RETRANSMIT>
TXTS:	TEXT <T-SEND>
TXTT:	TEXT <T-TRANSMIT>
TXTMEX:	TEXT <TIME-EXCEEDED>
TXTIMF:	TEXT <TIME-FIELDS>
TXTIML:	TEXT <TIME-LIVE>
TXTIMS:	TEXT <TIME-SERVER>
TXTSMP:	TEXT <TIMESTAMP>
TXTSRP:	TEXT <TIMESTAMP-REPLY>
TXTRCD:	TEXT <TRACE-CODES>
TXTTYT:	TEXT <TTYTST>
TXTYPE:	TEXT <TYPE>
TXTYPS:	TEXT <TYPE-SERVICE>
TXUCL:	TEXT <UCL>,CM%NOR
TXURG:	TEXT <URG-POINTER>
TXURGF:	TEXT <URGENT>
TXUSDG:	TEXT <USER-DATAGRAM>,CM%NOR
TXUDPF:	TEXT <USER-DATAGRAM-FIELDS>,CM%NOR
TXVER:	TEXT <VERSION>
TXVERS:	TEXT <VERSION>,CM%NOR
TXWAIT:	TEXT <WAIT>,CM%NOR
TXWHOI:	TEXT <WHOIS>
TXWBEX:	TEXT <WIDEBAND-EXPAK>,CM%NOR
TXWBMN:	TEXT <WIDEBAND-MONITORING>,CM%NOR
TXWIND:	TEXT <WINDOW>
TXXNET:	TEXT <XNET>,CM%NOR

; TCB TEXT Fields
TXABTF:	TEXT <TABTFX>
TXBRBQ:	TEXT <TCBRBQ>
TXBRPQ:	TEXT <TCBRPQ>
TXBRXQ:	TEXT <TCBRXQ>
TXBSBQ:	TEXT <TCBSBQ>
TXCABI:	TEXT <TCABI>
TXCABR:	TEXT <TCABR>
TXCATM:	TEXT <TCATM>
TXCBAD:	TEXT <TCBAD>
TXCBID:	TEXT <TCBID>
TXCBIO:	TEXT <TCBIO>
TXCBIR:	TEXT <TCBIR>
TXCBIU:	TEXT <TCBIU>
TXCBTO:	TEXT <TCBTO>
TXCBTP:	TEXT <TCBTP>
TXCBTR:	TEXT <TCBTR>
TXCBTU:	TEXT <TCBTU>
TXCCIA:	TEXT <TCCIA>
TXCCIE:	TEXT <TCCIE>
TXCCIR:	TEXT <TCCIR>
TXCCIS:	TEXT <TCCIS>
TXCCIU:	TEXT <TCCIU>
TXCCIX:	TEXT <TCCIX>
TXCDUP:	TEXT <TCDUP>
TXCERR:	TEXT <TCERR>
TXCFAK:	TEXT <TCFAK>
TXCFWP:	TEXT <TCFWP>
TXCICM:	TEXT <TCICM>
TXCIDU:	TEXT <TCIDU>
TXCIPB:	TEXT <TCIPB>
TXCIRD:	TEXT <TCIRD>
TXCISQ:	TEXT <TCISQ>
TXCITE:	TEXT <TCITE>
TXCLTM:	TEXT <TCLTM>
TXCPCC:	TEXT <TCPCC>
TXCPZT:	TEXT <TCPZT>
TXCQDY:	TEXT <TCQDY>
TXCQPZ:	TEXT <TCQPX>
TXCQRA:	TEXT <TCQRA>
TXCQRX:	TEXT <TCQRX>
TXCRCV:	TEXT <TCRCV>
TXCRMQ:	TEXT <TCRMQ>
TXCRMW:	TEXT <TCRMW>
TXCRPC:	TEXT <TCRPC>
TXCRST:	TEXT <TCRST>
TXCRTM:	TEXT <TCRTM>
TXCRUT:	TEXT <TCRUT>
TXCRXF:	TEXT <TCRXF>
TXCRXP:	TEXT <TCRXP>
TXCSAG:	TEXT <TCSAG>
TXCSMO:	TEXT <TCSMO>
TXCSND:	TEXT <TCSND>
TXCSPC:	TEXT <TCSPC>
TXCSQT:	TEXT <TCSQT>
TXCTDY:	TEXT <TCTDY>
TXCTPZ:	TEXT <TCTPZ>
TXCTRA:	TEXT <TCTRA>
TXCTRX:	TEXT <TCTRX>
TXERR:	TEXT <TERR>
TXFH:	TEXT <TFH>
TXFP:	TEXT <TFP>
TXIFDF:	TEXT <TIFDF>
TXIOPF:	TEXT <TIOPF>
TXIPDO:	TEXT <TIPDO>
TXIPOR:	TEXT <TIPOR>
TXIPOU:	TEXT <TIPOU>
TXJCN:	TEXT <TJCN>
TXJFN:	TEXT <TJFN>
TXJIBA:	TEXT <TJIBA>
TXJIBE:	TEXT <TJIBE>
TXJOBA:	TEXT <TJOBA>
TXJOBF:	TEXT <TJOBF>
TXLH:	TEXT <TLH>
TXLP:	TEXT <TLP>
TXMNRT:	TEXT <TMNRT>
TXOFRK:	TEXT <TOFRK>
TXOWNR:	TEXT <TOWNR>
TXCBCI:	TEXT <TCBCI>
TXCBCO:	TEXT <TCBCO>
TXPICA:	TEXT <TPICA>
TXPICE:	TEXT <TPICE>
TXPICR:	TEXT <TPICR>
TXPICS:	TEXT <TPICS>
TXPICU:	TEXT <TPICU>
TXPICX:	TEXT <TPICX>
TXPIFA:	TEXT <TPIFA>
TXPIFE:	TEXT <TPIFE>
TXPIFR:	TEXT <TPIFR>
TXPIFS:	TEXT <TPIFS>
TXPIFU:	TEXT <TPIFU>
TXPIFX:	TEXT <TPIFX>
TXPRS1:	TEXT <TPRS1>
TXPRS2:	TEXT <TPRS2>
TXRCB:	TEXT <TRCB>
TXRIS:	TEXT <TRIS>
TXRLFT:	TEXT <TRLFT>
TXRSYN:	TEXT <TRSYN>
TXRURP:	TEXT <TRURP>
TXRWND:	TEXT <TRWND>
TXRXPD:	TEXT <TRXPD>
TXRXPI:	TEXT <TRXPI>
TXRXPN:	TEXT <TRXPN>
TXSBYT:	TEXT <TSBYT>
TXSCB:	TEXT <TSCB>
TXSCPK:	TEXT <TSCPK>
TXSEPT:	TEXT <TSEPT>
TXSESB:	TEXT <TSESB>
TXSFHO:	TEXT <TSFHOP>
TXSFHT:	TEXT <TSFHT>
TXSFHW:	TEXT <TSFHW>
TXSIS:	TEXT <TSIS>
TXSLBY:	TEXT <TSLBY>
TXSLFT:	TEXT <TSLFT>
TXSMRT:	TEXT <TSMRT>
TXSMXB:	TEXT <TSMXB>
TXSMXS:	TEXT <TSMXS>
TXSPET:	TEXT <TSPET>
TXSPRB:	TEXT <TSPRB>
TXSSEQ:	TEXT <TSSEQ>
TXSSYN:	TEXT <TSSYN>
TXSTAT:	TEXT <TSTAT>
TXSTO:	TEXT <TSTO>
TXSUOP:	TEXT <TSUOP>
TXSURP:	TEXT <TSURP>
TXSWND:	TEXT <TSWND>
TXTOPF:	TEXT <TTOPF>
TXTOSC:	TEXT <TTOSC>
TXTOSD:	TEXT <TTOSD>
TXTOSR:	TEXT <TTOSR>
TXTOST:	TEXT <TTOST>
TXTOSU:	TEXT <TTOSU>
TXTPDO:	TEXT <TTPDO>
TXTPOR:	TEXT <TTPOR>
TXTPOU:	TEXT <TTPOU>
TXTTL:	TEXT <TTTL>
TXUNRT:	TEXT <TUNRT>
TXVTL:	TEXT <TVTL>

	SUBTTL	Filter Data Structure

NEGATE==:1		; Negate term flag
FOREIGN==:2		; Packet received from net
NFILTB==:20		; Maximum # filter elements
							;source = foreign
; Table of Filter Expressions				;dest = local
; Default filter terms ...

TRIO:	-2,,0			; I/O
	0,,7777			; Mask
	5130			; In
	5230			; Out

PRICM:	-1,,0			; ICMP protocol
	0,,377			; mask
	1			; ICMP

NOTECO:	-2,,NEGATE		; Not echos
	0,,377			; mask
	0			; Echo Reply
	10			; Echo

PRTCP:	-1,,0			; TCP protocol
	0,,377			; mask
	6			; TCP

; Tables of terms in each expression
; Table entry is routine,,values pointer , or 0,,0 to indicate end.
; Default filter expressions ...

EXCEP:	TRCODS,,TRIO		; Exceptions are I/O
	PROTS,,PRICM		; For ICMP
	PRCODS,,NOTECO		; But not echos
	0			; End of expression

IO:	TRCODS,,TRIO		; Low level are I/O
	PROTS,,PRTCP		; For TCP
	0			; End of expression

; Table of filter expressions
; Default filter ...

FILTAB:	2			; Count of filter expressions
	EXCEP			; Exceptions
	IO			; Low level input & output
	BLOCK NFILTB		; Filter element block address
	0			; Guard

FREEP:	FREEI			; Next Free Word
FREE:				; Area to build filter data structure
FREEI:	BLOCK 3000		;Filter element blocks

	SUBTTL	Subroutine to print host number/port

; T1/	Destination string pointer
; T2/	32-bit Internet address
; T3/	Port number, or -1 to omit
;	CALL HNO2NA
; T1/	Updated pointer

HNO2NA:	PUSH P,T4		; Save temp reg
	PUSH P,T3		; Save Port

	PUSH P,T2		; Save Host address & setup bytes
	LSH T3,^D<36-3*8>	; 16 bits into 2nd+3rd bytes
	TRO T3,<377B31>		; Stop after ports
	PUSH P,T3		; Last setup word

	MOVX T4,<POINT 8,-2(P),3> ; First 8 bits
	PUSH P,T4		; Initial address pointer

; Start with 4 address bytes

	SKIPA T4,[-4,,0]	; 4 bytes of host
HNO2NH:	  BOUT
	ILDB T2,0(P)		; Next byte
	MOVX T3,DECRAD		; Network virtual radix
	NOUT
	  JRST [MOVX T2,"?"	; Error ??
		BOUT
		JRST .+1]
	MOVX T2,"."		; Bytes separated by dot
	AOBJN T4,HNO2NH

; See if have port, back if so, with space separating address & port

	MOVX T4,<-2,,0>		; If doing ports
	ILDB T2,0(P)		; Port/end flag bytes
	TRON T2," "		; Make space if want port
	  JRST HNO2NH		; Go for ports

	POP P,0(P)		; Drop pointer
	POP P,0(P)		; Port & flags
	POP P,T2		; Restore Host address,
	POP P,T3		; Port, and
	POP P,T4		; Temp register
	RET

	SUBTTL	Common Parsing Routines

; Initialize COMND State Block & Get Parameter
;	CALL PARSE

PARSE:	PUSH P,CURFDB		; Save previous state
	PUSH P,CURP
	PUSH P,CURPMT
	MOVEM T2,CURFDB		; Set new parameters for Reparse
	MOVEM T3,CURPMT		; Descriptor, Prompt,
	MOVEM P,CURP		; Stack pointer

NEWCMD:	MOVX T2,<REPARS>
	MOVE T3,CURPMT
	CALL CINIT		; Init command state block
	; *** returns to REPARS

; Get/Reparse Command

	CALL ER			; Error reset
REPARS:	MOVE T2,CURFDB		; Usually keyword table
	XCT -1(T2)		; Reset
	TXZ F,TMPFLG		; Reset flags and variables
	HRRZS CMD		; Clear flags in state block on reparse

	MOVE T2,CURFDB
NOCMD:	MOVE P,CURP		; Be safe from REPARSes
	MOVX T1,CMD
	MOVEM T2,LSTFDB
	COMND
	  ERCAL CMDEOF		; Check for COMND EOF
	TXNE T1,CM%NOP		; Parse ok?
        JRST WHAT		; No

	HRRZ FCT,(T2)		; Right-half of keyword entry
	JUMPE FCT,WHAT
	CALL (FCT)		; Dispatch to processing routine
	  JRST NEWCMD		; Do another
	JRST NOCMD		; Saw NO, Try again


WHAT:	HRROI T1,[ASCIZ /
? Sorry, "/]
	PSOUT
	HRROI T1,ATMBUF
	PSOUT
	HRROI T1,[ASCIZ /" is not a parameter.
/]
	PSOUT
	JRST NEWCMD		; Try again

CMDXIT:	MOVE P,CURP		; Restore stack & prior parameters
	POP P,CURPMT
	POP P,CURP
	POP P,CURFDB		; From parse

	RET

; CALL CCMDEC to parse a decimal number  or
; CALL CCMCFM to confirm a command

CMCFM:	FLDDB.	(.CMCFM)	; Simple confirmation

CCMDEC:	SKIPA T2,[DECFDB]	; Decimal number
CCMCFM:	  MOVX T2,CMCFM		; Confirm


;	MOVX T2,<first fdb>
;	CALL CCOMND
; RET+1	OK, T4 first fdb, T3 actual
; Jumps to REPARS-1 on parse error

CCOMND:	MOVX T1,CMD
	HRRZ T4,T2		; Save initial function
	COMND%
	  ERCAL CMDEOF		; Check for COMND EOF
	HRRZS T3		; Actual function
	TXNN T1,CM%NOP		; Parse ok?
	  RET			; Yes

	HRLI T2,.FHSLF		; T2 has error code...
	MOVX T1,<POINT 7,ERMSG,6>
	HRLI T3,-<<5*ERMSGS>-2>
	ERSTR%			; Get system error string
	  JFCL
	  JFCL
	SETZ T2,		; End string with a NUL
	BOUT%

	HRROI EST,ERMSG		; Point to error string

	HRRZ T3,CMD+.CMFLG	; Get reparse address
	SUBI T3,1		; Error address
	HRRM T3,(P)		; for return
	RET

; See if we hit an EOF while in a take file

CMDEOF:	SKIPG TAKLVL		; In a TAKE file?
	  RET			; No, return
	PUSH P,T1		; Save ACs
	PUSH P,T2
	MOVE T1,TAKJFN		; Get the current take JFN
	GTSTS%			; Get the status
	TXNE T2,GS%EOF		; At EOF?
	  JRST CMDXIT		; Yes, exit the TAKE file
	POP P,T2		; Restore ACs only if we are going to
	POP P,T1		;  Return
	RET			; No, return

;	MOVX T2,<REPARS>
;	MOVX T3,<POINT 7,[ASCIZ /*/]>
;	CALL CINIT		; Init command state block
; *** Returns to <REPARS>

CINIT:	MOVX T1,CMD		; Locate State block
	MOVEM T2,.CMFLG(T1)	; No flags/reparse
	HRRM T2,0(P)		; Modify return address ***
	MOVE T2,CMDIOJ		; Current Input/Output JFNs
	MOVEM T2,.CMIOJ(T1)	; Input/Output JFNs
	MOVEM T3,.CMRTY(T1)	; Retype text
	MOVX T2,<POINT 7,CMDBUF>
	MOVEM T2,.CMBFP(T1)	; Input buffer
	MOVX T2,<POINT 7,CMDBUF>
	MOVEM T2,.CMPTR(T1)
	MOVX T2,CMDBSZ*5-1
	MOVEM T2,.CMCNT(T1)	; Input buffer size
	SETZM .CMINC(T1)	; Buffer is empty
	MOVX T2,<POINT 7,ATMBUF>
	MOVEM T2,.CMABP(T1)	; Atom buffer
	MOVX T2,ATMBSZ*5-1
	MOVEM T2,.CMABC(T1)	; Atom buffer size
	MOVX T2,GJFN
	MOVEM T2,.CMGJB(T1)	; GTJFN block
CINITX:
	MOVX T1,CMD		; Reinitialize
	MOVX T2,CMINI
	COMND%
	SETZ EST,		; No error string
	RET			; To REPARS address

CMINI:	FLDDB.	(.CMINI)	; Initialize parameter parser


; String copying routines

CPYASZ:	SETZ T3,
	SOUT%
	RET


; General Error Exit

ER:	HRROI T1,[ASCIZ /
? Error/]
	PSOUT%
	SKIPE T1,EST
	  PSOUT%
	HRROI T1,[ASCIZ /.
/]
	PSOUT%
	JRST CINITX

	SUBTTL	GO Command

GONOI:	FLDDB.(.CMNOI,CM%SDH,<POINT 7,[ASCIZ /process data/]>,,,)


.GO:	MOVX T2,GONOI		; (process data)
	CALL CCOMND
	CALL CCMCFM		; Confirm parameter
	JRST CMDXIT		; Out

	SUBTTL	HELP Command


; Basic structure for multiple level help function:
;
;	<General help text adr>,,<Help sub-command keyword table adr>
;	<Reparse instruction to be executed>
;CURFDB->FLDDB.(.CMKEY, ... of keywords for this level


; Top-level HELP

HLPSUB:	FLDDB.(.CMCFM,<CM%HPP!CM%SDH>,,<RETURN for general information>,
,HLPCMA)
HLPCMA:	FLDDB.(.CMCMA,,,<Comma for help about a particular topic>)


; HELP Sub-Commnad

HSUBC:	FLDDB.(.CMKEY,,0-0,,,HSBCFM)
HSBCFM:	FLDDB.(.CMCFM,<CM%HPP!CM%SDH>,,<RETURN to terminate help>,,)



.HELP:	HRROI T1,[ASCIZ /No more help available./]

	MOVE T2,CURFDB
	HRRZ T2,-2(T2)		; Help keyword table address, or 0 if none
	JUMPE T2,HELPX		; none

	MOVEM T2,HSUBC+.CMDAT	; Set keyword address into FDB block
	MOVX T2,HLPSUB		; Confirm is initial function
	CALL CCOMND
	CAME T3,T4		; Carriage return?
	  JRST HLPSB		; No, comma for subcommands

	MOVE T1,CURFDB		; Find current level
	HLRO T1,-2(T1)		; Help for this level
HELPX:	PSOUT
	RET



; Sub commands for HELP

HLPSB:	CALL CCMCFM		; Confirm HELP,
HLPSBL:	MOVX T2,<HREPAR>	; Reparse and prompt
	MOVX T3,<POINT 7,[ASCIZ /Give help about:/]>
	CALL CINIT		; Initialize for subcommands
; *** returns to HREPAR

	CALL HLPSBE		; Error reset
HREPAR:	HRROI EST,[ASCIZ / Sorry, do not have any more help about that./]
	MOVX T2,HSUBC
	CALL CCOMND
	CAME T3,T4		; Get a subcommand or CRLF?
	  RET			; CRLF ends subcommands

	HRRO FCT,(T2)		; Subcommand, right-half of keyword entry
	CALL CCMCFM		; Confirm HELP subcommand

	HRRO T1,FCT		; Exetended help message
	PSOUT
	JRST HLPSBL		; Get next subcommand


; Get/Reparse sub-command

HLPSBE:	  HRROI T1,[ASCIZ /
? Not confirmed./]
	PSOUT
	SKIPE T1,EST
	  PSOUT
	HRROI T1,[ASCIZ /

/]
	PSOUT
	JRST CINITX		; Reinitialize
	SUBTTL PUSH Command

HPUSH:	ASCIZ \The PUSH command creates an inferior EXEC and passes control
to it.  Use the EXEC's POP command to return to the packet printer.

Typing PUSH again will get you to the same EXEC.  If you want to get
to a new EXEC, use PUSH /RESET.  The /RESET switch will kill any
existing EXEC and create a new one for you.
\

	TBBEG(PSHSWT)
	TB TXREST,.PSHRS
	TBEND

; Push command
.PUSH:	MOVEI T2,[FLDDB.(.CMNOI,,<POINT 7,[ASCIZ /(to inferior EXEC)/]>)]
	CALL CCOMND
	MOVEI T2,[FLDDB.(.CMSWI,,PSHSWT,,,CMCFM)]
	CALL CCOMND		; Parse <cr> or switch
	CAIN T3,CMCFM		; <cr>?
	IFSKP.			; No, must have been switch
	  MOVE FCT,(T2)		; Save table entry
	  CALL CCMCFM		; Confirm
	  CALL (FCT)		; Call the function
	ENDIF.

	SKIPE T1,EXECFH		; Have an EXEC already?
	IFSKP.			; No, get one...
	  MOVX T1,<GJ%SHT!GJ%OLD>
	  HRROI T2,[ASCIZ /SYSTEM:EXEC.EXE/]
	  GTJFN%
	    ERJMP GJERR
	  MOVE FCT,T1		; Save JFN

	  MOVX T1,CR%CAP	; Same capabilities
	  CFORK%		; Create fork
	    JRST CFERR
	  EXCH FCT,T1		; Save process handle

	  HRL T1,FCT		; Fork,,JFN
	  GET%			; Get program
	    ERJMP GTERR

	  MOVX T1,.FHSLF	; Get current capabilities
	  RPCAP%
	    ERJMP RCERR
	  MOVE T1,FCT
	  EPCAP%		; Pass them down
	    ERJMP ECERR

	  MOVEM FCT,EXECFH	; EXEC setup and ready to go
	ENDIF.

	; Here with fork handle in T1
	SETZ T2,		; Start address
	SFRKV%
	  ERJMP SFERR

	WFORK%			; Wait for it to finish
	  ERJMP WFERR
	RET

; /RESET switch for the PUSH command
.PSHRS:	SKIPN T1,EXECFH		; An EXEC fork handle to reset?
	  RET			; No, return
	SETZM EXECFH		; Fork gone
	KFORK%			; Get rid of inferior fork
	  ERJMP KFERR
	RET			; Done


KFERR:	HRROI T2,[ASCIZ /kill inferior EXEC's fork, /]
	JRST JFERR
WFERR:	HRROI T2,[ASCIZ /wait for program to finish, /]
	JRST JFERR
SFERR:	HRROI T2,[ASCIZ /start inferior process, /]
	JRST JFERR
GVERR:	HRROI T2,[ASCIZ /obtain program starting address, /]
	JRST JFERR
ECERR:	HRROI T2,[ASCIZ /set inferior's capabilities, /]
	JRST JFERR
RCERR:	HRROI T2,[ASCIZ /read process's capabilities, /]
	JRST JFERR
GTERR:	HRROI T2,[ASCIZ /GET file, /]
JLERR:	MOVX T1,-1		; Lasst error for process

JFERR:	HRRZ T3,T1		; Save error code
	HRRZ T1,FCT		; Get fork handle
	SKIPE T1
	 KFORK%
	  ERJMP .+1
	SETZM EXECFH		; Fork handle gone
	JRST JSEROR

GJERR:	SKIPA T2,[-1,,[ASCIZ /access SYSTEM:EXEC.EXE, /]]
CFERR:	  HRROI T2,[ASCIZ /create inferior fork, /]
	HRRZ T3,T1		; Save error code

JSEROR:	HRROI T1,[ASCIZ /
? Unable to /]
	PSOUT%
	MOVE T1,T2		; More info
	PSOUT%

	MOVE T2,T3		; Error code
	HRLI T2,.FHSLF		; This process
	MOVX T1,.PRIOU		; To the TTY:
	SETZ T3,		; No limit
	ERSTR%
	  JFCL
	  JFCL
	HRROI T1,[ASCIZ /.
/]
	PSOUT%

	RET

	SUBTTL Input Host and Port Specification Routine

HSTPRT:	SETOB HST,PRT		; Not yet parsed host or port

	MOVE T2,HOSTGW		; Start with (host) or (port)
	CALL CCOMND
	CAME T3,T4		; Which?
	  JRST PRTGW		; Port

	MOVX T2,HSTFLD		; If (host) then host specification
	CALL CCOMND
	CALL NAMES
	 JRST ER

; Now get port

	MOVX T2,PORTGW		; After host, get port
	CALL CCOMND
PRTGW: CALL GPORT
	 JRST ER
	RET			; FROM HSTPRT


; Host Specifications

HSTFLD:	FLDBK.(.CMFLD,,,<Host NAME or ADDRESS>,,HSTBRK,)

HSTBRK:	BRMSK.(FLDB0.,FLDB1.,FLDB2.,FLDB3.,<#.>,)

HOSTGW:	FLDDB.	(.CMNOI,CM%SDH,<POINT 7,[ASCIZ /HOST/]>,,,PORTGW)


; Port Specifications

PORTGW:	FLDDB.	(.CMNOI,CM%SDH,<POINT 7,[ASCIZ /PORT/]>,,,)

PRTFDB:	FLDDB.(.CMKEY,,PRTKEY,<PORT NAME,>,,PRTFLD)

PRTKEY:	NPRT,,NPRT
	TXAFM,,^D059
	TXCSMP,,^D105
	TXCSMT,,^D105
	TXDC,,^D131
	TXDCCA,,^D067
	TXDCS,,^D097
	TXDAT,,^D013
	TXDCP,,^D093
	TXDROP,,^D009
	TXECHO,,^D007
	TXFNGR,,^D079
	TXFTP,,^D021
	TXFTPD,,^D020
	TXGRPH,,^D041
	TXHST2,,^D081
	TXIOSS,,^D035
	TXGRPL,,^D055
	TXLNK,,^D245
	TXMETR,,^D099
	TXMITD,,^D091
	TXMIT1,,^D083
	TXMIT2,,^D085
	TXMPMR,,^D045
	TXMPMS,,^D046
	TXMSGA,,^D031
	TXMSGI,,^D029
	TXNAMS,,^D042
	TXNRJ1,,^D071
	TXNRJ2,,^D072
	TXNRJ3,,^D073
	TXNRJ4,,^D074
	TXNSTS,,^D015
	TXNNAM,,^D101
	TXNIFT,,^D047
	TXNIML,,^D061
	TXNSWU,,^D027
	TXOFTP,,^D003
	TXOTN,,^D001
	TXPRJE,,^D077
	TXRTN,,^D107
	TXRJE,,^D005
	TXSMTP,,^D025
	TXSMGY,,^D089
	TXSPDP,,^D095
	TXSURM,,^D243
	TXSYST,,^D011
	TXTELN,,^D023
	TXTERM,,^D087
	TXTEXT,,^D017
	TXTFTP,,^D069
	TXTIMS,,^D037
	TXTTYT,,^D019
	TXWHOI,,^D043
NPRT==.-PRTKEY-1

PRTFLD:	FLDBK.(.CMFLD,,,<PORT NUMBER>,,PRTBRK,)

..X==777777777760
PRTBRK:	BRMSK.(..X,..X,..X,..X,<0123456789.>,)


; Port Guide Word

GPORT:	MOVX T2,PRTFDB		; If (port) then port specification
	CALL CCOMND		; Get port's first byte
	CAMN T3,T4		; Keyword specified?
	  JRST GPRTK		; Yes
	MOVX T1,<POINT 7,ATMBUF>
	SETO PRT,		; Assume no port
	MOVE T2,T1
	ILDB T3,T2
	CAIN T3,0		; Have anything?
	 JRST GPRTX		; No
	MOVX T3,DECRAD
	NIN			; Read decimal #
	  JRST [HRROI T1,[ASCIZ /? Invalid port.
/]
		PSOUT
		RET]
	MOVEM T2,PRT

	LDB T2,T1
	CAIE T2,"."		; Another byte?
	  JRST GPRTX		; No
	NIN
	  JRST [HRROI T1,[ASCIZ /? Invalid 2nd byte of port.
/]
		PSOUT
		RET]
	LSH PRT,10
	IOR PRT,T2

	LDB T2,T1
	CAIE T2,0		; End of specification?
	  JRST [HRROI T1,[ASCIZ /? Garbage following port specification.
/]
		PSOUT
		RET]		; Trailing garbage is bad
	SKIPA
GPRTK:	  HRRZ PRT,(T2)		; Get value corresponding to keyword
GPRTX:	AOS (P)
	RET


; Decide which case: Name, 4 decimal bytes, 32-bit octal #

NAMES:	SETO HST,		; No name yet
	SETZ T2,
	MOVX T1,<POINT 7,ATMBUF> ; Host name

	ILDB T3,T1		; Get character
	CAIN T3,"#"		; #<OCTAL ADDRESS>?
	  JRST NAMESO		; YES

	MOVX T1,<POINT 7,ATMBUF> ; Host name again
	JUMPE T3,NAMESY		; Nothing?

	CAIL T3,"0"
	 CAILE T3,"9"
	  JRST NAMESN		; Name
	JRST NAMESD		; Decimal #

; 32-Bit Octal address

NAMESO:	MOVX T3,OCTRAD
	NIN			; Host name is octal number
	  JRST [HRROI T1,[ASCIZ /? Invalid octal host address.
/]
		PSOUT
		RET]
	MOVE HST,T2
	JRST NAMESX

; ASCII host name

NAMESN:	MOVX T1,<.GTHSN>	; Name to address
	HRROI T2,ATMBUF
	GTHST
	  JRST [HRROI T1,[ASCIZ /? Invalid host name.
/]
		PSOUT
		RET]
	MOVE HST,T3		; Address to T2
	JRST NAMESX		; Go make sure

; 4 8-bit decimal byte address

NAMESD:	MOVX T4,<-4,,0>		; FOUR BYTES
	MOVX T3,DECRAD		; Get first decimal byte
	SETZ HST,

NAMESE:	NIN			; BAD
	  JRST [HRROI T1,[ASCIZ /? Invalid decimal host address byte.
/]
		PSOUT
		RET]
	CAIL T2,0		; Change help message
	 CAILE T2,377		; for each byte
	  JRST [HRROI T1,[ASCIZ /? Invalid port byte, not in range 0 to 255.
/]
		PSOUT
		RET]		; NOT 8 BITS IS BAD
	LSH HST,10
	IOR HST,T2		; INSERT NEXT BYTE

	LDB T2,T1
	CAIN T2,"."		; Another byte?
	  AOBJN T4,NAMESE	; Yes, back for it
NAMESX:
	LDB T2,T1
	CAIE T2,0
	  JRST [HRROI T1,[ASCIZ /? Garbage following host specification.
/]
		PSOUT
		RET]		; TRAILING GARBAGE IS BAD

	TLNE HST,340000		; Only 32 bits
	  JRST [HRROI T1,[ASCIZ /? Invalid host address exceeds 32 bits.
/]
		PSOUT
		RET]
NAMESY:	AOS (P)			; Skip return
	RET

	SUBTTL	Set Keyword Table Flags

;	MOVX T2,<fdb of a .cmkey table>
;	MOVX TMP,<instruction to get new flags>
;	CALL KEYINI

KEYINI:	MOVE T3,.CMDAT(T2)	; Address of keyword table
KEYIN0:	HLRZ T4,(T3)		; Acutal Number of entries
	MOVNS T4
	HRLZS T4
	HRRI T4,1(T3)		; AOBJN pointer to keys
KEYLUP:	HLRZ T3,(T4)		; Address of text block
	XCT TMP			; Get new flags
	STOR T1,CRKY,(T3)
	AOBJN T4,KEYLUP
	RET


	SUBTTL	NO prefix

.NO:	MOVE T2,LSTFDB
	MOVE TMP,[LOAD T1,NOKY,(T3)]	; Seen "NO" instruction
	CALL KEYINI		; Remove parameters which cannot follow NO
	TXO F,F.NO		; Seen "NO"
	AOS (P)			; Skip return
	RET			; Get parameter

	SUBTTL	Top-level Command Keyword Table


	HELPTX,,HLPKEY		;Parallel HELP keywords
	JFCL			; Reparse instruction
TOPLVL:	FLDDB.	(.CMKEY,,TOPKEY); First parameter is keyword

TOPKEY:	NTOP,,NTOP		; Table of parameter keywords
	TXEXIT,,.EXIT		;  EXIT
	TXFILT,,.FILT		;  FILTER
	TXFRMT,,.FORM		;  FORMAT
	TXFUNC,,.FUNC		;  FUNCTION
	TXGO,,.GO		;  GO
	TXHELP,,.HELP		;  HELP
	TXINPU,,.INPTF		;  INPUT
	TXOUTP,,.OTPTF		;  OUTPUT
	TXPUSH,,.PUSH		;  PUSH
	TXSHOW,,.SHOW		;  SHOW
	TXSKIP,,.SKIPC		;  SKIP
	TXTAKE,,.TAKE		;  TAKE
	TXWAIT,,.WAIT		;  WAIT
NTOP==.-TOPKEY-1


HLPKEY:	NHLP,,NHLP		; Table size
	TXEXIT,,HEXIT
	TXFILT,,HFILT
	TXFRMT,,HFRMT
	TXFUNC,,HFUNC
	TXGO,,HGO
	TXINPU,,HINPUT
	TXOUTP,,HOUTPU
	TXPUSH,,HPUSH
	TXSHOW,,HTSHOW
	TXSKIP,,HSKIP
	TXTAKE,,HTAKE		;  TAKE
	TXWAIT,,HWAIT		;  WAIT
NHLP==.-HLPKEY-1

	SUBTTL	FILTER Command

HFILT:	ASCIZ	\FILTER is used to select samples to be listed.
Zero or more filter expressions may be specified.  If none are
specified, all samples are listed;  otherwise, samples are listed
if they satisfy one (or more) of the expressions.  An expression
is entered term-by-term, with each term terminated by pressing
RETURN.  When all terms have been specified, the expression is
confirmed by the ENTER command.
\
HBFRS:	ASCIZ	\BUFFER-SAMPLES is used to list buffer headers associated with
RECV% and SEND% JSYI.
\
HCLER:	ASCIZ	\CLEAR is used to delete filter expression(s).
  CLEAR	{         ALL         }    to clear all expressions
	{ <expression number> }    to clear the nth expression
	{       RETURN        }    to clear current expression
\
HCODS:	ASCIZ	\The CODES term specifies protocol-dependent codes.
  CODES	{ <protocol-dependent keyword> } * [/MASK: <octal mask>]
	{ <protocol-dependent octal #> } *
\
HDONE:	ASCIZ	\The DONE command exits FILTER, returning to the top level.
  DONE	(entring filter expressions)
\
HENTR:	ASCIZ	\ENTER records the current filter expression.
  ENTER	(current filter expression into filter table)
\
HTCBS:	ASCIZ \Include TCB SAMPLES in the trace listing.  If no ID or
  HOSTS-PORTS are given, then all TCBs will be listed.  Otherwise,
  only TCBs that pass the ID and HOSTS-PORTS filter terms will be
  listed.

Syntax:
  [NOT] TCB-SAMPLES	{ <confirm>			}
			{ <TCB-filter-term>		}

  Where <TCB-filter-term> is:
		{ ID <decimal #> [<decimal #>]* [/MASK:<octal#>]	}
		{ HOSTS-PORTS <hosts-ports-specification>		}

  See "HELP HOSTS-PORTS" for help on <hosts-ports-specification>.
\


HHSTPT:	ASCIZ	\The HOSTS-PORTS term filters samples by hosts and ports.
  HOSTS-PORTS	 (FH) <host-address> [/MASK:<host-mask>]
		[(FP) <port-#> [/MASK:<port-mask>]]
		[(LH) <host-address> [/MASK:<host-mask>]]
		[(LP) <port-#> [/MASK:<port-mask>]]
  where	<host-address>	[[[<d-byte> . ] <d-byte> . ] <d-byte> . ] <d-byte>
	<host-mask>
	<port-#>	[<d-byte> . ] <d-byte>
	<port-mask>
\
HNOT:	ASCIZ	\NOT negates the following term.\

HPROT:	ASCIZ	\The PROTOCOLS term selects samples by internet protocol.
  PROTOCOLS	{  <protocol-name>  } *	[/MASK:<octal-mask>]
		{ <protocol-number> } *
\
HREGS:	ASCIZ	\REGISTER-SAMPLES is used to list events which do not have
associated packets or buffer headers.
\
HSHOW:	ASCIZ	\The SHOW command displays one or more filter expressions.
	{      ALL       }
  SHOW	{ <index-number> }
	{                } (expression currently being entered)
\
HTRCD:	ASCIZ	\The TRACE-CODES term selects samples by trace codes.
  TRACE-CODES	{ <code-name>  } * [/MASK:<octal-mask>]
		{ <octal-code> } *
\

FILINI:	MOVE TMP,[LOAD T1,OKKY,(T3)]
	MOVEI T2,FILFDB
	CALL KEYINI		; Haven't yet seen NOT
	HRRZS -1(TA)		; Initialize an empty expression
	SETZM (TA)
	SETZM 1(TA)
	RET

.FILT:	MOVEI T2,[FLDDB.(.CMNOI,,<POINT 7,[ASCIZ /expressions are/]>)]
	CALL CCOMND
	CALL CCMCFM		; Confirm it

	CALL CLRI		; Initialize for another expression
	MOVX T2,FILFDB		; Filter keyword table
	MOVX T3,<POINT 7,[ASCIZ /Filter term: /]>
	CALLRET PARSE		; Get filter keywords, etc., through done


	COMMENT \

	Build list structure for expressions as entered.

	Routine,,0
    +->	<-1 if NOT>,,# Items		  +--->	-# Items,,<NEGATE>
    !	mask				  !	mask
    !	Item-1				  !	Item-1
    !	...				  !	...
    !	Item-n				  !	Item-n
    !					  !
    +---------------------+		  !
			  !		  !
	    Routine,,Ptr -+		  !
    +->	<-1 if NOT>,,# Items		  ! +->	<-1 if NOT>,,# Items
    !	mask				  ! !	mask
    !	Item-1				  ! !	Item-1
    !	...				  ! !	...
    !	Item-n				  ! !	Item-n
    !					  ! !
   ...					 .....
    !					  ! !
    +---------------------+		  ! +------------------+
			  !		  !		       !
	          0,,Ptr -+		  +--------------------+-+
  TA-->	          0,,0					       ! !
	             0		FILTAB+n --->	Routine,,Ptr --+ !
						Routine,,Ptr ----+
						0
	\

	HFILT,,FILHLP		;Parallel HELP keywords
	CALL FILINI		;Reparse instruction
FILFDB:	FLDDB.(.CMKEY,,FILKEY) ; Filter keywords

FILKEY:	NFIL,,NFIL
	TXBFRS,,.IBFR		;  BUFFER-SAMPLES
	TXCLER,,.ICLER		;  CLEAR
	TXCODS,,.ICWP		;  CODES within protocol
	TXDONE,,.DONE		;  DONE
	TXENTR,,.IENTR		;  ENTER
	TXHELP,,.HELP		;  HELP
	TXHSTP,,.IHSPT		;  HOSTS-PORTS
	TXIFAC,,.IIFAC		;  INTERFACE
	TXLNKP,,.ILNKP		;  LINK-PROTOCOL
	TXNETD,,.INETD		;  NETWORK-DRIVER
	TXNOT,,.NO		;  NOT ...
	TXPROA,,FILKYP		;  PRO ...
	TXPRSU,,.IPRSU		;  PROTOCOL-SUITE
FILKYP:	TXPROS,,.IPROT		;  PROTOCOLS
	TXPSUI,,.IPRSU		;  PSUITE
	TXREGS,,.IREGS		;  REGISTER-SAMPLES
	TXSHOW,,.ISHOW		;  SHOW
	TXTCBS,,.ITCBS		;  TCB-SAMPLES
	TXTRCD,,.ITRAC		;  TRACE-CODES
NFIL==.-FILKEY-1

	0	;Parallel HELP keywords
	JFCL	;Reparse instrcution
HFLFDB:	FLDDB.	(.CMKEY,,FILHLP)	;	

FILHLP:	NFILH,,NFILH
	TXBFRS,,HBFRS
	TXCLER,,HCLER
	TXCODS,,HCODS
	TXDONE,,HDONE
	TXENTR,,HENTR
	TXHSTP,,HHSTPT
	TXNOT,,HNOT
	TXPROS,,HPROT
	TXREGS,,HREGS
	TXSHOW,,HSHOW
	TXTCBS,,HTCBS
	TXTRCD,,HTRCD
NFILH==.-FILHLP-1

	SUBTTL	Parse an Address Specification Term

ADRNOI:	FLDDB.(.CMNOI,,<POINT 7,[ASCIZ /OF FOREIGN HOST IS/]>,,,)

MASFDB:	FLDDB.(.CMSWI,,MSKKEY,,,0-0)

FADRGW:	FLDDB.(.CMNOI,,<POINT 7,[ASCIZ /FH/]>,,,FPRTGW)
FPRTGW:	FLDDB.(.CMNOI,,<POINT 7,[ASCIZ /FP/]>,,,LADRGW)
LADRGW:	FLDDB.(.CMNOI,,<POINT 7,[ASCIZ /LH/]>,,,LPRTGW)
LPRTGW:	FLDDB.(.CMNOI,,<POINT 7,[ASCIZ /LP/]>,,,CMCFM)

HSTMSK:	FLDBK.(.CMFLD,,,,,HSTBRK,)


.IHSPT:	MOVX T2,ADRS		; Default Routine
	; Enter here with routine address in T2
.IHSP0:	MOVX T1,<-11,,0>	; SIZE OF BLOCK
	ADDI T1,(TA)		; -11,,TERM ADDRESS
	SETZM (T1)		; CLEAR ADDRESS TERM BLOCK
	AOBJN T1,.-1
	HRLM T2,-1(TA)		; Set routine address
	TXNE F,F.NO		; IF SAW NOT
	  HRROS (TA)		; LEFT HALF BECOMES -1

	MOVX T2,FADRGW		; ACCEPT GUIDE WORD
	CALL CCOMND
	CAIE T3,FADRGW		; NONE OR FOREIGN HOST ?
	  JRST ADRFPG		; NO, SOMETHING ELSE

	MOVX T2,HSTFLD
	CALL CCOMND			
	CALL NAMES		; GET ADDRESS
	  JRST ADDRER		; ERROR
	JUMPL HST,ADRNFH	; None there, skip it
	MOVEM HST,1(TA)		; SAVE FOREIGN HOST ADDRESS
	MOVX T1,<037777,,777777>
	MOVEM T1,2(TA)		; DEFAULT MASK
	AOS (TA)

	MOVX T2,MASFDB		; MASK OR
	MOVX T1,FPRTGW		; PORT GUIDE WORD IS NEXT
	STOR T1,NXFDB,(T2)
	CALL CCOMND		; GET NEXT FIELD
	CAIE T3,MASFDB
	  JRST ADRFPG		; NOT MASK, GO FOR PORT

	MOVX T2,HSTMSK		; GET MASK VALUE
	CALL CCOMND
	CALL NAMES		; GET MASK
	  JRST ADDRER		; ERROR
	JUMPL HST,ADRNFH	; None there, keep default
	MOVEM HST,2(TA)		; SAVE MASK
ADRNFH:

	MOVX T2,FPRTGW		; FOREIGN PORT IS NEXT
	CALL CCOMND
ADRFPG:	CAIE T3,FPRTGW		; FOREIGN PORT SPECIFIED?
	  JRST ADRLHG		; NOT, MAYBE LOCAL

	CALL GPORT		; GET A PORT
	  JRST ADDRER
	JUMPL PRT,ADRNFP	; None there, skip it
	MOVEM PRT,3(TA)		; SAVE FOREIGN PORT NUMBER
	MOVX T1,<177777>
	MOVEM T1,4(TA)		; DEFAULT MASK
	AOS (TA)

	MOVX T2,MASFDB
	MOVX T1,LADRGW
	STOR T1,NXFDB,(T2)
	CALL CCOMND		; GET MASK OR LOCAL INFO
	CAIE T3,MASFDB
	  JRST ADRLHG		; NOT MASK

	CALL GPORT		; GET MASK
	  JRST ADDRER
	JUMPL PRT,ADRNFP	; None there, keep default
	MOVEM PRT,4(TA)		; SAVE IT
ADRNFP:

	MOVX T2,LADRGW
	CALL CCOMND		; LOCAL INFO IS NEXT
ADRLHG:	CAIE T3,LADRGW		; LOCAL HOST SPECIFIED ?
	  JRST ADRLPG		; NO, MAYBE LOCAL PORT

	MOVX T2,HSTFLD
	CALL CCOMND
	CALL NAMES		; GET LOCAL HOST
	  JRST ADDRER
	JUMPL HST,ADRNLH	; None there, skip it
	MOVEM HST,5(TA)		; SAVE THE ADDRESS

	MOVX T1,<037777,,777777>
	MOVEM T1,6(TA)		; DEFAULT MASK
	AOS (TA)

	MOVX T2,MASFDB
	MOVX T1,LPRTGW
	STOR T1,NXFDB,(T2)
	CALL CCOMND		; GET MASK OR LOCAL PORT
	CAIE T3,MASFDB
	  JRST ADRLPG		; NOT MASK

	MOVX T2,HSTMSK
	CALL CCOMND
	CALL NAMES		; GET MASK VALUE
	  JRST ADDRER
	JUMPL HST,ADRNLH	; None there, keep default
	MOVEM HST,6(TA)		; SAVE IT
ADRNLH:

	MOVX T2,LPRTGW
	CALL CCOMND		; LOCAL PORT IS NEXT
ADRLPG:	CAIE T3,LPRTGW		; LOCAL PORT SPECIFIED ?
	  JRST ADRCM		; NO, MAYBE RETURN

	CALL GPORT		; GET LOCAL PORT
	  JRST ADDRER
	JUMPL PRT,ADRNLP	; None there, skip it
	MOVEM PRT,7(TA)		; SAVE IT

	MOVX T1,<177777>
	MOVEM T1,10(TA)		; DEFAULT MASK VALUE
	AOS (TA)

	MOVX T2,MASFDB
	MOVX T1,CMCFM
	STOR T1,NXFDB,(T2)
	CALL CCOMND		; GET MASK OR CONFIRM
	CAIE T3,MASFDB
	  JRST ADRCM		; NOT MASK
	CALL GPORT		; GET MASK VALUE
	  JRST ADDRER
	JUMPL PRT,ADRNLP	; None there, skip it
	MOVEM PRT,10(TA)	; SAVE IT
ADRNLP:
	MOVX T2,CMCFM		; GET CONFIRMING RETURN
	CALL CCOMND
ADRCM:
	HRROI T1,[ASCIZ /? Invalid address specificatoin; ignored./]
	CAIE T3,CMCFM		; HAVE CONFIRMATION ?
	  JRST ERXXXX		; NO, ERROR

	MOVX T2,<10-1>		; SET # ELEMENTS IN "LIST"
	HRRM T2,(TA)
	JRST TRCODX		; GO PROCESS THIS TERM


ADDRER:	HRROI T1,[ASCIZ /? Error; ignored./]
	JRST ERXXXX

; FILTER BUFFER-SAMPLES


.IBFR:	MOVX T1,0		; MASK to match anything
	MOVX T2,BFRF		; FILTER ROUTINE ADDRESS
	HRLM T2,-1(TA)		; SET ROUTINE
	MOVEM T1,1(TA)		; SET DEFAULT MASK
	TXNE F,F.NO		; REMEMBER IF NOT WAS GIVEN
	  HRROS (TA)		; IF SO, LEFT HALF TO -1

	JRST TRCODV		; Go confirm, bump count, zero next slot


;FILTER CLEAR (FILTER EXPRESSION)	[{ALL}]
;					[{<D#>}]
CLRNOI:	FLDDB.(.CMNOI,,<POINT 7,[ASCIZ /filter expression/]>,,,)

.ICLER:	MOVX T2,CLRNOI
	CALL CCOMND		; Get ALL or # or <return>
	MOVX T2,ALNFDB
	CALL CCOMND
	CAIN T3,CMCFM		; <return>
	  CALLRET CLRI		; Clear current expression
	MOVE FCT,T2		; Save address or #
	CALL CCMCFM 		; Confirm
	CAIN FCT,ALADR		;Clear all?
	 JRST CLRALL		;YES

CLRN:	CAILE FCT,0		; Range check # 1 NFILTB
	 CAILE FCT,NFILTB
	  RET			; Lose
	CAMLE FCT,FILTAB	; Make sure have Nth expression
	  RET			; Don't

CLRL:	MOVE T1,FILTAB+1(FCT)	; GET FCT+1TH EXPRESSION
	MOVEM T1,FILTAB(FCT)	; INTO FCT-TH SLOT
	AOS FCT			; MOVE TO NEXT
	JUMPN T1,CLRL		; LOOP UNTIL 0 WAS MOVED
	SOSGE FILTAB		; ONE LESS EXPRESSION IN TABLE
	  SETZM FILTAB
	RET

CLRALL:	SETZM FILTAB		; Zero filter table
	MOVE T1,[FILTAB,,FILTAB+1]
	BLT T1,FILTAB+NFILTB
	MOVEI T1,FREE		; Release all FREE storage
	MOVEM T1,FREEP

CLRI:	MOVE TA,FREEP		; LOCATE FREE STORAGE
	SETZM (TA)		; For routine ,, pointer
	AOS TA
	SETZM (TA)		; For -1 IF NOT,, COUNT OF ELEMENTS
	SETZM 1(TA)		; For mask
	RET



; ALL or <decimal number> OR <return>

ALNFDB:	FLDDB.	(.CMKEY,,ALNKEY,,,DECFIL)	;all

ALNKEY:	NALN,,NALN
ALADR:	TXALL,,0 ;ALL
NALN==.-ALNKEY-1

ALNHLP:	NALNH,,NALNH
	TXALL,,HALL
NALNH==.-ALNHLP-1

DECFIL:	FLDDB. (.CMNUM,,DECRAD,,,CMCFM)	;OR DECIMAL #


; FILTER [NOT] CODES <DECIMAL #> [<DECIMAL #>]* [/MASK:<OCTAL #>]

.ICWP:
PRSCD:	MOVX T2,PRCODS		; FILTER ROUTINE ADDRESS
	MOVEI T3,[FLDDB.(.CMNOI,,<POINT 7,[ASCIZ /within protocol of/]>)]
	MOVX FCT,PCDFDB		; Name, value, mask, or confirm
	CALLRET FILTRL		; Go parse name, number, or mask



HPRICM:	ASCIZ \Within-protocol codes (not) to be listed.\

	HPRICM,,PRSHLP
	JFCL
PCDFDB:	FLDDB. (.CMKEY,,PCDKEY,<PACKET TYPE>,,PRNFDB)
PCDKEY:	NPCD,,NPCD
	TXDTUN,,^D3
	TXECHO,,^D8
	TXECRP,,^D0
;	TXHELP,,-1
	TXIRP,,^D16
	TXIRQ,,^D15
	TXPARP,,^D12
	TXREDR,,^D5
	TXSRCQ,,^D4
	TXTMEX,,^D11
	TXTSMP,,^D13
	TXTSRP,,^D14
NPCD==.-PCDKEY-1


PRSHLP:	NHPCD,,NHPCD

NHPCD==.-PRSHLP

MSKFDB:	FLDDB. (.CMSWI,,MSKKEY,,,CMCFM)

MSKKEY:	NMSK,,NMSK
	TXMASK,,OCTFDB
NMSK==.-MSKKEY-1








; FILTER DONE (ENTERING FILTER EXPRESSIONS)


.DONE:	MOVEI T2,[FLDDB.(.CMNOI,,<POINT 7,[ASCIZ /entering filter expressions/]>,,,)]
	CALL CCOMND		; Confirm
	CALL CCMCFM		; Return from filter's parse
	JRST CMDXIT

	SUBTTL	Enter Current Expression into Filter Table

ENTNOI:	FLDDB.	(.CMNOI,CM%SDH,
<POINT 7,[ASCIZ /current filter expression into filter table/]>,,,)


.IENTR:	MOVX T2,ENTNOI
	CALL CCOMND
	CALL CCMCFM
	MOVE T4,TA		; Setup for scan
ENTRB:	SKIPE (T4)		; Term specified ?
	  JRST ENTRD		; YES
	HRRZ T4,-1(T4)		; Routine ,, POINTER
	JUMPN T4,ENTRB		; Back if another
				; No current expression to be entered
	HRROI T1,[ASCIZ /? You have not yet specified an expression; ignored.
/]
ENTRER:	PSOUT
	CALLRET CLRI


ENTRD:	SOS TA			; Back to unused word
	MOVE T3,TA		; Save for filtab
ENTRL:	HLL T4,-1(T4)		; Routine ,, items
	MOVEM T4,(TA)
	AOS TA
	SETZM (TA)		; Zero ends list
	HRRZ T4,-1(T4)		; Next term
	JUMPN T4,ENTRL		; Back if it exists
	HRROI T1,[ASCIZ /? Sorry, the filter table is full; ignored.
/]
	MOVE T2,FILTAB
	CAIL T2,NFILTB		;Room for another filter entry ?
	  JRST ENTRER		; No, error exit
	AOS TA			; Keep zero ending list
	MOVEM TA,FREEP		; Update free pointer
	AOS T2,FILTAB
	MOVEM T3,FILTAB(T2)
	HRROI T1,[ASCIZ /  Entered.
/]
	JRST ENTRER

	SUBTTL	INTERFACE

; FILTER [NOT] LINK-INTERFACE <NL.HSH or D#> [<NL.HSH or D#>]* [/MASK: <O#>]

IFCFDB:	FLDDB.(.CMKEY,,IFCKEY,<Interface #>,,IFCNUM)
IFCNUM:	FLDDB.(.CMNUM,,DECRAD,,,MSKFDB)
IFCKEY:	NIFC,,NIFC
	[TEXT <Loopback>],,0	;  0
	[TEXT <NCT1>],,1	;  1
	[TEXT <NCT2>],,2	;  2
NIFC==.-IFCKEY-1

.IIFAC:	MOVX T2,IFACCD		; Filter routine address
	MOVX FCT,IFCFDB		; Name, value, mask, or confirm
	CALLRET FILTRK		; Go parse terms and mask



	SUBTTL	LINK-PROTOCOL

; FILTER [NOT] LINK-PROTOCOL <NL.xxx or D#> [<NL.xxx or D#>]* [/MASK: <O#>]

LKPFDB:	FLDDB.(.CMKEY,,LKPKEY,<Link Protocol>,,LKPNUM)
LKPNUM:	FLDDB.(.CMNUM,,DECRAD,,,MSKFDB)
LKPKEY:	NLKP,,NLKP
	TX1822,,NL.NCP		;  1822
	TXNFE,,NL.NFE		;  Network-Front-End
NLKP==.-LKPKEY-1

.ILNKP:	MOVX T2,LNKPCD		; Filter routine address
	MOVX FCT,LKPFDB		; Name, value, mask, or confirm
	CALLRET FILTRK		; Go parse terms and mask



	SUBTTL	NETWORK DRIVER

; FILTER [NOT] NETWORK-DRIVER <NH.xxx or D#> [<NH.xxx or D#>]* [/MASK: <O#>]

NTDFDB:	FLDDB.(.CMKEY,,NTDKEY,<Network Driver>,,NTDNUM)
NTDNUM:	FLDDB.(.CMNUM,,DECRAD,,,MSKFDB)
NTDKEY:	NNTD,,NNTD
	TXANXX,,NH.ANX
	TXIMPX,,NH.BBN
	TXNFE,,NH.NFE
NNTD==.-NTDKEY-1

.INETD:	MOVX T2,NTDRCD		; Filter routine address
	MOVX FCT,NTDFDB		; Name, value, mask, or confirm
	CALLRET FILTRK		; Go parse terms and mask

; FILTER [NOT] PROTOCOLS <D#> [<D#>]* [/MASK: <O#>]

.IPROT:	MOVX T2,PROTS		; FILTER ROUTINE ADDRESS
	MOVX FCT,PRCFDB		; NAME, VALUE, MASK, OR RETURN
	CALLRET FILTRK

; Protocols

HPROTG:	ASCIZ \List of protocol names or numbers (not) to be listed.\

	HPROTG,,PRCHLP		;Parallel HELP keywords
	JFCL			;Reparse instruction
PRCFDB:	FLDDB.(.CMKEY,,PRCKEY,<Protocol name, pick>,,PRNFDB)
PRNFDB:	FLDDB.(.CMNUM,,DECRAD,<protocol>,,MSKFDB)

PRCKEY:	NPRC,,NPRC
	TXCHAS,,^D16
	TXCMCC,,^D4
	TXDCN,,^D19
	TXGGP,,^D3
	TXHELP,,-1
	TXICMP,,^D1
	TXMIT,,^D65
	TXMPLX,,^D18
	TXNVP,,^D11
	TXPKCU,,^D71
	TXPLRBS,,^D13
	TXPUP,,^D12
	TXRCC,,^D10
	TXSATB,,^D64
	TXSATM,,^D69
	TXSCR,,^D9
	TXST,,^D5
	TXSTBM,,^D76
	TXTAC,,^D20
	TXTCP,,^D6
	TXTELE,,^D14
	TXUCL,,^D7
	TXUSDG,,^D17
	TXWBEX,,^D79
	TXWBMN,,^D78
	TXXNET,,^D15
NPRC==.-PRCKEY-1


PRCHLP:	NPRCH,,NPRCH
	TXGGP,,HGGP
	TXICMP,,HICMP
	TXTCP,,HTCP
NPRCH==.-PRCHLP-1

	SUBTTL	PROTOCOL-SUITE

; FILTER [NOT] PROTOCOL-SUITE <NP.xxx or D#> [<NP.xxx or D#>]* [/MASK: <O#>]

PRSFDB:	FLDDB.(.CMKEY,,PRSKEY,<Protocol Suite>,,PRSNUM)
PRSNUM:	FLDDB.(.CMNUM,,DECRAD,,,MSKFDB)
PRSKEY:	NPRS,,NPRS
	TXIP,,NP.IP		; Darpa protocol suite
NPRS==.-PRSKEY-1

.IPRSU:	MOVX T2,PRSUCD		; Filter routine address
	MOVX FCT,PRSFDB		; Name, value, mask, or confirm
	CALLRET FILTRK		; Go parse things

; FILTER REGISTER-SAMPLES

.IREGS:	MOVX T1,0		; MASK to match anything
	MOVX T2,REGF		; FILTER ROUTINE ADDRESS

	HRLM T2,-1(TA)		; SET ROUTINE
	MOVEM T1,1(TA)		; SET DEFAULT MASK
	TXNE F,F.NO		; REMEMBER IF NOT WAS GIVEN
	  HRROS (TA)		; IF SO, LEFT HALF TO -1

	MOVEI T2,[FLDDB.(.CMNOI,CM%SDH,<POINT 7,[ASCIZ /will be accepted/]>)]
	CALL CCOMND

	JRST TRCODV		; Go confirm, bump count, zero next slot

	SUBTTL	FILTER-level SHOW Command

.ISHOW:	MOVX T2,CLRNOI
	CALL CCOMND

	MOVX T2,ALNFDB		; Get ALL, #, or RETURN
	CALL CCOMND
	CAIE T3,CMCFM
	  JRST SHOWAN		; All or #

; SHOW <return> -- Show expression being specified

	MOVX T1,.PRIOU
	HRROI T2,[ASCIZ /? There are no terms in the current expression./]
	SKIPN -1(TA)		; Have any terms?
	  JRST SHOWY		; No
	HRROI T2,[ASCIZ /       /]

	PUSH P,TA
SHOWR:	HRRZ TA,-1(TA)		; Move to next term
	JUMPE TA,SHOWS		; No more, All done
	MOVE T5,-1(TA)		; ROUTINE,,POINTER-TO-LAST
	HRRI T5,(TA)		; Pointer
	MOVE T4,(TA)		; -N,,NEGATE flag
	CALL SHOWT		; Output term
	HRROI T2,[ASCIZ /  and  /]
	JRST SHOWR		; Back for another

SHOWS:	POP P,TA		; Restore pointer
	JRST SHOWZ		; Done


; SHOW ALL or #

SHOWAN:	MOVE FCT,T2		; Save ALL/#
	CALL CCMCFM		; Confirm

	PUSH P,TI		; Save regs used by SHOWA
	PUSH P,TA

	MOVX T1,.PRIOU		; Primary output during command processing
	HRROI T2,[ASCIZ /       /]
	CALL SHOWA

	POP P,TA		; Restore regs
	POP P,TI
	RET


; FILTER TCB-SAMPLES
;
;  [NOT] TCB-SAMPLES	{ <confirm>			}
;			{ <TCB-filter-term>		}
;
;  Where <TCB-filter-term> is:
;		{ ID <decimal #> [<decimal #>]* [/MASK:<octal#>]	}
;		{ HOSTS-PORTS <hosts-ports-specification>		}

.ITCBS:	MOVX T2,TCBFDB
	CALL CCOMND		; Get TCB filter keyword
	TXNE T1,CM%NOP
	  JRST WHAT
	CAIN T3,CMCFM		; Confirm?
	  JRST TCBALL		; Yes, use all TCBs
	HRRZ FCT,(T2)		; Routine address
	JUMPE FCT,WHAT		; ??
	CALLRET (FCT)		; A TCB filter term

TCBALL:	MOVX T1,0		; MASK to match anything
	MOVX T2,TIDS		; TCB Filter ID Routine Address
	HRLM T2,-1(TA)		; Set routine
	MOVEM T1,1(TA)		; Set default mask
	TXNE F,F.NO		; NOT given?
	  HRROS (TA)		; Yes, left half to -1
	JRST TRCODW		; Go bump count & zero next slot



; FILTER [NOT] TCB-SAMPLES HOSTS-PORTS ...

.TCBHP:	MOVX T2,TADRS		; TCB HOSTS-PORTS filter routine
	JRST .IHSP0		; Join common code


; FILTER [NOT] TCB-SAMPLES ID <dec #> [<dec #>]* [/MASK:<oct #>]

.TCBID:	MOVX T1,<.RTJST(-1,TCBID)>  ; Default mask
	MOVX T2,TIDS		; TCB ID filter routine
	MOVX T3,TIDFDB		; Address of ID FLDDB
	JRST .TCBXX		; Join common code

; FILTER [NOT] TCB-SAMPLES JOBs <dec #> [<dec #>]* [/MASK:<oct #>]

.TCBJB:	MOVX T1,<.RTJST(-1,TOWNR)>  ; Default mask
	MOVX T2,TJBS		; TCB JOB filter routine
	MOVX T3,TJBFDB		; Address of JOB FLDDB
	JRST .TCBXX		; Join common code

.TCBXX:	PUSH P,T3		; Save address of FLDDB
	HRLM T2,-1(TA)		; Set routine
	MOVEM T1,1(TA)		; Set default mask
	TXNE F,F.NO		; NOT given?
	  HRROS (TA)		; Yes, left half to -1
TCBXXL:	MOVE T2,(P)		; Address of FLDDB
TCBXXX:	CALL CCOMND
	CAIE T3,CMCFM
	IFSKP.			; Return
	  POP P,(P)		; Drop the FLDDB address
	  JRST TRCODX
	ENDIF.
	CAIN T3,(P)
	  JRST TCBN		; Number in T2
	CAIN T3,MSKFDB
	  JRST TCBM		; /Mask:

	HRROI T1,[ASCIZ /? Invalid TCB ID term, ignored.
/]
	JRST ERXXXX

TCBM:	; Here to parse a mask
	HRRZ T2,(T2)		; Address of Mask parse routine
	CALL CCOMND		; Parse mask
	MOVEM T2,1(TA)		; Put into data structure
	MOVX T2,CMCFM
	JRST TCBXXX		; Confirm and exit

TCBN:	; Here to parse a number
	AOS T1,(TA)		; Count another number
	ADDI T1,1(TA)		; Locate next slot
	MOVEM T2,(T1)		; Put number into data structure
	JRST TCBXXL		; Look for more
	
	; FILTER TCB-SAMPLES HELP Routine
.TCBHL:	PUSH P,CURFDB		; Save the current FLDDB setting
	MOVEI T1,TCBFDB		; Get the TCB-SAMPLE FLDDB
	MOVEM T1,CURFDB		; Make it current
	CALL .HELP		; Call help
	  NOP			; It skips
	POP P,CURFDB		; Restore the old FLDDB
	RET

	; FILTER TCB-SAMPLES FLDDB
	HTCBS,,TCBHLP		; Help,,TCB help keyword table
	JFCL			; Reparse instruction
TCBFDB:	FLDDB.(.CMKEY,,TCBKEY,,,CMCFM)  ; Keyword OR Confirm

	; FILTER TCB-SAMPLES Keyword Table
	TBBEG(TCBKEY)
	TB TXHELP,.TCBHL	;  HELP
	TB TXHSTP,.TCBHP	;  HOSTS-PORTS
	TB TXIDS,.TCBID		;  IDs
	TB TXJOBS,.TCBJB	;  JOBs
	TBEND

	; FILTER TCB-SAMPLES Parallel Help Table
	TBBEG(TCBHLP)
	TB TXHSTP,HTCBHP
	TB TXIDS,HTCBID
	TB TXJOBS,HTCBJB
	TBEND

HTCBHP:	ASCIZ \Filter on HOSTS and PORTS that are specified.
\
HTCBID:	ASCIZ \Filter on the TCB IDs that are specified.
\
HTCBJB:	ASCIZ \Filter on the TCB owned by the specified jobs.
\

	; FILTER TCB-SAMPLES ID FLDDB
TIDFDB:	FLDDB.(.CMNUM,,DECRAD,<TCB ID>,,MSKFDB)

	; FILTER TCB-SAMPLES JOB FLDDB
TJBFDB:	FLDDB.(.CMNUM,,DECRAD,<Job number>,,MSKFDB)



; FILTER [NOT] TRACE-CODES <OCTAL #> [<OCTAL #>]* <RETURN>

TRCFDB:	FLDDB.(.CMKEY,,TRCKEY,,,OCDFDB)
OCDFDB:	FLDDB.(.CMNUM,,OCTRAD,,,MSKFDB)
TRCKEY:	NTRC,,NTRC
	TXGWIN,,<PT%RGW&1777>
	TXGWOU,,<PT%QLN&1777>
	TXLNAL,,<PT%%NT>
	TXLNIN,,<PT%RLN&1777>
	TXLNOU,,<PT%SLN&1777>
NTRC==.-TRCKEY-1


.ITRAC:	MOVX T2,TRCODS		; Set filter routine
	MOVX FCT,TRCFDB		; Names
	CALLRET FILTRK		; Go parse names, numbers, mask


;FILTRM	Parses name, number, mask, or confirm and places it into next term

;T1/	Default mask
;T2/	Address of filtering routine
;T3/	Address of noise
;FCT/	Address of first FDB in name, number, mask, or confirm

FILTRK:	MOVEI T3,[FLDDB.(.CMNOI,CM%SDH,<POINT 7,[ASCIZ /to accept are/]>)]
FILTRL:	MOVX T1,377		; Default mask if /MASK: not given
FILTRM:	HRLM T2,-1(TA)
	MOVEM T1,1(TA)
	TXNE F,F.NO
	  HRROS (TA)		; Remember if NOT was given

	MOVE T2,T3		; Noise
	CALL CCOMND

	DO.			; Process all terms
	  MOVE T2,FCT		; Name, value, mask, or confirm
	  DO.
	    CALL CCOMND		; Get next field, T3 & T4 set
	    CAIN T3,CMCFM	; Confirmed?
	      JRST TRCODX	; Yes, return

	    CAIE T3,MSKFDB	; Mask?
	    IFSKP.		; Yes
	      HRRZ T2,(T2)	; Want octal mask value
	      CALL CCOMND
	      MOVEM T2,1(TA)	; Value into data structure
	      MOVX T2,CMCFM	; Only allow <return> after mask
	      LOOP.		; Back for confirmation
	    ENDIF.
	  ENDDO.

	  HRRZ T1,(T4)		; Get FLDDB of number
	  CAMN T3,T1		; Number in T2 ?
	  IFSKP.		; No
	    HRROI T1,[ASCIZ /? Invalid term; ignored.
/]  
	    CAME T3,T4		; Name?
	      JRST ERXXXX	; No, something else ?? an error
	    HRRE T2,(T2)	; Get value correpsonding to name
	  ENDIF.		; Now have # in T2
	  IFL. T2		; Make sure valid
	    CALL .HELP		; Not valid
	      NOP		; .HELP skips
	    LOOP.		; Invalid number specified
	  ENDIF.
	  AOS T1,(TA)		; Count another term
	  ADDI T1,1(TA)		; Locate its slot
	  MOVEM T2,(T1)		; Put code into data structure
	  LOOP.			; Look for more codes
	ENDDO.


ERTRCD:	HRROI T1,[ASCIZ /? Invalid term; ignored.
/]

ERXXXX:	PSOUT			; MESSAGE TO USER
	HRRZS -1(TA)		; JUST KEEP LINK TO LAST
	SETZM (TA)		; NO NEGATE,,COUNT
	SETZM 1(TA)		; NO MASK
	RET


;0,,POINTER TO LAST		TRCODS,,POINTER TO LAST
;TA->0,,0	BECOMES			-N,,[NEGATE] <--+
;0,,0					-1              !
;					<CODE>          !
;					<CODE>          !
;					0,,POINTER TO --+
;				TA->	0,,0
;					0,,0


TRCODV:	CALL CCMCFM		; Confirm term

TRCODW:	AOS T1,(TA)		; Count term just added
	ADDI T1,1(TA)		; Next slot
	SETZM (T1)		; Make it zero

TRCODX:	HRRZ T3,(TA)		; COUNT OF ELEMENTS IN TERM
	JUMPE T3,ERTRCD		; NO ELEMENTS IS ERROR
	MOVN T2,T3		; NEGATIVE COUNT FOR AOBJN
	HRLZS T2		; IN LH
	SKIPG (TA)		; IF SAW NOT
	  TXO T2,NEGATE		; SET NEGATE FLAG
	MOVEM T2,(TA)		; INTO DATA STRUCTURE
	MOVE T2,TA
	ADDI TA,2+1(T3)		; FREE SPACE FOR NEXT TERM
	MOVEM T2,-1(TA)		; (ROUTINE=0),,LINK TO LAST
	SETZM (TA)		; (-1 IF NEGATE,,COUNT=0)
	SETZM 1(TA)		; (MASK=0)
	RET

	SUBTTL	FORMAT Command

HFRMT:	ASCIZ	\The FORMAT command is used to specify how the sampled
packets should be listed.  The FORMAT modifiers may be displayed by typing
"FO ?" after the Parameter> prompt.
\
HASCF:	ASCIZ	\List TCP data as ASCII characters.\
HBINF:	ASCIZ	\List TCP data as BINARY octets.\
;HBFRF:	ASCIZ	\Specify which buffer header fields should be displayed.\
HCORF:	ASCIZ	\Input file is from a core dump.\
HDATAF:	ASCIZ	\Specify whether data octets should be listed.\
HGARB:	ASCIZ	\List garbage octets after the end of the packet.\
HGGP:	ASCIZ	/GGP packets are included./
HICMP:	ASCIZ	/List ICMP packets./
HICMF:	ASCIZ	\Specify which ICMP fields should be listed.\
HINTL:	ASCIZ	\List internal fields from samples.\
HINT:	ASCIZ	\Specify which internal fields should be listed.\
HIPF:	ASCIZ	\Specify which IP fields should be listed.\
HLCL:	ASCIZ	\List packet's local leader.\
HLONG:	ASCIZ	\Use long listing format (titles for each field are listed).\
HMXDL:	ASCIZ	\Maximum number of data bytes to be listed.\
HNO:	ASCIZ	\Negate following item.\
HNTF:	ASCIZ	\Specify which local net fields should be listed.\
HOMITF:	ASCIZ	\Specify whether number of omitted data octets should be listed.\
HPAGEF:	ASCIZ	\Paginate the listing.\
HREGF:	ASCIZ	\Specify format of register samples to be listed.\
HSHRT:	ASCIZ	\Use short listing format (field titles are not listed).\
HTCP:	ASCIZ	/List TCP packets./
HTCPF:	ASCIZ	\Specify which TCP fields should be listed.\
HTCBF:	ASCIZ	\Specify which TCB fields should be listed.\
;HUQ:	ASCIZ	/List user queue packets./
HVERS:	ASCIZ	/Specify monitor version of trace data./

FRMINI:	MOVE TMP,[LOAD T1,OKKY,(T3)]
	MOVEI T2,FRMFDB		; Haven't yet seen NO
	CALL KEYINI
	RET

.FORM:	CALL FRMINI		; Reset NO
NOFRMT:	MOVX T2,FRMFDB
	MOVEM T2,LSTFDB		; For no
	CALL CCOMND		; Get format parameter
	TXNE T1,CM%NOP
	  JRST WHAT
	HRRZ FCT,(T2)		;Routine address
	JUMPE FCT,WHAT		; ??
	CALL (FCT)		; Set/Clear bit
	  RET			; All OK, try another
	JRST NOFRMT		; NO - try again

HFRMTG:	ASCIZ \Parameters which control the format of the listing may
now be specified.  The listing format for a particular
protocol header may be customized by specifying the FIELDS
keyword.\

	HFRMTG,,FRMHLP		;Parallel HELP keywords
	CALL FRMINI		;Reparse instruction
FRMFDB:	FLDDB.	(.CMKEY,,FRMKEY)

; Format keywords

FRMKEY:	NFRM,,NFRM
	TXASC,,.OASC		;  ASCII
	TXBFLD,,.OTBFR		;  B-FIELDS
	TXBIN,,.OBIN		;  BINARY
	TXBFRD,,.OTBFR		;  BUFFER-FIELDS
	TXCORF,,.ICOR		;  CORE-FORMAT
	TXDATA,,.ODATL		;  DATA-OCTETS
	TXFILE,,.OFILP		;  FILE-POSITION
	TXGARB,,.OGARB		;  GARBAGE-OCTETS
	TXHELP,,.FRMHL		;  HELP
	TAINTF,,.OFINT		;  I-FIELDS
	TAINTL,,.OINTL		;  I-LEADERS
	TXICMF,,.OFICM		;  ICMP-FIELDS
	TXINT,,.OFINT		;  INTERNAL-FIELDS
	TXINTL,,.OINTL		;  INTERNAL-LEADERS
	TXIPF,,.OFIP		;  IP-FIELDS
	TALCF,,.OFLCL		;  L-FIELDS
	TALCL,,.OLCLL		;  L-LEADERS
	TXLCF,,.OFLCL		;  LOCAL-FIELDS
	TXLCL,,.OLCLL		;  LOCAL-LEADERS
	TALONG,,FRMKA5		;  LO
FRMKA5:	TXLONG,,.OLONG		;  LONG
	TXMXDL,,.ODATC		;  MAXIMUM-DATA-LENGTH
	TXNO,,.NO		;  No ...
	TXOMIT,,.OOMIT		;  OMITTED-COUNT
	TXPAGE,,.OPAGE		;  PAGINATION
	TXPARI,,.OPARI		;  PARITY
;	TX ,,FRMREG		;  REGISTER
	TXSHRT,,.OSHRT		;  SHORT
	TXTCBF,,.OFTCB		;  TCB-FIELDS
	TXTCPF,,.OFTCP		;  TCP-FIELDS
	TXUDPF,,.OFUDP		;  UDP-FIELDS
;	TXVERS,,.IVERS		;  VERSION
NFRM==.-FRMKEY-1

	; Handle the FORMAT HELP command
.FRMHL:	PUSH P,CURFDB		; Save the current FLDDB setting
	MOVEI T1,FRMFDB		; Get the FORMAT FLDDB
	MOVEM T1,CURFDB		; Make it current
	CALL .HELP		; Call help
	  NOP			; It skips
	POP P,CURFDB		; Restore the old FLDDB
	RET

FRMHLP:	NFRMH,,NFRMH
	TXASC,,HASCF
	TXBFLD,,HBFRF		;  B-FIELDS
	TXBIN,,HBINF
	TXBFRD,,HBFRF		;  BUFFER-FIELDS
	TXCORF,,HCORF
	TXDATA,,HDATAF		;  DATA-OCTETS
	TXGARB,,HGARB
;	TXGGP,,HGGP
	TXICMF,,HICMF
;	TXICMP,,HICMP
	TXINT,,HINT
	TXINTL,,HINTL
	TXIPF,,HIPF
	TXLCF,,HNTF
	TXLCL,,HLCL
	TXLONG,,HLONG
	TXMXDL,,HMXDL
	TXNO,,HNO
	TXOMIT,,HOMITF		;  OMITTED-COUNT
	TXPAGE,,HPAGEF
	TXSHRT,,HSHRT
	TXTCBF,,HTCBF
	TXTCPF,,HTCPF
;	TXTCP,,HTCP
;	TXVERS,,HVERS
NFRMH==.-FRMHLP-1

	SUBTTL	FORMAT Fields Using Flag Bits

.OASC:	CALL CCMCFM		;Confirm ASCII
	TXNN F,F.NO
	 TXOA F,F%TX
	  TXZ F,F%TX
	RET

.OBIN:	CALL CCMCFM		;Confirm BINARY
	TXNN F,F.NO
	 TXOA F,F%BIN
	  TXZ F,F%BIN
	RET

.ICOR:	CALL CCMCFM		;Confirm ASCII
	MOVX T1,<IFIW+.DOSAM>	; Be safe
	MOVEM T1,FUNCT
	TXNN F,F.NO
	 TXOA F,F%FCOR
	  TXZ F,F%FCOR
	RET

.ODATL:	CALL CCMCFM		; Confirm(no) DATA-OCTETS
	TXNE F,F.NO
	 TXOA F,F%NDAT
	  TXZ F,F%NDAT
	RET

.OFILP:	CALL CCMCFM		; Confirm(no) FILE-POSITION
	TXNN F,F.NO
	 TXOA F,F%FILP
	  TXZ F,F%FILP
	RET

.OGARB:	CALL CCMCFM		; Confirm(no) garbage
	TXNN F,F.NO
	 TXOA F,F%GB
	  TXZ F,F%GB
	RET

.OINTL:	CALL CCMCFM		;Confirm (no) internal fields
	TXNN F,F.NO
	 TXOA F,F%INTL
	  TXZ F,F%INTL
	RET

.OLCLL:	CALL CCMCFM		;Confirm (no) local leaders
	TXNN F,F.NO
	 TXOA F,F%LLDR
	  TXZ F,F%LLDR
	RET

.OLONG:	CALL CCMCFM		;Confirm long
	TXNE F,F.NO
	 TXOA F,F%SF
	  TXZ F,F%SF
	RET

.OOMIT:	CALL CCMCFM		; Confirm(no) OMITTED-COUNT
	TXNN F,F.NO
	 TXOA F,F%OMIT
	  TXZ F,F%OMIT
	RET

.OPAGE:	CALL CCMCFM		;Confirm (no) pagenated
	TXNN F,F.NO
	 TXOA F,F%PG
	  TXZ F,F%PG
	RET

.OPARI:	CALL CCMCFM		;Confirm (no) parity bit
	TXNE F,F.NO
	 TXOA F,F%NOPY
	  TXZ F,F%NOPY
	RET

.OSHRT:	CALL CCMCFM		;Confirm short
	TXNN F,F.NO
	 TXOA F,F%SF
	  TXZ F,F%SF
	RET

	SUBTTL	FORMAT Specifications with Numbers

; Read maximum number of data bytes to be listed

MXDNOI:	FLDDB.(.CMNOI,,<POINT 7,[ASCIZ /to be listed/]>,,,)
MXDFDB:	FLDDB.(.CMNUM,,DECRAD,,,)

.ODATC:	MOVX T2,MXDNOI		; Noise
	CALL CCOMND

	MOVX T2,MXDFDB
	CALL CCOMND
	MOVEM T2,FCT

	CALL CCMCFM		; Confirm

	HRROI EST,[ASCIZ / Invalid Maximum-data-length/]
	CAIL FCT,0
	 CAILE FCT,MAXPKT*4	; Rough top value
	  JRST ER		; Lose
	SETZ EST,

	MOVEM FCT,DATDLN	; Set maximum data length
	RET


; Read version

VERNOI:	FLDDB.(.CMNOI,,<POINT 7,[ASCIZ /of input data/]>,,,)
VERFDB:	FLDDB.(.CMNUM,,DECRAD,,,)


.IVERS:	MOVX T2,VERNOI		; Noise
	CALL CCOMND

	MOVX T2,VERFDB
	CALL CCOMND
	MOVEM T2,FCT

	CALL CCMCFM		; Confirm

	HRROI EST,[ASCIZ / Invalid Version Number/]
	CAIL FCT,0
	 CAILE FCT,VMINOR
	  JRST ER		; Lose
	SETZ EST,

	MOVEM FCT,VERSUN	; Set version
	RET

	SUBTTL	FORMAT xxx-FIELD Specifications

; Find Buffer header fileds which should be listed

FRMIBF:	MOVE TMP,[LOAD T1,OKKY,(T3)]
	MOVEI T2,BFRFDB		; Haven't yet seen NO
	CALL KEYINI
	RET


.OTBFR:	MOVEI T1,FBFR		; Flag word to be updated
	MOVX T2,BFRFDB		; Table for common routine
	CALLRET FRMXXX		; Get the bits



HBFRF:	ASCIZ /Specify which fields in a TCP Buffer header should be listed./

	CALL FRMIBF		; Init instruction
BFRFDB:	FLDDB.(.CMKEY,,BFRKEY,,,CMCFM)

BFRKEY:	NBFR,,NBFR
	TXALL,,[377777777777]	; ALL
	TXBCNT,,LBCNT		; Current octet count
	TXBDAD,,LBDADR		; User data address
	TXBDSP,,LBDSPT		; Data map page SPT index
	TXBFRL,,LBFRFLG		; User flag word
	TXBFRK,,LBFRKX		; FORKX of RECV%/SEND%
	TXBFRM,,LBFRMN		; Monitor space buffer
	TXBFRO,,LBFROPT		; Option word
	TXBFRQ,,LBFRQ		; Queue
	TXBFSR,,LBFSRC		; Share count
	TXBHAD,,LBHADR		; User buffer header address
	TXBHSP,,LBHSPT		; Header map page SPT index
	TXBICN,,LBICNT		; Initial octet count
	TXBIDX,,LBIDX		; Wait index
	TXBPTR,,LBPTR		; Data pointer
	TXBTCB,,LBTCB		; TCB
	TXBTS,,LBTS		; Time stamp
	TXDFLT,,<FLDEF+[DBFR]>	; DEFAULT
	TXNO,,FLDNO		; NO
NBFR==.-BFRKEY-1


; Find Internal fields which should be listed

FRMIIN:	MOVE TMP,[LOAD T1,OKKY,(T3)]
	MOVEI T2,ITFFDB		; Haven't yet seen NO
	CALL KEYINI
	RET



.OFINT:	MOVEI T1,FINT		; Flag word to be updated
	MOVX T2,ITFFDB		; Table for common routine
	CALLRET FRMXXX		; Get the bits



	CALL FRMIIN		; Init instruction
ITFFDB:	FLDDB.(.CMKEY,,ITFKEY,,,CMCFM)

ITFKEY:	NITF,,NITF
	TXAPDT,,LPAPDT		; A-ADDRESS
	TXAPBZ,,LPAPBZ		; A-LENGTH
	TXNAM,,LNAM		; ACTUAL-TRANSMISSION-TIME
	TXALL,,[377777777777]	; ALL
	TXCMPR,,LCNR		; Completion routine
	TXDFLT,,<FLDEF+[DFINT]>	; DEFAULT
	TXDCT,,LCTPTO		; DESTROY-TIME
	TXDRVB,,LPLNDB		; DRV-BEGIN
	TXDRVE,,LPLNDE		; DRV-END
	TXNEM,,LNEM		; ESTIMATED-TRANSMISSION-TIME
	TXFLAG,,LPFLGS		; FLAGS
	TXFLOC,,LNFC		; Flow control
	TXHINT,,LHNT		; Hint
	TXNDT,,LNDT		; L-ADDRESS
	TXHN2,,LHN2		; L-HINT
	TXNBZ,,LNBZ		; L-LENGTH
	TXBYT,,LBYT		; LAST-BYTE
	TXLENO,,LBSZ		; Length-octets
	TXMXDL,,LPMXSZ		; MAXIMUM-DATA-LENGTH
	TXNCT,,LBNCT		; NCT-ADDRESS
	TXNO,,FLDNO		; NO
	TXPKTQ,,LPQU		; Packet queue
	TXPGLK,,LPLC		; Pages locked
	TXPROT,,LPRO		; Protocol
	TXQUE,,LSQUE		; QUEUE
	TXIPTO,,LCTPTO		; RA-TIMEOUT
	TXREAS,,LRAXI		; REASSEMBLY
	TXPRT,,LPTSRT		; RECEIVED-TIME
	TXRXI,,LRAXI		; RETRANSMIT-INTERVAL
	TXROUT,,LPFLAD		; ROUTE
	TXSDT,,LSDT		; S-ADDRESS
	TXSHNT,,LPHINT		; S-HINT
	TXSBZ,,LSBZ		; S-LENGTH
	TXTPDT,,LTPDT		; T-ADDRESS
	TXTG,,LPTG		; T-GENERATED
	TXTPBZ,,LTPBZ		; T-LENGTH
	TXTQ,,LPLNQD		; T-QUEUED
	TXTRX,,LPXT		; T-RETRANSMIT
	TXTS,,LPTSRT		; T-SEND


NITF==.-ITFKEY-1

; Find Local Net Leader fields which should be listed

FRMILN:	MOVE TMP,[LOAD T1,OKKY,(T3)]
	MOVEI T2,LNFFDB		; Haven't yet seen NO
	CALL KEYINI
	RET


.OFLCL:	MOVEI T1,FLN		; Address of flag word
	MOVX T2,LNFFDB		; Get field name or confirm
	CALLRET FRMXXX		; Parse & update

	CALL FRMILN		; Init NO
LNFFDB:	FLDDB.(.CMKEY,,LNFKEY,,,CMCFM)

LNFKEY:	NLNF,,NLNF
	TX1TY,,LIHFTY		; 1822-TYPE
	TXADR,,LIADDR		; ADDRESS x.x.x.x
	TXALL,,[377777777777]	; ALL
	TXDFLT,,<FLDEF+[DFLN]>	; DEFAULT
	TXHTY,,LIHHTY		; HANDLING-TYPE
;	TXIHOST,,0
	TXIMP,,LIHHST		; IMP #x
;	TXITRA,,0
	TXLDF,,LIHLDF		; LEADER-FLAGS
	TXLENB,,LIHLEN		; LENGTH-BITS
	TXLINK,,LIHLNK		; LINK
	TXMSID,,LIHMI2		; MSG-ID
	TXMSST,,LIHSTY		; MSG-SUB-TYPE
	TXMSTY,,LIHMTY		; MSG-TYPE
	TXNET,,LIHNET		; NET
	TXNO,,FLDNO		; NO
;	TXTYPE,,LIHNAM
NLNF==.-LNFKEY-1


; Find IP Header fields which should be listed

FRMIIP:	MOVE TMP,[LOAD T1,OKKY,(T3)]
	MOVEI T2,IPFFDB		; Haven't yet seen NO
	CALL KEYINI
	RET



.OFIP:	MOVEI T1,FIP		; Address of flag words
	MOVX T2,IPFFDB		; Get field name or confirm
	CALLRET FRMXXX		; Parse & update



	CALL FRMIIP		; Init keywords
IPFFDB:	FLDDB.(.CMKEY,,IPFKEY,,,CMCFM)

IPFKEY:	NIPF,,NIPF
	TXALL,,[377777777777]	; ALL
	TXCHKS,,LPICKS		; CHECKSUM
	TXDATO,,LPIDO		; DATA-OFFSET
	TXDFLT,,<FLDEF+[DFIP]>	; DEFAULT
	TXDEST,,LPIDH		; DESTINATION
	TXDONF,,LPIDF		; DONT-FRAGMENT
	TXFLAG,,LPIFLG		; FLAGS
	TXFRGO,,LPIFO		; FRAGMENT-OFFSET
	TXHIRE,,LPIHRL		; HI-RELIABILITY
	TXHITR,,LPIHTR		; HI-THROUGHPUT
	TXLENO,,LPIPL		; LENGTH-OCTETS
	TXLODY,,LPILDY		; LO-DELAY
	TXMORF,,LPIMF		; MORE-FRAGMENTS
	TXNO,,FLDNO		; NO
	TXPREC,,LPIPRC		; PRECEDENCE
	TXPROT,,LPIPRO		; PROTOCOL
	TXSGID,,LPISID		; SEGMENT-ID
	TXSORC,,LPISH		; SOURCE
	TXTIML,,LPITTL		; TIME-LIVE
	TXTYPS,,LPITOS		; TYPE-SERVICE
	TXVER,,LPIVER		; VERSION
NIPF==.-IPFKEY-1

; Find ICMP Header fields which should be listed

FRMIIC:	MOVE TMP,[LOAD T1,OKKY,(T3)]
	MOVEI T2,ICMFDB		; Haven't yet seen NO
	CALL KEYINI
	RET


.OFICM:	MOVEI T1,FICMP		; Address of flag word
	MOVX T2,ICMFDB		; Get field name or confirm
	CALLRET FRMXXX		; Parse & update


	CALL FRMIIC		; Init keywords
ICMFDB:	FLDDB.(.CMKEY,,ICMKEY,,,CMCFM)

ICMKEY:	NICM,,NICM
	TXALL,,[377777777777]	; ALL
	TXCHKS,,LCMCKS		; CHECKSUM
	TXCODE,,LCMCOD		; CODE
	TXDFLT,,<FLDEF+[DFICMP]>; DEFAULT
	TXGATW,,LCMGWA		; GATEWAY
	TXID,,LCMID		; IDENTIFIER
	TXNO,,FLDNO		; NO
	TXPNTR,,LCMPTR		; POINTER
	TXSEQN,,LCMSEQ		; SEQUENCE
	TXTO,,LCMTSO		; T-ORIGINATE
	TXTR,,LCMTSR		; T-RECEIVE
	TXTT,,LCMTST		; T-TRANSMIT
	TXTYPE,,LCMTYP		; TYPE
NICM==.-ICMKEY-1


; Find Registers

FRMIRG:	MOVE TMP,[LOAD T1,OKKY,(T3)]
	MOVEI T2,REGFDB		; Haven't yet seen NO
	CALL KEYINI
	RET


FRMREG:	MOVEI T1,FREG		; Flag word to be updated
	MOVX T2,REGFDB		; Table for common routine
	CALLRET FRMXXX		; Get the bits



	CALL FRMIRG		; Init instruction
REGFDB:	FLDDB.(.CMKEY,,REGKEY,,,CMCFM)

REGKEY:	NREG,,NREG
	TXALL,,[377777777777]	; ALL
	TXDFLT,,<FLDEF+[DREG]>	; DEFAULT
	TXNO,,FLDNO		; NO
NREG==.-REGKEY-1


; Find TCB Header fields which should be listed

FRMIT0:	MOVE TMP,[LOAD T1,OKKY,(T3)]
	CALLRET KEYIN0

FRMITB:	MOVE TMP,[LOAD T1,OKKY,(T3)]
	MOVEI T5,TCBFLD		; Address of field/sub-field table
	DO.
	  HRRZ T3,(T5)		; Get the keyword table address
	  JUMPE T3,ENDLP.	; If 0, all done
	  CALL KEYIN0		; Init it
	  ADDI T5,TSBWPE-1	; Words per entry minus 1
	  AOJA T5,TOP.		; One more and loop
	ENDDO.
	RET

	CALL FRMITB		; Init instruction
TCBFFD:	FLDDB.(.CMKEY,,TCBFKY)

.OFTCB:	MOVX T1,FTCB		; Address of TCB flags word
	MOVX T2,TCBFFD		; Keyword table
	CALLRET FRMXXX		; Get the bits

.TBALL:	TDZA T5,T5		; 0 means ALL
.TBDEF:	  SETO T5,		; -1 means DEFAULT
	MOVX T2,CMCFM		; Confirm this mess
	CALL CCOMND
	MOVEI T2,TCBFLD		; Get address of field/sub-field table
	DO.
	  HLRZ T3,0(T2)		; Get the flag address
	  JUMPE T3,ENDLP.	; If 0, all done
	  MOVE T4,1(T2)		; Assume default
	  SKIPN T5		; ALL wanted?
	    MOVX T4,<377777777777>  ; Yes, use all bits
	  SKIPE T5		; Default wanted?
	    SETZM (T3)		; Yes, clear the bits
	  TXNN F,F.NO		; "NO" prefix?
	    IORM T4,(T3)	; Not a "NO", turn on the bits
	  TXNE F,F.NO		; "NO" prefix?
	    ANDCAM T4,(T3)	; A "NO", turn off the bits
	  ADDI T2,TSBWPE-1	; Words per entry minus 1
	  AOJA T2,TOP.		; One more and loop
	ENDDO.
	TXZ F,F.NO		; Clear NO
	RET			; Return +1 to exit FRMXXX promptly

.TBINC:	PUSH P,(T1)		; Save argument
	MOVX T2,CMCFM		; Confirm
	CALL CCOMND
	POP P,T4
	MOVX T3,FTCB
	TXNN F,F.NO		; "NO" prefix?
	  IORM T4,(T3)		; Not a "NO", turn on the bits
	TXZE F,F.NO		; "NO" prefix?
	  ANDCAM T4,(T3)	; A "NO", turn off the bits
	RET			; Return +1 to exit FRMXXX promptly

; Test if TCB field/subfields for format command are in the default
;  state.

ISTCBD:	MOVEI T5,TCBFLD		; Address of field/subfield
	DO.
	  HLRZ T4,(T5)		; Get the flag address
	  JUMPE T4,ENDLP.	; Exit if done
	  MOVE T4,(T4)		; Get the flag
	  CAME T4,1(T5)		; Same as the default?
	    RET			;  No, fail
	  ADDI T5,TSBWPE-1	; Try the next
	  AOJA T5,TOP.
	ENDDO.
	AOS (P)			; Success, skip return
	RET

; WARNING!!! TCBFKY and TCBFLD/TCBSUB are parallel tables and must be
; updated together!!!

	; TCB-FIELDS keyword table
	TBBEG(TCBFKY)
	TB TXALL,<FLRTN+[EXP .TBALL]>  ; ALL (fields/subfields)
	TB TXDEDF,<FLRTN+[EXP FRMXXX,FTBDED,TBDEDF]>  ; DEAD-TCB-FIELDS
	TB TXDECF,<FLRTN+[EXP FRMXXX,FTBDEC,TBDECF]>  ; DEC-TCB-FIELDS
	TB TXDFLT,<FLRTN+[EXP .TBDEF]>  ; DEFAULT (fields/subfields)
	TB TXERRF,<FLRTN+[EXP FRMXXX,FTBERR,TBERRF]>  ; ERROR-FIELDS
	TB TXFLOF,<FLRTN+[EXP FRMXXX,FTBFLO,TBFLOF]>  ; FLOW-CONTROL-FIELDS
	TB TXIDF,<FLRTN+[EXP FRMXXX,FTBIDF,TBIDFF]>   ; IDENTIFYING-FIELDS
	TB TXINTF,<FLRTN+[EXP FRMXXX,FTBINT,TBINTF]>  ; INTERRUPT-FIELDS
	TB TXNO,FLDNO				      ; NO ...
	TB TXOPTF,<FLRTN+[EXP FRMXXX,FTBOPT,TBOPTF]>  ; OPTION-FIELDS
	TB TXRSCF,<FLRTN+[EXP FRMXXX,FTBRSC,TBRSCF]>  ; R-S-COUNT-FIELDS
	TB TXRCVF,<FLRTN+[EXP FRMXXX,FTBRCV,TBRCVF]>  ; RECEIVE-FIELDS
	TB TXRXF,<FLRTN+[EXP FRMXXX,FTBRX,TBRXF]>     ; RETRANSMISSION-FIELDS
	TB TXROUF,<FLRTN+[EXP FRMXXX,FTBROU,TBROUF]>  ; ROUTE-FIELDS
	TB TXSNDF,<FLRTN+[EXP FRMXXX,FTBSND,TBSNDF]>  ; SEND-FIELDS
	TB TXTIMF,<FLRTN+[EXP FRMXXX,FTBTIM,TBTIMF]>  ; TIME-FIELDS
	TBEND

; WARNING!!! TCBFKY and TCBFLD/TCBSUB are parallel tables and must be
; updated together!!!

; Table of fields/subfields:
;  first is the flag word address in the LH,,Keyword table addr in RH
;  second word is the default

	TSBWPE==2 ; WORDS PER ENTRY

TCBFLD:	EXP <FTCB,,TCBFKY>,DFTCB  ; TCB-FIELDS
TCBSUB:	EXP <FTBDED,,TBDEDK>,DFTDED  ; DEAD-TCB-FIELDS
	EXP <FTBDEC,,TBDECK>,DFTDEC  ; DEC-TCB-FIELDS
	EXP <FTBERR,,TBERRK>,DFTERR  ; ERROR-FIELDS
	EXP <FTBFLO,,TBFLOK>,DFTFLO  ; FLOW-CONTROL-FIELDS
	EXP <FTBIDF,,TBIDFK>,DFTIDF  ; IDENTIFYING-FIELDS
	EXP <FTBINT,,TBINTK>,DFTINT  ; INTERRUPT-FIELDS
	EXP <FTBOPT,,TBOPTK>,DFTOPT  ; OPTION-FIELDS
	EXP <FTBRSC,,TBRSCK>,DFTRSC  ; R-S-COUNT-FIELDS
	EXP <FTBRCV,,TBRCVK>,DFTRCV  ; RECEIVE-FIELDS
	EXP <FTBRX,,TBRXK>,DFTRX  ; RETRANSMISSION-FIELDS
	EXP <FTBROU,,TBROUK>,DFTROU  ; ROUTE-FIELDS
	EXP <FTBSND,,TBSNDK>,DFTSND  ; SEND-FIELDS
	EXP <FTBTIM,,TBTIMK>,DFTTIM  ; TIME-FIELDS
	EXP <0,,0>,0		; Marks end of table


; FLDDBs/Keyword tables for TCB sub-fields

	CALL [MOVEI T3,TBDEDK
	      JRST FRMIT0]
TBDEDF:	FLDDB.(.CMKEY,,TBDEDK,,,CMCFM)

	; DEAD-TCB-FIELDS keyword table
	TBBEG(TBDEDK)
	TB TXALL,[377777777777]	; ALL
	TB TXDFLT,<FLDEF+[DFTDED]>  ; DEFAULT
	TB TXINCL,<FLRTN+[EXP .TBINC,LDED]> ; INCLUDED
	TB TXNO,FLDNO		; NO ...
	TB TXBRBQ,LTKRBQ	; TCBRBQ
	TB TXBRPQ,LTKRPQ	; TCBRPQ
	TB TXBRXQ,LTKRXQ	; TCBRXQ
	TB TXBSBQ,LTKSBQ	; TCBSBQ
	TB TXCQDY,LTCQDY	; TCQDY
	TB TXCQPZ,LTCQPZ	; TCQPX
	TB TXCQRA,LTCQRA	; TCQRA
	TB TXCQRX,LTCQRX	; TCQRX
	TB TXJCN,LTJCND		; TJCN
	TB TXRSYN,LTRSYN	; TRSYN
	TB TXSCB,LTSCBD		; TSCB
	TB TXSSYN,LTSSYN	; TSSYN
	TB TXSUOP,LTSUOP	; TSUOP
	TBEND

	CALL [MOVEI T3,TBDECK
	      JRST FRMIT0]
TBDECF:	FLDDB.(.CMKEY,,TBDECK,,,CMCFM)

	; DEC-TCB-FIELDS keyword table
	TBBEG(TBDECK)
	TB TXALL,[377777777777]	; ALL
	TB TXDFLT,<FLDEF+[DFTDEC]>  ; DEFAULT
	TB TXFLAG,LTBDFG	; FLAGS
	TB TXINCL,<FLRTN+[EXP .TBINC,LDEC]> ; INCLUDED
	TB TXNO,FLDNO		; NO ...
	TB TXCBCI,LTCBCI	; TCBCI
	TB TXCBCO,LTCBCO	; TCBCO
	TB TXJFN,LTJFN		; TJFN
	TB TXJIBA,LTJIBA	; TJIBA
	TB TXJIBE,LTJIBE	; TJIBE
	TB TXJOBA,LTJOBA	; TJOBA
	TB TXJOBF,LTJOBF	; TJOBF
	TB TXPRS1,LTPRS1	; TPRS1
	TB TXPRS2,LTPRS2	; TPRS2
	TBEND

	CALL [MOVEI T3,TBERRK
	      JRST FRMIT0]
TBERRF:	FLDDB.(.CMKEY,,TBERRK,,,CMCFM)

	; ERROR-FIELDS keyword table
	TBBEG(TBERRK)
	TB TXALL,[377777777777]	; ALL
	TB TXDFLT,<FLDEF+[DFTERR]>  ; DEFAULT
	TB TXINCL,<FLRTN+[EXP .TBINC,LERR]> ; INCLUDED
	TB TXNO,FLDNO		; NO ...
	TB TXABTF,LTABTF	; TABTFX
	TB TXCABI,LTCABI	; TCABI
	TB TXCABR,LTCABR	; TCABR
	TB TXCERR,LTCERR	; TCERR
	TB TXCFAK,LTCFAK	; TCFAK
	TB TXCFWP,LTCFWP	; TCFWP
	TB TXCICM,LTCICM	; TCICM
	TB TXCIDU,LTCIDU	; TCIDU
	TB TXCIPB,LTCIPB	; TCIPB
	TB TXCIRD,LTCIRD	; TCIRD
	TB TXCISQ,LTCISQ	; TCISQ
	TB TXCITE,LTCITE	; TCITE
	TB TXCPCC,LTCPCC	; TCPCC
	TB TXCRST,LTCRST	; TCRST
	TB TXCSAG,LTCSAG	; TCSAG
	TB TXERR,LTERR		; TERR
	TB TXIFDF,LTIFDF	; TIFDF
	TB TXSTO,LTSTOE		; TSTO
	TB TXTOSC,LTTOSC	; TTOSC
	TB TXTOSD,LTTOSD	; TTOSD
	TB TXTOSR,LTTOSR	; TTOSR
	TB TXTOST,LTTOST	; TTOST
	TB TXTOSU,LTTOSU	; TTOSU
	TB TXTTL,LTTTL		; TTTL
	TBEND

	CALL [MOVEI T3,TBFLOK
	      JRST FRMIT0]
TBFLOF:	FLDDB.(.CMKEY,,TBFLOK,,,CMCFM)

	; FLOW-CONTROL-FIELDS keyword table
	TBBEG(TBFLOK)
	TB TXALL,[377777777777]	; ALL
	TB TXDFLT,<FLDEF+[DFTFLO]>  ; DEFAULT
	TB TXINCL,<FLRTN+[EXP .TBINC,LFLO]> ; INCLUDED
	TB TXNO,FLDNO		; NO ...
	TB TXCPZT,LTFPZT	; TCPZT
	TB TXCSQT,LTFSQT	; TCSQT
	TB TXSBYT,LTFBYT	; TSBYT
	TB TXSEPT,LTFEPT	; TSEPT
	TB TXSESB,LTSESB	; TSESB
	TB TXSMXB,LTSMXB	; TSMXB
	TB TXSPET,LTFPET	; TSPET
	TBEND

	CALL [MOVEI T3,TBIDFK
	      JRST FRMIT0]
TBIDFF:	FLDDB.(.CMKEY,,TBIDFK,,,CMCFM)

	; IDENTIFYING-FIELDS keyword table
	TBBEG(TBIDFK)
	TB TXALL,[377777777777]	; ALL
	TB TXDFLT,<FLDEF+[DFTIDF]>  ; DEFAULT
	TB TXINCL,<FLRTN+[EXP .TBINC,LIDF]> ; INCLUDED
	TB TXNO,FLDNO		; NO ...
	TB TXCBAD,LTCBAD	; TCBAD
	TB TXCBID,LTCBID	; TCBID
	TB TXFH,LTFH		; TFH
	TB TXFP,LTFP		; TFP
	TB TXJCN,LTJCNI		; TJCN
	TB TXLH,LTLH		; TLH
	TB TXLP,LTLP		; TLP
	TB TXOFRK,LTOFRK	; TOFRK
	TB TXOWNR,LTOWNR	; TOWNR
	TB TXSTAT,LTSTAT	; TSTAT
	TB TXVTL,LTVTL		; TVTL
	TBEND

	CALL [MOVEI T3,TBINTK
	      JRST FRMIT0]
TBINTF:	FLDDB.(.CMKEY,,TBINTK,,,CMCFM)

	; INTERRUPT-FIELDS keyword table
	TBBEG(TBINTK)
	TB TXALL,[377777777777]	; ALL
	TB TXDFLT,<FLDEF+[DFTINT]>  ; DEFAULT
	TB TXINCL,<FLRTN+[EXP .TBINC,LINTR]> ; INCLUDED
	TB TXNO,FLDNO		; NO ...
	TB TXCCIA,LTCCIA	; TCCIA
	TB TXCCIE,LTCCIE	; TCCIE
	TB TXCCIR,LTCCIR	; TCCIR
	TB TXCCIS,LTCCIS	; TCCIS
	TB TXCCIU,LTCCIU	; TCCIU
	TB TXCCIX,LTCCIX	; TCCIX
	TB TXPICA,LTPICA	; TPICA
	TB TXPICE,LTPICE	; TPICE
	TB TXPICR,LTPICR	; TPICR
	TB TXPICS,LTPICS	; TPICS
	TB TXPICU,LTPICU	; TPICU
	TB TXPICX,LTPICX	; TPICX
	TB TXPIFA,LTPIFA	; TPIFA
	TB TXPIFE,LTPIFE	; TPIFE
	TB TXPIFR,LTPIFR	; TPIFR
	TB TXPIFS,LTPIFS	; TPIFS
	TB TXPIFU,LTPIFU	; TPIFU
	TB TXPIFX,LTPIFX	; TPIFX
	TBEND

	CALL [MOVEI T3,TBOPTK
	      JRST FRMIT0]
TBOPTF:	FLDDB.(.CMKEY,,TBOPTK,,,CMCFM)

	; OPTION-FIELDS keyword table
	TBBEG(TBOPTK)
	TB TXALL,[377777777777]	; ALL
	TB TXDFLT,<FLDEF+[DFTOPT]>  ; DEFAULT
	TB TXINCL,<FLRTN+[EXP .TBINC,LOPT]> ; INCLUDED
	TB TXNO,FLDNO		; NO ...
	TB TXCBIO,LTCBIO	; TCBIO
	TB TXCBIR,LTCBIR	; TCBIR
	TB TXCBIU,LTCBIU	; TCBIU
	TB TXCBTO,LTCBTO	; TCBTO
	TB TXCBTR,LTCBTR	; TCBTR
	TB TXCBTU,LTCBTU	; TCBTU
	TB TXIOPF,LTIOPF	; TIOPF
	TB TXIPDO,LTIPDO	; TIPDO
	TB TXIPOR,LTIPOR	; TIPOR
	TB TXIPOU,LTIPOU	; TIPOU
	TB TXTOPF,LTTOPF	; TTOPF
	TB TXTPDO,LTTPDO	; TTPDO
	TB TXTPOR,LTTPOR	; TTPOR
	TB TXTPOU,LTTPOU	; TTPOU
	TBEND

	CALL [MOVEI T3,TBRSCK
	      JRST FRMIT0]
TBRSCF:	FLDDB.(.CMKEY,,TBRSCK,,,CMCFM)

	; R-S-COUNT-FIELDS keyword table
	TBBEG(TBRSCK)
	TB TXALL,[377777777777]	; ALL
	TB TXDFLT,<FLDEF+[DFTRSC]>  ; DEFAULT
	TB TXINCL,<FLRTN+[EXP .TBINC,LRSC]> ; INCLUDED
	TB TXNO,FLDNO		; NO ...
	TB TXCRCV,LTCRCV	; TCRCV
	TB TXCRPC,LTCRPC	; TCRPC
	TB TXCSND,LTCSND	; TCSND
	TB TXCSPC,LTCSPC	; TCSPC
	TBEND

	CALL [MOVEI T3,TBRCVK
	      JRST FRMIT0]
TBRCVF:	FLDDB.(.CMKEY,,TBRCVK,,,CMCFM)

	; RECEIVE-FIELDS keyword table
	TBBEG(TBRCVK)
	TB TXALL,[377777777777]	; ALL
	TB TXDFLT,<FLDEF+[DFTRCV]>  ; DEFAULT
	TB TXINCL,<FLRTN+[EXP .TBINC,LRCV]> ; INCLUDED
	TB TXNO,FLDNO		; NO ...
	TB TXBRBQ,LTRRBQ	; TCBRBQ
	TB TXBRPQ,LTRRPQ	; TCBRPQ
	TB TXCDUP,LTCDUP	; TCDUP
	TB TXCRMQ,LTCRMQ	; TCRMQ
	TB TXCRMW,LTCRMW	; TCRMW
	TB TXCTRA,LTRTRA	; TCTRA
	TB TXRCB,LTRCB		; TRCB
	TB TXRIS,LTRIS		; TRIS
	TB TXRLFT,LTRLFT	; TRLFT
	TB TXRURP,LTRURP	; TRURP
	TB TXRWND,LTRWND	; TRWND
	TBEND

	CALL [MOVEI T3,TBRXK
	      JRST FRMIT0]
TBRXF:	FLDDB.(.CMKEY,,TBRXK,,,CMCFM)

	; RETRANSMISSION-FIELDS keyword table
	TBBEG(TBRXK)
	TB TXALL,[377777777777]	; ALL
	TB TXDFLT,<FLDEF+[DFTRX]>  ; DEFAULT
	TB TXINCL,<FLRTN+[EXP .TBINC,LRX]> ; INCLUDED
	TB TXNO,FLDNO		; NO ...
	TB TXCRXF,LTCRXF	; TCRXF
	TB TXCRXP,LTCRXP	; TCRXP
	TB TXCTRX,LTXTRX	; TCTRX
	TB TXMNRT,LTMNRT	; TMNRT
	TB TXRXPD,LTRXPD	; TRXPD
	TB TXRXPI,LTRXPI	; TRXPI
	TB TXRXPN,LTRXPN	; TRXPN
	TB TXSMRT,LTSMRT	; TSMRT
	TB TXUNRT,LTUNRT	; TUNRT
	TBEND

	CALL [MOVEI T3,TBROUK
	      JRST FRMIT0]
TBROUF:	FLDDB.(.CMKEY,,TBROUK,,,CMCFM)

	; ROUTE-FIELDS keyword table
	TBBEG(TBROUK)
	TB TXALL,[377777777777]	; ALL
	TB TXDFLT,<FLDEF+[DFTROU]>  ; DEFAULT
	TB TXINCL,<FLRTN+[EXP .TBINC,LROU]> ; INCLUDED
	TB TXNO,FLDNO		; NO ...
	TB TXCRUT,LTCRUT	; TCRUT
	TB TXSFHO,LTSFHO	; TSFHOP
	TB TXSFHT,LTSFHT	; TSFHT
	TB TXSFHW,LTSFHW	; TSFHW
	TBEND

	CALL [MOVEI T3,TBSNDK
	      JRST FRMIT0]
TBSNDF:	FLDDB.(.CMKEY,,TBSNDK,,,CMCFM)

	; SEND-FIELDS keyword table
	TBBEG(TBSNDK)
	TB TXALL,[377777777777]	; ALL
	TB TXDFLT,<FLDEF+[DFTSND]>  ; DEFAULT
	TB TXINCL,<FLRTN+[EXP .TBINC,LSND]> ; INCLUDED
	TB TXNO,FLDNO		; NO ...
	TB TXBRXQ,LTSRXQ	; TCBRXQ
	TB TXBSBQ,LTSSBQ	; TCBSBQ
	TB TXCSMO,LTCSMO	; TCSMO
	TB TXCTPZ,LTSTPZ	; TCTPZ
	TB TXSBYT,LTSBYT	; TSBYT
	TB TXSCB,LTSCBS		; TSCB
	TB TXSCPK,LTSCPK	; TSCPK
	TB TXSEPT,LTSEPT	; TSEPT
	TB TXSIS,LTSIS		; TSIS
	TB TXSLBY,LTSLBY	; TSLBY
	TB TXSLFT,LTSLFT	; TSLFT
	TB TXSMXS,LTSMXS	; TSMXS
	TB TXSSEQ,LTSSEQ	; TSSEQ
	TB TXSTO,LTSTOS		; TSTO
	TB TXSURP,LTSURP	; TSURP
	TB TXSWND,LTSWND	; TSWND
	TBEND

	CALL [MOVEI T3,TBTIMK
	      JRST FRMIT0]
TBTIMF:	FLDDB.(.CMKEY,,TBTIMK,,,CMCFM)

	; TIME-FIELDS keyword table
	TBBEG(TBTIMK)
	TB TXALL,[377777777777]	; ALL
	TB TXDFLT,<FLDEF+[DFTTIM]>  ; DEFAULT
	TB TXINCL,<FLRTN+[EXP .TBINC,LTIM]> ; INCLUDED
	TB TXNO,FLDNO		; NO ...
	TB TXCATM,LTCATM	; TCATM
	TB TXCBTP,LTCBTP	; TCBTP
	TB TXCLTM,LTCLTM	; TCLTM
	TB TXCPZT,LTTPZT	; TCPZT
	TB TXCRTM,LTCRTM	; TCRTM
	TB TXCSQT,LTTSQT	; TCSQT
	TB TXCTDY,LTCTDY	; TCTDY
	TB TXCTPZ,LTTTPZ	; TCTPZ
	TB TXCTRA,LTTTRA	; TCTRA
	TB TXCTRX,LTTTRX	; TCTRX
	TB TXSEPT,LTTEPT	; TSEPT
	TB TXSPET,LTTPET	; TSPET
	TB TXSPRB,LTSPRB	; TSPRB
	TBEND


; Find TCP Header fields which should be listed

FRMITC:	MOVE TMP,[LOAD T1,OKKY,(T3)]
	MOVEI T2,TCPFDB		; Haven't yet seen NO
	CALL KEYINI
	RET



.OFTCP:	MOVEI T1,FTCP		; Address of flag word
	MOVX T2,TCPFDB		; Get field name or confirm
	CALLRET FRMXXX		; Parse & update


	CALL FRMITC		; Init instruction
TCPFDB:	FLDDB.(.CMKEY,,TCPKEY,,,CMCFM)

TCPKEY:	NTCP,,NTCP
	TXACK,,LPACK		; ACK
	TXACKS,,LPACKS		; ACK-SEQUENCE
	TXALL,,[377777777777]	; ALL
	TXCHKS,,LPTCKS		; CHECKSUM
	TXCNTL,,LPTCTL		; CONTROL
	TXDATO,,LPTDO		; DATA-OFFSET
	TXDFLT,,<FLDEF+[DFTCP]>	; DEFAULT
	TXDSTP,,LPDP		; DESTINATION-PORT
	TXESE,,LTESEQ		; END-SEQUENCE
	TXFIN,,LPFIN		; FIN
	TXNO,,FLDNO		; NO
	TXPUSH,,LPPSH		; PUSH
	TXREST,,LPRST		; RESET
	TXSNDR,,LTSNDR		; SEND-RIGHT
	TXSEQN,,LPSEQ		; SEQUENCE
	TXSOUP,,LPSP		; SOURCE-PORT
	TXSYN,,LPSYN		; SYN
	TXURG,,LPURGP		; URG-POINTER
	TXURGF,,LPURG		; URGENT
	TXWIND,,LPWNDO		; WINDOW
NTCP==.-TCPKEY-1


; Find UDP Header fields which should be listed

FRMIUD:	MOVE TMP,[LOAD T1,OKKY,(T3)]
	MOVEI T2,UDPFDB		; Haven't yet seen NO
	CALL KEYINI
	RET


.OFUDP:	MOVEI T1,FUDP		; Address of flag word
	MOVX T2,UDPFDB		; Get field name or confirm
	CALLRET FRMXXX		; Parse & update


	CALL FRMIUD		; Init keywords
UDPFDB:	FLDDB.(.CMKEY,,UDPKEY,,,CMCFM)

UDPKEY:	NUDP,,NUDP
	TXALL,,[377777777777]	; ALL
	TXCHKS,,LUDCKS		; CHECKSUM
;	TXDATA,,		; DATA-OCTETS
	TXDFLT,,<FLDEF+[DFUDP]>	; DEFAULT
	TXDSTP,,LUDDP		; DESTINATION-PORT
;	TXGARB,,		; GARBAGE-OCTETS
	TXLENO,,LUDLN		; LENGTH-OCTETS
	TXNO,,FLDNO		; NO
	TXSOUP,,LUDSP		; SOURCE-PORT
NUDP==.-UDPKEY-1


; Routine to process fields in a header

;	MOVEI T1,Fxxx		; Address of flag word
;	MOVX T2,[FLDDB.()]	; Address of parsing block
;	CALL FRMXXX		; Parse field names & update flag word

FRMXXX:	PUSH P,(T1)		; Initial flags
	PUSH P,T1		; Save flag word address
	PUSH P,T2		; FLDDB address
	MOVE T3,-1(T2)		; Init instruction
	PUSH P,T3
	JRST FRMXXZ

; The stack should look like this now:
;	return address from FRMXXX	-4(P)
;	original flags			-3(P)
;	address of flag variable	-2(P)
;	FLDDB address			-1(P)
;  P ->	init instruction		 0(P)

FRMXXY:	CALL .NO ;skips
FRMXXZ:	  XCT (P)		; Init NO
	MOVE T2,-1(P)		; Get field name or confirm
	CALL CCOMND
	CAIN T3,CMCFM		; Confirm?
	  JRST FRMXXW		; Yes
	HRRZ T2,(T2)		; Address of bit, or no, or default,
				; or routine
	TRZE T2,FLDEF		; Default?
	  SETZM -3(P)		; Forget initial flags
	TRZE T2,FLDNO		; "No"?
	  JRST FRMXXY		; Correct
	TRZN T2,FLRTN		; Routine to be called?
	IFSKP.
	  HRRZ T3,0(T2)		; Get the routine to be call
	  DMOVE T1,1(T2)	; Pickup ACs 1 and 2 for the routine
	  CALL (T3)		; Call the routine
	    JRST FRMXXV		; +1: Exit promptly, don't update flags
	    JRST FRMXXZ		; +2: Back for some more
	    NOP			; +3: Address of bit mask for field in T2
	ENDIF.

	MOVE T2,(T2)		; Bit corresponding to field
	TXNN F,F.NO		; "NO" prefix?
	  IORM T2,-3(P)		; Another YES
	TXZE F,F.NO		; "NO" prefix?
	  ANDCAM T2,-3(P)	; Another NO
	JRST FRMXXZ		; Back for more

; Exit with updating
FRMXXW:	POP P,(P)		; Drop init inst
	POP P,(P)		; Drop FLDDB address
	POP P,T1		; Address of flag variable
	POP P,(T1)		; Put the new flags there
	RET

; Exit without updating
FRMXXV:	ADJSP P,-4		; Drop the args
	RET
	SUBTTL FUNCTION Command

HFUNC:
 ASCIZ \The FUNCTION Command is used to specify which of the available
processing routines is to be applied to the data.\

HLIST:
 ASCIZ \The LIST Function (default) is used to list the contents of packet
samples from the data.  See also the FORMAT Command to specify the
format to be used.\

FUNINI:	MOVE TMP,[LOAD T1,OKKY,(T3)]
	MOVEI T2,FUNFDB		; Haven't yet seen NO
	CALLRET KEYINI

	HELPTX,,FUNHKY		; Help message & Keyword table
	CALL FUNINI		; Init instruction
FUNFDB:	FLDDB.(.CMKEY,,FUNKEY,,,)

FUNKEY:	NFUN,,NFUN
	TXDRVU,,.DRVU
	TXEXTR,,.EXTR
	TXHELP,,.HELP
	TXLIST,,.DOSAM
NFUN==.-FUNKEY-1


FUNHKY:	NFUNH,,NFUNH
	TXDRVU,,HDRVU
	TXEXTR,,HEXTR
	TXLIST,,HLIST
NFUNH==.-FUNHKY-1


.FUNC:	MOVEI T2,[FLDDB.(.CMNOI,CM%SDH,<POINT 7,[ASCIZ /to be applied to data is/]>)]
	CALL CCOMND

	MOVX T2,FUNFDB		; Get function keyword
	CALL CCOMND
	HRRZ FCT,(T2)		; Remember which function
	TXO FCT,<IFIW>		; Make indirect word
	MOVE T2,FCT
	SUBI T2,FCTCM.
	XCT @T2			; Function specific ending
;	CALL CCMCFM
ret
	MOVE T2,FUNCT		; Function vector
	SUBI T2,FCTGI.		; Grand initialization offset
	XCT @T2			; Initialize
	RET

	SUBTTL INPUT Command

INPNOI:	FLDDB.(.CMNOI,CM%SDH,<POINT 7,[ASCIZ /from file/]>,,,)

JFNFDB:	FLDDB.(.CMFIL,,,,,,)


.INPTF:	MOVX T2,INPNOI		; from file
	CALL CCOMND

	SETZ T1,
	EXCH T1,JFNT			; Is there a left-over JFN from an
	SKIPE T1			; Unconfirmed INPUT/OUTPUT?
	 RLJFN				; Yes, release it
	  JFCL

	MOVE T1,[[	GJ%OLD
			0
			0		; DEV
			0		; DIR
			0		; NAM
			[ASCIZ /BIN/]	; EXT
			0
			0
			0],,GJFN]
	BLT T1,GJFN+10		; Initialize GTJFN block

	MOVX T2,JFNFDB
	CALL CCOMND
	MOVE FCT,T2		; Save JFN
	MOVEM FCT,JFNT		; Trash JFN

	CALL CCMCFM

	CALL CLSRLF		; Close and release
	  IFIW JFNI		; Input file

	MOVEM FCT,JFNI		; Set new file
	SETZM JFNT		; No longer trash

	SETZM DFN		; Setup default output name
	HRROI T1,DFN
	MOVE T2,JFNI
	MOVX T3,<FLD(.JSAOF,JS%NAM)>
	MOVX T4,0
	JFNS
	IDPB T4,T1		; End string

	RET

	SUBTTL OUTPUT Command

OUTNOI:	FLDDB.(.CMNOI,CM%SDH,<POINT 7,[ASCIZ /to file/]>,,,)


.OTPTF:	MOVX T2,OUTNOI		; to file
	CALL CCOMND

	SETZ T1,
	EXCH T1,JFNT			; Is there a left-over JFN from an
	SKIPE T1			; Unconfirmed INPUT/OUTPUT?
	 RLJFN				; Yes, release it
	  JFCL

	MOVE T1,[[	GJ%FOU+GJ%SHT
			0
			0		; DEV
			0		; DIR
			0,,DFN		; NAM
			[ASCIZ /LST/]	; EXT
			0
			0
			0],,GJFN]
	BLT T1,GJFN+10		; Initialize GTJFN block

	MOVX T2,JFNFDB
	CALL CCOMND
	MOVE FCT,T2		; Save JFN
	MOVEM FCT,JFNT		; Save trash JFN

	CALL CCMCFM

	CALL CLSRLF		; Close and release
	  IFIW JFNO		; Output file

	MOVEM FCT,JFNO		; Set new file
	SETZM JFNT		; No longer trash
	RET


CLSRLF:	SETZ T1,
	MOVE CX,(P)		; Get the pointer to the JFN
	EXCH T1,@(CX)		; Prior JFN, if any
	JUMPE T1,CLSRLX		; Have old JFN? No
	GTSTS			; Is it open?
	TXNE T2,GS%OPN
	 CLOSF			; Yes, close and release it
	  RLJFN			; No, just release it
	   JFCL
CLSRLX:	AOS (P)			; Skip over argument
	RET

	SUBTTL	Top-level SHOW Command,  SHOW1 Subroutine

HTSHOW:	ASCIZ \The SHOW command displays the current FORMAT parameters
and FILTER expressions.\

SHONOI:	FLDDB.(.CMNOI,CM%SDH,<POINT 7,[ASCIZ /current parameter settings/]>,,,)


.SHOW:	MOVX T2,SHONOI
	CALL CCOMND
	CALL CCMCFM		; Confirm command
	MOVX T1,.PRIOU		; Info to primary output

; Enter here with T1 containing output designator

SHOW1:	
	SKIPG JFNI		; Know input file?
	IFSKP.			; Yes
	  SSOUT < Input >
	  MOVE T2,JFNI		; Input file
	  MOVX T3,<FLD(.JSAOF,JS%DEV)+FLD(.JSAOF,JS%DIR)+FLD(.JSAOF,JS%NAM)+FLD(.JSAOF,JS%TYP)+FLD(.JSAOF,JS%GEN)+JS%PAF>
	  JFNS%
	  SKIPG SKPCNT
	  IFSKP.
	    SSOUT <, Skipping >
	    MOVE T2,SKPCNT
	    XNOUT DECRAD
	    SSOUT < samples>
	  ENDIF.
	  CALL CRLF
	ENDIF.

	SKIPG JFNO		; Know output file?
	IFSKP.			; Yes
	  SSOUT <Output >
	  MOVE T2,JFNO
	  MOVX T3,<FLD(.JSAOF,JS%DEV)+FLD(.JSAOF,JS%DIR)+FLD(.JSAOF,JS%NAM)+FLD(.JSAOF,JS%TYP)+FLD(.JSAOF,JS%GEN)+JS%PAF>
	  JFNS%
	  CALL CRLF
	ENDIF.

	SSOUT <Function >
	HRRZ T4,FUNCT			; Function vector address
	HLLZ T2,FUNKEY			; #funct,,0
	MOVNS T2			; -#funct,,0
	DO.				; Search for function
	  HRRZ T3,FUNKEY+1(T2)		; Get possible function
	  CAME T3,T4			; Match?
	    AOBJN T2,TOP.		; No, back for next
	ENDDO.
	IFL. T2				; Find function?
	  HLRO T2,FUNKEY+1(T2)		; Yes, locate text block
	  ADDI T2,1			; Point to text
	ELSE.				; Not find function
	  HRROI T2,[ASCIZ /? unknown/]	; Complain
	ENDIF.
	SETZ T3,
	SOUT%
;cwl	ought to add function-dependent call here
	SSOUT <.
>

;list only?
	SSOUT <Format >
	HRROI T2,[ASCIZ /ASCII, /]
	TXNE F,F%TX
	  SOUT%
	HRROI T2,[ASCIZ /Binary, /]
	TXNE F,F%BIN
	  SOUT%
	HRROI T2,[ASCIZ /Core-dump, /]
	TXNE F,F%FCOR
	  SOUT%
	HRROI T2,[ASCIZ /No data, /]
	TXNE F,F%NDAT
	  SOUT%
	HRROI T2,[ASCIZ	/File-position, /]
	TXNE F,F%FILP
	  SOUT%
	HRROI T2,[ASCIZ	/Garbage, /]
	TXNE F,F%GB
	  SOUT%
	HRROI T2,[ASCIZ /Internal-leaders, /]
	TXNE F,F%INTL
	  SOUT%
	HRROI T2,[ASCIZ /Local-leaders, /]
	TXNE F,F%LLDR
	  SOUT%
	HRROI T2,[ASCIZ /Omitted count, /]
	TXNE F,F%OMIT
	  SOUT%
	HRROI T2,[ASCIZ /Pagination, /]
	TXNE F,F%PG
	  SOUT%
	HRROI T2,[ASCIZ /No Parity, /]
	TXNE F,F%NOPY
	  SOUT%

	MOVE T2,DATDLN
	CAIN T2,DMXDL
	IFSKP.
	  XNOUT DECRAD
	  SSOUT < Data octets, >
	ENDIF.
	HRROI T2,[ASCIZ /Long/]
	TXNE F,F%SF
	  HRROI T2,[ASCIZ /Short/]
	SOUT%
REPEAT 0,<
	HRROI T2,[ASCIZ/, Version /]
	MOVE T2,VERSUN
	XNOUT DECRAD
>
	CALL CRLF

; Find which header formats have been changed from the default

	TRZ F,TMPFLG
	MOVE T4,FINT
	CAME T4,[DFINT]
	  TRO F,1
	MOVE T4,FLN
	CAME T4,[DFLN]
	  TRO F,2
	MOVE T4,FIP
	CAME T4,[DFIP]
	  TRO F,4
	MOVE T4,FICMP
	CAME T4,[DFICMP]
	  TRO F,10
	MOVE T4,FTCP
	CAME T4,[DFTCP]
	  TRO F,20
	MOVE T4,FBFR
	CAME T4,[DBFR]
	  TRO F,40
	MOVE T4,FREG
	CAME T4,[DREG]
	  TRO F,100
	CALL ISTCBD		; Is the TCB format fields in the
				;  default state?
	  TRO F,200		; No
	TRNN F,377		; Any special formats?
	  JRST TOPSH2		; No

	SSOUT <       Custom header formats:>

	HRROI T2,[ASCIZ / Internal/]
	TRNE F,1
	  SOUT%
	HRROI T2,[ASCIZ / Local/]
	TRNE F,2
	  SOUT%
	HRROI T2,[ASCIZ / IP/]
	TRNE F,4
	  SOUT%
	HRROI T2,[ASCIZ / ICMP/]
	TRNE F,10
	  SOUT%
	HRROI T2,[ASCIZ / TCP/]
	TRNE F,20
	  SOUT%
	HRROI T2,[ASCIZ / Buffer-header/]
	TRNE F,40
	  SOUT%
	HRROI T2,[ASCIZ / Register/]
	TRNE F,100
	  SOUT%
	HRROI T2,[ASCIZ / TCB/]
	TRNE F,200
	  SOUT%

	CALL CRLF
TOPSH2:

	SKIPG T2,SKPCNT
	 SKIPLE WATCNT
	IFNSK.
	  IFG. T2
	    SSOUT <Skipping >
	    MOVE T2,SKPCNT
	    XNOUT DECRAD
	    SSOUT < >
	  ENDIF.
	  SKIPG WATCNT
	  IFSKP.
	    SSOUT <Waiting before sample >
	    MOVE T2,WATCNT
	    XNOUT DECRAD
	  ENDIF.
	  CALL CRLF
	ENDIF.

	MOVX FCT,ALADR
	HRROI T2,[ASCIZ /Filter /]
;	JRST SHOWA		; Join SHOW ALL to list filter


; T1/	Output designator
; T2/	String pointer to prefix
; FCT/	ALADR or expression #

SHOWA:	MOVN TI,FILTAB		; Get negative count of Expressions
	SKIPL TI		; Any at all?
	  JRST SHOWU		; No, FILTAB=0 means all packets listed
	HRLZS TI
	HRRI TI,FILTAB+1	; AOBJN pointer for all Expressions

	CAIN FCT,ALADR		; ALL ?
	IFSKP.
	  HRROI T2,[ASCIZ /? Invalid filter expression number./]
	  CAILE FCT,0
	   CAILE FCT,NFILTB
	    CAIA		; Number out of max possible range
	     CAMLE FCT,FILTAB	; or current legal range
	      JRST SHOWY	; Yes, error
	  HRROI TI,FILTAB(FCT)	; AOBJN pointer for single Expression
	  HRROI T2,[ASCIZ /       /]
	ENDIF.

	DO.			; Loop over requested Expressions
	  SKIPG TA,(TI)		; Point to Terms in Nth Expression
	  IFSKP.		; No more Expressions
	    DO.			; Loop over Terms in Expression
	      SKIPN T5,(TA)	; Get <Routine,,Ptr to list>
	        EXIT.		; No more Terms in this Expression
	      MOVE T4,(T5)
	      CALL SHOWT	; List Term
	      HRROI T2,[ASCIZ /  and  /]
	      AOJA TA,TOP.	; Back for next Term
	    ENDDO.
	    HRROI T2,[ASCIZ /or     /]
	  ENDIF.
	  AOBJN TI,TOP.		; Back for another Expression
	ENDDO.
	JRST SHOWX

; Common Exits

SHOWU:	SETZ T3,		; Print what's in T2
	SOUT%
	HRROI T2,[ASCIZ /All packets will be processed./]
SHOWY:	SETZ T3,		; Print what's in T2
	SOUT%
SHOWX:	CALL CRLF		; End the line
SHOWZ:	RET			; Return

; Print a filter Term

; T5 ->	Routine,,Term list
; T4/	-#,,NEGATE
; T2/	Pointer to header
; T1/	Output designator

SHOWT:	SETZ T3,		; Print header
	SOUT%

	HRROI T2,[ASCIZ /NOT /]
	TXNE T4,NEGATE		; Print NOT if NEGATE flag set
	  SOUT%

	HRR T4,T5		; -#,,LIST
	HLRZS T5		; Routine
	EXCH T4,T5		; T4/ Routine,  T5/ -#,,List

	HRRO T2,-1(T4)		; From TXXXXX in word before Routine
	SOUT%

	CAIE T4,TADRS		; TCB HOSTS-PORTS term? OR
	 CAIN T4,ADRS		; Host-Ports Term?
	  JRST SHOWW		; Yes, use custom printer, T5 has xx,,List

	PUSH P,1(T5)		; Mask is first word, followed by list

	MOVE T3,-2(T4)		; Name table,,RADIX, from 2nd word before
				;			Routine

	DO.			; Loop to print each Item in Term
	  PUSH P,T3		; Save <Keyword Table,,RADIX>
	  MOVX T2," "		; Space before next Item in Term
	  BOUT%

	  MOVE T2,2(T5)		; Value of next Item
	  TLNE T3,-1		; RADIX or <Keyword Table,,RADIX>?
	   CALL SHONAM		; Have Keyword Table, try lookup
	    NOUT%		; Print value if no name found
	     JFCL

	  POP P,T3		; Restore Keyword Table,,RADIX
	  AOBJN T5,TOP.		; Back for next Item
	ENDDO.

; Print MASK associated with Term

	SSOUT < /MASK:>

	POP P,T2		; Value of MASK
	XNOUT OCTRAD		; In octal?
	JRST SHOWX		; Go end line & return

; Try to find keyword corresponding to value in T2

; T2/	Value
; T3/	Keyword Table,,RADIX

SHONAM:	PUSH P,T1		; Save output designator

	HLRZ T1,T3
	HRRZS T3		; RADIX in case no name found
	PUSH P,T3		; Save RADIX
	MOVN T3,(T1)
	HRRI T3,(T1)		; -(#+1),, Pointer
	AOBJN T3,.+2		; -#,,Pointer to first
	IFSKP.
	  DO.
	    MOVE T1,(T3)	; TXXXXX,,Value
	    CAIE T2,(T1)	; Match ?
	      AOBJN T3,TOP.	; No, keep looking
	    JUMPGE T3,ENDLP.	; No name, print #

	    HLRO T2,T1		; -1,,TXXXXX
	    ADDI T2,1		; -1,,TXXXXX+1
	    MOVE T1,-1(P)	; Output designator
	    SETZ T3,
	    SOUT%		; Print name instead of value
	    AOS -2(P)		; Skip return over NOUT
	  ENDDO.
	ENDIF.
	POP P,T3
	POP P,T1
	RET

; Display an address term
;     HOSTS-PORTS Foreign x.x.x.x x.x Local x.x.x.x x.x
;         /Masks: xxx.xxx.xxx.xxx xxx.xxx    xxx.xxx.xxx.xxx xxx.xxx

; T1/	Output designator
; T5/	xx,,List

SHOWW:	SSOUT < Foreign >

	MOVE T2,1(T5)
	MOVE T3,3(T5)
	CALL HNO2NA		; Output foreign address/port

	SSOUT < Local >

	MOVE T2,5(T5)
	MOVE T3,7(T5)
	CALL HNO2NA		; Output local address/port

	CALL CRLF		; Begin line for masks

	SSOUT <           /Masks: >

	MOVE T2,2(T5)
	MOVE T3,4(T5)
	CALL HNO2NA		; Output foreign adr/prt masks

	SSOUT <    >

	MOVE T2,6(T5)
	MOVE T3,10(T5)
	CALL HNO2NA		; Output local adr/prt masks

	JRST SHOWX		; End line & return

	SUBTTL SKIP Command

HSKIP:	ASCIZ /SKIP specified how many samples should be skipped before
beginning to list./

SKPNOI:	FLDDB.(.CMNOI,CM%SDH,<POINT 7,[ASCIZ /over/]>,,,)
SKPFDB:	FLDDB.(.CMNUM,,DECRAD)
SKPNOJ:	FLDDB.(.CMNOI,CM%SDH,<POINT 7,[ASCIZ /samples/]>,,,)


.SKIPC:	MOVX T2,SKPNOI		; Noise
	CALL CCOMND

	MOVX T2,SKPFDB		; Value
	CALL CCOMND
	MOVEM T2,FCT

	MOVX T2,SKPNOJ		; Noise
	CALL CCOMND

	CALL CCMCFM		; Confirm

	MOVEM FCT,SKPCNT	; Set count
	RET

	SUBTTL TAKE Command
HTAKE:	ASCIZ /TAKE commands from command file./
TAKNOI:	FLDDB.(.CMNOI,CM%SDH,<POINT 7,[ASCIZ/Commands from File/]>,,,)
TAKFDB:	FLDDB.(.CMCFM,CM%SDH,,,,JFNFDB)

.TAKE:	MOVX T2,TAKNOI		; Noise
	CALL CCOMND

	SETZ T1,
	EXCH T1,JFNT		; Is there a left-over JFN from an
	SKIPE T1		; Unconfirmed TAKE?
	 RLJFN			; Yes, release it
	  JFCL

	MOVE T1,[[	GJ%OLD
			0
			0	; DEV
			0	; DIR
			0	; NAM
			-1,,[ASCIZ /CMD/]  ; EXT
			0
			0
			0],,GJFN]
	BLT T1,GJFN+10		; Initialize GTJFN block

	MOVX T2,TAKFDB		; Confirm or file spec
	CALL CCOMND
	CAIE T3,TAKFDB		; Confirm?
	IFSKP.			; Yes
	  SKIPG TAKLVL		; In a TAKE file?
	    RET			; No, this is a NOP
	  JRST CMDXIT		; Yes, exit the TAKE file
	ENDIF.
	MOVE FCT,T2		; Save JFN
	MOVEM FCT,JFNT		; Trash JFN

	CALL CCMCFM

	SETZM JFNT		; No longer a trash JFN

	ADJSP P,<.CMGJB+1>	; Save the COMND state block
	MOVEI T1,-.CMGJB(P)	; Get destination address
	HRLI T1,CMD		; Get source COMND state block address
	BLT T1,(P)		; Save it

	PUSH P,CMDIOJ		; Save Input/Output JFNs
	PUSH P,TAKJFN		; Save current TAKE JFN
	MOVEM FCT,TAKJFN	; Set the new TAKE JFN
	AOS TAKLVL		; Increment the TAKE level of nesting

	MOVE T1,TAKJFN		; Get the TAKE JFN
	MOVX T2,<FLD(7,OF%BSZ)!OF%RD>  ; Read 7 bit bytes
	OPENF%			; Open the file
	IFJER.
	  MOVX T1,.PRIOU	; To primary output
	  SETZ T3,
	  HRROI T2,[ASCIZ/
?Error OPENFing TAKE file "/]
	  SOUT
	  MOVE T2,TAKJFN
	  JFNS
	  HRROI T2,[ASCIZ/" - /]
	  SOUT
	  HRLOI T2,.FHSLF	; This fork,,most recent
	  ERSTR			; Error string
	    JFCL
	    JFCL
	  CALL CRLF		; Next line
	  JRST TAKXIT		; Quit out of here
	ENDIF.

	; Reenter top-level parse for TAKE command
	HRL T1,TAKJFN		; Set I/O JFNs for COMND
	HRRI T1,.NULIO
	MOVEM T1,CMDIOJ
	MOVX T2,TOPLVL		; Parse top-level commands
	MOVX T3,<POINT 7,[ASCIZ//]>  ; Set prompt to null
	CALL PARSE

TAKDON:	; All done with this take file
	MOVX T1,.PRIOU		; To primary output
	SETZ T3,
	HRROI T2,[ASCIZ/ End of /]  ; A little message
	SOUT
	MOVE T2,TAKJFN		; Which file
	JFNS
	CALL CRLF
TAKXIT:	; Exit from this take file
	CALL CLSRLF		; Close/Release Take JFN
	 IFIW TAKJFN

	POP P,TAKJFN		; Restore old TAKE JFN
	POP P,CMDIOJ		; Restore old Input/Output JFNs
	SOS TAKLVL		; Decrement the TAKE level of nesting

	MOVSI T1,-.CMGJB(P)	; Restore the COMND state block, source address
	HRRI T1,CMD		; Get destination COMD state block address
	BLT T1,CMD+.CMGJB	; Restore it
	ADJSP P,-<.CMGJB+1>
	
	RET

	SUBTTL WAIT Command

HWAIT:	ASCIZ /Wait before listing the specified sample number./

WATNOI:	FLDDB.(.CMNOI,CM%SDH,<POINT 7,[ASCIZ /before sample/]>,,,)
WATFDB:	FLDDB.(.CMNUM,,DECRAD)


.WAIT:	MOVX T2,WATNOI		; Noise
	CALL CCOMND

	MOVX T2,WATFDB		; Value
	CALL CCOMND
	MOVEM T2,FCT

	CALL CCMCFM		; Confirm

	MOVEM FCT,WATCNT	; Set count
	RET

; Routine called when specified sample has been read (into NPACKET)


ATWAIT:	ADJSP P,20		; Be safe
	DMOVEM <P-1>,-1(P)	; Save CX,P
	HRRZI <P-1>,-17(P)
	BLT <P-1>,(P)

	MOVX T2,WATLVL
	MOVX T3,<POINT 7,[ASCIZ /Waiting:/]>
	CALL PARSE

	HRLZI 0,-17(P)
	BLT 0,P
	ADJSP P,-20
	RET

	SUBTTL	WAIT Subcommands -- CONTINUE

	HELPTX,,WHLPKEY		; Parallel HELP keywords
	JFCL			; Reparse instruction
WATLVL:	FLDDB.(.CMKEY,,WATKEY)	; First parameter is keyword

WATKEY:	WNTOP,,WNTOP		; Table of parameter keywords
	TXCONT,,.CONT		;  CONTINUE
	TXHELP,,.HELP		;  HELP
	TXWAIT,,.WAIT		;  WAIT
WNTOP==.-WATKEY-1


WHLPKEY:WNHLP,,WNHLP		; Table size
	TXCONT,,HCONT		;  CONTINUE
	TXWAIT,,HWAIT		;  WAIT
WNHLP==.-WHLPKEY-1



HCONT:	ASCIZ /The CONTINUE command resumes processing./

CONNOI:	FLDDB.	(.CMNOI,CM%SDH,<POINT 7,[ASCIZ /processing data/]>,,,)


.CONT:	MOVX T2,CONNOI		; (processing data)
	CALL CCOMND
	CALL CCMCFM		; Confirm parameter
	JRST CMDXIT		; Out


	SUBTTL Interrupt Routines

CTGINT:	DMOVEM 16,PI3AC+16	; Save 16 & 17
	MOVX 16,<0,,PI3AC>
	BLT 16,PI3AC+15		; and the rest

	HRROI T1,[ASCIZ /
Control-G typed/]
	PSOUT			; Say what is happening

	MOVX T1,<PC%USR+STOP>
	MOVEM T1,RETPC3		; Break out
	JRST L3DBRK


CTTINT:	DMOVEM 16,PI3AC+16	; Save 16 & 17
	MOVX 16,<0,,PI3AC>
	BLT 16,PI3AC+15		; and the rest

	HRROI T1,[ASCIZ /
/]
	CALL STATMG		; Output status message

L3DBRK:	MOVX 17,<PI3AC,,0>
	BLT 17,17		; Restore all registers
	DEBRK			; Leave


; Routine to output status message

; T1/	HRROI T1,[ASCIZ /.../]
;	CALL STATMG


STATMG:	PSOUT%

	SETO T4,		; No position
	SKIPG T1,JFNI		; Input file
	IFSKP.
	  SIZEF%		; Get file length, bytes
	    ANSKP.		; Error
	  MOVE T3,T2		; Assume byte sizes are the same
	  RFPTR%		; Get current position
	    ANSKP.		; Error
	  IMULI T2,^D100	; For %
	  IDIV T2,T3		; Have it
	  MOVE T4,T2		; Save it
	ENDIF.

	MOVX T1,.PRIOU
	MOVE T2,NPKTN
	XNOUT DECRAD
	SSOUT < samples read, >
	SKIPG T2,HDRCNT
	IFSKP.
	  XNOUT DECRAD
	  SSOUT < headers, >
	ENDIF.
	MOVE T2,SMPCNT
	XNOUT DECRAD
	SSOUT < samples processed.>
	SKIPGE T4		; Have %age?
	  CALLRET CRLF		; No
	SSOUT < Input file >
	MOVE T2,T4
	XNOUT DECRAD
	SSOUT <% processed.
>
	RET

LITS0:	LIT

	SUBTTL Initialization

START:	RESET%
	SETZM EXECFH		; RESET kills any inferior forks
	SETZM TAKJFN		; Clear TAKE JFN
	SETZM TAKLVL		; And TAKE level
	MOVX T1,<.PRIIN,,.PRIOU>  ; Set the default COMND I/O JFNs
	MOVEM T1,CMDIOJ

	MOVE P,PDLP		; Reset stack
	SKIPN PTVSRT
	  CALL SRTPTV		; Sort PTVALS if it hasn't yet been done

	SETZ F,			; Start with all flags cleared

	MOVX T1,.FHSLF
	MOVE T2,[LEVTAB,,CHNTAB]
	SIR%			; Setup interrupt control tables
	EIR%			; Turn interrupts on

	GREET	\VMAJOR,\VMINOR,\VEDIT ; Give program id
	PSOUT%
	JRST RENTR



NOFILE:	SETZ T3,		; File missing, error message
	MOVX T1,.PRIOU
	SOUT%
RENTR:	MOVE P,PDLP		; Reset stack

	MOVX T1,.FHSLF
	MOVX T2,<1B<CGICHN>+1B<CTICHN>>
	DIC%			; Deactivate channels
	MOVX T1,<.TICCG>	; Deassign
	DTI%			; ^G to stop
	MOVX T1,<.TICCT>	; Deassign
	DTI%			; ^T to check progress

	SETZM SKPCNT		; Assume start at beginning
	MOVX T2,TOPLVL		; Top-level parameters and the prompt
	MOVX T3,<POINT 7,[ASCIZ /Parameters:/]>
	CALL PARSE		; Process Parameters
				; GO command returns here

	MOVX T1,<.TICCG,,CGICHN>  ; Assign
	ATI%			; ^G to stop
	MOVX T1,<.TICCT,,CTICHN>  ; Assign
	ATI%			; ^T to check progress
	MOVX T1,.FHSLF
	MOVX T2,<1B<CGICHN>+1B<CTICHN>>
	AIC%			; Activate channels

	TXZ F,F%EOF		; Haven't seen end
	HRROI T2,[ASCIZ /? An INPUT file must be specified.
/]
	MOVE T1,JFNI		; Input JFN
	JUMPE T1,NOFILE
	GTSTS%
	TXNE T2,GS%OPN		; Input file open?
	IFSKP.			; No
	  MOVX T2,<FLD(^D36,OF%BSZ)+OF%RD>
	  TXNE F,F%FCOR		; ASCII or Binary?
	    MOVX T2,<FLD(^D7,OF%BSZ)+OF%RD>
	  OPENF%
	    CALL ERROR1
	ENDIF.

	HRROI T2,[ASCIZ /? An OUTPUT file must be specified.
/]
	MOVE T1,JFNO		; Output JFN
	JUMPE T1,NOFILE
	GTSTS%
	TXNE T2,GS%OPN		; Output file open?
	IFSKP.			; No
	  MOVE T2,FUNCT		; Function vector
	  MOVE T2,-FCTOF.(T2)	; Get output file size, etc.
	  OPENF%
	    CALL ERROR1
	ENDIF.
				; Build page heading
	HRROI T1,OTITLE
	HRROI T2,PAGHED		; Initial text
	SETZ T3,
	SOUT%
	PUSH P,T1

	MOVX T1,.GTHSZ		; Get local host address
	GTHST%
	  CALL ERROR1
	MOVE T3,T4
	POP P,T2
	MOVX T1,.GTHNS		; Append local host name
	GTHST%
	  CALL ERROR1
	MOVE T1,T2
	MOVX T2,"]"
	BOUT%

	MOVE T2,JFNO
	MOVX T3,<FLD(.JSAOF,JS%DEV)+FLD(.JSAOF,JS%DIR)+FLD(.JSAOF,JS%NAM)+FLD(.JSAOF,JS%TYP)+FLD(.JSAOF,JS%GEN)+JS%PAF>
	JFNS%			; Append output file name

	SSOUT <
Dump of >

	MOVE T2,JFNI
	MOVX T3,<FLD(.JSAOF,JS%DEV)+FLD(.JSAOF,JS%DIR)+FLD(.JSAOF,JS%NAM)+FLD(.JSAOF,JS%TYP)+FLD(.JSAOF,JS%GEN)+JS%SIZ+JS%LWR+JS%PSD+JS%PAF>
	JFNS%			; Append input file name

	CALL CRLF

	SETZM OLDTIM		; Initialize variables
	SETZM NPKTN
	SETZM PKTN
	SETZM FILBYT

	SETZM LOSTLN
	SETZM LOSTOT
	SETZM SMPCNT

	SETZM PAGCNT		; LIST only?
	SETZM PAGE
	SETZM HDRCNT

	CALL STATIN		; Initialize statistics area

	MOVE T2,FUNCT		; Function vector
	SUBI T2,FCTPR.		; Initialization offset
	XCT @T2			; Initialize

	SUBTTL Main Loop, Read in next Sample

; Loop here to read

LOOP0:	SETZM NPKTN+1		; Clear out previous data
	MOVX T2,<NPKTN+1,,NPKTN+2>
	BLT T2,NPACKET+MAXPKT-1
	TXO F,F%0PKT	

; Loop here after printing PACKET, to copy NPACKET to PACKET and read another

LOOP:	MOVX T2,<NPKTN,,PKTN>	; Copy pre-read New PACKET
	BLT T2,PACKET+MAXPKT-1 	; Into PACKET
	TXZ F,F%NIP		; And NNIP flag into NIP
	TXZE F,F%NNIP
	  TXO F,F%NIP

; Loop here to drop last sample read

LOOP1:	LOAD T1,DAUXI,+PPKT+NPACKET-PACKET
	JUMPE T1,NOLOST
	ADDM T1,LOSTLN
	HRLI T1,1
	ADDM T1,LOSTOT		; Lost samples
	MOVE T1,NPKTN
	HRLM T1,LOSTLN
NOLOST:
	TXNE F,F%EOF		; Read last entry?
	  JRST EOF		; Yes, all done

	AOS NPKTN		; Count samples

	SETZM NPTDTA		; Clear for read ahead
	MOVX T2,<NPTDTA,,NPTDTA+1>
	BLT T2,NPACKET+MAXPKT-1

	TXZ F,<F%NNIP+F%CORD>

	TXNN F,F%FCOR		; Core format?
	  JRST LOOP2		; No

; From ASCII core dump

	CALL AINPUT		; Get address/ <words to follow,,garbage>
	MOVEM T4,CORADR		; Address
	MOVEM T2,NPACKET-1	; Data

	HLLZ T5,T2		; N,,0

	HLRZS T2		; N
	MOVEM T2,DMPLTH		; ???
	CAILE T2,0		; UNREASONABLE OR
	 CAIL T2,MAXPKT-LCLPKT	; OVERFLOW BUFFER?
	  CALL BAD		; YES, BAD LENGTH, QUIT

	MOVNS T5		; -N,,0
	HRRI T5,NPACKET		; -N,,NPACKET

ASIN:	CALL AINPUT		; Get info
	MOVEM T2,(T5)		; Into new packet
	AOBJN T5,ASIN		; Get rest

	TXO F,F%CORD		; Assume not a packet
	LOAD T1,PIVER,<+NPACKET>
	CAIE T1,4		; Look like it might be a packet?
	  JRST LOOP5		; No, list core block

	TXZ F,F%CORD		; Looks like an IP packet

	MOVE T1,CORADR
	ADDI T1,1
	STOR T1,DPKTP,<+PPKT+NPACKET-PACKET> ; Packet buffer address

	MOVE T4,DMPLTH
	STOR T4,DLENW,+PPKT+NPACKET-PACKET
	SUBI T4,PKTELI
	LSH T4,2
	MOVEM T4,NTPBZ		; # bytes in sample

	JRST LOOP2E		; Go filter packet

; Have core block in NPACKET (from ASIN)

LOOP5:	CALL @FUNCT		; List contents of PACKET

	MOVX T2,<NPKTN,,PKTN>	; Copy NPACKET to PACKET
	BLT T2,PACKET+MAXPKT-1
	TXZ F,F%NIP		; Copy NNIP to NIP
	TXZE F,F%NNIP
	  TXO F,F%NIP

	CALL PP			; Header line for core block
	CALL DMPCOR		; Dump core block
	JRST LOOP0		; Back with empty NPACKET/PACKET

; From binary packet tracer

LOOP2:	MOVE T1,JFNI
	BIN			; Read dump length (LH not 0)
	ERJMP [ TXO F,F%EOF	; Seen EOF
		JRST LOOP4]	; Get last dumped

	MOVE T4,FILBYT		; Position of this sample in input file
	MOVEM T4,NFLBYT
	HRRZ T4,T2		; Sample length
	ADDM T4,FILBYT		; Position of next sample
	SKIPL T3,VERSUN		; Input trace version number
	 CAILE T3,VMINOR	; Keep JRST below legal
	  CALL BAD		; Bad version number
	CAIL T4,2		; Range check sample length
	 CAIL T4,MAXPKT
	  CAIA			; Too short or long, complain
	   ; Dispatch on version number
	   JRST @[IFIW .+1	; Version 0, not supported
		  IFIW .+1	; Version 1, ditto
		  IFIW VER2	; Version 2 and beyond
		](T3)		; Go read input

	CALL .+1		; Fake CALL BAD
	PUSH P,T2		; Bad length

;	RFPTR
;	  CALL ERROR1
;	SUBI T2,1		; Correct for BIN
;	SUB T2,NPTDTA		; Position of last read
	MOVE T2,NFLBYT
	JRST BAD2

; Version 2 format

VER2:	MOVEM T2,NPTDTA+$DLENW	; Save first word of trace info
	MOVNI T4,-1(T2)		; Negative remaining count

	MOVX T3,<-PPPKTO+1>	; Negative remaining trace info words
	CAMGE T3,T4		; Have all trace info in sample?
	  MOVE T3,T4		; No, just read what is there
	SUB T4,T3		; Negative packet data words

	MOVX T2,<POINT 36,NPTDTA+1> ;+$DLENW
	SIN			; Read rest of trace info
	ERCAL EOF

	LOAD T3,DPTRC,+PPKT+NPACKET-PACKET ; (New) trace code & flags
	TXNE T3,PT%%VI+PT%%VN+PT%%NT	; Packet sample?
	  TXO  T3,PT%%VI	; Single new flag
	STOR T3,DPTRC,+PPKT+NPACKET-PACKET ; (New) trace code & flags
	TXO F,F%NNIP		; Assume not a high level sample

	MOVX T5,PKTELI		; Assume Buffer/Register/TCB sample
				; (data loaded at PKTELI so cruncher works)
	TXNN T3,PT%%VI		; Packet sample?
	IFSKP.			; Yes
	  SETZ T5,		; Full packet sample
	  TXNN T3,PT%%NT	; Abbreviated driver packet sample?
	  IFSKP.		; No, full high level packet sample
	    MOVX T5,SAMPKT	; Abbreviated samples begin at SAMPKT unless
	    SKIPGE $DPKTP+NPTDTA ; Check for canned local leader
	      MOVX T5,LCLPKT	; Canned abbreviated samples begin at LCLPKT
	    LOAD T3,DSTAT,+NPTDTA ; Move flags to proper position
	    MOVEM T3,PKTFLG+NPACKET
	    SETZRO DSTAT,+NPTDTA ; No high level flags here
	  ENDIF.  		;		     NNIP=0, T5/SAMPKT,LCLPKT
	  TXZ F,F%NNIP		; High level sample  NNIP=0, T5/0
	ENDIF.			; 		     NNIP=1, T5/PKTELI
	LOAD T3,DTYPE,+NPTDTA	; Get the sample type
	CAIE T3,ND.TCB		; TCB?
	IFSKP.			; Yes, add in the starting offset
	  LOAD T3,DTCBO,+NPTDTA	; Get the starting offset
	  ADD T5,T3		; Add it into the sample dependent offset
	ENDIF.
	MOVX T2,<POINT 36,NPACKET> ; Base position for data
	ADD T2,T5		; Offset depending on what is in sample
	SKIPGE T3,T4		; Negative remaining count
	  SIN			; Read packet data
	ERCAL EOF

	MOVE T3,T5		; Find number of
	SUBI T3,PKTELI		; Words before PKTELI
	ASH T3,2		; Octets before PKTELI
	MOVEM T3,NLDOCT		; Save it

	MOVNS T4		; # words beginning at NPACKET/SAMPKT/LCLPKT
	LSH T4,2		; # IP octets sampled

	LOAD T2,DPTRC,+PPKT+NPACKET-PACKET ; (New) trace code & flags
	TXNN T2,PT%%VI
	 TDZA T3,T3		; Not packet sample
	  SUBI T4,4		; Packet sample (guard word)
	ADD T4,T3		; Words skipped (T3 is .le. 0)
	MOVEM T4,NTPBZ		; Save it

	JRST LOOP2E

REPEAT 0,<

; Version 1 format

VER1:	MOVEM T2,NPTDTA		; Save first word of trace info
	MOVNI T4,-1(T2)		; Negative remaining count
	HRRZS T2		; Just size
	CAIL T2,MAXPKT		; Reasonable count?
	  CALL BAD		; No, stop

	MOVX T3,<-PPPKTO+1>	; Negative remaining trace info words
	CAMGE T3,T4		; Have all trace info in sample?
	  MOVE T3,T4		; No, just read what is there
	SUB T4,T3		; Negative packet data words

	MOVX T2,<POINT 36,NPTDTA+1>
	SIN			; Read rest of trace info
	ERCAL EOF

	MOVX T2,<POINT 36,NPACKET>
	TXO F,F%NNIP		; Assume local net packet sample
	LOAD T3,DPTRC,+PPKT+NPACKET-PACKET ; (New) trace code & flags
	TXNE T3,PT%%VI+PT%%VN	; Packet sample?
	 TXNN T3,PT%%NT		; Local sample?
	 TXZA F,F%NNIP		; Not local packet sample
	  ADDI T2,SAMPKT	; Yes, point to local leader position
;	  CALL FIX1
	SKIPGE T3,T4		; Negative remaining count
	  SIN			; Read packet data
	ERCAL EOF

	MOVNS T4		; # words beginning at NPACKET/SAMPKT
	LOAD T3,DPTRC,+PPKT+NPACKET-PACKET ; (New) trace code & flags
IFO 7,<
	CAIL T3,PT%XX0
	 CAILE T3,PT%XX8
	  TRNA
	   TDO T3,[PT%%SY+PT%%TC+PT%%VH+PT%%VP+PT%%VI ;0
		   PT%%SY+PT%%OU+PT%%TC+PT%%VH+PT%%VP+PT%%VI ;1
		   PT%%SY+PT%%OU+PT%%TC+PT%%VH+PT%%VP+PT%%VI ;2
		   PT%%SY+PT%%IN+PT%%TC+PT%%VH+PT%%VP+PT%%VI ;3
		   PT%%SY+PT%%IN+PT%%TC+PT%%VH+PT%%VP+PT%%VI ;4
		   PT%%SY+PT%%IN+PT%%TC+PT%%VH+PT%%VP+PT%%VI ;5
		   PT%%SY+PT%%IN+PT%%TC+PT%%VH+PT%%VP+PT%%VI ;6
		   PT%%SY+PT%%OU+PT%%TC+PT%%VH+PT%%VP+PT%%VI ;7
		   PT%%SY+PT%%OU+PT%%TC+PT%%VH+PT%%VP+PT%%VI ;8
			](T3)
>
	STOR T3,DPTRC,+PPKT+NPACKET-PACKET ; (New) trace code & flags
	TXNN T3,PT%%VI+PT%%VN
	  JRST VER1L
	SUBI T4,PKTELI+1	; Host-to-Host words if IP sample (guard word)
	TXNE F,F%NNIP		; Local net sample?
	  ADDI T4,SAMPKT	; Yes, a few words not saved
VER1L:	LSH T4,2		; # IP octets sampled
	MOVEM T4,NTPBZ		; Save it

	JRST LOOP2E

; Version 0 format

VER0:	HLRZ T3,T2		; Trace code
IFO 7,<
	CAIL T3,PT%XX0
	 CAILE T3,PT%XX8
	  TRNA
	   TDO T3,[PT%%SY+PT%%TC+PT%%VH+PT%%VP+PT%%VI ;0
		   PT%%SY+PT%%OU+PT%%TC+PT%%VH+PT%%VP+PT%%VI ;1
		   PT%%SY+PT%%OU+PT%%TC+PT%%VH+PT%%VP+PT%%VI ;2
		   PT%%SY+PT%%IN+PT%%TC+PT%%VH+PT%%VP+PT%%VI ;3
		   PT%%SY+PT%%IN+PT%%TC+PT%%VH+PT%%VP+PT%%VI ;4
		   PT%%SY+PT%%IN+PT%%TC+PT%%VH+PT%%VP+PT%%VI ;5
		   PT%%SY+PT%%IN+PT%%TC+PT%%VH+PT%%VP+PT%%VI ;6
		   PT%%SY+PT%%OU+PT%%TC+PT%%VH+PT%%VP+PT%%VI ;7
		   PT%%SY+PT%%OU+PT%%TC+PT%%VH+PT%%VP+PT%%VI ;8
			](T3)
>
	STOR T3,DPTRC,+PPKT+NPACKET-PACKET ; (New) trace code & flags
	HRRZS T2		; Drop left half to get
	STOR T2,DLENW,+PPKT+NPACKET-PACKET ; Sample length

	CAME T2,IPTRSZ		; IP packet printer size
	  JRST [AOS NPACKET+LCLPKT ; Not IP format, must be IMP
		BIN		; GTAD
		  ERCAL EOF	;   IMP format:	n
		STOR T2,PTS,<+NPACKET> ;		GTAD
		MOVE T2,NPACKET+LCLPKT ;		n words @LCLPKT+1
		TXO F,F%NNIP
		JRST .+1]	;    IP format:	n words @LCLPKT

	CAILE T2,0		; Unreasonable or
	 CAIL T2,MAXPKT-LCLPKT	; Overflow buffer?
	  CALL BAD		; Yes, bad length, quit

	MOVNI T3,-1(T2)		; Minus exact count
	MOVX T2,<POINT 36,NPACKET+LCLPKT+1>
	SIN			; Read rest of packet
	  ERCAL EOF

	MOVX T2,PTDTAO		; Virtual words sampled
	MOVEM T2,NPACKET+LCLPKT	; Local leader length word
	MOVX T2,<<PTDTAO-4>*4>	; Virtual octets
	MOVEM T2,NTPBZ

	MOVEI T3,NPACKET+14+PTDTAO ; Trace info (14 is old PKTELI)

	SETZ T2,
	EXCH T2,(T3)
	STOR T2,DFLAG,+PPKT+NPACKET-PACKET

	SETZ T2,
	EXCH T2,1(T3)
	STOR T2,DDS,+PPKT+NPACKET-PACKET
	MOVSS T2
	STOR T2,DSS,+PPKT+NPACKET-PACKET

	SETZ T2,
	EXCH T2,2(T3)
	LOAD T4,DTIME,+PPKT+NPACKET-PACKET
	CAIGE T2,(T4)
	  ADD T4,[1,,0]
	HRR T4,T2
	STOR T4,DTIME,+PPKT+NPACKET-PACKET

	SETZ T2,
	EXCH T2,3(T3)
	HRRI T2,6
	MOVSS T2
	STOR T2,DPKTP,+PPKT+NPACKET-PACKET

	SETZ T2,
	STOR T2,DAUXI,+PPKT+NPACKET-PACKET

> ; End REPEAT 0



LOOP2E:
	MOVE T2,NPKTN			; Number of sample just read
	CAMN T2,WATCNT			; Want to pause here?
	  CALL ATWAIT			; Yes


;?	LOAD T4,DPTRC,+PPKT+NPACKET-PACKET ; (New) trace code & flags
;?	TXNE T4,PT%%VI+PT%%VN
	  CALL STATIS		; Collect statistics info


	SOSL SKPCNT		; Skip this sample?
	  JRST LOOP1		; Yes

	SUBTTL	Packet Filtering

FILTER:	SKIPG FILTAB		; If no filter expressions, then
	  JRST LOOP4		; List sample

	PUSH P,TI		; Save registers
	PUSH P,TA

	SETZ TI,		; Begin with first Expression
FILTEN:	AOS TI			; Index of next Expression
	MOVE TA,FILTAB(TI)	; For all FILTAB Expressions
	JUMPLE TA,FILNO		; No more Expressions - all failed

FILTEL:	HRRZ T1,(TA)		; Element List address
	HLRZ T2,(TA)		; Routine address
	JUMPE T2,LOOP3		; Expression success for all ANDs

	LOAD T4,DPTRC,+PPKT+NPACKET-PACKET ; (New) trace code & flags
	MOVE T3,(T1)		; Flags (negate)
				; T3 & T4 Frequently needed by Routines
	CALL (T2)		; Test Term in Expression
	  JRST FILTEN		; Fail Term, thus Expression
	AOS TA			; Address of next Term (Routine,,List)
	JRST FILTEL		; Go check it

FILNO:	POP P,TA		; Restore registers
	POP P,TI		; Forget this NPACKET sample
	JRST LOOP1

;=======
FIX1:	push p,1
	load 1,dpktp,<+ppkt-packet+npacket>
	hlrzs 1
	cain 1,6;intsec
	  addi 2,lclpkt-sampkt
	ADDI T2,SAMPKT	; Yes, point to local leader position
	pop p,1
	ret
;=======

; Routines called by FILTEL...
; T1/ Address of -#,MASK,(CODES)*
;Ret+1:	 TERM FAILS
;Ret+2:	TERM OK
	SUBTTL	Packet Filtering Routines

; Filter addresses

;T1/ NEGATE,(FOREIGN HOST,MASK),(PORT,MASK),(LOCAL HOST,MASK),(PORT,MASK)
; CHECK PACKET ADDRESSES/PORTS

	0,,0	
	0,,TXHSTP+1
ADRS:	LOAD T2,DTYPE,+PPKT+NPACKET-PACKET  ; Get the sample type
	CAIN T2,ND.PKT		; Packet?
	 TXNE T4,PT%%NT		; Net sample?
	  JRST TRMLOS		; Yes, no addresses in sample

	TRNE T4,PT%%IN		; Which is it ? *****
	  TRO T3,FOREIGN	; Remember packet from net

	LOAD T2,PIDH,<+NPACKET>
	LOAD T4,PISH,<+NPACKET>	; Assume locally generated
	TRNN T3,FOREIGN		; correct ?
	  EXCH T2,T4		; Sent, Dest is Foreign, Source is Local

	XOR T4,1(T1)		; Foreign host value
	AND T4,2(T1)		; Mask it, match ?
	JUMPN T4,TRMLOS		; No, lose

	XOR T2,5(T1)		; Local host value
	AND T2,6(T1)		; Mask it, match ?
	JUMPN T2,TRMLOS		; No, lose

	LOAD T4,PIDO,<+NPACKET>	; Locate end of IP header
	ADDI T4,NPACKET+PKTELI

	LOAD T2,PDP,(T4)	; Port #s in first work after IP header
	LOAD T4,PSP,(T4)
	TRNN T3,FOREIGN		; Packet sent or received?
	  EXCH T2,T4		; Sent, Dest is Foreign, Source is Local

	XOR T4,3(T1)		; Foreign port value
	AND T4,4(T1)		; Mask it, match ?
	JUMPN T4,TRMLOS		; No, lose

	XOR T2,7(T1)		; Local port value
	AND T2,10(T1)		; Mask it, match ?
	JUMPN T2,TRMLOS		; No, lose

	JRST TRMWIN		; Addresses & ports match, term succeeds

; Check if TCB sample matches on HOSTS-PORTS
	TCBFKY,,0
	0,,[ASCIZ /TCB-SAMPLES HOSTS-PORTS/]
TADRS:	LOAD T2,DTYPE,+PPKT+NPACKET-PACKET  ; Get the sample type
	CAIE T2,ND.TCB		; TCB?
	 JRST TRMLOS		; No, loose

	LOAD T2,TFH,<+NPACKET+PKTELI>  ; Get Foreign host
	LOAD T4,TLH,<+NPACKET+PKTELI>  ; Get Local host

	XOR T2,1(T1)		; Foreign host value
	AND T2,2(T1)		; Mask it, match?
	JUMPN T2,TRMLOS		; No, loose

	XOR T4,5(T1)		; Local host value
	AND T4,6(T1)		; Mask it, match?
	JUMPN T4,TRMLOS		; No, loose

	LOAD T2,TFP,<+NPACKET+PKTELI>  ; Get Foreign port
	LOAD T4,TLP,<+NPACKET+PKTELI>  ; Get Local port

	XOR T2,3(T1)		; Foreign port value
	AND T2,4(T1)		; Mask it, match?
	JUMPN T2,TRMLOS		; No, loose

	XOR T4,7(T1)		; Local port value
	AND T4,10(T1)		; Mask it, match?
	JUMPN T4,TRMLOS		; No, loose

	JRST TRMWIN		; Addresses & Ports match, term succeeds

; Check if TCB sample matches on IDs
	TCBFKY,,DECRAD
	0,,[ASCIZ /TCB-SAMPLES IDs/]
TIDS:	LOAD T2,DTYPE,+PPKT+NPACKET-PACKET  ; Get the sample type
	CAIE T2,ND.TCB		; TCB?
	 JRST TRMLOS		; No, loose

	LOAD T4,TCBID,<+NPACKET+PKTELI>  ; Get the TCBID
	JRST ORLIST		; Find a match

; Check if TCB sample matches on JOBs
	TCBFKY,,DECRAD
	0,,[ASCIZ /TCB-SAMPLES JOBs/]
TJBS:	LOAD T2,DTYPE,+PPKT+NPACKET-PACKET  ; Get the sample type
	CAIE T2,ND.TCB		; TCB?
	 JRST TRMLOS		; No, loose

	LOAD T4,TOWNR,<+NPACKET+PKTELI>  ; Get the TOWNR
	JRST ORLIST		; Find a match

; Check if Buffer header sample

	BFRKEY,,DECRAD
	0,,TXBFRS+1
BFRF:	LOAD T2,DTYPE,+PPKT+NPACKET-PACKET  ; Get the sample type
	CAIE T2,ND.BFR		; Buffer?
	 JRST TRMLOS		; No, not match

	SETZ T4,		; No value
	JRST ORLIST		; Go find match


; Check Interface against list

	IFCKEY,,DECRAD
	0,,TXIFAC+1
IFACCD:	LOAD T2,DTYPE,+PPKT+NPACKET-PACKET	; Get the sample type
	CAIE T2,ND.PKT				; Packet?
	  JRST TRMLOS				; No field in sample
setz t4,;LOAD T4,Dxxx,<+PPKT+NPACKET-PACKET>	; Interface # (NTHSH)
	JRST ORLIST


; Check Link Protocol against list

	LKPKEY,,DECRAD
	0,,TXLNKP+1
LNKPCD:	LOAD T2,DTYPE,+PPKT+NPACKET-PACKET	; Get the sample type
	CAIE T2,ND.PKT				; Packet?
	  JRST TRMLOS				; No field in sample
	LOAD T4,DTYP,<+PPKT+NPACKET-PACKET>	; Link Protocol (NL.NFE, etc)
	JRST ORLIST


; Check Network Driver against list

	NTDKEY,,DECRAD
	0,,TXNETD+1
NTDRCD:	LOAD T2,DTYPE,+PPKT+NPACKET-PACKET	; Get the sample type
	CAIE T2,ND.PKT				; Packet?
	  JRST TRMLOS				; No field in sample
	LOAD T4,DDEV,<+PPKT+NPACKET-PACKET>	; Network Driver (NH.ANX, etc)
	JRST ORLIST

; Check (ICMP) Protocol Code against list

	PCDKEY,,DECRAD
	0,,TXCODS+1
PRCODS:	LOAD T2,DTYPE,+PPKT+NPACKET-PACKET  ; Get the sample type
	CAIN T2,ND.PKT		; Packet?
	 TXNE T4,PT%%NT		; Net sample?
	  JRST TRMLOS		; Yes, no Protocol/Type fields in sample

	LOAD T2,PIPRO,<+NPACKET>; Protocol - specific code
	CAILE T2,0		; Protocol in range of PRLDC table ?
	 CAILE T2,NPRCOD
	  JRST TRMLOS		; No, lose

	LOAD T4,PIDO,<+NPACKET>	; Locate beginning of
	ADDI T4,NPACKET+PKTELI	; Protocol header
	XCT PRLDC(T2)		; Get protocol - specific code value
	JRST ORLIST		; Go see if in list

				; Location of protocol - specific code
PRLDC: 	JRST TRMLOS 		;0
	LOAD T4,CMTYP,(T4)	;1 ICMP
	JRST TRMLOS       	;2
	JRST TRMLOS;(T4)	;3 GGP
	JRST TRMLOS		;4
	JRST TRMLOS		;5
	JRST TRMLOS		;6 TCP
	JRST TRMLOS		;7
NPRCOD=.-PRLDC



; Check Protocol Number against list

	PRCKEY,,DECRAD
	0,,TXPROS+1
PROTS:	LOAD T2,DTYPE,+PPKT+NPACKET-PACKET  ; Get the sample type
	CAIN T2,ND.PKT		; Packet?
	 TXNE T4,PT%%NT		; Net sample?
	  JRST TRMLOS		; Yes, no Protocol field in sample
	LOAD T4,PIPRO,<+NPACKET>; Protocol type (ICMP,TCP,ETC)
	JRST ORLIST

; Check Protocol Suite against list

	PRSKEY,,DECRAD
	0,,TXPRSU+1
PRSUCD:	LOAD T2,DTYPE,+PPKT+NPACKET-PACKET	; Get the sample type
	CAIE T2,ND.PKT				; Packet?
	  JRST TRMLOS				; No field in sample
	LOAD T4,DPRO,<+PPKT+NPACKET-PACKET>	; Protocol Suite (NP.IP, etc)
	JRST ORLIST

; Check if Register sample

	REGKEY,,DECRAD
	0,,TXREGS+1
REGF:	LOAD T2,DTYPE,+PPKT+NPACKET-PACKET  ; Get the sample type
	CAIE T2,ND.REG		; Register?
	 JRST TRMLOS		; No, not match

	SETZ T4,		; No value
	JRST ORLIST		; Go find match


	
; Check Trace Code against list

	0,,OCTRAD
	0,,TXTRCD+1
TRCODS:
;	LOAD T4,DPTRC,+PPKT+NPACKET-PACKET	; (New) trace code & flags
	JRST ORLIST		; Go see if in list

				; T4 contains value from packet
ORLIST:	MOVEI T2,2(T1)		; POINTER TO FIRST VALUE
	HLL T2,(T1)		; -COUNT,,PTR TO FIRST VALUE

ORLISL:	XOR T4,(T2)		; Find bits which differ
	TDNN T4,1(T1)		; All masked bits same?	
	  JRST TRMWIN		; Yes - value found in list
	XOR T4,(T2)		; Restore original T4
	AOBJN T2,ORLISL		; Check whole list
				; Value missing from list
TRMLOS:	TRC T3,NEGATE		; No match
TRMWIN:	TRNN T3,NEGATE		; Match
	  AOS (P)		; Succeed - skip return
	RET			; Fail




LOOP3:	POP P,TI		; RESTORE REGISTERS
	POP P,TA
LOOP4:

; Have packet

	CALL @FUNCT		; Process packet, e.g. .DOSAM, .EXTR
	JRST LOOP

	SUBTTL Error & Normal Completion

ERROR1:	MOVE T2,T1
	HRLI T2,.FHSLF
	SETZ T3,

	HRROI T1,[ASCIZ /
? Error: /]
	PSOUT

	MOVX T1,.PRIOU
	ERSTR
	  JFCL
	  JFCL

	HRROI T1,[ASCIZ /
/]
	PSOUT
	JRST EOF

BAD:	PUSH P,T2

	RFPTR
	  CALL ERROR1
BAD2:
	HRROI T1,[ASCIZ /
? Unreasonably large sample length of /]
	PSOUT

	EXCH T2,(P)
	MOVX T1,.PRIOU
	XNOUT DECRAD

	HRROI T1,[ASCIZ / in input file
at position /]
	PSOUT

	MOVX T1,.PRIOU
	POP P,T2
	NOUT
	  JFCL



STOP:	HRROI T1,[ASCIZ /; Stopping.
/]
	PSOUT%

EOF:	MOVE T1,JFNI		; Close input file
	TXO T1,CO%NRJ		; Keep JFN
	TRNE T1,-1		; Have JFN?
	 CLOSF%			; Yes, close it
	  JFCL

	SETO T2,		; In case no output file
	SKIPG T1,JFNO		; Have output file?
	IFSKP.			; Yes
	  SOSGE NPKTN		; Remove extra count due to EOF
	    SETZM NPKTN		; Probably an error exit

	  MOVE T2,FUNCT		; Function vector
	  SUBI T2,FCTPS.	; Post processing offset
	  XCT @T2		; Print final info

	  SETO T2,
	  MOVE T1,JFNO		; If have an output JFN
	  DVCHR%		; Get the device info

	  MOVE T1,JFNO
	  TXO T1,CO%NRJ		; Keep JFN
	  CLOSF%		; Close output file
	    JFCL
	ENDIF.

	MOVX T1,.PRIOU		; Statistics to tty: too
	AND T2,[DV%TYP]		; Unless listing device
	CAME T2,[FLD(.DVTTY,DV%TYP)]; Is a terminal
	  CALL STATIM		; List statistics info

	HRROI T1,[ASCIZ /  /]	; Output status message
	CALL STATMG

	HRRZ T2,LOSTOT
	IFG. T2
	  MOVX T1,.PRIOU		; Statistics to tty: too
	  XNOUT DECRAD
	  SSOUT < samples lost in >
	  HLRZ T2,LOSTOT
	  XNOUT DECRAD
	  SSOUT < gaps.
>
	ENDIF.
	JRST RENTR		; More

	SUBTTL EXIT Command

.EXIT:	CALL CLSRLF		; Close and release
	  IFIW JFNI		; Input file

	CALL CLSRLF		; Close and release
	  IFIW JFNO		; Output file

	HALTF			; Halt
	JRST RENTR		; Do another, without changing parameters

	SUBTTL Subroutine to read ASCII input line

AINPUT:	MOVE T1,JFNI
	MOVX T2,<POINT 7,STRING>
	MOVX T3,<200>
	MOVX T4,C.LF
	SIN
	 ERJMP [TXO F,F%EOF	; SEEN EOF
		SETZB T2,T4	; Return zeros
		RET]		; GET LAST DUMPED
	SETZ T3,
	IDPB T3,T2		; End string

	MOVX T1,<POINT 7,STRING>
	MOVE T2,T1
	ILDB T3,T2
	CAIL T3,"0"
	 CAILE T3,"7"
	  JRST AINPUC		; Probably a comment

	MOVX T3,OCTRAD
	NIN			; Address
	  MOVX T3,OCTRAD
	MOVE T4,T2		; Save it

	LDB T2,T1		; Break
	CAIE T2,"/"
	 CAIN T2,"["
	  CAIA
	   JRST AINPUC

	NIN			; Word or LH
	  MOVX T3,OCTRAD
	PUSH P,T2

	LDB T2,T1		; Break
	CAIE T2,","
	  JRST AINPUW
	ILDB T2,T1		; Second ,

	NIN			; RH
	  MOVX T3,OCTRAD

	HRL T2,(P)
	MOVEM T2,(P)		; LH,,RH
AINPUW:
	POP P,T2		; Value
	RET

AINPUC:	MOVE T1,JFNO
	MOVX T2,<POINT 7,STRING>
	SETZ T3,
	SOUT
	JRST AINPUT

	SUBTTL Code to dump core

DMPCOR:	MOVE T1,JFNO
	CALL CRLF
	MOVE T2,CORADR
	XNOUT <NO%LFL+FLD(6,NO%COL)+OCTRAD>
	MOVX T2,"["
	BOUT

	MOVEI T4,<NPACKET-1>	; Address of data
	HLLZ T5,(T4)		; N,,0
	JUMPE T5,DMPCOX		; ??
	ADD T5,[1,,0]		; N+1
	MOVNS T5		; -<N+1>,,0 is words present
	HRR T5,CORCNT		; Max to list

DMPCOL:	HRLI T4,<-4>		; 4 per line
DMPCOM:	MOVE T2,(T4)		; Next data
	XNOUT <NO%MAG+NO%LFL+FLD(^D13,NO%COL)+OCTRAD>
	AOBJP T5,DMPCOX		; Listed 20
	TRNN T5,-1
	  JRST DMPCOX		; Listed all there is
	AOBJN T4,DMPCOM		; Back for next on same line

	SSOUT <
       >
	JRST DMPCOL		; Back for another line

DMPCOX:	CALLRET CRLF

	SUBTTL	Routine to Extract Samples

;============================================================
;================ Beginning of EXTRACT Command ==============
;============================================================

HEXTR:	ASCIZ /The EXTRACT command writes the filtered binary samples to
the output file./
	
.EXTR.:	MOVEI T2,[FLDDB.(.CMNOI,CM%SDH,<POINT 7,[ASCIZ /filtered samples/]>)]
	CALL CCOMND
	CALL CCMCFM		; Confirm EXTRACT
	MOVEM FCT,FUNCT
	RET

	FLD(^D36,OF%BSZ)+OF%RD+OF%WR+OF%APP ; Output file size
	JFCL				; Grand initialization
	CALL .EXTR.			; Extract command
	JFCL				; Run initialization
	JFCL				; Post-processing

.EXTR:					; Per sample routine
	TXNE F,F%EOF			; Done?
	  JRST .EXTRX			; Yes

	MOVE T1,JFNI			; Easiest to backup and re-read
	MOVE T2,NFLBYT			; Position of start of sample
	SFPTR%
	  ERJMP .EXTRX
	MOVX T2,<POINT 36,PACKET>	; Use second buffer
	LOAD T3,DLENW,+NPTDTA		; Actual length
	MOVNS T3
	MOVE T4,T3			; Save it
	SIN%
	ERJMP .EXTRX

	MOVE T1,JFNO			; Output file name
	MOVX T2,<POINT 36,PACKET>
	MOVE T3,T4
	SOUT%
	ERJMP .EXTRX

	AOS SMPCNT			; Count packet sampled
.EXTRX:
	RET

;============================================================
;================== End of EXTRACT Command ==================
;============================================================

	SUBTTL	Routine to List a Sample

;============================================================
;================= Beginning of LIST Command ================
;============================================================

;(NPACKET should be listed but first have to) list PACKET.  Always list
; header line (+.) but only list PACKET contents if it differs from NPACKET.

.DOSA.:	CALL CCMCFM		; Confirm LIST
	MOVEM FCT,FUNCT
	RET

	FLD(^D7,OF%BSZ)+OF%RD+OF%WR+OF%APP ; Output file size
	JFCL			; Grand initialization routine
	CALL .DOSA.
	JFCL			; Initialization routine
	CALL STATOF		; Post-processing routine - summary info
.DOSAM:
	MOVE T1,JFNO		; JFN stays for duration...

; Begin new page if requested and full

	TXNN F,F%PG		; Want pages?
	 SKIPN PAGE		; Always first page
	  SOSLE PAGCNT		
	   JRST DOSAMQ		; Not paging or not yet full

	MOVEI T2,^D<55-6>	; Reset lines-to-go counter
	MOVEM T2,PAGCNT
	HRROI T2,OTITLE		; Print title
	SETZ T3,
	SOUT%
	CALL CRLF
	SKIPN PAGE		; First page?
	  CALL SHOW1		; Yes, Print parameters
	LOAD T2,DTIME,<+PPKT>	; Start time
	SKIPN PAGE		; First page?
	  MOVEM T2,OLDTIM	; Yes, no first time difference
	AOS PAGE		; Increment page #
DOSAMQ:
	TXZE F,F%0PKT		; Have a sample in PACKET?
	  RET			; No, all done

	CALL PP			; Print header line

; Decide if Nsample and Sample are same so can print it later

	LOAD T4,DPKTP,+PPKT	; If packet addresses
	LOAD T5,DPKTP,+PPKT-PACKET+NPACKET
	CAMN T4,T5		; Differ?
	 TXNE F,F%FCOR		; Core sample?
	  JRST NOSQUZ		; Yes, list samples separately

	MOVE T2,TPBZ		; Get legnths of two samples
	MOVE T3,NTPBZ

	LOAD T4,DPTRC,+PPKT	; (New) trace code & flags
	LOAD T5,DPTRC,+PPKT-PACKET+NPACKET
	TXNE T4,<PT%%VI+PT%%VN+PT%%NT>	; Both packet samples?
	 TXNN T5,<PT%%VI+PT%%VN+PT%%NT>
	  JRST DOSAMW		; No, just check words
	XOR T5,T4		; Bits which differ
	TXNN T5,<PT%%IN+PT%%OU>	; Direction same and
	 TXNN T4,<PT%%IN+PT%%OU> ; Either IN or OUT?
	  JRST DOSAMW		; No, just check words

	TXNE T4,<PT%%OU> 	; OUT?
	  JRST DOSAMS		; Yes

; Input sample - size can increase

;DOSAMR:
	CAMLE T2,T3
	  JRST NOSQUZ
	MOVE T3,T2		; Number of octets to compare
	CALL IPHSAV		; Fix up checksum and time to live
	CALL CMPT3		; Compare # octets in T3
	CALL IPHRES		; Restore checksum and time to live
	JUMPL T3,NOSQUZ		; Differ
	RET			; Same, will dump info later

IPHSAV:	LOAD T4,PICKS,<+PACKET>	; Save checksum and
	LOAD T5,PITTL,<+PACKET>	; Time to live
	LOAD T2,PICKS,<+NPACKET>
	STOR T2,PICKS,<+PACKET>
	LOAD T2,PITTL,<+NPACKET>
	STOR T2,PITTL,<+PACKET>
	RET

IPHRES:	STOR T4,PICKS,<+PACKET>	; Restore original data
	STOR T5,PITTL,<+PACKET>
	RET



CMPT3:	MOVNS T3		; Octets
	ASH T3,-2		; Words (rounded "up")
	HRLZS T3		; Into AOBJN ptr
	  MOVE T2,PACKET+PKTELI(T3)
	  CAMN T2,NPACKE+PKTELI(T3)
	   AOBJN T3,.-2
	RET			; T3 .lt. 0 if differ


; Output sample - size can decrease or old data may not be specified

DOSAMS:	CAMGE T2,T3		; Next sample bigger?
	  JRST NOSQUZ		; Yes, not expected for output
	CALL IPHSAV		; Fix up checksum and time to live
	CALL CMPT3		; Compare # octets in T3
	CALL IPHRES		; Restore checksum and time to live
	JUMPL T3,NOSQUZ		; Differ

; Copy excess to next sample ...

	MOVE T5,TPBZ
	EXCH T5,NTPBZ
	SUB T5,TPBZ
	ASH T5,-2
	SKIPL T5
	  RET			; Same, will dump info later
	HRLZ T3,T5
	  MOVE T2,PACKET+PKTELI(T3)
	  MOVEM T2,NPACKE+PKTELI(T3)
	  AOBJN T3,.-2
	RET			; Same, will dump info later


; Register or buffer sample

DOSAMW:	CAME T2,T3		; Same lengths?
	  JRST NOSQUZ		; No, list samples separately
	CALL CMPT3		; Compare T3 octets
	JUMPL T3,NOSQUZ		; Differ
	RET			; Same, will dump info later

NOSQUZ:	AOS SMPCNT		; Count samples listed

	SETZM STRTOF		; Assume starting offset of 0

	LOAD T2,DTYPE,+PPKT	; Get the sample type
	CAIN T2,ND.PKT		; Packet?
	  CALLRET LSTPKT	; Yes
	CAIN T2,ND.BFR		; Buffer?
	  CALLRET LSTBFR	; Yes
	CAIN T2,ND.TCB		; TCB?
	  CALLRET LSTTCB	; Yes
	CALLRET LSTREG		; Must have registers 

	SUBTTL	Routine to Generate Header Line

; T1/	Otput JFN

PP:	SKIPN LOSTLN		; Any lost samples?
	  JRST PP0		; No
	CALL CRLF
	HRRZ T2,LOSTLN
	XNOUT DECRAD
	SSOUT < samples lost.
>
	PUSH P,T1
	MOVX T1,.PRIOU
	HRRZ T2,LOSTLN
	XNOUT DECRAD
	SSOUT < samples lost before sample >
	HLRZ T2,LOSTLN
	XNOUT DECRAD
	SSOUT <
>
	SETZM LOSTLN
	POP P,T1
PP0:
	AOS HDRCNT		; Count header lines output
	SSOUT <
+>
	SOS PAGCNT		; Count lines per page

	TXNE F,F%FCOR		; IF SAMPLE ISN'T AN IP PACKET
	  JRST IMPD		; SKIP TIMES

	LOAD T2,DTIME,<+PPKT>
	SKIPN OLDTIM		;Got an old time?
	  MOVEM T2,OLDTIM	;No, it is the first
	SUB T2,OLDTIM

	PUSH P,T2		; Save increment
	XNOUT <NO%LFL+FLD(7,NO%COL)+DECRAD>
	SSOUT <.  >
	POP P,T2		; Increment

	ADDB T2,OLDTIM		; Plus last
	XNOUT <NO%LFL+FLD(^D10,NO%COL)+DECRAD>

	HRROI T2,[ASCIZ /., Sample /]
	CAIA
IMPD:	  HRROI T2,[ASCIZ /                      Sample /]
	SETZ T3,
	SOUT

	MOVE T2,PKTN		; Sample number
	XNOUT DECRAD
	SSOUT <.>

;	TXNE F,F%NIP		; If sample isn't an IP packet
;	  JRST IMPF:		; Skip packet buffer address

	LOAD T4,DPTRC,+PPKT	; Funny new code or zero
	LOAD T3,DPKTP,<+PPKT>	; Packet buffer address
	SKIPE T4		; But skip zero
	 TXNN T4,PT%%VI+PT%%VN+PT%%VB+PT%%VH  ; Must be packet, buffer
	  JRST NOADR			      ;  or TCB header

	MOVX T2,","
	BOUT
	MOVE T2,T3		; List address
	XNOUT NO%MAG+OCTRAD
NOADR:
	TXNN F,F%FCOR		; If sample isn't an IP packet
	 TXNN T4,PT%%VI+PT%%VN
	  JRST IMPF		; Skip TCP flags

REPEAT 0,<
	LOAD T4,DFLAG,<+PPKT>	; Sampled flags
	TXZ T4,PP%DUN		; Forget this bit - always there
	JUMPE T4,NOPFL		; Not TCP packet if zero
	SSOUT < PP% >
	AND T4,PFLGSS-1		; Discard unknow bits
	MOVEI COD,PFLGSS	; Name of leftmost bit
PFLGL:	HRRO T2,COD		; String pointer to name
	SKIPGE T4		; Bit set ?
	  SOUT			; Yes, print name
	ADDI COD,1		; Next name
	LSH T4,1		; Next bit
	JUMPN T4,PFLGL		; Back if more to do
NOPFL:
> ; End REPEAT 0
IMPF:
	LOAD T4,DPTRC,+PPKT	; Trace code or zero
	SKIPN T4
	  JRST DUNNOT		; Omit zero codes

	SSOUT < Note: >

	PUSH P,T1		; Save output designator
	HRRZS T4		; Just right-half
	CALL SRCH		; Lookup name for code
	  JRST NOTOCT
	POP P,T1		; Restore output designator

	PUSH P,T2		; Save ASCIZ pointer while
	SSOUT <PT%>		; Output common prefix
	POP P,T2		; Pointer to last three letters
	SOUT			; Output them
	JRST DUNNOT

NOTOCT:	POP P,T1		; Restore output designator
	MOVX T3,OCTRAD		; Octal data
	LOAD T2,DPTRC,+PPKT	; Trace code or zero
	SKIPE T2		; Skip # if zero
	 NOUT
	  JFCL
DUNNOT:
	TXNN F,F%FILP		; Want file-positions?
	  RET			; No
	SSOUT < at >
	MOVE T2,FLBYT		; Position of packet
	XNOUT <DECRAD>
	RET

REPEAT 0,<
	PP%MT+PP%SK+PP%DK+PP%SNT+PP%RCV+PP%REX+PP%PZ+PP%RA+PP%GSS+PP%GDS+PP%DUN
PFLGSS:	ASCIZ /MT /
	ASCIZ /SK /
	ASCIZ /DK /
	ASCIZ /SNT /
	ASCIZ /RCV /
	ASCIZ /REX /
	ASCIZ /PZ /
	ASCIZ /RA /
	ASCIZ /GSS /
	ASCIZ /GDS /
	ASCIZ /DUN /
> ; End REPEAT 0

;SRCH: Exact Match Binary Search Routine

; T4/	Value
;	CALL SRCH
;Ret+1:	  Not found
;Ret+2:	Fouund and	T2/ Pointer	T3/ Zero

PRB==1
X.X==2
OFS==3
KEY==4

SRCH:
REPEAT 0,<MOVEI X.X,STABLN	; STABLN is external... must compute
	JFFO X.X,.+2		; # leading zeros
	  RET			; ??  NB: T2/X.X is zero here
	MOVE OFS,BITS-1(OFS)	; Next 2**N larger than STABLN
>
	MOVX OFS,<1_<^D<36-^L<PTVALL>>>>
	SETZB PRB,T2		; Offset into table & Assume missing
SRCHF:	ADD PRB,OFS		; Move forward (double)
SRCHR:	LSH OFS,-1		; Next time
	SUB PRB,OFS		; Move reverse
	JUMPLE OFS,SRCHX	; Stop if no move
	CAIG PRB,PTVALL		; Point too far? or
	 CAMGE KEY,PTVALS(PRB)	; Value too big?
	  JRST SRCHR		; Yes, move back
	CAML KEY,PTVALS+1(PRB)	; As far as next?
	  JRST SRCHF		; Yes, move forward
SRCHX:	CAME KEY,PTVALS(PRB)	; Exact match?
	  RET			; No, error (T2 is 0)
				; Yes
	HRROI T2,PTNAMS(PRB)	; Pointer to text
	SETZ T3,
	AOS (P)			; Skip return
	RET

	PURGE PRB,X.X,OFS,KEY

DEFINE PT(NAM,VAL,LST)<	.X==VAL
			IRP LST,<.X==.X+PT%%'LST>
			EXP <.X&777777>	; PT%'NAM>

PTVALS:	400000000000
	PT%XXX
	377777777777
PTVALL=.-PTVALS


DEFINE PT(NAM,VAL,LST)<	ASCIZ /NAM/>

PTNAMS:	ASCIZ /000/
	PT%XXX
	ASCIZ /777/


;SRTPTV
;Sort trace code table, PTVALS, and parallel name table, PTNAMS

SRTPTV:	MOVX T4,<-PTVALL+1,,0>	; Loop over all but 1 entries
SRTPTW:	MOVE T3,T4		; Inner loop from there
	ADDI T3,1		; Beginning with next
	MOVE T2,PTVALS(T4)	; Get current minimum
SRTPTX:	CAMG T2,PTVALS(T3)	; Current entry out of order?
	  JRST SRTPTY		; No
	EXCH T2,PTVALS(T3)	; Yes, exchange
	MOVE T1,PTNAMS(T4)	; Also exchange corresponding
	EXCH T1,PTNAMS(T3)	; Entries in count table
	MOVEM T1,PTNAMS(T4)
SRTPTY:	AOBJN T3,SRTPTX		; Back for rest of inner loop
	MOVEM T2,PTVALS(T4)	; Save minimum value
	AOBJN T4,SRTPTW		; Back for rest of outer loop

	SETOM PTVSRT		; Sorted

	MOVX T4,<-PTVALL+1,,0>	; Loop over all but 1 entries
SRTPTZ:	MOVE T3,PTVALS(T4)	; Get entry
	CAMGE T3,PTVALS+1(T4)	; Any duplicates?
	  JRST SRTPTN		; No
	MOVX T1,.PRIOU
	HRROI T2,[ASCIZ /Duplicate value in PTVALS for "/]
	SETZ T3,
	SOUT
	HRROI T2,PTNAMS(T4)	; First name
	MOVX T3,-3
	SOUT
	HRROI T2,[ASCIZ /" and "/]
	SETZ T3,
	SOUT
	HRROI T2,PTNAMS+1(T4)	; Second name
	MOVX T3,-3
	SOUT
	HRROI T2,[ASCIZ /", value /]
	SETZ T3,
	SOUT
	MOVE T2,PTVALS(T4)
	MOVX T3,OCTRAD
	NOUT
	  JFCL
	HRROI T1,[ASCIZ /
/]
	PSOUT
	SETZM PTVSRT		; Sort failed
SRTPTN:	AOBJN T4,SRTPTZ		; Check whole table
	HRROI T1,[ASCIZ /Save program now.
/]
	PSOUT
	HALTF
	RET			; Tables are sorted

COMMENT \
; Packet Printer Trace Codes
; Old codes

PT%XX0==^D0	;     BG is flushing packet printer buffer
PT%XX1==^D1	; PZ  Generated normal packet "being output"
PT%XX2==^D2	; SNT EMTPKT, ABTNTC
PT%XX3==^D3	; RCV PKT on no connection, for RA
PT%XX4==^D4	; RA  Reassembly from packet completed
PT%XX5==^D5	;     IP Flushed (checksum, PKT on closed conn)
PT%XX6==^D6	;     INPUT finished: New SYN, DUP, IGN, no SEQ#, sent RST
PT%XX7==^D7	; SNT Sent a RST in response to received packet
PT%XX8==^D8	; REX Retransmitted a PKT

; New codes  (NB don't use 400000,,0)

			; Bit indicating validity
PT%%VR==100000,,0	; Registers valid
PT%%VH==040000,,0	; Higher level protocol (TCB=14)
PT%%VB==020000,,0	; User buffer (BFR=11)
PT%%VP==010000,,0	; Protocol pkt (T/CPKT=12)
PT%%VI==004000,,0	; IP (PKT=13)
;PT%%VG==002000,,0	; Gateway (PKT=13)
PT%%VN==001000,,0	; Local Net (PKT=13)

			; Bit indicating error level
PT%%EI==000400,,0	; Internal error
PT%%EU==000200,,0	; Unimplemented
PT%%ER==000100,,0	; Resource
PT%%EN==000040,,0	; Normal

			; Bit indicating level of detail
PT%%LH==000010,,0	; High level
PT%%LF==000004,,0	; Filter
PT%%LM==000002,,0	; Medium
PT%%LL==000001,,0	; Low

			; Bit indicating "protocol"
PT%%TC==200000		; TCP
PT%%UQ==100000		; IP User Queues
PT%%GG==040000		; GGP
PT%%IC==020000		; ICMP
PT%%IP==010000		; IP
PT%%GW==004000		; Gateway
PT%%NT==002000		; Local Net

			; Agent & Direction
PT%%SY==001000		; System
PT%%UR==000400		; User
PT%%OU==000200		; Output
PT%%IN==000100		; Input

; Plus an ID code



DEFINE PT(NAM,VAL,LST)<	.X==VAL
			IRP LST,<.X==.X+PT%%'LST>
			PT%'NAM==.X>

					; Local net
PT(RLN,30,<SY,IN,NT,LL,EN>)		; Packet received from local net
PT(KLS,10,<SY,IN,OU,NT,LL,ER>)		; Note of samples being dropped
PT(KIL,11,<SY,IN,NT,LL,ER>)		; Input packet flushed by local net
PT(KOL,11,<SY,OU,NT,LL,ER>)		; Output packet flushed by local net
PT(SLN,30,<SY,OU,NT,LL,EN>)		; Packet sent over local net

					; Input, gateway level
PT(RGW,30,<SY,IN,GW,LL,VI>)		; Packet received at gateway from net
PT(KIP,11,<SY,IN,GW,LL,VI,EN>)		; Killed invalid format
PT(KCS,13,<SY,IN,GW,LL,VI,EN>)		; Killed checksum
PT(KDP,14,<SY,IN,GW,LL,VI,EN>)		; Killed duplication
PT(KIS,20,<SY,IN,GW,LL,VI,ER>)		; Killed no space to reassemble
PT(KIT,21,<SY,IN,GW,LL,VI,EN>)		; Killed reassembly timeout
PT(QIF,40,<SY,IN,GW,LL,VI>)		; Internet fragment queued (INTRAQ)
PT(DIF,44,<SY,IN,GW,LL,VI>)		; Dequeued and reassembled
PT(IRA,45,<SY,IN,GW,LL,VI>)		; Reassembled packet created

					; Input, IP level
PT(IDD,30,<SY,IN,IP,LL,VI>)		; Dequeued for dispatch
PT(IKC,13,<SY,IN,IP,LL,VI,EN>)		; Killed due to invalid checksum
PT(IKP,16,<SY,IN,IP,LL,VI,EU>)		; Killed due to invalid protocol
PT(IQP,57,<SY,IN,IP,LL,VI>)		; Queued for protocol module

					; Output, IP level
PT(IDO,57,<SY,OU,IP,LL,VI>)		; Dequeued packet for output
PT(IQG,30,<SY,OU,IP,LL,VI>)		; Queued packet for gateway

					; Output, Gateway level
PT(RGI,57,<SY,OU,GW,LL,VI>)		; Received at gateway from IP
PT(KDF,24,<SY,OU,GW,LL,VI,EN>)		; Killed fragmentation not allowed
PT(KIA,23,<SY,OU,GW,LL,VI,EN>)		; Killed addressing failure
PT(KPT,21,<SY,OU,GW,LL,VI,EN>)		; Killed packet (fragmentation) timeout
PT(KIO,22,<SY,OU,GW,LL,VI,EN>)		; Killed ill formated options
PT(KFS,20,<SY,OU,GW,LL,VI,ER>)		; Killed insufficient space to fragment
PT(BYP,34,<SY,OU,GW,LL,VI>)		; Queued for GW input
PT(IFR,33,<SY,OU,GW,LL,VI>)		; Internet fragment created
PT(QLN,30,<SY,OU,GW,LL,VI>)		; Queued for local net



       					; ICMP
PT(CDI,30,<SY,IN,IC,LM,VP>)		; ICMP received packet
PT(CKS,12,<SY,IN,IC,LL,VP,EN>)		; Killed due to truncated packet
PT(CKC,13,<SY,IN,IC,LL,VP,EN>)		; Killed due to bad checksum
PT(CKT,16,<SY,IN,IC,LL,VP,EN>)		; Killed due to bad ICMP Type
PT(CKX,17,<SY,IN,IC,LL,VP,EN>)		; Killed due to bad ICMP Code

					; GGP
PT(GDI,30,<SY,IN,GG,LM,VP>)		; Received packet
PT(GKS,12,<SY,IN,GG,LL,VP,EN>)		; Killed due to truncated packet
PT(GKC,13,<SY,IN,GG,LL,VP,EN>)		; Killed due to bad checksum
PT(GKT,16,<SY,IN,GG,LL,VP,EN>)		; Killed due to bad GGP Type
PT(GKX,17,<SY,IN,GG,LL,VP,EN>)		; Killed due to bad GGP Code

					; Input, Internet User Queues
PT(UDI,30,<SY,IN,UQ,LM>)		; Received packet
PT(UKQ,16,<SY,IN,UQ,LL,EN>)		; Killed due to no such queue
PT(UKS,20,<SY,IN,UQ,LL,ER>)		; No space in RECIN queue
PT(UKT,21,<SY,IN,UQ,LL,EN>)		; RCVIN queue timedout
PT(UQU,57,<SY,IN,UQ,LM>)		; Passed to user

					; User Interface, Internet User Queues
PT(UQA,02,<UR,IN,UQ,LM>)		; User queue assigned
PT(URJ,30,<UR,IN,UQ,LM>)		; User receive
PT(USJ,57,<UR,OU,UQ,LM>)		; User send
PT(UQD,02,<UR,OU,UQ,LM>)		; User queue deassigned

					; Output, Internet User Queues
PT(UDU,57,<SY,OU,UQ,LH,VI>)		; Received from user
PT(UKP,11,<SY,OU,UQ,LL,VI>)		; Killed
PT(UQO,30,<SY,OU,UQ,LL,VI>)		; Queued for output



					; Input, TCP level
PT(TDI,30,<SY,IN,TC,LH,VH,VP,VI>)	; Received packet
PT(TRS,01,<SY,IN,TC,LL,VH,VP,VI,EN>)	; Reset received
PT(TKR,10,<SY,IN,TC,LL,VH,VP,VI,EN>)	; Killed & sent RST
PT(TKC,13,<SY,IN,TC,LL,VH,VP,VI,EN>)	; Killed due to bad checksum
PT(TKD,14,<SY,IN,TC,LL,VH,VP,VI,EN>)	; Killed due to duplicate
PT(TKS,15,<SY,IN,TC,LL,VH,VP,VI,EN>)	; Killed due to sequence error
PT(TKX,16,<SY,IN,TC,LL,VH,VP,VI,EN>)	; Killed due to no local connection
PT(TKN,17,<SY,IN,TC,LL,VH,VP,VI,EN>)	; Killed due to closed connection
PT(TKT,20,<SY,IN,TC,LL,VH,VP,VI,EN>)	; TRMPKT killed packet - no space
PT(TTP,37,<SY,IN,TC,LL,VH,VP,VI>)	; TRMPKT trimming packet
PT(TQR,40,<SY,IN,TC,LL,VH,VP,VI>)	; Queued for reassembly
PT(TRA,42,<SY,IN,TC,LM,VH,VP,VI>)	; Being reassembled
PT(TDR,44,<SY,IN,TC,LL,VH,VP,VI>)	; Dequeued from reassembly
PT(TID,60,<SY,IN,TC,LL,VH,VP,VI>)	; Done with packet
PT(TIR,01,<SY,OU,TC,LL,VH,VP,VI,EN>)	; Reset sent in response to input pkt

					; User Interface, TCP level
PT(TST,01,<UR,IN,TC,LM>)		; User status request
PT(TOJ,02,<UR,IN,TC,LM,VH>)		; User Open
PT(TIS,03,<UR,IN,TC,LM,VH>)		; Interrupt levels specified
PT(TSL,05,<UR,IN,TC,LM,VH>)		; User security level change
PT(TRD,30,<UR,IN,TC,LM,VH,VB>)		; User receive data
PT(TIO,34,<UR,OU,TC,LM,VH,VP,VI>)	; Options to user
PT(TOO,35,<UR,OU,TC,LM,VH>)		; User options processed
PT(TSD,57,<UR,OU,TC,LM,VH,VB>)		; User send data
PT(TBF,60,<UR,IN,TC,LM,VH,VP,VI>)	; User buffer filled
PT(TBE,60,<UR,OU,TC,LM,VH,VP,VI>)	; User buffer emptied
PT(TER,11,<UR,TC,LM,VH>)		; Error
PT(TIU,06,<UR,IN,TC,LM,VH,VP,VI>)	; Interrupt to user
PT(TSC,04,<UR,OU,TC,LM,VH,VP,VI>)	; Secure close
PT(TVT,07,<UR,TC,LM,VH>)		; ATNVT for TVT
PT(TCJ,02,<UR,OU,TC,LM,VH>)		; User Close
PT(TAJ,01,<UR,OU,TC,LM,VH>)		; User Abort
PT(TAB,01,<SY,OU,TC,LM,VH>)		; Abort (not user)

					; Output, TCP level
PT(TPZ,60,<SY,OU,TC,LM,VH,VP,VI>)	; TCP packet generated (Normal)
PT(TQX,40,<SY,OU,TC,LM,VH,VP,VI>)	; TCP PKT queued for RX
PT(TRX,42,<SY,OU,TC,LM,VH,VP,VI>)	; TCP PKT being RX'd
PT(TDX,44,<SY,OU,TC,LM,VH,VP,VI>)	; TCP PKT dequeued from RX
PT(TRX,30,<SY,OU,TC,LM,VH,VP,VI>)	; TCP packet transmitted
PT(TSC,04,<SY,OU,TC,LM,VH,VP,VI>)	; TCP secure close generated
PT(TOR,03,<SY,OU,TC,LM,VH,VP,VI>)	; TCP Reset generated by output

\ ; End of COMMENT


; List Buffer header sample

LSTBFR:	MOVEI IPKT,PACKET+PKTELI ; Pointer for internal information
	MOVE OP,[POINT 9,(IPKT)]
	MOVE VL,TPBZ		; Have whole buffer header
	MOVE PL,VL

	MOVE T5,FBFR		; Format bits
	MOVE T4,BFRTB-1		; AOBJN pointer
	CALL LSTHDR		; List buffer header
	CALLRET CRLF

.BFRMN:	HRROI T4,[ASCIZ / Mon /]
	TRNA
.BFSRC: HRROI T4,[ASCIZ / Src /]
	EXCH T4,T2		; Flag in T4, ASCIZ ptr in T2
	SETZ T3,
	SKIPE T4
	  SOUT
	AOS (P)
	RET

; Print a queue
QUEOUT:
	MOVE T4,LSTT2(T4)	; LDB pointer or SOUT pointer
	MOVEI T4,@T4		; get the address of the queue
	SSOUT <(C:>		;Count
	LOAD T2,QCNT,(T4)
	XNOUT <DECRAD>
	SSOUT < N:>		;Next
	LOAD T2,QNEXT,(T4)
	XNOUT <OCTRAD+NO%MAG>
	SSOUT < M:>		;Max
	LOAD T2,QMAX,(T4)
	XNOUT <DECRAD>
	SSOUT < P:>		;Prev
	LOAD T2,QPREV,(T4)
	XNOUT <OCTRAD+NO%MAG>
	SSOUT < W:>		;When
	LOAD T2,QMWHN,(T4)
	LSH T2,^D9		;Shift when to msecs
	XNOUT <DECRAD+NO%MAG>
	SSOUT < H:>		;Header
	LOAD T2,QHDR,(T4)
	XNOUT <OCTRAD+NO%MAG>
	SSOUT <)>
	AOS (P)			;RETSKP
	RET

.XX==0
	-BFRTL,,BFRTB

BFRTB:
XX (LBFR,1B0,01,<>,xxx,<
BFR:>,0)

XX (LBFRQ,1B1,<BFRQ+1>*4,< Q=>,,BFRQ(IPKT),QUEOUT)
;;User
XX (LBFRFL,1B2,<BFRFLG+1>*4,< FLG=>,,BFRFLG(IPKT),<NO%MAG+NO%LFL+FLD(12,NO%COL)+OCTRAD>)
XX (LBDADR,1B6,<$BDADR+1>*4,< DAT=>,BDADR,(IPKT),<NO%LFL+NO%MAG+FLD(^D8,NO%COL)+OCTRAD>)
XX (LBCNT,1B7,<$BCNT+1>*4,< CNT=>,BCNT,(IPKT),<NO%LFL+FLD(^D6,NO%COL)+DECRAD>)
XX (LBFROP,1B8,<BFROPT+1>*4,< OPT=>,,BFROPT(IPKT),<NO%MAG+NO%LFL+FLD(^D12,NO%COL)+OCTRAD>)
;XX ... 
;;End user
XX (LBHADR,1B9,<$BHADR+1>*4,< UH=>,BHADR,(IPKT),<NO%LFL+FLD(^D8,NO%COL)+OCTRAD>)
XX (LBICNT,1B10,<$BICNT+1>*4,< ICNT=>,BICNT,(IPKT),<NO%LFL+FLD(^D6,NO%COL)+DECRAD>)
XX (LBFRKX,1B11,<$BFRKX+1>*4,< FX=>,BFRKX,(IPKT),<NO%LFL+FLD(^D4,NO%COL)+OCTRAD>)
XX (LBFRMN,1B17,<$BFRMN+1>*4,<>,BFRMN,(IPKT),.BFRMN)
XX (LBFSRC,1B18,<$BFSRC+1>*4,<>,BFSRC,(IPKT),.BFSRC)
XX (LBIDX,1B15,<$BIDX+1>*4,< IDX=>,BIDX,(IPKT),<NO%LFL+FLD(3,NO%COL)+DECRAD>)
XX (LBHSPT,1B19,<$BHSPT+1>*4,< Hi=>,BHSPT,(IPKT),<NO%LFL+FLD(4,NO%COL)+OCTRAD>)
XX (LBDSPT,1B20,<$BDSPT+1>*4,< Di=>,BDSPT,(IPKT),<NO%LFL+FLD(4,NO%COL)+OCTRAD>)
XX (LBPTR,1B13,<$BPTR+1>*4,< Dp=>,BPTR,(IPKT),<NO%MAG+NO%LFL+FLD(^D12,NO%COL)+OCTRAD>)
XX (LBTCB,1B14,<$BTCB+1>*4,< TCB=>,BTCB,(IPKT),<NO%LFL+FLD(^D8,NO%COL)+OCTRAD>)
XX (LBTS,1B16,<$BTS+1>*4,< TS=>,BTS,(IPKT),<NO%LFL+FLD(^D11,NO%COL)+DECRAD>)
BFRTL==.XX

DBFR==1B0+1B2+1B6+1B7+1B9+1B10+1B14+1B17+1B18


; List Registers

LSTREG:	MOVEI IPKT,PACKET+PKTELI ; Pointer for internal information
	MOVE OP,[POINT 36,(IPKT)]
	MOVE VL,TPBZ		; Have whole buffer header
	LSH VL,-2		; Words
	MOVE PL,VL

	HRROI T2,[ASCIZ /
Reg:        /]
	MOVX T5,20
	CALL OUTB
	  NO%MAG+NO%LFL+FLD(^D13,NO%COL)+OCTRAD
	  4
	CALLRET CRLF

DREG==1B1


LSTPKT:

; List Internal information

	MOVEI IPKT,PACKET	; Pointer for internal information
	MOVE VL,LDOCT		; What is there (negative from PKTELI)
	MOVE PL,VL
	TXNE F,F%INTL		; Want internal data?
	  CALL PKTLDR		; Yes, list internal packet leader

; Examine & List Local Leader

	MOVEI IPKT,PACKET+LCLPKT ; Point at local leader (LCLPKT)
	MOVX OP,<POINT 9,(IPKT)>
	MOVE VL,LDOCT		; What is there (negative from PKTELI)
	MOVE PL,VL

	CALL PRCLCL		; Process local leader
				; Sets VL to # octets after local leader
				; T5 has protocol code NP.xxx
	JUMPE VL,ENDPKT		; Some form of control packet

	CAIE T5,0
	CAIN T5,NP.IP
	  JRST HAVIP

; Not IP, probably NCP

	CALL NCPPKT		; List NCP packet
	JRST ENDPKT


HAVIP:	MOVEI IPKT,PACKET+PKTELI ; Pointer to IP header



;============================================================
;============= Beginning of Packet Listing Code =============
;============================================================

; T1/	Output designator
; IPKT/	Address of first word of IP header
; VL/	Maximum # which might be in sample (-1 means use length from packet)


	LOAD PL,PIPL,-PKTELI(IPKT); Total IP packet length
	SKIPGE VL		; If sample length not known,
	  MOVE VL,PL		; Assume have whole packet

; Have an IP packet to list

HAVIP4:	CALL IPHDRL		; List IP packet

ENDPKT:	JUMPLE PL,OMITD		; Whole packet listed ? Yes
	JUMPLE VL,OMITD		; Whole packet listed ? Yes
	TXNN F,F%OMIT		; Want omitted count?
	  JRST OMITD		; No

	SSOUT <
   Omitted: >
	SOS PAGCNT

	MOVE T2,PL
	XNOUT DECRAD
OMITD:
	TXNN F,F%GB
	  CALLRET CRLF		; Omit garbage

	MOVEI PL,10000		; A large number
	HRROI T2,[ASCIZ /
   Garbage: /]
	MOVE T5,VL		; # octets remaining in sample
	CALL BOCT		; List them as garbage

	CALLRET CRLF		; Skip a line

	SUBTTL Subroutine to List Packet's Internal Data

PKTLDR:	CAML VL,[<LCLPKT-PKTELI>*4]	; Anything sampled?
	  RET				; No

	MOVX T2,<-LCLPKT+2,,PACKET+1>
	  SKIPN (T2)			; Check if anything there
	   AOBJN T2,.-1
	SKIPN (T2)			; All zeros?
	  RET				; Yes, don't bother listing zeros

	MOVE T5,FINT			; Field bits
	MOVE T4,INTTB-1			; AOBJN pointer
	CALLRET LSTHDR			; List the header


;	XX (Lnam,bit,oct,title,nam,off,fmt)

.XX=0
	-INTTL,,INTTB
INTTB:
XX (LINT,1B0,-15,<>,xxx,<
Int:>,0)

;GEN
XX (LSQUE,1B2,<<$NBQUE-PKTELI>*4>,< Q=>,NBQUE,(IPKT),<NO%MAG+NO%LFL+OCTRAD>)
XX (LBSZ,1B16,<<$NBSIZ-PKTELI>*4>,< Sz=>,NBSIZ,(IPKT),<NO%MAG+NO%LFL+DECRAD>)
XX (LPRO,1B17,<<$NBPRO-PKTELI>*4+2>,< Pr=>,NBPRO,(IPKT),<NO%MAG+NO%LFL+DECRAD>)
XX (LBNCT,1B1,<<$NBNCT-PKTELI>*4+2>,< NCT=>,NBNCT,(IPKT),<NO%MAG+NO%LFL+OCTRAD>)
XX (LPFLGS,1B12,<<PKTFLG-PKTELI>*4>,< FG=>,,PKTFLG(IPKT),<NO%MAG+NO%LFL+OCTRAD>)
;;HIP
XX (LNFC,1B19,<<$PLNFC-PKTELI>*4>,< Fc=>,PLNFC,(IPKT),<NO%MAG+NO%LFL+OCTRAD>)
;;LNC
XX (LNBZ,1B5,<<$PLNBZ-PKTELI>*4>,< LB=>,PLNBZ,(IPKT),<NO%MAG+NO%LFL+DECRAD>)
XX (LNDT,1B22,<<$PLNDT-PKTELI>*4+2>,< LD=>,PLNDT,(IPKT),<NO%MAG+NO%LFL+OCTRAD>)
XX (LNEM,1B25,<<$PLNEM-PKTELI>*4>,< EM=>,PLNEM,(IPKT),<NO%MAG+NO%LFL+DECRAD>)
XX (LNAM,1B26,<<$PLNAM-PKTELI>*4+2>,< AM=>,PLNAM,(IPKT),<NO%MAG+NO%LFL+DECRAD>)
;;LNP
XX (LHNT,1B20,<<$PLHNT-PKTELI>*4>,< Hn=>,PLHNT,(IPKT),<NO%MAG+NO%LFL+OCTRAD>)
;;TPC
XX (LTPBZ,1B27,<<$PTPBZ-PKTELI>*4>,< TB=>,PTPBZ,(IPKT),<NO%MAG+NO%LFL+DECRAD>)
XX (LTPDT,1B28,<<$PTPDT-PKTELI>*4+2>,< TD=>,PTPDT,(IPKT),<NO%MAG+NO%LFL+OCTRAD>)
;;TPP
XX (LPIPRA,1B14,<<$PIPRA-PKTELI>*4>,< IPRA=>,PIPRA,(IPKT),<NO%MAG+NO%LFL+OCTRAD>)
XX (LPLC,1B21,<<$PLPLC-PKTELI>*4>,< Lk=>,PLPLC,(IPKT),<NO%MAG+NO%LFL+DECRAD>)
XX (LHN2,1B29,<<$PLHN2-PKTELI>*4+1>,< H2=>,PLHN2,(IPKT),<NO%MAG+NO%LFL+OCTRAD>)
;;SSC
XX (LSBZ,1B30,<<$PSSBZ-PKTELI>*4>,< SB=>,PSSBZ,(IPKT),<NO%MAG+NO%LFL+DECRAD>)
XX (LSDT,1B31,<<$PSSDT-PKTELI>*4+2>,< SD=>,PSSDT,(IPKT),<NO%MAG+NO%LFL+OCTRAD>)
XX (LCNR,1B23,<<$PLNCR-PKTELI>*4>,< Cr=>,PLNCR,(IPKT),<NO%MAG+NO%LFL+OCTRAD>)
XX (LPQU,1B35,<<PKTQ-PKTELI>*4>,< Qn=>,,PKTQ(IPKT),QUEOUT)
;;SSP
XX (LSEQNF,1B8,<<$PESEQ-PKTELI>*4>,< ES/NF=>,PESEQ,(IPKT),<NO%MAG+NO%LFL+DECRAD>)
XX (LPTSRT,1B7,<<$PTS-PKTELI>*4>,< TS/TR=>,PTS,(IPKT),<NO%MAG+NO%LFL+DECRAD>)
XX (LCTPTO,1B6,<<$PDCT-PKTELI>*4>,< KL=>,PDCT,(IPKT),<NO%MAG+NO%LFL+DECRAD>)
XX (LRAXI,1B14,<<$PRXI-PKTELI>*4>,< XI/RA=>,PRXI,(IPKT),<NO%MAG+NO%LFL+OCTRAD>)
XX (LPTG,1B3,<<$PTG-PKTELI>*4>,< G=>,PTG,(IPKT),<NO%MAG+NO%LFL+DECRAD>)
XX (LPXT,1B4,<<$PXT-PKTELI>*4>,< X=>,PXT,(IPKT),<NO%MAG+NO%LFL+DECRAD>)
XX (LPMXSZ,1B13,<<$PMXSZ-PKTELI>*4>,< MX=>,PMXSZ,(IPKT),<NO%MAG+NO%LFL+DECRAD>)
XX (LBYT,1B31,<<$PLBYT-PKTELI>*4+2>,< Lb=>,PLBYT,(IPKT),<NO%MAG+NO%LFL+DECRAD>)
XX (LPHINT,1B32,<<$PHINT-PKTELI>*4>,< H1=>,PHINT,(IPKT),<NO%MAG+NO%LFL+OCTRAD>)
;;APC
XX (LPAPBZ,1B33,<<$PAPBZ-PKTELI>*4>,< AB=>,PAPBZ,(IPKT),<NO%MAG+NO%LFL+DECRAD>)
XX (LPAPDT,1B34,<<$PAPDT-PKTELI>*4+2>,< AD=>,PAPDT,(IPKT),<NO%MAG+NO%LFL+OCTRAD>)
;;SAMPKT
XX (LPFLAD,1B15,<<$PFLAD-PKTELI>*4>,< FD=>,PFLAD,(IPKT),<HPIN2>)
XX (LPLNQD,1B11,<<$PLNQD-PKTELI>*4>,< QD=>,PLNQD,(IPKT),<NO%MAG+NO%LFL+DECRAD>)
XX (LPLNDB,1B10,<<$PLNDB-PKTELI>*4>,< DB=>,PLNDB,(IPKT),<NO%MAG+NO%LFL+DECRAD>)
XX (LPLNDE,1B9,<<$PLNDE-PKTELI>*4>,< DE=>,PLNDE,(IPKT),<NO%MAG+NO%LFL+DECRAD>)

INTTL==.XX

DFINT=1B0+1B5+1B6+1B9+1B10+1B11+1B12

	SUBTTL Subroutine to Process and List Local Leader

; IPKT/	Points to local leader area in PACKET, i.e. LCLPKT
; Sets VL to # octets after local leader
; T5 has protocol code NP.xxx

PRCLCL:	MOVX T5,NP.IP		; Assume IP
	LOAD T2,DPTRC,+PPKT	; Trace code
	TXNN T2,PT%%NT		; Have local net info?
;cwl squeezing ip over local net looses PT%%NT flag bit
	  RET			; No, assume IP - return and continue

	MOVX T4,<<LCLPKT-PKTELI>,,0>	; Check for empty local leader
	HRRI T4,(IPKT)		; AOBJN pointer

	SKIPN (T4)		; Have something?
	  AOBJN T4,.-1		; Not yet
	SKIPGE T4		; Anything at all?
	 TXNN F,F%LLDR+F%NIP	; or if dont want 1822 leader
;cwl above test now failing - not getting NIP set
	  RET			; Return & continue


	MOVE T3,VERSUN		; Input trace version number
	JRST  @[IFIW LCLV0
		IFIW LCLV1
		IFIW LCLV2
		](T3)

LCLV0:
LCLV1:	LOAD T3,DPTRC,<+PPKT>	; Trace code
jfcl;	TXNE T3,PT%%NT		; Local net sample and
;	 SKIPE .NFEDH-1(IPKT)	; Doesn't look like 1822?
	 SKIPE 1(IPKT)		; Doesn't look like 1822?
	  JRST DP1822		; No
	   JRST NFEPKT		; Looks like NFE packet

LCLV2:	LOAD T3,DTYP,+PTDTA	; Get local net protocol (NL.xxx)
	CAIN T3,NL.NCP		; 1822 protocol?
	  CALLRET DP1822	; Yes
	CAIN T3,NL.NFE		; NFE protocol?
	  CALLRET NFEPKT	; Yes
	LOAD T3,DDEV,+PTDTA	; Get local net device type (NH.xxx)
	MOVE VL,TPBZ		; May be Loopback
	CAIN T3,NH.LNK		; Which leaves field blank
	  RET

	SSOUT <
Sample for unsupported type of network.>
	SETZ VL,
	RET			; Don't know

	SUBTTL	Local Leader - NL.NCP - 1822

DP1822:	ADDI IPKT,PKTELI-LCLPKT-.NBHDL	; Point to first word of local leader
	LOAD T4,IHMTY,(IPKT)		; Get 1822 message type

	TXNE F,F%LLDR			; Want local leaders listed?
	IFSKP.				; No
	  JUMPN T4,LCLQUT		; Control message, no transport data
	  MOVX T5,NP.IP			; Regular message, has transport data
	  MOVE VL,TPBZ			; Normal transport data count
	  RET
	ENDIF.
	MOVE T5,FLN			; Format bits
	MOVE T4,LN18TB-1		; AOBJN pointer for 1822 local leader
	CALL LSTHDR			; List header

	LOAD T3,IHMTY,(IPKT)		; Get 1822 message type
	JUMPN T3,LCLQUT			; All done if not Type 0

	MOVX T5,NP.IP			; Regular message, has IP
	MOVE VL,TPBZ			; Normal IP data count
	LOAD T3,IHLNK,(IPKT)		; 1822 link
	TXNE F,F%NIP			; If sample is an IP packet or
	 CAIN T3,233			; an 1822 packet on the Internet link
	  RET				; Proceed to IP code, otherwise

	MOVE VL,TPBZ			; What is there (positive from PKTELI)
	HRROI T2,[ASCIZ /
NCP no longer supported/]
	SETZ T3,
	SOUT

LCLQUT:	POP P,(P)			; Stop when return
	SETZ VL,			; Nothing more to be listed
	CALLRET CRLF

TB1822:
;0
	4,,[	-1,,[ASCIZ /Reg Std/]
		-1,,[ASCIZ /Reg Ref/]
		-1,,[ASCIZ /Reg Rdy/]
		-1,,[ASCIZ /Reg Unc/]	]
;1
	4,,[	-1,,[ASCIZ /Err FF/]
		-1,,[ASCIZ /Err lt 80/]
		-1,,[ASCIZ /Err Typ/]
		-1,,[ASCIZ /Err Ldr/]	]
;2
	-1,,[ASCIZ /IMP going down/]
;3
	-1,,[ASCIZ /3 ??/]
;4
	-1,,[ASCIZ /NOP/]
;5
	2,,[	-1,,[ASCIZ /RFNM Std/]
		-1,,[ASCIZ /RFNM Ref/]	]
;6
	20,,[	-1,,[ASCIZ /Host dead 0?/]
		-1,,[ASCIZ /Host dropped READY/]
		-1,,[ASCIZ /Host tardy/]
		-1,,[ASCIZ /Host non-ex/]
		-1,,[ASCIZ /IMP SW/]
		-1,,[ASCIZ /Host PM/]
		-1,,[ASCIZ /Host HW/]
		-1,,[ASCIZ /Host SW/]
		-1,,[ASCIZ /Host emergency restart/]
		-1,,[ASCIZ /Host power fail/]
		-1,,[ASCIZ /Host BPT/]
		-1,,[ASCIZ /Host HW failure/]
		-1,,[ASCIZ /Host not up/]
		-1,,[ASCIZ /Host down/]
		-1,,[ASCIZ /Host 14?/]
		-1,,[ASCIZ /Host coming up/]	]
;7
	4,,[	-1,,[ASCIZ /Dest IMP unreachable/]
		-1,,[ASCIZ /Dest IMP not up/]
		-1,,[ASCIZ /Dest IMP Ldr fmt/]
		-1,,[ASCIZ /Dest IMP not allowed/]	]
;8
	-1,,[ASCIZ /Error in data/]
;9
	6,,[	-1,,[ASCIZ /Incomplete, host slow/]
		-1,,[ASCIZ /Incomplete, Msg too long/]
		-1,,[ASCIZ /Incomplete, Host-IMP timeout/]
		-1,,[ASCIZ /Incomplete, Msg lost/]
		-1,,[ASCIZ /Incomplete, IMP resource timeout/]
		-1,,[ASCIZ /Incomplete, Src IMP failure/]	]

;10
	-1,,[ASCIZ /Interface reset/]
;11
	2,,[	-1,,[ASCIZ /Refused no IMP buffer/]
		-1,,[ASCIZ /Refused no IMP transmit block/]	]
;12
	6,,[	-1,,[ASCIZ /Refused 0?/]
		-1,,[ASCIZ /Refused 1?/]
		-1,,[ASCIZ /Refused no connection/]
		-1,,[ASCIZ /Refused no RA space/]
		-1,,[ASCIZ /Refused Msg # not available/]
		-1,,[ASCIZ /Refused no transaction block/]	]
;13
	-1,,[ASCIZ /Refused, still trying/]
;14
	-1,,[ASCIZ /Ready/]
;15


LNTRHF:	PUSH P,T4

	MOVE T4,T2		; IHLDF field
	SETZ T3,

	HRROI T2,[ASCIZ / Trace/]
	TRZE T4,10
	  SOUT			; List TRACE if flag set

	HRROI T2,[ASCIZ / Host/]
	TRZE T4,4
	  SOUT			; List HOST if flag set

	MOVX T3,<NO%LFL+FLD(2,NO%COL)+OCTRAD>
	SKIPE T2,T4
	 NOUT			; List other bits, if any
	  JFCL

	POP P,T4
	AOS (P)			; RETSKP
	RET


LNTST:	PUSH P,T5
	PUSH P,T4

	MOVX T2," "
	BOUT

	LOAD T4,IHSTY,(IPKT)
	LOAD T5,IHMTY,(IPKT)

	CAIL T5,17
	  JRST DP182X
	MOVE T3,TB1822(T5)
	SKIPG T2,T3
	  JRST DP182W

	HLRZS T2
	CAMLE T4,T2
	  JRST DP182X
	HRRZ T2,T3
	ADD T4,T2
	HRRO T2,(T4)
DP182W:
	SETZ T3,
	SOUT
	JRST DP182Z

DP182X:
	SSOUT <Type >

	MOVE T2,T5
	XNOUT DECRAD
	MOVX T2," "
	BOUT
	MOVE T2,T4
	XNOUT DECRAD
DP182Z:
	POP P,T4
	POP P,T5

	AOS (P)			; RETSKP
	RET


;	XX (Lnam,bit,oct,title,nam,off,fmt)

.XX=0
	-LN18TL,,LN18TB
LN18TB:
XX (LLN,1B0,-1,<>,xxx,<
Lcl:>,0)
XX (LIHFTY,1B3,-14,< Format=>,IHFTY,(IPKT),<NO%LFL+FLD(2,NO%COL)+DECRAD>)
XX(LIHNET,1B4,-13,< Hsh=>,IHNET,(IPKT),<NO%LFL+FLD(3,NO%COL)+DECRAD>)
XX (LIHLDF,1B6,-12,< Flags=>,IHLDF,(IPKT),<NO%LFL+FLD(2,NO%COL)+OCTRAD>)
XX (LIHLTF,1B7,-12,< >,IHLDF,(IPKT),LNTRHF)
XX (LIHMTY,1B12,-11,< Type=>,IHMTY,(IPKT),<NO%LFL+FLD(3,NO%COL)+DECRAD>)
XX (LIHHTY,1B13,-10,< Han=>,IHHTY,(IPKT),<NO%LFL+FLD(1,NO%COL)+DECRAD>)
XX (LIHHST,1B14,-07,< Imp=>,IHHST,(IPKT),<NO%LFL+FLD(8,NO%COL)+DECRAD>)
XX (LIHIMP,1B14,-07,,IHIMP,(IPKT),<NO%LFL+FLD(8,NO%COL)+DECRAD>)
XX (LIADDR,1B15,-13,< >,IHNET,(IPKT),HPLN)
XX (LIHLNK,1B16,-04,< Link=>,IHLNK,(IPKT),<NO%LFL+FLD(3,NO%COL)+DECRAD>)
XX (LIHMI2,1B17,-03,< Rfid=>,IHMI2,(IPKT),<NO%LFL+FLD(2,NO%COL)+DECRAD>)
XX (LIHSTY,1B18,-03,< Subt=>,IHSTY,(IPKT),<NO%LFL+FLD(2,NO%COL)+DECRAD>)
XX (LIHLEN,1B22,-02,< Bits=>,IHLEN,(IPKT),<NO%LFL+FLD(5,NO%COL)+DECRAD>)
XX (LIHNAM,1B23,-11,< >,IHMTY,(IPKT),LNTST)

LN18TL==.XX

DFLN=1B0+1B4+1B13+1B14+1B17+1B22+1B23

	SUBTTL	Transport Leader - NP.NCP - NCP (obsolete)

; IPKT/	Point at Host-Host Leader


NCPPKT:
	MOVE PL,VL			;*****
	MOVE T5,FIP			;*****
	MOVE T4,NCPFTB-1		; AOBJN pointer
	CALL LSTHDR

	HRROI T2,[ASCIZ /
NCP packet formats no longer supported/]
	SETZ T3,
	SOUT

	SETZ VL,			; No more data
	RET

;	XX (Lnam,bit,oct,title,nam,off,fmt)

.XX==0
	-NCPFTL,,NCPFTB
NCPFTB:
XX (LNCP,1B0,01,<>,xxx,<
NCP:>,0)
XX (,1B2,01,< Vr=>,PIVER,(IPKT),<NO%LFL+FLD(2,NO%COL)+DECRAD>)
NCPFTL==.XX

	SUBTTL	Local Leader - NL.NFE - Network Front End

; NFE local leader -- First word is link/size, the last word describes
; the type of packet.  If .gt. 2^24 then packet is an internet packet,
; header word is the internet address of the interface it was received on
; (11 to 10) or the Internet address of the immediate destination (10 to 11).

; If the PKTNET is 0 then PKTCMD encodes the packet type further as:
C%NOP==0  ; NOP
C%RPKT==1 ; Raw network packet, third byte is the interface number.
C%IRST==2 ; Interface reset. Byte 3  is the interface number,
;	    byte 4 is the network type code. If this command is sent
;	    from the 11 to the 10 then the packet data is the local
;	    address of the interface (size depends on the network type).
;	    If sent from the 10 to the 11 the first 32 bits of data are
;	    the internet address to be used on that front-end.
C%AERR==3 ; Address error (Interface unreachable). Probably only
;	    11 to 10. If the 3rd byte is 255 then the first 32 bits of data 
;	    are the Internet address that can't be reached, otherwise
;	    it is the interface number that is not-usable

DEFSTR	NFENET,.NFLD0,7,8	; Non-zero if internet address
DEFSTR	NFECMD,.NFLD0,15,8	; Command byte in word
DEFSTR	NFEINN,.NFLD0,23,8	; Interface number
DEFSTR	NFEITY,.NFLD0,31,8	; Network type
DEFSTR	NFEADR,.NFLD0,31,32	; Destination address

DEFSTR	NFEIAD,.NFLD0+1,31,32	; Interface address



NFEPKT:	MOVE VL,TPBZ		; Normal transport data count
	MOVX T5,NP.IP		; IP is only protocol over NFE

	LOAD T4,NFENET,(IPKT)	; Type of packet
	TXNE F,F%LLDR		; Want local leaders listed?
	IFSKP.			; No
	  JUMPE T4,NFE0IP	; Control message, no transport data
	  RET			; Regular message, has transport data
	ENDIF.

	SSOUT <
Lcl: >
	LOAD T2,NFEADR,(IPKT)	; Assume regular message
	JUMPN T4,NFEADD		; Regular message


	LOAD T4,NFECMD,(IPKT)	; Get command code

	CAIE T4,C%NOP		; Nop
	IFSKP.
	  SSOUT <NOP>
	  JRST NFEQUT
	ENDIF.

	CAIE T4,C%RPKT		; Raw packet
	IFSKP.
	  SSOUT <Raw packet from interface >
	  LOAD T2,NFEINN,(IPKT)
	  XNOUT DECRAD
	  JRST NFE0IP
	ENDIF.

	CAIE T4,C%IRST		; Reset
	IFSKP.
	  SSOUT <Interface reset on interface >
	  LOAD T2,NFEINN,(IPKT)
	  XNOUT DECRAD

	  SSOUT < for net type >
	  LOAD T2,NFEITY,(IPKT)
	  XNOUT DECRAD
	  JRST NFEQUT
	ENDIF.

	CAIE T4,C%AERR		; Address error
	IFSKP.
	  LOAD T2,NFEINN,(IPKT)
	  CAIN T2,^D255
	  IFSKP.
	    XNOUT DECRAD
	    SSOUT <Interface unusable>
	    JRST NFE0IP
	  ENDIF. 

	  SSOUT <Address unreachable >
	  LOAD T2,NFEIAD,(IPKT)
	  SETZ VL,		; No more data
NFEADD:				; VL set for return
	  SETO T3,		; T2 has address
	  CALL HNO2NA
	  MOVX T5,NP.IP		; Always IP for return
	  RET
	ENDIF.

	SSOUT <Command code >	; Otherwise
	MOVE T2,T4
	XNOUT DECRAD
NFE0IP:	SETZ VL,
	RET

NFEQUT:	SETZB PL,VL
	POP P,(P)		; Nothing more to do but
	CALLRET CRLF		; End the line

.XX=0
	-LNFNTL,,LNFNTB
LNFNTB:
XX (,1B0,01,<>,xxx,<
 Local Hdr:>,0)
XX (,1B2,01,< Format=>,IHFTY,(IPKT),<NO%LFL+FLD(2,NO%COL)+DECRAD>)
XX (,1B14,<<PKTELI-LCLPKT>*4>,< Adr=>,NFEADR,(IPKT),HPIN2)
LNFNTL==.XX

	SUBTTL	Transport Leader - NP.IP - Internet Protocol

IPHDRL:

; Reenter here for included IP packet (in ICMP packets)
; T1/ destination pointer
; VL/ octets left in sample, IPKT points to IP header

REGO:	MOVX OP,<POINT 9,(IPKT)>; Point to IP header as data
	SUBI IPKT,PKTELI	; Point to use IP header symbols

repeat 0,<	version 0 format
	loadi vl,dflag,<+0>	; length of sampled packet data
	lsh vl,2		; # bytes
> ; end of repeat 0

	LOAD TPKT,PIDO,(IPKT)	; Get IP header length
	ADDI TPKT,PKTELI(IPKT)	; Point after IP header
				; for ICMP/TCP symbols
	MOVX T2,<POINT 8,0>
	ADD T2,TPKT		; Point to ICMP/TCP header

; IPKT/	Point for IP Header
; PL/	Packet length, octets
; VL/	# octets in sample

	SKIPG VL		; Have anything at all?
	  RET			; No, give up now

	PUSH P,T2


; Compute checksum

	LOAD T2,PIDO,(IPKT)	; Find actual IP checksum
	LSH T2,2		; # octets in IP header
	LOAD T5,PICKS,(IPKT)
	SKIPE T5		; Ignore checksum if packet has zero
	 CAMLE T2,VL		; Have whole header in sample?
	IFSKP.			; Yes

	  LSH T2,-1		; # 16-bit words in IP header
	  MOVEI T4,PKTELI(IPKT)
	  HRLI T4,(POINT 16,0)	; Point to first
	  MOVNS T5		; Remove checksum from zero sum

	  DO.
	    ILDB T3,T4		; Get 16-bits
	    ADD T5,T3		; Sum them
	    SOJG T2,TOP.	; All
	  ENDDO.

	  DO.
	    MOVE T3,T5
	    ANDI T5,177777	; Fold sum into 16-bits
	    LSH T3,-20
	    ADD T5,T3
	    JUMPN T3,TOP.	; Loop if still more than 16-bits
	  ENDDO.

	  SKIPE T5		; If not zero
	    XORI T5,177777	; Complement

	  LOAD T4,PICKS,(IPKT)	; Checksum from packet
	  CAMN T5,T4		; Match computed checksum?
	  ANSKP.		; No

	    SSOUT <
	    [IP Checksum error: computed = >
	    SOS PAGCNT

	    MOVE T2,T5		; Computed value
	    XNOUT OCTRAD

	    SSOUT <, packet = >

	    MOVE T2,T4		; Packet value
	    XNOUT OCTRAD

	    SSOUT <]>
	ENDIF.
; Begin listing IP Header

	MOVX COD,XXXPKT		; Assume unknown protocol

	MOVE T5,FIP		; IP Format bits
	MOVE T4,IPFTB-1		; AOBJN pointer
	CALL LSTHDR		; List the header


repeat 0,<
	load t2,piver,(ipkt)	; list ip version #
	Xnout <no%lfl+fld(2,no%col)+octrad>

	load t2,pido,(ipkt)	; ip data offset
	movei tpkt,pkteli(ipkt)
	add tpkt,t2		; icmp/tcp header address
				; list ip data offset
	Xnout <no%lfl+fld(2,no%col)+octrad>

	load t2,piprc,(ipkt)	; list type-of-service: precedence
	Xnout <no%lfl+fld(1,no%col)+octrad>

	movx t2," "
	bout

	load t2,pildy,(ipkt)	; list type-of-service: low delay
	Xnout <no%lfl+fld(1,no%col)+octrad>

	load t2,pihtr,(ipkt)	; list type-of-service: high throughput
	Xnout <no%lfl+fld(1,no%col)+octrad>

	load t2,pihrl,(ipkt)	; list type-of-service: high reliability
	Xnout <no%lfl+fld(1,no%col)+octrad>

	load t2,pipl,(ipkt)	; list total packet length
	Xnout <no%lfl+fld(5,no%col)+octrad>

	load t2,pisid,(ipkt)	; list ip segment id
	Xnout <no%lfl+fld(6,no%col)+octrad>

	movx t2," "
	bout

	call frag		; list fragmentation information
	jfcl

	movx t2," "
	bout

	load t2,pittl,(ipkt)	; list time to line
	Xnout <no%lfl+fld(3,no%col)+octrad>

	movx t2," "
	bout

	call prot		; list protocol name/.#;set cod
	jfcl

	load t2,picks,(ipkt)	; list ip checksum
	Xnout <<no%lfl+fld(6,no%col)+octrad>>

	movx t2," "
	bout
> ; end of repeat 0


	LOAD T4,DSTAT,<+PPKT>	; Get possible TCB TSTAT word
	LOAD T5,DPTRC,<+PPKT>	; Get trace code
	TXNE T5,PT%%VH		; Valid TCB? and
	 SKIPN T4		; Non-zero TSTAT word?
	IFSKP.			; Yes to both, list it
	  CALL CRLF		; On its line
	  HRROI T2,[ASCIZ/      /]  ; Some white space
	  SOUT			; T3 already has 0 from CRLF routine
	  CALL TCBST		; Print the line
	ENDIF.

	SUBI PL,<5*4>		; # Bytes processed by
	SUBI VL,<5*4>		; IP header
	ADDI OP,5		; Point to IP options

	CALL IPOPT		; Possible IP options

	POP P,OP

; List Packet Contents

	CALL (COD)		; LIST MIN(VL,PL)OCTETS
				; MAY POP/JRST REGO
	RET

	SUBTTL List IP Fragmentation Information

FRAG:	JE <PIDF,PIMF,PIFO>,(IPKT),RETSKP ; Omit if nothing there

	SSOUT < F=>

	LOAD T3,PIDF,(IPKT)
	MOVX T2,"-"		; Minus if not fragmentation is not allowed
	CAIE T3,0		; Nothing if allowed
	  BOUT

	LOAD T3,PIMF,(IPKT)
	MOVX T2,"+"		; Plus if not last fragment of a packet
	CAIE T3,0		; Nothing if last fragment
	  BOUT

	LOAD T2,PIFO,(IPKT)
	MOVX T3,<NO%LFL+FLD(5,NO%COL)+DECRAD>
	TXNN F,F%SF		; If long format
	  TXZ T3,NO%COL		; Don't columnize
	RET			; Back for NOUT

; List Protocol Name or Number and Select Protocol Listing Routine

PROT:	MOVX T2," "
	BOUT

	LOAD T2,PIPRO,(IPKT)	; Get Protocol Number
	CAIGE T2,NCODTA		; Is it in table of known protocols?
	  JRST PRO1		; Yes
				; No, list number of protocol
	XNOUT <NO%LFL+FLD(3,NO%COL)+DECRAD>

	MOVEI COD,XXXPKT	; Use general octet listing routine
	JRST PRO2

PRO1:	MOVE COD,CODTAB(T2)	; Get known protocol listing routine
	HRROI T2,PROTAB(T2)	; List its name
	SETZ T3,
	SOUT

	JE PIFO,(IPKT),PRO2	; If have a fragment (except first)
	  MOVE COD,CODTAB-1	; Use general routine
PRO2:
RETSKP:	AOS (P)
	RET

	FRGPKT			; Routine for fragments
CODTAB:	XXXPKT			; Routines to process protocols by value
	ICMPKT
	XXXPKT
	GGPPKT
	XXXPKT
	 STPKT
	TCPPKT
	UCLPKT
	EGPPKT
	IGPPKT
	RCCPKT		; SMS - BBN-RCC-MONITORING
	XXXPKT		; NVP
	XXXPKT		; PUP
	XXXPKT		; ARGUS
	XXXPKT		; EMCON
	XXXPKT		; XNET
	XXXPKT		; CHAOS
	UDPPKT		; UDP
NCODTA==.-CODTAB

PROTAB:	ASCIZ /0   /		; Parallel Basic Protocol Name Table
	ASCIZ /1ICM/
	ASCIZ /2   /
	ASCIZ /3GGP/
	ASCIZ /4   /
	ASCIZ /5ST /
	ASCIZ /6TCP/
	ASCIZ /7UCL/
	ASCIZ /8EGP/
	ASCIZ /9IGP/
	ASCIZ /aSMS/
	ASCIZ /bNVP/
	ASCIZ /cPUP/
	ASCIZ /ARGU/
	ASCIZ /EMCO/
	ASCIZ /XNET/
	ASCIZ /CHAO/
	ASCIZ /hUDP/
IFN <.-PROTAB-NCODTA>,<PRINTX % PROTAB length different from CODTAB>

; List Host Address - Local leader, IP source/destination

HPLN:	LSH T2,30		; Net field
	PUSH P,T2
	LOAD T2,IHADR,(IPKT)	; Address within net
	ADDM T2,(P)
	JRST HPCOM

HPSRC:	LOAD T3,PSP,(TPKT)	; Assumed source port
	CAIA
HPDST:	  LOAD T3,PDP,(TPKT)	; Assumed destination port
HPIN2:	PUSH P,T2

	MOVEI T2,1(TPKT)	; Find # octets needed to get ports
	SUBI T2,PKTELI(IPKT)	; IP header+ports, words
	LSH T2,2		; Octets
	CAIE COD,TCPPKT		; TCP and
	 CAIN COD,UDPPKT	; UDP have ports
	  CAMGE VL,T2		; Have ports?
HPCOM:	   SETO T3,		; Not TCP or ports not in sample

	MOVX T2," "
	TXNE F,F%SF
	  BOUT
	TXNE F,F%SF
	  BOUT

	POP P,T2
	AOS (P)			; RETSKP
	CALLRET HNO2NA		; List host/port


CHK4:	CAIE T2,4		; Better be 4
	  TDO T5,LPIVER+LSTBIT	; Force version
	AOS (P)			; Skip return
	RET

; For T2/	nz,,x	LDB pointer
;		 0,,x	Becomes -1,,x
;
; For T3/	    0	SOUT
;		nz,,x	NOUT
;		 0,,x	CALL x
;	XX (Lnam,bit,oct,title,nam,off,fmt)

.XX==0
	-IPFTL,,IPFTB
IPFTB:
XX (LIP,1B0,01,<>,xxx,<
 IP:>,0)
XX (,1B1,01,<>,PIVER,(IPKT),CHK4)
XX (LPIVER,1B2,01,< Vr=>,PIVER,(IPKT),<NO%LFL+FLD(2,NO%COL)+DECRAD>)
XX (LPIDO,1B3,01,< Do=>,PIDO,(IPKT),<NO%LFL+FLD(2,NO%COL)+DECRAD>)
XX (LPITOS,1B4,02,< Tos=>,PIPRC,(IPKT),<NO%LFL+NO%ZRO+FLD(2,NO%COL)+OCTRAD>)
XX  (LPIPRC,1B5,02,< P=>,PIPRC,(IPKT),<NO%LFL+FLD(1,NO%COL)+DECRAD>)
XX  (LPILDY,1B6,02,< D=>,PILDY,(IPKT),<NO%LFL+FLD(1,NO%COL)+DECRAD>)
XX  (LPIHTR,1B7,02,< T=>,PIHTR,(IPKT),<NO%LFL+FLD(1,NO%COL)+DECRAD>)
XX  (LPIHRL,1B9,02,< R=>,PIHRL,(IPKT),<NO%LFL+FLD(1,NO%COL)+DECRAD>)
XX (LPIPL,1B10,04,< Ln=>,PIPL,(IPKT),<NO%LFL+FLD(5,NO%COL)+DECRAD>)
XX (LPISID,1B13,06,< ID=>,PISID,(IPKT),<NO%LFL+FLD(6,NO%COL)+DECRAD>)
XX (LPIDF,1B11,10,<>,PIDF,(IPKT),FRAG)
XX  (LPIFLG,1B14,07,< Flg=>,PIFLG,(IPKT),<NO%LFL+FLD(1,NO%COL)+OCTRAD>)
XX  (LPIMF,1B15,07,< MF=>,PIMF,(IPKT),<NO%LFL+FLD(1,NO%COL)+DECRAD>)
XX  (LPIFO,1B16,10,< FO=>,PIFO,(IPKT),<NO%LFL+FLD(5,NO%COL)+DECRAD>)
XX (LPITTL,1B17,11,< TTL=>,PITTL,(IPKT),<NO%LFL+FLD(3,NO%COL)+DECRAD>)
XX (LPIPRO,1B21,12,,PIPRO,(IPKT),PROT)
XX (LPICKS,1B22,14,< Cks=>,PICKS,(IPKT),<NO%LFL+FLD(6,NO%COL)+OCTRAD>)
XX (LPISH,1B23,20,< S=>,PISH,(IPKT),HPSRC)
XX (LPIDH,1B24,24,< D=>,PIDH,(IPKT),HPDST)
IPFTL==.XX

DFIP=1B0+1B1+1B10+1B13+1B11+1B17+1B21+1B23+1B24

	SUBTTL	Transport Leader - NP.IP - IP Options

IPOPT:	SKIPG VL		; Have anything at all?
	  RET			; No, give up now
	HRROI T2,[ASCIZ /
 IP Option: /]
	MOVEI OP,PKTELI+.IPKDH+1(IPKT) ; Address of end of minimal IP header
	MOVEI T5,(TPKT)		; Address of ICMP/TCP header
	SUB T5,OP		; # extra words in IP header
	LSH T5,2		; # bytes
	SUB VL,T5
	SUB PL,T5
	HRLI OP,(POINT 8,0)	; Point to first IP option byte
	CALLRET OPTS		; List IP options


; T2/	String pointer to title
; OP/	Byte pointer
; T5/	Byte count

OPTS:	DO.
	  SKIPG T5
	    RET			; All done
	  PUSH P,T5		; Save count

	  MOVE T3,OP		; Temp prt to read
	  ILDB T5,T3		; Option code
	  TRZ T5,CPYOPT		; Discard copy-on-fragmentation
	  PUSH P,T5		; Save Option code

	  CAIG T5,1		; MAX(ENDOPT,NOPOPT)
	   SKIPA T5,[1]		; Their length
	    ILDB T5,T3		; Length of others
	  CAMLE T5,-1(P)	; Don't process more than have
	    MOVE T5,-1(P)

	  MOVNS T5		; Decrement
	  ADDM T5,-1(P)		; remaining
	  MOVNS T5		; count

	  CALL OUTB		; Decimal option bytes
	    NO%LFL+FLD(4,NO%COL)+DECRAD
	    20

	  POP P,T3		; Option just listed
	  POP P,T5		; Remaining option bytes
	  HRROI T2,[ASCIZ /
      Next: /]
	  JUMPN T3,TOP.		; More if not ENDOPT
	ENDDO.

	HRROI T2,[ASCIZ /
   Garbage: /]
	TXNN F,F%GB		; Want to see garbage?
	IFSKP.			; Yes
	  CALL OUTB		; Octal garbage octets
	    NO%LFL+FLD(4,NO%COL)+OCTRAD
	    20
	  RET
	ENDIF.
				; No, Rest are garbage
	IFG. T5			; If not at end, move pointer
	  DO.
	    ILDB T2,OP
	    SOJG T5,TOP.
	  ENDDO.
	ENDIF.
	RET

	SUBTTL	Session Leader

; T2/	String pointer to title
; PL/	# Bytes of remaining packet data
; VL/	# Bytes of remaining sampled data
; OP/	Byte pointer to next byte


FRGPKT:	HRROI T2,[ASCIZ /
   IP Frag: /]
	CALLRET XXX

GGPPKT:	HRROI T2,[ASCIZ /
  GGP Data: /]
	CALLRET XXX
STPKT:	HRROI T2,[ASCIZ /
   ST Data: /]
	CALLRET XXX
UCLPKT:	HRROI T2,[ASCIZ /
  UCL Data: /]
	CALLRET XXX
EGPPKT:	HRROI T2,[ASCIZ /
  EGP Data: /]
	CALLRET XXX
IGPPKT:	HRROI T2,[ASCIZ /
  IGP Data: /]
	CALLRET XXX
RCCPKT:	HRROI T2,[ASCIZ /
  RCC Data: /]
	CALLRET XXX
XXXPKT:	HRROI T2,[ASCIZ /
      Data: /]
;	CALLRET XXX
XXX:	TXNN F,F%NDAT		; Want data and
	 SKIPG VL		; Have anything at all?
	  RET			; No, give up now
	SOS PAGCNT
	SKIPG T5,DATDLN		; Limit # data octets
	  MOVE T5,PL		; # Bytes to be listed
	CALL BOCT		; List all rest
	RET

	SUBTTL	Session Leader - ICMP

ICF%IDS==1B0	; Has ID & Seq
ICF%PTR==1B1	; Has Pointer
ICF%GWA==1B2	; Has Gateway address
ICF%IPP==1B3	; Has IP packet
ICF%TIM==1B4	; Has times

ICSIZ==4	; Words per entry

DEFINE ICTB (SIZ,WRD),<	LOC ..X
	WRD
..X==..X+SIZ
	LOC ..X
> ; End of DEFINE ICTB

ICMCOD:
..X==.
ICTB (ICSIZ,<EXP ^D0,0,ICF%IDS>)
ICTB (ICSIZ,<EXP ^D3,ICMUNR,ICF%IPP>)
ICTB (ICSIZ,<EXP ^D4,0,ICF%IPP>)
ICTB (ICSIZ,<EXP ^D5,ICMRED,ICF%IPP!ICF%GWA>)
ICTB (ICSIZ,<EXP ^D8,0,ICF%IDS>)
ICTB (ICSIZ,<EXP ^D11,ICMTE,ICF%IPP>)
ICTB (ICSIZ,<EXP ^D12,0,ICF%IPP!ICF%PTR>)
ICTB (ICSIZ,<EXP ^D13,0,ICF%IDS!ICF%TIM>)
ICTB (ICSIZ,<EXP ^D14,0,ICF%IDS!ICF%TIM>)
ICTB (ICSIZ,<EXP ^D15,0,ICF%IDS>)
ICTB (ICSIZ,<EXP ^D16,0,ICF%IDS>)
ICMTYP==<.-ICMCOD>/ICSIZ


ICMNAM:
ICTB (ICSIZ,<ASCIZ /Echo Reply />)
ICTB (ICSIZ,<ASCIZ /Unreachable />)
ICTB (ICSIZ,<ASCIZ /Source Quench />)
ICTB (ICSIZ,<ASCIZ /Redirect />)
ICTB (ICSIZ,<ASCIZ /Echo />)
ICTB (ICSIZ,<ASCIZ /Time Exceeded />)
ICTB (ICSIZ,<ASCIZ /Parameter Problem />)
ICTB (ICSIZ,<ASCIZ /Timestamp Request />)
ICTB (ICSIZ,<ASCIZ /Timestamp Reply />)
ICTB (ICSIZ,<ASCIZ /Info Request />)
ICTB (ICSIZ,<ASCIZ /Info Reply />)

SICMCD==4
	NICMUN
ICMUNR:
..X==.
ICTB (SICMCD,<ASCIZ / Net />)
ICTB (SICMCD,<ASCIZ / Host />)
ICTB (SICMCD,<ASCIZ / Protocol />)
ICTB (SICMCD,<ASCIZ / Port />)
ICTB (SICMCD,<ASCIZ / Frag Required />)
ICTB (SICMCD,<ASCIZ / Source Route />)
NICMUN==<.-ICMUNR>/SICMCD

	NICMRE
ICMRED:
..X==.
ICTB (SICMCD,<ASCIZ / Net />)
ICTB (SICMCD,<ASCIZ / Host />)
ICTB (SICMCD,<ASCIZ / TOS+Net />)
ICTB (SICMCD,<ASCIZ / TOS+Host />)
NICMRE==<.-ICMRED>/SICMCD

	NICMTE
ICMTE:
..X==.
ICTB (SICMCD,<ASCIZ / Packet Life />)
ICTB (SICMCD,<ASCIZ / Reassembly />)
NICMTE==<.-ICMTE>/SICMCD

ICMPKT:	SKIPG VL		; Have anything at all?
	  RET			; No, give up now
	MOVE T5,FICMP		; ICMP format bits
	MOVE T4,ICMPTB-1	; AOBJN pointer
	CALL LSTHDR

	MOVEI IPKT,.CMINH(TPKT)	; Included IP header address
	SUBI VL,4*.CMINH	; Remaining octets
	SUBI PL,4*.CMINH	; Remaining octets

	LOAD T3,CMTYP,(TPKT)	; ICMP Type
	MOVX T4,<-ICMTYP,,ICMCOD>
	DO.
	  CAMN T3,(T4)		; This it?
	    EXIT.		; Yes
	  ADDI T4,ICSIZ-1
	  AOBJN T4,TOP.		; Try next
	  CALLRET BOCT		; Just list octets
	ENDDO.

	MOVE T2,2(T4)		; Flags
	TXNN T2,ICF%IPP		; Included packet?
	  RET			; No, stop

	SSOUT <
Included Packet:>
	POP P,(P)		; Forget return for garbage
	JRST REGO		; Go do it, Then garbage

; Print name for ICMP Type/Code
; T2 has the CODE

ICMXXX:	LOAD T3,CMTYP,(TPKT)	; ICMP Type
	MOVX T4,<-ICMTYP,,ICMCOD>
	DO.
	  CAMN T3,(T4)		; This it?
	    EXIT.		; Yes
	  ADDI T4,ICSIZ-1
	  AOBJN T4,TOP.		; Try next

; Unknown TYPE

	  HRROI T2,[ASCIZ //]	; Already printed title
	  MOVE T5,PL		; Maximum length remaining
	  CALLRET XXX		; New code - octal
	ENDDO.

; Known TYPE

	SKIPE T3,1(T4)		; Code table or 0
	 CAML T2,-1(T3)		; Known code?
	IFSKP.			; Yes

; Known CODE

	  IMULI T2,SICMCD	; Words per message
	  ADDI T2,(T3)		; Plus table address
	  HRROS T2		; Into string pointer
	  SETZ T3,
	  SOUT

	  HRROI T2,ICMNAM-ICMCOD(T4) ; ICMP Type
	  SOUT
	ELSE.

; Unknown CODE

	  HRROI T2,ICMNAM-ICMCOD(T4) ; ICMP Type
	  SETZ T3,
	  SOUT

	  LOAD T2,CMCOD,(TPKT)
	  ANDN. T2		; Omit code 0
	    SSOUT <Code >
	    LOAD T2,CMCOD,(TPKT)
	    CALL DECNUM		; List decimal code
	ENDIF.

	SSOUT <  Cks = >
	LOAD T2,CMCKS,(TPKT)	; List checksum
	XNOUT OCTRAD

	MOVE T2,2(T4)		; Flags
	TXNN T2,ICF%IDS		; Have ID & SEQ?
	IFSKP.			; Yes

	  SSOUT <, ID = >
	  LOAD T2,CMID,(TPKT)	; List ID
	  CALL DECNUM

	  SSOUT <, Seq = >
	  LOAD T2,CMSEQ,(TPKT)	; List SEQ
	  CALL DECNUM
	ENDIF.

	MOVE T2,2(T4)		; Flags
	TXNN T2,ICF%PTR		; Have pointer?
	IFSKP.			; Yes
	  SSOUT <, Pointer = >
	  LOAD T2,CMPTR,(TPKT)	; List pointer
	  CALL DECNUM
	ENDIF.

	MOVE T2,2(T4)		; Flags
	TXNN T2,ICF%GWA		; Have address?
	IFSKP.			; Yesn
	  SSOUT <, Route via >
	  LOAD T2,CMGWA,(TPKT)	; List address
	  SETO T3,		; No port
	  CALL HNO2NA
	  SETZ T3,
	ENDIF.

	MOVE T2,2(T4)		; Flags
	TXNN T2,ICF%TIM		; Have timestamps?
	IFSKP.			; Yes
	  SSOUT <
          Originate = >
	  LOAD T2,CMTSO,(TPKT)
	  CALL DECNUM

	  SSOUT <, Receive = >
	  LOAD T2,CMTSR,(TPKT)
	  CALL DECNUM

	  SSOUT <, Transmit = >
	  LOAD T2,CMTST,(TPKT)
	  CALL DECNUM
	ENDIF.

	AOS (P)			; Skip return to avoid NOUT
	RET

LSTHST:	PUSH P,T2		; Save (gateway) address
	MOVX T2," "
	BOUT
	POP P,T2		; Restore (gateway) address
	SETO T3,		; No ports
	CALL HNO2NA		; List it
	AOS (P)			; Skip return
	RET


.XX=0
	-ICMPTL,,ICMPTB
ICMPTB:
XX (LICMP,1B0,01,<>,xxx,<
  ICMP Hdr:>,0)
XX (LCMTYP,1B1,01,< Type=>,CMTYP,(TPKT),<NO%LFL+FLD(3,NO%COL)+DECRAD>)
XX (LCMCOD,1B2,02,< Code=>,CMCOD,(TPKT),<NO%LFL+FLD(4,NO%COL)+DECRAD>)
XX (LCMCKS,1B3,04,< Cks=>,CMCKS,(TPKT),<NO%LFL+FLD(7,NO%COL)+OCTRAD>)
XX (LCMPTR,1B4,05,< Pntr=>,CMPTR,(TPKT),<NO%LFL+FLD(3,NO%COL)+DECRAD>)
XX (LCMGWA,1B5,10,< Gwy=>,CMGWA,(TPKT),LSTHST)
XX (LCMID,1B6,12,< Id=>,CMID,(TPKT),<NO%LFL+FLD(6,NO%COL)+DECRAD>)
XX (LCMSEQ,1B7,14,< Seq=>,CMSEQ,(TPKT),<NO%LFL+FLD(6,NO%COL)+DECRAD>)
XX (LCMTSO,1B9,14,< TSo=>,CMTSO,(TPKT),<NO%LFL+FLD(9,NO%COL)+DECRAD>)
XX (LCMTSR,1B10,20,< TSr=>,CMTSR,(TPKT),<NO%LFL+FLD(9,NO%COL)+DECRAD>)
XX (LCMTST,1B11,24,< TSt=>,CMTST,(TPKT),<NO%LFL+FLD(9,NO%COL)+DECRAD>)
XX (LCMXXX,1B17,04,<>,CMCOD,(TPKT),ICMXXX)
ICMPTL==.XX

DFICMP==1B0+1B17

	SUBTTL	Session Leader - TCP

TCPPKT:	SKIPG VL		; Have anything at all?
	  RET			; No, give up now
	MOVE T5,FTCP		; Format bits
	MOVE T4,TCPFTB-1	; AOBJN pointer
	CALL LSTHDR		; List the header

	SUBI PL,<MINTHS>	; # Bytes processed by
	SUBI VL,<MINTHS>	; TCP header
	MOVX T2,<MINTHS>
	ADJBP T2,OP
	MOVE OP,T2		; Point to TCP options (after minimal header)

; TCP Options

	CAIL PL,0
	 CAIGE VL,0
	IFNSK.
	  SETZ PL,
	  RET			; Not enough for options or data
	ENDIF.

	LOAD T2,PSP,(TPKT)	; Source port
	LOAD T5,PDP,(TPKT)	; Destination port
	PUSH P,T2
	PUSH P,T5

	LOAD T5,PTDO,(TPKT)	; TCP header length
	ADD TPKT,T5		; Point after TCP header
	LSH T5,2		; bytes
	SUBI T5,MINTHS		; # option bytes

	SUB VL,T5		; Remainder after options
	SUB PL,T5

	HRROI T2,[ASCIZ /
TCP Option: /]			; Title
	CALL OPTS		; List TCP options

	TXNE F,F%NDAT		; Want data?
	  SETZ VL,		; No

	POP P,T5		; Destination port
	POP P,T2		; Source port
	TXO F,F%TMP		; May be trouble in multiple packet byte stream
	CALL PRTCHK		; Check for special port

	HRROI T2,[ASCIZ /
  TCP Data: /]
	SKIPG T5,DATDLN		; Limit # data octets
	  MOVE T5,PL		; List all
	CALLRET TBOCT		; List them, ASCII/BINARY

	SUBTTL	Session Leader - TCP

; List TCB State

; Print the TCB SEND State
; Called with T4 containing the index into LSTT2
TCBS4S:	LDB T2,LSTT2(T4)		; Get the Send State
	AOS 0(P)			; Skip return
; Called with T2/ TCB state 0 thru 7
TCBSTS:	ADD T2,T2			; DOUBLE IT
	HRROI T2,SSTCOD(T2)		; POINTER TO SEND STATE NAME
	SETZ T3,
	SOUT				; LIST IT
	RET

; Print the TCB RECV State
; Called with T4 containing the index into LSTT2
TCBS4R:	LDB T2,LSTT2(T4)		; Get the Receive State
	AOS 0(P)			; Skip return
; Called with T2/ TCB state 0 thru 7
TCBSTR:	ADD T2,T2			; DOUBLE IT
	HRROI T2,RSTCOD(T2)		; POINTER TO RECEIVE STATE NAME
	SETZ T3,
	SOUT				; LIST IT
	RET

; Print the TERR code of the TSTAT word
TCBERR:	LDB T5,LSTT2(T4)		; Get TERR
	AOS 0(P)			; Skip return
; Here with TERR in T5
TCBER:	SKIPN T5			; Don't list 0
	IFSKP.
	  MOVE T2,T5			; Get the error code
	  XNOUT OCTRAD			; List it in octal
	  HRROI T2,[ASCIZ / (/]		; Also as a string
	  SETZ T3,
	  SOUT
	  LDB T2,[POINT 3,T5,30]  	; Get E/X L/F P/T bits
	  HRROI T2,[ASCII /XFT/
		    ASCII /XFP/
		    ASCII /XLT/
		    ASCII /XLP/
		    ASCII /EFT/
		    ASCII /EFP/
		    ASCII /ELT/
		    ASCII /ELP/](T2)	; Get the proper string
	  SOUT				; Print it
	  MOVE T2,T5			; Get the error code back
	  ANDI T2,37			; Save only the error code
	  HRRO T2,TCBERT(T2)		; Get the string
	  SOUT				; Print it
	  MOVX T2,")"
	  BOUT
	ELSE.				; Error code is 0
	  MOVX T2,"0"
	  BOUT
	ENDIF.
	RET

	; TCB TERR error strings		  Decimal Error #
TCBERT:	[ASCIZ / No Error/]				; 0
	[ASCIZ / Argument Error in JSYS/]		; 1
	[ASCIZ / Invalid Options specified/]		; 2
	[ASCIZ / Connection Not Open/]			; 3
	[ASCIZ / Temporarily Out of Resources/]		; 4
	[ASCIZ \ Wild foreign host/port not allowed\]	; 5
	[ASCIZ / Connection Already Exists/]		; 6
	[ASCIZ / Connection Rejected or Reset/]		; 7
	[ASCIZ / Undefined error = 8./]			; 8
	[ASCIZ / Transmission Timeout/]			; 9
	[ASCIZ / Undefined error = 10./]		; 10
	[ASCIZ / Undefined error = 11./]		; 11
	[ASCIZ / Connection Closed or Closing/]		; 12
	[ASCIZ / Wild local port is illegal/]		; 13
	[ASCIZ / Connection Reset/]			; 14
	[ASCIZ / Bad Buffer Argument/]			; 15
	[ASCIZ / Insufficient resources to process data buffer/]  ; 16
	[ASCIZ / Invalid interrupt channel/]		; 17
	[ASCIZ / Undefined error = 18./]		; 18
	[ASCIZ / Undefined error = 19./]		; 19
	[ASCIZ / Bad STAT offset/]			; 20
	[ASCIZ / Bad STAT count/]			; 21
	[ASCIZ / Bad STAT name/]			; 22
	[ASCIZ / Undefined error = 23./]		; 23
	[ASCIZ / Undefined error = 24./]		; 24
	[ASCIZ / Undefined error = 25./]		; 25
	[ASCIZ / Undefined error = 26./]		; 26
	[ASCIZ / Undefined error = 27./]		; 27
	[ASCIZ / Undefined error = 28./]		; 28
	[ASCIZ / Changing security levels is not allowed/]  ; 29
	[ASCIZ / Use of TCP%VT not allowed/]		; 30
	[ASCIZ / TCP not available/]			; 31

; Print the Status word of the TCB (TSTAT)
; Called with T4 containing the index into LSTT2
TCBSTA:	MOVE T4,@LSTT2(T4)		; @LDB pointer, gets whole word
	AOS 0(P)			; Skip return
	; Here with TSTAT word in T4
TCBST:	LOAD T2,TRSYN,-$TRSYN+T4	; GET RECEIVE STATE NUMBER
	CALL TCBSTR
	MOVX T2," "			; Separate with <space>
	BOUT
	LOAD T2,TSSYN,-$TSSYN+T4	; GET SEND STATE NUMBER
	CALL TCBSTS
	MOVEI T5,TCBFGT			; Address of TCB Flag Table
	CALL TCBLFG			; List it
	MOVX T2," "			; Separate with <space>
	BOUT
	LOAD T5,TERR,-$TERR+T4		; GET TERR
	IFN. T5				; Don't list 0's
	  HRROI T2,[ASCIZ /TERR=/]
	  SETZ T3,
	  SOUT
	  CALL TCBER
	ENDIF.
	RET

; List the flags in the TCBFG. format flag table
; Call:	T5/ Address of the flag table
;	T4/ The flag word

TCBLFG:	SETZ T3,			; Put 0 in T3 for SOUTs
	DO.
	  SKIPN T2,(T5)			; Get NameAddr,,MaskAddr
	    EXIT.			; If 0, all done
	  TDNN T4,(T2)			; Bit on?
	    AOJA T5,TOP.		; No, loop
	  HLROS T2			; Make -1,,NameAddr
	  SOUT				; Type the name
	  AOJA T5,TOP.			; Do the next
	ENDDO.
	RET


; Flags found the the TSTAT word of the TCB
DEFINE TCBFGS<
TCBFG.(TSRX,< RX>);;			Don't kill connection on RTX timeout
TCBFG.(TSFR,< SFR>);;			Flush RECV data after CLOSE
TCBFG.(TWFR,< WFR>);;			We did Flush RECV data after CLOSE
TCBFG.(TSFP,< FP>);;			Send force packet
TCBFG.(TSEP,< EP>);;			Send encourage packet
TCBFG.(TPOMZ,< POMZ>);;			Packet options enabled
TCBFG.(TRPP,< RPP>);;			Receive parital packet
TCBFG.(TSCR,< SCR>);;			Secure connection
TCBFG.(TTVT,< TVT>);;			TCP virtual terminal
TCBFG.(TERRT,< ERRT>);;			Error trace
TCBFG.(TDEC,< DEC>);;			DEC JSYS TCB
TCBFG.(TSTMW,< TMW>);;			Need Time Wait state
TCBFG.(TSUOP,< UOP>);;			User OPENed (1), CLOSEd (0)
TCBFG.(TSOPN,< OPN>);;			Said OPEN
TCBFG.(TSPRS,< PRS>);;			Persistent
TCBFG.(TSABT,< ABT>);;			ABORTed
TCBFG.(TSSV,< SV>);;			Send sequence valid
TCBFG.(TSURG,< SURG>);;			Send urgent mode
TCBFG.(TRURG,< RURG>);;			Receive urgent mode
> ; End DEFINE TCBFGS

; Flags found in the DEC Flags word in the TCB
DEFINE TCBDCS<
TCBFG.(TCDWT,< WT>);;			DEC Wait mode flag
TCBFG.(TCDHT,< HT>);;			DEC High Throughput Mode flag
TCBFG.(TCDFS,< FS>);;			DEC Active Flag
TCBFG.(TCDOW,< OW>);;			DEC OPENF block flag
TCBFG.(TCDGN,< GN>);;			DEC GTJFN Name done once flag
TCBFG.(TCDGE,< GE>);;			DEC GTJFN Extension done once flag
TCBFG.(TCDPS,< PS>);;			DEC Persist flag
TCBFG.(TCDOB,< OB>);;			DEC Output TJOBF buffer setup to fill
TCBFG.(TCDIB,< IB>);;			DEC Input TJIBE buffer setup to read
TCBFG.(TCDCW,< CW>);;			DEC CLOSF Block flag
TCBFG.(TCDB8,< B8>);;			DEC OPENF 8 bit byte mode
TCBFG.(TCDOQ,< OQ>);;			DEC Output buffer Queued
TCBFG.(TCDPU,< PU>);;			DEC Do a PUSH flag
TCBFG.(TCDUR,< UR>);;			DEC Do an URGENT flag
> ; End DEFINE TCBDCS


; Allocate address of the mask and the address of the ASCIZ
;  pointer to the mask description
DEFINE TCBFG.(MSK,NAM)<
XWD [ASCIZ\NAM\],[MSK];;		ASCIZ NameAddr,,MaskAddr
>

; TCB TSTAT flags word
TCBFGT:	TCBFGS				; Expand all flags
	0				; List ends with 0

; TCB DEC flags word
TCBDCT:	TCBDCS				; Expand DEC flags
	0				; List ends with 0

RSTCOD:	ASCIZ /NOTSYN/
	ASCIZ /TIMWAT/
	ASCIZ /FINRCV/
	ASCIZ /    ?3/
	ASCIZ /SYNABL/
	ASCIZ /SYNRCV/
	ASCIZ /    ?6/
	ASCIZ /SYNCED/

SSTCOD:	ASCIZ /NOTSYN/
	ASCIZ /TIMWAT/
	ASCIZ /FINSNT/
	ASCIZ /    ?3/
	ASCIZ /SYNABL/
	ASCIZ /SYNSNT/
	ASCIZ /    ?6/
	ASCIZ /SYNCED/



TESEQ:	LOAD T3,PSYN,(TPKT)	; SYN and
	ADD T2,T3
	LOAD T3,PFIN,(TPKT)	; FIN count 1
	ADD T2,T3
	LOAD T3,PTDO,(TPKT)	; Less TCP and
	LSH T3,2
	SUB T2,T3
	LOAD T3,PIDO,(IPKT)	; IP header lengths
	LSH T3,2
	SUB T2,T3
	LOAD T3,PIPL,(IPKT)	; Plus packet length
	JRST TSEQ

TSNDR:	LOAD T3,PACK,(TPKT)	; Ack valid?
	JUMPE T3,TORETS
	LOAD T3,PWNDO,(TPKT)	; Window
TSEQ:	ADD T2,T3
	MOVX T3,<NO%LFL+FLD(^D10,NO%COL)+DECRAD>
	TXNN F,F%SF		; Long or short?
	  TXZ T3,NO%COL		; Long so suppress columns
	RET			; Return to print #


QURG:	HRROI T3,[ASCIZ / Urg/]
	JRST QQQ
QACK:	HRROI T3,[ASCIZ / Ack/]
	JRST QQQ
QPSH:	HRROI T3,[ASCIZ / Psh/]
	JRST QQQ
QRST:	HRROI T3,[ASCIZ / Rst/]
	JRST QQQ
QSYN:	HRROI T3,[ASCIZ / Syn/]
	JRST QQQ
QFIN:	HRROI T3,[ASCIZ / Fin/]

QQQ:	PUSH P,T2
	MOVE T2,T3
	SETZ T3,
	SKIPE (P)		; Skip if zero
	  SOUT			; Print if non-zero
	POP P,(P)
TORETS:	AOS (P)			; RETSKP
TORET:	RET



;	XX (Lnam,bit,oct,title,nam,off,fmt)

.XX==0
	-TCPFTL,,TCPFTB
TCPFTB:
XX (LTCP,1B0,10,<>,xxx,<
TCP:>,0)  ;; Don't bother with header if don't have at least seq # to report
XX (LPSP,1B1,02,< SP=>,PSP,(TPKT),<NO%LFL+FLD(5,NO%COL)+DECRAD>)
XX (LPDP,1B2,04,< DP=>,PDP,(TPKT),<NO%LFL+FLD(5,NO%COL)+DECRAD>)
XX (LPSEQ,1B3,10,< Seq=>,PSEQ,(TPKT),<NO%LFL+FLD(^D10,NO%COL)+DECRAD>)
XX (LTESEQ,1B6,16,< ESeq=>,PSEQ,(TPKT),TESEQ)
XX (LPACKS,1B4,14,< Ack=>,PACKS,(TPKT),<NO%LFL+FLD(^D10,NO%COL)+DECRAD>)
XX (LTSNDR,1B7,20,< SR=>,PACKS,(TPKT),TSNDR)
XX (LPTDO,1B5,15,< Do=>,PTDO,(TPKT),<NO%LFL+FLD(2,NO%COL)+DECRAD>)
XX (LPTCTL,1B8,16,< CTL=>,PTCTL,(TPKT),<NO%LFL+FLD(2,NO%COL)+OCTRAD>)
;XX (LDUM0,77B14,16,,xxx,< >,0)
XX  (LPURG,1B9,16,<>,PURG,(TPKT),QURG)
XX  (LPACK,1B10,16,<>,PACK,(TPKT),QACK)
XX  (LPPSH,1B11,16,<>,PPSH,(TPKT),QPSH)
XX  (LPRST,1B12,16,<>,PRST,(TPKT),QRST)
XX  (LPSYN,1B13,16,<>,PSYN,(TPKT),QSYN)
XX  (LPFIN,1B14,16,<>,PFIN,(TPKT),QFIN)
XX (LPWNDO,1B15,20,< Wnd=>,PWNDO,(TPKT),<NO%LFL+FLD(5,NO%COL)+DECRAD>)
XX (LPTCKS,1B16,22,< Cks=>,PTCKS,(TPKT),<NO%LFL+NO%ZRO+FLD(6,NO%COL)+OCTRAD>)
XX (LPURGP,1B17,24,< Urgp=>,PURGP,(TPKT),<NO%LFL+FLD(5,NO%COL)+DECRAD>)
TCPFTL==.XX

DFTCP=1B0+1B3+1B4+1B9+1B10+1B11+1B12+1B13+1B14+1B15+1B17

	SUBTTL	Transmission Control Block - TCB

LSTTCB:

; List  TCB samples

	MOVEI IPKT,PACKET+PKTELI  ; Get TCB's starting address
	MOVE OP,[POINT 36,(IPKT)]

	MOVE VL,TPBZ		; Number of bytes in TCB
	LSH VL,-2		; Words

	LOAD T2,DTCBN,+PPKT	; Get number of words from the header
	CAMN T2,VL		; Should be the same or else a bug
	IFSKP.			;  crept in
	  PUSH P,T1
	  HRROI T1,[ASCIZ/%DTCBN and TPBZ mismatch in LSTTCB, proceeding
/]
	  PSOUT
	  POP P,T1
	ENDIF.

	LOAD T2,DTCBO,+PPKT	; Get starting offset
	MOVEM T2,STRTOF		; Save starting offset
	ADD VL,T2		; Add to the number of words
	SOS PL,VL		; VL and PL have offset of last TCB word

	MOVE T5,FTCB		; TCB format bits
	MOVE T4,TCBFTB-1	; Get the AOBJN pointer
	CALL LSTHDR
	CALLRET CRLF

	SUBTTL LSTTCB Support routines

TCBLHS:	AOS 0(P)		; Skip return
; List a host or port from the TCB
TCBLH:	LDB T4,LSTT2(T4)	; Get the Host/Port
	TXZ T4,17B3		; Shoot off the top 4 bits
	MOVX T3,DECRAD		; Print in decimal
	PUSH P,[-1]		; Flag the end of the bytes
	DO.			; Push the bytes on the stack
	  IDIVI T4,400		; Divide by 8 bits
	  PUSH P,T5		; Save the byte on the stack
	  JUMPN T4,TOP.		; Loop til 0
	ENDDO.
	DO.			; Pop and print the bytes
	  POP P,T2		; Recover the byte
	  NOUT			; Output it
	    ERJMP .+1
	  MOVX T2,"."		; Separate with "." maybe
	  SKIPL T5,(P)		; Going to hit our -1?
	    BOUT		; No, Print the "."
	  JUMPGE T5,TOP.	; If going to hit our -1, exit
	ENDDO.
	POP P,(P)		; Yes, Wipe the -1 from the stack
	RET			; Return

; List the DEC Flags from the TCB
TCBLDF:	MOVE T4,@LSTT2(T4)	; Get the DEC flags word
	MOVEI T5,TCBDCT		; Get the flags table
	CALLRET TCBLFG		; List the flags

ERRWDS==<^D80/5>+1		; This number of word for an error string

; Print a TOPS-20 error code
T20ERR:	LDB T5,LSTT2(T4)	; Get the TOPS-20 error code
	AOS 0(P)		; Skip return
	; Here with TOPS-20 error code in T5
T20ER:	SKIPN T2,T5		; List only non-0 error codes
	IFSKP.
	  XNOUT OCTRAD		; Type it in octal
	  ADJSP P,ERRWDS	; Allocate space for the error message
	  PUSH P,T1		; Save real output designator
	  MOVX T1,<POINT 7,-ERRWDS+1-1(P)>  ; Put error string here
				; NB. Allow for PUSHed output designator
	  HRLI T2,.FHSLF	; Have to use .FHSLF
	  HRR T2,T5		; Error code here
	  MOVSI T3,-<<5*ERRWDS>-1>  ; How long?
	  ERSTR
	    JRST [HRROI T1,[ASCIZ /Unknown error number/]
		  JRST T20ER0]  ; +1: Unknown
	    NOP			; +2: Not enough room, print anyway
				; +3: All ok
	  MOVX T1,<POINT 7,-ERRWDS+1(P)>  ; Get error string from here
				; NB. Pointer used after the "POP P,T2"
T20ER0:	  EXCH T1,(P)		; Restore original output designator
				; and save the error string pointer
	  HRROI T2,[ASCIZ / "/]	; Error string in quotes
	  SETZ T3,
	  SOUT
	  POP P,T2		; Get the error string pointer
	  SOUT
	  MOVX T2,""""		; End quote (")
	  BOUT
	  ADJSP P,-ERRWDS	; Deallocate space for the error message
	ENDIF.
	RET

;	XX (Lnam,bit,oct,title,nam,off,fmt)

.XX==0
	-TCBFTL,,TCBFTB
TCBFTB:
XX (LTCB,1B0,0,<>,xxx,<
TCB:>,0)
XX (,1B34,0,< Starting Offset(8)=>,DTCBO,+PPKT,<NO%LFL+FLD(3,NO%COL)+OCTRAD>)
XX (,1B35,0,<, Number of words(10)=>,DTCBN,+PPKT,<NO%LFL+FLD(3,NO%COL)+DECRAD>)
XX (LIDF,1B1,0,<>,xxx,<>,.TBIDF)
XX (LDED,1B2,0,<>,xxx,<>,.TBDED)
XX (LDEC,1B3,0,<>,xxx,<>,.TBDEC)
XX (LERR,1B4,0,<>,xxx,<>,.TBERR)
XX (LFLO,1B5,0,<>,xxx,<>,.TBFLO)
XX (LINTR,1B6,0,<>,xxx,<>,.TBINT)
XX (LOPT,1B7,0,<>,xxx,<>,.TBOPT)
XX (LRSC,1B8,0,<>,xxx,<>,.TBRSC)
XX (LRCV,1B9,0,<>,xxx,<>,.TBRCV)
XX (LRX,1B10,0,<>,xxx,<>,.TBRX)
XX (LROU,1B11,0,<>,xxx,<>,.TBROU)
XX (LSND,1B12,0,<>,xxx,<>,.TBSND)
XX (LTIM,1B13,0,<>,xxx,<>,.TBTIM)
TCBFTL==.XX

DFTCB==1B0+1B1+1B34+1B35


.TBIDF:	MOVE T5,FTBIDF		; TCB format bits
	MOVE T4,LTBIDF-1	; Get the AOBJN pointer
	AOS 0(P)		; Skip return
	CALLRET LSTHDR

.XX==0
	-TBIDFL,,LTBIDF
XX (LTBIDF,1B0,0,<>,xxx,<
 ID: >,0)
XX (LTLH,1B6,<$TLH>,< LH=>,TLH,(IPKT),TCBLHS)
XX (LTLP,1B7,<$TLP>,< >,TLP,(IPKT),TCBLHS)
XX (LTFH,1B3,<$TFH>,<  FH=>,TFH,(IPKT),TCBLHS)
XX (LTFP,1B4,<$TFP>,< >,TFP,(IPKT),TCBLHS)
XX (LTCBID,1B2,<$TCBID>,< TCBID=>,TCBID,(IPKT),<NO%LFL+FLD(6,NO%COL)+DECRAD>)
XX (LTJCNI,1B5,<$TJCN>,< JCN=>,TJCN,(IPKT),<NO%LFL+FLD(6,NO%COL)+DECRAD>)
XX (LTVTL,1B11,<$TVTL>,< TVTL=>,TVTL,(IPKT),<NO%LFL+FLD(3,NO%COL)+OCTRAD>)

XX (LTSTAT,1B10,<$TSTAT>,<
      TSTAT=>,TSTAT,(IPKT),TCBSTA)

XX (LTOWNR,1B9,<$TOWNR>,<
      JOB=>,TOWNR,(IPKT),<NO%LFL+FLD(6,NO%COL)+DECRAD>)
XX (LTCBAD,1B1,<$TCBAD>,< TCBAD=>,TCBAD,(IPKT),<NO%LFL+FLD(^D8,NO%COL)+OCTRAD>)
XX (LTOFRK,1B8,<$TOFRK>,< TOFRK=>,TOFRK,(IPKT),<NO%LFL+FLD(6,NO%COL)+OCTRAD>)

TBIDFL==.XX

DFTIDF==1B0+1B1+1B2+1B3+1B4+1B5+1B6+1B7+1B8+1B9+1B10+1B11


.TBDED:	MOVE T5,FTBDED		; Get the format bits
	MOVE T4,LTBDED-1	; Get the AOBJN pointer
	AOS 0(P)		; Skip return
	CALLRET LSTHDR

.XX==0
	-TBDEDL,,LTBDED
XX (LTBDED,1B0,0,<>,xxx,<
 DEAD:>,0)
XX (LTJCND,1B9,<$TJCN>,< JCN=>,TJCN,(IPKT),<NO%LFL+FLD(6,NO%COL)+DECRAD>)
XX (LTRSYN,1B10,<$TRSYN>,< >,TRSYN,(IPKT),TCBS4R)
XX (LTSSYN,1B12,<$TSSYN>,< >,TSSYN,(IPKT),TCBS4S)
XX (LTSCBD,1B11,<$TSCB>,< TSCB=>,TSCB,(IPKT),<NO%LFL+FLD(^D8,NO%COL)+OCTRAD>)
XX (LTSUOP,1B13,<$TSUOP>,< TSUOP=>,TSUOP,(IPKT),<NO%LFL+FLD(1,NO%COL)+OCTRAD>)

XX (LTKRBQ,1B1,<TCBRBQ>,<
      TCBRBQ=>,,TCBRBQ(IPKT),QUEOUT)

XX (LTKRPQ,1B2,<TCBRPQ>,<
      TCBRPQ=>,,TCBRPQ(IPKT),QUEOUT)

XX (LTKRXQ,1B3,<TCBRXQ>,<
      TCBRXQ=>,,TCBRXQ(IPKT),QUEOUT)

XX (LTKSBQ,1B4,<TCBSBQ>,<
      TCBSBQ=>,,TCBSBQ(IPKT),QUEOUT)

XX (LTCQDY,1B5,<TCQDY>,<
      TCQDY=>,,TCQDY(IPKT),QUEOUT)

XX (LTCQPZ,1B6,<TCQPZ>,<
      TCQPZ=>,,TCQPZ(IPKT),QUEOUT)

XX (LTCQRA,1B7,<TCQRA>,<
      TCQRA=>,,TCQRA(IPKT),QUEOUT)

XX (LTCQRX,1B8,<TCQRX>,<
      TCQRX=>,,TCQRX(IPKT),QUEOUT)

TBDEDL==.XX

DFTDED==1B0+1B1+1B2+1B3+1B4+1B5+1B6+1B7+1B8+1B9+1B10+1B11+1B12+1B13


.TBDEC:	MOVE T5,FTBDEC		; Get the format bits
	MOVE T4,LTBDEC-1	; Get the AOBJN pointer
	AOS 0(P)		; Skip return
	CALLRET LSTHDR

.XX==0
	-TBDECL,,LTBDEC
XX (LTBDEC,1B0,0,<>,xxx,<
 DEC:>,0)
XX (LTJFN,1B4,<$TJFN>,< JFN=>,TJFN,(IPKT),<NO%LFL+FLD(6,NO%COL)+OCTRAD>)
;;;	        Use any flag in the DEC flag word to locate offsets
;;;		The entire flags word is output
XX (LTBDFG,1B1,<$TCDWT>,< FLAGS=>,TCDWT,(IPKT),TCBLDF)

XX (LTCBCI,1B2,<TCBCI>,<
      TCBCI=>,,TCBCI(IPKT),<NO%LFL+FLD(^D8,NO%COL)+OCTRAD>)
XX (LTCBCO,1B3,<TCBCO>,< TCBCO=>,,TCBCO(IPKT),<NO%LFL+FLD(^D8,NO%COL)+OCTRAD>)
XX (LTJIBA,1B5,<TJIBA>,< TJIBA=>,,TJIBA(IPKT),<NO%LFL+FLD(^D8,NO%COL)+OCTRAD>)
XX (LTJIBE,1B6,<TJIBE>,< TJIBE=>,,TJIBE(IPKT),<NO%LFL+FLD(^D8,NO%COL)+OCTRAD>)
XX (LTJOBA,1B7,<TJOBA>,< TJOBA=>,,TJOBA(IPKT),<NO%LFL+FLD(^D8,NO%COL)+OCTRAD>)
XX (LTJOBF,1B8,<TJOBF>,< TJOBF=>,,TJOBF(IPKT),<NO%LFL+FLD(^D8,NO%COL)+OCTRAD>)
XX (LTPRS1,1B9,<$TPRS1>,< TPRS1=>,TPRS1,(IPKT),<NO%LFL+FLD(^D6,NO%COL)+DECRAD>)
XX(LTPRS2,1B10,<$TPRS2>,< TPRS2=>,TPRS2,(IPKT),<NO%LFL+FLD(^D6,NO%COL)+DECRAD>)

TBDECL==.XX

DFTDEC==1B0+1B1+1B2+1B3+1B4+1B5+1B6+1B7+1B8+1B9+1B10


.TBERR:	MOVE T5,FTBERR		; Get the format bits
	MOVE T4,LTBERR-1	; Get the AOBJN pointer
	AOS 0(P)		; Skip return
	CALLRET LSTHDR

.XX==0
	-TBERRL,,LTBERR
XX (LTBERR,1B0,0,<>,xxx,<
 ERR:>,0)
XX (LTERR,1B16,<$TERR>,< TERR=>,TERR,(IPKT),TCBERR)

XX (LTCERR,1B4,<$TCERR>,<
      TCERR=>,TCERR,(IPKT),T20ERR)

XX (LTABTF,1B1,<$TABTFX>,<
      TABTFX=>,TABTFX,(IPKT),
<NO%LFL+FLD(6,NO%COL)+OCTRAD>)
XX (LTCABI,1B2,<$TCABI>,< TCABI=>,TCABI,(IPKT),<NO%LFL+FLD(1,NO%COL)+OCTRAD>)
XX (LTCABR,1B3,<$TCABR>,< TCABR=>,TCABR,(IPKT),<NO%LFL+FLD(1,NO%COL)+OCTRAD>)
XX (LTCFAK,1B5,<$TCFAK>,< TCFAK=>,TCFAK,(IPKT),<NO%LFL+FLD(1,NO%COL)+OCTRAD>)
XX (LTCFWP,1B6,<$TCFWP>,< TCFWP=>,TCFWP,(IPKT),<NO%LFL+FLD(3,NO%COL)+OCTRAD>)

XX (LTCICM,1B7,<$TCICM>,<
      TCICM=>,TCICM,(IPKT),<NO%LFL+FLD(2,NO%COL)+OCTRAD>)
XX (LTCIDU,1B8,<$TCIDU>,< TCIDU=>,TCIDU,(IPKT),<NO%LFL+FLD(2,NO%COL)+OCTRAD>)
XX (LTCIPB,1B9,<$TCIPB>,< TCIPB=>,TCIPB,(IPKT),<NO%LFL+FLD(2,NO%COL)+OCTRAD>)
XX (LTCIRD,1B10,<$TCIRD>,< TCIRD=>,TCIRD,(IPKT),<NO%LFL+FLD(2,NO%COL)+OCTRAD>)
XX (LTCISQ,1B11,<$TCISQ>,< TCISQ=>,TCISQ,(IPKT),<NO%LFL+FLD(2,NO%COL)+OCTRAD>)
XX (LTCITE,1B12,<$TCITE>,< TCITE=>,TCITE,(IPKT),<NO%LFL+FLD(2,NO%COL)+OCTRAD>)

XX (LTTOSC,1B19,<$TTOSC>,<
      TTOSC=>,TTOSC,(IPKT),<NO%LFL+FLD(1,NO%COL)+OCTRAD>)
XX (LTTOSD,1B20,<$TTOSD>,< TTOSD=>,TTOSD,(IPKT),<NO%LFL+FLD(1,NO%COL)+OCTRAD>)
XX (LTTOSR,1B21,<$TTOSR>,< TTOSR=>,TTOSR,(IPKT),<NO%LFL+FLD(1,NO%COL)+OCTRAD>)
XX (LTTOST,1B22,<$TTOST>,< TTOST=>,TTOST,(IPKT),<NO%LFL+FLD(1,NO%COL)+OCTRAD>)
XX (LTTOSU,1B23,<$TTOSU>,< TTOSU=>,TTOSU,(IPKT),<NO%LFL+FLD(1,NO%COL)+OCTRAD>)
XX (LTTTL,1B24,<$TTTL>,< TTTL=>,TTTL,(IPKT),<NO%LFL+FLD(3,NO%COL)+DECRAD>)

XX (LTCPCC,1B13,<$TCPCC>,<
      TCPCC=>,TCPCC,(IPKT),<NO%LFL+FLD(1,NO%COL)+OCTRAD>)
XX (LTCRST,1B14,<$TCRST>,< TCRST=>,TCRST,(IPKT),<NO%LFL+FLD(1,NO%COL)+OCTRAD>)
XX (LTCSAG,1B15,<$TCSAG>,< TCSAG=>,TCSAG,(IPKT),<NO%LFL+FLD(1,NO%COL)+OCTRAD>)
XX (LTIFDF,1B17,<$TIFDF>,< TIFDF=>,TIFDF,(IPKT),<NO%LFL+FLD(1,NO%COL)+OCTRAD>)
XX (LTSTOE,1B18,<$TSTO>,< TSTO=>,TSTO,(IPKT),<NO%LFL+FLD(^D12,NO%COL)+DECRAD>)

TBERRL==.XX

DFTERR==1B0+1B1+1B2+1B3+1B4+1B5+1B6+1B7+1B8+1B9+1B10+1B11+1B12+1B13+1B14+1B15+1B16+1B17+1B18+1B19+1B20+1B21+1B22+1B23+1B24


.TBFLO:	MOVE T5,FTBFLO		; Get the format bits
	MOVE T4,LTBFLO-1	; Get the AOBJN pointer
	AOS 0(P)		; Skip return
	CALLRET LSTHDR

.XX==0
	-TBFLOL,,LTBFLO
XX (LTBFLO,1B0,0,<>,xxx,<
 FLO:>,0)
XX(LTFPZT,1B1,<$TCPZT>,< TCPZT=>,TCPZT,(IPKT),<NO%LFL+FLD(^D12,NO%COL)+DECRAD>)
XX(LTFSQT,1B2,<$TCSQT>,< TCSQT=>,TCSQT,(IPKT),<NO%LFL+FLD(^D12,NO%COL)+DECRAD>)
XX(LTFBYT,1B3,<$TSBYT>,< TSBYT=>,TSBYT,(IPKT),<NO%LFL+FLD(^D12,NO%COL)+DECRAD>)
XX(LTFEPT,1B4,<$TSEPT>,< TSEPT=>,TSEPT,(IPKT),<NO%LFL+FLD(^D12,NO%COL)+DECRAD>)

XX(LTSESB,1B5,<$TSESB>,<
      TSESB=>,TSESB,(IPKT),<NO%LFL+FLD(^D12,NO%COL)+DECRAD>)
XX(LTSMXB,1B6,<$TSMXB>,< TSMXB=>,TSMXB,(IPKT),<NO%LFL+FLD(^D12,NO%COL)+DECRAD>)
XX(LTFPET,1B7,<$TSPET>,< TSPET=>,TSPET,(IPKT),<NO%LFL+FLD(^D12,NO%COL)+DECRAD>)

TBFLOL==.XX

DFTFLO==1B0+1B1+1B2+1B3+1B4+1B5+1B6+1B7


.TBINT:	MOVE T5,FTBINT		; Get the format bits
	MOVE T4,LTBINT-1	; Get the AOBJN pointer
	AOS 0(P)		; Skip return
	CALLRET LSTHDR

.XX==0
	-TBINTL,,LTBINT
XX (LTBINT,1B0,0,<>,xxx,<
 PSI:>,0)
XX (LTCCIA,1B1,<$TCCIA>,< TCCIA=>,TCCIA,(IPKT),<NO%LFL+FLD(6,NO%COL)+DECRAD>)
XX (LTCCIE,1B2,<$TCCIE>,< TCCIE=>,TCCIE,(IPKT),<NO%LFL+FLD(6,NO%COL)+DECRAD>)
XX (LTCCIR,1B3,<$TCCIR>,< TCCIR=>,TCCIR,(IPKT),<NO%LFL+FLD(6,NO%COL)+DECRAD>)
XX (LTCCIS,1B4,<$TCCIS>,< TCCIS=>,TCCIS,(IPKT),<NO%LFL+FLD(6,NO%COL)+DECRAD>)
XX (LTCCIU,1B5,<$TCCIU>,< TCCIU=>,TCCIU,(IPKT),<NO%LFL+FLD(6,NO%COL)+DECRAD>)
XX (LTCCIX,1B6,<$TCCIX>,< TCCIX=>,TCCIX,(IPKT),<NO%LFL+FLD(6,NO%COL)+DECRAD>)

XX (LTPICA,1B7,<$TPICA>,<
      TPICA=>,TPICA,(IPKT),<NO%LFL+FLD(2,NO%COL)+DECRAD>)
XX (LTPICE,1B8,<$TPICE>,< TPICE=>,TPICE,(IPKT),<NO%LFL+FLD(2,NO%COL)+DECRAD>)
XX (LTPICR,1B9,<$TPICR>,< TPICR=>,TPICR,(IPKT),<NO%LFL+FLD(2,NO%COL)+DECRAD>)
XX (LTPICS,1B10,<$TPICS>,< TPICS=>,TPICS,(IPKT),<NO%LFL+FLD(2,NO%COL)+DECRAD>)
XX (LTPICU,1B11,<$TPICU>,< TPICU=>,TPICU,(IPKT),<NO%LFL+FLD(2,NO%COL)+DECRAD>)
XX (LTPICX,1B12,<$TPICX>,< TPICX=>,TPICX,(IPKT),<NO%LFL+FLD(2,NO%COL)+DECRAD>)

XX (LTPIFA,1B13,<$TPIFA>,<
      TPIFA=>,TPIFA,(IPKT),<NO%LFL+FLD(6,NO%COL)+OCTRAD>)
XX (LTPIFE,1B14,<$TPIFE>,< TPIFE=>,TPIFE,(IPKT),<NO%LFL+FLD(6,NO%COL)+OCTRAD>)
XX (LTPIFR,1B15,<$TPIFR>,< TPIFR=>,TPIFR,(IPKT),<NO%LFL+FLD(6,NO%COL)+OCTRAD>)

XX (LTPIFS,1B16,<$TPIFS>,<
      TPIFS=>,TPIFS,(IPKT),<NO%LFL+FLD(6,NO%COL)+OCTRAD>)
XX (LTPIFU,1B17,<$TPIFU>,< TPIFU=>,TPIFU,(IPKT),<NO%LFL+FLD(6,NO%COL)+OCTRAD>)
XX (LTPIFX,1B18,<$TPIFX>,< TPIFX=>,TPIFX,(IPKT),<NO%LFL+FLD(6,NO%COL)+OCTRAD>)

TBINTL==.XX

DFTINT==1B0+1B1+1B2+1B3+1B4+1B5+1B6+1B7+1B8+1B9+1B10+1B11+1B12+1B13+1B14+1B15+1B16+1B17+1B18


.TBOPT:	MOVE T5,FTBOPT		; Get the format bits
	MOVE T4,LTBOPT-1	; Get the AOBJN pointer
	AOS 0(P)		; Skip return
	CALLRET LSTHDR

.XX==0
	-TBOPTL,,LTBOPT
XX (LTBOPT,1B0,0,<>,xxx,<
 OPT:>,0)
XX (LTCBIO,1B1,<TCBIO>,< TCBIO=>,,TCBIO(IPKT),<NO%LFL+FLD(^D12,NO%COL)+OCTRAD>)
XX (LTCBIR,1B2,<TCBIR>,< TCBIR=>,,TCBIR(IPKT),<NO%LFL+FLD(^D12,NO%COL)+OCTRAD>)
XX (LTCBIU,1B3,<TCBIU>,< TCBIU=>,,TCBIU(IPKT),<NO%LFL+FLD(^D12,NO%COL)+OCTRAD>)

XX (LTCBTO,1B4,<TCBTO>,<
      TCBTO=>,,TCBTO(IPKT),<NO%LFL+FLD(^D12,NO%COL)+OCTRAD>)
XX (LTCBTR,1B5,<TCBTR>,< TCBTR=>,,TCBTR(IPKT),<NO%LFL+FLD(^D12,NO%COL)+OCTRAD>)
XX (LTCBTU,1B6,<TCBTU>,< TCBTU=>,,TCBTU(IPKT),<NO%LFL+FLD(^D12,NO%COL)+OCTRAD>)

XX (LTIOPF,1B7,<$TIOPF>,<
      TIOPF=>,TIOPF,(IPKT),<NO%LFL+FLD(6,NO%COL)+OCTRAD>)
XX (LTIPDO,1B8,<$TIPDO>,< TIPDO=>,TIPDO,(IPKT),<NO%LFL+FLD(2,NO%COL)+OCTRAD>)
XX (LTIPOR,1B9,<$TIPOR>,< TIPOR=>,TIPOR,(IPKT),<NO%LFL+FLD(2,NO%COL)+OCTRAD>)
XX (LTIPOU,1B10,<$TIPOU>,< TIPOU=>,TIPOU,(IPKT),<NO%LFL+FLD(2,NO%COL)+OCTRAD>)

XX (LTTOPF,1B11,<$TTOPF>,<
      TTOPF=>,TTOPF,(IPKT),<NO%LFL+FLD(6,NO%COL)+OCTRAD>)
XX (LTTPDO,1B12,<$TTPDO>,< TTPDO=>,TTPDO,(IPKT),<NO%LFL+FLD(2,NO%COL)+OCTRAD>)
XX (LTTPOR,1B13,<$TTPOR>,< TTPOR=>,TTPOR,(IPKT),<NO%LFL+FLD(2,NO%COL)+OCTRAD>)
XX (LTTPOU,1B14,<$TTPOU>,< TTPOU=>,TTPOU,(IPKT),<NO%LFL+FLD(2,NO%COL)+OCTRAD>)

TBOPTL==.XX

DFTOPT==1B0+1B1+1B2+1B3+1B4+1B5+1B6+1B7+1B8+1B9+1B10+1B11+1B12+1B13+1B14


.TBRSC:	MOVE T5,FTBRSC		; Get the format bits
	MOVE T4,LTBRSC-1	; Get the AOBJN pointer
	AOS 0(P)		; Skip return
	CALLRET LSTHDR

.XX==0
	-TBRSCL,,LTBRSC
XX (LTBRSC,1B0,0,<>,xxx,<
 RSC:>,0)
XX (LTCRCV,1B1,<$TCRCV>,< TCRCV=>,TCRCV,(IPKT),<NO%LFL+FLD(6,NO%COL)+DECRAD>)
XX (LTCRPC,1B2,<$TCRPC>,< TCRPC=>,TCRPC,(IPKT),<NO%LFL+FLD(6,NO%COL)+DECRAD>)
XX (LTCSND,1B3,<$TCSND>,< TCSND=>,TCSND,(IPKT),<NO%LFL+FLD(6,NO%COL)+DECRAD>)
XX (LTCSPC,1B4,<$TCSPC>,< TCSPC=>,TCSPC,(IPKT),<NO%LFL+FLD(6,NO%COL)+DECRAD>)

TBRSCL==.XX

DFTRSC==1B0+1B1+1B2+1B3+1B4


.TBRCV:	MOVE T5,FTBRCV		; Get the format bits
	MOVE T4,LTBRCV-1	; Get the AOBJN pointer
	AOS 0(P)		; Skip return
	CALLRET LSTHDR

.XX==0
	-TBRCVL,,LTBRCV
XX (LTBRCV,1B0,0,<>,xxx,<
 RCV:>,0)
XX (LTRIS,1B8,<$TRIS>,< TRIS=>,TRIS,(IPKT),<NO%LFL+FLD(^D10,NO%COL)+DECRAD>)
XX (LTRLFT,1B9,<$TRLFT>,< TRLFT=>,TRLFT,(IPKT),
<NO%LFL+FLD(^D10,NO%COL)+DECRAD>)
XX (LTRWND,1B11,<$TRWND>,< TRWND=>,TRWND,(IPKT),<NO%LFL+FLD(5,NO%COL)+DECRAD>)
XX (LTRCB,1B7,<$TRCB>,< TRCB=>,TRCB,(IPKT),<NO%LFL+FLD(^D12,NO%COL)+DECRAD>)
XX (LTCDUP,1B3,<$TCDUP>,< TCDUP=>,TCDUP,(IPKT),<NO%LFL+FLD(3,NO%COL)+DECRAD>)

XX (LTRRBQ,1B1,<TCBRBQ>,<
      TCBRBQ=>,,TCBRBQ(IPKT),QUEOUT)

XX (LTRRPQ,1B2,<TCBRPQ>,<
      TCBRPQ=>,,TCBRPQ(IPKT),QUEOUT)

XX (LTCRMQ,1B4,<$TCRMQ>,<
      TCRMQ=>,TCRMQ,(IPKT),<NO%LFL+FLD(2,NO%COL)+DECRAD>)
XX (LTCRMW,1B5,<$TCRMW>,< TCRMW=>,TCRMW,(IPKT),<NO%LFL+FLD(2,NO%COL)+DECRAD>)
XX (LTRTRA,1B6,<TCTRA>,< TCTRA=>,,TCTRA(IPKT),<NO%LFL+FLD(^D12,NO%COL)+DECRAD>)
XX (LTRURP,1B10,<$TRURP>,< TRURP=>,TRURP,(IPKT),
<NO%LFL+FLD(^D10,NO%COL)+DECRAD>)

TBRCVL==.XX

DFTRCV==1B0+1B1+1B2+1B3+1B4+1B5+1B6+1B7+1B8+1B9+1B10+1B11


.TBRX:	MOVE T5,FTBRX		; Get the format bits
	MOVE T4,LTBRX-1		; Get the AOBJN pointer
	AOS 0(P)		; Skip return
	CALLRET LSTHDR

.XX==0
	-TBRXL,,LTBRX
XX (LTBRX,1B0,0,<>,xxx,<
 RX: >,0)
XX (LTCRXF,1B1,<$TCRXF>,< TCRXF=>,TCRXF,(IPKT),<NO%LFL+FLD(6,NO%COL)+DECRAD>)
XX (LTCRXP,1B2,<$TCRXP>,< TCRXP=>,TCRXP,(IPKT),<NO%LFL+FLD(6,NO%COL)+DECRAD>)
XX (LTXTRX,1B3,<TCTRX>,< TCTRX=>,,TCTRX(IPKT),<NO%LFL+FLD(^D12,NO%COL)+DECRAD>)
XX (LTMNRT,1B4,<$TMNRT>,< TMNRT=>,TMNRT,(IPKT),
<NO%LFL+FLD(^D12,NO%COL)+DECRAD>)

XX (LTRXPD,1B5,<$TRXPD>,<
      TRXPD=>,TRXPD,(IPKT),<NO%LFL+FLD(3,NO%COL)+DECRAD>)
XX (LTRXPI,1B6,<$TRXPI>,< TRXPI=>,TRXPI,(IPKT),<NO%LFL+FLD(6,NO%COL)+DECRAD>)
XX (LTRXPN,1B7,<$TRXPN>,< TRXPN=>,TRXPN,(IPKT),<NO%LFL+FLD(3,NO%COL)+DECRAD>)
XX (LTSMRT,1B8,<$TSMRT>,< TSMRT=>,TSMRT,(IPKT),
<NO%LFL+FLD(^D12,NO%COL)+DECRAD>)
XX (LTUNRT,1B9,<$TUNRT>,< TUNRT=>,TUNRT,(IPKT),
<NO%LFL+FLD(^D12,NO%COL)+DECRAD>)

TBRXL==.XX

DFTRX==1B0+1B1+1B2+1B3+1B4+1B5+1B6+1B7+1B8+1B9


.TBROU:	MOVE T5,FTBROU		; Get the format bits
	MOVE T4,LTBROU-1	; Get the AOBJN pointer
	AOS 0(P)		; Skip return
	CALLRET LSTHDR

.XX==0
	-TBROUL,,LTBROU
XX (LTBROU,1B0,0,<>,xxx,<
 ROU:>,0)
XX (LTCRUT,1B1,<$TCRUT>,< TCRUT=>,TCRUT,(IPKT),
<NO%LFL+FLD(^D12,NO%COL)+OCTRAD>)
XX (LTSFHO,1B2,<$TSFHOP>,< TSFHOP=>,TSFHOP,(IPKT),
<NO%LFL+FLD(^D12,NO%COL)+OCTRAD>)
XX (LTSFHT,1B3,<$TSFHT>,< TSFHT=>,TSFHT,(IPKT),
<NO%LFL+FLD(^D12,NO%COL)+DECRAD>)
XX (LTSFHW,1B4,<$TSFHW>,< TSFHW=>,TSFHW,(IPKT),
<NO%LFL+FLD(^D12,NO%COL)+OCTRAD>)

TBROUL==.XX

DFTROU==1B0+1B1+1B2+1B3+1B4


.TBSND:	MOVE T5,FTBSND		; Get the format bits
	MOVE T4,LTBSND-1	; Get the AOBJN pointer
	AOS 0(P)		; Skip return
	CALLRET LSTHDR

.XX==0
	-TBSNDL,,LTBSND
XX (LTBSND,1B0,0,<>,xxx,<
 SND:>,0)
XX (LTSIS,1B9,<$TSIS>,< TSIS=>,TSIS,(IPKT),<NO%LFL+FLD(^D10,NO%COL)+DECRAD>)
XX (LTSLFT,1B11,<$TSLFT>,< TSLFT=>,TSLFT,(IPKT),
<NO%LFL+FLD(^D10,NO%COL)+DECRAD>)
XX (LTSMXS,1B12,<$TSMXS>,< TSMXS=>,TSMXS,(IPKT),<NO%LFL+FLD(6,NO%COL)+DECRAD>)
XX (LTSSEQ,1B13,<$TSSEQ>,< TSSEQ=>,TSSEQ,(IPKT),
<NO%LFL+FLD(^D12,NO%COL)+DECRAD>)
XX (LTSWND,1B16,<$TSWND>,< TSWND=>,TSWND,(IPKT),<NO%LFL+FLD(6,NO%COL)+DECRAD>)

XX (LTSRXQ,1B1,<TCBRXQ>,<
      TCBRXQ=>,,TCBRXQ(IPKT),QUEOUT)

XX (LTSSBQ,1B2,<TCBSBQ>,<
      TCBSBQ=>,,TCBSBQ(IPKT),QUEOUT)

XX (LTSTPZ,1B4,<TCTPZ>,<
      TCTPZ=>,,TCTPZ(IPKT),
<NO%LFL+FLD(^D12,NO%COL)+DECRAD>)
XX (LTSEPT,1B8,<$TSEPT>,< TSEPT=>,TSEPT,(IPKT),
<NO%LFL+FLD(^D12,NO%COL)+DECRAD>)
XX (LTSTOS,1B14,<$TSTO>,< TSTO=>,TSTO,(IPKT),<NO%LFL+FLD(^D12,NO%COL)+DECRAD>)
XX (LTCSMO,1B3,<$TCSMO>,< TCSMO=>,TCSMO,(IPKT),<NO%LFL+FLD(2,NO%COL)+DECRAD>)

XX (LTSBYT,1B5,<$TSBYT>,<
      TSBYT=>,TSBYT,(IPKT),
<NO%LFL+FLD(^D12,NO%COL)+DECRAD>)
XX (LTSCBS,1B6,<$TSCB>,< TSCB=>,TSCB,(IPKT),<NO%LFL+FLD(^D8,NO%COL)+OCTRAD>)
XX (LTSCPK,1B7,<$TSCPK>,< TSCPK=>,TSCPK,(IPKT),<NO%LFL+FLD(^D8,NO%COL)+OCTRAD>)
XX (LTSURP,1B15,<$TSURP>,< TSURP=>,TSURP,(IPKT),
<NO%LFL+FLD(^D12,NO%COL)+DECRAD>)
XX (LTSLBY,1B10,<$TSLBY>,< TSLBY=>,TSLBY,(IPKT),<NO%LFL+FLD(3,NO%COL)+OCTRAD>)

TBSNDL==.XX

DFTSND==1B0+1B1+1B2+1B3+1B4+1B5+1B6+1B7+1B8+1B9+1B10+1B11+1B12+1B13+1B14+1B15+1B16


.TBTIM:	MOVE T5,FTBTIM		; Get the format bits
	MOVE T4,LTBTIM-1	; Get the AOBJN pointer
	AOS 0(P)		; Skip return
	CALLRET LSTHDR

.XX==0
	-TBTIML,,LTBTIM
XX (LTBTIM,1B0,0,<>,xxx,<
 TIM:>,0)
XX (LTCATM,1B1,<$TCATM>,< TCATM=>,TCATM,(IPKT),
<NO%LFL+FLD(^D12,NO%COL)+DECRAD>)
XX (LTCBTP,1B2,<$TCBTP>,< TCBTP=>,TCBTP,(IPKT),
<NO%LFL+FLD(^D12,NO%COL)+DECRAD>)
XX (LTCLTM,1B3,<$TCLTM>,< TCLTM=>,TCLTM,(IPKT),
<NO%LFL+FLD(^D12,NO%COL)+DECRAD>)
XX (LTTPZT,1B4,<$TCPZT>,< TCPZT=>,TCPZT,(IPKT),
<NO%LFL+FLD(^D12,NO%COL)+DECRAD>)

XX (LTCRTM,1B5,<$TCRTM>,<
      TCRTM=>,TCRTM,(IPKT),
<NO%LFL+FLD(^D12,NO%COL)+DECRAD>)
XX (LTTSQT,1B6,<$TCSQT>,< TCSQT=>,TCSQT,(IPKT),
<NO%LFL+FLD(^D12,NO%COL)+DECRAD>)
XX (LTCTDY,1B7,<TCTDY>,< TCTDY=>,,TCTDY(IPKT),<NO%LFL+FLD(^D12,NO%COL)+DECRAD>)
XX (LTTTPZ,1B8,<TCTPZ>,< TCTPZ=>,,TCTPZ(IPKT),<NO%LFL+FLD(^D12,NO%COL)+DECRAD>)
XX (LTTTRA,1B9,<TCTRA>,< TCTRA=>,,TCTRA(IPKT),<NO%LFL+FLD(^D12,NO%COL)+DECRAD>)

XX (LTTTRX,1B10,<TCTRX>,<
      TCTRX=>,,TCTRX(IPKT),<NO%LFL+FLD(^D12,NO%COL)+DECRAD>)
XX (LTTEPT,1B11,<$TSEPT>,< TSEPT=>,TSEPT,(IPKT),
<NO%LFL+FLD(^D12,NO%COL)+DECRAD>)
XX (LTTPET,1B12,<$TSPET>,< TSPET=>,TSPET,(IPKT),
<NO%LFL+FLD(^D12,NO%COL)+DECRAD>)
XX (LTSPRB,1B13,<$TSPRB>,< TSPRB=>,TSPRB,(IPKT),
<NO%LFL+FLD(^D12,NO%COL)+DECRAD>)

TBTIML==.XX

DFTTIM==1B0+1B1+1B2+1B3+1B4+1B5+1B6+1B7+1B8+1B9+1B10+1B11+1B12+1B13

	SUBTTL	Session Leader - UDP

UDPPKT:	SKIPG VL		; Have anything at all?
	  RET			; No, give up now
	MOVE T5,FUDP		; Format bits
	MOVE T4,UDPFTB-1	; AOBJN pointer
	CALL LSTHDR		; List the header

	SUBI PL,.UDPBZ		; # Bytes processed by
	SUBI VL,.UDPBZ		; UDP header
	MOVX T2,.UDPBZ
	ADJBP T2,OP
	MOVE OP,T2		; Point after UDP header

	TXNE F,F%NDAT		; Want data?
	  SETZ VL,		; No

	LOAD T2,UDPSP,(TPKT)	; Source port
	LOAD T5,UDPDP,(TPKT)	; Destination port
	ADDI TPKT,<.UDPBZ+3>/4	; Point after UDP header
	CALL PRTCHK		; Check for special port

	HRROI T2,[ASCIZ /
  UDP Data: /]
	SKIPG T5,DATDLN		; Limit # data octets
	  MOVE T5,PL		; List all
	CALLRET TBOCT		; List them, ASCII/BINARY

.XX=0
	-UDPTL,,UDPFTB
UDPFTB:
XX (LUDP,1B0,01,<>,xxx,<
   UDP Hdr:>,0)
XX (LUDSP,1B2,02,< Src=>,UDPSP,(TPKT),<NO%LFL+FLD(6,NO%COL)+DECRAD>)
XX (LUDDP,1B3,04,< Dst=>,UDPDP,(TPKT),<NO%LFL+FLD(6,NO%COL)+DECRAD>)
XX (LUDLN,1B4,06,< Len=>,UDLEN,(TPKT),<NO%LFL+FLD(6,NO%COL)+DECRAD>)
XX (LUDCKS,1B5,10,< Cks=>,UDCKS,(TPKT),<NO%LFL+FLD(7,NO%COL)+OCTRAD>)
UDPTL==.XX

DFUDP==1B0+1B4+1B5

	SUBTTL	Application Layer

;PRTCHK	Check if a packet is using a well-known port for which specific
;	formatting information is available.

; T2/	One port
; T5/	Other port or 0
;	CALL CHKPRT
;Ret+1:	Always, as much specific information as possible (if any) has been
;	processed.  PL, VL, OP have been updated by information processed.

PRTCHK:	SKIPLE T2		; Valid port and
	 CAIL T2,^D256		; Well-known?
	  SETZ T2,		; No, nothing special
	CAIGE T5,^D256		; Well-known?
	  MOVE T2,T5		; Yes

	IFN. T2			; Have a well-known port
	  CAIN T2,^D53		; Domain?
	    CALLRET PRT53	; Yes (it returns to caller for trash at end)
; ... others here ...

	ENDIF.
	RET			; Nothing special


	SUBTTL	Port 53: Domain Service

PRT53:	SKIPG VL		; Have anything at all?
	  RET			; No, give up now

	TXNN F,F%TMP		; In a byte stream (TCP)?
	IFSKP.			; Yes
	  skipa
				; zzzz fix this up ...
	  ANSKP.
	    RET			; Don't try
	ENDIF.

	MOVE T5,FP53		; Format bits
	MOVE T4,P53FTB-1	; AOBJN pointer
;cwl have to use OP instead of TPKT ... for multiple messages not word aligned
	CALL LSTHDR		; List the header

	SUBI PL,^D<4*.DMQST>	; # Bytes processed by
	SUBI VL,^D<4*.DMQST>	; DOMAIN header
	MOVX T2,^D<4*.DMQST>
	ADJBP T2,OP
	MOVE OP,T2		; Point to question section

	TXNE F,F%NDAT		; Want data?
	  SETZ VL,		; No
ifskp.
	SKIPG T5,DATDLN		; Limit # data octets
	  MOVE T5,PL		; List all
endif.
	LOAD T3,DOMQD,(TPKT)	; # questions
	HRROI T2,[ASCIZ /
 Questions: /]
	TXO F,F%TMP		; Not resource records
	CALL PRT53R		; Output questions
	  RET			; All data processed
	TXZ F,F%TMP		; Resource records

	LOAD T3,DOMAN,(TPKT)	; # answers
	HRROI T2,[ASCIZ /
   Answers: /]
	CALL PRT53R		; Output resource records
	  RET			; All data processed

	LOAD T3,DOMNS,(TPKT)	; # NS records
	HRROI T2,[ASCIZ /
NameServer: /]
	CALL PRT53R		; Output resource records
	  RET			; All data processed

	LOAD T3,DOMAR,(TPKT)	; # additional records
	HRROI T2,[ASCIZ /
Additional: /]
	CALL PRT53R		; Output resource records
	  RET			; All data processed

	HRROI T2,[ASCIZ /
   Garbage: /]
	SKIPG T5,DATDLN		; Limit # data octets
	  MOVE T5,PL		; List all
	CALLRET TBOCT		; List them, ASCII/BINARY

;PRT53R	Output N questions/resource records

;F%TMP	0-resource records, 1-questions only
;T2/	Pointer to title
;T3/	Count
;PL,VL,OP
;	CALL PRT53R
;Ret+1:	Ran out of data
;Ret+2:	All records output. PL,VL,OP updated

PRT53R:	JUMPLE T3,TORETS		; Done if repeat count is zero
	MOVEM T3,PRT53I#		; Save count
	SETZ T3,
	SOUT%				; Output title
	DO.				; Process an entry
	  DO.				; Output Domain name
	    CALL GET8			; Get a byte
	      RET
	    IFN. T2			; Not <nil> terminator
	      CAIL T2,300		; Compressed?
	      IFSKP.			; No
	        CAILE T2,40
	         CAILE T2,175
	        IFSKP.			; Printable
	          BOUT%			; Output character
	        ELSE.			; Not printable
	          PUSH P,T2
	          MOVEI T2,"<"
	          BOUT%			; Surround octal by <...>
	          POP P,T2
	          MOVX T3,OCTRAD
	          NOUT%
	            JFCL
	          MOVEI T2,">"
	          BOUT%
	        ENDIF.
	        LOOP.			; Pack for next character
	      ENDIF.
					; Compressed
	      TXZ T2,300		; Remove compression code
	      LSH T2,10			; Rest is part of offset
	      MOVE CX,T2
	      MOVEI T2,"@"		; Compression indicator
	      BOUT%
	      CALL GET8			; Low byte of offset
	        RET
	      ADD T2,CX			; Total offset
	      XNOUT DECRAD
	      SSOUT < >			; Compressed ending
	    ELSE.			; <Nil> terminator
	      SSOUT <<0> >		; Un-compressed ending
	    ENDIF.
	  ENDDO.

	  CALL GET16			; Get 16-bit type
	    RET
	  PUSH P,T2
	  SSOUT < Type=>
	  POP P,T2
	  MOVEI T3,PRT53T
	  CALL TABLUK			; Output code

	  CALL GET16			; Get 16-bit class
	    RET
	  PUSH P,T2
	  SSOUT < Class=>
	  POP P,T2
	  MOVEI T3,PRT53C
	  CALL TABLUK			; Output code

	  TXNE F,F%TMP			; If resource record
	  IFSKP.			; Output TTL, Data len, data
	    CALL GET32			; get 32-bit TTL
	      RET
	    PUSH P,T2
	    SSOUT < TTL=>
	    POP P,T2
	    XNOUT DECRAD		; Output ttl

	    CALL GET16			; Get 16-bit data length
	      RET
	    PUSH P,T2
	    SSOUT < Len=>
	    POP P,T2
	    XNOUT DECRAD		; Output data length

	    MOVE T5,T2			; # bytes
	    HRROI T2,[ASCIZ /
            /]
	    CALL BOCT			; Output data bytes
	  ENDIF.			; Of resorce record

	  SOSG PRT53I#			; Another entry?
	  IFSKP.			; Yes
	    SSOUT <
          : >				; Title for next entry
	    LOOP.			; Back to do it
	  ENDIF.
	ENDDO.
	AOS (P)
	RET


.XX=0
	-P53TL,,P53FTB
P53FTB:
XX (LP53,1B0,01,<>,xxx,<
Domain Hdr:>,0)
XX (LP53ID,1B2,02,< ID=>,DOMID,(TPKT),<NO%LFL+FLD(6,NO%COL)+DECRAD>)
XX (LP53RP,1B3,03,<>,DOMRP,(TPKT),Q53RPY)
XX (LP53CD,1B4,03,< Fn=>,DOMCD,(TPKT),PRT53F)
XX (LP53AA,1B5,03,<>,DOMAA,(TPKT),Q53AA)
XX (LP53TC,1B6,03,<>,DOMTC,(TPKT),Q53TC)
XX (LP53RD,1B7,03,<>,DOMRD,(TPKT),Q53RD)
XX (LP53RA,1B8,04,<>,DOMRA,(TPKT),Q53AR)
XX (LP53UN,1B9,04,<>,DOMUN,(TPKT),<NO%LFL+FLD(1,NO%COL)+OCTRAD>)
XX (LP53ER,1B10,04,< Er=>,DOMRC,(TPKT),PRT53E)
XX (LP53QD,1B11,06,< Qu=>,DOMQD,(TPKT),<NO%LFL+FLD(5,NO%COL)+DECRAD>)
XX (LP53AN,1B12,10,< An=>,DOMAN,(TPKT),<NO%LFL+FLD(5,NO%COL)+DECRAD>)
XX (LP53NS,1B13,12,< NS=>,DOMNS,(TPKT),<NO%LFL+FLD(5,NO%COL)+DECRAD>)
XX (LP53AR,1B14,14,< Ad=>,DOMAR,(TPKT),<NO%LFL+FLD(5,NO%COL)+DECRAD>)
P53TL==.XX

DFP53==1B0+1B2+1B3+1B4+1B5+1B6+1B7+1B8+1B10+1B11+1B12+1B13+1B14

Q53RPY:	HRROI T3,[ASCIZ / Reply/]
	JRST QQQ
Q53AA:	HRROI T3,[ASCIZ / Auth./]
	JRST QQQ
Q53TC:	HRROI T3,[ASCIZ / Truncated/]
	JRST QQQ
Q53RD:	HRROI T3,[ASCIZ / Rec-Desired/]
	JRST QQQ
Q53AR:	HRROI T3,[ASCIZ / Rec-Available/]
	JRST QQQ

PRT53F:	MOVEI T3,F53TAB
	CALL TABLUK
	JRST TORETS

	4					; # entries
F53TAB:	-1,,[ASCIZ /Std/]			; .DMSTD==0
	-1,,[ASCIZ /Inv/]			; .DMINV==1
	-1,,[ASCIZ /Mult-Comp/]			; .DMCM==2
	-1,,[ASCIZ /Unique-Comp/]		; .DMCU==3

PRT53E:	MOVEI T3,E53TAB
	CALL TABLUK
	JRST TORETS

	6					; # entries
E53TAB:	-1,,[ASCIZ /Ok/]			; .DMEOK==0
	-1,,[ASCIZ /Format-error/]		; .DMEFE==1
	-1,,[ASCIZ /Server-failure/]		; .DMESF==2
	-1,,[ASCIZ /Name-error/]		; .DMENE==3
	-1,,[ASCIZ /Not-implemented/]		; .DMENI==4
	-1,,[ASCIZ /Refused/]			; .DMERF==5

	3					; # entries
PRT53C:	-1,,[ASCIZ /0/]
	-1,,[ASCIZ /IN/]
	-1,,[ASCIZ /CS/]

;255	-1,,[ASCIZ /*/]

	^D15					; # entries
PRT53T:	-1,,[ASCIZ /0/]
	-1,,[ASCIZ /A/]
	-1,,[ASCIZ /NS/]
	-1,,[ASCIZ /MD/]
	-1,,[ASCIZ /MF/]
	-1,,[ASCIZ /CNAME/]
	-1,,[ASCIZ /SOA/]
	-1,,[ASCIZ /MB/]
	-1,,[ASCIZ /MG/]
	-1,,[ASCIZ /MR/]
	-1,,[ASCIZ /NULL/]
	-1,,[ASCIZ /WKS/]
	-1,,[ASCIZ /PTR/]
	-1,,[ASCIZ /HINFO/]
	-1,,[ASCIZ /MINFO/]

;252	-1,,[ASCIZ /AXFR/]
;253	-1,,[ASCIZ /MAILB/]
;254	-1,,[ASCIZ /MAILA/]
;255	-1,,[ASCIZ /*/]

	SUBTTL	Subroutine to List Headers

; T5/	Format bits
; T4/	-Length,,Table

; Table entries:	one entry per header field
;	LSTBIT/	Bit corresponding to this field
;		If bit in mask is 1, the field is listed
;	LSTLTH/	Minimum VL required to insure field was sampled
;	LSTTTL/	Address of ASCIZ string for long format title
;	LSTT2/	Either:	0,,address of ASCIZ string to be listed,
;		or:	LDB pointer for datum to be listed
;	LSTT3/	Either:	0 if have string to SOUT,
;		or:	0,,address of routine to be called,
;		or:	NZ,,x	NOUT format specification
;				(columnized in short format)

LSTHDR:	SOS PAGCNT
	DO.
	  TDNN T5,LSTBIT(T4)	; Want this field
	  IFSKP.		; Yes

	    SKIPL T2,LSTLTH(T4)	; Octets needed for info to exist
	    IFSKP.
	      CAMLE VL,T2	; Have info before PKTELI?
	        JRST LSTNXT	; No
	    ELSE.
	      CAMGE T2,STRTOF	; At or beyond starting offset?
	       SKIPN T2		; No, but 0 is ok
		CAIA		; 0 or beyond starting offset
		 JRST LSTNXT
	      CAML PL,T2	; Have info after PKTELI in packet and
	       CAMGE VL,T2	; Have info after PKTELI in sample?
	        JRST LSTNXT	; No
	    ENDIF.

	    HRRO T2,LSTTTL(T4)	; Title
	    SETZ T3,
	    TXNN F,F%SF		; Long or short?
	      SOUT		; Title if long format

	    MOVX T2," "		; Space
	    MOVE T3,LSTT3(T4)	; How to print it	
	    TXNE T3,NO%LFL	; Filler?
	     TXNN F,F%SF	; Long or short?
	      CAIA		; Long or no filler
	       BOUT		; Space if short format with filler


	    MOVE T2,LSTT2(T4)	; LDB pointer or SOUT pointer?
	    TLNN T2,-1
	     TLOA T2,-1		; SOUT
	      LDB T2,T2		; LDB

; How to print it

	    SKIPE T3,LSTT3(T4)	; How to print it
	    IFSKP.		; SOUT
	      SOUT
	    ELSE.
	      TXNN F,F%SF	; Long or short?
	        TXZ T3,NO%COL	; Long so suppress columns
	      PUSH P,T4		; Save temp registers
	      PUSH P,T5
	      TLNN T3,-1	; Call or NOUT
	       CALL (T3)	; Call (RETSKPs)
	        NOUT		; NOUT
	         JFCL
	      POP P,T5		; Restore temp registers
	      POP P,T4
	    ENDIF.

LSTNXT:	  ENDIF.

	  ADDI T4,LSTSIZ-1	; Move to next entry
	  AOBJN T4,TOP.		; Back if another
	ENDDO.
	RET


;TABLUK	Print string indexed by value, or value if no string given

;T2/	Code value
;T3/	Address of table of string pointers, -1 is # entries
;	CALL TABLUK

TABLUK:	CAML T2,-1(T3)			; Valid?
	IFSKP.				; Yes
	  ADD T2,T3
	  MOVE T2,(T2)			; String pointer
	  SETZ T3,
	  SOUT				; Print it
	ELSE.
	  XNOUT DECRAD			; Invalid code, print number
	ENDIF.
	RET

	SUBTTL	Subroutines to List Data Bytes

; TBOCT	List ASCII or BINARY bytes

; T2/	String pointer to title
; T5/	# bytes to list
; PL/	# Bytes of remaining packet data
; VL/	# Bytes of remaining sampled data
; OP/	Byte pointer to next byte


TBOCT:	SKIPLE PL		; If no more bytes in packet
	 SKIPG VL		; or in sample, then
	  RET			; Done

	CAMLE T5,PL		; Min bytes to list
	  MOVE T5,PL		; against packet
	CAMLE T5,VL		; and sample lengths
	  MOVE T5,VL

	PUSH P,T5		; Save count
	CALL TOUT		; List the bytes
	POP P,T5		; Restore count

	SUB PL,T5		; Update remaining counts
	SUB VL,T5

	RET


; TOUT	Print formatted data bytes

; T2/	String pointer to title
; T5/	# bytes to list
; OP/	Byte pointer to data

; Uses
; T4/	.lt. zero, get next data byte from OP pointer
;	.ge. zero, data byte which couldn't be printed last time
; T5/	-# characters left in line,,-# bytes left to be printed

TOUT:	SKIPG T5		; If no bytes left,
	  RET			; Done

	MOVNS T5		; Negative byte count
	TLOA T4,-1		; No pre-read byte, T4 .lt. 0

; Begin line, T4 may have pre-read character, but may not be anything at all

	DO.
	    HRROI T2,[ASCIZ /
            /]			; Begin a new line
	  TRNN T5,400000	; More bytes, or
	   SKIPL T4		; Un-processed byte?
	    TDZA T3,T3		; Yes, start new line
	     JRST TOUTXT	; No, stop
	  SOUT			; Output CRLF and title
	  SOS PAGCNT
	
	  TXNE F,F%BIN		; Want Numbers?
	    JRST TOUTNM		; Yes, just numbers

	  HRLI T5,-^D66		; -Line count,,-Remaining count
	  CALL TOUTGC		; Get first character for line
	    JRST TOUTXT		; None
	    JRST TOUTSB		; Printable, begin alpha string
				; Un-printable
	  CAIE T4,15		; CR/LF treated as "ASCII"
	   CAIN T4,12
	    JRST TOUTNB		; Begin numeric string
	  CAIE T4,215
	   CAIN T4,212
	    TXNN F,F%NOPY	; Or with parity if ignoring it
	     TRNA
	      JRST TOUTNB	; Begin numeric string
	  TXNE F,F%NOPY
	   CAIE T4,211
	    CAIN T4,11		; Tab also "ASCII"
	     JRST TOUTNB	; Begin numeric string
	  TXNE F,F%TX		; Want ASCII?
	    JRST TOUTNB		; Yes, begin numeric string
	  JRST TOUTNM		; No, decide by first character


; Begin an alpha string

TOUTSB:	  MOVX T2,"{"		; Begin text
	  BOUT
	  ADD T5,[1,,0]		; Used a character position
	  DO.
	    CALL TOUTGC		; Get character
	      JRST TOUTSX	; None
	      SKIPA T2,T4	; Printable
	        JRST TOUTSE	; Un-printable, end alpha string, begin numeric
	    BOUT
	    SETO T4,		; Byte processed
	    AOBJN T5,TOP.	; Back for next
	  ENDDO.
	  SSOUT <}>		; End alpha string
	  LOOP.			; Begin new line, if needed

TOUTSE:	  SSOUT <}>		; End alpha string
	  ADD T5,[1,,0]		; Used a character in line
	  CAML T5,[-5,,0]	; Much space left?
	    LOOP.		; No, begin new line now
				; Yes, go begin numeric string
; Begin numbers

TOUTNB:	  MOVEI T2,"<"	;>	; Begin numbers
	  DO.
	    CALL TOUTGC		; Get character
	      JRST TOUTNX	; None, quit ending numeric string
	      JRST TOUTNE	; Printable, end numeric string & begin alpha
	    BOUT		; Space or begin numbers
	    MOVE T2,T4		; Datum to be formatted
	    ADD T5,T3		; Digits to be used
	    MOVX T3,<OCTRAD>	; Radix for data bytes
	    NOUT
	      JFCL
	    SETO T4,		; Byte processed
	    MOVX T2," "		; Space if another
	    AOBJN T5,TOP.	; Loop if unused characters in line  ;<
	  ENDDO.
	  MOVEI T2,">"		; End string of numbers
	  BOUT
	  LOOP.			; Begin new line, if needed

;<
TOUTNE:	  MOVEI T2,">"		; End string of numbers
	  BOUT
	  ADD T5,[1,,0]		; Used a character
	  CAML T5,[-5,,0]	; Much space left?
	    LOOP.		; No, begin new line now
	  JRST TOUTSB		; Yes, go begin alpha string
	ENDDO.			; Next line

; Everything as numbers

TOUTNM:	DO.
	  HRLI T5,-^D66		; -Line count,,-Remaining count
	  TRNA
	  DO.
	      BOUT		; Space
	    CALL TOUTGC		; Get character
	      JRST TOUTXT	; None
	      JFCL		; Printable
				; Un-printable
	    ADD T5,T3		; Digits to be used
	    MOVE T2,T4		; Data byte
	    SETO T4,		; Will be printed
	    MOVX T3,<OCTRAD>
	    NOUT
	      JFCL
	    MOVX T2," "		; Space if loop back for another
	    AOBJN T5,TOP.	; Back for next byte
	  ENDDO.
	  TRNN T5,400000	; More bytes or end of line?
	    JRST TOUTXT		; No more data, quit
	  HRROI T2,[ASCIZ /
            /]			; End of line, begin another
	  SETZ T3,
	  SOUT			; Begin new line
	  SOS PAGCNT
	  LOOP.			; Back for another line of numbers
	ENDDO.

TOUTSX:	SKIPA T2,["}"]		; Quit, ending text string
TOUTNX:	  MOVEI T2,">"		; Quit, ending numeric string
	BOUT
TOUTXT:				; Quit, ending all numeric
	HRRES T5		; Negative remaining count
	MOVNS T5		; Postitive remaining count (ought to be 0!)
	RET


; TOUTGC	Get and classify next data byte

; T2/	Unchanged
; T4/	Byte or -1
;	CALL TOUTGC
;Ret+1:	  No byte, T4/ .lt. 0
; T3/	Extra width,,0
; T4/	Byte
;Ret+2:	  Printable ASCII
;Ret+3:	Unprintable ASCII

TOUTGC:	SKIPL T4		; Any pre-read byte?
	IFSKP.			; No, get another
	  TRNN T5,400000	; More bytes to be read?
	    RET		;+1	; No, stop
	  ILDB T4,OP		; Get next byte
	ENDIF.
	AOS (P)			; Will return +2 or +3
	MOVE T3,[1,,0]		; Digit
	CAIL T4,10
	  ADD T3,[1,,0]		; Two digits
	CAIL T4,100
	  ADD T3,[1,,0]		; Three digits
	CAIL T4,40
	 CAILE T4,176
	  TRNA
	   RET		;+2	; Printable ASCII
	CAIL T4,240
	 CAILE T4,376
	  TRNA			; Not printable ascii with parity
	   TXNN F,F%NOPY	; Accept with parity bit?
	    AOS (P)	;+3	; Not printable ASCII, will return +3
	RET		;+2	; Printable ASCII

; BOCT	List up to 16. BINARY bytes per line

; T2/	String pointer to title
; PL/	# Bytes of remaining packet data
; VL/	# Bytes of remaining sampled data
; OP/	Byte pointer to next byte


BOCT:	SKIPLE PL		; If no more bytes in packet
	 SKIPG VL		; or in sample, then
	  RET			; Done

	CAMLE T5,PL		; Min bytes to list
	  MOVE T5,PL		; against packet
	CAMLE T5,VL		; and sample lengths
	  MOVE T5,VL

	PUSH P,T5		; Save count
	CALL OUTB		; List the bytes
	  NO%LFL+FLD(4,NO%COL)+OCTRAD
	  20
	POP P,T5		; Restore count

	SUB PL,T5		; Update remaining counts
	SUB VL,T5
	RET


; DECNUM	List a DECIMAL byte

; T2/	Byte to be listed

DECNUM:	XNOUT DECRAD
	MOVX T2,"."
	BOUT
	SETZ T3,
	RET

; OUTB	List BINARY bytes

; T2/	String pointer to title
; T5/	# Bytes to list
; OP/	Byte pointer to next byte
;	CALL OUTB
;	  NOUT Format word
;	  # bytes per line

OUTB:	DO.
	  SKIPG T5		; Any more to list?
	    RET			; No, Done

	  SETZ T3,		; Output title
	  SOUT
	  SOS PAGCNT

	  MOVNS T5		; Negative remaining byte count
	  MOVE T3,(P)		; Address of arguments
	  MOVN T3,1(T3)		; Bytes per line
	  CAMGE T5,T3		; More than a line?
	  IFSKP.
	    HRL T5,T5		; No
	  ELSE.
	    HRL T5,T3		; Yes
	  ENDIF.

	  MOVE T3,@(P)		; Format argument
	  DO.
	    ILDB T2,OP		; Get byte
	    NOUT		; List it
	      MOVE T3,@(P)	; Format again
	    AOBJN T5,TOP.	; Back for next
	  ENDDO.

	  HRROI T2,[ASCIZ /
            /]
	  HRRES T5		; Negative remaining bytes
	  MOVNS T5		; Positive remaining bytes
	  JUMPG T5,TOP.		; Do it again
	ENDDO.
	AOS (P)			; Skip args
	AOS (P)
	RET


;GETnn	Get nn bits of data

;OP/	Pointer to data
;	CALL GETnn
;Ret+1:	Insufficient data
;Ret+2:	T2/ nn-bit number

GET32:	CAIL VL,4
	 CAIGE PL,4
	  RET
	CALL GET16
	  RET
	LSH T2,20
	MOVE T4,T2
	CALL GET16
	  RET
	ADD T2,T4
	AOS (P)
	RET

GET16:	CAIL VL,2
	 CAIGE PL,2
	  RET
	CALL GET8
	  RET
	MOVE CX,T2
	LSH CX,10
	CALL GET8
	  RET
	ADD T2,CX
	AOS (P)
	RET

GET8:	SOJL VL,TORET
	SOJL PL,TORET
	ILDB T2,OP
	AOS (P)
	RET


CRLF:	HRROI T2,[ASCIZ /
/]
	SETZ T3,		; End line
	SOUT
	SOS PAGCNT		; Count line
	RET


PAGHED:	BYTE (7)14,15,12,40,40
	ASCIZ /[/

;============================================================
;================ End of Packet Listing Code ================
;============================================================

;============================================================
;==================== End of LIST Command ===================
;============================================================


;============================================================
;============= Start of Driver Utilization Code =============
;============================================================

HDRVU:	ASCIZ /The Driver-Utilization function analyzes the usage of
one of the network interfaces based on samples from a packet trace./

.DRVU.:	MOVEI T2,[FLDDB.(.CMNOI,CM%SDH,<POINT 7,[ASCIZ /for driver/]>)]
	CALL CCOMND
	MOVEI T2,[FLDDB.(.CMNUM,,DECRAD,,<0>)]
	CALL CCOMND
	MOVE T5,T2		; Save driver
	CALL CCMCFM		; Confirm DRIVER-UTILIZATION

	SKIPL T5		; Remain same?
	  MOVEM T5,DEVPR	; No, set desired driver
	MOVEM FCT,FUNCT		; Save address
	RET


; Overall initialization

DRUINI:	MOVE T1,[HIST,,HISIDL]
	BLT T1,HISIDL+HISTE-HIST-1	; Initialize idle time array

	MOVE T1,[HIST,,HISBSY]
	BLT T1,HISBSY+HISTE-HIST-1	; Initialize busy time array

	MOVE T1,[HIST,,HISQUE]
	BLT T1,HISQUE+HISTE-HIST-1	; Initialize total queued time array

	MOVE T1,[HIST,,HISBLK]
	BLT T1,HISBLK+HISTE-HIST-1	; Initialize blocked time array

	MOVE T1,[HISTL,,HISLEN]
	BLT T1,HISLEN+HISTLE-HISTL-1	; Initialize packet length array

	MOVE T1,[DEVTB0,,DEVTAB]
	BLT T1,DEVLEN+DEVTAB-1		; Initialize device array

	CALL SCAINI			; Initialize scattergram

	SETZM NPKTN
	SETZM SMPCNT
	SETZM STBSY
	SETZM PPLNQD	
	SETZM TBASE
	SETZM VMAXR
	SETZM HMAXR

	CALL XRTINI			; Initialize

	TXNE F,F%NDAT			; Want detail data?
	IFSKP.				; Yes
	  MOVE T1,JFNO
	  TXNE F,F%SF			; Want graph?
	  IFSKP.			; No
	    SKIPL DEVPR			; Interface already specified?
	      CALL PRTDEV		; Yes, print titles
	  ENDIF.
	ENDIF.
	RET

;Per-sample processing

	FLD(^D7,OF%BSZ)+OF%RD+OF%WR+OF%APP ; Output file size
	SETOM DEVPR			; Grand init - No current device
	CALL .DRVU.
	CALL DRUINI			; Initialization routine
	CALL DRUPRT			; Post-processing routine
.DRVU:
	TXNE F,F%EOF			; Seen EOF?
	  RET				; Yes, NPACKET is empty here

	LOAD T3,DPTRC,+NPTDTA		; trace code & flags
	CAME T3,DRVUCD			; Do we want record for this process?
jfcl;	  RET				; No; read next record
	LOAD T3,NBNCT,+NPACKET		; get NCT address
	HRRZS T3	

	LOAD T3,DDEV,+NPTDTA		; Get hardware device code, NH.xxx
	CALL CEKDEV
	SKIPL T3			; Make sure have one
	 CAME T3,DEVPR			; This interface one being processed?
	  RET				; No, skip it

	AOS SMPCNT			; Count samples processed

	LOAD T4,PTPBZ,+NPACKET		; packet size
	LOAD T1,DPRO,+NPTDTA		; Protocol code, NP.xxx
	LOAD T2,PIPL,+NPACKET		; IP length
;fix NP.IP
	CAIE T1,0
	 CAIN T1,4
	  SKIPA T4,T2			; IP
	   SETZ T4,			; Probably control, no length
	MOVEM T4,TNBSIZ			; store it away

	LOAD TQD,PLNQD,+NPACKET		; Time packet queued for net
	LOAD TDB,PLNDB,+NPACKET		; Time driver began
	LOAD TDE,PLNDE,+NPACKET		; Time driver ended

	TXNE F,F%NDAT			; Want detail data?
	IFSKP.				; Yes
	  TXNN F,F%SF			; Want graph?
	  IFSKP.			; Yes
	    MOVE T1,JFNO		; Output file
	    DO.
	      SKIPG TBASE		; First time?
	        CALL DRUNUP		; Begin new page
	      MOVE T2,TDB		; Absolute time
	      SUB T2,TBASE		; Relative time
	      CAMLE T2,VMAXR
	        MOVEM T2,VMAXR
DRUVSC:	      XCT VXCT			; Scale it
jfcl;	      ADD T2,VBASE		; Within margin
	      CAMG T2,VMAX		; Check for too large
	      IFSKP.			; Too big, need new page
	        SSOUT <^IJ00500^IT00500^-^PN^-

>					; End page
	        SETZM TBASE
	        LOOP.
	      ENDIF.

	    ENDDO.
	    PUSH P,T2			; Save vertical position
	    SSOUT <^JM>			; Vertical position, rel to margin
	    POP P,T2
	    XNOUT <NO%LFL+NO%ZRO+FLD(^D5,NO%COL)+DECRAD>
	    SSOUT <^T>			; Horizontal position, rel to margin
	    MOVE T2,TDE			; Driver end less
	    SUB T2,TDB			; Driver begin is busy time
	    IMULI T2,^D1000		; Micro seconds
	    IDIV T2,TNBSIZ		; Microseconds per byte
	    LSH T3,1
	    CAML T3,TNBSIZ		; Need to round up?
	      ADDI T2,1			; Yes
	    CAMLE T2,HMAXR
	      MOVEM T2,HMAXR
DRUHSC:	    XCT HXCT			; Scale it
jfcl;	    ADD T2,HBASE		; Within margin
	    CAML T2,HMAX		; Too large?
	      MOVE T2,HMAX		; Yes, clamp

	    XNOUT <NO%LFL+NO%ZRO+FLD(^D5,NO%COL)+DECRAD>
	    SSOUT <^LB0003000030010010^-> ; Draw a box there
	  ELSE.				; Not want graph
	    PUSH P,T1
	    PUSH P,T3
	    MOVE T1,JFNO		; Output file
	    MOVE T2,NPKTN		; Sample number
	    XNOUT <NO%LFL+FLD(^D6,NO%COL)+DECRAD>
	    LOAD T2,DTIME,+NPTDTA	; Time of sample
	    XNOUT <NO%LFL+FLD(^D12,NO%COL)+DECRAD>
	    POP P,T2			; Driver code, NH.xxx
	    XNOUT <NO%LFL+FLD(^D3,NO%COL)+DECRAD>
	    POP P,T2			; Protocol code, NP.xxx

	    XNOUT <NO%LFL+FLD(^D3,NO%COL)+DECRAD>
	    MOVE T2,T4			; Packet length
	    XNOUT <NO%LFL+FLD(^D5,NO%COL)+DECRAD>
	    MOVE T2,TQD			; Packet queued
	    XNOUT <NO%LFL+FLD(^D12,NO%COL)+DECRAD>
	    MOVE T2,TDB			; Driver began
	    XNOUT <NO%LFL+FLD(^D12,NO%COL)+DECRAD>
	    MOVE T2,TDE			; Driver finished
	    XNOUT <NO%LFL+FLD(^D12,NO%COL)+DECRAD>
	    MOVE T2,TDE			; Driver busy
	    SUB T2,TDB
	    XNOUT <NO%LFL+FLD(^D6,NO%COL)+DECRAD>
	    TXNN F,F%FILP		; Want FILE POSITION?
	    IFSKP.
	      MOVE T2,NFLBYT		; Position of packet
	      XNOUT <NO%LFL+FLD(^D6,NO%COL)+DECRAD>
	    ENDIF.
	  ENDIF.			; End of not graph
	  CALL CRLF
	ENDIF.

	MOVE T4,TNBSIZ			; Packet length
	MOVEI T3,HISLEN
	INHIST (,,T4,T3,T2)		; Histogram length

	MOVE T4,TDB
	SUB T4,TQD			; Time waiting in output queue
	CALL QUEPR			; histogram queued time
		
	MOVE T4,TDE
	SUB T4,TDB			; time driver busy
	CALL BUSYPR

	MOVE T4,PPLNQD	
	IFE. T4				; previous que time zeros? (1st record)
	  MOVEM TDB,STBSY		; store start continuously busy
	ELSE.
	  MOVE T4,TDB
	  SUB T4,PPLNDE			; time driver idle
	  CAIG T4,1			; driver continuosly busy?
	   AOSA TMPBSY			; yes, increment temp busy
	    CALL IDLEPR			; no, some idle time
	ENDIF.

	MOVEM TQD,PPLNQD		; store previous queue time
	MOVEM TDB,PPLNDB		; store previous begin time
	MOVEM TDE,PPLNDE		; store previous end time
	RET

DRUNUP:	MOVEM TDB,TBASE			; Init base
	SSOUT <
^PY^-
^F^IB11000^IJ00500^IT00500^LS0750000010^IJ00500^IT00500^LS0001010000^-
>;QUIC on,free,bot,top,lft,hor axis,    org,            ver axis
	RET

; Post processing routines

DRUPRT:	MOVEI T1,2		; Do the output side
	CALL XRTCMP		; Compute m (slope) and b (y intercept)
	HRRZ T1,JFNO		; Output designator

	TXNN F,F%NDAT		; Want detail data and
	 TXNN F,F%SF		; Graphing?
	IFSKP.			; Yes
	  SSOUT <^IJ00500^IT00500^-^PN^-
>					; End page, leave QUIC mode
	ENDIF.

	SSOUT <

>
  	MOVEI T2,2		; Do the output side
	CALL XRTPRT		; Print it

	HRRZ T1,JFNO
	SSOUT <

**Process Totals:	>

	SSOUT <
    Total Records Read:	>
	MOVE T2,NPKTN		;total number records
	XNOUT <NO%LFL+FLD(6,NO%COL)+DECRAD>

	SSOUT <
    Records Processed:	>
	MOVE T2,SMPCNT		;total number Accepted records
	XNOUT <NO%LFL+FLD(6,NO%COL)+DECRAD>

	HRROI T2,[ASCIZ/

Idle Time:
  Total Idle Time: /]
	MOVEI HST,HISIDL		; idle time array address
	CALL STHIST			; print histogram
;end idle display

	HRROI T2,[ASCIZ/

Busy Time:
  Total Busy Time: /]
	MOVEI HST,HISBSY		; busy time table address
	CALL STHIST			; print histogram
;end busy display

	HRROI T2,[ASCIZ/

Queued Time:
  Total Queued Time: /]
	MOVEI HST,HISQUE		; busy time table address
	CALL STHIST			; print histogram
;end queued display

	HRROI T2,[ASCIZ/

Packet Length:
  Total Bytes Sent: /]
	MOVEI HST,HISLEN		; packet length table address
	CALL LNHIST			; print histogram

	SSOUT <

Packets per Device:
>
	MOVN T4,DEVTAB			; # buckets
	HRLZS T4
	DO.
	  SKIPN DEVTAB+3(T4)		; Any for this device?
	  IFSKP.			; Yes
	    HRRZ T2,T4			; Code
	    XNOUT <NO%LFL+FLD(^D6,NO%COL)+DECRAD>
	    MOVE T2,DEVTAB+3(T4)	; Count
	    XNOUT <NO%LFL+FLD(^D8,NO%COL)+DECRAD>
	    CALL CRLF
	  ENDIF.
	  AOBJN T4,TOP.			; Back for next
	ENDDO.

	MOVE T1,JFNO
	MOVEI T2,1			; Output side
	CALL SCAPRT			; Print scattergram

	CALLRET STATOF			; Also include normal summary


; Subroutines

;QUEPR	Called to total queued time.
; checks block possibilities ( was record queued before any previous
; packet was queued, was packet queued before any previous idle time

;T4/	queued time (driver begin time less time packet queued)

QUEPR:	MOVEI T3,HISQUE
	INHIST (,,T4,T3,T2)
	MOVEM T4,TMPQUE
;simple check for non-sequential records
	MOVE T3,PPLNQD		; time previous packet queued
	CAMG T3,TQD		; was previous packet queued before this?
	  RET			; yes-in sequence

; this will eventually do great things, right now it will just mention that
; the driver sent packets out of sequence

	HRROI T2,[ASCIZ/'Questionable queueing sequence'/]
	CALL MESREC		; output message and record number
	RET


;BUSYPR	Totals busy time
;T4/	busy time (driver end time less driver begin time)

BUSYPR:	PUSH P,T4
	MOVEI T1,1		;Do the output side
	MOVE T2,(P)
	MOVE T3,TNBSIZ
	CALL SCAADD		; Add sample to scattergram

	MOVEI T1,2		;Do the output side
	MOVE T2,(P)
	MOVE T3,TNBSIZ
	CALL XRTADD		;Compute m (slope) and b (y intercept)

	POP P,T4
	MOVEI T3,HISBSY
	INHIST (,,T4,T3,T2)
	RET


;IDLEPR	Called when driver idle noted.
; Totals idle time, closes previous busy cycle, and opens new cycle.

;T4/	idle time (previous driver end time less driver begin time)

IDLEPR:	MOVEI T3,HISIDL
	INHIST (,,T4,T3,T2)
	CALL IDLBLK		; simple check for "idle blocked"
	MOVE T4,PPLNDE		; previous driver end time
	SUB T4,STBSY		; continuously busy start
				; time driver continuously busy
	SKIPE TMPBSY		; temp busy record count > 1
				;   constitutes continuously busy
	  ADDM T4,CNTBSY	; yes, it was
	SETZM TMPBSY
	RET

; this will eventually do great things, right now it will just mention that
; blocking has occurred

IDLBLK:	MOVE T2,TMPQUE	; queue time for current packet
	CAIG T2,1	; packet queued for more that a tick of the clock?
	  RET

	CAMLE TQD,PPLNDE	; was queued before previous job ended?
	  MOVE T4,T2		; no, blocked = queued time
	HRROI T2,[ASCIZ/'Packet in queue while driver idle  '/]
	CALL MESREC		; output message and record number
	RET


;STHIST	Routine to print histogram.

;T1/	Output Designator
;T2/	String pointer to title
;HST/	Starting address, i.e.  n,sum,cnt, <count,limit>n

STHIST:	SETZ T3,			; Title
	SOUT%
;	SSOUT <	Sum: >
	MOVE T2,1(HST)
	CALL PRTIME
	SSOUT <, Instances: >
	MOVE T2,2(HST)
	XNOUT <DECRAD>
	SSOUT <, Average: >
	MOVE T2,2(HST)
	ASH T2,-1
	ADD T2,1(HST)
	IDIV T2,2(HST)
	CALL PRTIME
	SSOUT <

Occurrences          Range(msecs)
>;xxxxxxxxx xxxx:xx.xxx    - xxxx:xx.xxx
	ADDI HST,3			; point to first total count
	SETZ T5,			; lower end first msec range

	DO.
	  MOVE T2,(HST)			; number of times
	  XNOUT <NO%LFL+FLD(^D11,NO%COL)+DECRAD>
	  MOVE T2,T5			; previous high -1
	  CALL PRTIME			; print low range msecs
	  SSOUT <    ->
	  MOVE T2,1(HST)		; msec
	  CALL PRTIME			; print high ramge msecs
	  CALL CRLF
	  MOVE T5,1(HST)		; msec
	  ADDI T5,1			; plus 1 for next low
	  ADDI HST,2
	  JUMPG T5,TOP.
	ENDDO.
	RET


;PRTIME	Displays time in minutes and seconds.

;T1/	Output Designator
;T2/	Total number seconds

PRTIME:	IFL. T2
	  SSOUT <    or more>
	  RET
	ENDIF.
	IDIVI T2,^D60000			; minutes
	PUSH P,T3
	XNOUT <NO%LFL+FLD(^D5,NO%COL)+DECRAD>

	SSOUT <:>

	POP P,T2
	IDIVI T2,^D1000			; seconds
	PUSH P,T3
	XNOUT <NO%LFL+NO%ZRO+FLD(2,NO%COL)+DECRAD>

	SSOUT <.>

	POP P,T2			; milliseconds
	XNOUT <NO%LFL+NO%ZRO+FLD(3,NO%COL)+DECRAD>
	RET


;PRTTOT	Print total

;T1/	Output Designator
;T2/	Pointer to message
;T4/	Total time to be printed

PRTTOT:	SETZ T3,
	SOUT%
	MOVE T2,T4
	CALL PRTIME			; output total time
	CALL CRLF
	RET


;MESREC	Outputs message and record number

;T2/	Message pointer
;T4/	Time

MESREC:	TXNE F,F%SF		; Skip message if graphing
	  RET
	HRRZ T1,JFNO
	SETZ T3,
	SOUT%
	SSOUT <	Sample Number: >
	MOVE T2,NPKTN
	XNOUT <NO%LFL+FLD(6,NO%COL)+DECRAD>
	MOVE T2,T4
	CALL PRTIME
	CALL CRLF
	RET


;LNHIST	Routine to print histogram.

;T1/	Output Designator
;T2/	String pointer to title
;HST/	Starting address, i.e.  n,sum,cnt, <count,limit>n

LNHIST:	SETZ T3,			; Title
	SOUT%
;	SSOUT <	Sum: >
	MOVE T2,1(HST)
	XNOUT <DECRAD>
	SSOUT <, Packets: >
	MOVE T2,2(HST)
	XNOUT <DECRAD>
	SSOUT <, Average Length: >
	MOVE T2,2(HST)
	ASH T2,-1
	ADD T2,1(HST)
	IDIV T2,2(HST)
	XNOUT <DECRAD>
	SSOUT <

Occurrences       Range(bytes)
>;xxxxxxxxx     xxxx  -    xxxx
	ADDI HST,3			; point to first total count
	SETZ T5,			; lower end first msec range

	DO.
	  MOVE T2,(HST)			; number of times
	  XNOUT <NO%LFL+FLD(^D11,NO%COL)+DECRAD>
	  MOVE T2,T5			; previous high -1
	  XNOUT <NO%LFL+FLD(^D8,NO%COL)+DECRAD>
	  SSOUT <    ->
	  MOVE T2,1(HST)		; msec
	  IFL. T2
	    SSOUT <    or more>
	  ELSE.
	    XNOUT <NO%LFL+FLD(^D8,NO%COL)+DECRAD>
	  ENDIF.
	  CALL CRLF
	  MOVE T5,1(HST)		; msec
	  ADDI T5,1			; plus 1 for next low
	  ADDI HST,2
	  JUMPG T5,TOP.
	ENDDO.
	RET

;Process device

CEKDEV:	MOVEI T2,DEVTAB
	INHSTI (,,T3,T2,T4)		; Histogram device code

	SKIPL T2,DEVPR			; Already have device specified?
	IFSKP.				; No, use
	  MOVEM T3,DEVPR
	  CALL PRTDEV
	  MOVE T3,DEVPR			; Return it also
	ENDIF.
	RET

PRTDEV:	MOVE T1,JFNO
	SSOUT <Processing device >
	MOVE T2,DEVPR
	MOVX T3,<^D8>
	XNOUT <DECRAD>
	CALL CRLF
	TXNE F,F%NDAT			; Want detail data?
	IFSKP.				; Yes, print heading
	  SSOUT <
Sample      TODCLK NH NP  Len      Queued       Begin    Finished  Busy  File
>
;xxxxxx xxxxxxxxxxx xx xx xxxx xxxxxxxxxxx xxxxxxxxxxx xxxxxxxxxxx xxxxx xxxxx
	ENDIF.
	CALL CRLF
	RET





ERROR:	PUSH P,T2
	PUSH P,T1		; save string pointer
	HRROI T1,[ASCIZ/Error: /]
	ESOUT
	POP P,T1
	PSOUT
	MOVEI T1,.PRIOU
	CALL CRLF
	HRLOI T2,.FHSLF	; process handle/this fork
	SETZ T3,
	ERSTR			; translate last error to a string
	JFCL
	JFCL
	CALL CRLF
	HRROI T1,[ASCIZ/
			Process Restarted/]
	PSOUT
;cwl error return?
	RET


;;HERE

FOO1:	LOAD T5,DDEV,+PACKET	; Device type
	CAIE T5,NH.ANX		; AN20 or
	 CAIN T5,NH.BBN		; IMP10 are
	  JRST .+3		; 1822 driver
	CAIN T5,NH.NFE		; NFE is an
	  JFCL			; NFE driver
	jfcl
;TO HERE


; Constants

HTAB:	BYTE (7) 11
FFEED:	BYTE (7) 14

HIST:	EXP ^D9,0,0,   0,1, 0,4, 0,20, 0,100, 0,400, 0,2000, 0,10000
	EXP            0,40000, 0,-1
HISTE:

HISTL:	EXP ^D17,0,0,  0, ^D39, 0,  ^D40, 0,  ^D41, 0,  ^D42, 0, ^D43, 0, ^D44
	EXP            0,^ D60, 0,  ^D90, 0, ^D125, 0, ^D200, 0,^D300, 0,^D400
	EXP            0,^D576, 0,^D1000, 0,^D1007, 0,^D2000, 0,-1
HISTLE:

DEVTB0:	EXP ^D12,0,0,  0,0,0,0,0,0,0,0,0,0,0,0
DEVLEN==.-DEVTB0

; Variables

DRVUCD:	PT%SLN			; Trace code to be processed
NCT:	0			; NCT address to be processed

DEVCT:  0			; device types processed (index into DEVTAB)
DEVPR:  -1			; device type currently in process (0 to n)
DEVTAB: BLOCK DEVLEN		; Device type histogram

TBASE:	0			; First time sampled
VBASE:	^D500			; 1/2 inch top margin
VXCT:	IDIV T2,VSCALE		; Vertical scale
VSCALE:	^D20			; Msec per thousnadth vertical inch
VMAX:	^D10000			; Maximum vertical
VMAXR:	0
HBASE:	^D500			; 1/2 inch left margin
HXCT:	IMUL T2,HSCALE		; Horizontal scale
HSCALE:	^D100			; Msec/byte per thousandth inch horizontal
HMAX:	^D7900			; Maximum horizontal
HMAXR:	0
PPLNQD:	0			; previous que time
PPLNDB:	0			; previous begin time
PPLNDE:	0			; previous end time

TNBSIZ:	0			; packet size (current packet)
TMPQUE:	0			; queue time of current packet
HISQUE:	BLOCK HISTE-HIST	; Queued time histogram
HISIDL:	BLOCK HISTE-HIST	; Idle time histogram
STBSY:	0			; start busy time
TMPBSY:	0			; temp number busy packets
CNTBSY:	0			; total time driver continuously busy
HISBSY:	BLOCK HISTE-HIST	; Busy time histogram
HISBLK:	BLOCK HISTE-HIST	; Blocked time histogram
HISLEN:	BLOCK HISTLE-HISTL	; Packet length histogram

;APLNDQ:	BLOCK MAXSAV	
;APLNDB:	BLOCK MAXSAV	
;APLNDE:	BLOCK MAXSAV	

;SAVIND:	0

;SPLNQD: 0		; starting queue time
;SPLNDB:	0		; starting begin time
;SPLNDE:	0		; starting end time


;=== Start of XRATE =========================================================

; Subroutines to compute and print I/O Transmission Rates (from NCTiG)
; Typical calling sequence:
;
;	...
;	CALL XRTINI		;Initialize variables
;	MOVE T1,NCTIG		;Get NCTiG address
;	CALL XRTGET		;Compute the times and lengths
;	MOVEI T1,0		;Do the input side
;	CALL XRTCMP		;Compute m (slope) and b (y intercept)
;	MOVEI T1,.PRIOU		;Output designator
;  ;	MOVEI T2,0		;Do the input side
;	CALL XRTPRT		;Print it
;	MOVEI T1,2		;Do the output side
;	CALL XRTCMP		;Compute m (slope) and b (y intercept)
;	MOVEI T1,.PRIOU		;Output designator
;  ;	MOVEI T2,2		;Do the output side
;	CALL XRTPRT		;Print it
;	...
;

 F.MRG==1B30					; Combine over SCANs
 F.SHT==1B31					; Brief output format
 F.DOR==1B32					; List receieve info
 F.CAD==1B33					; Combine all samples in SCAN
 F.BNZ==1B34					; Y = M*X+B fit
 F.LSP==1B35					; List first 64 <X,Y> pairs

;XRTINI	Initialize variables
;
;Returns: +1 always
;
; Clobbers temp ACs


XRTINI::

;Init SIGMA statics

	SETZM XR$BEG				; Clear first word
	MOVX T1,<XWD XR$BEG,XR$BEG+1>		; BLT Pointer
	BLT T1,XR$BEG+XR$LEN-1			; Clear block
	RET


;XRTGET	Get the data from the NCTiG block.
;
;Called:
;	T1/ address of NCTiG
;Returns: +1 always
;
;Sets up XRx$xx SIGMA variables, and XRx.xx list of value variables
;AC usage:
Q1==5
PTR==5	;Saved address of NCTiG
Q2==6
LEN==6	;Ring buffer length from 0(Q1)
CUR==7	;Current pointer from 1(Q1)
WRP==10	;Contains the last address in the ring buffer for wrap around comp.
IDX==11	;Pseudo "AOBJN" pointer into ring buffer
;
; Clobbers temp ACs

XRTGET::
	PUSH P,5	; PTR			; Save ACs
	PUSH P,6	; LEN
	PUSH P,7	; CUR
	PUSH P,10	; WRP
	PUSH P,11	; IDX

	MOVE PTR,T1				; Save NCTiG Pointer
	MOVE LEN,0(PTR)				; Get ring buffer length
	SKIPE LEN				; Anything there?
	IFSKP.
	  TMSG <?NCTiG is empty
>
	  JRST XRTGEX
	ENDIF.

	MOVE CUR,1(PTR)				; Get current pointer
	CAML CUR,LEN				; Current pointer beyond end?
	  SETZ CUR,				; Yes, adjust to beginning

;Form <-Length,,Current offset> "AOBJN" pointer

	MOVN IDX,LEN				; Get -Length
	HRLZS IDX				; Get -Length,,0
	HRR IDX,CUR				; Get -Length,,Current Offset
	ADDI IDX,2(PTR)				; Get -Length,,Address in NCTiG

;Compute the last ring buffer address

	MOVE WRP,LEN				; Get the size of the buffer
	ADDI WRP,2-1(PTR)			; Add base address (minus 1)

;Fall thru...

;...Fell thru

;Loop thru block, pairing Begin/End of Input/Output events.
;Get length of the packet (X), and time to send (Y), and accumulate the
;totals in XRx$xx SIGMA variables

	DO.
	  MOVE T4,IPDVBF(IDX)			; Get flags
	  SETZ T1,				; Assume Input, use 0 index
	  TXNE T4,IPDV%O			; Output event?
	    MOVX T1,2				; Yes, use 2 index
	  TXNN T4,IPDV%E			; Processing completed?
	  IFSKP.				; Yes...
	    SKIPN T2,XRI$TM(T1)			; Have a TODCLK Begin Time
	      JRST XRTGT0			; No, ignore it
	    ADD T2,IPDVTM(IDX)			; Get elapsed time
	    JUMPL T2,XRTGT0			; Negative???  Error, ignore it
	    SETZB T3,XRI$TM(T1)			; Assume canned 0 length pkt,
						; clear begin time
	    TXNN T4,IPDV%R			; Canned message
	      LOAD T3,PIPL,-PKTELI+IPDVLL+MAXLDR(IDX)  ; No, get length
	    CALL XRTADD				; Add info to SIGMAs
	  ELSE.					; Processing begin...
	    MOVN T2,IPDVTM(IDX)			; Get negative begin time
	    MOVEM T2,XRI$TM(T1)			; Save it
	  ENDIF.
XRTGT0:	  ADD IDX,[XWD IPDVSZ,IPDVSZ]		; Simulate AOBJN
	  IFL. IDX				; Still less than 0?
	    CAIG WRP,(IDX)			; Time to wrap around?
	      SUB IDX,LEN			; Yes, sub len from the address
	    LOOP.
	  ENDIF.
	ENDDO.
XRTGEX:	POP P,11				; Restore registers
	POP P,10
	POP P,7
	POP P,6
	POP P,5
	RET

;XRTADD	Add X,Y to the SIGMAs (as in y=mx+b), and keep list of values.
;Called:
;	T1/ I/O index (Input = 0, Output = 2)
;	T2/ Y (Time to send/receive)
;	T3/ X (Length of the packet)
;Returns: +1 always
;
; Clobbers temp ACs

XRTADD::
repeat 0,<	; this uses a separate call
	PUSH P,T1
	PUSH P,T2
	PUSH P,T3
	CALL SCAADD
	POP P,T3
	POP P,T2
	POP P,T1
> ; End of repeat 0

	MOVE T4,XRI$N(T1)			; Get sample number (-1)
	CAIL T4,IPDVNT				; Check for too many
	  MOVX T4,<-1,,0>			; Negative
	SKIPE T1				; Point to either input or
	  ADDI T4,IPDVNT			; Point to output

;Form the quantities, sum them, and Update the XRx.xx list of values

	AOS XRI$N(T1)				; Count this sample
	SKIPL T4
	  MOVEM T2,XRI.Y(T4)			; Save Y
	ADDM T2,XRI$Y(T1)			; Sum the Y
	SKIPL T4
	  MOVEM T3,XRI.X(T4)			; Save X
	ADDM T3,XRI$X(T1)			; Sum the X
	PUSH P,T3				; Save X
	MUL T2,T3				; Compute X*Y
	SKIPL T4
	  MOVEM T3,XRI.XY(T4)			; Save X*Y
	DADD T2,XRI$XY(T1)			; Sum the X*Y
	DMOVEM T2,XRI$XY(T1)
	POP P,T2
	MUL T2,T2				; Compute X*X (X squared)
	SKIPL T4
	  MOVEM T3,XRI.XX(T4)			; Save X*X
	DADD T2,XRI$XX(T1)			; Sum the X*X
	DMOVEM T2,XRI$XX(T1)
	RET


;XRTCMP	Compute m and b (as in y=mx+b)
;	T1/ I/O index (Input = 0, Output = 2)
;	XRx$xx SIGMA variables set up
;Returns: +1 always, with XRx$M and XRx$B
; Clobbers temp ACs, Moves T1 to T2 (for XRTPRT)

XRTCMP::	; N must be .gt. 1 to complete the calculation meaningfully
	MOVE T3,XRI$N(T1)
	CAILE T3,1				; N .gt. 1?
	IFSKP.					; No, return zero/Y
	  SETZM XRI$M(T1)
	  MOVE T3,XRI$Y(T1)			; The sum Y is Y for N=1
	  MOVEM T3,XRI$B(T1)
	  JRST XRTCMX
	ENDIF.

	ADJSP P,5				; DP Denom, DP , saved T5
	MOVEM T5,(P)

; Compute b:
;     SIGMA(X)*SIGMA(X*Y) - SIGMA(Y)*SIGMA(X*X)
; b = -----------------------------------------
;     SIGMA(X)*SIGMA(X)   - N*SIGMA(X*X)

	SETZ T2,
	MOVE T3,XRI$N(T1)			; N
	DMUL T2,XRI$XX(T1)			; N*SIGMA(X*X)
						; Save subtrahend in 4,5
	MOVE T2,XRI$X(T1)			; SIGMA(X)
	MUL T2,T2				; SIGMA(X)*SIGMA(X)
	DSUB T2,T4				; Denominator
	DMOVEM T2,-4(P)				; Save DP denominator

	SETZ T2,
	MOVE T3,XRI$Y(T1)			; DP SIGMA(Y)
	DMUL T2,XRI$XX(T1)			; QP SIGMA(Y)*SIGMA(X*X)
	DMOVEM T4,-2(P)				; Save subtrahend as DP
;	SETZ T2,
	MOVE T3,XRI$X(T1)			; DP SIGMA(X)
	DMUL T2,XRI$XY(T1)			; QP SIGMA(X)*SIGMA(X*Y)
	DSUB T4,-2(P)				; DP numerator

	SKIPGE T4
	  SETOB T2,T3
	SKIPL T4
	  SETZB T2,T3				; QP numerator
	DDIV T2,-4(P)				; DP Quotient & DP remainder

	TXNN F,F.BNZ				; Want y = M*x+B form?
	  SETZ T3,				; No,  y = M*x   form
	MOVEM T3,XRI$B(T1)			; SP B

;Compute m:
;     SIGMA(Y) - b*N
; m = --------------
;       SIGMA(X)
; Note: m is a fractional value with imaginary binary point at the half-word

	IMUL T3,XRI$N(T1)			; b*N
	MOVE T2,XRI$Y(T1)			; SIGMA(Y)
	SUB T2,T3				; Numerator
	SETZ T3,
	ASHC T2,-^D<18-1>			; DP numerator * 2**18
	DIV T2,XRI$X(T1)			; m
	MOVEM T2,XRI$M(T1)

	MOVE T5,(P)
	ADJSP P,-5

XRTCMX:	MOVE T2,T1				; T2/ Input/Output flag
	RET

;XRTPRT	Print the info, Input/Output b/m
;	T1/ Destination pointer
;	T2/ I/O index (Input = 0, Output = 2)
;	XRx.M and XRx.B
;Returns: +1 always
;AC usage:
IOX==5	;Saved I/O index
; Clobbers temp ACs

XRTPRT::
	PUSH P,IOX				; Save AC
	MOVE IOX,T2
	MOVE T2,[ -1,,[ASCIZ/Input /]
		  -1,,[ASCIZ/Error /]
		  -1,,[ASCIZ/Output/]
		  -1,,[ASCIZ/Error /]
		](IOX)				; Say either Input or Output
	SETZ T3,
	TXNN F,F.SHT
	  SOUT%

	MOVN T4,XRI$N(IOX)			; Get -<number of samples>
	CAMGE T4,[-IPDVNT]			; Too big?
	  MOVE T4,[-IPDVNT]			; Yes, just list first few
	TXNN F,F.LSP				; List pairs?
	  SETZ T4,				; No
	IFL. T4					; More than none?
						; Yes
	  FMSG <  Table of SIGMA values:
           N           x           y         x*y         x*x
      ------      ------      ------      ------      ------
            >

	  HRLZS T4				; Make -N,,I/O array index
	  SKIPE IOX				; Get I/O index
	    HRRI T4,IPDVNT			; Get index into array
	  DO.
	    MOVE T2,XRI.X(T4)
	    XNOUT FLD(DECRAD,NO%RDX)!FLD(^D12,NO%COL)!NO%LFL
	    MOVE T2,XRI.Y(T4)
	    XNOUT FLD(DECRAD,NO%RDX)!FLD(^D12,NO%COL)!NO%LFL
	    MOVE T2,XRI.XY(T4)
	    XNOUT FLD(DECRAD,NO%RDX)!FLD(^D12,NO%COL)!NO%LFL
	    MOVE T2,XRI.XX(T4)
	    XNOUT FLD(DECRAD,NO%RDX)!FLD(^D12,NO%COL)!NO%LFL

	    FMSG <
            >

	    AOBJN T4,TOP.
	  ENDDO.

	  FMSG <* Totals:
>
	  MOVE T2,XRI$N(IOX)
	  XNOUT FLD(DECRAD,NO%RDX)!FLD(^D12,NO%COL)!NO%LFL
	  MOVE T2,XRI$X(IOX)
	  XNOUT FLD(DECRAD,NO%RDX)!FLD(^D12,NO%COL)!NO%LFL
	  MOVE T2,XRI$Y(IOX)
	  XNOUT FLD(DECRAD,NO%RDX)!FLD(^D12,NO%COL)!NO%LFL

	  DMOVE T2,XRI$XY(IOX)
	  CALL DNOUT
	  DMOVE T2,XRI$XX(IOX)
	  CALL DNOUT

	  FMSG <
          >
	ENDIF.

	TXNE F,F.SHT
	IFSKP.
	  FMSG <  Y =>
	ENDIF.

; N.B. m is in the form <i,,f>, i=integer part; f=fractional part
;  Print it as n.nnn

	MOVE T4,XRI$M(IOX)			; Get m
	HLRZ T2,T4				; Print Integer part
	XNOUT NO%LFL+FLD(^D3,NO%COL)+FLD(DECRAD,NO%RDX)
	MOVEI T2,"."
	BOUT%
	HRRZ T2,T4				; Fractional part
	IMULI T2,^D1000				; Fractional digits in lh
	HLRZS T2
	XNOUT FLD(DECRAD,NO%RDX)!FLD(^D3,NO%COL)!NO%LFL!NO%ZRO

	TXNE F,F.SHT
	IFSKP.
	  FMSG < * X>

	  SKIPN T4,XRI$B(IOX)			; Get b
	  IFSKP.
	    FMSG < + >
	    MOVE T2,T4
	    XNOUT FLD(DECRAD,NO%RDX)
	  ENDIF.

	  FMSG <   based on >
	ENDIF.

	MOVE T2,XRI$N(IOX)
	XNOUT NO%LFL+FLD(^D8,NO%COL)+FLD(DECRAD,NO%RDX)

	TXNE F,F.SHT
	IFSKP.
	  FMSG < samples averaging >
	ENDIF.

	MOVE T2,XRI$X(IOX)			; Bytes sent
	MOVE T3,XRI$N(IOX)			; Packets sent
	LSH T3,-1
	ADD T2,T3				; Round
	IDIV T2,XRI$N(IOX)
	XNOUT NO%LFL+FLD(^D5,NO%COL)+DECRAD

	TXNE F,F.SHT
	IFSKP.
	  FMSG < bytes.>
	ENDIF.

	FMSG <
>
	POP P,IOX				; Restore register
	RET

;DNOUT	Print double precision number

;T2,T3/	Standard DP number

DNOUT:	IFE. T2
	  MOVE T2,T3
	  XNOUT FLD(DECRAD,NO%RDX)!FLD(^D12,NO%COL)!NO%LFL
	ELSE.
	  DIV T2,[^D1000000000]
	  PUSH P,T3
	  XNOUT FLD(DECRAD,NO%RDX)!FLD(^D12,NO%COL)!NO%LFL
	  POP P,T2
	  XNOUT FLD(DECRAD,NO%RDX)!FLD(^D9,NO%COL)!NO%LFL!NO%ZRO
	ENDIF.
	RET

LXRATE:	LIT


; Local storage for XRATE

; ******************************
; NB. the following words must be paired by Input/Output, in that order

XR$BEG==.				;Addr of XRx$xx begin, for clearing
XRI$TM:	BLOCK 1+1			;Start Input TODCLK, 0 if none
XRO$TM: BLOCK 1+1			;Start Output TODCLK
XRI$N:	BLOCK 1+1			;Start Input N, number of (X,Y) pairs
XRO$N:	BLOCK 1+1			;Start Output N, number of (X,Y) pairs
XRI$X:	BLOCK 1+1			;Input SIGMA(X)
XRO$X:	BLOCK 1+1			;Output SIGMA(X)
XRI$Y:	BLOCK 1+1			;Input  SIGMA(Y)
XRO$Y:	BLOCK 1+1			;Output SIGMA(Y)
XRI$XY:	BLOCK 2				;Input SIGMA(X*Y) (Double precision)
XRO$XY:	BLOCK 2				;Output SIGMA(X*Y) (Double precision)
XRI$XX:	BLOCK 2				;Input SIGMA(X*X) (Double precision)
XRO$XX:	BLOCK 2				;Output SIGMA(X*X) (Double precision)
XRI$M:	BLOCK 1+1			;Input M, slope of Least squares line
XRO$M:	BLOCK 1+1			;Output M, slope of Least squares line
XRI$B:	BLOCK 1+1			;Input B, y intersect of ...
XRO$B:	BLOCK 1+1			;Output B, y intersect of ...

; Tables of (first IPDVNT) individual values

XRI.X:	BLOCK IPDVNT			;Input list of X values
XRO.X:	BLOCK IPDVNT			;Output list of X values
XRI.Y:	BLOCK IPDVNT			;Input list of Y values
XRO.Y:	BLOCK IPDVNT			;Output list of Y values
XRI.XY:	BLOCK IPDVNT			;Input list of X*Y values
XRO.XY:	BLOCK IPDVNT			;Output list of X*Y values
XRI.XX:	BLOCK IPDVNT			;Input list of X*X values
XRO.XX:	BLOCK IPDVNT			;Output list of X*X values
XR$LEN==.-XR$BEG			;Number of XRx$xx locations

; End of pairing by Input/Output
;******************************

;=== End of XRATE ===========================================================

;=== Start of Scattergram routines ==========================================

WCOL==^D5
NCOL==^D64
WLIN==^D20
NLIN==^D128
SCSIZ==NCOL*NLIN
SCALE:	0		; scale, if required, for scatgm
HLFSCA:	0		; scale, if required, for scatgm
HICELL:	0		; highest number in scatgm
HILINE:	0		; highest line number in scatgm

SCATXT:	BLOCK <5+NCOL+2+2>*<NLIN+2>/5		; 2 extra
SCATGM:	BLOCK SCSIZ				; Array 

SCAINI:	SETZM HICELL			; Clear scaling variables
	SETZM SCALE
	SETZM SCATGM
	MOVX T2,^D5			; Minimum # lines to print
	MOVEM T2,HILINE
	MOVE T2,[SCATGM,,SCATGM+1]
	BLT T2,SCATGM+SCSIZ-1		; Clear the scattergram
	RET

; called with
;	T1/ I/O index (Input = 0, Output = 1)
;	T2/ Y (Time to send/receive)
;	T3/ X (Length of the packet)

SCAADD:	CAIE T1,1			; Only do output
	  RET
	MOVE T1,T2
	IDIVI T1,WCOL
	CAIL T1,NCOL
	  MOVEI T1,NCOL-1
	IDIVI T3,WLIN
	CAIL T3,NLIN
	  MOVEI T3,NLIN-1
	CAMLE T3,HILINE
	  MOVEM T3,HILINE
	IMULI T3,NCOL
	ADD T3,T1
	AOS T1,SCATGM(T3)
	CAMLE T1,HICELL
	  MOVEM T1,HICELL
	RET

;SCAPRT	Print text version of SCATGM

;T1/	Destination pointer
;T2/	I/O index (Input = 0, Output = 1)

SCAPRT:	CAIE T2,1			; Only do output
	  RET
	PUSH P,T1			; Save output designator

	MOVE T2,HICELL			; highest entry in SCTGRM
	CAIG T2,^D<10-1+26>		; Largest (linear) symbol value
	IFSKP.
	  IDIVI T2,^D26			; divide by radix of second region
	  ADDI T2,1			; round up
	  CAIG T2,1			; scaling in effect?
	    SETZ T2,			; no
	  MOVEM T2,SCALE		; save the scale
	  LSH T2,-1			; what is half the scale?
	  MOVEM T2,HLFSCA
	ENDIF.

	SSOUT <
            Time (Msec)   >		; X-axis label

	SKIPG SCALE
	IFSKP.				; Yes
	  SSOUT	<  "A" = >
	  MOVE T2,SCALE
	  XNOUT DECRAD
	  SSOUT < Samples (1-9 exact, Alpha scaled).>
	ENDIF.

	SSOUT <
                         11111111111111111111222222222222222222223333
       11223344556677889900112233445566778899001122334455667788990011
Pkt  0505050505050505050505050505050505050505050505050505050505050505
Len +----------------------------------------------------------------
>

	MOVE T1,[POINT 7,SCATXT]	; byte pointer to the output buffer
	MOVX Q2,<0,,SCATGM>		; Point to first entry
	SETCM Q1,HILINE			; -<HILINE+1> is # lines, including 0
	HRLZS Q1			; Counter for outer loop
	DO.				; For all lines
	  HRLI Q2,-NCOL			; Counter for inner loop

	  MOVX T2,WLIN
	  IMULI T2,(Q1)			; Line spacing * line # is label
	  XNOUT <NO%LFL+FLD(4,NO%COL)+DECRAD>
	  MOVEI T4,"|"			; Axis
	  IDPB T4,T1

	  DO.				; For all columns
	    MOVE T2,(Q2)		; Get total hits
	    CAIG T2,^D9			; In 1-to-1 range?
	    IFSKP.			; No, may need to scale
	      SKIPG T3,SCALE		; Scaling in effect?
	      ANSKP.			; Yes
	        IDIV T2,T3		; scale number
	        CAMLE T3,HLFSCA		; should round up?
	          ADDI T2,1		; yes, round up
	        CAILE T2,^D<10-1+26>	; but not over top
	          MOVEI T2,^D<10-1+26+1> ; Overflow is *
	        SKIPN T2		; if scaled to zero,
	         TROA T2,^D<10-1+26+2>	; print "o", otherwise
	          ADDI T2,^D<10-1>	; Use A to Z for scaled 1 to 26
	    ENDIF.
	   ADJBP T2,[POINT 7,[ASCIZ/ 123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ*o/],6]
	    LDB T2,T2			; Get character
	    IDPB T2,T1			; Into matrix
	    AOBJN Q2,TOP.		; finish this line?
	  ENDDO.

	  CALL CRLF
	  AOBJN Q1,TOP.			; finished?
	ENDDO.				; yes, prepare for SOUT
	SETZ T3,
	IDPB T3,T1			; End the scttergram

	POP P,T1			; Restore output designator
	HRROI T2,SCATXT			; starting address of output buffer
	SOUT%
	RET

;=== End of plot ============================================================

;============================================================
;============== End of Driver Utilization Code ==============
;============================================================
	SUBTTL	Statistics - Initialization

; Bin structure.  Bin "0" is for "other", Bins 1-n have values.

DEFSTR BINRCT,0,17,18			; "Receive" count
DEFSTR BINSCT,0,35,18			; "Send" count
DEFSTR BINVAL,1,35,36			; Bin's "value"
BINSIZ==2



; STATIN	Routine to initialize statistics areas

STATIN:	SETZM STSTRC			; Zero trace codes
	MOVE T1,[STSTRC,,STSTRC+1]
	BLT T1,STTTRC-1

	SETZM STSPRT			; Zero Protocol vector
	MOVE T1,[STSPRT,,STSPRT+1]
	BLT T1,STTPRT-1

	MOVE T1,[STIPRT,,STSPRT]	; Initialize it
	BLT T1,STSPRT+STSPRT-STIPRT-1

	MOVE T1,[STIPR1,,STSPR1]	; Initialize ICMP array
	BLT T1,STTPR1-1

	SETZM STSPR6			; Zero TCP vector
	MOVE T1,[STSPR6,,STSPR6+1]
	BLT T1,STTPR6-1

	RET

	SUBTTL	Statistics - Print Summary


STATOF:	  MOVE T1,JFNO		; Output file
	  CALL CRLF		; CRLF before ^L in case ^G was typed
;	  CALLRET STATIM	; List statistics info


; STATIM	Routine to print statistics info
;  T1/	Output JFN


STATIM:	HRROI T2,OTITLE			; Output title on new page
	SETZ T3,
	SOUT

	SSOUT <
Protocol        Recv    Sent
>

	MOVN T5,STSPRT			; # protocols found
	HRLS T5
	HRRI T5,STSPRT+BINSIZ		; AOBJN at first
	DO.
	  MOVX T4,<-NPRC,,PRCKEY+1>
	  DO.
	    HRRZ T2,(T4)		; Get known code
	    OPSTR <CAME T2,>,BINVAL,(T5) ; This it?
	      AOBJN T4,TOP.		; No
	  ENDDO.

	  CALL STIMNN			; Keyword name or number
	  CALL STIMRS			; Output Recv/send counts

	  ADDI T5,BINSIZ-1		; Two words per entry
	  AOBJN T5,TOP.			; Back for next protocol
	ENDDO.

	MOVEI T5,STSPRT+$BINVAL		; "Point" to overflow cell
	SKIPN $BINRCT(T5)		; Any not processed?
	IFSKP.				; No
	  SSOUT <       Other>
	  CALL STIMRS			; Output Recv/send counts
	ENDIF.

	SSOUT <
TCP Port        Recv    Sent
>

	HRLI T5,-NSTPR6			; Max # ports
	HRRI T5,STSPR6+BINSIZ		; AOBJN at first
	DO.
	  OPSTR SKIPN,BINVAL,(T5)	; Have another entry?
	    EXIT.			; No
	  MOVX T4,<-NPRT,,PRTKEY+1>
	  DO.
	    HRRZ T2,(T4)		; Get known code
	    OPSTR <CAME T2,>,BINVAL,(T5) ; This it?
	      AOBJN T4,TOP.		; No
	  ENDDO.

	  CALL STIMNN			; Keyword name or number
	  CALL STIMRS			; Output Recv/send counts

	  ADDI T5,BINSIZ-1
	  AOBJN T5,TOP.
	ENDDO.

	SSOUT <
Type-Code       Recv    Sent
>

	MOVN T5,STSPR1			; Number of pairs
	HRLS T5
	HRRI T5,STSPR1+BINSIZ		; AOBJN for ICMP
	PUSH P,[0]
	DO.
	  SKIPN $BINRCT(T5)		; Get TYPE counts
	  IFSKP.
	    MOVE T3,(P)			; Type number
	    MOVX T4,<-ICMTYP,,ICMCOD>
	    DO.
	      CAMN T3,(T4)		; This it?
	      IFSKP.			; Yes
	        ADDI T4,ICSIZ-1
	        AOBJN T4,TOP.		; Try next
	        MOVE T2,T3		; Unknown TYPE
	      ELSE.			; Known TYPE
	        HRROI T2,ICMNAM-ICMCOD(T4) ; ICMP Type
	      ENDIF.
	    ENDDO.
	    CALL STIMNM			; List name or # in T2
	    CALL STIMRS			; List Type counts

	    PUSH P,T5
	    PUSH P,[0]			; Code number
	    OPSTR <SKIPG T5,>,BINVAL,(T5) ; Codes?
	    IFSKP.
	      MOVN T3,(T5)		; # Codes bins
	      HRL T5,T3
	      HRRI T5,$BINVAL(T5)	; Point at counts
	      DO.
	        SKIPN (T5)		; Any counts?
	        IFSKP.
	          MOVE T2,(P)		; Code #
	          SKIPE T3,1(T4)	; Code table or 0
	           CAML T2,-1(T3)	; Known code?
	          IFSKP.		; Known CODE
	            IMULI T2,SICMCD	; Words per message
	            ADDI T2,(T3)	; Plus table address
	            HRROS T2		; Into string pointer
	          ENDIF.
	          CALL STIMNM		; Code name or number
	          CALL STIMRS		; Counts
	        ENDIF.
	        AOS (P)			; Next Code #
	        AOBJN T5,TOP.		; Back for next code
	      ENDDO.
	    ENDIF.
	    POP P,(P)			; Code #
	    POP P,T5			; Type counter
	  ENDIF.
	  AOS (P)
	  ADDI T5,1			; Not really BINSIZ-1
	  AOBJN T5,TOP.
	ENDDO.
	POP P,(P)			; Drop Type number


	SSOUT <
   Trace        Recv    Sent
>

	MOVN T5,STSTRC			; # trace codes found
	HRLS T5
	HRRI T5,STSTRC+BINSIZ		; AOBJN at first
	DO.
	  PUSH P,T1
	  OPSTR <HRRZ T4,>,BINVAL,(T5)	; Code
	  CALL SRCH			; Find code?
	  IFSKP.			; Yes
	    POP P,T1
	    SOUT
	    MOVX T3,<NO%LFL+FLD(^D9,NO%COL)+OCTRAD>
	  ELSE.
	    POP P,T1
	    MOVX T3,<NO%LFL+FLD(^D12,NO%COL)+OCTRAD>
	  ENDIF.
	  OPSTR <HRRZ T2,>,BINVAL,(T5)	; Code
	  NOUT
	    JFCL
	  CALL STIMRS			; Output Recv/send counts
	  ADDI T5,BINSIZ-1		; Two words per entry
	  AOBJN T5,TOP.			; Back for next protocol
	ENDDO.
	MOVEI T5,STSTRC+$BINVAL		; "Point" to overflow cell
	SKIPN (T5)			; Any not processed?
	IFSKP.
	  SSOUT <       Other>
	  CALL STIMRS			; Output Recv/send counts
	ENDIF.
	RET

	SUBTTL	Statistics - Format Name or Key Value

; STIMNM  Print ASCIZ string for name, or Number
;T5/	Points to current bin
;T2/	ASCIZ pointer to text (-1,,adr) or Key Value
;T1/	Destination designator

STIMNM:	PUSH P,T4
	JUMPGE T2,STIMN3		; Number
	JRST STIMN1			; ASCIZ string


; STIMNN  Print Keyword name or Number
;T5/	Points to current bin
;T4/	Points into COMND Keyword table (if match found)
;T2/	Keyword table value, if it matches BINVAL, print Keyword, else BINVAL
;T1/	Destination designator

STIMNN:	PUSH P,T4
	OPSTR <CAME T2,>,BINVAL,(T5)	; Find matching value in Keyword table?
	IFSKP.				; No, use BINVAL
	  HLRZ T2,(T4)			; Yes, get TXxxxx adr from key table
	  HRROI T2,1(T2)		; ASCIZ begins in next word
STIMN1:					; Have ASCIZ string
	  PUSH P,T1
	  HRROI T1,STSTMP
	  MOVX T3,^D12+1		; Character limit
	  SETZ T4,			; NUL ends string
	  SOUT
	  MOVX T2,<" ">
	  DPB T2,T1			; In case ended on NUL
	  HRROI T2,[ASCIZ /             /]
	  SETZ T3,			; Pad
	  SOUT

	  POP P,T1
	  HRROI T2,STSTMP
	  MOVX T3,-^D12			; Exact length
	  SOUT				; Output padded string
	ELSE.
	  LOAD T2,BINVAL,(T5)		; Key value
STIMN3:					; Value in T2
	  XNOUT <NO%LFL+FLD(^D12,NO%COL)+DECRAD>
	ENDIF.
	POP P,T4
	RET

	SUBTTL	Statistics - Format Counts

; STIMRS  Print Receive and Send Counts
;T5/	Points to current bin
;T1/	Destination designator

STIMRS:	LOAD T2,BINRCT,(T5)		; Recv count
	XNOUT <NO%LFL+FLD(^D8,NO%COL)+DECRAD>

	LOAD T2,BINSCT,(T5)		; Send count
	XNOUT <NO%LFL+FLD(^D8,NO%COL)+DECRAD>

	CALLRET CRLF

	SUBTTL	Statistics - Accumulate Statistics

; STATIS	Routine to accumulate statistics for NPACKET
; NPACKET/Current sample


STATIS:	PUSH P,T1			; Save (JFN)

; Set increment:  LH if recv, RH if send

	LOAD T1,DPTRC,+PPKT-PACKET+NPACKET ; Trace code flags
	SETZ T5,
	TXNE T1,PT%%OU			; Output?
	  ADD T5,[FLD(1,BINSCT)]	; Yes
	TXNE T1,PT%%IN			; Input?
	  ADD T5,[FLD(1,BINRCT)]	; Yes
	SKIPN T5			; Neither?
	  MOVX T5,1			; Yes, better than nothing

; Histogram trace code
					; T1 has trace code
	MOVEI T4,STSTRC+BINSIZ		; 1st pair
	CALL HISTVL			; Histogram trace code
	  NSTTRC			; Max # of bins

	LOAD T1,DPTRC,+PPKT-PACKET+NPACKET ; Trace code flags
	TXNN T1,PT%%VI+PT%%VN		; Have packet?
	IFSKP.				; Yes
					; Histogram protocol
					; Validate?
					; NNIP?
	  LOAD T1,PIPRO,+NPACKET	; Get protocol
	  MOVEI T4,STSPRT+BINSIZ	; 1st pair
	  CALL HISTVL			; Histogram protocol
	    NSTPRT			; Max # bins

	  CAIE T1,.ICMFM
	  IFSKP.
	    CALL STSICM			; Do ICMP
	  ELSE.
	    CAIN T1,.TCPFM
	      CALL STSTCP		; Do TCP
	  ENDIF.
	ENDIF.
	POP P,T1
	RET

; Histogram ICMP packets - Type and a few Codes

					; Validate?
STSICM:	LOAD T2,PIDO,+NPACKET
	ADDI T2,NPACKET+PKTELI
	LOAD T1,CMCOD,(T2)		; Code and
	LOAD T2,CMTYP,(T2)		; Type

	MOVEI T4,STSPR1			; ICMP histogram

	SETZ T3,			; Bin 0
	IFG. T2
	  MOVE T3,0(T4)			; Number of bins
	  SUBI T3,1			; Index of last bin
	  CAIGE T2,(T3)			; Have a bin?
	    MOVE T3,T2			; Yes, use it
	  LSH T3,1			; Two words per bin
	ENDIF.
	ADDI T4,2(T3)			; Locate slot
	ADDM T5,0(T4)			; Count entry

	SKIPG T4,1(T4)			; Want histogram of Codes?
	IFSKP.				; No
	  SETZ T3,			; Bin 0
	  IFG. T1
	    MOVE T3,0(T4)		; Number of bins
	    SUBI T3,1			; Index of last bin
	    CAIGE T1,(T3)		; Have a bin?
	      MOVE T3,T1		; Yes, use it
	  ENDIF.
	  ADDI T4,1(T3)			; Locate slot
	  ADDM T5,0(T4)			; Count entry
	ENDIF.
	RET

; Histogram TCP packets by "well known" port

					; Validate?
STSTCP:	LOAD T2,PIDO,+NPACKET		; Locate TCP header
	ADDI T2,NPACKET+PKTELI
	LOAD T1,PSP,(T2)		; Get Source &
	LOAD T2,PDP,(T2)		; Destination ports
	LOAD T3,DPTRC,+PPKT+NPACKET-PACKET ; Trace code & flags
	TXNN T3,PT%%OU			; Host is source if output
	  EXCH T1,T2			; But is destination if input
	TXNN T1,177400			; Using a "well known" host port?
	IFSKP.				; No
	  ADDM T5,STSPR6+1		; No, count others
	ELSE.				; T1 has "well known" port
	  MOVEI T4,STSPR6+BINSIZ	; 1st pair
	  CALL HISTVL			; Histogram T1
	    NSTPR6			; Max # bins
	ENDIF.
	RET

;  T1/	Value to be histogramed
;  T4/	Address of bin 1st
;  T5/	Count to be added
;	MOVEI T4,xxx+BINSIZ
;	CALL HISTVL
;	  max # bins
;Ret+2:	Always, T1 preserved

HISTVL:	PUSH P,T4			; Save table
	MOVN T3,-BINSIZ(T4)		; Number of bins
	IFL. T3
	  HRL T4,T3			; AOBJN pointer
	  DO.
	    LOAD CX,BINVAL,(T4)		; This bin
	    CAMN T1,CX
	      JRST HISTV8		; Yes
	    ADDI T4,BINSIZ-1		; Two words per bin
	    AOBJN T4,TOP.		; Try next
	  ENDDO.
	ENDIF.

	MOVE T3,(P)			; 1st bin
	MOVE T2,-BINSIZ(T3)		; Number of bins used
	CAML T2,@-1(P)			; Another free one?
	IFSKP.
	  STOR T1,BINVAL,(T4)		; New bin, its value
	  AOS -BINSIZ(T3)		; Another bin to check
	ELSE.
	  MOVEI T4,-1(T3)		; Count sample dropped
	ENDIF.
HISTV8:	ADDM T5,$BINRCT(T4)		; Count
	POP P,(P)
	AOS (P)			; Skip max
	RET

LITS:	LIT

	LOC <<.+777>/1000>*1000

; Temp string area

STSTMP:	BLOCK <^D12*2+5+5>/5

; Trace code statistics

NSTTRC==100
STSTRC:	BLOCK BINSIZ+BINSIZ*NSTTRC
STTTRC:	0


; Protocol Statistics Vector

NSTPRT==20				; # protocol bins
STIPRT:	EXP 2,0,0,6,0,1			; Initial values (TCP 6, ICMP 1)
STSPRT:	BLOCK BINSIZ+BINSIZ*NSTPRT	; Protocol bins
STTPRT:	0


; ICMP Statistics Array

STIPR1:	EXP 22,0,0,0,0,0,0,0,0,x3+STSPR1-STIPR1,0,0,0,x5+STSPR1-STIPR1
	EXP 0,0,0,0,0,0,0,0,0,0,0,x11+STSPR1-STIPR1,0,0,0,0,0,0,0,0,0,0,0,0
x3:	EXP 7,0,0,0,0,0,0,0
x5:	EXP 5,0,0,0,0,0
x11:	EXP 3,0,0,0
STSPR1:	BLOCK STSPR1-STIPR1
STTPR1:	0


; TCP Port Statistics Vector

NSTPR6==50				; # Port bins
STIPR6:	
STSPR6:	BLOCK BINSIZ+BINSIZ*NSTPR6	; <count,port> entries
STTPR6:	0
	BLOCK 2000


	END	<3,,ENTVEC>

