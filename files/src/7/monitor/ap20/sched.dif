

; SCHED.NEW.1 & <MONITOR>SCHED.MAC.2 31-Mar-89 2353	PAGE 1



LINE 1, PAGE 1
1)	; Edit= 8950 to SCHED.MAC on 26-Aug-88 by GSCOTT
1)	;Update more BUG. documentation.
1)	; Edit= 8923 to SCHED.MAC on 18-Aug-88 by GSCOTT
1)	;DDMP should be checked before CHKR at JB0CHK. HPSCHK BUGCHK should output the
1)	;global job number not the local job number. Update BUG. documentation. 
1)	;[SRI-NIC]SRC:<7.MONITOR>SCHED.MAC.2,  7-Nov-88 17:00:45, Edit by MKL
LINE 1, PAGE 1
2)	;[SRI-NIC]SRC:<7.MONITOR>SCHED.MAC.2,  7-Nov-88 17:00:45, Edit by MKL


LINE 15, PAGE 7
1)		    BUG.(HLT,KRSFRK,SCHED,SOFT,<Crash-on-fork invoked>,<<FORKX,CRFORK>,<CRSJBN,REQJOB>>,<
1)	
1)	Cause:	The crash-on-fork facility was invoked, scheduling the specfied fork
1)		and then crashing the system.  Console output includes the crashed fork
1)		number and the job number that requested the crash.
1)	
1)	Data:	CRFORK - Crashed fork
1)		REQJOB - Requesting job number
1)	
1)	>)
LINE 15, PAGE 7
2)		    BUG.(HLT,KRSFRK,SCHED,HARD,<Crash-on-fork invoked>,<<FORKX,CRFORK>,<CRSJBN,REQJOB>>,<
2)	
2)	Cause:  The crash-on-fork facility was invoked, scheduling the specfied
2)		fork and then crashing the system.  Console output includes the
2)		crashed fork number and the job number that requested the crash.
2)	
2)	Data:	CRFORK - Crashed fork
2)		REQJOB- - Requesting job number
2)	
2)	>)


LINE 8, PAGE 8
1)		MOVE T1,[BUG.(HLT,SCDUUO,SCHED,SOFT,<UUO in scheduler>,,<
1)	
1)	Cause:	An illegal instruction has been executed while in the scheduler's
1)		context. Since the scheduler's PSB is only a prototype PSB and UPT,
1)		allowing this MUUO to behave like others results in bizarre errors that
1)		mask the original problem.  This probably a software problem.  This
1)		BUGHLT should be analyzed like an ILLUUO.
1)	>)]
LINE 8, PAGE 8
2)		MOVE T1,[BUG.(HLT,SCDUUO,SCHED,HARD,<UUO in scheduler>,,<
2)	
2)	Cause:	An illegal instruction has been executed while in
2)		the scheduler's context. Since the scheduler's PSB

; SCHED.NEW.1 & <MONITOR>SCHED.MAC.2 31-Mar-89 2353	PAGE 2


2)		is only a prototype PSB and UPT, allowing this MUUO
2)		to behave like others results in bizarre errors
2)		that mask the original problem. This BUGHLT should
2)		be analyzed like an ILLUUO.
2)	
2)	Action:	Most likley a software bug. Analyze this like any other
2)		ILLUUO.
2)	
2)	>)]


LINE 22, PAGE 17
1)	Cause:	An OKSKED or OKSKD1 was done when the code was not NOSKED.  Clearly
1)		this is a software problem.  This is bad as sensitive code may be
1)		getting ruined because of races.  A NSKDIS BUGHLT would probably have
1)		resulted when a DISMS was done later on.
1)	
1)	Data:	ADR - Address of caller
LINE 22, PAGE 17
2)	Cause:	An OKSKED or OKSKD1 was done when the code was not NOSKED.
2)		This is bad as sensitive code may be getting ruined because 
2)		of races etc..  A NSKDIS would probably have resulted when a
2)		DISMS was done later on.
2)	
2)	Data:	ADR - Address of caller


LINE 15, PAGE 19
1)	Cause:	An ECSKED was done when the code was not really CSKED.  This is clearly
1)		a software problem.  This may cause sensitive code to be ruined because
1)		of races.
1)	>)
LINE 15, PAGE 19
2)	Cause:	An ECSKED was done when the code was not really CSKED. This may 
2)		cause sensitive code to be ruined because of races.
2)	
2)	>)


LINE 29, PAGE 20
1)		BUG.(HLT,NSKDIS,SCHED,SOFT,<Dismiss while nosked or with non-res test address>,,<
1)	
1)	Cause:	A process has declared its intention to cease running (dismiss) until a
1)		particular event occurs.  This is clearly a software problem.  The
1)		scheduler will test for the occurrence of the event by calling a
1)		routine that the process has provided.  The BUGHLT occurs if one of the
1)		following happens:
1)	
1)		1. The process has already declared itself to be NOSKED, thereby
1)		preventing the running of other processes;
1)	

; SCHED.NEW.1 & <MONITOR>SCHED.MAC.2 31-Mar-89 2353	PAGE 3


1)		2. The test routine is in part of the monitor's swappable code and
1)		could therefore cause an illegal page fault in the scheduler.
1)	>)
LINE 29, PAGE 20
2)		BUG.(HLT,NSKDIS,SCHED,HARD,<Dismiss while nosked or with non-res test address>,,<
2)	
2)	Cause:	A process has declared its intention to cease running (dismiss) until
2)		a particular event occurs. The scheduler will test for the occurrence
2)		of the event by calling a routine that the process has provided.  The
2)		BUGHLT occurs if one of the following happens:
2)			
2)		     1. The process has already declared itself to be
2)		   	NOSKED, thereby preventing the running of other processes;
2)		
2)		     2. The test routine is in  part of the monitor's swappable code
2)		   	and could therefore cause an illegal page fault in the
2)		   	scheduler.
2)	
2)	>)


LINE 8, PAGE 24
1)		BUG.(HLT,ILOKSK,SCHED,SOFT,<OKSKED executed when not NOSKED>,,<
1)	
1)	Cause:	A process has declared itself to be OKSKED and ready to cease running
1)		(dismiss) until some event occurs.  This is clearly a software problem.
1)		This BUGHLT occurs because the process is OKSKED, indicating a mismatch
1)		of NOSKED and OKSKED states.
1)	>)
LINE 8, PAGE 24
2)		BUG.(HLT,ILOKSK,SCHED,,<OKSKED executed when not NOSKED>,,<
2)	
2)	Cause:	A process has declared itself to be OKSKED and ready to cease running
2)		(dismiss) until some event occurs.  This BUGHLT occurs because the
2)		process is OKSKED, indicating a mismatch of NOSKED and OKSKED states.
2)	
2)	>)


LINE 33, PAGE 25
1)	REEBUG:	BUG.(HLT,SKDCL1,SCHED,SOFT,<Call to scheduler when already in scheduler>,,<
1)	
1)	Cause:	Code running in scheduler context has attempted to dismiss, block or
1)		page fault thereby trying to enter scheduler context again.  This might
1)		result from an unexpected page fault or faulty logic, for example the
1)		code doing the dismiss was not expected to be run in scheduler context.
1)		This BUGHLT is CALLed from several places, examination of the stack
1)		will indicate find out where the problem was discovered.  This is
1)		clearly a software problem.
1)	>)				;SOME SORT OF DISMISS IN SCHED
LINE 33, PAGE 25

; SCHED.NEW.1 & <MONITOR>SCHED.MAC.2 31-Mar-89 2353	PAGE 4


2)	REEBUG:	BUG.(HLT,SKDCL1,SCHED,HARD,<Call to scheduler when already in scheduler>,,<
2)	
2)	Cause:	Code running in scheduler context has attempted to dismiss, block
2)		or page fault thereby trying to enter scheduler context again.
2)		This might result from an unexpected page fault or faulty logic,
2)		i.e. the code doing the dismiss was not expected to be run
2)		in scheduler context.
2)	
2)	>)		;SOME SORT OF DISMISS IN SCHED


LINE 13, PAGE 27
1)		BUG.(HLT,SKDTRP,SCHED,SOFT,<Instruction trap while in scheduler>,<<KIMUPC,PC>,<LSTERR,LSTERR>,<LSTIPC,ERRPC>>,<
1)	
1)	Cause:	An error occurred, resulting in an illegal instruction trap.  If a JSYS
1)		is being executed by the monitor, the process normally receives an
1)		error return when this happens.  However, in this case the error
1)		occurred in the scheduler, and there is no recovery.
1)	
1)	Action:	Although it is possible for bad hardware to cause this BUGHLT, it is
1)		usually bad software.  If the hardware checks out OK, send in an SPR
1)		along with a dump and indicate how this problem can be reproduced.
1)	
1)	Data:	PC - PC of last MUUO, this may or may not be relevant
1)		LSTERR - Last error code, this may indicate where error was generated
1)		ERRPC -  PC where ITRAP was called
LINE 13, PAGE 27
2)		BUG.(HLT,SKDTRP,SCHED,HARD,<Instruction trap while in scheduler>,<<KIMUPC,PC>,<LSTERR,LSTERR>,<LSTIPC,ERRPC>>,<
2)	
2)	Cause:	An error occurred, resulting in an illegal instruction
2)		trap. If a JSYS is being executed by the monitor, the
2)		process normally receives an error return when this happens.
2)		However, in this case the error occurred in the scheduler,
2)		and there is no recovery.
2)	
2)	Data:	PC - PC of last MUUO.  This may or may not be relevant
2)		LSTERR - Last error code.  This may indicate where error was
2)			 generated
2)		ERRPC -  PC where ITRAP was called


LINE 33, PAGE 27
1)		was being executed by the monitor, the process would receive an error
1)		return.  However, in this case the error occurred while a hardware
1)		interrupt (PI) was being processed, or while the monitor was executing
1)		code that starts the scheduler cycle.
1)	
1)	Action:	Although it is possible for bad hardware to cause this BUGHLT, it is
1)		usually bad software.  If the hardware checks out OK, send in an SPR
1)		along with a dump and indicate how this problem can be reproduced.
1)	

; SCHED.NEW.1 & <MONITOR>SCHED.MAC.2 31-Mar-89 2353	PAGE 5


1)	Data:	LSTERR - Last error code, this may indicate where error was generated.
1)		ERRPC - PC at which error was generated.
LINE 31, PAGE 27
2)		was being executed by the monitor, the process would receive an
2)		error return.  However, in this case the error occurred  while a
2)		hardware interrupt (PI) was being processed, or while the monitor was
2)		executing code that starts the scheduler cycle.
2)	
2)	Data:	LSTERR - Last error code.  This may indicate where error was
2)			 generated.
2)		ERRPC - PC at which error was generated.


LINE 5, PAGE 28
1)	Cause:	The illegal instruction trap handler has been entered, but the process
1)		is not in JSYS context.
1)	
1)	Action:	This BUGHLT is normally seen with bad hardware.  If the hardware checks
1)		out OK, send in an SPR along with a dump and indicate how this problem
1)		can be reproduced.
1)	
1)	Data:	LSTERR - Last error code
LINE 5, PAGE 28
2)	Cause:	The illegal instruction trap handler has been entered, but the
2)		process is not in JSYS context.
2)	
2)	Data:	LSTERR - Last error code


LINE 11, PAGE 29
1)	Cause:	An illegal instruction trap has occurred while the process was NOSKED
1)		or CSKED.  This suggests that important resources may be left locked.
1)	
1)	Action:	This BUGHLT is normally seen with bad hardware.  If the hardware checks
1)		out OK, send in an SPR along with a dump and indicate how this problem
1)		can be reproduced.
1)	
1)	Data:	MUUOPC - PC of last MUUO
LINE 40, PAGE 28
2)	Cause:	An illegal instruction trap has occurred while the process
2)		was NOSKED or CSKED.  This suggests that important
2)		resources may be left locked.
2)	
2)	Action:	See if this is reproducible, and if so, report the
2)		sequence to Software Engineering.
2)	
2)	Data:	MUUOPC - PC of last MUUO


; SCHED.NEW.1 & <MONITOR>SCHED.MAC.2 31-Mar-89 2353	PAGE 6



LINE 15, PAGE 30
1)	Cause:	An illegal instruction trap has occurred and the previous context is
1)		the monitor but no ERJMP is present following the nested JSYS call.
1)		This violates required coding practice because the previous context may
1)		have locks that need to be released.
1)	
1)	Action:	If this problem can be reproduced, set this bug dumpable and submit 
1)		an SPR along with the dump and instructions on reproducing the problem.
1)	
1)	Data:	FLAGS - Processor flags
LINE 15, PAGE 29
2)	Cause:	An illegal instruction trap has occurred and the previous context
2)		is the monitor but no ERJMP is present following the nested
2)		JSYS call.  This violates required coding practice because
2)		the previous context may have locks that need to be released.
2)	
2)	Action:	If this is reproducible, report the circumstances to
2)		Software Engineering.
2)	
2)	Data:	FLAGS - Processor flags


LINE 11, PAGE 38
1)	Action:	Field Service should check out the system carefully.  This BUGHLT is
1)		seen with bad hardware.  If the hardware checks out OK, send in an SPR
1)		along with a dump and indicate how this problem can be reproduced.
1)	>)
LINE 10, PAGE 37
2)	>)


LINE 1, PAGE 43
1)	;Check DDMP and CHKR 
1)	
1)	;[8923] DDMP is now checked first since it is usually the one that blocks
1)	;trying to write on a disk, and the DDMPNR BUGHLT will therefore come out
1)	;rather than blaming an innocent CHKR (which can be blocked by DDMP).
1)	
1)	JB0CHK::
1)		MOVEI T1,^D10000	;WANT TO RUN AGAIN IN 10 SECONDS
1)		MOVEM T1,JB0TIM		;SAVE FOR POSTERITY
1)		CALL CKDDMP		;[8923] Check on DDMP
1)	;	CALLRET CKCHKR		;[8923] Check on CHKR and return
   {Skipped 1 page and 1 line}
1)	;[8923] Here to check on CHKR
1)	
1)	CKCHKR:	MOVE T1,TODCLK		;[8923] Get the current time
1)		CAMGE T1,CHKTIM		;[8923] CHKR overdue?
1)		RET			;[8923] Not overdue, return now

; SCHED.NEW.1 & <MONITOR>SCHED.MAC.2 31-Mar-89 2353	PAGE 7


1)		AOS T1,CHKDUE		;Bump the count of overdues
1)		CAIL T1,CHKMAX		;Has it been overdue too long?
1)		BUG.(HLT,CHKRNR,SCHED,HARD,<CHKR fork not run for too long>,,<
1)	
1)	Cause:	The monitor creates a fork in job zero that exists for the life of the
1)		system.  This fork runs periodically to perform essential system
1)		functions.  The BUGHLT occurs when the scheduler detects that the CHKR
1)		fork has not run for too long a time.
1)	
1)		Possible causes for CHKR not running include: 
1)			1. A disk failure that prevents job 0 from updating the disk
1)			2. Removal of a disk that is mounted
1)			3. An HSC or MSCP server disk is hung
1)			4. Logic errors in the monitor.
1)	
1)	Action:	Check the console output from this system.  Try to find out if any disk
1)		problems are blocking DDMP.  It is unlikely that this is a software
1)		problem.  Examination of the dump will probably show that some fork is
1)		at the top of the go list and is blocked and NOSKED.  If this fork is
1)		DDMP then it is a disk problem.  If CHKR is at the top of the go list
1)		there is probably a software problem.
1)	>)				;[8923]
1)		CAIE T1,1		;[8923] Is this the first time?
1)		BUG.(CHK,NOCHKR,SCHED,HARD,<CHKR fork blocked>,<<T1,CHKDUE>>,<
1)	
1)	Cause:	The CHKR fork has not run in a while.  The monitor is getting nervous.
1)		If the CHKR fork continues to not run for a long time the a CHKRNR
1)		BUGHLT will result.
1)	
1)		Possible causes for CHKR not running include: 
1)			1. A disk failure that prevents fork 0 from updating the disk
1)			2. Removal of a disk that is mounted
1)			3. An HSC or MSCP server disk is hung
1)			4. Logic errors in the monitor.
1)	
1)	Action:	Check the console output from this system.  Try to find out if any disk
1)		problems are blocking job 0.  It is unlikely that this is a software
1)		problem.
1)	
1)	Data:	CHKDUE - Count of times CHKR was found overdue
1)	>,,<DB%NND>)			;[7.1210] 
1)		AOS JB0FLG		;[8923] Make sure CHKR will run soon
1)		MOVE T1,TODCLK		;[8923] Get the current time
1)		ADD T1,CHKPER		;[8923] Get the alarm time
1)		MOVEM T1,CHKTIM		;[8923] Set the alarm time
1)		RET			;[8923]  and return
   {Skipped 1 page and 1 line}
1)	;[8923] Here to check on DDMP.
1)	
1)	CKDDMP:	MOVE T1,TODCLK		;[8923] Get the current time
1)		CAMGE T1,DDPTIM		;[8923] Is DDMP overdue?

; SCHED.NEW.1 & <MONITOR>SCHED.MAC.2 31-Mar-89 2353	PAGE 8


1)		RET			;[8923] Not overdue, return now
1)	        AOS T1,DDPDUE		;Bump the overdue count
1)		CAIL T1,DDPMAX		;Overdue too long?
1)		BUG.(HLT,DDMPNR,SCHED,HARD,<DDMP fork not run for too long>,,<
1)	
1)	Cause:	The monitor creates a fork in job zero that exists for the life of the
1)		system.  This fork runs periodically to move pages from the swapping
1)		space to files on disk.  This is an essential system function.  The
1)		BUGHLT occurs when the scheduler detects that the DDMP fork has not run
1)		in too long a time.
1)	
1)		Possible causes for DDMP not running include: 
1)			1. A disk failure that prevents DDMP from updating the disk
1)			2. Removal of a disk that is mounted causing DDMP to block
1)			3. An HSC or MSCP server disk is hung causing DDMP to block
1)			4. Logic errors in the monitor.
1)	
1)	Action:	Check the console output from this system.  Try to find out if any disk
1)		problems are blocking DDMP.  It is unlikely that this is a software
1)		problem.  Examination of the dump will probably show that some fork is
1)		at the top of the go list and is blocked and NOSKED.  If this fork is
1)		DDMP then it is a disk problem.  If CHKR is at the top of the go list
1)		there is probably a software problem.
1)	>)				;[8923]
1)		CAIE T1,1		;Is this the first time?
1)		BUG.(CHK,NODDMP,SCHED,HARD,<DDMP fork blocked>,<<T1,DDPDUE>>,<
1)	
1)	Cause:	The monitor creates a fork in job zero that exists for the life of the
1)		system.  This fork runs periodically to move pages from the swapping
1)		space to files on disk.  This is an essential system function. 	The
1)		DDMP fork has not run in a while.  The monitor is getting nervous.  If
1)		the DDMP fork continues to not run for a long time the a DDMPNR BUGHLT
1)		will result.
1)	
1)		Possible causes for DDMP not running include: 
1)			1. A disk failure that prevents DDMP from updating the disk
1)			2. Removal of a disk that is mounted causing DDMP to block
1)			3. An HSC or MSCP server disk is hung causing DDMP to block
1)			4. Logic errors in the monitor.
1)	
1)	Action:	Check the console output from this system.  Try to find out if any disk
1)		problems are blocking DDMP.  It is unlikely that this is a software
1)		problem.
1)	
1)	Data:	DDPDUE - Count of times DDMP was found overdue
1)	>,,<DB%NND>)			;[8923][7.1210] 
1)		MOVE T1,TODCLK		;Get the current time
1)		ADD T1,DDPPER		;Get the next alarm time
1)		MOVEM T1,DDPTIM		;Set the next alarm time
1)		RET			;[8923] Return
   {Skipped 1 page and 1 line}

; SCHED.NEW.1 & <MONITOR>SCHED.MAC.2 31-Mar-89 2353	PAGE 9


1)	;CHECK LOAD AVS AND LITES
LINE 1, PAGE 42
2)	;CHECK DDMP AND CHKR 
2)	
2)	JB0CHK::
2)		MOVEI	T1,^D10000	;WANT TO RUN AGAIN IN 10 SECONDS
2)		MOVEM	T1,JB0TIM	;SAVE FOR POSTERITY
2)		MOVE T1,TODCLK		;GET THE CURRENT TIME
2)		CAMGE T1,CHKTIM		;CHKR OVERDUE?
2)		 JRST JB0C.0		;NOT OVERDUE
2)		AOS T1,CHKDUE		;BUMP THE COUNT OF OVERDUES
2)		CAIL T1,CHKMAX		;HAS IT BEEN OVERDUE TOO LONG?
2)		BUG.(HLT,CHKRNR,SCHED,SOFT,<CHKR fork not run for too long>,,<
2)	
2)	Cause:	The  monitor  creates  a fork in job zero that exists for the life of
2)		the  system.  This  fork  runs  periodically  to  perform   essential
2)		functions.  The  BUGHLT  occurs  when the scheduler detects that the
2)		CHKR fork has not run for too long a time.
2)	
2)		Possible causes for CHKR not running include: 
2)			1. A disk failure that prevents fork 0 from updating the disk
2)			2. Removal of a  mounted structure
2)			3. Logic errors in the monitor.
2)			4. An HSC or MSCP server disk is hung.
2)	
2)	>)
2)		CAIE T1,1		;IS THIS THE FIRST TIME?
2)		BUG.(CHK,NOCHKR,SCHED,SOFT,<CHKR fork blocked>,<<T1,CHKDUE>>,<
2)	
2)	Cause:	The CHKR fork has not run in a while.  The monitor is getting
2)		nervous.  If the CHKR fork continues to not run for a long time
2)		the a CHKRNR BUGHLT will result.
2)	
2)	Data:	CHKDUE - Count of times CHKR was found overdue
2)	>,,<DB%NND>)			;[7.1210] 
2)		AOS JB0FLG		;MAKE SURE CHKR WILL RUN
2)		MOVE T1,TODCLK		;GET THE CURRENT TIME
2)		ADD T1,CHKPER		;GET THE ALARM TIME
2)		MOVEM T1,CHKTIM		;SET THE ALARM TIME
   {Skipped 1 page and 1 line}
2)	JB0C.0:				;HERE AFTER CHECKING UP ON CHKR
2)		CAMGE T1,DDPTIM		;DDMP OVERDUE?
2)		 JRST JB0C.1		;NOT OVERDUE
2)	        AOS T1,DDPDUE		;BUMP THE OVERDUE COUNT
2)		CAIL T1,DDPMAX		;OVERDUE TOO LONG?
2)		BUG.(HLT,DDMPNR,SCHED,SOFT,<DDMP fork not run for too long>,,<
2)	
2)	Cause:	The  monitor  creates  a fork in job zero that exists for the life of
2)		the  system.  This  fork  runs  periodically  to  perform   essential
2)		functions.  The  BUGHLT  occurs  when the scheduler detects that the
2)		DDMP fork has not run in too long a time.

; SCHED.NEW.1 & <MONITOR>SCHED.MAC.2 31-Mar-89 2353	PAGE 10


2)	
2)		Possible causes for DDMP not running include the following:
2)			1. A disk failure that prevents fork 0 from updating the
2)			   disk
2)			2. Removal of a  mounted structure
2)			3. Logic errors in the monitor.
2)	
2)	>)
2)		CAIE T1,1		;IS THIS THE FIRST TIME?
2)		BUG.(CHK,NODDMP,SCHED,SOFT,<DDMP fork blocked>,<<T1,DDPDUE>>,<
2)	
2)	Cause:	The DDMP fork has not run in a while.  The monitor is getting
2)		nervous.  If the DDMP fork continues to not run for a long time
2)		the a DDMPNR BUGHLT will result.
2)	
2)	Data:	DDPDUE - Count of times DDMP was found overdue
2)	>,,<DB%NND>)			;[7.1210] 
2)		MOVE T1,TODCLK		;GET THE CURRENT TIME
2)		ADD T1,DDPPER		;GET THE NEXT ALARM TIME
2)		MOVEM T1,DDPTIM		;SETTHE NEXT ALARM
2)					;HERE AFTER CHECKING UP ON DDMP
2)	JB0C.1:	RET
   {Skipped 1 page and 1 line}
2)	;CHECK LOAD AVS AND LITES


LINE 16, PAGE 54
1)		BUG.(CHK,SRQBAD,SCHED,SOFT,<SCDRQ - Bad call to SCDRQ7>,,<
1)	
1)	Cause:	SCDRQ7 was called with a function it does not know about.  Fix the
1)		caller or fix SCDRQ7 to know about this function.
1)	
1)	Action:	If this bug can be reproduced, set it dumpable and submit an SPR along
1)		with a dump and how to reproduce the problem.
1)	>)
LINE 16, PAGE 52
2)		BUG.(CHK,SRQBAD,SCHED,HARD,<SCDRQ - Bad call to SCDRQ7>,,<
2)	
2)	Cause:	SCDRQ7 was called with a function it does not know about.
2)	
2)	Action:	Fix the call or fix SCDRQ7 to know about this function.
2)	
2)	>)


; SCHED.NEW.1 & <MONITOR>SCHED.MAC.2 31-Mar-89 2353	PAGE 11



LINE 4, PAGE 59
1)		BUG.(HLT,SKDFKS,SCHED,SOFT,<Illegal scheduler action while fork context setup>,,<
1)	
1)	Cause:  The scheduler was about to perform an action that requires that no fork
1)		context is setup.  The monitor found that FORKX was non-negative which
1)		indicates that fork context was setup.
1)	
1)	Action:	Submit an SPR along with the dump and any information on reproducing
1)		the problem.
1)	
1)		To fix the problem, change the monitor to call DISMSJ before calling
1)		the routine or move the call to a more appropriate place. CLK2 always
1)		forces DISMSJ and is usually a good place for periodic actions.
1)	>)
LINE 4, PAGE 57
2)		BUG.(HLT,SKDFKS,SCHED,HARD,<Illegal scheduler action while fork context setup>,,<
2)	
2)	Cause:  The scheduler was about to perform an action that requires that no fork
2)		context is setup. The monitor found that FORKX was non-negative which
2)		indicates that fork context was setup.
2)	
2)	Action:	Change the monitor to call DISMSJ before calling the routine or 
2)		move the call to a more appropriate place. CLK2 always forces 
2)		DISMSJ and is usually a good place for periodic actions.
2)	>)


LINE 10, PAGE 70
1)		  BUG.(CHK,SUMNR2,SCHED,SOFT,<WSMGR - SUMNR incorrect>,<<T3,SUMNR>,<T4,CHECK>>,<
1)	
1)	Cause:	The sum of reserve pages as stored in SUMNR was found to be incorrect
1)		by routine WSMGR. The correct value has been computed and stored in
1)		SUMNR.  This problem is difficult to diagnose.
1)	
1)	Action:	If this BUGCHK can be reproduced, change it to a BUGHLT and submit an
1)		SPR along with a dump and how to reproduce the problem.
1)	
1)	Data:	SUMNR - Current SUMNR value
LINE 10, PAGE 68
2)		  BUG.(CHK,SUMNR2,SCHED,HARD,<WSMGR - SUMNR incorrect>,<<T3,SUMNR>,<T4,CHECK>>,<
2)	
2)	Cause:	The sum of reserve pages as stored in SUMNR was found to be
2)		incorrect by routine WSMGR. The correct value has been computed and
2)		stored in SUMNR.
2)	
2)	Data:	SUMNR - Current SUMNR value


; SCHED.NEW.1 & <MONITOR>SCHED.MAC.2 31-Mar-89 2353	PAGE 12



LINE 23, PAGE 79
1)		  BUG.(CHK,SUMNR1,SCHED,SOFT,<AJBALX - SUMBNR incorrect>,<<T3,SUMBNR>,<T4,CHECK>>,<
1)	
1)	Cause:	The value of SUMBNR has been found to be incorrect by AJBALX.  The
1)		correct value of SUMBNR has been computed and stored in SUMBNR.  This
1)		problem is difficult to diagnose.
1)	
1)	Action:	If this BUGCHK can be reproduced, change it to a BUGHLT and submit an
1)		SPR along with a dump and how to reproduce the problem.
1)	
1)	Data:	SUMBNR - Sum of working sets in balance set
LINE 23, PAGE 77
2)		  BUG.(CHK,SUMNR1,SCHED,HARD,<AJBALX - SUMBNR incorrect>,<<T3,SUMBNR>,<T4,CHECK>>,<
2)	
2)	Cause:	The value of SUMBNR has been found to be incorrect by AJBALX. The
2)		correct value of SUMBNR has been computed and stored in SUMBNR.
2)	
2)	Data:	SUMBNR - Sum of working sets in balance set


LINE 12, PAGE 88
1)		BUG.(CHK,FKWSP1,SCHED,SOFT,<LOADBS - Unreasonable FKWSP>,<<T1,FKWSS>,<T2,COUNT>,<T3,FKCSIZ>,<FX,FORK>>,<
1)	
1)	Cause:	The value of FKCSIZ for this fork was found to be incorrect.
1)		Specifically, the value of FKWSS was found to be less than the value of
1)		FKCSIZ for this work.  The correct value is being computed and saved in
1)		FKCSIZ.  This problem is difficult to diagnose.
1)	
1)	Action:	If this BUGCHK can be reproduced, change it to a BUGHLT and submit an
1)		SPR along with a dump and how to reproduce the problem.
1)	
1)	Data:	FKWSS - Fork's reserve working set size
LINE 12, PAGE 86
2)		BUG.(CHK,FKWSP1,SCHED,HARD,<LOADBS - Unreasonable FKWSP>,<<T1,FKWSS>,<T2,COUNT>,<T3,FKCSIZ>,<FX,FORK>>,<
2)	
2)	Cause:	The value of FKCSIZ for this fork was found to be incorrect.
2)		Specifically, the value of FKWSS was found to be less than the
2)		value of FKCSIZ for this work. The correct value is being computed
2)		and saved in FKCSIZ.
2)	
2)	Data:	FKWSS - Fork's reserve working set size


; SCHED.NEW.1 & <MONITOR>SCHED.MAC.2 31-Mar-89 2353	PAGE 13



LINE 5, PAGE 90
1)		    MOVE T2,GBLJNO	;[8923] Yes, job probably stuck
1)	
1)	;This bugchk is intended to detect forks which are running with priority (e.g.
1)	;JP%SYS, NOSKED, CRKSED, or even PIBUMP) and using too much time.  This is
1)	;useful to know because such cases impact response for all ordinary users.  The
1)	;bugchk reports the job and fork number of the offending fork.  DLM 10/28/81
1)	
1)	HPSHOG:	    SKIPA		;[8923] JFCL here if you want this BUG output
1)		    BUG.(CHK,HPSCHK,SCHED,SOFT,<Excessive time in high priority>,<<T2,JOBNO>,<FX,FRKNO>>,<
1)	
1)	Cause:	A fork has entered a high priority scheduling condition (PIBMP, CSKED,
1)		or JP%SYS), and has remained compute-bound for more than 5 seconds.
1)		The fork has probably malfunctioned in some way, and the high
1)		scheduling priority is affecting overall system response.  The high
1)		priority status is disabled until the fork itself clears the condition.
1)	
1)	Action:	The additional data contains the job number and system fork number.
1)		The program should be changed to either not be so compute bound or not
1)		set itself as high priority.
1)	
1)	Data:	GBLJNO - Job number
1)		FRKNO - Fork number
1)	>)				;[8923]
1)		    SETONE BSOVRD	;OVERRIDE PRIORITY
LINE 5, PAGE 88
2)		    MOVE T2,JOBNO	;YES, JOB PROBABLY STUCK
2)	
2)	;This bugchk is intended to detect forks which are running with priority
2)	;(e.g. JP%SYS, NOSKED, CRKSED, or even PIBUMP) and using too much time.
2)	;This is useful to know because such cases impact response for all
2)	;ordinary users.  The bugchk reports
2)	;the job and fork number of the offending fork.   DLM  10/28/81
2)	
2)		    SKIPA
2)		    BUG.(CHK,HPSCHK,SCHED,SOFT,<SCHEDULER - Excessive time in high priority>,<<T2,JOBNO>,<FX,FRKNO>>,<
2)	
2)	Cause:	A fork has entered a high priority scheduling condition, i.e.
2)		PIBMP, CSKED, or JP%SYS, and has remained compute-bound for more than
2)		5 seconds.  The fork has probably malfunctioned in some way, and
2)		the high scheduling priority is affecting overall system response.
2)	
2)	Action:	The high priority status is disabled until the fork itself
2)		clears the condition.
2)	
2)	Data:	JOBNO - Job number
2)		FRKNO - Fork number
2)	>)
2)		    SETONE BSOVRD	;OVERRIDE PRIORITY

; SCHED.NEW.1 & <MONITOR>SCHED.MAC.2 31-Mar-89 2353	PAGE 14




LINE 3, PAGE 96
1)		CALL [	BUG.(CHK,NEGJRT,SCHED,SOFT,<UCLOCK - Negative JOBRT detected>,<<T2,JOBNO>>,<
1)	
1)	Cause:	The job runtime (JOBRT) is negative for an existing job.  This would
1)		cause the job to appear non-existent to most JSYSes.  The monitor will
1)		use a reasonable value for JOBRT (0) and logout the job.
1)	
1)	Action:	If this BUGCHK can be reproduced, set it dumpable and submit an SPR
1)		along with a dump and how to reproduce the problem.
1)	
1)	Data:	JOBNO - Job number
LINE 3, PAGE 94
2)		CALL [	BUG.(CHK,NEGJRT,SCHED,SOFT,<UCLOCK: Negative JOBRT detected>,<<T2,JOBNO>>,<
2)	
2)	Cause:	The job runtime (JOBRT) is negative for an existing job.  This
2)		would cause the job to appear non-existent to most JSYSes.
2)	
2)	Action:	Use a reasonable value for JOBRT (0) and logout the job.
2)	
2)	Data:	JOBNO - Job number


LINE 19, PAGE 102
1)	UBBAD:	BUG.(CHK,UNBFNF,SCHED,SOFT,<Fork not found>,,<
1)	
1)	Cause:	This BUG can be caused in one of three ways:
LINE 19, PAGE 100
2)	UBBAD:	BUG.(CHK,UNBFNF,SCHED,HARD,<Fork not found>,,<
2)	
2)	Cause:	This BUG can be caused in one of three ways:


LINE 32, PAGE 102
1)	Action:	If this BUGCHK can be reproduced, set it dumpable and submit an SPR
1)		along with a dump and how to reproduce the problem.
1)	>)
LINE 31, PAGE 100
2)	>)


LINE 31, PAGE 109
1)	GLREM2:	BUG.(HLT,GLFNF,SCHED,SOFT,<GLREM - Fork not found>,,<
1)	
1)	Cause:	The scheduler is trying to remove a process from its linked list of
LINE 31, PAGE 107
2)	GLREM2:	BUG.(HLT,GLFNF,SCHED,HARD,<GLREM - Fork not found>,,<
2)	
2)	Cause:	The scheduler is trying to remove a process from its linked list of


; SCHED.NEW.1 & <MONITOR>SCHED.MAC.2 31-Mar-89 2353	PAGE 15



LINE 32, PAGE 131
1)	Cause:	A call to MSETPT to clear the job map or process map for the top fork
1)		of a job being killed has failed.
1)	
1)	Action:	If this BUGCHK can be reproduced, set it dumpable and submit an SPR
1)		along with a dump and how to reproduce the problem.
1)	>)
LINE 32, PAGE 129
2)	Cause:	A call to MSETPT to clear the job map or process map for
2)		the top fork of a job being killed has failed.
2)	
2)	Action:	Continue.
2)	>)


LINE 5, PAGE 132
1)		BUG.(HLT,TTDAS1,SCHED,SOFT,<HLTJB - Unable to deassign controlling terminal>,,<
1)	
1)	Cause:	The monitor is killing the last (top) fork in a job and is trying to
LINE 5, PAGE 130
2)		BUG.(HLT,TTDAS1,SCHED,HARD,<HLTJB - Unable to deassign controlling terminal>,,<
2)	
2)	Cause:	The monitor is killing the last (top) fork in a job and is trying to


LINE 16, PAGE 134
1)		BUG.(CHK,FRKNDL,SCHED,SOFT,<HLTFRK - Fork not properly deleted>,,<
1)	
1)	Cause:	HLTFRK was called to complete the deletion process for a fork but a
1)		check of FKCSIZ showed that not all pages belonging to this fork have
1)		been deleted.  This indicates an inconsistency in the monitor's data
1)		base.
1)	
1)	Action:	If this BUGCHK can be reproduced, set it dumpable and submit an SPR
1)		along with a dump and how to reproduce the problem.
1)	>)
LINE 16, PAGE 132
2)		BUG.(CHK,FRKNDL,SCHED,HARD,<HLTFRK - Fork not properly deleted>,,<
2)	
2)	Cause:	HLTFRK was called to complete the deletion process for a fork but
2)		a check of FKCSIZ showed that not all pages belonging to this fork
2)		have been deleted. This indicates an inconsistency in the monitor's
2)		data base.
2)	
2)	Action:	Contine deletion process
2)	
2)	>)


; SCHED.NEW.1 & <MONITOR>SCHED.MAC.2 31-Mar-89 2353	PAGE 16



LINE 27, PAGE 143
1)		BUG.(CHK,UNPIRX,SCHED,SOFT,<UNPIR - No PSI in progress>,,<
1)	
1)	Cause:	UNPIR was called to leave PSI context but there was no PSI in progress.
1)	
1)	Action:	If this BUGCHK can be reproduced, set it dumpable and submit an SPR
1)		along with a dump and how to reproduce the problem.
1)	>)
LINE 27, PAGE 141
2)		BUG.(CHK,UNPIRX,SCHED,HARD,<UNPIR - No PSI in progress>,,<
2)	
2)	Cause:	UNPIR was called to leave PSI context but there was no PSI in
2)		progress.
2)	
2)	Action:	Continue.
2)	
2)	>)


LINE 18, PAGE 155
1)	Cause:	At PSII, the PC flags were not set properly.  All paths to PSII should
1)		ensure that PCU is 1 and PCS is non-0.  This is under a debug
1)		conditional and so should not be seen in the field.
1)	
1)	Action:	If this BUGCHK can be reproduced, set it dumpable and submit an SPR
1)		along with a dump and how to reproduce the problem.
1)	
1)	Data:	FLAGS - Flags from XSFM.
LINE 18, PAGE 153
2)	Cause:	At PSII, the PC flags were not set properly.  All paths
2)		to PSII should ensure that PCU is 1 and PCS is non-0.  This
2)		is under a debug conditional and so should not be seen in the
2)		field.
2)	
2)	Data:	FLAGS - Flags from XSFM.


LINE 1, PAGE 163
1)	PIOVFW:	BUG.(HLT,PSISTK,SCHED,SOFT,<PSI Storage stack overflow>,,<
1)	
1)	Cause:	A software interrupt occurred while a process was running in the
1)		monitor.  The monitor is saving information regarding the state of the
1)		process so that in can restore that state when the process dismisses
1)		the interrupt.  The BUGHLT indicates that the storage area has
1)		overflowed.
1)	>)
LINE 1, PAGE 161
2)	PIOVFW:	BUG.(HLT,PSISTK,SCHED,HARD,<PSI Storage stack overflow>,,<
2)	

; SCHED.NEW.1 & <MONITOR>SCHED.MAC.2 31-Mar-89 2353	PAGE 17


2)	Cause:	A software interrupt occurred while a process was running
2)		in the monitor. The monitor is saving information regarding
2)		the state of the process so that in can restore that state
2)		when the process dismisses the interrupt. The BUGHLT indicates
2)		that the storage area has overflowed.
2)	>)


LINE 16, PAGE 168
1)		BUG.(CHK,PSINSK,SCHED,SOFT,<PSI From NOSKED or CRSKED context>,,<
1)	
1)	Cause:	A process is NOSKED or CSKED, but is not NOINT.  This indicates a
1)		monitor software error.
1)	
1)	Action:	If this BUGCHK can be reproduced, set it dumpable and submit an SPR
1)		along with a dump and how to reproduce the problem.
1)	>)
LINE 16, PAGE 166
2)		BUG.(CHK,PSINSK,SCHED,HARD,<PSI From NOSKED or CRSKED context>,,<
2)	
2)	Cause:	This process is NOSKED or CSKED, but is not NOINT.
2)	
2)	>)


LINE 4, PAGE 175
1)		 BUG.(CHK,TRPSIE,SCHED,SOFT,<TRAPSI - No monitor for trapped fork>,,<
1)	
1)	Cause:	A fork executed a JSYS that was marked as trapped, but there is no fork
1)		monitoring this JSYS trap.  The JSYS trap will be ignored.
1)	
1)	Action:	If this BUGCHK can be reproduced, set it dumpable and submit an SPR
1)		along with a dump and how to reproduce the problem.
1)	>)
LINE 4, PAGE 173
2)		 BUG.(CHK,TRPSIE,SCHED,HARD,<TRAPSI - No monitor for trapped fork>,,<
2)	
2)	Cause:	A fork executed a JSYS that was marked as trapped, but there is no
2)		fork monitoring this JSYS trap.
2)	
2)	Action:	Ignore the JSYS trap.
2)	
2)	>)


; SCHED.NEW.1 & <MONITOR>SCHED.MAC.2 31-Mar-89 2353	PAGE 18



LINE 17, PAGE 178
1)	Cause:	A process has attempted to lock the JSYS trap lock and found it already
1)		locked.  The process will enter a queue and dismiss until the lock
1)		becomes available.  The BUGHLT occurs because when the process
1)		decrements its NOSKED counter, the value does not go to 0.  This means
1)		that the process is still NOSKED or it was OKSKED when it should have
1)		been NOSKED.
1)	>)
LINE 17, PAGE 176
2)	Cause:	A process has attempted to lock the JSYS trap lock and found
2)		it already locked. The process will enter a queue and dismiss until
2)		the lock becomes available. The BUGHLT occurs because when the process
2)		decrements its NOSKED counter, the value does not go to 0. This
2)		means that the process is still NOSKED or it was OKSKED when it
2)		should have been NOSKED.
2)	>)


LINE 21, PAGE 183
1)	Cause:	At entry to a JSYS called within the monitor, the return PC is in
1)		section 0.  This is a coding error which should be corrected.  This is
1)		under a debug conditional, so it should never occur in the field.
1)	
1)	Action:	If this BUGCHK can be reproduced, set it dumpable and submit an SPR
1)		along with a dump and how to reproduce the problem.
1)	
1)	Data:	PC - PC of offending JSYS
LINE 21, PAGE 181
2)	Cause:	At entry to a JSYS called within the monitor, the return PC is
2)		in section 0.  This is a coding error which should be corrected.
2)		This is under a debug conditional, so it should never occur in
2)		the field.
2)	
2)	Data:	PC - PC of offending JSYS


LINE 33, PAGE 183
1)	Cause:	At the time of a nested JSYS call, INTDF was less than -1.  Some code
1)		in the calling context must have fouled it up.  This is under a debug
1)		conditional and so should not appear in the field.
1)	
1)	Action:	If this BUGCHK can be reproduced, set it dumpable and submit an SPR
1)		along with a dump and how to reproduce the problem.
1)	
1)	Data:	PC - PC at which last JSYS was executed.
LINE 31, PAGE 181
2)	Cause:	At the time of a nested JSYS call, INTDF was less than -1.  Some
2)		code in the calling context must have fouled it up.  This is
2)		under a debug conditional and so should not appear in the field.

; SCHED.NEW.1 & <MONITOR>SCHED.MAC.2 31-Mar-89 2353	PAGE 19


2)	
2)	Data:	PC - PC at which last JSYS was executed.


LINE 8, PAGE 184
1)	Cause:	When a JSYS is executed from within the monitor, the AC's of the
1)		current process are stored in a special area in the monitor.  This area
1)		consists of several 20-word blocks that are used successively as one
1)		JSYS invokes another.  The BUGHLT indicates that a JSYS has been called
1)		but that no 20-word block is left in which to store the contents of the
1)		AC's.  This usually means that the counter that the monitor uses to
1)		keep track of these blocks has been clobbered.
1)	
1)	Data:	PC - PC at which last JSYS was executed
LINE 8, PAGE 182
2)	Cause:	When a JSYS is executed from within the monitor, the
2)		AC's of the current process are stored in a special area in the
2)		monitor.  This area consists of several 20-word blocks that are used
2)		successively as one JSYS invokes another.  The BUGHLT indicates that a
2)		JSYS has been called but that no 20-word block is left in which to
2)		store the contents of the AC's.  This usually means that the counter
2)		that the monitor uses to keep track of these blocks has been
2)		clobbered.
2)	
2)	Data:	PC - PC at which last JSYS was executed


LINE 11, PAGE 185
1)	Cause:	MCENTR has been used without FFL setup to be a user PC.  This is a
1)		coding error.
1)	
1)	Data:	PC - PC at which MCENTR was executed
LINE 11, PAGE 183
2)	Cause:	MCENTR has been used without FFL setup to be a user PC.  This is 
2)		a coding error.
2)	
2)	Data:	PC - PC at which MCENTR was executed


LINE 17, PAGE 187
1)	Cause:	At entry to a monitor call from a user mode process was found to be
1)		NOSKED or CSKED.  This should not happen unless flag PNSKDC is set
1)		indicating that a DIAG% has been done.
LINE 17, PAGE 185
2)	Cause:	At entry to a monitor call from a user mode process was found to
2)		be NOSKED or CSKED.  This should not happen unless flag PNSKDC is set
2)		indicating that a DIAG% has been done.


; SCHED.NEW.1 & <MONITOR>SCHED.MAC.2 31-Mar-89 2353	PAGE 20



LINE 10, PAGE 189
1)	Cause:	At MRETN, INTDF was found to be less than -1.  This indicates that this
1)		JSYS code did an unmatched OKINT and may have allowed interrupts when
1)		it didn't intend to.  This is a coding error.
1)	
1)	Action:	If this BUGCHK can be reproduced, set it dumpable and submit an SPR
1)		along with a dump and how to reproduce the problem.
1)	>)
LINE 10, PAGE 187
2)	Cause:	At MRETN, INTDF was found to be less than -1.  This indicates
2)		that this JSYS code did an unmatched OKINT and may have
2)		allowed interrupts when it didn't intend to.  This is
2)		a coding error.
2)	>)


LINE 14, PAGE 190
1)	Cause:	The process is NOSKED or CSKED at return from a monitor call.  Probably
1)		this JSYS went NOSKED or CSKED and forget to do the matching OKSKED or
1)		ECSKED.  This is a coding error.
1)	>)
LINE 14, PAGE 188
2)	Cause:	The process is NOSKED or CSKED at return from a monitor call.  
2)		Probably this JSYS went NOSKED or CSKED and forget to do the 
2)		matching OKSKED or ECSKED.  This is a coding error.
2)	>)


LINE 26, PAGE 190
1)	Cause:	Coding error has neglected to unlock the fork lock.  The monitor
1)		unlocks the fork lock before returning to the user. However, this
1)		BUGCHK may be indicative of other failures to properly release
1)		resources.
1)	
1)	Action:	If this BUGCHK can be reproduced, set it dumpable and submit an SPR
1)		along with a dump and how to reproduce the problem.
1)	>)		;YES. COMPLAIN THEN
LINE 26, PAGE 188
2)	Cause:	Coding error has neglected to unlock the fork lock.
2)	
2)	Action:	The monitor unlocks the fork lock before returning
2)		to the user. However,  this BUGCHK may be indicative
2)		of other failures to properly release resources.
2)	
2)	>)		;YES. COMPLAIN THEN


; SCHED.NEW.1 & <MONITOR>SCHED.MAC.2 31-Mar-89 2353	PAGE 21



LINE 29, PAGE 191
1)		BUG.(HLT,OPOPAC,SCHED,SOFT,<MRETN - Tried to over-pop AC stack>,,<
1)	
1)	Cause:	When a JSYS is executed from within the monitor, the AC's of the
1)		current process are stored in a special area in the monitor.  This area
1)		consists of several 20-word blocks that are used successively as one
1)		JSYS calls another.
1)	
1)		As each nested JSYS returns, the monitor's pointer to this area of
1)		memory is decremented.  The BUGHLT indicates that the pointer has been
1)		decremented too far.  This indicates either a clobbered pointer, or an
1)		attempt to return from a JSYS without having entered one.
1)	>)
LINE 29, PAGE 189
2)		BUG.(HLT,OPOPAC,SCHED,HARD,<MRETN - Tried to over-pop AC stack>,,<
2)	
2)	Cause:	When a JSYS is executed from within the monitor, the
2)		AC's of the current process are stored in a special area in the
2)		monitor.  This area consists of several 20-word blocks that are used
2)		successively as one JSYS calls another.
2)	
2)		As each nested JSYS returns, the monitor's pointer to this area of
2)		memory is decremented.  The BUGHLT indicates that the pointer has
2)		been decremented too far.  This indicates either a clobbered pointer,
2)		or an attempt to return from a JSYS without having entered one.
2)	
2)	>)
