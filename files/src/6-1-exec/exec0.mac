;[SRI-NIC]SRC:<6-1-EXEC>EXEC0.MAC.24,  8-Jun-88 22:20:24, Edit by MKL
; make Sun tty type use .TTSUN (new) instead of .TT100
;[SRI-NIC]SRC:<6-1-EXEC>EXEC0.MAC.22, 14-Apr-88 14:51:39, Edit by MKL
; add GETOK% call at job startup for ttyloc setting hooks
;SRC:<6-1-EXEC>EXEC0.MAC.21,  5-Jun-86 09:40:29, Edit by KNIGHT
; Make it all 19200, the monitor knows about it.
;SRC:<6-1-EXEC>EXEC0.MAC.19,  3-Jun-86 16:22:21, Edit by KNIGHT
; Map 19200 to 134, flush 134
;[SRI-NIC]SRC:<6-1-EXEC>EXEC0.MAC.15, 15-Apr-86 16:31:47, Edit by MKL
; Change at SNDCMD;  Just start up SEND program, let the program parse.
; ** Commented out until new SEND is ready.
;SRC:<6-1-EXEC>EXEC0.MAC.13, 21-Mar-86 10:26:43, Edit by KNIGHT
; Dogment lusers can say terminal dogment and win with ^h generating meese...
;[SRI-NIC]SRC:<6-1-EXEC>EXEC0.MAC.9,  2-Dec-85 15:55:13, Edit by MKL
;EM34 user IPCF sends
;SRC:<6-1-EXEC>EXEC0.MAC.7, 11-Nov-85 08:32:40, Edit by KNIGHT
; MOVX to HRLOI in .PEEK.  Mea culpa.
;[SRI-NIC]SRC:<6-1-EXEC>EXEC0.MAC.5,  8-Nov-85 15:45:38, Edit by MKL
; receive user-messages by default
;SRC:<6-1-EXEC>EXEC0.MAC.3,  1-Nov-85 09:39:13, Edit by KNIGHT
; Flush .GVT
;SRC:<6-1-EXEC>EXEC0.MAC.2, 31-Oct-85 09:35:29, Edit by KNIGHT
;NIC changes:
; [NIC1046] TERMINAL ANSI is the same as TERMINAL VT100
; [NIC1041] Make SET TERMINAL parse a terminal number 
; [NIC1036] Receive links by default.
; [NIC1035] Add lazy connect code.
; [NIC1033] Add autokeep attribute.
; [NIC1017] Add NYU history code. (may want to flush with command editor -RMK)
; [NIC1012] Add terminal LINEPROCESSOR.
; [NIC1002] Add IDDT and NO IDDT command support
; [NIC1001] Enable ^EPEEK command
;<6-1-EXEC>EXEC0.MAC.40, 16-Oct-85 13:32:40, Edit by WHP4
; call TTYINI after attach as well as at startup
;<6-1-EXEC.FT6>EXEC0.MAC.3, 12-Aug-85 14:42:26, Edit by WHP4
; command editor stuff
;<6-1-EXEC.FT6>EXEC0.MAC.2, 12-Aug-85 12:00:39, Edit by WHP4
; FT6 merge
;Stanford changes
; Add SUN48 terminal type for lazy typists
; Make sure HDRPOS is initialized to 0, not whatever was on the stack before
;  prevents lossage where SYSTAT prints host name on next line
; use () to delimit TCP host printing, {} for Pup hosts (in SYSTAT)
; Don't call TTYINI or do SETJB% if we are an inferior exec 
; Changes for command-editing EXEC
; reinstall old support for SYSTAT foreign host printing so we can run this
;  exec under pre-6.1 monitors
; Check against section not bottom of word address for sec num in addr typeout
; Don't let must-run-program accounts run bboard to read system-messages
;  This prevents them from getting lucky with ^C.
; Change the PSOUT% in the ECHO command to be an ETYPE so @ECHO
; will output newlines.
; Set location to LOCAL before calling TTYINI at
;  job login. This is to avoid having batch jobs and other things that
;  TTYINI doesn't change having their locations set to some ridiculous place.
; Flush RDMAIL and TERMINAL BELL commands
; Add the Concept AVT terminal
; Add the Concept GVT terminal
; Don't run TTYINI or do SETJB% if we are an inferior EXEC
; Flush concept of POBOX: - too random!
; TCP/IP enhancements for SYSTAT
; Crude fix to ALOTST to make AUTOL1 be seconds
; Set default typeout mode to be symbolic
; Set receive system messages if unlogged in
; Run TTYINI if unlogged in
; Type SYSTEM:BEWARE-MESSAGE.TXT if unlogged in
; MAIL, SEND, FINGER front end commands to those utilities
; Don't turn on PI's until after CERET is set up, also set CINITF
; Support for Stanford "Must Run Program" accounts
; Support for lazy login
; Fix CIN2 to use the right command name (PCL+kept forks)
; Output section number as independent halfword for address typeout
; Include state and class in SYSTAT by default
; Don't bother with operator attendance or remedial printouts in SYSTAT
; Use Stanford downtime printer (DWNPNT)
; Support for TERMINAL BACKSPACE-RUBOUT and TERMINAL BELL
; Support for Stanford terminal types
; Support for Stanford-style system messages
; Support for ^EREPLACE and ECHO commands
; Use HNMMSK in parsing host names for SEND, MAIL, etc.
; FINGER switches
;SUMEX changes:
; ^EPEEK command.
;CSLI changes:
; WHOCONSULT, HELPME commands
;LOTS changes:
; HELPME, WHOCONSULT, WIZARDS commands
; Set default typeout mode numeric
; Refuse links by default
; RDMAIL command
; LOTS finger program
; Don't include state, class in default SYSTAT
; add parsing for FIND command at LOTS (cross-system finger)
; Add support for LOTS EXEC-based queueing system (CKLTSQ and CIN9)
;
; UPD ID= 216, SNARK:<6.1.EXEC>EXEC0.MAC.20,  10-Jun-85 08:41:13 by DMCDANIEL
; UPD ID= 200, SNARK:<6.1.EXEC>EXEC0.MAC.19,  24-May-85 14:12:56 by EVANS
;TCO 6.1.1404 - Add command editor stuff.
; UPD ID= 186, SNARK:<6.1.EXEC>EXEC0.MAC.18,   3-May-85 14:43:04 by PRATT
;TCO 6.1.1357 - Don't clear name of fork when non-virgin on deposits
; UPD ID= 160, SNARK:<6.1.EXEC>EXEC0.MAC.17,   3-May-85 08:29:05 by DMCDANIEL
;Update copyrights for 6.1.
; UPD ID= 151, SNARK:<6.1.EXEC>EXEC0.MAC.16,   8-Apr-85 11:08:19 by PRATT
;TCO 6.1.1311 - Move the label FST3 up one line before the CALL ALRCHK
; UPD ID= 149, SNARK:<6.1.EXEC>EXEC0.MAC.15,  23-Mar-85 09:47:36 by MCCOLLUM
;OPERATOR and ORGIN are alphabetically inverted in the $SYSNO table
; UPD ID= 148, SNARK:<6.1.EXEC>EXEC0.MAC.14,  18-Mar-85 11:09:47 by PRATT
;TCO 6.1.1274 - Add ORIGIN/NO ORIGIN to SYSTAT
; UPD ID= 102, SNARK:<6.1.EXEC>EXEC0.MAC.13,  11-Dec-84 15:21:04 by MOSER
;TCO 6.1.1077 - ADD STAT STUFF
; UPD ID= 97, SNARK:<6.1.EXEC>EXEC0.MAC.12,  27-Nov-84 11:21:46 by EVANS
;TCO 6.1.1027 - Handle case of running program in LOGOUT.CMD
; UPD ID= 58, SNARK:<6.1.EXEC>EXEC0.MAC.7,  12-Nov-84 03:43:26 by MERRILL
;TCO 6.1.1042 - Update to work with the latest PCL we have
;  Clear CIPF later (after CIN1) so DOCOMMAND "kept-fork-name" works.
;  Fix ORIGINAL <esc> ^U to not leave the doing-an-original-command flag set.
; UPD ID= 51, SNARK:<6.1.EXEC>EXEC0.MAC.6,   5-Nov-84 12:55:23 by PRATT
;More TCO 6.1.1028 - Include network type after hostname
; UPD ID= 50, SNARK:<6.1.EXEC>EXEC0.MAC.5,   2-Nov-84 16:30:48 by PRATT
;More TCO 6.1.1028 - Handle detached lines correctly
; UPD ID= 43, SNARK:<6.1.EXEC>EXEC0.MAC.3,  28-Oct-84 10:53:18 by PRATT
;TCO 6.1.1028 - Always type out the "4n host" field
; UPD ID= 37, SNARK:<6.1.EXEC>EXEC0.MAC.2,  26-Oct-84 13:35:15 by EVANS
;TCO 6.1.1207 - Add SYSTEM: .CMD file code and label for LOGOUT.CMD
; UPD ID= 454, SNARK:<6.EXEC>EXEC0.MAC.45,   3-Oct-84 17:01:12 by PRATT
;TCO 6.2235 - Fix problem with ^T during ^C of ephemoral program
; UPD ID= 448, SNARK:<6.EXEC>EXEC0.MAC.44,  27-Sep-84 11:15:06 by MCCOLLUM
;TCO 6.2230 - Change text for shared page made private in DEPOSIT command.
; UPD ID= 445, SNARK:<6.EXEC>EXEC0.MAC.43,  26-Sep-84 16:46:07 by MCCOLLUM
;TCO 6.2229 - Clear private name in fork data block in DEPOSIT code
; UPD ID= 438, SNARK:<6.EXEC>EXEC0.MAC.42,  25-Sep-84 10:51:16 by EVANS
;TCO 6.2222 - Add support for VT200 terminals; also VT131.
; UPD ID= 425, SNARK:<6.EXEC>EXEC0.MAC.41,  19-Jul-84 16:03:26 by PRATT
;TCO 6.2136 - Allow both new and the old flavors of TERMINAL guide words
; UPD ID= 411, SNARK:<6.EXEC>EXEC0.MAC.40,  12-Jun-84 12:00:29 by MCCOLLUM
;TCO 6.2093 - Fix "TERM NO PAUSE CHAR" command to set defaults.
; UPD ID= 408, SNARK:<6.EXEC>EXEC0.MAC.39,   3-May-84 10:19:22 by SHTIL
; UPD ID= 379, SNARK:<6.EXEC>EXEC0.MAC.38,  20-Jan-84 16:00:27 by MCCOLLUM
;TCO 6.1945 - Range check ASCII code in "TERMINAL PAUSE (ON) CHARACTER"
; UPD ID= 373, SNARK:<6.EXEC>EXEC0.MAC.36,   9-Jan-84 20:30:16 by MCCOLLUM
;TCO 6.1928 - Confirm after "TERMINAL PAUSE CHARACTER n 0"
; UPD ID= 366, SNARK:<6.EXEC>EXEC0.MAC.35,  28-Dec-83 15:56:38 by PRATT
;TCO 6.1796 - Add [SET] TERMINAL [NO] INHIBIT (NON-JOB OUTPUT)
; UPD ID= 333, SNARK:<6.EXEC>EXEC0.MAC.34,  20-Nov-83 19:38:11 by PRATT
;TCO 6.1870 - Get rid of code which is under NONEWF. Remove NEWF's.
; UPD ID= 321, SNARK:<6.EXEC>EXEC0.MAC.33,   8-Nov-83 15:04:02 by PRATT
;TCO 6.1852 - Make TERMINAL HELP command typeout HLP:TERMINAL.HLP
; UPD ID= 317, SNARK:<6.EXEC>EXEC0.MAC.32,   8-Nov-83 13:47:17 by PRATT
;TCO 6.1847 - New /FAST switch to LOGIN
; UPD ID= 315, SNARK:<6.EXEC>EXEC0.MAC.31,  17-Oct-83 13:41:50 by PRATT
;TCO 6.1831 - Change the bizarre byte pointers in EXEC02
; UPD ID= 310, SNARK:<6.EXEC>EXEC0.MAC.30,  22-Sep-83 12:16:33 by MILLER
;TCO 6.1758. Make system mail work
; UPD ID= 288, SNARK:<6.EXEC>EXEC0.MAC.29,  14-Jun-83 11:57:01 by LOMARTIRE
;TCO 6.1676 - Allow range of terminal lines in ^ESET TERMINAL command
; UPD ID= 272, SNARK:<6.EXEC>EXEC0.MAC.28,  20-Apr-83 15:33:55 by PAETZOLD
;TCP 6.1619 - Add H10
; UPD ID= 234, SNARK:<6.EXEC>EXEC0.MAC.27,   4-Apr-83 10:10:30 by CHALL
;TCO 6.1456 - Set up AC C for $GET0 and $GET2
; UPD ID= 233, SNARK:<6.EXEC>EXEC0.MAC.26,  15-Jan-83 19:23:30 by CHALL
;TCO 6.1464 - UPDATE COPYRIGHT NOTICE
; UPD ID= 202, SNARK:<6.EXEC>EXEC0.MAC.25,   3-Dec-82 15:40:37 by CHALL
;TCO 6.1399 CIN9- USE A DIFFERENT KEYWORD TABLE WHEN NOT LOGGED IN
;TCO 6.1397 .TERMI- CHANGE NOISE TO "TERMINAL (FEATURE OR TYPE)"
;ALSO, SEPARATE KEYWORDS INTO TWO TABLES: TYPES AND FEATURES
; UPD ID= 160, SNARK:<6.EXEC>EXEC0.MAC.24,  21-Sep-82 15:50:43 by TSANG
;TCO 6.1248 MODIFY HELP TEXT STRING IN TERMINAL COMMAND
;TCO 6.1253 FIX THE USED CLASS (.SAUSE) PROBLEM
; UPD ID= 151, SNARK:<6.EXEC>EXEC0.MAC.23,  19-Aug-82 14:23:51 by MOSER
;MORE OF TCO 5.1306 LOAD FLAGS BEFORE TEST
; UPD ID= 132, SNARK:<6.EXEC>EXEC0.MAC.21,   4-Aug-82 17:09:50 by LEACHE
;TCO 6.1209 Fix invocations of ETYPE
; UPD ID= 122, SNARK:<6.EXEC>EXEC0.MAC.20,  24-Apr-82 12:24:51 by CHALL
;TCO 6.1101 MOVE STUFF WITH TERMINAL NAMES (.TERMI, .TTYPE) TO EXECCA
; UPD ID= 113, SNARK:<6.EXEC>EXEC0.MAC.19,  20-Apr-82 07:52:59 by CHALL
;TCO 6.1092 EXEC01- Remove MIC conditional
; UPD ID= 110, SNARK:<6.EXEC>EXEC0.MAC.18,   9-Apr-82 09:41:54 by CHALL
;TCO 6.1088 .TERMI- AND .TTYPE- ADD TERMINAL TYPE VT102
; UPD ID= 138, SNARK:<5.EXEC>EXEC0.MAC.42,   7-Feb-82 13:41:31 by CHALL
;TCO 5.1700 .TERMI- AND .TTYPE- ADD TERMINAL TYPES VT125 AND VK100
; UPD ID= 133, SNARK:<5.EXEC>EXEC0.MAC.41,  22-Jan-82 14:44:35 by CHALL
;TCO 6.1052 - UPDATE COPYRIGHT NOTICE AND DELETE PRE-V4.1 EDIT HISTORY
; UPD ID= 129, SNARK:<5.EXEC>EXEC0.MAC.40,   5-Jan-82 10:00:30 by MOSER
; UPD ID= 108, SNARK:<5.EXEC>EXEC0.MAC.27,  30-Nov-81 13:59:11 by MOSER
;TCO 5.1613 - ADD NEW BIT B4 TO CRJOB FLAGS. MEANS SIMULATE LOGIN.
; UPD ID= 97, SNARK:<5.EXEC>EXEC0.MAC.26,  21-Oct-81 13:43:45 by GROUT
;TCO 5.1578 MAKE CMDINI GLOBAL SO IT CAN BE CALLED FROM EOFJER
; UPD ID= 71, SNARK:<5.EXEC>EXEC0.MAC.23,  21-Sep-81 09:06:15 by CHALL
;TCO 5.1521 SUBSTA- OUTPUT SCOUNTS IN INFO SUBSYS (SEE TCO 5.1301)
; UPD ID= 60, SNARK:<5.EXEC>EXEC0.MAC.21,   1-Sep-81 18:01:29 by CHALL
;TCO 5.1483 SYSNX- IF USER TYPED "SYS:" GIVE FILESPEC-LIKE ERROR
; UPD ID= 43, SNARK:<5.EXEC>EXEC0.MAC.19,  17-Aug-81 22:48:14 by MURPHY
;MAKE MESS NOT FLUSH CURRENT FORK
; UPD ID= 31, SNARK:<5.EXEC>EXEC0.MAC.18,  14-Aug-81 19:11:43 by CHALL
;TCO 5.1454 CHANGE NAME FROM XDEF TO EXECDE
; UPD ID= 22, SNARK:<5.EXEC>EXEC0.MAC.17,   5-Aug-81 16:00:09 by MURPHY
;BUG IN MESS - LEAVING GARBAGE FORK HANDLE IN FORK.
; UPD ID= 18, SNARK:<5.EXEC>EXEC0.MAC.16,  21-Jul-81 11:53:08 by GROUT
;TCO 5.1426 - Make SYSTAT work with wild directory and user args
;<HELLIWELL.EXEC.5>EXEC0.MAC.2, 13-May-81 19:58:17, EDIT BY HELLIWELL
;REMOVE DOCCL AND DOCC1 (NOW UNUSED)
;<HELLIWELL.EXEC.5>EXEC0.MAC.1, 13-May-81 14:51:16, EDIT BY HELLIWELL
;REMOVE GT40 TERMINAL TYPE
; UPD ID= 2099, SNARK:<5.EXEC>EXEC0.MAC.12,  28-May-81 10:58:35 by GROUT
; TCO 5.1351 - Make TERMINAL terminal-type not change duplex mode
; UPD ID= 2063, SNARK:<5.EXEC>EXEC0.MAC.11,  22-May-81 11:51:03 by GROUT
;TCO 5.1343 - Make IPCF code flush buffers only when necessary
; UPD ID= 2035, SNARK:<5.EXEC>EXEC0.MAC.10,  19-May-81 16:55:38 by MURPHY
;Raise input on TER PAUSE CHARACTER CONTROL x
; UPD ID= 1974, SNARK:<5.EXEC>EXEC0.MAC.9,  11-May-81 11:35:56 by TILLSON
;TCO 5.1306 - Make LOGIN messages print in Batch log file
; UPD ID= 1962, SNARK:<5.EXEC>EXEC0.MAC.8,   8-May-81 10:03:01 by SCHMITT
;TCO 5.1309 - Check for DWNTIM of -1 for system shutdown at SYSDWN
; UPD ID= 1949, SNARK:<5.EXEC>EXEC0.MAC.4,   6-May-81 14:53:33 by MURPHY
; TCO 5.1315  - PAUSE (ON) CHARACTER etc.
; UPD ID= 1871, SNARK:<5.EXEC>EXEC0.MAC.3,  22-Apr-81 11:29:57 by PAETZOLD
;fix typo in previous (TCO 5.1295)
; UPD ID= 1868, SNARK:<5.EXEC>EXEC0.MAC.2,  22-Apr-81 10:49:55 by PAETZOLD
;TCO 5.1295 Add cosmetic fix for systat for foreign arpanet host
;previous edit history line missing
;ADD PCLF SWITCHES WHERE VISIBLE TO USER
;REMOVE MFRK SWITCHES EXCEPT WHERE VISIBLE TO USER
;<4.EXEC>EXEC0.MAC.1, 23-Dec-80 19:03:03, Edit by DK32
;Programmable Command Language
; UPD ID= 1434, SNARK:<5.EXEC>EXEC0.MAC.41,  13-Jan-81 09:58:33 by OSMAN
;More 5.1129 - Make EXAMINE show octal contents "...too, if different"
; UPD ID= 1397, SNARK:<5.EXEC>EXEC0.MAC.40,   6-Jan-81 10:27:42 by OSMAN
;tco 5.1225 - Implement jsys trapping and file-opening trapping!
; UPD ID= 1394, SNARK:<5.EXEC>EXEC0.MAC.39,  31-Dec-80 16:08:32 by LYONS
; UPD ID= 1392, SNARK:<5.EXEC>EXEC0.MAC.38,  31-Dec-80 15:09:40 by LYONS
;for the time being, keep both sets of system mail code.
; UPD ID= 1355, SNARK:<5.EXEC>EXEC0.MAC.37,  16-Dec-80 09:51:38 by OSMAN
;Don't get second symbol buffer upon restarting customized exec
; UPD ID= 1280, SNARK:<5.EXEC>EXEC0.MAC.36,  17-Nov-80 16:40:55 by OSMAN
;Remove ^L hack
; UPD ID= 1252, SNARK:<5.EXEC>EXEC0.MAC.35,  10-Nov-80 13:24:26 by OSMAN
;More 5.1189 - Make DDT see /USE-SECTION switch
; UPD ID= 1237, SNARK:<5.EXEC>EXEC0.MAC.34,   6-Nov-80 15:20:32 by OSMAN
;tco 5.1189 - Use $GET0 instead of $GET2
; UPD ID= 1233, SNARK:<5.EXEC>EXEC0.MAC.33,   5-Nov-80 15:31:57 by LCAMPBELL
; UPD ID= 1188, SNARK:<5.EXEC>EXEC0.MAC.31,  23-Oct-80 10:09:49 by OSMAN
; UPD ID= 1187, SNARK:<5.EXEC>EXEC0.MAC.30,  22-Oct-80 17:01:15 by OSMAN
;Fix SET PROG EPHEMERAL
; UPD ID= 1146, SNARK:<5.EXEC>EXEC0.MAC.29,  10-Oct-80 09:31:07 by OSMAN
;More 5.1151 - Unbreak "DEC SYN CD CONNECT"
; UPD ID= 1145, SNARK:<5.EXEC>EXEC0.MAC.28,  10-Oct-80 09:25:26 by OSMAN
; UPD ID= 1127, SNARK:<5.EXEC>EXEC0.MAC.27,   6-Oct-80 10:16:23 by OSMAN
;tco 5.1167 - Remove FDB autokeep feature
; UPD ID= 1114, SNARK:<5.EXEC>EXEC0.MAC.26,   3-Oct-80 11:32:25 by OSMAN
;tco 5.1162 - Parse program names as keywords.
; UPD ID= 1040, SNARK:<5.EXEC>EXEC0.MAC.25,  25-Sep-80 14:12:54 by OSMAN
;tco 5.1156 - Add SET DEFAULT PROGRAM
; UPD ID= 1034, SNARK:<5.EXEC>EXEC0.MAC.24,  23-Sep-80 14:03:54 by OSMAN
;tco 5.1151 - prevent spurious error from "INFO MON"
; UPD ID= 1025, SNARK:<5.EXEC>EXEC0.MAC.23,  22-Sep-80 10:37:46 by OSMAN
;tco 5.1150 - Add SET PROGRAM
; UPD ID= 1016, SNARK:<5.EXEC>EXEC0.MAC.22,  16-Sep-80 10:14:20 by HESS
; New version of MIC
; UPD ID= 918, SNARK:<5.EXEC>EXEC0.MAC.21,  19-Aug-80 14:28:14 by HESS
; Fix Examine/Deposit commands for multi-forking
; UPD ID= 871, SNARK:<5.EXEC>EXEC0.MAC.20,  11-Aug-80 11:21:43 by OSMAN
;5.1129 - Allow "@FOO" as contents for DEPOSIT
; UPD ID= 865, SNARK:<5.EXEC>EXEC0.MAC.19,  11-Aug-80 10:59:05 by OSMAN
;More 5.1129 - Allow symbolic deposit into empty fork
; UPD ID= 863, SNARK:<5.EXEC>EXEC0.MAC.18,  10-Aug-80 16:41:16 by OSMAN
;More 5.1129 - Fix EXAMINE and DEPOSIT
; UPD ID= 852, SNARK:<5.EXEC>EXEC0.MAC.17,  10-Aug-80 15:20:04 by OSMAN
;tco 5.1129 - Add symbolic expression and address support
; UPD ID= 837, SNARK:<5.EXEC>EXEC0.MAC.16,   5-Aug-80 10:27:28 by OSMAN
;tco 5.1124 - Do LOGIN.CMD before COMAND.CMD
; UPD ID= 836, SNARK:<5.EXEC>EXEC0.MAC.15,   5-Aug-80 10:07:21 by OSMAN
;Remove SY abbreviation
; UPD ID= 829, SNARK:<5.EXEC>EXEC0.MAC.14,   4-Aug-80 12:36:58 by LYONS
; Change ^V echo to fix listings alignment
; Fix herald suppression code
; UPD ID= 825, SNARK:<5.EXEC>EXEC0.MAC.13,   4-Aug-80 09:48:52 by OSMAN
;Move version stuff into EXECIN
; UPD ID= 805, SNARK:<5.EXEC>EXEC0.MAC.12,  28-Jul-80 14:54:35 by MURPHY
;Remove effect of .FBKEP
; UPD ID= 787, SNARK:<5.EXEC>EXEC0.MAC.11,  23-Jul-80 15:25:57 by OSMAN
;tco 5.1111 - Don't croak SYSTAT if SKED% keels over due to job logging out
; UPD ID= 770, SNARK:<5.EXEC>EXEC0.MAC.10,  21-Jul-80 13:58:49 by MURPHY
;FORCE SY AS ABBREV FOR SYSTAT
; UPD ID= 586, SNARK:<5.EXEC>EXEC0.MAC.9,   2-Jun-80 14:35:06 by MURPHY
;<5.EXEC>EXEC0.MAC.8, 30-May-80 16:42:15, EDIT BY MURPHY
;PUT ALERT AND MAIL-WATCH UNDER NEWF
; UPD ID= 565, SNARK:<5.EXEC>EXEC0.MAC.7,  28-May-80 16:54:41 by MURPHY
; UPD ID= 551, SNARK:<5.EXEC>EXEC0.MAC.6,  23-May-80 13:36:11 by MURPHY
;MAKE EDIT/CREATE USE IMPLICIT RUN COMMAND LOGIC
; UPD ID= 543, SNARK:<5.EXEC>EXEC0.MAC.5,  21-May-80 12:06:57 by MURPHY
;ADD MFRK TO CONTROL MULTI-FORK FEATURES ONLY
;ADD NEWF TO CONTROL "NEW" FEATURES PENDING REVIEW
;Change handling of fork name as command
;<5.EXEC>EXEC0.MAC.4,  8-May-80 14:01:08, EDIT BY OSMAN
;Remove R.L.5 and R.GE.5 macro calls
;<4.1.EXEC>EXEC0.MAC.27, 29-Apr-80 13:30:31, EDIT BY OSMAN
;Make "Up again at" have space before it
; UPD ID= 457, SNARK:<4.1.EXEC>EXEC0.MAC.25,  22-Apr-80 16:42:13 by OSMAN
;tco 4.1.1146 - Make CTRL/Q during advice work.
;<4.1.EXEC>EXEC0.MAC.24, 28-Mar-80 09:52:19, Edit by HESS
; New version of MIC support
;<4.1.EXEC>EXEC0.MAC.23, 17-Mar-80 14:10:16, EDIT BY OSMAN
;Get rid of ONEWRD checks
;<4.1.EXEC>EXEC0.MAC.22, 17-Mar-80 10:53:23, EDIT BY OSMAN
;PUT R.L.5 CONDITIONAL AROUND SMOUNT, SDISMOUNT, TMOUNT
;<4.1.EXEC>EXEC0.MAC.21, 13-Mar-80 10:50:22, EDIT BY OSMAN
;tco 4.1.1108 - Print n.m instead of nx in version numbers
;Put SMOUNT and SDISMOUNT back in for release 4.1
;<4.1.EXEC>EXEC0.MAC.19,  7-Mar-80 17:00:41, EDIT BY OSMAN
;tco 4.1.1101 - lowercase error message "Illegal character in program name..."
;<4.1.EXEC>EXEC0.MAC.11, 29-Feb-80 09:31:36, EDIT BY OSMAN
;tco 4.1.1095 - allow "SYS NO ."
; UPD ID= 261, SNARK:<4.1.EXEC>EXEC0.MAC.8,  14-Feb-80 08:52:57 by OSMAN
;tco 4.1.1079 - Flush SMOUNT, SDISMOUNT, TMOUNT
; UPD ID= 258, SNARK:<4.1.EXEC>EXEC0.MAC.7,  12-Feb-80 10:10:48 by OSMAN
;Remove QCM (old QUENCH startup stuff)
; UPD ID= 236, SNARK:<4.1.EXEC>EXEC0.MAC.6,   1-Feb-80 08:51:12 by OSMAN
;tco 4.1.1076 - Wait for confirmation on FOREIGN-HOST subcommand
; UPD ID= 195, SNARK:<4.1.EXEC>EXEC0.MAC.5,   8-Jan-80 14:31:09 by OSMAN
; UPD ID= 192, SNARK:<4.1.EXEC>EXEC0.MAC.4,   8-Jan-80 14:25:26 by OSMAN
;tco 4.1.1061 - Use generation 1 on system mail
;<4.1.EXEC>EXEC0.MAC.2, 20-Nov-79 10:46:37, EDIT BY OSMAN
;TCO 4.1.1023 - FIX TAKE STUFF

;TOPS20 'EXECUTIVE' COMMAND LANGUAGE

;THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY ONLY BE USED
;  OR COPIED IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
;COPYRIGHT (C) BY DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS. 1980,1985
;ALL RIGHTS RESERVED.

	SEARCH EXECDE
	UTITLE EXEC0

;THIS FILE CONTAINS
; START AND REENTER INITIALIZATION
; MAIN LOOP TO READ FIRST WORD OF COMMAND AND DISPATCH
; COMMAND TABLES AND OTHER MISC TABLES
; STATUS AND TERMINAL CHARACTERISTICS COMMANDS

;TOPS10 JOB DATA AREA

JOBSA==:120
JOBSYM==:116
JOBDDT==:74

;TOPS20 ENTRY VECTOR
; NOTE: "EXEC" IS ASSUMED TO BE FIRST SYMBOL IN EXEC.REL, AND AT A
; PAGE BOUNDARY, BY PAGE BOUNDARY CHECK IN "ALOFRK" AT END OF THIS FILE.

EXEC::	JRST REENTE		;START ENTRY
	JRST REENTE		;REENTER ENTRY
	%%LVER,,%%RVER		;VERSION NUMBER

;PUT THE COPYRIGHT STATEMENT HERE IN THE REL FILE

CPYRYT

;POINTER TO SYMBOL TABLE
;SAVED HERE FROM JOBSYM WHEN THAT PAGE REMOVED FOR SHARABLE SUBSYSTEM

.JOBSYM::0
.NPAGS::0			;SIZE OF EXEC IN PAGES

 EVLEN==:3			;ENTRY VECTOR LENGTH (STARTING AT "EXEC")

;PATCH AREA
;ALSO THERE'S A WRITEABLE PATCH AREA (PPAT) IN EXECPR.MAC.

PATS::
PAT:: BLOCK 200

;SUBROUTINE TO "AUTOLOGOUT" THIS JOB IF NOT LOGGED IN AND MORE
; THAN "AUTOL1" SECONDS HAVE ELAPSED SINCE STARTUP.
;ONE CALL IN CMDIN4 AREA.

ALOTST:	PUSH P,A
	GTAD
	SUB A,STRTIM
IFE STANSW,<
	SUB A,[AUTOL1]
>;IFE STANSW
IFN STANSW,<
	SUB A,[AUTOL1*3]	;AUTOL1 IS SUPPOSED TO BE IN SECONDS
>;IFN STANSW
	JUMPG A,AUTOLO		;DO AUTOLOGOUT (EXECSU.MAC)
	POP P,A
	RET


CHNMSK:	CHNS			;MASK FOR ACTIVE CHANNELS

;ROUTINE TO CLEAR CRJOB/PRARG START UP BLOCK

CLPRA:	SETZM CRPRA
	MOVE A,[XWD CRPRA,CRPRA+1]
	BLT A,CRPRA+17
	RET

;"EXEC" AND ITS VERSION

EXECV::	TYPE < TOPS-20 Command processor >
	MOVE Q1,EXEC+2		;GET VERSION #
	CALLRET VERPNT		;PRINT IT

;ROUTINE TO INITIALIZE COMND JSYS.  ITEMS INITIALIZED IN THIS ROUTINE
;ARE ONES NOT NECESSARY TO REINITIALIZE FOR EACH COMMAND.

CMDINI::MOVEI A,REPARS		;SET UP REPARSE HANDLER ADDRESS
	MOVEM A,CMFLG
	HRROI A,CBUF		;POINTER TO COMMAND BUFFER
	MOVEM A,CMBFP
	MOVEM A,CMPTR		;NO "NEXT FIELD" YET
	MOVEI B,CBUFL*5		;ANNOUNCE HOW MUCH ROOM FOR TYPEIN THERE IS
	MOVEM B,CMCNT
	SETZM CMINC		;NO UNPARSED CHARACTERS YET
	HRROI A,ATMBUF		;POINTER TO ATOM BUFFER
	MOVEM A,CMABP
	MOVEI A,ATMLEN*5	;LENGTH OF ATOM BUFFER
	MOVEM A,CMABC
	MOVEI A,CJFNBK		;ADDRESS OF GTJFN BLOCK
	MOVEM A,CMGJB
	RET

;REENTER ENTRY

REENTE::
REE::	SKIPN CINITF		;IS EXEC INITIALIZED?
	JRST EXEC0		;NO, "REENTER" GIVEN BEFORE "START",
				;FULL INITIALIZATION REQUIRED.
	SKIPE CUSTMF		;PCL Is this just a customized Exec?
	JRST EXEC0		;PCL It is, do full initialization

;THE FOLLOWING CODE IS EXECUTED ON "REENTER" ONLY.

;RE-INITIALIZE PSI SYSTEM
; (^C OUT OF EXEC DDT TO SUPERIOR EXEC LEAVES IT WRONG).

	CALL ICLEAR		;CLEAR INTERRUPT WE MAY HAVE RESTARTED OUT OF, DONE HERE TO AVOID TWO FOR EVERY ^C!
	MOVEI A,.FHSLF
	MOVE B,CHNMSK		;GET ACTIVE CHANNEL MASK
	AIC			;ACTIVATE CHANNELS SPECIFIED BY MASK
	EIR			;ENABLE PROCESS PSEUDOINTERRUPT SYSTEM
	CALL CPULIM		;GET AND SET CPU TIME LIMIT
	TXO Z,NECHOF		;PRETEND ECHOING OFF
	CALL DOECHO		;FORCE ECHOING (IN CASE WARM START AFTER INTERRUPT OUT OF A NOECHO PLACE!)
	CALL DOATI		;TERMINAL INTERRUPTS (ON ^EQ, MINI-EXEC CLEARS THEM)
	MOVEI Q1,ETTYMD
	CALL IPCINI		;EM34 initialize IPCF
	CALL LTTYMD		;INIT TTY STATE IN CASE INTERRUPTED OUT OF COMND
	JRST CMDIN2		;JOIN STARTUP CASE

;INSTRUCTION TO INITIALIZE STACK

INISTK::MOVE P,[IOWD PDL,PD]

;FIRST STARTUP INITIALIZATION

EXEC0::	XCT INISTK		;INITIALIZE THE STACK
	MOVEI A,.FHSLF
	RPCAP			;GET CURRENT CAPABILITIES
	HLLZ C,C		;PREVENT "ATTACH" WITHOUT PASSWORD
	EPCAP			;(MONITOR MAKES VIRGIN JOB BE WHEEL!)
	SETZM CSZ1
        MOVE A,[XWD CSZ1,CSZ1+1]
        BLT A,CSZ4
	GETNM			;GET PROGRAM NAME
	MOVEM A,SAVNAM		;REMEMBER NAME
	CALL GETMOD		;SEE WHETHER WE'RE COMING FROM EXEC OR USER MODE
	MOVEM A,SAVT20		;REMEMBER FOR WHEN WE POP

;SET UP 41 FOR UUO'S, P=17 FOR PUSHDOWN POINTER

        MOVE A,[CALL CUUO]
        MOVEM A,41
	MOVE A,[IOWD JBUFL,JBUF] ;INIT PTR INTO JFN BUFFER
	MOVEM A,JBUFP		;..
	SETOM 1(A)		;INIT JFN BUFFER TO -1'S: 0 IS A JFN.
	AOBJN A,.-1		;..
IFN STANSW,<
IFE LOTSW,<
	SETOM SYMF		;SET DEFAULT TYPEOUT MODE TO BE SYMBOLIC
>;IFE LOTSW
IFN LOTSW,<
	SETZM SYMF		;WE CAN'T AFFORD THIS AT LOTS
>;IFN LOTSW
>;IFN STANSW
	SKIPN XDICT		;PCL Does permanent pool need initialized?
	CALL XFRINI		;INITIALIZE PERMANENT FREE SPACE
IFN CHSTSW,<
	CALL INITHS		;Initialize command history module
>;IFN CHSTSW
IFN FTCE,<
	SETOM CEPSIC		;NO DEFAULT INTERRUPT CHAR FOR COMMAND EDITOR
>;IFN FTCE
	MOVEI A,NFRKS		;INITIALIZE FORK NAME TABLE
	MOVEM A,FRKNMS		;SAY MAXIMUM NAMES ALLOWED IN TABLE
	MOVEM A,KEPNMS		;INITIALIZE KEPT FORKS TABLE TOO
	CALL GETFB1		;GET FORK BLOCK FOR DEFAULTS
	MOVEM A,FRKDEF		;REMEMBER ADDRESS OF DEFAULT BLOCK
	SKIPE SYMBF		;DO WE ALREADY HAVE SYMBOL BUFFER (IS THIS A CUSTOMIZED EXEC)
	JRST SYMDON		;YES
	MOVEI A,777+NSMPGS_9	;GET WINDOW FOR SYMBOL TABLE MAPPING
	CALL GTBUFX
	TRZE A,777		;WE NEED PAGE-ALIGNED ADDRESS FOR PMAP
	ADDI A,1000		;IF BLOCK STARTED ON PARTIAL PAGE, GET TO FULL ONE
	MOVEM A,SYMBF		;REMEMBER WHERE BUFFER STARTS
SYMDON:	SETZ Z,			;CLEAR FLAGS
	CALL CLPRA		;CLEAR CRJOB/PRARG AREA
	MOVE A,[.PRARD,,.FHSLF]	;READ OUR BLK IF THERE
	MOVEI B,CRPRA
	MOVEI C,20		;LENGTH OF OUR BLK
	PRARG
	JUMPE C,EXEC01		;NOTHING WAITING FOR US
	MOVE A,CRPRA+.CJPHD	;PICK UP ID THAT IDENTIFIES CRJOB-PRARG
	CAME A,[1B0+3B6+2B12+CR%PRA] ;PRARG FROM CRJOB?
	 JRST [ CALL CLPRA	;NO, WHO KNOWS WHAT, DITCH IT
		JRST EXEC01]
	SETO A,			;THIS JOB
	HRROI B,CJPTIM		;1 WORD INTO OUR FLAG WORD
	MOVEI C,.JIRTL		;GET JOB RUNTIME LIMIT (IF SET)
	GETJI
	 SETZM CJPTIM		;FAILED, FLAG AS NONE PRESENT
	HRRZ A,CRPRA+.CJPLP	;GET PTR TO FLAGS
	MOVE B,CRPRA(A)		;PICK UP FLAGS
	TLNN B,(1B1+1B2)	;A FORK HANDLE GIVEN TO US?
	 JRST EXEC01		;NO, CONTINUE
	HRRZ A,CRPRA+.CJPKP	;GET PTR TO FORK,,SFRKV OFFSET
	MOVE B,CRPRA(A)
	HLRZM B,FORK		;SET IT AS CURRENT LOWER FORK
	JRST EXEC02
EXEC01:	SETOM FORK		;SAY NO INFERIOR FORK
	SETOM RUNFK		;NO RUNNING FORK
	SETOM EDFORK		;NO EDITOR FORK
IFE NICSW,<
	SETOM IDFORK		;NO IDDT FORK
>;IFE NICSW
	SETOM EFORK		;NO EPHERMERAL FORK
	SETOM MICFRK		;NO MIC FORK

IFN FTCE,<
	MOVEI A, CESAVE+2	;INITIALIZE THE COMMAND EDITOR
	MOVEM A, CESAVE		;
	MOVEM A, CEFFL		;INITIALIZE FREE SPACE POINTER
	MOVEI A, CESAVE		;INITIALIZE POINTER INTO TABLE
	MOVEM A, CE1ST		;
	MOVEM A, CELAST		;
	MOVEI A, 1		;INITIALIZE THE COMMAND COUNT
	MOVEM A, CECNT		;
>;IFN FTCE
EXEC02:	SETOM NPAGE		;SAY NO PAGE OF INFERIOR IS MAPPED
	SETOM OLDIDX		;SAY NO IPCF MESSAGE WAITING YET
	MOVEI A,NEXTS		;INITIALIZE EXTENSION TABLE
	MOVEM A,DEXTBL

;INITIALIZE PROCESS PSI SYSTEM,
; DONE EARLY SO ERRORS IN REST OF INITIALIZATION WILL BE HANDLED.
;ENABLE ALL ERROR CHANNELS BUT OVERFLOW,
; ALSO CHANNEL 1 FOR ASSIGNMENT TO ^C BELOW,
; AND 2 FOR AUTOLOGOUT.

	MOVEI A,.FHSLF		;SAY THIS FORK
	MOVE B,[XWD LEVTAB,CHNTAB]
	SIR			;SET UP TABLE ADDRESSES
	MOVE B,CHNMSK		;GET ACTIVE CHANNEL MASK
	AIC			;ACTIVATE SPECIFIED CHANNELS
	EIR			;ENABLE PROCESS PSI SYSTEM
	CALL CPULIM		;GET AND SET CPU TIME LIMIT
	CALL CMDINI		;INITALIZE ALL COMND PARAMETERS
	SETZM TAKLEN		;NO JFNS ON STACK YET
	DMOVE A,[XWD .PRIIN,.PRIOU ;USE PRIMARY IO
		 TKALEF]	;ALLOW ERRORS AT THIS LEVEL, NO ECHOING OF COMMAND
	CALL PUSHIO		;START INITIAL STREAM
	CALL STSYST		;INIT GETAB NUMBERS
IFN PUPSW,<
	SETZM PUPFLG		;ASSUME NO ETHERNET
	MOVE A,[SIXBIT/PUPPAR/]
	SYSGT%			;GET -NBR,,1ST PUP NVT
	JUMPE B,NOPUP		;RETURN IF NO SUCH TABLE
	HRRZM A,PUPLOW		;SAVE TTY NBR OF 1ST PUP NVT
	HLRE D,A
	SUBI A,1(D)
	HRRZM A,PUPHGH		;AND TTY NBR OF LAST PUP NVT
	MOVEI A,(B)		;GET GETAB TABLE NBR
	HRLI A,1		;NEXT ITEM IN TABLE
	GETAB%
	 ERJMP NOPUP
	MOVEM A,PUPBUF		;ADDR OF PUP FREE STORAGE (IN MONITOR SPACE)
	MOVE A,[SIXBIT/NVTPUP/]
	SYSGT%
	JUMPE B,NOPUP		;RETURN IF NO SUCH TABLE
	MOVEM B,$NVTPUP
	MOVE A,[SIXBIT/PUPFPT/]
	SYSGT%
	JUMPE B,NOPUP		;RETURN IF NO SUCH TABLE
	MOVEM B,$PUPFPT
	MOVE A,[SIXBIT/PUPBUF/]
	SYSGT%
	JUMPE B,NOPUP		;RETURN IF NO SUCH TABLE
	MOVEM B,$PUPBUF
	SETOM PUPFLG		;FLAG THAT ETHERNET EXISTS
NOPUP:
>;IFN PUPSW

;INITIALIZE TELETYPE MODE, TABS, CONTROL CHARACTER OUTPUT (CCOC).
;INITIALIZE MODES FOR USE IN RUNNING PROGRAM FROM PRESENT MODES.

	MOVEI Q1,ITTYMD		;INITIAL MODES FOR "START"
	CALL RTTYMD		;THIS SUBR SAVES MODE WORD, TABS, CCOC.
	MOVE A,[SIXBIT /(PRIV)/]
	MOVEM A,ITTYMD+TTWSNM	;SUBSYSTEM NAME UNLESS OTHERWISE SPEC

;INITIALIZE MODES FOR USE WHEN EXEC IS RUNNING:
;ASSUME IT'S ALREADY CORRECT WITH REGARD TO HARDWARE FEATURES;

	MOVEI Q1,ETTYMD		;KEEP EXEC MODES UP TO DATE IN STORAGE
	CALL RTTYMD		;...FOR ^C.
	MOVEI A,0		;DON'T TYPE ^V IN ANY FORM
	DPB A,[POINT 2,ETTYMD+TTWCOC+1,9]
				;MAKE CONTROL-V ECHO LITERALLY AS IN FILENAMES
	MOVEI A,3		;FORMAT LINEFEED (MAKE IT ECHO AS CRLF)
	DPB A,[POINT 2,ETTYMD+TTWCOC,21]

IFN STANSW,<
	GJINF%
	IFGE. D			;DON'T DO THIS IF DETACHED
	ANDE. A			;OR IF LOGGED IN(!)
	  MOVEI A,.PRIOU	;SET RECEIVE SYSTEM-MESSAGES
	  MOVEI B,.MOSNT
	  MOVEI C,.MOSMY
	  MTOPR%
IFN NICSW,<
	  MOVEI A,.CTTRM
	  MOVEI B,.MORTF
	  MTOPR%
	  TXZ C,MO%NUM		;RECEIVE USER-MESSAGES 
	  MOVEI B,.MOSTF
	  MTOPR%
>

	ENDIF.
>;IFN STANSW

;DISABLE COMPAT FOR EXEC

	MOVEI	A,.FHSLF	;FOR SELF
	MOVNI	B,1		;SET TO -1
	MOVEI	C,0		;...
	SCVEC			;BYE

;DETERMINE HERE IF BATCH MODE

	SETZM BATCHF		;ASSUME NOT BATCH JOB
	MOVNI A,1
	MOVE B,[-1,,A]
	MOVEI C,.JIBAT		;GET BATCH FLAG
	GETJI
	 CALL JERR
	JUMPE A,NOBTCH		;0 := NOT BATCH
	SETOM	BATCHF		;SET BATCH FLAG
	SETOM	CCFLAG		;NO CTRL-C CAPABILITY
NOBTCH:

;FIND OUT IF THIS JOB IS LOGGED IN. (MIGHT BE AT STARTUP IF SUBSIDIARY.
;  OR A SUBSYSTEM COULD LOG JOB IN.)

	GJINF			;USER # IN A, 0 IF NOT LOGGED
	MOVEM A,CUSRNO		;SAVE USER # OR 0
	MOVEM A,LIDNO		;SAVE AS LOGGED-IN DIR NUMBER IN CASE OLD MONITOR AND GETJI FAILS
	MOVEM C,JOBNO		;REMEMBER JOB NUMBER
STAT,<	CALL SETUS>		;SETUP STATS
	MOVE A,C		;GET THE JOB NUMBER
	HRROI B,LIDNO		;READ LOGGED-IN DIRECTORY NUMBER INTO LIDNO
	MOVEI C,.JILNO		;ASK FOR ONLY THIS ONE.
	GETJI			;DO IT.
	 JFCL			;IGNORE FAILURE, SEE LIDNO REF. ABOVE.
	MOVEI A,.FHJOB
	RTIW			;UPDATED JOB TIW FOR EXEC
	MOVEM B,ETTYMD+TTWJTI
	MOVEM B,ITTYMD+TTWJTI	;INITIALLY, SAME FOR PGM
	MOVEI Q1,ETTYMD		;INITIALIZE TTY, SO ^V DOESN'T APPEAR IN FILENAMES
	CALL LTTYMD
	CALL IPCINI		;EM34 Do IPCF initialization
IFN NICSW,<
	MOVEI 1,400001		;inform ACJ of job startup
	SETZB 2,3
	SETZ 4,
	GETOK%			;always returns ok
	 ERJMP .+1
>;IFN NICSW

;SAY INITIALIZATION HAS COMPLETED SUCCESSFULLY.
;UNTIL CINITF<>0, ERROR ROUTINES HALT RATHER THAN TYPE MESSAGES.
; AND "REENTER" DOES A "START".

	SETOM CINITF
	CALL DOATI		;ASSIGN TERMINAL INTERRUPTS (DON'T ALLOW ^C EARLIER !)
	SKIPN CRPRA		;CRJOB SET UP?
	JRST CMDIN0		;NO
	HRRZ A,CRPRA+.CJPLP	;FETCH FLAG POINTER
	SKIPGE B,CRPRA(A)	;HERALD SUPPRESS?
	JRST CMDIN2		;YES
	TLNN B,(1B4)		;SIMULATE LOGIN?
	JRST CMDIN0		;NO SO GO ON.
	ETYPE <%_>		;PRINT A LINE.
	CALL %VERSI		;VERSION AND STUFF
	CALL DWNPNT		;DOWN TIME
	JRST CMDIN2		;AND CONTINUE
CMDIN0:	SKIPE BATCHF		;BATCH JOB?
	JRST CMDIN1		;GO PRINT HERALD
	SETO A,			;SUPPRESS HERALD FOR SYSJOB
	HRROI B,C
	MOVEI C,.JICPJ
	GETJI			;FETCH CONTROLLING JOB NUMBER
	 CALL JERR
	JUMPE C,CMDIN2		;SYSJOB, SO SKIP IT
CMDIN1:	ETYPE <%_>		;HERALD
IFN STANSW,<
;SET LOCATION TO LOCAL TO MAKE SURE BATCH JOBS DON'T HAVE WEIRD LOCATIONS.
	CALL INFER		;DO THIS ONLY FOR THE TOP-MOST EXEC.
	IFNSK.	
	  HRROI C,[ASCIZ/LOCAL/]  ;START OFF EVERYTHING AT LOCATION "LOCAL"
	  HRROI A,-1		;OURSELF
	  MOVEI B,.SJLLO	;SET LOGICAL LOCATION
	  SETJB%		;DO IT
	   ERJMP .+1		;FAILED, IGNORE IT
	  CALL TTYINI		;INITIALIZE TERMINAL PARAMETERS
	ENDIF.
>;IFN STANSW
	CALL $VERSI		;VERSIONS
	CALL DWNTYP		;IF THERE IS A DOWN TIME
IFN STANSW,<
IFN LOTSW,<
	CALL CKLTSQ		;SEE IF THERE IS A QUEUE AT LOTS
>;IFN LOTSW
	SKIPN CUSRNO		;MUST NOT BE LOGGED IN OR ON A PTY
	 CALL CHKPTY
	IFSKP.
	  MOVX A,<GJ%SHT!GJ%OLD> ;TYPE SYSTEM:BEWARE-MESSAGE.TXT IF IT EXISTS
	  HRROI B,[ASCIZ/SYSTEM:BEWARE-MESSAGE.TXT/]
	  CALL GTJFS
	  IFSKP.
	    MOVE A,[CTRLO,,5]	;ENABLE ^O INTERRUPT ON CHANNEL 5
	    ATI%
	    MOVEI Q1,CP%HEL	;SO "TYPE" LOGIC WILL KNOW IT'S US
	    MOVE A,JBUFP	;GET POINTER TO JFN CELL
	    HRRZM A,INIFH1
	    HRRZM A,INIFH2	;COPY CODE NEEDS THIS
	    CALL TYPE1		;COPY FILE TO TERMINAL
	  ENDIF.
	ENDIF.
>;IFN STANSW

;COMMANDS THAT RUN PROGRAM RETURN HERE WHEN IT STOPS.
;START, CONT, REENTER, RUN, <SUBSYSTEM NAME>, GOTO.
;RE-ENTRY JOINS MAIN FLOW HERE

CMDIN2::CALL SETT20		;SAY TOPS20 COMMAND LEVEL (PLACED HERE TO MINIMIZE JSYS'S PER COMMAND)
	JRST CMDIN3

$VERSI:	GJINF
	JUMPN A,EXECV		;EXEC VERSION ONLY IF LOGGED IN
%VERSI::PRINT " "
	HLLZ D,SYSVER		;XWD LENGTH, INDEX
%VERS1:	GTB .SYSVE		;GET A DATA WORD FROM TABLE (USES D)
	MOVE B,A
	MOVEI C,5		;PRINT 5 CHARS FROM EACH WORD
%VERS2:	SETZ A,
	LSHC A,7
	JUMPE A,%VERS3		;END ON NULL
	PRINT (A)
	SOJG C,%VERS2
	AOBJN D,%VERS1		;ALSO END ON END OF TABLE
%VERS3:	ETYPE<%_>
	RET

IFN STANSW&LOTSW,<

;CKLTSQ - CHECKS THE TMON% FUNCTION FOR A LOTS QUEUE (This is a kludge - PAH)
;SETS THE FLAG LOTSQ IF THERE IS A QUEUE AND GIVES APPROPRIATE MESSAGE.

CKLTSQ:	HRRZ A,CUSRNO		;WHO ARE WE?
	SKIPE ,A		;NOT-LOGGED-IN?
	 RET			;NO, FORGET THIS NONSENSE

	SETZM LOTSQ		;ASSUME NO QUEUE
	SETZM PLOGIN		;ASSUME NO PLOGIN
	SETZM INJSQ		;SAY THAT WE ARE NOT PRESENTLY TALKING TO JSQ

	MOVEI A,.SFLTQ		;WANT LENGTH OF QUEUE
	TMON			;GET IT
	 ERJMP R		;FAILED, ASSUME NO QUEUE

	SKIPGE B		;-1 MEANS THERE IS NO QUEUE
	 RET

	SETOM LOTSQ		;THERE IS A QUEUE
	TYPE <
                Queueing is presently in effect at LOTS.

If you wish to queue up for a job, just LOGIN normally.  If you DO NOT wish
to put yourself in the queue, simply use the LOGOUT command to log out.

If you use LOGIN, then decide you do not wish to continue in the queue,
type ^C (hold down the <CTRL> key and press C simultaneously).  The system
will then log you out.

>
	CAIG B,1		;LESS THAN TWO PEOPLE IN THE QUEUE?
	 JRST CKLTS1		;YES, GIVE APPROPRIATE MESSAGE

	TYPE <There are >
	MOVEI A,.PRIOU
	MOVEI C,12
	NOUT
	 ERJMP CJERR
	TYPE < people in the queue.

>
	RET

CKLTS1:	JUMPE B,CKLTS2
	TYPE <There is one person in the queue.

>
	RET

CKLTS2:	TYPE <The queue is empty.

>
	RET

>;IFN STANSW&LOTSW

;FIXON IS CALLED AFTER ADVISE IS ENDED TO RESTORE TERMINAL PAGING.

FIXON::	MOVEI A,.CTTRM		;REFERENCE CONTROLLING TERMINAL
	RFMOD			;GET CURRENT SETTINGS
	TXZ B,TT%PGM		;START WITH CLEAN PAGE MODE BIT
	IOR B,SAVPGM		;GET SAVED VALUE OF PAGE MODE BIT
	STPAR			;RESTORE VALUE OF PAGING BIT
	RET

;ROUTINE TO ENABLE TERMINAL INTERRUPTS

DOATI::	MOVEI A,.FHSLF
	RPCAP			;SEE IF WE'RE ALLOWED TO ENABLE ^C
	TXNN B,SC%CTC		;TEST SPEC CAP BIT 0
	JRST DOAT0		;NOT ALLOWED TO ENABLE ^C
	TXO C,SC%CTC
	EPCAP			;ENABLE FOR ^C CAPABILITY
	MOVE A,[XWD CTRLC,1]
	ATI
	MOVEI A,.FHJOB		;SET TERMINAL MASK FOR JOB
	MOVE B,ETTYMD+TTWJTI	;GET CORRECT MASK
	STIW			;SET UP CORRECT MASK
	MOVX A,ST%DIM!.FHSLF	;OURSELF, GET DEFERREDS IN AC3
	RTIW			;GET DEFERRED MASK
	TXO C,1B<CTRLC>
	STIW			;MAKE SO PROGRAM BUFFERED INPUT GETS READ BEFORE ^C

;ASSIGN CHAR TO PRINT TIME USED (^T) TO PSI CHANNEL 3

DOAT0:	MOVEI A,ADVESC		;MAKE SURE ADVICE CHARACTER NO LONGER SPECIAL
	DTI
	MOVE A,[XWD CTCODE,3]
	ATI

IFN FTCE,<
;ASSIGN CHARACTER TO ACTIVATE COMMAND EDITOR

	SKIPG CEPSIC		;INTERRUPT CHARACTER SET?
	IFSKP.			;YES
	  HRLZ A, CEPSIC	;GET IT
	  HRRI A, CEDCHN	;AND USE CHANNEL FOR COMMAND EDITOR
	  ATI%			;ENABLE THE INTERRUPT
	ENDIF.
>;IFN FTCE

;ASSIGN CHARACTER TO CLEAR OUTPUT BUFFER

	MOVE A,[CTRLO,,5]	;CONTROL-O IS USED
	ATI
	RET

;THIS ROUTINE GET TIME LIMIT WHICH WAS POSSIBLY SET BY ANOTHER
;PROCESS AND SETS IT ON THE CORRECT CHANNEL

CPULIM:	MOVNI A,1
	MOVE B,[-1,,D]		;GET CURRENT LIMIT INTO D
	MOVEI C,.JIRTL
	GETJI
	 CALL JERR
	MOVE A,[.FHJOB,,.TIMRT]	;SET TIME LIMIT CODE
	SETZB B,C		;CLEAR LIMIT
	TIMER
	 CALL [	CAIE A,TIMX4	;NOT SET BY THIS FORK?
		JRST JERR	;NOPE, PRINT IT
		POP P,(P)
		RET]		;RETURN HAVING DONE NOTHING
	MOVE A,[.FHJOB,,.TIMRT]	;SET TIME LIMIT CODE
	MOVE B,D		;GET TIME TO SET
	MOVEI C,4		;CHANNEL
	TIMER
TIMERR:	 ERROR <Couldn't set time limit - %?>
	RET

;SUBROUTINE TO INIT GTTAB NUMBERS - USED AT STARTUP ONLY
;NOTE:  THE ONLY ONES THAT SHOULD BE INITED HERE ARE ONES TO BE
;USED FOR *OTHER* THAN GETAB JSYS.  FOR GETAB JSYS, USE MONITOR
;SYMBOLS.

STSYST:	MOVSI D,-NGTTBS		;NUMBER OF TABLES
STSYS1:	MOVE A,GTTBS(D)		;GET THE SIXBIT NAME OF THE TABLE
	SYSGT			;GET ITS NUMBER
	JUMPN B,STSYS2		;JUMP UNLESS NO SUCH TABLE
	TYPE <%No system table named: >
	MOVE A,GTTBS(D)
	CALL SIXPRT
	SETZ B,
STSYS2:	MOVEM B,@GTTBS+1(D)	;PUT NUMBER IN VARIABLE
	AOBJN D,.+1
	AOBJN D,STSYS1		;DO ALL TABLES
	RET

DEFINE PRGSTG			;STORAGE NEEDED FOR PROGRAM COMMANDS
<	TRVAR <PNAMP,NAMFLG,PJFN,PTBLP>
>
;LIST OF GTTAB TABLES KNOWN TO EXEC

DEFINE XX (NAMS)<
	IRP NAMS,<
	SIXBIT /NAMS/
	Z NAMS>>

GTTBS:	XX <QTIMES,SNAMES,SYSVER,JOBRT,TTYJOB>
NGTTBS==.-GTTBS

IFN STANSW,<
;STANFORD MAIL COMMAND - INVOKES MM
.MAIL::	NOISE <TO>
	MOVE B,[[FLDDB. .CMCFM,,,,,USRLST]]
	DO.
	  CALL FLDSKP		;TRY TO PARSE IT
	   CMERRX
	  LDB D,[POINT 9,(C),8]	;WHAT DID USER SAY?
	  CAIN D,.CMCFM		;JUST MAIL<CR>?
	  IFSKP.		;NO.
	    CAIE D,.CMTOK	;TOKEN?
	    IFSKP.
	      MOVE A,.CMDAT(C)	;YES, GET THE TOKEN
	      ILDB A,A
	      CAIE A,"*"	;OUTPUT FILE?
	      IFSKP.
	        SETZM CJFNBK	;CLEAR GTJFN DEFAULT BLOCK
	        MOVE A,[CJFNBK,,CJFNBK+1]
	        BLT A,CJFNBK+JBLEN-1
	        FILEX <file name to output message to>
	         CMERRX
	      ENDIF.
	    ENDIF.
	    MOVEI B,[FLDDB. .CMTOK,CM%SDH,<POINT 7,[ASCIZ /@/]>,<confirm with carriage return
 or "," for another address
 or "@" for a network host name
 or ":" to make this a group name>,,<[
  		     FLDDB. .CMTOK,CM%SDH,<POINT 7,[ASCIZ /:/]>]>]
	    MOVX D,CM%XIF	;ALLOW @ FOR HOST NAME
	    IORM D,SBLOCK
	    CALL FLDSKP
	    IFSKP.		;HAVE @ OR :.
	      MOVE A,.CMDAT(C)
	      ILDB A,A
	      CAIE A,":"	;DISTRIBUTION LIST?
	      IFSKP.		;YES.
	        MOVEI B,USRLST	;DON'T ALLOW CONFIRM SECOND TIME AROUND
	        LOOP.		;GET ANOTHER ADDRESS
	      ENDIF.
	      MOVEI B,[FLDBK. .CMFLD,,,<Host name>,,HNMMSK] ;HOST NAME NOW
	      CALL FLDSKP	;TRY TO PARSE IT (DUMBLY)
	       CMERRX
	    ENDIF.
	    MOVEI B,[FLDDB. .CMCFM,,,,,<[FLDDB. .CMCMA]>]
	    CALL FLDSKP		;MUST BE COMMA OR CONFIRM HERE
	     CMERRX
	    LDB D,[POINT 9,(C),8]	;GET FIELD TYPE
	    CAIE D,.CMCMA	;COMMA?
	    IFSKP.		;YES.
	      MOVEI B,USRLST	;DON'T ALLOW CONFIRM SECOND TIME AROUND
	      LOOP.		;GET ANOTHER ADDRESS
	    ENDIF.
	  ENDIF.
	ENDDO.
	HRROI B,[GETSAVE (SYS:MM.)] ;MUST BE CONFIRM, GO RUN MM
	JRST DOCC2

USRLST:	FLDDB. .CMTOK,CM%SDH,<POINT 7,[ASCIZ/*/]>,<"*" for sending to a file
  or "@" to send indirect from a file>,,<[
	FLDDB. .CMUSR,,,,,<[
	FLDDB. .CMTOK,CM%SDH,<POINT 7,[ASCIZ/./]>,<"." for yourself>,,<[
	FLDDB. .CMKEY,,<[2,,2
		[ASCIZ/BBOARD/],,0
		[ASCIZ/SYSTEM/],,0]>,<special mailbox>,,<[
	FLDDB. .CMQST,,,,,<[
	FLDBK. .CMFLD,,,<Network address>,,UNMMSK]>]>]>]>]>

;SEND COMMAND
;SEND TTY MESSAGES TO LOCAL AND NETWORK TERMINALS

SNDCMD::
;begin NIC change
;	HRROI B,[GETSAVE <SYS:SEND.>] ;get program
;	CALL TRYGTJ	
;	 ERROR <Utility not installed at this site>
;	CALL $GET0		;get a new fork
;	CALL CRSCAN		;put command in rescan buffer
;	CALLRET ..STRT		;start fork

;	NOISE <TO>	
;	CALLRET STEPH
;end NIC change

	NOISE <TO>
	DO.
	  MOVEI B,[FLDDB. .CMUSR,,,,,[
		   FLDDB. .CMNUM,CM%SDH,10,<Local terminal number>,,[
		   FLDDB. .CMTOK,CM%SDH,<-1,,[ASCIZ/*/]>,,,[
		   FLDBK. .CMFLD,,,<Network address>,,UNMMSK]]]]
	  CALL FLDSKP		;PARSE DESTINATION
	   ERROR <No such user>
	  LOAD D,CM%FNC,(C)	;FETCH TYPE OF FIELD WE JUST PARSED FOR LATER
	  MOVX A,CM%XIF
	  ORM A,SBLOCK+.CMFLG	;TURN OFF SPECIAL MEANING OF @
	  MOVEI B,[FLDDB. .CMCMA,CM%SDH,,<comma and another address>,,[
		   FLDDB. .CMTOK,,<-1,,[ASCIZ/@/]>,,,[
		   FLDDB. .CMTOK,CM%SDH,<-1,,[ASCIZ/%/]>,,,[
		   FLDDB. .CMTXT,CM%SDH,,<one line text message, or confirm with carriage return>]]]]
	  CAIN D,.CMFLD		;IF FIELD, MUST PARSE NET SITE
	   MOVEI B,[FLDDB. .CMTOK,,<-1,,[ASCIZ/@/]>,,,[
		    FLDDB. .CMTOK,CM%SDH,<-1,,[ASCIZ/%/]>]]
	  CALL FLDSKP		;PARSE COMMA, ATSIGN, ETC
	   ERROR <No such user>
	  LOAD C,CM%FNC,(C)	;GET WHAT WE PARSED
	  CAIE C,.CMTOK		;ATSIGN?
	  IFSKP.
	    MOVEI B,[FLDBK. .CMFLD,,,<Host name>,,HNMMSK] ;HOST NAME NOW
	    CALL FLDSKP		;YES, PARSE HOST NAME
	     ERROR <No such host name>
	    MOVEI B,[FLDDB. .CMCMA,CM%SDH,,<comma and another address>,,[
		     FLDDB. .CMTXT,CM%SDH,,<one line text message, or confirm with carriage return>]]
	    CALL FLDSKP		;GET PARSE BACK TO EXPECTED STATE
	     ERROR <Not confirmed> ;???
	    LOAD C,CM%FNC,(C)	;GET LAST FIELD PARSED
	  ENDIF.
	  CAIN C,.CMCMA		;COMMA?
	   LOOP.		;BACK FOR ANOTHER
	ENDDO.
	CONFIRM			;FINISH COMMAND PARSE
	SETZM RSPTR		;FORCE CRSCAN TO USE COMMAND ITSELF
	HRROI B,[GETSAVE (SYS:SEND.)]
	JRST PERUN

;; LOTS' CFS CROSS-SYSTEM FINGER

.FIND::	MOVEI B,[FLDDB. .CMCFM,CM%SDH,,<confirm to FIND all users>,,[
		 FLDDB. .CMSWI,,FISTBL,,,[
		 FLDDB. .CMUSR,,,,,[
		 FLDDB. .CMQST,CM%SDH,,<personal name>,,[
		 FLDDB. .CMTOK,CM%SDH,<-1,,[ASCIZ\@\]>,<@<host name>>,,[
		 FLDBK. .CMFLD,CM%SDH,,,,UNMMSK]]]]]]
	SKIPA
.FIND1:	 MOVEI B,[FLDDB. .CMCFM,,,,,[
		  FLDDB. .CMSWI,,FISTBL,,,[
		  FLDDB. .CMUSR,,,,,[
		  FLDDB. .CMQST,CM%SDH,,<personal name>,,[
		  FLDDB. .CMTOK,CM%SDH,<-1,,[ASCIZ\@\]>,<@<host name>>,,[
		  FLDBK. .CMFLD,CM%SDH,,,,UNMMSK]]]]]]
	MOVX D,CM%XIF		;ALLOW @ FOR HOST NAME
	IORM D,SBLOCK		;SET IT UP
	CALL FLDSKP		;PARSE IT
	 ERROR <Couldn't parse switch, user, personal name or token>
	LOAD D,CM%FNC,(C)	;FIND OUT WHAT WE PARSED
	CAIE D,.CMSWI		;WAS IT A SWITCH?
	IFSKP.
	  HRRZ B,(B)		;YES, GET THE DISPATCH LOCATION
	  CALL (B)		;DO IT
	  JRST .FIND1		;AND GET THE NEXT SWITCH
	ENDIF.
	CAIN D,.CMCFM		;DID WE GET A RETURN?
	 JRST .FINDX		;YES, GO FINISH UP
	CAIE D,.CMFLD		;DID WE GET A PERSONAL NAME?
	 CAIN D,.CMQST
	  JRST .FINDM		;GO DO IT AS A STRING
	CAIN D,.CMTOK		;WAS IT THE @?
	 JRST .FINDS		;MUST BE A NET SITE, GO DO IT

.FINDU:	MOVEI B,[FLDDB. .CMCFM,,,,,[
		 FLDDB. .CMSWI,,FISTBL,,,[
		 FLDDB. .CMCMA,CM%SDH,,<"," and another username>,,[
		 FLDDB. .CMTOK,CM%SDH,<-1,,[ASCIZ\@\]>,<@<host name>>]]]]
	MOVX D,CM%XIF		;ALLOW @ FOR HOST NAME
	IORM D,SBLOCK		;SET IT UP
	CALL FLDSKP
	 ERROR <Couldn't parse comma, switch or token>
	LOAD D,CM%FNC,(C)
	CAIN D,.CMCFM		;CONFIRM?
	 JRST .FINDX		;YES, FINISH UP
	CAIE D,.CMCMA		;WAS IT A COMMA?	 
	IFSKP.
	  MOVEI B,[FLDDB. .CMUSR] ;PARSE A USER NAME
	  CALL FLDSKP
	   ERROR <Couldn't parse user name>
	  JRST .FINDU		;AND GO GET MORE USERS (OR SWITCHES)
	ENDIF.
	CAIN D,.CMTOK		;WAS IT THE HOST NAME?
	 JRST .FNDS1		;YES, GO FIND OUT WHERE TO FIND
	CAIE D,.CMSWI		;GOT A SWITCH?
	IFSKP.
	  HRRZ B,(B)		;GET THE DISPATCH
	  CALL (B)		;DO IT
	ENDIF.

.FINDH:	MOVEI B,[FLDDB. .CMCFM,,,,,[
		 FLDDB. .CMSWI,,FISTBL,,,[
		 FLDDB. .CMTOK,CM%SDH,<-1,,[ASCIZ\@\]>,<@<host name>>]]]
	MOVX D,CM%XIF		;ALLOW @ FOR HOST NAME
	IORM D,SBLOCK		;SET IT UP
	CALL FLDSKP
	 ERROR <Couldn't parse switch or token>
	LOAD D,CM%FNC,(C)
	CAIN D,.CMCFM		;CONFIRM?
	 JRST .FINDX		;YES, GO FINISH UP
	CAIE D,.CMSWI		;SWITCH?
	IFSKP.
	  HRRZ B,(B)		;YES, GET THE DISPATCH
	  CALL (B)		;DO IT
	  JRST .FINDH		;GO GET MORE SWITCHES OR A HOST
	ENDIF.

.FINDS:	MOVEI B,[FLDBK. .CMFLD,,,<network host name>,,HNMMSK] ;Want a host
	CALL FLDSKP
	 ERROR <Couldn't parse host name>
	JRST .FINDN
.FNDS1:	MOVEI B,[FLDBK. .CMFLD,,,<network host name>,,HNMMSK] ;Want a host
	CALL FLDSKP
	 ERROR <Couldn't parse host name>

.FINDW:	MOVEI B,[FLDDB. .CMCFM,,,,,[
		 FLDDB. .CMSWI,,FISTBL]]
	CALL FLDSKP
	 ERROR <Couldn't parse switch>
	LOAD D,CM%FNC,(C)
	CAIN D,.CMCFM		;CONFIRM?
	 JRST .FINDX
	CAIE D,.CMSWI		;SWITCH?
	IFSKP.
	  HRRZ B,(B)		;YES, GET THE DISPATCH
	  CALL (B)		;DO IT
	  JRST .FINDW		;GO GET MORE SWITCHES (OR CONFIRM)
	ENDIF.

.FINDN:	MOVEI B,[FLDDB. .CMCFM,,,,,[
		 FLDDB. .CMSWI,,FISTBL,,,[
		 FLDDB. .CMUSR,,,,,[
		 FLDDB. .CMQST,CM%SDH,,<personal name>,,[
		 FLDBK. .CMFLD,CM%SDH,,,,UNMMSK]]]]]
	CALL FLDSKP
	 ERROR <Couldn't parse username, personal name or switch>
	LOAD D,CM%FNC,(C)	;GET WHAT WE PARSED
	CAIN D,.CMCFM		;DID WE GET A RETURN?
	 JRST .FINDX		;YES, GO FINISH UP
	CAIE D,.CMSWI		;WAS IT A SWITCH?
	IFSKP.
	  HRRZ B,(B)		;YES, GET THE DISPATCH LOCATION
	  CALL (B)		;DO IT
	  JRST .FINDN		;GO GET MORE SWITCHES AND STUFF
	ENDIF.
	CAIE D,.CMFLD		;DID WE GET A PERSONAL NAME?
	 CAIN D,.CMQST
	  JRST .FINDW		;GO GET SWITCHES

.FNDN1:	MOVEI B,[FLDDB. .CMCFM,,,,,[
		 FLDDB. .CMSWI,,FISTBL,,,[
		 FLDDB. .CMCMA,CM%SDH,,<"," and another username>]]]
	CALL FLDSKP
	 ERROR <Couldn't parse comma or switch>
	LOAD D,CM%FNC,(C)
	CAIN D,.CMCFM		;CONFIRM?
	 JRST .FINDX		;YES, FINISH UP
	CAIE D,.CMCMA		;WAS IT A COMMA?	 
	IFSKP.
	  MOVEI B,[FLDDB. .CMUSR] ;PARSE A USER NAME
	  CALL FLDSKP
	   ERROR <Couldn't parse user name>
	  JRST .FNDN1		;AND GO GET MORE USERS (OR SWITCHES)
	ENDIF.
	CAIE D,.CMSWI		;GOT A SWITCH?
	IFSKP.
	  HRRZ B,(B)		;GET THE DISPATCH
	  CALL (B)		;DO IT
	ENDIF.
	JRST .FINDW		;GO GET SWITCHES

.FINDM:	MOVEI B,[FLDDB. .CMCFM,,,,,[
		 FLDDB. .CMSWI,,FISTBL,,,[
	         FLDDB. .CMTOK,CM%SDH,<-1,,[ASCIZ \@\]>,<@<host name>>]]]
	MOVX D,CM%XIF		;ALLOW @ FOR HOST NAME
	IORM D,SBLOCK		;SET IT UP
	CALL FLDSKP
	 ERROR <Couldn't parse switch or token>
	LOAD D,CM%FNC,(C)	;GET WHA WE PARSED
	CAIE D,.CMSWI		;DID WE PARSE A SWITCH?
	IFSKP.
	  HRRZ B,(B)		;YES, GET THE DISPATCH
	  CALL (B)		;DO IT
	  JRST .FINDM		;GET NEXT SWITCH OR GET A HOST NAME
	ENDIF.
	CAIN D,.CMTOK		;DID WE GET "@"?
	 JRST .FINDS		;YES, GO FIND AT THAT HOST

.FINDX:	SETZM RSPTR		;FORCE CRSCAN TO USE COMMAND ITSELF
	HRROI B,[GETSAVE(SYS:FIND.)]	;GET WHAT WE WANT TO RUN
	JRST PERUN		;AND RUN IT

.FNDLN:	MOVEI B,[FLDDB. .CMFLD,CM%SDH,,<last name of user to find>]
	SKIPA	
.FNDAT:	 MOVEI B,[FLDDB. .CMFLD,CM%SDH,,<place to find at>]
	SKIPA
.FNDTT:	 MOVEI B,[FLDDB. .CMNUM,CM%SDH,^D8,<octal terminal number>]
	CALL FLDSKP
	 ERROR <Couldn't parse field>
	RET

FISTBL:	FISLEN,,FISLEN		;FIND COMMAND SWITCHES

	[ASCIZ/AT:/],,.FNDAT
	[ASCIZ/CONSULTANT/],,R
	[CM%ABR!CM%INV
	ASCIZ/D/],,%FNDD
	[CM%ABR!CM%INV
	ASCIZ/DI/],,%FNDD
	[CM%ABR!CM%INV
	ASCIZ/DIA/],,%FNDD
	[CM%ABR!CM%INV
	ASCIZ/DIAL/],,%FNDD
%FNDD:!	[ASCIZ/DIAL-IN/],,R
	[CM%INV
	ASCIZ/DIALIN/],,R
	[CM%ABR!CM%INV
	ASCIZ/F/],,%FNDF
	[CM%ABR!CM%INV
	ASCIZ/FU/],,%FNDF
	[CM%ABR!CM%INV
	ASCIZ/FUL/],,%FNDF
	[CM%ABR!CM%INV
	ASCIZ/FULL/],,%FNDF
%FNDF:!	[ASCIZ/FULL-USER-NAME/],,R
	[CM%INV
	ASCIZ/FULLUSERNAME/],,R
	[ASCIZ/HELP/],,R
	[CM%ABR!CM%INV
	ASCIZ/LA/],,%FNDL
	[CM%ABR!CM%INV
	ASCIZ/LAS/],,%FNDL
	[CM%ABR!CM%INV
	ASCIZ/LAST/],,%FNDL
%FNDL:!	[ASCIZ/LAST-NAME:/],,.FNDLN
	[CM%INV
	ASCIZ/LASTNAME:/],,.FNDLN
	[ASCIZ/LOCAL/],,R
	[ASCIZ/LOGIN/],,R
	[CM%ABR!CM%INV
	ASCIZ/N/],,%FNDN
	[CM%ABR!CM%INV
	ASCIZ/NO/],,%FNDN
%FNDN:!	[ASCIZ/NO-PLAN/],,R
	[CM%INV
	ASCIZ/NOPLAN/],,R
	[ASCIZ/OPERATOR/],,R
	[ASCIZ/PLAN/],,R
	[ASCIZ/RUNTIME/],,R
	[CM%ABR!CM%INV
	ASCIZ/T/],,%FNDT
	[CM%ABR!CM%INV
	ASCIZ/TT/],,%FNDT
	[CM%ABR!CM%INV
	ASCIZ/TTY/],,%FNDT
%FNDT:!	[ASCIZ/TTY:/],,.FNDTT
	[ASCIZ/WIZARDS/],,R

FISLEN==.-FISTBL-1

; BREAK MASK FOR USER NAME 

UNMMSK:	777777777760			; NO CONTROLS
	767544001760			; %, *, -, .. NUMERICS
	400000000760			; UPPER CASE ALPHABETICS
	400000000760			; LOWER CASE ALPHABETICS

;BREAK MASK FOR HOST NAME

HNMMSK:	777777777760		;NO CONTROLS
	737744001760		;"#", "-", ".", NUMERICS
	400000000260		;UPPER CASE ALPHABETICS, "[", "]"
	400000000760		;LOWER CASE ALPHABETICS

;FINGER COMMAND - SIMPLE FRONT END TO FINGER PROGRAM
;
;IT'S OK IF THIS PARSE IS NOT AS RESTRICTIVE AS IT COULD
;BE - THE FINGER PROGRAM WILL CATCH ANY REMAINING PROBLEMS
;(FOR INSTANCE .CMCMA ONLY WORKS AT LOTS BUT IS OK TO PARSE
; ON ALL SYSTEMS)

.FINGE::DO.
	  MOVX D,CM%XIF		;ALLOW @ FOR HOST NAME
	  IORM D,SBLOCK
	  MOVEI B,[FLDDB. .CMCFM,,,,,[
		   FLDDB. .CMUSR,,,,,[
		   FLDDB. .CMSWI,,FSWTAB,,,[ ;SYS-SPECIFIC SWITCHES
		   FLDDB. .CMCMA,CM%SDH,,,,[ ;(LOTS FINGER ONLY)
		   FLDDB. .CMTOK,CM%SDH,<POINT 7,[ASCIZ/@/]>,,,[
		   FLDDB. .CMTXT,CM%SDH,,<network address>]]]]]]
	  CALL FLDSKP		;TRY TO PARSE IT
	   ERROR <No such user or switch>
	  LOAD D,CM%FNC,(C)	;FIND OUT WHICH IT WAS
	  CAIE D,.CMTOK		;TOKEN ("@")?
	  IFSKP.
	    MOVEI B,[FLDBK. .CMFLD,CM%SDH,,<Host name>,,HNMMSK]
	    CALL FLDSKP
	     ERROR <Invalid host name>
	    LOOP.
	  ELSE.
	    CAIE D,.CMSWI	;LOTS-SPECIFIC (SCORE DOESN'T HAVE SWITCH VALS)
	    IFSKP.
	      HRRZ A,(B)	;PICK UP SWITCH VALUE
	    ANDN. A
	      MOVEI B,[FLDDB. .CMFLD,CM%SDH,,<switch value>] ; (KLUDGE)
	      CALL FLDSKP	;TRY TO PARSE IT
	       ERROR <Invalid switch value>
	      LOOP.
	    ENDIF.
	    CAIE D,.CMCFM	;CONFIRMATION?
	     LOOP.
	  ENDIF.
	ENDDO.
	SETZM RSPTR		;FORCE CRSCAN TO USE COMMAND ITSELF
	HRROI B,[GETSAVE(SYS:FINGER.)]	;GET WHAT WE WANT TO RUN
PERUN::	PRGSTG			;ALLOCATE STORAGE
	CALL TRYGTJ		;GET JFN ON FILESPEC
	 CMERRX <Can't find program>
	MOVEM A,PJFN		;REMEMBER JFN OF PROGRAM
	MOVEI Q1,ETTYMD		;SET TTY MODES
	CALL LTTYMD
	MOVE A,PJFN		;PASS ON JFN
	JRST REPH		;GO RUN AS EPHEMERAL

FSWTAB:	FSWLEN,,FSWLEN		;FINGER COMMAND SWITCHES
	[CM%FW!CM%INV
	 ASCIZ/ARPANET/],,0
	[ASCIZ/CPU-IDLE/],,0
	[ASCIZ/DETACHED/],,0
	[ASCIZ/DIAL-IN/],,0
	[ASCIZ/ETHERNET/],,0
	[ASCIZ/FULL-USER-NAME/],,0
	[ASCIZ/HELP/],,0
	[ASCIZ/INTERNET/],,0
	[ASCIZ/JOBNAME:/],,1
	[ASCIZ/LOCAL/],,0
	[ASCIZ/LOGIN/],,0
	[ASCIZ/NETWORK/],,0
	[CM%FW!CM%INV!CM%ABR
	 ASCIZ/NO/],,%NOPLN
	[ASCIZ/NO-DETACHED/],,0
	[ASCIZ/NO-OPERATOR/],,0
%NOPLN:![ASCIZ/NO-PLAN/],,0
	[ASCIZ/OPERATOR/],,0
	[ASCIZ/PHYSICAL-LOCATIONS/],,0
	[ASCIZ/PTY/],,0
	[ASCIZ/REAL-LOCATIONS/],,0
	[ASCIZ/TERSE/],,0
	[EXP CM%FW!CM%ABR!CM%INV,ASCIZ/TT/],,TTYENT ;TT = TTY:
	[EXP CM%FW!CM%ABR!CM%INV,ASCIZ/TTY/],,TTYENT ;TTY = TTY:
	[ASCIZ/TTY-IDLE/],,0
TTYENT:	[ASCIZ/TTY:/],,1
	[ASCIZ/TYPE:/],,1
	[ASCIZ/VERBOSE/],,0
	[ASCIZ/WHOIS/],,0

FSWLEN==.-FSWTAB-1

IFN LOTSW!CSLISW,<
; HELPME, WHOCONSULT, WIZARDS.
.WHO::	CONFIRM
	HRROI B,[GETSAVE(SYS:WHOCONSULT.)]
	JRST PERUN		;RUN IT.

.WIZ::	CONFIRM
	HRROI B,[GETSAVE(SYS:WIZARDS.)]
	JRST PERUN		;RUN IT.

.HELPM::MOVEI B,[FLDDB. .CMTXT,CM%SDH,,<one line text message, or confirm with carriage return>]
	CALL FLDSKP
	 ERROR <Not confirmed>	;HMMM...
	CONFIRM
	HRROI B,[GETSAVE(SYS:HELPME.)]
	JRST PERUN		;RUN IT.
>;IFN LOTSW
>;IFN STANSW

;^C AND COMMAND ERRORS COME BACK HERE.
;AFTER ^C IT IS NECESSARY TO EXECUTE CODE TO FIND OUT WHETHER LOGGED IN,
; HAVE INFERIOR FORK, UPDATE CAPABILITIES, KILL AUTOLOGOUT FORK,
; ETC IN CASE INTERRUPTED COMMAND WAS LOGIN, RUN, ETC.

ERRET::	SETZM ERRMF		;CLEAR ERROR WITHIN ERROR FLAG
	SKIPN ADVFLG
	JRST CMDIN3		;NO CLEANUP NECESSARY
	CALL DOATI		;MAKE SO ^E AND ^C WORK AS NORMAL AGAIN
	CALL FIXON		;FIX PAGE MODE SETTING
	MOVE B,ADVTNM		;GET TERMINAL FOR BREAKING LINKS WITH
	CALL BREAK1		;BREAK LINKS TO REALLY END THE ADVICE
	XCT ADVMES		;GIVE STANDARD END MESSAGE (AFTER BREAK SO WE DON'T HANG UP AGAIN)
	SETZM ADVFLG		;INDICATE NOT IN ADVISE CODE

CMDIN3:	MOVEI A,1
	MOVEM A,INTDF
	MOVEM A,IINTDF		;MAKE SURE IPCF INTERRUPTS ALLOWED
IFE STANSW,<
	CALL PION		;MAKE SURE ^C ALLOWED
	CALL IPCON		;MAKE SURE IPCF INTERRUPTS ALLOWED
>;IFE STANSW

;MISCELLANEOUS INITIALIZATION

	MOVEI A,RERET		;SAY WHERE TO GO ON ERROR WHILE TYPING
	MOVEM A,CERET		; ...LOGIN MESSAGE
IFN STANSW,<
	SETOM CINITF		;FLAG INITIALIZED NOW IN CASE ^C INTERRUPT
	CALL PION		;MAKE SURE ^C ALLOWED
	CALL IPCON		;MAKE SURE IPCF INTERRUPTS ALLOWED
>;IFN STANSW

;PRINT "YOU HAVE A MESSAGE" IF APPROPRIATE
;HERE SO DONE EVEN AFTER ^C DURING LOGIN MESSAGE

	SKIPE CRPRA		;IS CRJOB START UP?
	 JRST [ HRRZ A,CRPRA+.CJPLP ;GET FLAGS PTR
		MOVE B,CRPRA(A)
IFE STANSW,<
		TLNE B,(1B4)	;SIMULATE LOGIN?
		SETOM LOGINI	;YES.
>;IFE STANSW
IFN STANSW,<	
		TLNN B,(1B4)	;SIMULATE LOGIN?
		IFSKP.		
		  SETOM LOGINI	;YES.
		  SETOM LGXINI	;YES, READ SYSTEM:LOGIN.CMD 1ST
		ENDIF.
>;IFN STANSW
		TLNN B,(1B3!1B4);CREATOR WANT SYSTEM MESSAGES ETC?
		 JRST [ SETZM MESMSF ;NO LOGIN CHECK
			SETZM MWATCF ;NO MAIL WATCH
			JRST CMDIN4] ;BYPASS
		ETYPE < Job %J on %L %D %E
>
		SETO A,		;THIS JOB
		HRROI B,LOGDAT
		MOVEI C,.JILLN	;GET LAST LOGIN D&T
		GETJI
		 SETZ A,	;FAILS, USED NEVER LOGGED IN
		SETOM SYSMF	;INIT GUY SO IT WORKS...
		CALL FREINI	;INITIALIZE FREE SPACE
		CALL PNTMES	;PRINT SYSTEM MESSAGE(S)
		JRST .+1]
	JRST CMDIN4

;CMDOUT - FROM LOGOUT CODE TO PROCESS LOGOUT.CMD AND SAVE OUR RETURN
;CMDIN4 - WHEN READY TO INPUT A COMMAND.
;ALL COMMANDS RETURN TO CMDIN4 OR ABOVE WHEN DONE.

CMDOUT::SKIPN LGORET		;DOING LOGOUT.CMD? IF NOT, NO NEED TO SAVE OUR RETURN
	JRST CMDIN4
	POP P,LGORET		;YES, SAVE THE RETURN
	HRRZS LGORET
CMDIN4::SETZM .JBUFP		;ALLOW ALL JFNS TO BE RELEASED
	CALL FIXIO		;MAKE SURE REAL STREAM USED FOR COMMAND

;SET SUBSYSTEM NAME TO "EXEC".
;THIS UPDATES MONITOR TABLES USED BY "SYSTAT".

	MOVX A,OURNAM
	MOVEM A,ETTYMD+TTWSNM
	MOVEM A,ETTYMD+TTWPNM	;PROGRAM NAME TOO
	MOVX B,OURNAM		;SET UP PRIVATE NAME AS SAME
	SKIPN PCCURC		;PCL If no stored command in progress
	SETSN			;SET UP SYSTEM NAME AS EXEC
	 JFCL
	SETO A,
	CAME A,NPAGE
	CALL MAPPF		;DON'T LEAVE FORK PAGES MAPPED
	 JFCL			;UNMAP SHOULDN'T FAIL
	SETZM CSZ1		;ZERO STORAGE
	MOVE A,[XWD CSZ1,CSZ1+1]
        BLT A,CSZ2

;INITIALIZE WHAT NEEDS INITIALIZING

        MOVE A,[POINT 7,CBUF,-1] ;BYTE POINTER INTO COMMAND BUFFER,
				;IN WHICH ENTIRE LINE IS ACCUMULATED.
	MOVEM A,BEGINP		;REMEMBER WHERE INPUT LINE BEGINS (FOR REPARSES)
	XCT INISTK		;INITIALIZE STACK
	PRGSTG			;GET LOCAL STORAGE FOR PROGRAM NAME STUFF
	CALL FREINI		;INITIALIZE FREE SPACE

;INITIALIZE AUTOLOGOUT STUFF IF NECESSARY

	SKIPE CUSRNO
	JRST CMDN5E		;LOGGED IN, NOT RELEVANT.
	IFNBATCH (CMDN5E)	;NO ALO STUFF IF IN BATCH
	SKIPE ALOST		;HAVE WE STARTED THE AUTOLOGOUT STUFF UP?
	 JRST CMDN5D		;YES, THE FOLLOWING ALREADY DONE
	GTAD			;SAVE STARTUP TIME FOR USE IN
	MOVEM A,STRTIM		;"ALOTST" SUBR

;SET UP A PENDING TIMER INTERRUPT FOR AUTO-LOGOUT IF JOB IS INACTIVE

	MOVE A,[.FHSLF,,.TIMEL]	;SET AN ELAPSED TIMER FOR SELF
	MOVE B,[AUTOL2*^D1000]	;FOR THAT FAR IN FUTURE
	MOVEI C,2		;ON CHANNEL 2
	CALL PIOFF		;DISABLE CONTROL-C'S
	SETOM ALOST		;SAY AUTOLOGOUT STUFF STARTED
	TIMER
	 ERROR <Couldn't initialize auto-logout timer - %?>
	CALL PION		;ENABLE CONTROL-C'S

;JOB ISN'T LOGGED IN, SEE IF IT'S TIME TO AUTO-LOGOUT IT.

CMDN5D:	CALL ALOTST

;PRINT READY CHARACTER

CMDN5E:
;CHECK TO SEE IF CRJOB/PRARG START UP & IF SO, A PROGRAM TO RUN

	SKIPE CRPRA		;CRJOB START UP?
	 JRST [ HRRZ A,CRPRA+.CJPLP ;YES, GET FLAGS PTR
		MOVE B,CRPRA(A)	;THEN FLAGS
		TLNN B,(1B2)	;WANT FORK STARTED?
		 JRST .+1	;NO
		HRRZ A,CRPRA+.CJPKP ;GET PTR TO FORK & SFRKV OFFSET
		HRRZ B,CRPRA(A)
		CALL CLPRA	;CLEAR CRJOB/PRARG AREA
		PUSH P,[CMDIN4] ;WHERE TO RETURN WHEN DONE
		JRST ..STCR]	;RUN IT
	CALL CLPRA

;CHECK FOR DEFAULT "TAKE" COMMANDS

	MOVE A,CIJFN
	CAIN A,.PRIIN		;IF INPUT NOT FROM PRIMARY,
	SKIPE FSTLGN		;  OR FAST LOGIN WANTED,
	JRST NLGINI		;THEN NO CHANGE OF INPUT NOW
	SKIPN LOGINI		;LOGIN JUST DONE?
	JRST NL1		;NO, SKIP THIS - IF LOGINI=0, WE ALREADY DID .CMD FILES
	SKIPL LOGINI		;HAVE WE TAKEN ANY LOGIN.CMD FILES YET?
	JRST TKULOG		;YES, TAKEN SYSTEM: .CMD FILE (LOGINI>0)-TRY USER's .CMD FILE
	MOVEI B,1		;LOGINI <0; WE HAVEN'T TAKEN ANY .CMD FILES YET
	MOVEM B, LOGINI		;WE DO SYSTEM: .CMD FILES NOW - SET FLAG TO 1
	HRROI B, [ASCIZ /SYSTEM:LOGIN.CMD/]
	SKIPE BATCHF		;UNDER BATCH?
	HRROI B,[ASCIZ /SYSTEM:BATCH.CMD/]
	CALL TAKSYS		;SET UP FOR APPROPRIATE SYSTEM: FILE
	CAIA			;PROBABLY NO SUCH FILE
	JRST CMDIN4
TKULOG:	SETZM LOGINI		;CLEAR FLAG
	HRROI B,[ASCIZ "LOGIN.CMD"]
	SKIPE BATCHF		;UNDER BATCH?
	HRROI B,[ASCIZ "BATCH.CMD"] ;YES - USER OTHER FILE
	CALL TAKEIN		;NO, SET UP EXEC INPUT
	CAIA			;DON'T RESET ANYTHING IF NOTHING GOT TAKEN
	JRST CMDIN4		;RESET ALL COMMAND INFO AFTER TAKEIN ATtach.cmdTEMPT
NL1:	SKIPE CUSRNO		;IF NOT LOGGED IN,
	SKIPGE FILINI		;OR INITIALIZATION DONE,
IFE STANSW,<
	JRST NLGINI		;THEN SKIP FOR NOW - FILINI .LT. 0 MEANS INIT DONE
>;IFE STANSW
IFN STANSW,<
	JRST NL2
>;IFN STANSW
	SKIPE FILINI		;FILINI=0 MEANS WE HAVEN'T TAKEN ANY .CMD FILES
	JRST TKUCMD		;WE'VE TAKEN SYSTEM: .CMD FILES - LOOK FOR USER'S
	MOVEI B,1		;HERE WE DO SYSTEM: .CMD FILES,
	MOVEM B, FILINI		;  SO SET FLAG TO 1
	HRROI B, [ASCIZ/SYSTEM:COMAND.CMD/]
	CALL TAKSYS		;SEE IF SYSTEM:COMAND.CMD EXISTS
	CAIA			;PROBABLY NOT
	JRST CMDIN4
TKUCMD: SETOM FILINI		;HERE WE TAKE USER'S CMD FILE, SO SET FLAG TO "INIT DONE"
	HRROI B,[ASCIZ "COMAND.CMD"]
	CALL TAKEIN		;NO, TAKE FILE
	CAIA			;DON'T RESET ANYTHING UNLESS WE'RE REALLY DOING "TAKE" NOW
	JRST CMDIN4		;RESET ALL COMMAND INFO AFTER TAKEIN ATTEMPT

IFN STANSW,<
NL2:	SKIPE CUSRNO		;IF NOT LOGGED IN OR
	SKIPN ATTINI		;HAVE NOT BEEN DETAHCED SINCE LAST COMMAND
	 JRST NLGINI		;THEN SKIP ALL OF THIS
	SETZM ATTINI		;DON"T DO THIS NEXT TIME ROUND
	MOVE A,COJFN		;GET OUR OUTPUT DESIGNATOR
	DVCHR%			;WAIT FOR IT TO BE "REAL"
	 ERJMP .+1
	CALL TTYINI		;MAKE SURE TTY AND NODE NAME ARE SET CORRECTLY
	HRROI B,[ASCIZ "ATTACH.CMD"] ;TAKE COMMANDS FROM THIS FILE
	CALL TAKEIN
	CAIA			;DON'T RESET ALL COMMAND INFO
	JRST CMDIN4		;RESET ALL INFO AFTER ATTEMPT
>;IFN STANSW

NLGINI:	MOVE A,CIJFN		;SEE WHERE INPUT IS COMING FROM
	SKIPE FSTLGN		;FAST LOGIN
	JRST FST2		;YES - NO SYSTEM MAIL CHECK
	CAIN A,.PRIIN		;INPUTTING FROM TERMINAL?
	CALL PNTMES		;YES, SO DONE WITH INITIALIZATION, TYPE SYSTEM MESSAGES
FST2:	;..
IFN STANSW,<
	SKIPN MRPFLG		;IS MRP SET?
	IFSKP.
	  MOVE A,CIJFN		;YES
	  CAIN A,.PRIIN		;IF INPUT NOT FROM PRIMARY
	   JRST LOGOU2		;DO QUICK LOGOUT
	ENDIF.
	SKIPE CUSRNO		;SKIP IF JOB LOGGED IN
	IFSKP.
	  MOVEI A,.FHSLF
	  RPCAP
	  HLLZS C		;CLEAR ANY SPECIAL CAPABILITIES
	  EPCAP
	ENDIF.
>;IFN STANSW

;PREFORM MAIL WATCH FUNCTION, IF REQUESTED BY SET MAIL-WATCH

	CALL IPCOFF		;DON'T ALLOW IPCF INTERRUPTS
	SKIPE IPCRCF		;WERE THERE SOME?
	CALL IPCHEK		;YES, CHECK FOR MESSAGES RECEIVED
	SETZM IPCRCF		;THIS FLAG WILL BE SET NEXT TIME AN INTERRUPT HAPPENS
	CALL IPCON		;...WHICH COULD BE RIGHT NOW OR LATER
	SKIPE FSTLGN		;FAST LOGIN
	JRST FST3		;YES - NO MAIL CHECK
	SETZM TYPING		;NO TYPEOUT IN PROGRESS
	SETZM AUTOF		;NO INTERRUPT IN PROGRESS
	CALL MWATCH		;DO MAIL WATCH
FST3:	;..
	CALL ALRCHK		; AND ALERT CHECK
	CALL RLJFNS		;RELEASE ANY JFNS USED IN PREVIOUS COMMAND
				;NOTE:  RLJFNS CALLED HERE RATHER THAN EARLIER
				;TO FLUSH JFN USED BY MWATCH.  THIS IS NECESSARY
				;SO THAT "COPY TTY:$" DOESN'T TYPE "MAIL"!
	SETOM CLF		;SAY WE'RE AT COMMAND LEVEL
	CALL READY		;INITIALIZE FOR COMND JSYS
CIN42::	MOVEI A,RERET		;REGULAR ERROR RETURN ADDRESS
	MOVEM A,CERET		;SAY WHERE TO GO AFTER PRINTING ERR MSG

;CLEAR SOME FLAGS

	MOVEI Z,0		;CLEAR FLAGS

;BEGIN INPUTTING AND DECODING A COMMAND

CIN0::	CALL COMSET		;SET UP THINGS FOR COMMAND INPUT
	MOVE B,PCLDCO		;[PCL] Get default value for Original flag
				; (0 unless from DOCOMMAND ORIGINAL "...")
	MOVEM B,ORIFLG		;[PCL] Set Original flag (here because after
				; reparse address but before entry from
				; the "Original" command.
IFE CHSTSW,<
CIN1:	
>;IFE CHSTSW
IFN CHSTSW,<
CIN1::	SETZM LINSVD		;Flag line not saved yet (must be after
				; Exec's reparse address)
	SETZM PWDFLG		;Flag no password seen on this line
>;IFN CHSTSW
	SETZM CIPF		;[PCL] No command in progress yet
IFN FTCE,<
	SETZM CEBPTR		;SAY COMMAND CAN BE SAVED (COMMAND EDITOR)
	SETOM CLF		;AND SAY AT COMMAND LEVEL (COMMAND EDITOR)
>;IFN FTCE
IFE STANSW,<
	MOVX B,WHLU+OPRU+ERRU	;PCL
>;IFE STANSW
IFN STANSW,<
	MOVX B,WHLU+OPRU	;NO CTRL-E COMMANDS UNLESS WOPR
>;IFN STANSW
	SKIPE PRVENF		;USER "ENABLE"D?
	CALL PRVCK		;CHECK FOR PRIVILEGED USER
	 JRST CIN9		;NOT PRIVILEGED, SO ^E NO POSSIBILITY
	MOVEI B,CM1DBE		;GET THE PRIVILEGED DESCRIPTOR BLOCKS
	JRST CIN7		;AND GO CHECK FOR PCL COMMANDS

CIN9:	MOVEI B,CM1DB		;GET THE UNPRIVILEGED DESCRIPTOR BLOCKS
	SKIPE CUSRNO		;LOGGED IN?
	JRST CIN7		;YES - GO CHECK PCL
IFN STANSW&LOTSW,<
	SKIPE LOTSQ		;IF THERE IS A QUEUE
	 SKIPA B,[CM1QL]	;GET QUEUE NOT-LOGGED-IN TABLE
>;IFN STANSW&LOTSW
	MOVEI B,CM1XL		;NO - USE NOT-LOGGED-IN DESCRIPTOR BLOCKS
	JRST CIN10		;NO PCL UNTIL LOGGED IN (USES THE WRONG TABLE)

CIN7:	SKIPN PCFLDB		;IS PCL A FACTOR?
	SKIPE PCFLDP
	TRNA			;YES
	JRST CIN10		;NO
	MOVEI C,PCFLDB		;ASSUME USER TABLE
	SKIPN ORIFLG		;[PCL] DOES HE WANT THE ORIGINAL SET?
	SKIPN PCFLDB		;DOES HE HAVE HIS OWN?
	TRNA			;YES, OR NO
	JRST CIN8		;NO AND YES, USE HIS
	SKIPN PCFLDP		;IS THERE A PRESERVED TABLE?
	JRST CIN10		;NO, USE ORIGINAL ONE
	SKIPLE ORIFLG		;[PCL] USE PRESERVED COMMANDS?
	JRST CIN10		;NO, USE ORIGINAL ONE
	MOVEI C,PCFLDP		;USE PRESERVED COMMANDS
CIN8:	HRRZ B,(B)		;STEP PAST THE ORIGINAL TABLE
	HRRM B,(C)		;LINK AFTER PCL TABLE
	MOVEI B,(C)		;USE IT
CIN10:	CALL FLDSKP		;TRY TO READ COMMAND NAME
	 CMERRX <Unrecognized command>
	MOVEM B,COMAND		;SAVE COMMAND INFO
	LOAD D,FKFLAG,+@FRKDEF	;GET DEFAULT FLAGS
	MOVEM D,NAMFLG
	LDB D,[331100,,(C)]	;GOOD PARSE,  SEE WHAT GOT TYPED
	CAIN D,.CMFIL		;FILESPEC?
	JRST [STAT,<AOS STBUF+STA%FL> ;COUNT IMPLICIT RUN COMMANDS
	      JRST CIN3P]	;YES, GO RUN PROGRAM
	CAIN D,.CMTOK		;^E?
	JRST CINE		;YES
IFN NICSW,<			;[NIC1035]
	CAIN D,.CMDIR		;[NIC1035] LAZY CONNECT
	 JRST LAZCON		;[NIC1035] GO DO IT
>;IFN NICSW
IFN STANSW,<
	CAIN D,.CMUSR		;USER NAME?
	 JRST LAZY		;YES, LAZY LOGIN
>;IFN STANSW
	JRST CIN2		;MUST BE COMMAND

;ROUTINE TO SET UP DEFAULTS FOR COMMAND INPUT
;PLEASE BE CAREFUL ABOUT CAUSING JSYS'S TO BE EXECUTED IN THIS ROUTINE,
;SINCE THIS ROUTINE GETS CALLED FOR EVERY COMMAND, AND WE WANT TO
;MINIMIZE NUMBER OF SYSTEM CALLS.  THANKS.

COMSET:	DEXTX <EXE>		;DEFAULT PROGRAM EXTENSION IS "EXE"
	HRROI A,[ASCIZ /SYS/]	;DEFAULT DEVICE FOR PROGRAMS IS SYS:
	MOVEM A,CJFNBK+.GJDEV
	MOVX A,GJ%OLD		;PROGRAM MUST EXIST
	MOVEM A,CJFNBK+.GJGEN
	RET

;PRIVILEGED, AND ^E TYPED

CINE:
IFN NICSW,<			;[NIC1017] HISTORY CODE
	MOVSI A,(<BYTE (7) "/">) ;[NIC1017] GET SPECIAL EDIT CHAR
	HRRZ D,1(C)		;[NIC1017] GET TOKEN PARSED
	CAMN A,0(D)		;[NIC1017] WAS IT SPECIAL EDIT CHAR?
	 JRST .DOHST		;[NIC1017] YES, GO DO HISTORY
>;IFN NICSW
  	MOVEI B,[FLDDB. .CMKEY,,CTBL2]
	CALL FLDSKP
	 CMERRX			;NO SUCH ^E COMMAND
	MOVEM B,COMAND

;HAVE VALID FIRST KEYWORD IN COMMAND
;MAKE PRE-DISPATCH CHECKS

CIN2::	MOVE B,COMAND		;PCL GET WHICH COMMAND WE'RE DOING
	CALL GETKEY
	HLRO A,@COMAND		;GET NAME OF COMMAND IN CASE IT'S A FORK
	MOVEM A,PNAMP		;SAVE IT FOR ROUTINE THAT BUILD RESCAN STRING
	MOVE A,COMAND		;GET WHICH COMMAND WE'RE DOING
	HLRZ B,KEPNMS		;SEE HOW MANY FORKS IN FORK TABLE
	ADDI B,KEPNMS		;GET HIGHEST TABLE ADDRESS POSSIBLE
	CAIL A,KEPNMS+1		;IS OUR COMMAND IN RANGE OF FORK TABLE?
	CAMLE A,B		;LARGE ENOUGH.  IS IT SMALL ENOUGH?
	CAIA			;TOO SMALL OR TOO LARGE.
	JRST [	CALL CIN3D	;GET RESCAN LINE AND CONFIRMATION
		MOVEI A,FRKNMS	;SAVED FORK, FIND WHERE IT IS IN FORK TABLE
IFE STANSW,<
		MOVE B,COMAND	;GET POINTER TO NAME ("FIELD" PUT POINTER IN COMAND)
>;IFE STANSW
IFN STANSW,<
		MOVE B,PNAMP	;GET POINTER TO NAME
>;IFN STANSW
		TBLUK		;GET TABLE ADDRESS
		MOVEM A,PTBLP	;SAVE TABLE ADDRESS
STAT,<		AOS STBUF+STA%FK> ;COUNT NAMED FORK EXECUTIONS
		JRST CINFRK]	;JOIN OTHER CODE
	MOVE P4,P3		;1ST KW'S VALUE WD STAYS IN P4.
	SKIPE CUSRNO		;LOGGED IN?
	JRST CIN2A		;YES - SKIP THIS
	TXNN P4,NOLG		;NO - IS THIS COMMAND ALLOWED?
	ERROR <LOGIN please>	;NO - IT'S AN ERROR
CIN2A:	MOVE B,P3		;FOUND PRIVILEGED COMMAND, MAKE SURE PRIVILEGES
	CALL PRVCK
	 ERROR <Insufficient privileges>
STAT,<	MOVE A,COMAND		;GET WHICH COMMAND WE'RE DOING
	HLRZ B,CTBL1		;COMMANDS IN PRIMARY COMAND TABLE
	ADDI B,CTBL1		;GET HIGHEST TABLE ADDRESS POSSIBLE
	CAIL A,CTBL1+1		;IS OUR COMMAND IN MAIN COMAND TABLE
	CAMLE A,B		;LARGE ENOUGH.  IS IT SMALL ENOUGH?
	AOSA STBUF+STA%NG	;TOO SMALL OR TOO LARGE. COUNT IT AS NO-GOOD
	JRST [SUBI A,CTBL1	;CREATE INDEX
	      AOS STBUF(A)	;COUNT IT
	      JRST .+1]
>;STAT
	CALL (P4)		;DISPATCH WITH PUSHJ,
				;CAN RETURN WITH POPJ
				;OR JRST CMDIN2,3,4.
	JRST CMDIN4		;WHERE MOST COMMANDS SHOULD RETURN.

;RUN PROGRAM ENTRY FOR PRARG.

DOCC2::	PRGSTG			;ALLOCATE STORAGE
	CALL TRYGTJ		;GET JFN ON FILESPEC
	 CMERRX <Can't run program>
	MOVEM A,PJFN		;REMEMBER JFN OF PROGRAM
	JRST RSUBS4		;GO RUN PROGRAM

;FIRST KEYWORD IS NOT A COMMAND NAME,
; SEE IF IT'S A SUBSYSTEM NAME

CIN3P:	CALL SPNAME		;SET UP PROGRAM NAME
	CALL CIN3D		;GET REST OF LINE
	MOVEI A,FRKNMS		;POINT TO TABLE OF KNOWN FORK NAMES
	MOVE B,PNAMP		;GET POINTER TO CURRENT PROGRAM NAME
	TBLUK			;SEE IF NAME IS IN TABLE
	TXNE B,TL%EXM		;EXACT MATCH?
	JRST [	HRRZ A,(A)	;YES, GET ADDRESS OF FORK BLOCK
		LOAD A,FKFLAG,(A) ;GET FLAGS FOR THIS FORK
		MOVEM A,NAMFLG	;REMEMBER THEM
		JRST .+1]
	MOVE A,NAMFLG		;GET FLAGS FOR THIS PROGRAM
	TXNE A,FN%EPH		;RUN THIS AS AN EPHEMERON?
	JRST EPH		;YES
	TXNE A,FN%NEF		;NEVER RUN THIS AS AN EPHEMERON?
	JRST RSUBS4		;YES
	MOVE A,PJFN
	DVCHR			;GET DEVICE CHARACTERISTICS
	TLNE A,177777		;IS IT A DISK?
	 JRST RSUBS4		;NO - GO ON
	MOVE A,PJFN
	MOVE B,[1,,.FBCTL]	;GET FILE FLAGS
	MOVEI C,C		;INTO C
	CALL $GTFDB
	 JRST CERR
	LDB C,[POINTR C,FB%FCF]
IFN NICSW,<			;[NIC1033] ADD AUTOKEEP ATTRIBUTE
	MOVE A,NAMFLG		;[NIC1033] GET FLAGS BACK
	CAIN C,.FBKEP		;[NIC1033] WAS IT AUTOKEEP?
	 TXNE A,FN%NKP		;[NIC1033] WAS SET NO-KEEP SET?
	  CAIA			;[NIC1033]
	   SETOM AUTO		;[NIC1033] THEN REMEMBER IT
>;IFN NICSW
	CAIE C,.FBEPH		;EPHEMERAL?
	 JRST RSUBS4		;NO - GO ON
EPH:	MOVEI Q1,ETTYMD		;SET TTY MODES
	CALL LTTYMD
	MOVE A,PJFN		;PASS ON JFN
	JRST REPH		;GO RUN EPHEMERAL

;SPNAME is used to set up the program name cell.
;
;Accepts:	B/	jfn

SPNAME:	MOVEM B,PJFN		;REMEMBER JFN
	MOVEI A,EXTSIZ		;GET ROOM FOR FILENAME
	CALL GETBUF		;GET BUFFER FOR IT
	HRRO A,A		;MAKE POINTER TO THE SPACE
	MOVEM A,PNAMP		;REMEMBER POINTER TO PROGRAM NAME
	HRLM A,PRGCEL		;SET UP POINTER TO PROG NAME FOR ^T
	MOVE B,PJFN		;GET PROGRAM NAME
	MOVX C,1B8		;WE WANT JUST THE NAME FIELD
	JFNS			;GET FILE NAME
	MOVEI B,PRGCEL
	MOVEM B,COMAND
	RET

;ENTER HERE FROM EDIT/CREATE COMMAND

CIN3::	CALL SPNAME		;SET UP PROGRAM NAME
	MOVEI A,FRKNMS		;POINT TO LIST OF KNOWN FORKS
	MOVE B,PNAMP		;POINT TO NAME OF EDITOR
	TBLUK			;LOOK UP EDITOR IN KNOWN NAMES
	TXNN B,TL%EXM		;IS EDITOR IN LIST OF KNOWN FORKS?
	JRST CINXED		;NO, SO IT WILL BE LOADED AND STARTED FOR SURE
	HRRZ C,(A)		;YES, GET ADDRESS OF FORK BLOCK
	LOAD D,FKHAN,(C)	;GET FORK HANDLE OF EDITOR
	JUMPE D,CINXED		;IF NONE, GO START EDITOR
	MOVX C,FK%RUN		;FORCE EDITOR TO ALWAYS BE "START"ED ON "EDIT"
	ANDCAM C,SLFTAB(D)	;COMMAND, SO FRESH COPY OF EDITED FILE IS GUARANTEED.
CINXED:	MOVEM A,PTBLP		;SAVE TABLE POINTER
	TXNN B,TL%EXM		;EXACT MATCH OF NAME?
	JRST RSUBS4		;NO, GO RUN PROGRAM
CINFRK:	HRRZ B,(A)		;GET ADDRESS OF FORK BLOCK
	LOAD A,FKHAN,(B)	;GET FORK HANDLE
	CAIN A,0		;DOES THIS FORK EXIST?
	JRST RSUBS4		;NO
	MOVE B,PTBLP		;GET TABLE ADDRESS IN CASE FORK IS KEPT
	MOVE A,SLFTAB(A)	;GET FLAGS FOR THIS FORK
	TXNE A,FK%KPT		;IS FORK KEPT ALREADY?
	JRST RSTFK		;YES, SO GO RESTART IT
	JRST RSUBS4

CIN3D:	LINEX <Data line to be sent to program>
	 CMERRX
	MOVE B,CMABP		;GET POINTER TO BEGINNING OF END OF LINE
	ILDB D,B		;GET FIRST CHARACTER OF REST OF LINE
	MOVE A,CSBUFP		;POINTER TO COMMAND LINE
	MOVE B,PNAMP		;GET POINTER TO PROGRAM NAME
	MOVEI C,0		;END ON NULL
	SOUT			;START COMMAND LINE WITH PROGRAM NAME
	MOVEI B,40		;SPACE TO SEPARATE FILENAME FROM REST OF LINE
	CAIE D,0		;IS THERE ANY MORE TO THE LINE?
	 TLOA Z,F3		;YES - LIGHT FLAG
	  TLZA Z,F3		;NO - CLEAR FLAG
	   BOUT			; AND PUT THE SPACE IN
	MOVE B,CMABP		;GET POINTER TO ATOM BUFFER (REST OF LINE)
	SOUT			;COPY REST OF LINE FOR RSCAN
	HRROI B,[BYTE (7)12,0]	;LINEFEED TO END RSCAN BUFFER
	SOUT			;FINISH LINE WITH LF
	CONFIRM			;GET CONFIRMATION AFTER DATA LINE
	MOVE A,CSBUFP		;GET RESCAN POINTER
	CALL BUFFS		;SAVE THE STRING
	MOVEM A,RSPTR		;SET UP FINAL ONE, NOW THAT COMMAND IS CONFIRMED
	RET			;RETURN

RSUBS4:	MOVEI Q1,ETTYMD		;MAKE SURE NORMAL TTY MODE RESTORED
	CALL LTTYMD
	CALL ERESET		;PREPARE TO LOAD AND RUN PGM
IFN STANSW,<
	HRROI A,CBUF		;NO LONGER DONE BY ..STRT, SET POINTER
	SKIPN RSPTR		;IF NOT SET ALREADY
	 MOVEM A,RSPTR		;FOR RSCAN OF COMMAND LINE
>;IFN STANSW
	MOVE A,PJFN		;SAY WHICH PROGRAM TO GET
	SETO C,			;FORCE OVERLAY
	CALL $GET0		;GET PROGRAM
	JRST ..STRT		;START PROGRAM

;EXAMINE (MEMORY LOCATION) N

BLEN==20			;ENOUGH FOR ASCIZ STRINGS

.EXAMI::STKVAR <<FANCBF,BLEN>,<OCTBF,BLEN>>
	NOISE <MEMORY LOCATION>
	SETZ A,			;SAY EXAMINE
	CALL EXDPDF		;SET DEFAULT ADDRESS, IF ANY
	ADDRX <Address to examine>
	 ERROR <Couldn't parse address>
	CONFIRM
	MOVE A,B
	TLNE A,777740		;THIS COMMAND ONLY ALLOWS 32 SECTIONS
	ERROR <Memory address not between 0 and 37,,777777>
	CALL MAPPF		;MAP THAT PAGE & GET ACCESS INFO
	 JRST CJERRE		;FAILED-- TYPE JSYS ERROR
	TXNN B,PA%PEX
	ERROR <No such page>
	TXNN B,PA%RD
	ERROR <Can't read that page>
	MOVE B,FORK		;CURRENT FORK
	SKIPE C,SLFTAB(B)	;EXISTS?
	 JRST [	MOVX D,FK%EDF
		ANDCAM D,SLFTAB(B) ;INDICATE LAST WAS EXAMINE
		MOVEM A,.FKEDL(C) ;SAVE THIS LOC
		JRST .+1]
	MOVE C,A		;FETCH CONTENTS
	ANDI C,777
	MOVE C,PAGEN(C)		;RH
	HRROI D,FANCBF		;FIRST POINT AT FANCY BUFFER
	MOVEM D,COJFN
	ETYPE<%1Y/ %3/>		;CREATE FANCY VERSION
	MOVEI D,.CHNUL		;MAKE SURE NULL AFTER STRING
	IDPB D,COJFN
	HRROI D,OCTBF		;NOW CREATE OCTAL VERSION
	MOVEM D,COJFN
IFN STANSW,<
	HLRZ D,A		;GET SECTION NUMBER
	TXZE A,.LHALF		;WAS THERE ONE?
	 ETYPE <%4O,,>		;YES, TYPE IT OUT
>;IFN STANSW
	ETYPE <%1O/ %3#>
	MOVEI D,.CHNUL
	IDPB D,COJFN		;FINISH WITH NULL
	CALL FIXIO		;REVERT TO STANDARD IO
	UTYPE FANCBF		;FIRST, DISPLAY THE FANCY VERSION
	HRROI B,OCTBF		;COMPARE IT WITH OCTAL VERSION
	HRROI A,FANCBF
	STCMP
	JUMPN A,[HRROI A,OCTBF ;SHOW OCTAL VERSION IF DIFFERENT
		 ETYPE <   (%1M)>
		 JRST .+1]
	ETYPE <%_>		;FINISH LINE
	RET

;DEPOSIT (MEMORY LOCATION) N (CONTENTS) M

.DEPOS::STKVAR <DEADD,DECON>
	NOISE <MEMORY LOCATION>
	SETO A,			;INDICATE DEPOSIT
	CALL EXDPDF		;SET DEFAULT ADDRESS
	ADDRX <Address in which to deposit>
	 ERROR <Couldn't parse address>
	TLNE B,777740		;THIS COMMAND ONLY ALLOWS 32 SECTIONS
	ERROR <Memory address not between 0 and 37,,777777>
	MOVEM B,DEADD		;SAVE ADDRESS
	HRROI A,[ASCIZ /contents/] ;GUIDE WORD
	CALL RINST		;GET INSTRUCTION TO BE DEPOSITED
	MOVEM A,DECON		;SAVE UNEVALUATED DATA FOR DEPOSITING
	CONFIRM
	SKIPG FORK		;FORK EXISTS?
	CALL ECFORK		;NO, CREATE ONE
	MOVE A,FORK		;GET FORK INDEX
	MOVE Q1,SLFTAB(A)	;GET ADDRESS OF FORK DATA
	SKIPG FORK		;FORK EXISTS?
	SETZM .FKPTM+TTWPNM(Q1) ;CLEAR FORK PROGRAM NAME
	MOVE A,DECON		;GET UNEVALUATED CONTENTS
	CALL PINST		;EVALUATE IT, NOW THAT WE HAVE A FORK
	 ERROR <Can't evaluate contents>
	MOVEM A,DECON		;REMEMBER EVALUATED CONTENTS
	MOVE A,DEADD		;GET LOCATION BEING WRITTEN INTO
	CALL MAPPF		;MAP THAT PAGE AND GET ACCESS INFO
	 JRST CJERRE		;FAILED-- TYPE JSYS ERROR
	TXNN B,PA%WT
	JRST [	TXNN B,PA%CPY	;COPY-ON-WRITE BIT
		ERROR <Can't write that page>
		TYPE < [Shared page made private]>
		JRST .+1]
	TXNN B,PA%PEX
	JRST [	TYPE < [New]>	;ADVISORY MESSAGE
		JRST .+1]
	MOVE B,DEADD		;GET LOCATION
	MOVE A,FORK
	SKIPE C,SLFTAB(A)	;FORK EXISTS?
	 JRST [	MOVX D,FK%EDF
		IORM D,SLFTAB(A) ;INDICATE LAST WAS DEPOSIT
		MOVEM B,.FKEDL(C) ;SAVE THIS LOC
		JRST .+1]
	MOVE A,DECON		;GET DATA

;STORE A AT B IN FORK. ASSUME WE STILL HAVE THE PAGE.

	MOVE C,B		;REMEMBER ADDRESS
	ANDI B,777		;MASK OFF PAGE # PART OF ADDRESS
	MOVEM A,PAGEN(B)	;STORE INTO PAGE BUFFER

;EXECUTION OF DEPOSIT COMMAND...
;IF ADDRESS < 20, SET FORK AC'S. NON-AC PAGES HANDLE THEMSELVES.

	TDNE C,[777776,,777760]	;ACS ARE ALSO IN SECTION 1
	JRST CMDIN4
	MOVE A,FORK
	MOVEI B,PAGEN
	SFACS
	 ERJMP CJERRE		;FAILED-- TYPE JSYS ERROR
	JRST CMDIN4

;EXDPDF - SET DEFAULT ADDRESS FOR EXAMINE OR DEPOSIT
;	A/	0 FOR EXAMINE, -1 FOR DEPOSIT

EXDPDF:	STKVAR <EAM>
	SKIPE C,FORK		;FORK HANDLE
	 SKIPN C,SLFTAB(C)	;KNOWN?
	  RET			;NO FORK - DO NOT SET DEFAULT
	SKIPGE B,.FKEDL(C)	;ANY PREVIOUS E/D?
	 RET			;NO - DON'T SET DEFAULT
	XOR C,A			;MASK FLAG
	TXNN C,FK%EDF		;SAME AS LAST?
	 ADDI B,1		;YES - INCR LOC
	MOVEM B,EAM
	MOVEI A,3		;ENOUGH ROOM FOR NUMBER
	CALL GETBUF		;GET BUFFER ON WORD BOUNDARY
	MOVE D,A		;REMEMBER WHERE BUFFER STARTS
	HRLI A,440700		;MAKE BYTE POINTER
	MOVX C,^D8		;GET OLD VALUE
	MOVE B,EAM

;WOULD LIKE TO SET DEFAULT STRING TO M,,N INSTEAD OF LARGE OCTAL NUMBER
;THIS REQUIRES M,,N TO BE AN ATOM FOR SOME TYPE OF COMND JSYS FIELD

REPEAT 0,<
	TLNN B,-1		;ANY SIGNIFICANCE IN LEFT HALF?
	JRST EXDPRH		;NO--JUST DO RIGHT HALF
	PUSH P,B		;SAVE NUMBER FOR RIGHT HALF LATER
	HLRZS B			;SET TO PRINT LEFT HALF NOW
	NOUT			;IN OCTAL
	 JRST [	POP P,(P)	;CAN'T--DON'T DEFAULT
		RET]
	MOVEI B,","		;SEPARATE HALVES WITH ",,"
	IDPB B,A
	IDPB B,A
	POP P,B			;GET BACK NUMBER
EXDPRH:	HRRZS B			;PRINT JUST RIGHT HALF NOW
>				;END OF REPEAT 0

	NOUT			;IN OCTAL
	 RET			;CAN'T-- DON'T DEFAULT
	UDEF @D			;SET DEFAULT TO TEXT NUMBER
	RET			;RETURN FROM EXDPDF

;PCL Original Exec command

.ORIGI::NOISE (EXEC COMMAND)
	SETOM ORIFLG		;[PCL] NEXT COMMAND USES ORIGINAL TABLE
	JRST CIN1		;PARSE AS IF REGULAR COMMAND

;SYSTAT

;BITS IN Q1 USED FOR SYSTAT OUTPUT CONTROL

SYSIND==1

DEFINE SYSBIT(A)
<	IRP A,<
IFE SYSIND,<PRINTX SYSTAT CONTROL BITS EXHAUSTED
>
SY%'A==SYSIND
SYSIND==SYSIND+SYSIND
>>

SYSBIT <IME,ALL,CLS,HED,NHD,TTY,USR,SUB,TIM,CON,LIM,CJB,JOB,NJB,STA,NOP,4NH>

SYSDEF==SY%IME!SY%TTY!SY%USR!SY%SUB!SY%4NH	;DEFAULT LISTING

SYSALL==SY%ALL!SY%CLS!SY%TTY!SY%USR!SY%SUB!SY%TIM!SY%CON!SY%LIM!SY%CJB!SY%STA!SY%4NH ;ALL (EVERYTHING)

;INDICES FOR STACK ARGS

SY$JOB==0	;JOB NUMBER
SY$TTY==1	;LINE NUMBER
SY$DIR==2	;DIRNUM
SY$USR==3	;USER NUMBER
SY$PRG==4	;PROGRAM NAME

JIBLN==.JILNO+1			;SIZE BLOCK NEEDED FOR JOB INFO
SYCLN==10			;SKED% BLOCK SIZE

.SISTA::TRVAR <SYSJFN,JNX,<SYCLB,SYCLN>,<.JIBAS,JIBLN>,<.NTBAS,.NWNU1+1>,SFRAME,<SYSTAK,SYSTAL>,SYSDIR,SYSTNM,SISTAS,SISLDS,SISCDS,SISTAN,<HSTNAM,10>,HSTDEL,HDRPOS>
	SETZM SYSJFN		;NO SPECIAL OUTPUT JFN YET
	SETOM TYPING		;SAY TYPEOUT IN PROGRESS
IFN STANSW,<
	SETZM HDRPOS		;MAKE SURE WE DON'T USE BOGUS VALUE HERE
>;IFN STANSW
	MOVE Q1,[SYSDEF]
	HRLI A,-SYSTAL
	HRRI A,SYSTAK		;MAKE STACK POINTER
	MOVEM A,SFRAME		;SAVE ARG START
	TLZ Z,F3

SYSTK1:	MOVEI B,[
		FLDBK. .CMKEY,,$SESTA,,,DOTBRK,[
		FLDDB. .CMUSR,,CM%DWC,,,[
		FLDDB. .CMDIR,,CM%DWC,,,[	;KEEP AFTER USER NAME TO ALLOW RECOGNITION ON USER NAME
		FLDDB. .CMNUM,CM%SDH,5+5,<Decimal job number>,,[
		FLDDB. .CMCMA,,,,,[
		FLDDB. .CMCFM,,,,,]]]]]]
	CALL FLDSKP		;GET SOME INPUT
	 JRST SYSNX		;NO
	LDB D,[331100,,(C)]	;GET FUNCTION CODE
	CAIN D,.CMKEY		;KEYWORD?
	JRST SYSKEY		;YES
	CAIN D,.CMUSR		;USER NAME?
	JRST SYSTU		;YES
	CAIN D,.CMDIR		;DIRECTORY NAME?
	JRST SYSTD		;YES
	CAIN D,.CMNUM		;DECIMAL JOB NUMBER?
	JRST SYSTJ		;YES
	CAIN D,.CMCMA		;COMMA?
	JRST SYSSUB		;YES, MAYBE SUBCOMMANDS COMING
	CAIN D,.CMCFM		;END OF LINE?
	JRST SYSTS0		;YES GO EXECUTE COMMAND
	CALL SCREWUP		;SHOULD NEVER GET HERE

;HERE FOR "SYS ."

SYSTK.:	MOVEI A,SY$JOB
	CALL SSTACK		;PUT FLAVOR ON STACK
	MOVE A,JOBNO
	CALL SSTACK		;PUT ITEM ON STACK
	TXO Q1,SY%IME		;"SYS NO . ." = "SYS ."
	CALLRET .SYSEL		;EXIT THROUGH CODE THAT SAYS NOT TO PRINT HEADER

;KEYWORD TYPED AFTER SYSTAT

SYSKEY:	CALL GETKEY		;CHANGE TABLE ADDRESS TO DISPATCH DATA
	CALL (P3)
	JRST SYSTK1

;COMMA TYPED..

SYSSUB:	CRRX <Carriage return to enter subcommands, or another SYSTAT argument>
	 JRST SYSTK1		;NO CR AFTER COMMA, NOT TIME FOR SUBCOMMANDS
	JRST SYSUB1		;COMMA CR, SO GO GET SUBCOMMANDS

;HERE ON AN ERROR. "SYS:" IS A SPECIAL CASE BECAUSE IT LOOKS LIKE THE START
;OF A FILESPEC. IF THE SPEC IS ILLEGAL CONTROL GETS TO SYSTAT. BUT THE
;"INVALID SYSTAT ARGUMENT" MESSAGE IS PRETTY HOSTILE, SO THE KLUGE BELOW
;TELLS THE USER IT'S A FILESPEC ERROR, WHICH IT PROBABLY IS.

SYSNX:	MOVE A,CBUF		;GET WHAT WAS TYPED
	TRZ A,377		;KEEP ONLY THE FIRST FOUR CHARACTERS
	CAMN A,[ASCIZ /SYS:/]	;SPECIAL MESSAGE IF IT'S A BOGUS DEVICE NAME
	ERROR <Unrecognized command - Bad filespecs - "SYS:">
	CMERRX <Invalid SYSTAT argument>

SYSUB1:	SUBCOM $SYSTB
SYSTS0:	TXNE Q1,SY%CLS		;USER ASKING FOR CLASS STUFF?
	JRST [	CALL CLSON	;YES, MAKE SURE CLASS SCHEDULING IS ON
		 CAIA		;NO!
		JRST .+1	;YES
		TXNN Q1,SY%ALL	;DON'T COMPLAIN IF HE SAID "ALL"
		ETYPE <%%Class scheduling is off%_>
		TXZ Q1,SY%CLS	;PRETEND HE NEVER ASKED FOR CLASS STUFF
		JRST .+1]
	SKIPN A,SYSJFN		;SPECIAL OUTPUT JFN?
	JRST SYSNFL		;NO!
	LDF B,OF%WR		;WRITE
	CALL $OPEN7		;OPEN, 7 BIT BYTES, MODE 0.
	MOVE A,SYSJFN		;NOW REDIRECT COJFN
	MOVEM A,COJFN		;(MUST WAIT UNTIL AFTER $OPEN7 SINCE $IOCHK WOULD CIRCUMVENT THE OPENF!)
SYSNFL:	TXNN	Q1,SY%JOB!SY%NJB ;IF NEITHER JOB NOR NON-JOB NOR DEBUG
	TXO	Q1,SY%JOB!SY%NJB ;THEN DEFAULT TO JOB AND NON-JOB
	TXNN	Q1,SY%HED!SY%NHD ;IF HEADER NOT DECIDED,
	TXO	Q1,SY%HED	;DEFAULT TO HEADER
	TXNE	Q1,SY%NJB
	CALL SYPART		;TYPE SYSTEM PART
	TXNE	Q1,SY%JOB
	CALL JBPART		;TYPE JOB LINES
	RET

SYPART:	SAVEAC <Q1>		;DON'T CLOBBER Q1 (READT DOES SO)
	PRINT " "
	GTAD
	MOVE B,A
	CAMN B,[-1]
	MOVSI B,1		;DO SAME AS %A IF NO DATE
	MOVE A,COJFN
	MOVX C,OT%DAY!OT%SCL
	ODTIM			;CAN'T USE %D BECAUSE WE WANT DAY OF WEEK
	ETYPE <  Up %K%%_ %I Jobs   Load av >
	HRROI A,-1		;WE WANT LOADS FOR CURRENT JOB'S CLASS
	CALL GLOADS		;GET LOAD AVERAGES
	CAIL A,0		;CLASS SCHEDULING ON?
	ETYPE <(class %1Q) >
	ETYPE <%2Q %3Q %4Q%%_%%_>
IFE STANSW,<
	MOVEI A,.SFOPR		;READ OPR STATUS
	TMON
	CAIN B,0
	ETYPE < No operator in attendance%_%%_>
	SETZ D,
	GTB .DBUGS		;READ DBUGSW
	JUMPE A,SYDBG1		;0=NORMAL, DON'T PRINT
	HRROI B,[ASCIZ/ System is stand-alone/]	;ASSUME THIS
	CAIN A,1		;1=REMEDIAL
	HRROI B,[ASCIZ / System is remedial/]
	ETYPE <%2m%%_%%_>
SYDBG1:	CALL SYSDWN		;PRINT DOWN-TIME INFO
	RET

SYSDWN::MOVEI D,0		;GET ITEM 0 FROM DWNTIM TABLE
	GTB .DWNTI
	JUMPE A,R		;DO NOTHING IF NOT SET
	CAMN A,[-1]		;IS SYSTEM SHUTDOWN
	JRST [	ETYPE < System is shut down>
		JRST SYSDW1]	;YES, TYPE MESSAGE
	ETYPE < System shutdown scheduled for %1D %E>
SYSDW1:	MOVEI D,1		;GET ITEM 1
	GTB .DWNTI
	CAIE A,0
	ETYPE <,%_ Up again at %1D %e>
	ETYPE <%_%%_>
	RET
>;IFE STANSW
IFN STANSW,<
	SETZ D,
	GTB .DBUGS		;READ DBUGSW
	CAIL A,2		;2=STAND-ALONE
	 ETYPE < System is stand-alone%_%%_>
SYDBG1:	CALL DWNPNT		;DOWN-TIME INFO
	TYPE <
>				;NEXT LINE
	RET
>;IFN STANSW


;LOOP TO TYPE TSS JOB #, TTY #, USER  FOR EACH JOB

JBPART:	TLZ Z,F1+F2		;CLEAR LOCAL FLAGS
	MOVSI A,(RC%EMO)	;EXACT MATCH ONLY
	HRROI B,[ASCIZ /OPERATOR/]
	RCUSR			;GET OPERATOR'S USER NUMBER
	TLNE A,(RC%NOM+RC%AMB)	;GOT IT?
	 MOVEI C,-1		;IF NO SUCH, USE -1
	MOVEM C,SYSDIR
	TLZ Z,F3		;NO JOBS PRINTED YET
SYST9A:	SETO D,
	GTB .JOBRT		;GET # POSSIBLE JOBS
	HRLZ D,A		;XWD AOBJN COUNT, JOB #

;TOP OF LOOP

SYST2:	MOVEM D,JNX		;REMEMBER JOB NUMBER COUNTER
	SETZM SISTAS		;CLEAR USER NAME STRING POINTER
	SETZM SISLDS
	SETZM SISCDS
	HRRZ A,JNX
	HRLI B,-JIBLN		;LENGTH OF JOB INFO BLOCK
	HRRI B,.JIBAS		;STORE INTO CORRECT BLOCK
	MOVEI C,0		;START WITH FIRST ENTRY
	GETJI
	 CALL [	CAIE A,GTJIX4	;NO SUCH JOB?
		JRST JERR	;NO, COMPLAIN
		POP P,(P)
		JRST SYST9]	;YES, SKIP IT
	HRROI B,.JILNO+.JIBAS	;PREPARE TO GET LOGGED-IN DIR NUMBER
	MOVEI C,.JILNO
	GETJI			;TRY TO GET LOGGED-IN DIR NUMBER
	 JFCL			;FAILED, BUT SEE "MOVE C," ABOVE
	SKIPGE .JIRT+.JIBAS	;NEG RUN TIME MEANS NO JOB
	JRST SYST9		;SO SKIP IT
	TXNN Q1,SY%IME		;DID USER SAY "NO ."?
	JRST [	HRRZ B,JNX	;YES, SEE WHICH JOB WE'RE ON
		CAME B,JOBNO	;IS IT OURSELF?
		JRST .+1	;NO, SO DISPLAY IT
		JRST SYST9]	;YES, SO SKIP IT

	MOVE A,.JIJNO+.JIBAS	;GET JOB NUMBER
	MOVEM A,.SAJOB+SYCLB	;TELL MONITOR WHICH JOB TO INVESTIGATE
	MOVEI A,SYCLN		;SET UP BLOCK SIZE FOR SKED%
	MOVEM A,.SACNT+SYCLB
	MOVEI A,.SKRJP		;SAY READ JOB PARAMETERS
	MOVEI B,SYCLB		;POINT TO BLOCK
	TXNE Q1,SY%CLS		;DON'T BOTHER DOING SKED% IF CLASS NOT WANTED
	SKED%			;READ THE INFO
	 ERJMP [CALL DGETER	;FAILED, SEE WHY
		CAIE A,ARGX15	;"JOB IS NOT LOGGED IN"?
		CALL JERR	;NO, UNEXPECTED ERROR
		JRST SYST9]	;YES, JOB LOGGED OUT, SKIP IT

;CHECK FOR PASS 1 OR 2

	SETO B,			;ASSUME NOT OPR
	MOVE A,SYSDIR
	CAMN A,.JIUNO+.JIBAS
	SETZ B,			;FLAG OPR
	TLNE Z,F2
	SETCA B,		;REVERSE TEST FOR PASS 2
	JUMPE B,SYST9		;PASS 1, SKIP OPR. PASS 2, DO OPR

;CHECK IF REQUESTED JOB

	HRLI A,-SYSTAL
	HRRI A,SYSTAK
	CAMN A,SFRAME		;ANY ARGS?
	JRST SYST2Y
SYST2A:	MOVE B,(A)		;GET INDEX INTO FUNCTION TABLE
	MOVE C,1(A)		;GET ARG
	XCT [	JRST SYST2D
		CAMN C,.JITNO+.JIBAS
		JRST SYST2C
		JRST SYS2U
		JRST SYSPRG](B)	;NOTE INDEX ***
	JRST SYST2Z		;MATCH
SYST2B:	ADD A,[2,,2]
	CAME A,SFRAME
	JRST SYST2A
	JRST SYST9		;NO MATCH

SYSPRG:	CAMN C,.JIPNM+.JIBAS	;CORRECT PROGRAM NAME?
	JRST SYST2Z		;YES
	JRST SYST2B

SYS2U:	MOVEI B,SISTAS		;CHECK AGAINST CURRENT USER NUMBER/STRING
	MOVE D,.JIUNO+.JIBAS
	CALL SYSDUC
	 JRST SYST2Z		;SUCCESS, TYPE OUT JOB
	 JRST SYST2B		;FAILURE, NO MATCH

SYST2C:	MOVEI B,SISLDS		;CHECK AGAINST LOGGED-IN DIR
	MOVE D,.JILNO+.JIBAS
	CALL SYSDUC
	 JRST SYST2Z		;SUCCESS, GO TYPE JOB
	TXNN	Q1,SY%CON	;SHOWING CONNECTED DIR'S?
	JRST SYST2B
	MOVEI B,SISCDS		;CHECK AGAINST CONNECTED DIR
	MOVE D,.JIDNO+.JIBAS
	CALL SYSDUC
	 JRST SYST2Z		;SUCCESS
	 JRST SYST2B		;FAILURE

;ROUTINE TO CHECK CURRENT DIRECTORY/USER AGAINST DIRECTORY/USER ARGUMENT
;ACCEPTS:	B/	ADDRESS OF POINTER TO CURRENT DIRECTORY/USER STRING
;		C/	DIRECTORY/USER ARGUMENT (NUMBER OR 'WILD' BYTE POINTER)
;		D/	CURRENT DIRECTORY/USER NUMBER
;RETURNS:	+1 SUCCESS, CURRENT NUMBER/STRING MATCHES ARG
;		+2 FAILURE, CURRENT NUMBER/STRING DOES NOT MATCH ARG

SYSDUC:	STKVAR <ASAV,DUSTRP,DUCARG>
	CAMN C,D		;DOES IT MATCH ARG?
	 RET			;YES, GIVE SUCCESS RETURN
	HRRZM B,DUSTRP		;SAVE AC B
	LOAD B,NMFLG,C		;CHECK TO SEE IF ARG IS DIR/USER NUMBER
	CAIN B,NUMVAL		;IS IT?
	 RETSKP			;YES, GIVE FAILURE RETURN
	MOVEM A,ASAV		;SAVE AC'S A AND C
	MOVEM C,DUCARG
	SKIPE A,@DUSTRP		;HAVE WE GOTTEN DIR/USER STRING BEFORE?
	JRST SYSDU1		;YES, SKIP GETTING IT
	HRROI A,ATMBUF		;PUT IT IN ATOM BUFFER TEMPORARILY
	MOVE B,D
	DIRST
	ERJMP	[MOVE A,ASAV
		 MOVE C,DUCARG
		 RETSKP]	;IF ERROR, IT'S NO MATCH
	HRROI A,ATMBUF		;COPY STRING TO FREE AREA
	CALL BUFFS
	MOVEM A,@DUSTRP		;SAVE THE DIR/USER STRING POINTER
SYSDU1:	MOVE C,A		;PUT CUR DIR/USER STRING PTR IN N-W AC
	SETZ A,			;NO FLAGS TO WILD%
	MOVE B,DUCARG		;PUT DIR/USER ARG STRING PTR IN WILD AC
	WILD%			;CHECK CURRENT DIR/USER STRING
	 ERJMP JERR		;THIS IS A WILD ERORR!?
	TXNN A,WL%NOM		;WAS THERE A MATCH?
	TDZA B,B		;YES
	SETO B,			;NO
	MOVE A,ASAV		;RESTORE REGISTERS A AND C
	MOVE C,DUCARG
	JUMPN B,RSKP		;IF NO MATCH, SKIP RETURN
	RET			;IF MATCH, REGULAR RETURN

SYST2D:	HRRZ D,JNX
	CAMN C,D		;CURRENT JOB?
	JRST SYST2Z
	TXNN	Q1,SY%CJB
	JRST SYST2B
	CAMN C,.JICPJ+.JIBAS
	JRST SYST2Z
	JRST SYST2B

SYST2Y:	MOVE D,JNX
	TRNE D,-1
	JRST SYST2Z
	SKIPGE .JITNO+.JIBAS
	JRST SYST9		;SKIP JOB 0 FOR NORMAL PRINT IF DETACHED

;HAVE A REAL JOB #. PRINT IT.

SYST2Z:	TLOE Z,F1		;TYPE HEADER FIRST TIME.
	JRST SYSTS2
	TXNN	Q1,SY%HED
	JRST SYSTS2
	ETYPE < Job >
	TXNE	Q1,SY%CJB
	ETYPE < CJB>
	TXNE	Q1,SY%TTY
	ETYPE < Line>
	TXNE	Q1,SY%SUB
	ETYPE < Program>
	TXNE	Q1,SY%STA
	ETYPE < State>
	TXNE	Q1,SY%TIM
	ETYPE <  Time   >
	TXNE Q1,SY%CLS		;CLASS INFO REQUESTED?
	ETYPE < Cls   Shr   Use>
	TXNE	Q1,SY%LIM
	ETYPE <  Limit  >
	TXNN	Q1,SY%USR
	JRST SYST2U
	ETYPE <  User>
	TXNE	Q1,SY%CON
	UETYPE [ASCIZ /, <Directory>/]
	TXNN Q1,SY%4NH		;DOING FOREIGN HOST?
	JRST SYST2U		;NO, SKIP THIS THEN
	TXNN Q1,SY%CON		;IF PREVIOUS HEADING NOT TYPED,
	ETYPE <            >	;COLUMNIZE THIS BETTER
	MOVE A,COJFN		;GET CURRENT COLUMN POSITION
	RFPOS			; ..
	 ERJMP [SETZ B,		;IF NOT TERMINAL, ASSUME 0
		JRST .+2]	; *** NOTE .+2, NOT .+1 ***
	ADDI B,2		;ACCOUNT FOR LEADING SPACES IN NEXT ETYPE
	HRRZM B,HDRPOS		;SAVE FOR LATER
	ETYPE <  Origin>
SYST2U:	ETYPE <%_>
	TLZ Z,F3		;NO NEW LINE AFTER TITLE
SYSTS2:	TLZE Z,F3		;SEPARATE USER FROM OPR?
	ETYPE <%_>
	HRRZ A,JNX
	CALL NUM4		;PRINT 4-COLUMN NUMBER
	GJINF
	MOVEI B," "		;ASSUME NOT CURRENT JOB
	HRRZ D,JNX
	CAMN C,D		;OUR JOB?
	MOVEI B,"*"		;YES, INDICATE
	PRINT @B		;SPACE OR STAR

;CONTROLLING JOB OF PTY

	TXNN	Q1,SY%CJB
	JRST SYST4A
	SKIPGE A,.JICPJ+.JIBAS
	JRST [	TYPE <    >
		JRST SYST4A]
	MOVX B,NO%LFL!FLD(4,NO%COL)!<5+5> ;LEADING FILLER, 4 COLUMNS, DECIMAL
	CALL SYNUM
SYST4A:

;"DET" OR "TTY N"

	TXNN	Q1,SY%TTY
	JRST SYST4
	SKIPGE A,.JITNO+.JIBAS
	JRST [	TYPE <  DET>
		JRST SYST4]
	MOVX B,NO%LFL!FLD(5,NO%COL)!8	;LEADING FILLER, 5 COLUMNS, OCTAL
	CALL SYNUM

SYST4:

;SYSTAT...
;SUBSYSTEM NAME

	TXNN	Q1,SY%SUB
	JRST SYST8
	SKIPN A,.JIPNM+.JIBAS
	MOVE A,.JISNM+.JIBAS	;IF NO PROGRAM NAME, USE SUBSYSTEM NAME
	ETYPE <  %1'>
	MOVEI B,0
	JUMPE A,[TYPE <      >	;SIX SPACES IF 0 NAME
		 JRST SYST8]
SYSSU:	LSHC A,-6		;PAD TO EXACTLY SIX CHARACTERS
	JUMPN B,SYST8		;LEAVE LOOP IF ENOUGH SPACES
	PRINT " "		;PRINT A SPACE
	JRST SYSSU
SYST8:	TXNN	Q1,SY%STA
	JRST SYST8A
	SKIPGE D,.JITNO+.JIBAS
	JRST SYST8B		;IF NO TERMINAL, SAY RUNNING
	GTB .TTYJO		;GET TERMINAL WORD
	HRRZ A,A
	CAIE A,-1		;OTHER THAN -1 MEANS FORK WAITING
	SKIPA B,[-1,,[ASCIZ/  TI  /]]
SYST8B:	HRROI B,[ASCIZ/  RUN /]
	ETYPE <%2M>
SYST8A:	TXNN	Q1,SY%TIM
	JRST SYSTS3
	MOVE A,.JIRT+.JIBAS
	ETYPE <  %1B>

SYSTS3:	TXNN Q1,SY%CLS		;PRINT CLASS STUFF?
	JRST SYSECL		;NO

;CLASS SCHEDULER INFO

	MOVE A,.SAJCL+SYCLB	;GET CLASS
	CALL NUM4		;PRINT AS FOUR COLUMNS
	DMOVE A,.SAJSH+SYCLB	;GET SHARE AND UTILIZATION
	ETYPE <%1=%%2=>
SYSECL:	TXNN	Q1,SY%LIM
	JRST SYSTS4

;LIMIT

	ETYPE <  >
	SKIPG A,.JIRTL+.JIBAS
	JRST [	ETYPE <       >
		JRST SYSTS4]
	ETYPE <%1B>

;USER NAME OR "?" IF CONVERSION FAILS.

SYSTS4:	TXNN	Q1,SY%USR
	JRST SYSTS5
	ETYPE <  >
	SKIPE B,SISTAS		;HAVE WE GOT USER STRING ALREADY?
	 JRST	[MOVE A,COJFN
		 SETZ C,
		 SOUT
		 JRST SYSTS7]	;YES, TYPE IT OUT
	SKIPN B,.JIUNO+.JIBAS
	JRST [	ETYPE <Not logged in>
		JRST SYSTS5]
	ETYPE <%2R>
SYSTS7:	TXNN Q1,SY%CON
	JRST SYSTS5
	MOVE B,.JIDNO+.JIBAS
	CAMN B,.JILNO+.JIBAS
	JRST SYSTS5
	ETYPE <, >
	SKIPE B,SISCDS		;DO WE HAVE STRING ALREADY?
	 JRST	[MOVE A,COJFN
		 SETZ C,
		 SOUT
		 JRST SYSTS5]	;YES, TYPE IT OUT
	MOVE B,.JIDNO+.JIBAS
	ETYPE <%2R>
SYSTS5:	TXNN Q1,SY%4NH		;DOING FOREIGN HOST NAME?
	JRST SYSTS6		;NO, SKIP THIS STUFF THEN
IFDEF NTINF%,<
	MOVEI A,.NTBAS		;GET ADR OF NTINF ARG BLOCK
	MOVEI B,.NWNU1+1	;LENGTH OF ARG BLOCK
	MOVEM B,.NWABC(A)
	MOVEI B,.NWRRH		;RETURN REMOTE HOST NAME FUNCTION CODE
	MOVEM B,.NWFNC(A)
	MOVE B,.JITNO+.JIBAS	;CONTROLLING TTY NUMBER OF JOB
	JUMPL B,SYSTS6		;HANDLE DETACHED LINES
	TRO B,.TTDES		;MAKE THE LINE NUMBER A LINE DESIGNATOR
	MOVEM B,.NWLIN(A)	;SAVE IT
	HRROI B,HSTNAM		;POINTER TO SAVE HOST NAME
	MOVEM B,.NWNNP(A)
	NTINF%			;GET NETWORK INFO ON THIS TERMINAL
	 ERJMP SYSTS6		;IGNORE THE ERROR
	MOVEI A,.NTBAS		;GET POINTER TO ARG BLOCK AGAIN
	MOVE B,.NWTTF(A)	;GET FLAGS WORD
	LDB C,[POINT 9,B,17]    ;GET NETWORK TYPE
	CAIN C,NW%NNT		;NON-NETWORK TERMINAL ?
	JRST SYSTS6		;YES
	CAIE C,NW%TCP		;TCP ?
	IFSKP.
	 MOVE D,TCPDEL		;SET UP HOST PREFIX AND SUFFIX
	 MOVEM D,HSTDEL
	 MOVEI C,.NWNNU(A)	;YES - GET ADDRESS OF NODE NUMBER
	 CALL TCPHST		;GO TYPE IT
	  JRST SYSTS6		;PROBLEM
	 JRST SYST5A		;FINISH UP
	ENDIF.
	CAIE C,NW%DNA		;DECNET ?
	IFSKP.
	 HRRZ C,B		;GET LINE TYPE
	 MOVE D,NRTDEL          ;SET UP HOST PREFIX AND SUFFIX
	 CAIN C,NW%CH		;CTERM ?
	 MOVE D,CTMDEL          ;SET UP HOST PREFIX AND SUFFIX
	 MOVEM D,HSTDEL
	 MOVEI C,.NWNNU(A)	;YES - GET ADDRESS OF NODE NUMBER
	 CALL DNAHST		;GO TYPE IT
	  JRST SYSTS6		;PROBLEM
	 JRST SYST5A		;FINISH UP
	ENDIF.
	CAIE C,NW%LAT		;LAT ?
	IFSKP.
	 MOVE D,LATDEL          ;SET UP HOST PREFIX AND SUFFIX
	 MOVEM D,HSTDEL
	 MOVEI C,.NWNNU(A)	;GET ADDRESS OF NODE NUMBER WORDS
	 CALL LATHST		;GO TYPE THEM
	  JRST SYSTS6		;PROBLEM
	 JRST SYST5A
	ENDIF.
IFN STANSW,<
IFN PUPSW,<
	CAIE C,NW%PN		;PUP ?
	IFSKP.
	 MOVE D,PUPDEL		;SET UP HOST PREFIX AND SUFFIX
	 MOVEM D,HSTDEL
	 MOVEI C,.NWNNU(A)	;GET ADDRESS OF NODE NUMBER WORDS
	 CALL PUPHST
	  JRST SYSTS6		;SOME PROBLEM
	 JRST SYST5A
	ENDIF.
>;IFN PUPSW
>;IFN STANSW
	JRST SYSTS6		;UNKNOWN NETWORK TYPE
>;IFDEF NTINF%
IFNDEF NTINF%,<			;PROBABLY A 6.0 MONITOR
IFN PUPSW,<
	CALL CHKPNV		;IS THIS LINE A PUP NVT?
	 JRST SYST5A		;YES, PRINT ITS FOREIGN HOST
>;IFN PUPSW
	SEARCH ANAUNV		;GET SYMBOLS FOR BBN INTERFACE (STAT% JSYS)

	MOVX A,TCP%NT		;GET TVT FUNCTION
	STAT%
	IFNJE.
	  HRRZ A,B		;GET FIRST TVT
	  CAMLE A,.JITNO+.JIBAS	;IS MINIMUM TVT .LE. CTRLING TTY?
	  IFSKP.
	    HLRO C,B		;YES, GET -NUMBER OF TVTS
	    SUB A,C		;COMPUTE 1+LAST TVT NUMBER
	    CAMG A,.JITNO+.JIBAS ;IS 1+MAXIMUM TVT .GT. CTRLING TTY??
	    IFSKP.
	      MOVX A,TCP%TV	;ARGUMENT IS TVT
	      HRR A,.JITNO+.JIBAS ;OUR TVT NUMBER
	      HRROI B,7		;WANT HOST NUMBER (SHOULD BE A SYMBOLIC NAME)
	      HRROI C,D		;PUT IT IN D (I DON'T TRUST STAT% TO USE C)
	      STAT%
	       ERJMP SYSTS6
	      MOVE C,D		;GET HOST IN APPROPRIATE PLACE FOR GTHST
	      JRST SYST.0
	    ENDIF.
	  ENDIF.
	ENDIF.
SYST.0:	MOVX A,.GTHNS		;GET HOST NAME FOR THIS NUMBER
	HRROI B,HSTNAM		;ONTO THE STACK
	GTHST			; ..
	IFJER.
	  MOVE D,C		;COPY HOST NUMBER TO D
	  HRROI A,HSTNAM	;OUTPUT IT HERE
	  MOVX C,^D10		;IN DECIMAL
	  LDB B,[POINT 8,D,11]	;1ST BYTE
	  NOUT%
	   NOP
	  MOVEI B,"."
	  IDPB B,A
	  LDB B,[POINT 8,D,19]	;2ND BYTE
	  NOUT%
	   NOP
	  MOVEI B,"."
	  IDPB B,A
	  LDB B,[POINT 8,D,27]	;3RD BYTE
	  NOUT%
	   NOP
	  MOVEI B,"."
	  IDPB B,A
	  LDB B,[POINT 8,D,35]	;4TH BYTE
	  NOUT%
	   NOP
	ENDIF.
>;IFNDEF NTINF%
SYST5A:	MOVE A,COJFN		;GET CURRENT HORIZONTAL POSITION
	RFPOS			; ..
	 ERJMP [MOVEI B,7777	;NOT TERMINAL, ASSUME COLUMN OVERFLOW
		JRST .+1]
	HRRZS B			;DROP LINE NUMBER
	MOVE A,HDRPOS		;GET DESIRED COLUMN NUMBER OF HOST COLUMN
	SUB A,B			;COMPUTE DISTANCE THERE
	SKIPG A			;RANGE CHECK...IS IT POSITIVE?
	 MOVEI A,2		;NO SO DEFAULT IT TO TWO SPACES
	CAIGE A,2		;FORCE AT LEAST TWO SPACES
	MOVEI A,2		; ..
	CAIL A,^D100		;UNREASONABLY LARGE NUMBER?
	MOVEI A,2		;YES, USE 2 INSTEAD
	PRINT " "		;TYPE ENOUGH SPACES TO LINE UP
	SOJG A,.-1		; ..
	HLRO A,HSTDEL		;GET HOST NAME PREFIX
	ETYPE <%1\>
	UETYPE HSTNAM		;TYPE THE NAME
	HRRO A,HSTDEL		;GET HOST NAME PREFIX
	ETYPE <%1\>
	JRST SYSTS6


IFE STANSW,<
TCPDEL:	 [ASCIZ//],,[ASCIZ/(TCP)/]	;SET UP HOST PREFIX AND SUFFIX
>;IFE STANSW
IFN STANSW,<
TCPDEL:	[ASCIZ//],,[ASCIZ//]		;SET UP HOST PREFIX AND SUFFIX
>;IFN STANSW	
NRTDEL:	 [ASCIZ//],,[ASCIZ/(NRT)/]	;SET UP HOST PREFIX AND SUFFIX
CTMDEL:	 [ASCIZ//],,[ASCIZ/(CTM)/]	;SET UP HOST PREFIX AND SUFFIX
LATDEL:	 [ASCIZ//],,[ASCIZ/(LAT)/]	;SET UP HOST PREFIX AND SUFFIX
IFN STANSW,<
IFN PUPSW,<
PUPDEL:	[ASCIZ//],,[ASCIZ//]		;SET UP HOST PREFIX AND SUFFIX
>;IFN PUPSW
>;IFN STANSW

DNAHST:	MOVE D,(C)		;GET DECNET NODE NUMBER
	TXNN B,NW%NNN		;HAVE A NODE NAME ?
	RETSKP			;YES
	HRROI A,HSTNAM		;OUTPUT TO HSTNAM STRING
	MOVEI C,^D10		;OUTPUT RADIX IS DECIMAL
	LDB B,[POINT 6,D,25]	;GET AREA OF DECNET NODE NUMBER
	JUMPE B,DNAHS1		;ZERO ? DON'T TYPE AREA
	NOUT			;NO - THEN OUTPUT IT
	 ERJMP R
	MOVEI B,"."		;PRINT A DOT
	BOUT
DNAHS1:	LDB B,[POINT 10,D,35]	;GET HOST NUMBER PART
	NOUT
	 ERJMP R
	RETSKP


LATHST:	SAVEAC <Z>
	TXNN B,NW%NNN		;HAVE A NODE NAME ?
	RETSKP			;YES
	MOVEI Z,6		;ETHERNET ADDRESSES ARE 6 BYTES LONG
	MOVE D,C		;GET ADDRESS OF ETHERNET ADDRESS
	TXO D,<POINT 8,0>	;FORM BYTE POINTER TO IT
	HRROI A,HSTNAM		;OUTPUT TO HSTNAM STRING
	MOVX C,<NO%LFL!NO%ZRO!<2B17>!^D16> ;HEX OUTPUT, 2 DIGITS, ZERO FILL
	JRST LATHS2		;DON'T PRINT A SEPERATOR
LATHS1:	MOVEI B,"-"		;PRINT A SEPERATOR
	BOUT
LATHS2:	ILDB B,D		;GET A BYTE
	NOUT			;OUTPUT IT
	 ERJMP R
	SOJG Z,LATHS1		;LOOP TILL DONE
	RETSKP


TCPHST:	
IFE STANSW,<
	TXNN B,NW%NNN		;HAVE A NODE NAME ?
	RETSKP			;YES
>;IFE STANSW
IFN STANSW,<
	STKVAR <HOSTNO>
	MOVE C,(C)		;GET HOST NUMBER
	MOVEM C,HOSTNO		;SAVE IT SOMEWHERE SAFE
	HRROI B,HSTNAM		;POINT AT STRING BUFFER
	HRLI B,(<POINT 7,0>)
	MOVEI A,"("
	IDPB A,B		;FORM (
	MOVEI A,.GTHNS		;CONVERT NUMBER TO STRING
	GTHST%
	IFNJE.
	 MOVEI A,")"		;FORM (FOO.ARPA)
	 IDPB A,B
	 MOVEI A,0
	 IDPB A,B		;NULL-TERMINATE
	 RETSKP
	ENDIF.
>;IFN STANSW
	HRROI A,HSTNAM		;TYPE HOST NUMBER LIKE #.#.#.#
IFE STANSW,<
	MOVE D,(C)		;GET HOST NUMBER
>;IFE STANSW
IFN STANSW,<
	HRLI A,(<POINT 7,0>)	
	MOVEI C,"("		;FORM (
	IDPB C,A
	MOVE D,HOSTNO
>;IFN STANSW
	MOVEI C,^D10
	LDB B,[POINT 8,D,11]	;GET A BYTE
	NOUT			;OUTPUT IT
	  ERJMP R
	MOVEI B,"."
	BOUT			;TYPE A DOT
	LDB B,[POINT 8,D,19]	;GET A BYTE
	NOUT			;OUTPUT IT IN DECIMAL
	  ERJMP R
	MOVEI B,"."
	BOUT			;TYPE A DOT
	LDB B,[POINT 8,D,27]	;GET A BYTE
	NOUT			;OUTPUT IT IN DECIMAL
	  ERJMP R
	MOVEI B,"."
	BOUT			;TYPE A DOT
	LDB B,[POINT 8,D,35]	;GET A BYTE
	NOUT			;OUTPUT IT IN DECIMAL
	  ERJMP R
IFN STANSW,<
	MOVEI B,")"
	IDPB B,A		;FORM (36.48.0.1)
	MOVEI B,0
	IDPB B,A		;NULL-TERMINATE
>;IFN STANSW
	RETSKP
IFN STANSW,<
	ENDSV.
>;IFN STANSW


IFN STANSW,<
IFN PUPSW,<
PUPHST:	MOVE C,(C)		;GET ADDRESS
	SETZM D			;NO PORT INFO
	HRROI A,HSTNAM		;INTO THIS STRING BUFFER
	HRLI A,(<POINT 7,0>)
	MOVEI B,"{"		;FORM {
	IDPB B,A
	MOVE B,[PN%OCT!PN%FLD!C] ;USE DEFAULTS, NAMES, NUMBERS IF UNKNOWN
	PUPNM%
	 ERJMP R
	MOVEI B,"}"		;FORM {Tip-AELa}
	IDPB B,A
	MOVEI B,0
	IDPB B,A		;NULL-TERMINATE
	RETSKP
>;IFN PUPSW
>;IFN STANSW

SYSTS6:	ETYPE <%_>
SYST9:	SKIPE A,SISTAS		;RETURN USER STRING IF USED
	CALL STREM
	SKIPE A,SISLDS		;RETURN LOGGED-IN DIR STRING IF USED
	CALL STREM
	SKIPE A,SISCDS		;RETURN CONNECTED DIR STRING IF USED
	CALL STREM
	MOVE D,JNX
	AOBJN D,SYST2
	TXNE Q1,SY%NOP
	JRST RLJFNS		;QUIT NOW IF NO OPERATOR JOBS
	TLO Z,F3		;FLAG CRLF SECOND TIME THROUGH
	TLON Z,F2		;SECOND PASS DONE?
	JRST SYST9A		;NO, DO IT (PRINT ONLY OPR JOBS)
	JRST RLJFNS

SYSTD:	MOVEM B,SISTAN		;SAVE DIR NUMBER
	CALL BUFFF		;GET THE DIR NAME STRING
	MOVEM A,SISTAS		;SAVE STRING POINTER
	MOVEI A,SY$DIR
	CALL SSTACK		;ANNOUNCE DIR NUMBER OR STRING COMING UP
	MOVE A,SISTAN		;STEP THE NUMBER
	MOVE B,SISTAS
	CALL STPDIR
	 JRST	[MOVE A,SISTAN
		 JRST SYSTD1]	;NO MORE, SAVE DIR NUMBER
	MOVEI A,[GJ%IFG+GJ%OFG
		.NULIO,,.NULIO
		0
		0
		POINT 7,[ASCIZ/*/]
		POINT 7,[ASCIZ/*/]
		0
		0]		;GET JFN ON WILD DIRECTORY STRING
	HRROI B,ATMBUF
	GTJFN
	 ERJMP JERR		;WILD ERROR!?
	MOVE B,A		;SET UP FOR JFNS
	HRROI A,ATMBUF
	MOVX C,1B2+1B5+JS%PAF
	JFNS
	MOVE A,B		;RELEASE THE JFN
	RLJFN
	 ERJMP JERR		;DITTO
	CALL BUFFF		;STORE STRING IN TEMPORARY FREE AREA
SYSTD1:	CALL SSTACK
	JRST SYST1J

SYSTU:	MOVEM B,SISTAN		;SAVE THE USER NUMBER
	CALL BUFFF		;GET THE ATOM BUFFER
	MOVEM A,SISTAS		;SAVE STRING POINTER TO USER NAME
	MOVEI A,SY$USR		;ANNOUNCE THAT USER NAME OR STR COMING UP
	CALL SSTACK
	MOVE A,SISTAN		;NOW STEP THE USER
	MOVE B,SISTAS		;IF NEEDED
	CALL STPUSR
	 SKIPA A,SISTAN		;NO MORE, SAVE USER NUMBER
	MOVE A,SISTAS		;IT'S WILD, SAVE STRING POINTER
	CALL SSTACK

SYST1J:	CALL .SYSEL
	JRST SYSTK1

SYSTJ:	PUSH P,B		;SAVE THE JOB NUMBER
	MOVEI A,SY$JOB		;FLAVOR IS "JOB NUMBER"
	CALL SSTACK
	POP P,A			;GET THE JOB NUMBER
	CALL SSTACK
	JRST SYST1J

DEFINE TB(TEXT,FLAGS,BIT)<
	T <TEXT>,FLAGS+,<[TXO Q1,SY%'BIT
			  RET]>
>
;THIS IS THE KEYWORD TABLE.  SEE $SYSTB FOR THE SUBCOMMAND TABLE.

$SESTA:	TABLE
	T .,,SYSTK.
	T ALL,,.SYSAL
	TB CLASS,,CLS
	TB CONTROLLING,,CJB
	TB DIRECTORY,,CON
	IT FOREIGN-HOST,,F4NH
	TB HEADER,,HED
	TB LIMIT,,LIM
	T LINE,,.SYSTT
	T LPT,,.$LPT
	T NO,,.SYSNO
	T ORIGIN,,F4NH
	T PROGRAM
	TB STATE,,STA
	TB SYSTEM,,NJB
	TB TIME,,TIM
	TB WHAT,,SUB
	TB WHERE,,TTY
	TB WHO,,USR
	TEND

DEFINE TB(TEXT,FLAGS,BIT)<
	T <TEXT>,FLAGS+,<[CONFIRM
			  TXO Q1,SY%'BIT
			  RET]>
>

;This is the subcommand table.  See $SESTA for the keyword table.

$SYSTB:	TABLE
	T ALL,,..SYSA
	TB CLASS,,CLS
	TB CONTROLLING,,CJB
	TB DIRECTORY,,CON
	IT FOREIGN-HOST,,CF4NH
	TB HEADER,,HED
	T JOB,,.SYJOB
	TB LIMIT,,LIM
	T LINE,,..SYST
	T LPT,,..LPT
	T NO,,..SYSN
	T ORIGIN,,CF4NH
	T OUTPUT,,.SYOUT
	T PROGRAM,,.PRCNF
	TB STATE,,STA
	TB SYSTEM,,NJB
	TB TIME,,TIM
	T USER,,.SYUSR
	TB WHAT,,SUB
	TB WHERE,,TTY
	TB WHO,,USR
	TEND

.SYOUT:	SKIPN CUSRNO
	ERROR <LOGIN please>
	NOISE <TO FILE>
	MOVE A,[XWD [ASCIZ /SYSTAT/],[ASCIZ /LST/]] ;DEFAULT NAME & EXT
	CALL COUTFN
	 JRST CERR
	CONFIRM
	MOVEM A,SYSJFN		;CAN'T SET UP COJFN UNTIL SUBCOMMANDS ARE OVER!
	RET

.$LPT:	SKIPN CUSRNO
	ERROR <LOGIN please>
	CALL GETLPT		;GET JFN ON LPT
	MOVEM A,SYSJFN		;REMEMBER TO USE IT FOR OUTPUT
	RET

..LPT:	SKIPN CUSRNO
	ERROR <LOGIN please>
	CALL FINLPT		;FINISH LPT SUBCOMMAND
	MOVEM A,SYSJFN		;REMEMBER LPT
	RET

.SYJOB:	DECX <Decimal job number>
	 CMERRX
	PUSH P,B		;SAVE THE NUMBER
	CONFIRM			;WAIT FOR CONFIRMATION
	MOVEI A,SY$JOB		;FLAVOR
	CALL SSTACK
	POP P,A			;RESTORE THE NUMBER
				;DON'T TRY TO BUM CODE BY STACKING THE
				;FLAVOR BEFORE READING VALUE.  THE
				;TYPIST MIGHT TYPE CONTROL-U, LEAVING
				;THE ARG STACK AMUCK
	CALL SSTACK
	JRST .SYSEL

.SYUSR:	TLZ Z,F1		;ALLOW DEFAULT
	SKIPN CUSRNO		;LOGGED IN?
	TLO Z,F1		;NO, SO DON'T ALLOW DEFAULTING
	CALL USRNMS
	 ERROR <No such user>
	MOVEM B,SISTAS		;SAVE POINTER TO WILD STRING
	MOVEM C,SISTAN		;SAVE USER NUMBER
	CONFIRM
	MOVEI A,SY$USR		;ANNOUNCE FLAVOR IS USER
	CALL SSTACK
	MOVE A,SISTAN		;GET DIRECTORY NUMBER
	MOVE B,SISTAS		;AND POINTER TO STRING
	CALL STPUSR		;STEP TO NEXT USER NUMBER
	 SKIPA A,SISTAN		;NO MORE, SAVE USER NUMBER
	MOVE A,SISTAS		;IT'S WILD, SAVE USER STR POINTER
	CALL SSTACK
	CALLRE .SYSEL		;RETURN VIA .SYSEL

;"SYSTAT PROGRAM FOO" ONLY LISTS JOBS RUNNING PROGRAM FOO

.PROGR:	CALL PROG1		;GET THE ARGS
	CALLRET .SYSEL		;SAY NO HEADING

PROG1:	STKVAR <PRGNAM>
	WORDX <Program name whose users should be displayed>
	 CMERRX <Invalid program name>
	HRROI A,ATMBUF		;POINT AT PROGRAM NAME
	CALL GETSIX		;CHANGE TO SIXBIT
	 ERROR <Illegal character in program name, or name too long>
	MOVEM A,PRGNAM		;REMEMBER WHICH PROGRAM WE'RE LOOKING FOR
	MOVEI A,SY$PRG		;SAY PROGRAM NAME
	CALL SSTACK
	MOVE A,PRGNAM
	CALL SSTACK		;REMEMBER THE PROGRAM NAME
	RET

.PRCNF:	CALL PROG1		;GET PROGRAM NAME
	CONFIRM			;WAIT FOR CONFIRMATION
	CALLRET .SYSEL		;SET FLAGS SO HEADING DOESN'T APPEAR

..SYST:	CALL .SYSTT
	CALLRET CONF

.SYSTT:	HELPX <octal line number or>
	KEYWD $SYTTY
	 0
	 JRST .SYST1
	HRROI B,-1		;FLAG FOR DETACHED LINES
	JRST .SYST2

$SYTTY:	TABLE
	T DETACHED,,0
	TEND

.SYST1:	OCTX			;IF NOT A KEYWORD, HAS TO BE OCTAL NUMBER
	 CMERRX			;NOT EITHER
.SYST2:	PUSH P,B		;SAVE NUMBER
	MOVEI A,SY$TTY
	CALL SSTACK
	POP P,A			;GET NUMBER
	CALL SSTACK		;PUT IT ON STACK
.SYSEL:	TXO	Q1,SY%JOB!SY%NHD
	RET

SSTACK::SKIPL SFRAME
	 ERROR <Too many arguments>
	EXCH B,SFRAME
	MOVEM A,(B)
	ADD B,[1,,1]
	EXCH B,SFRAME
	RET

..SYSA:	CONFIRM
.SYSAL:	TXO	Q1,SYSALL
	RET

..SYSN:	CALL .SYSNO
	CALLRET CONF

.SYSNO:	MOVEI B,[FLDBK. .CMKEY,,$SYSNO,,,DOTBRK] ;ALLOW DOT
	CALL FLDSKP
	 CMERRX
	CALL GETKEY
	JRST (P3)

DOTBRK:	BRMSK. KEYB0.,KEYB1.,KEYB2.,KEYB3.,<.>	;BREAK SET FOR KEYWORDS THAT MAY HAVE DOT IN THEM

DEFINE TB(TEXT,FLAGS,BIT)<
	T <TEXT>,FLAGS+,<[TXZ Q1,SY%'BIT
			  RET]>
>
;$SYSNO IS USED FOR THE SYSTAT NO FEATURE, BOTH FOR SUBCOMMANDS AND FOR
;KEYWORDS.

$SYSNO:	TABLE
	TB .,,IME
	TB CLASS,,CLS
	TB CONTROLLING,,CJB
	TB DIRECTORY,,CON
	IT FOREIGN-HOST,,F4NHN
	T HEADER,,.SYSNH
	TB LIMIT,,LIM
	T OPERATOR,,.NOOPR
	T ORIGIN,,F4NHN
	TB STATE,,STA
	T SYSTEM,,.SYSNS
	TB TIME,,TIM
	TB WHAT,,SUB
	TB WHERE,,TTY
	TB WHO,,USR
	TEND

.SYSNH:	TXZ	Q1,SY%HED
	TXO	Q1,SY%NHD
	RET

.NOOPR:	TXO	Q1,SY%NOP
	RET

.SYSNS:	TXO	Q1,SY%JOB
	RET

CF4NH:	CONFIRM			;MAKE SURE HE MEANS IT
F4NH:	TXO	Q1,SY%4NH
	RET

CN4NH:	CONFIRM			;MAKE SURE HE MEANS IT
F4NHN:	TXZ	Q1,SY%4NH
	RET

IFN PUPSW,<
;CHECK FOR PUP NVT AND GET ITS FOREIGN HOST NAME

CHKPNV:	MOVE A,.JITNO+.JIBAS	;GET THE CONTROLLING TTY NBR
	CAML A,PUPLOW		;IS THIS A PUP NVT?
	 CAMLE A,PUPHGH
	  JRST RSKP		;NO, THAT WAS EASY
	SUB A,PUPLOW		;GET PUP NVT INDEX
	MOVSS A
	HRR A,$NVTPUP		;GET ITS TTYPUP WORD
	GETAB%
	 CALL CERR
	MOVSS A
	JUMPLE A,RSKP		;MUST HAVE JUST DISCONNECTED
	HRR A,$PUPFPT
	GETAB%			;GET FOREIGN PORT ADDR (IN MONITOR SPACE)
	 CALL CERR
	JUMPE A,[MOVSI A,(<ASCIZ \*\>) ;IF 0, THEN WILDCARD
		 MOVEM A,HSTNAM
		 RET]
	SUB A,PUPBUF		;GET OFFSET FROM START OF PUP FREE STORAGE
	MOVSI A,1(A)		;REALLY WANT 2ND WORD
	HRR A,$PUPBUF
	GETAB%			;GET FOREIGN HOST NAME
	 CALL CERR
	MOVEM A,C		;SAVE IT
	SETZ D,			;DON'T WANT PORT INFO
	HRROI A,HSTNAM		;DESTINATION BYTE PTR
	MOVE B,[1B1!1B2+C]	;NO DEFAULTS AND SHOW CONSTANTS IF ERROR
	PUPNM%
	 CALL CERR
	RET			;RETURN WITH PUP NVT FOREIGN HOST
>;IFN PUPSW

;STATISTICS

CLBLN==7			;ROOM FOR COUNT, CLASS, SHAR, USE, 1 MIN LOAD, 5 MIN, 15 MIN

MONSTA::STKVAR <CURCLS,<CLBLK,CLBLN>>
	MOVE A,[SIXBIT /SYSTAT/]
	CALL READT		;READ SYSTEM STATISTICS TABLE INTO AC'S 4-13
	ETYPE < Up %K
 Idle %4T  Waiting %5T  Sched ovh %6T  Pager traps %7T
 Swap reads %10Q Writes %11Q  File reads %12Q Writes %13Q
>
	MOVE A,[SIXBIT /NCPGS/]
	SYSGT
	ETYPE < %1Q Pages of user memory
>
	MOVE A,[SIXBIT /SYSTAT/]
	MOVEI B,10
	CALL MORET		;READ MORE OF TABLE
	TIME			;TOTAL UPTIME OF SYSTEM
	CALL FLOAT
	EXCH 1,6
	CALL FLOAT		;FLOAT NBAL TOTAL
	EXCH 1,7
	CALL FLOAT		;FLOAT NRUN TOTAL
	EXCH 1,6
	FDVR 6,1		;NRUN AVERAGE
	FDVR 7,1		;NBAL AVERAGE
	ETYPE < %4Q Term wakeups  %5Q Term interrupts
 NBAL av %7Q  NRUN av %6Q
>
	HLRE A,QTIMES		;GET NUMBER OF SHCED QUEUES
	MOVM A,A		;MAKE POSITIVE
	SUBI A,1		;MAKE LIMIT INCLUSIVE
	ETYPE < Runtime of jobs on sched queues 0-%1Q (sec)
>
	HLLZ D,QTIMES		;SET UP TO LOOP OVER QTIMES
STAT5C:	GTB .QTIME
	IDIVI A,^D1000		;CONVERT TO SECONDS
	ETYPE <	%1Q>
	AOBJN D,STAT5C
	MOVEI A,CLBLN		;BLOCK LENGTH
	MOVEM A,.SACNT+CLBLK
	CALL CLSON		;SEE IF CLASS SCHEDULER IS ON
	 JRST CLDON		;NO, SO DON'T TRY TO PRINT TABLE!
	ETYPE <%_ Class Share   Use   Loads%_>
	SETZB A,CURCLS		;START CURRENT CLASS AT 0
CLLUP:	MOVEM A,.SACLS+CLBLK	;SAY WHICH CLASS TO LOOK AT
	MOVEI A,SYCLN		;SET UP BLOCK SIZE FOR SKED%
	MOVEM A,.SACNT+CLBLK
	MOVEI A,.SKRCS		;READ CLASS PARAMETERS
	MOVEI B,CLBLK		;SAY WHERE ARG BLOCK IS
	SKED%			;GET THE INFO
	 ERJMP [CALL DGETER	;FAILED, SEE WHY
		CAIE A,ARGX25	;SCAN ALL LEGAL CLASSES?
		CALL JERR	;NO, UNEXPECTED ERROR
		JRST CLDON]	;YES, JUST LEAVE LOOP
	SKIPN .SASHR+CLBLK	;DOES THIS CLASS HAVE A SHARE OF MACHINE?
	SKIPE .SAUSE+CLBLK	;IS THIS CLASS BEEN USED?
	CAIA
	JRST CLNXT		;NO, SKIP IT
	MOVE A,CURCLS		;GET CURRENT CLASS
	ETYPE <  >
	CALL NUM4		;PRINT 4-COLUMN CLASS NUMBER
	DMOVE A,.SASHR+CLBLK	;GET SHARE AND UTILIZATION
	ETYPE <%1=%%2=>		;SHARE, USE
	MOVSI Q1,-3		;SET UP TO PRINT 3 LOAD AVERAGES
	HRRI Q1,.SA1ML+CLBLK	;POINT TO FIRST LOAD AVERAGE
CLOD:	MOVE A,(Q1)		;GET NEXT LOAD
	MOVEI B,7		;PRINT IN 7 COLUMNS
	PRINT " "		;SEPARATE WITH SPACE IN CASE OVERFLOW
	CALL FLTTAB
	AOBJN Q1,CLOD		;LOOP FOR REST OF LOADS
	ETYPE <%_>
CLNXT:	AOS A,CURCLS		;STEP TO NEXT CLASS
	JRST CLLUP
CLDON:	RET

;STATISTICS
;INFO SUBSYSTEM-STATUS - TABLE OF SUBSYSTEM USAGE

SUBSTA::ETYPE<%_>
	TYPE < Subsys  Time(sec)   PGF/SEC   Nblocks   WS-size   Scounts
>
	HLLZ D,SNAMES		;SET UP TO LOOP OVER ALL NAMES
STAT5A:	GTB .SNAME		;GET SIXBIT NAME
	JUMPE A,STAT5Z		;0 MEANS NONE
IFE STANSW,<
	PUSH
>;IFE STANSW
IFN STANSW,<
	PUSH P,A		;SAVE NAME FOR LATER
>;IFN STANSW
	PRINT " "
	CALL SIXPRT		;PRINT IT
	PRINT TAB
	GTB .STIME		;GET RUNTIME
	PUSH P,A		;SAVE IT FOR LATER
	IDIVI A,^D1000		;CONVERT TO SECONDS
	CALL STAT5N		;PRINT SECONDS
	POP P,A			;GET TIME AGAIN
	JUMPE A,[CALL STAT5N	;IF 0, PRINT 0 FOR PGF/SEC ALSO
		 JRST STAT5B]
	CALL FLOAT
	FDVRI A,(1000.0)	;CONVERT TO SECONDS
	MOVEM A,C
	GTB .SPFLT		;GET PAGE FAULTS
	CALL FLOAT		;FLOAT IT
	FDVR A,C		;COMPUTE PAGE FAULTS PER SECOND
	JUMPE A,[CALL STAT5N	;IF 0, PRINT SPECIALLY SO IT'LL ALIGN PROPERLY
		 JRST STAT5B]
	ETYPE <    %1Q>		;PRINT IT IN 10-SPACE FIELD
STAT5B:	GTB .SNBLK		;GET NUMBER OF BLOCKS
	PUSH P,A
	CALL STAT5N		;PRINT IT
	POP P,A
	JUMPE A,[CALL STAT5N	;IF 0, PRINT 0 FOR WSSIZE ALSO
		 JRST STAT5Y]
	CALL FLOAT		;FLOAT IT
	PUSH P,A
	GTB .SSIZE		;GET SIZE INTEGRAL
	CALL FLOAT		;FLOAT IT
	POP P,B
	FDVR A,B		;COMPUTE WSSIZE
	JUMPE A,[CALL STAT5N	;IF 0, PRINT SPECIALLY SO IT'LL ALIGN PROPERLY
		 JRST STAT5Y]
	ETYPE <    %1Q>		;PRINT IT IN 10-SPACE FIELD

STAT5Y:	GTB .SCOUNT		;GET COUNT OF SETSN'S DONE
	POP P,B			;GET STORED PROGRAM NAME
	CAME B,[OURNAM]		;IF IT'S THE EXEC, SCOUNT IS MEANINGLESS (& BIG)
	CALL STAT5N		;ELSE OUTPUT IT IN 12 COLUMNS
	ETYPE <%_>		;END THE LINE
STAT5Z:	AOBJN D,STAT5A		;DO ALL NAMES
	JRST EOLRET

;PRINT FLOATING POINT NUMBER.  NUMBER IN A, COLUMNS IN B

DADP==2			;NUMBER OF DIGITS AFTER DECIMAL POINT

FLTTAB:	MOVX C,FL%ONE!FL%PNT!FL%OVL!FLD(DADP,FL%SND)	;AT LEAST ONE DIGIT, DECIMAL POINT, OUTPUT ON COLUMN OVERFLOW, 2 DIGITS AFTER POINT
	SUBI B,DADP+1		;SUBTRACT DIGITS AFTER POINT PLUS ONE FOR POINT
	STOR B,FL%FST,C		;TELL SYSTEM HOW MANY PLACES BEFORE POINT
	MOVE B,A		;NUMBER IN B
	MOVE A,COJFN		;OUTPUT CHANNEL IN A
	FLOUT			;TYPE THE FLOATING POINT NUMBER
	 JRST [	CAIN C,FLOTX1	;OVERFLOW OF COLUMN 1?
		JRST .+1	;YES, O.K.  JUST MEANS NUMBER REAL LARGE.
		CALL CJERRE]	;NO, PROBABLY OVER QUOTA ON "TAKE" OUTPUT.
	RET

;4-COLUMN NUMBER

NUM4:	MOVX B,NO%LFL!FLD(4,NO%COL)!<5+5> ;LEADING FILLER, 4 COLUMNS, DECIMAL
	CALLRET SYNUM

;PRINT FORMATTED NUMBER
;MAGNITUDE, LEADING FILLER, ERROR IF COLUMN OVERFLOW, 12 COLUMNS, DECIMAL

STAT5N:	MOVX B,NO%MAG!NO%LFL!NO%OOV!FLD(12,NO%COL)!FLD(5+5,NO%RDX)
;	CALLRET SYNUM		;PRINT NUMBER

;ROUTINE TO PRINT NUMBER FOR SYSTAT (COULD BE MADE MORE GENERAL!)
;ACCEPTS:	A/	NUMBER
;		B/	FORMAT, RADIX BITS PER NOUT SPECIFICATION
;RETURNS:	+1 ALWAYS, NUMBER OUTPUTTED TO COJFN

SYNUM:	MOVE C,B		;PUT FORMAT IN B
	MOVE B,A		;NUMBER IN B
	MOVE A,COJFN
	NOUT
	JRST [	CAIE A,NOUTX2	;CHECK FOR COLUMN OVERFLOW ERROR CODE
		CAIN C,NOUTX2	;IN A OR C
		RET		;ALLOW IT
		JRST JERR]	;REPORT ANY OTHER ERROR
	RET

;SUBROUTINE TO READ SYSTEM TABLE WHOSE NAME IS IN A INTO AC'S 4-14.
;USED IN SYSTAT, ERRSTAT.

READT:	SETZ B,			;NORMAL ENTRY: START AT BEGINNING OF TABLE
MORET:	MOVE D,B		;ENTRY FOR TABLE INDEX IN B
	SYSGT
	JUMPN B,.+2
	CALL SCREWUP		;NO SUCH TABLE
	HLLZ C,B		;FORM AOBJN INDEX
	SOJGE D,[AOBJP C,[RET]	;PASS UNWANTED ENTRIES
		 JRST .]
	PUSH P,[D]		;INIT PTR TO AC'S TO STORE VALUES IN
READT1:	HRR A,B			;TABLE #
	HRL A,C			;INDEX
	GETAB			;READ A WORD OF TABLE INTO A
	 CALL JERR
	MOVEM A,@(P)
	AOS A,(P)
	CAIGE A,15		;STOP BEFORE OVERWRITING 15!
	AOBJN C,READT1		;END-OF-TABLE TEST AND LOOP
	SUB P,[XWD 1,1]
	RET

;TERMINAL CHARACTERISTICS COMMANDS GROUP
;	LOWERCASE, FORMFEED, TABS, NO LOWERCASE, NO FORMFEED, NO TABS,
;	RAISE, NO RAISE, HALFDUPLEX, FULLDUPLEX, INDICATE.

;THESE COMMANDS CHANGE THE FILE MODE WORD AND THE CONTROL CHARACTER
;OUTPUT CONTROL (CCOC) WORDS FOR THE PRIMARY OUTPUT FILE,
;AND ALSO THE THREE SETS OF THESE VALUES KEPT IN STORAGE.

;THE "NO" PREFIXED VERSIONS GO THRU THE SAME ROUTINES AS THE UNPREFIXED
;VERSIONS, BUT WITH F1 SET WHICH REVERSES THE EFFECT OF THE SUBROUTINES
;THEY CALL.  F1 IS CLEAR ON DISPATCH FROM THE MAIN LOOP.

.TERNO::KEYWD $TERNO		;"NO". LOOK UP NEXT WORD.
	 0			;NO DEFAULT
	JRST CERR		;NULL ILLEGAL
	TLO Z,F1		;SAY NO
	JRST (P3)		;GO TO .FORMF, .TABS, OR .LOWER.

;LOW ORDER BIT POSITION OF TT%DUM

LB.DUM==<TT%DUM&-TT%DUM>

.LINE::	LDF C,<.TTLDX>*<LB.DUM>	;SET LINE HALF DUPLEX
	JRST SETDU		;DO SET DUPLEX

.FULLD::LDF C,<.TTFDX>*<LB.DUM>	;SET FULL DUPLEX
	JRST SETDU

.HALFD::LDF C,<.TTHDX>*<LB.DUM>
SETDU:	NOISE (MODE FOR TERMINAL)
	CONFIRM
IFE NICSW,<			;[NIC1041]
SETDU1:	MOVEI A,.CTTRM
>;IFE NICSW
IFN NICSW,<			;[NIC1041]
SETDU1:	MOVE A,Q1		;[NIC1041] GET TERMINAL TO USE
>;IFN NICSW
	RFMOD
	TXZ B,TT%DUM		;CLEAR ALL DUPLEX BITS
	IOR B,C			;SET THE DESIRED ONES
	STPAR			;SET NEW DUPLICITY
	RET

.FORMF::NOISE (EXISTS ON TERMINAL)
	LDF C,TT%MFF		;SET MECH FORMFEED BIT
	CALLRET CMOD		;CHANGE MODE WORD AND RETURN

.TABS::	NOISE (EXIST ON TERMINAL)
	LDF C,TT%TAB		;SET HARDWARE TABS BIT
	MOVE D,[POINT 2,(Q1),19] ;PTR TO ^I CCOC BYTE
	CALL CMOD		;CHANGE FILE MODE WORD
	JRST CCCOC		;CHANGE CONT. CHAR. OUTPUT CONT. WORDS

;PAGE MODE

.PAGE::	NOISE <MODE>
	DECX <Carriage return or page length>
	 JRST PAGE1		;NO NUMBER TYPED
	PUSH P,B		;A NUMBER SUPPLIED
	CALL PAGE1
	POP P,B
	JRST PLENT1

PAGE1:	CONFIRM
	CALL ..END		;DO BOTH "PAUSE (ON) END-OF-PAGE"
	CALLRET ..COMM		;AND "PAUSE (ON) COMMAND"

;TERMINAL PAUSE (ON)

.PAUSE::NOISE <ON>
	KEYWD $PAUSE
	 0
	 JRST CERR
	JRST (P3)		;DISPATCH

$PAUSE:	TABLE
	T CHARACTER,,..PPCH
	T COMMAND,ONEWRD,..COMM
	T END-OF-PAGE,ONEWRD,..END
	TEND

;SPECIFY PAGE PAUSE AND UNPAUSE CHARACTER

..PPCH:	TLNE Z,F1		;DID USER SAY "NO"?
	JRST [MOVEI Q1,23	;GET DEFAULTS. ^S
	      MOVEI A,21	;AND ^Q
	      JRST ..PPC1 ]	;AND FINISH UP
	MOVEI B,[FLDDB. .CMNUM,CM%SDH,^D8,<octal ASCII code for character>,,[
		 FLDDB. .CMKEY,,$PCHAR,,,[
		 FLDDB. .CMQST,CM%SDH,,<any printing character in double quotes>,,]]]
	CALL PPGETC		;GET THE CHARACTER TO PAUSE ON
IFE NICSW,<			;[NIC1041]
	MOVEM A,Q1		;SAVE IT FOR LATER
>;IFE NICSW
IFN NICSW,<			;[NIC1041]
	MOVEM A,Q2		;[NIC1041]
>;IFN NICSW
	NOISE <AND UNPAUSE ON>
	MOVEI B,[FLDDB. .CMCFM,,,,,[
		 FLDDB. .CMNUM,CM%SDH,^D8,<octal ASCII code for character>,,[
		 FLDDB. .CMKEY,,$PCHAR,,,[
		 FLDDB. .CMQST,CM%SDH,,<any printing character in double quotes>,,]]]]
	CALL PPGETC		;GET SECOND CHAR
	SKIPGE A		;DEFAULTED?
IFE NICSW,<			;[NIC1041]
	SKIPA A,Q1		;YES - MAKE IT THE SAME AS THE PAUSE CHARACTER
>;IFE NICSW
IFN NICSW,<			;[NIC1041]
	SKIPA A,Q2		;[NIC1041] USE Q2 NOT Q1
>;IFN NICSW
..PPC1:	CONFIRM			;ELSE CONFIRM
	MOVE C,A
IFE NICSW,<			;[NIC1041]
	HRL C,Q1
	MOVEI A,.CTTRM
>;IFE NICSW
IFN NICSW,<			;[NIC1041]
	HRL C,Q2		;[NIC1041]
	MOVE A,Q1		;[NIC1041] TERMINAL TO USE
>;IFN NICSW
	MOVEI B,.MOPCS		;SET PAUSE AND UNPAUSE CHARACTERS
	MTOPR
	 ERCAL CJERRE
	RET

PPGETC:	CALL FLDSKP
	 ERROR <Invalid, %?>
	LOAD C,CM%FNC,.CMFNP(C) ;GET FUNCTION USED
	CAIN C,.CMQST		;ARBITRARY CHAR?
	JRST PPGTCC		;YES - RETURN IT
	CAIN C,.CMCFM		;CR?
	JRST PPGTCR		;YES - RETURN 0
	CAIN C,.CMNUM		;NUMBER?
	JRST PPGTCN		;YES - RETURN IT
	HRRZ B,0(B)		;MUST BE KEYWORD, GET DISPATCH ADDRESS
	HRRZ B,0(B)
	CALLRET 0(B)

PPGTCC:	LDB A,[POINT 7,ATMBUF,6] ;GOT AN ARBITRARY CHARACTER - RETURN IT
	RET
PPGTCR:	SETO A,			;GOT A CR - RETURN -1
	RET
PPGTCN:	SKIPLE A,B		;GOT A NUMBER, CHECK RANGE
	CAILE A,177
	ERROR <Invalid, not a legal ASCII code>
	RET

PCHCON:	MOVEI B,[FLDDB. .CMQST,CM%SDH,,<any printing character in doublequotes>,,]
	CALL FLDSKP
	 ERROR <Invalid, not a quoted string>
	LDB A,[POINT 7,ATMBUF,6] ;GET FIRST CHAR
	CAIL A,"a"		;RAISE LOWERCASE
	CAILE A,"z"
	TRNA
	SUBI A,40
	CAILE A,100		;CHECK RANGE
	CAILE A,137
	ERROR <Invalid, not a control character>
	SUBI A,100
	RET

PCHSPA:	MOVEI A," "		;USE 'SPACE' CHARACTER
	RET

$PCHAR:	TABLE
	T CONTROL,,PCHCON
	T SPACE,,PCHSPA
	TEND

IFE NICSW,<			;[NIC1041]
..END:	MOVEI A,.CTTRM
>;IFE NICSW
IFN NICSW,<			;[NIC1041]
..END:	MOVE A,Q1		;[NIC1041] GET TERMINAL TO USE
>;IFN NICSW
	MOVEI B,.MOXOF
	MOVEI C,.MOONX		;ASSUME ON
	TLNE Z,F1		;"NO" ?
	MOVEI C,.MOOFF		;YUP, OFF
	MTOPR
	 ERCAL CJERRE		;GO SAY WHY IT FAILED
	RET

..COMM:	LDF C,TT%PGM
	JRST CMOD1		;GO CHANGE MODE

;IMMEDIATE ECHO MODE

.IMMED::NOISE <ECHO MODE>
	MOVEI C,TT%ECM
	JRST CMOD

;LOWERCASE: CONTROLS LOWER CASE OUTPUT.
;IT MAY ALSO BE NECESSARY TO CLEAR "INDICATE WITH %" BIT,
;BUT PREFERABLE NOT TO IF IT HAS NO EFFECT WHEN B3 ON.

.LOWER::NOISE (EXISTS ON TERMINAL)
	LDF C,TT%LCA		;SET LOWER CASE AVAILABLE BIT
	JRST CMOD		;CHANGE FILE MODE WORD

;RAISE: CONTROLS CONVERSION OF LOWER CASE TO UPPER ON INPUT.

.RAISE::NOISE (TERMINAL INPUT)
	LDF C,TT%LIC		;SET LOWERCASE INPUT CONTROL
	JRST CMOD

;FLAG UPPERCASE OUTPUT

.FLAG::	NOISE <UPPER CASE OUTPUT>
	LDF C,TT%UOC		;SET UPPERCASE OUTPUT CONTROL
	JRST CMOD




;[SET] TERMINAL [NO] INHIBIT (NON-JOB OUTPUT)
.INHIB::NOISE (NON-JOB OUTPUT)
	CONFIRM
	CALL RTTFLG		;RETURN EXISTING TERMINAL FLAGS
	 ERROR <The [NO] INHIBIT function is not implemented>
	TXO C,MO%NTM		;SET INHIBIT
	TLNE Z,F1		;GOT A "NO"
	 TXZ C,MO%NTM		;YES. TURN BIT OFF.
	MOVEI A,.CTTRM		;CONTROLLING TERMINAL
	MOVEI B,.MOSTF		;FUNCTION CODE FOR SETTING TERMINAL FLAGS
	MTOPR			;DO IT
	 ERCAL CJERRE
	RET



;TWO SUBROUTINES FOR TERMINAL CHARACTERISTICS COMMANDS

;CHANGE TELETYPE MODE WORD SUBR
;CHANGES MODE IN EFFECT
;TAKES: C: MASK INDICATING BITS TO CHANGE.
;	AC Z LH BIT F1: ON TO CLEAR BIT(S), OFF TO SET THEM.
;PRESERVES D, DESTROYS A, B.

CMOD:	CONFIRM			;NO TTY COMMANDS CONFIRMED BEFORE HERE
IFE NICSW,<			;[NIC1041]
CMOD1:	MOVEI A,.CTTRM
>;IFE NICSW
IFN NICSW,<			;[NIC1041]
CMOD1:	MOVE A,Q1		;[NIC1041] GET TERMINAL TO USE
>;IFN NICSW
	RFMOD
	ANDCAM C,B		;IF NO, TURN OFF THE BITS
	TLNN Z,F1
	IORM C,B		;OTHERWISE, TURN THEM ON
	STPAR			;THESE ARE ALL TERMINAL PARAMETERS
	RET

;TERMINAL (TYPE OR FEATURE) IS
;NOTE: IF ADDING A NEW TERMINAL, SEE ALSO TTYPTB IN EXECIN

.TERMI::MOVEI B,[FLDDB. .CMNOI,,<-1,,[ASCIZ/FEATURE OR TYPE/]>,,,[
		 FLDDB. .CMNOI,,<-1,,[ASCIZ/MODE IS/]>]]
	CALL FLDSKP		;READ THE GUIDE WORDS
	 CMERRX
IFN NICSW,<			;[NIC1041]
	MOVEI Q1,.CTTRM		;[NIC1041]
.TERM0::			;[NIC1041]
>;IFN NICSW
	MOVEI B,[FLDDB. .CMKEY,,$TERMI,,,[
		 FLDDB. .CMKEY,,$TTYP]]
	CALL FLDSKP
	 JRST CERR		;ERROR - NEITHER TYPE OF KEYWORD WAS TYPED
	CALL GETKEY		;CHANGE TABLE ADDRESS TO DISPATCH DATA
	JRST (P3)

;HELP FOR TERMINAL COMMANDS.

TTYHLP::CONFIRM
	MOVX A,GJ%OLD+GJ%SHT+GJ%IFG ;OLD FILE ONLY, SHORT FORM
	HRROI B,[ASCIZ/HLP:TERMINAL.HLP/]
	CALL GTJFS		;GET HANDLE ON HELP FILE
	 ERROR <No help available. The file HLP:TERMINAL.HLP was not found.>
	MOVEI Q1,CP%HEL		;SO "TYPE" LOGIC WILL KNOW IT'S US
	MOVE A,JBUFP		;GET POINTER TO JFN CELL
	HRRZM A,INIFH1
	HRRZM A,INIFH2		;COPY CODE NEEDS THIS
	JRST TYPE1		;FINISH COMMAND BY COPYING HELP FILE TO TERMINAL


;TERMINAL TYPE N OR <TYPE>
;NOTE: IF ADDING A NEW TERMINAL, SEE ALSO TTYPTB IN EXECIN

.TTYPE::MOVEI B,[FLDDB. .CMNUM,CM%SDH,5+5,<Terminal type>,<SYSTEM-DEFAULT>,[
		 FLDDB. .CMKEY,,$TTYP]]
	CALL FLDSKP
	 CMERRX			;NEITHER NUMBER OF KEYWORD TYPED
	LOAD D,CM%FNC,.CMFNP(C)	;GET DATUM TYPE
	CAIN D,.CMNUM		;NUMBER?
	JRST .TTYP1		;YES
	CALL GETKEY		;NO, KEYWORD, GET INFO
	JRST 0(P3)		;OK - DISPATCH
.TTYP1:	PUSH P,B
	JRST .TTY3

.T33::	PUSH P,[0]
	JRST .TTY3

.T35::	PUSH P,[1]
	JRST .TTY3

.T37::	PUSH P,[2]
	JRST .TTY3

.TI::	PUSH P,[3]
	JRST .TTY3

IFN STANSW,<
.ADM3::	PUSH P,[.TTADM]
	JRST .TTY3

.AMBAS::PUSH P,[.TTAMB]
	JRST .TTY3

.ANNAR::PUSH P,[.TTANN]
	JRST .TTY3

IFE NICSW,<			;[NIC1046]
.ANSI::	PUSH P,[.TTANS]
>;IFE NICSW
IFN NICSW,<			;[NIC1046]
.ANSI::	PUSH P,[.TT100]		;[NIC1046]
>;IFN NICSW
	JRST .TTY3

.AVT::	PUSH P,[.TTAVT]
	JRST .TTY3

.CONCE:: PUSH P,[.TTCPT]
	JRST .TTY3

.DATAM:: PUSH P,[.TTDAM]
	JRST .TTY3

.DATM2:: PUSH P,[.TTDM2]
	JRST .TTY3

.ESPRT:: PUSH P,[.TTESP]
        JRST .TTY3

.FREE2:: PUSH P,[.TTFR2]
	JRST .TTY3

.FREED:: PUSH P,[.TTFRD]
	JRST .TTY3

.GILLO:: PUSH P,[.TTGIL]
	JRST .TTY3

IFE NICSW,<
.GVT::	PUSH P,[.TTGVT]
	JRST .TTY3
>;IFE NICSW

.HAZEL:: PUSH P,[.TTHAZ]
 	JRST .TTY3

.HP2::	PUSH P,[.TTHP]
	JRST .TTY3

.IBM::	PUSH P,[.TTIBM]
	JRST .TTY3

.NVT::	PUSH P,[.TTIDL]
	JRST .TTY3

.SOROC:: PUSH P,[.TTSRC]
	JRST .TTY3

.T43::	PUSH P,[.TT43]
	JRST .TTY3

.TELER:: PUSH P,[.TTTEL]
	JRST .TTY3

.TELEV:: PUSH P,[.TTTVI]
	JRST .TTY3

.TEKT3:: PUSH P,[.TTTK3]
	JRST .TTY3

.TEKTR:: PUSH P,[.TTTEK]
	JRST .TTY3

.SUN48:: SKIPA C,[^D48]		;with 48 lines, or
.SUN::	MOVEI C,^D28		;WITH 28 LINES
	CONFIRM
IFE NICSW,<
	MOVEI B,.TT100
>
IFN NICSW,<
	MOVEI B,.TTSUN
>
.TTTLN:: MOVEI A,.CTTRM
	STTYP
	 ERJMP [ERROR <Invalid terminal type>]
	JRST PLENT2		;GO SET LINES

.ALTO::	CONFIRM
	MOVX B,.TTDAM		;DM2500 SIMULATION WITH A BIG SCREEN
	MOVEI C,^D60		;WITH 60 LINES
	JRST .TTTLN		;GO SET IT UP
>;IFN STANSW

IFN NICSW,<			;[NIC1012]
.LINEP:: PUSH P,[^D13]		;[NIC1012] LINEPROCESSOR/GT40
	JRST .TTY3		;[NIC1012]
>;IFN NICSW

.DFLT::				;SYSTEM-DEFAULT TERMINAL TYPE
IFN STANSW,<
IFN SUMXSW,<
	JRST .DATAM		;STANFORD SUMEX DEFAULTS TO DATAMEDIA
>;IFN SUMXSW
	JRST .ADM3		;EVERYONE ELSE DEFAULTS TO ADM-3 GLASS TTY
>;IFN STANSW

.TRMNT::PUSH P,[^D8]
	JRST .TTY3

.VT05::	PUSH P,[^D10]
	JRST .TTY3

.VT50::	PUSH P,[^D11]
	JRST .TTY3

.VT52::	PUSH P,[^D15]
	JRST .TTY3

.LA36::	PUSH P,[^D14]
	JRST .TTY3

.LA38::	PUSH P,[.TTL38]
	JRST .TTY3

.LA120::PUSH P,[.TT120]
	JRST .TTY3

.VT125::PUSH P,[.TT125]
	JRST .TTY3

.VK100::PUSH P,[.TTK10]
	JRST .TTY3

.VT100::PUSH P,[.TT100]
	JRST .TTY3

.VT102::PUSH P,[.TT102]
	JRST .TTY3

.VT200::PUSH P,[.TT200]
	JRST .TTY3

.VT131::PUSH P,[.TT131]
	JRST .TTY3

.VTH19::PUSH P,[.TTH19]
	JRST .TTY3

.LA30::	PUSH P,[^D12]
.TTY3::	CONFIRM
	POP P,B
IFE NICSW,<				;[NIC1041]
	MOVEI A,.CTTRM
>;IFE NICSW
IFN NICSW,<				;[NIC1041]
	MOVE A,Q1			;[NIC1041] GET TERMINAL TO SET
>;IFN NICSW
	STTYP
	 ERJMP [ERROR <Invalid terminal type>]
	RET

;WIDTH OF TERMINAL LINE

.LWIDT::NOISE (OF LINE IS)
	DECX <Terminal line width in decimal>
	 CMERRX
	CONFIRM
	MOVE C,B
IFE NICSW,<			;[NIC1041]
	MOVEI A,.CTTRM
>;IFE NICSW
IFN NICSW,<			;[NIC1041]
	MOVE A,Q1		;[NIC1041] TERMINAL TO SET
>;IFN NICSW
	MOVEI B,.MOSLW		;SPECIFY SETTING LINE WIDTH
	MTOPR			;DO IT
	 ERCAL CJERRE		;GO SAY WHY IT FAILED
	RET

;LENGTH OF TERMINAL PAGE

PLENTH::NOISE <OF PAGE IS>
	DECX <Length of page in decimal>
	 CMERRX
	CONFIRM
PLENT1:	MOVE C,B
IFN STANSW,<
PLENT2:
>;IFN STANSW
IFE NICSW,<			;[NIC1041]
	MOVEI A,.CTTRM
>;IFE NICSW
IFN NICSW,<			;[NIC1041]
	MOVE A,Q1		;[NIC1041]
>;IFN NICSW
	MOVEI A,.CTTRM
	MOVEI B,.MOSLL		;SPECIFY SETTING LENGTH
	MTOPR			;DO IT
	 ERCAL CJERRE		;FAILED, SAY WHY AND DIE
	RET

IFN STANSW,<
;ENABLE/DISABLE BACKSPACE BEING CONVERTED TO RUBOUT
.BACKRB::CONFIRM
	MOVE A,COJFN		;THE CONTROLLING TTY
	MOVEI B,.MOSLT
	SETZ C,			;CLEAR C FOR LUCK (COULD BE A READ SOMEDAY)
	TLNE Z,F1		;NO??
	 TROA C,MO%BSP		;DON'T TRANSLATE
	  TRZ C,MO%BSP		;YES TRANSLATE
	MTOPR%
	 ERCAL CJERRE		;OOPS, TELL ME
	RET			;ALL DONE
>;IFN STANSW

IFN NICSW,<
; Translate ^H to ^A if DOGMENT terminal
.DOGMN::CONFIRM
	MOVE A,COJFN		;THE CONTROLLING TTY
	MOVEI B,.MOSLT
	SETZ C,			;CLEAR C FOR LUCK (COULD BE A READ SOMEDAY)
	TLNE Z,F1		;NO??
	 TROA C,MO%AUG		;DON'T TRANSLATE
	  TRZ C,MO%AUG		;YES TRANSLATE
	MTOPR%
	 ERCAL CJERRE		;OOPS, TELL ME
	RET			;ALL DONE
>;IFN NICSW

IFN CHSTSW,<
;TERMINAL META (KEY EXISTS)

.META::	NOISE (KEY EXISTS)
	CONFIRM			;Tie off command line
	TXNN Z,F1		;'NO' version?
	IFSKP.
	 SETZM CEMETA		;TERM NO META
	ELSE.
	 SETOM CEMETA		;TERM META
	ENDIF.
	RET			

>;IFN CHSTSW

;INDICATE (FORMFEED)

.INDIC::NOISE (FORMFEED)
	CONFIRM
	TLZN Z,F1		;'NO'?
	TLO Z,F2
	MOVE D,[POINT 2,(Q1),25]
				;JRST CCCOC

;SUBR TO CHANGE CCOC BYTE TO SIMULATE (IF F1 ON & F2 OFF)
; OR SEND (IF F1 AND F2 OFF) OR INDICATE (IF F2 ON).
;BYTE TO CHANGE IS INDICATED BY A BYTE PTR IN D, INDEXED BY E.
;DESTROYS A, B, C, E.

IFE NICSW,<			;[NIC1041]
CCCOC:	MOVE A,COJFN
>;IFE NICSW
IFN NICSW,<			;[NIC1041]
CCCOC:	MOVE A,Q1		;[NIC1041] GET TERMINAL TO USE
	MOVE Q2,A		;[NIC1041] SAVE IT
>;IFN NICSW
	RFCOC
	MOVEI Q1,B
	CALL CCCOCS		;OPERATE ON CCCOC WORDS IN B,C
IFE NICSW,<			;[NIC1041]
	MOVE A,COJFN
>;IFE NICSW
IFN NICSW,<			;[NIC1041]
	MOVE A,Q2		;[NIC1041] TERMINAL TO SET
>;IFN NICSW
	SFCOC			;PUT NEW VALUE INTO EFFECT
	MOVEI Q1,ETTYMD+TTWCOC	;OPERATE ON STORED VALUES
	CALL CCCOCS
	MOVEI Q1,ITTYMD+TTWCOC

;SUBSUBROUTINE TO OPERATE ON BYTE IN WORDS Q1 POINTS TO

CCCOCS:	TLNE Z,F1
	SKIPA A,[3]		;3 = SIMULATE
	MOVEI A,2		;2 = SEND CODE
	TLNE Z,F2
	MOVEI A,1		;1 = INDICATE BY ^X
	DPB A,D
	RET

;SET TERMINAL SPEED

IFE NICSW,<			;[NIC1041]
.SPEED::MOVEI	A,.CTTRM	;TO CURRENT TERMINAL
	MOVEI B,.CTTRM		;HIGHEST TERMINAL IN RANGE
>;IFE NICSW
IFN NICSW,<			;[NIC1041]
.SPEED::MOVE A,Q1		;[NIC1041]
	MOVE B,Q1		;[NIC1041]
>;IFN NICSW
SPEEDA::STKVAR <STERM,RTERM,<SPNBUF,3>>
	MOVEM A,STERM		;REMEMBER TERMINAL NUMBER
	MOVEM B,RTERM		;REMEMBER HIGHEST TERMINAL IN RANGE
	NOISE	<OF INPUT>
	KEYWD	$BAUDR		;BAUD RATE TABLE
	  0			;NO DEFAULT
	  JRST	CERR		;ERROR IF NONE GIVEN
	NOISE <AND OUTPUT>
	HRLZ	Q1,P3		;SAVE VALUE
	HRRZ B,P3		;USE INPUT FOR OUTPUT DEFAULT
	HRROI A,SPNBUF
	MOVEM A,CMDEF
	MOVEI C,5+5		;SPEEDS ARE DECIMAL
	NOUT			;SET UP DEFAULT STRING
	 CALL JERR		;SHOULD NEVER FAIL
	KEYWD $BAUDR		;READ OUTPUT SPEED
	 0			;DEFAULT ALREADY SET UP
	 CMERRX			;BAD OUTPUT SPEED SPECIFIED
	HRR Q1,P3		;FILL IN SELECTED OUTPUT SPEED
	CONFIRM
	MOVE A,STERM		;TERMINAL NUMBER TO START WITH
SPEEDB:	MOVEI B,.MOSPD		;FCN CODE
	MOVE C,Q1		;PICK UP SELECTED SPEEDS
	MTOPR			;C := INPUT,,OUTPUT
	 ERCAL CJERRE		;FAILED, TELL USER WHY
	AOS A,STERM		;INCREMENT TERMINAL NUMBER
	CAMG A,RTERM		;STILL IN RANGE?
	JRST SPEEDB		;YES, SET NEXT TERMINAL
	RET			;NO, RETURN

$BAUDR:	TABLE
	T 0,,0
	T 110,,^D110
	T 1200,,^D1200
IFE NICSW,<
	T 134,,^D134
>;IFE NICSW
	T 150,,^D150
	T 1800,,^D1800
IFN NICSW,<
	T 19200,,^D19200
>;IFN NICSW
	T 200,,^D200
	T 2400,,^D2400
	T 300,,^D300
	T 4800,,^D4800
	T 50,,^D50
	T 600,,^D600
	T 75,,^D75
	T 9600,,^D9600
	TEND

;ROUTINE TO PRINT SYSTEM-MESSAGES THAT HAVEN'T BEEN PRINTED

PNTMES::
IFN STANSW,<
	SKIPE MRPFLG		;ARE WE MRP?
	 RET			;YES, DON'T RISK RUNNING BBOARD AND GETTING ^C
>;IFN STANSW
	SKIPE MESMSF		;MAIL CHECK YET?
	 CALL MESMES		;PUT OUT "YOU HAVE A MESSAGE" IS NECESSARY
	AOSE SYSMF		;YES, SO MAYBE TIME TO PRINT SYSTEM MESSAGES
	RET			;THEY'VE ALREADY BEEN PRINTED
IFE STANSW,<
	MOVE A,LOGDAT		;THEY HAVEN'T, GET LOGIN DATE.
	CALL MESS		;TYPE APPLICABLE LOGIN MESSAGES
	RET
>;IFE STANSW
IFN STANSW,<
;WITH STANFORD BBOARD PROGRAM, THE PROBLEM NOTED ABOVE DOESN'T HAPPEN.
	GJINF%			;GET TTY NUMBER
	CALL CHKPTY		;ON A PTY?
	 RET			;YES -- DON'T PRINT OUT MESSAGE
;DROP INTO MESS
>;IFN STANSW

;CODE TO USE RDMAIL TO TYPE <SYSTEM>MAIL.TXT
MESS:	STKVAR <MALJFN,SJFNP,MSFK>	;CELLS TO HOLD JFNS WE'LL USE
	MOVE A,.JBUFP		;GET CURRENT JFN STACK POINTER
	MOVEM A,SJFNP		;SAVE IT FOR RESTORATION LATER
	MOVE A,FORK		;SAVE CURRENT FORK
	MOVEM A,MSFK
	SETOM FORK		;FORCE NEW FORK BELOW
	MOVE A,JBUFP
	MOVEM A,.JBUFP		;MARK STACK SO RLJFNS DOESN'T CLOSE THINGS OUR CALLER OPENED
IFE STANSW,<
	HRROI B,[ASCIZ /POBOX:<SYSTEM>MAIL.TXT/]
>;IFE STANSW
IFN STANSW,<
IFE LOTSW,<
	HRROI B,[ASCIZ /SYSTEM:MAIL.TXT/]
>;IFE LOTSW
IFN LOTSW,<
	HRROI B,[ASCIZ /POBOX:<SYSTEM>MAIL.TXT/]
>;IFN LOTSW
>;IFN STANSW
	CALL TRGTV1		;TRY TO ASSIGN JFN TO FILE
	 JRST SYSLEV		;NO SUCH FILE
IFE STANSW,<
	MOVE B,[XWD 1,.FBSIZ]
	MOVEI C,C
	CALL $GTFDB		;GET # BYTES IN FILE
	 JRST SYSMDO		;LET RDMAIL FIGURE IT OUT
	JUMPLE C,SYSLEV		;THERE'S NO MESSAGE IF FILE IS NULL
	MOVE B,[XWD 1,.FBWRT]
	MOVEI C,C
	CALL $GTFDB
	 JRST SYSMDO
	CAMGE C,LOGDAT		;HAS FILE BEEN WRITTEN SINCE LAST LOGIN?
	JRST SYSLEV		;NO
SYSMDO:	HRROI B,[GETSAVE(SYS:RDMAIL.)]
>;IFE STANSW
IFN STANSW,<
SYSMDO:	HRROI B,[GETSAVE(SYS:BBOARD.)]
>;IFN STANSW
	CALL TRYGTJ
	 JRST SYSLEV		;LEAVE IF NO SUCH PROGRAM
	MOVEM A,MALJFN
	SETO C,			;FORCE OVERLAY
	CALL $GET2		;GET RDMAIL INTO IT
	MOVE A,FORK		;GET FORK HANDLE
	CALL JFNSTK		;STACK IT SO IT GOES AWAY LATER
	GEVEC			;GET ENTRY VECTOR POINTER
	HLRZ A,B
IFE STANSW,<
	CAIGE A,3		;MUST BE AT LEAST 3
	JRST SYSLOS		;LOSE
	ADDI A,-1(B)		;USE ENTRY -1 FROM LAST
	CALL LOADF		;READ IT
	 JRST SYSLOS		;CAN'T READ IT
	HRRZ C,A		;SAVE STARTING ADDR
	HLRZ A,A		;GET POINTER TO WHERE TO STORE DATE AND TIME
	MOVE B,LOGDAT		;GET DATE AND TIME
	CALL STOREF		;STORE IT
	 JRST SYSLOS 		;CAN'T SET IT
	SETO A,
	CALL MAPPF		;FREE MAPPED PAGE
	 JFCL			;UNMAP SHOULD NEVER FAIL
>;IFE STANSW
IFN STANSW,<
	CAIGE A,5		;MUST BE AT LEAST FIVE
	 JRST SYSLOS
	MOVEI C,-2(A)		;SAVE SECOND-TO-LAST POSITION IN ENTRY VECTOR
>;IFN STANSW
	MOVEI Q1,ETTYMD		;SAVE EXEC TTY MODES
	CALL RTTYMD
	TLO Z,RUNF
IFE STANSW,<
	MOVE B,C		;START ADDR IN B
	MOVE A,FORK		;SET UP AS RUNNING FORK
	SFORK			;START FORK HERE FOR SYSTEM MESSAGE
>;IFE STANSW
IFN STANSW,<
	SKIPE LOGDAT		;IF NOT FIRST LOGIN,
	 SKIPA B,C		;SECOND-TO-LAST POSITION FOR NORMAL MESSAGES
	  MOVEI B,1(C)		;FIRST LOGIN, LAST POSITION FOR ALL MESSAGES
	MOVE A,FORK		;SETUP AS RUNNING FORK
	SFRKV%			;START FORK VECTORED FOR SYSTEM MESSAGES
>;IFN STANSW
	RFORK			;RESUME IT
	WFORK			;WAIT FOR IT
SYSLEV:	SKIPL A,FORK		;GET RID OF TEMP FORK
	CALL KEFORK
	CALL RLJFNS		;CLOSE FILES WE USED
	MOVE A,SJFNP		;GET JFN STACK MARKER AS BEFORE WE TOUCHED IT
	MOVEM A,.JBUFP		;RESTORE IT
	MOVE A,MSFK		;RESTORE CURRENT FORK
	MOVEM A,FORK
	TLZ Z,RUNF		;SAY PROG'S TTY MODES NOT IN EFFECT
	MOVEI Q1,ETTYMD		;RESTORE EXEC'S TTY MODES
	CALL LTTYMD		; ..
	RET
SYSLOS:	ETYPE <%_%%%Error while reading system message -  %?%%_>
	JRST SYSLEV


IFN STANSW,<
;^EREPLACE COMMAND -- REPLACE EXEC WITH GIVEN PROCESS
.REPLA::NOISE <EXEC WITH>
	SETZ A,			;NO DEFAULT
	CALL CPFN		;TRY TO GET A JFN ON IT
	IFSKP.
	  CONFIRM
	  HRRZ A		;STASH JFN AWAY IN A SAFE PLACE
	  MOVE A,[ACPRG,,ACST]
	  BLT A,HIAC
	  SETO A,		;SET UP TO UNMAP US AT ACST.
	  HRLZI B,.FHSLF
	  MOVX C,PM%CNT+1000
	  JRST ACST		;GO EXECUTE IN ACS.
	ELSE.
	  MOVE A,ERCOD		;YOU LOSE
	  JRST CJERR
	ENDIF.

ACPRG:	PHASE 4
ACST:	PMAP%			;CLEAR CORE
	HRLZI 1,400000
	HRR 1,0
	HRRZI 2,777
	GET%			;LOAD NEW PROCESS
	HRRZI 1,400000
	GEVEC%			;START AT POSITION 0 OF E.V.
	CLZFF%			;CLOSE ALL FILES
HIAC:	JRST (2)
DEPHASE

;ECHO ...LINE TO BE ECHOED BACK...
.ECHO::	NOISE (TO THE TERMINAL)
	LINEX <Text to be echoed>
	 CMERRX			;ERROR
	CONFIRM
	HRROI A,ATMBUF		;GET BUFFER POINTER BACK
	ETYPE <%1M%%_>
	RET

IFN SUMXSW!NICSW,<
;^EPEEK (ON LINE)
;  Several people have expressed a valid concern about the moral, legal and
;  ethical questions this command raises.  However, since any wheel can set
;  up a 1-way link via SDDT, we might as well let the EXEC do it.  Besides
;  being a ^E cmd, it's invisible so wheels don't even see it on a ^E?.
.PEEK::	NOISE <ON LINE>
	OCTX <Octal line number>
	 CMERRX
	HRLOI A,(TL%ERO)	;LINK FROM REMOTE TO ME
	MOVEI B,.TTDES(B)	;REMOTE DESIGNATOR
	TLINK			;ESTABLISH 1-WAY LINK
	 ERJMP CJERRE		;FAILED, TYPE JSYS ERROR
	RET			;THAT WAS EASY
>;IFN SUMXSW!NICSW
>;IFN STANSW


	END

