;SRC:<6-1-EXEC>EXECCE.MAC.3,  6-Nov-85 11:50:00, Edit by KNIGHT
; Make the NOUT% use a variable-width field
;SRC:<6-1-EXEC>EXECCE.MAC.2,  6-Nov-85 11:23:09, Edit by KNIGHT
; Output numbers in CENUMB the same as old history junk
;SRC:<5-EXEC.STANFORD.EDITOR>EXECCE.MAC.4, 23-Jul-84 15:44:34, Edit by WHP4
; rewrite CEBACK to use BCOPTB and handle more terminals
;SRC:<5-EXEC.STANFORD.EDITOR>EXECCE.MAC.3, 28-Jun-84 11:40:03, Edit by WHP4
; put in stanford/fairchild terminal type table
;SRC:<5-EXEC.STANFORD.EDITOR>EXECCE.MAC.2, 26-Jun-84 16:56:54, Edit by WHP4
; comment out stuff dealing with PCCIPF since I don't know what it is

;TOPS20 'EXECUTIVE' COMMAND LANGUAGE

;UTEXAS-20 COMMAND EDITOR
;BILLY BROWN
;JULY, 1982

	SEARCH EXECDE
	TTITLE EXECCE


;THIS FILE CONTAINS
;COMMAND EDITOR, AGAIN COMMAND, COMMAND SAVE ROUTINE


; ROUTINE TO SAVE CONTENTS OF COMMAND BUFFER FOR LATER EDITING

CSAVE::	SKIPE CEBPTR		;THIS ONE NOT TO BE SAVED?
	 RET			;DON'T DO IT
	PUSH P,A		;SAVE THE REGISTERS
	PUSH P,B
	PUSH P,C
	PUSH P,D
	CALL PIOFF		;DON'T ABORT THIS
	MOVE A,SBLOCK+.CMIOJ	;GET PRIMARY JFNS
	CAME A,[.PRIIN,,.PRIOU]	;A REAL, TYPED COMMAND?
	 JRST CSAVE5		;NOPE, DON'T SAVE IT
;	SKIPE PCCIPF		;IF NOT PCL COMMAND, SAVE IT
;	 JRST [	SKIPE PCLMID
;		 JRST CSAVE5	;IF NOT THE CALLING COMMAND, DON'T SAVE
;		SETOM PCLMID	;DON'T SAVE ANY MORE PCL COMMANDS
;		JRST .+2 ]	;BUT DO SAVE THIS ONE
	SETZM PCLMID

	LDB A,[POINT 7,CBUF,6]	;CHECK IT OUT FIRST
	JUMPE A,CSAVE5		;DON'T SAVE EMPTY COMMANDS
	CAIN A,"^"
	 JRST CSAVE5		;DON'T SAVE EDITING COMMANDS
	CAIN A,CR		;CR?
	 JRST CSAVE5		;YES, DON'T SAVE
	CAIN A,LF		;LF?
	 JRST CSAVE5		;YES, EMPTY COMMAND, DON'T SAVE

	MOVE A,[POINT 7,CBUF]	;POINT TO THE SOURCE
	MOVE B,CEFFL		;GET ADDRESS OF FIRST FREE LOCATION
	CAME B,CE1ST		;ABOUT TO STOMP SOMEONE?
	 JRST CSAVE0		;NO

	HRRZ D,(B)		;GET ADDRESS OF NEXT ONE
	HRRZS (D)		;TIE IT OFF
	MOVEM D,CE1ST		;SAVE NEW ADDRESS
	SOS CECNT		;DECREMENT THE COUNT

;	CONTINUED ON NEXT PAGE

CSAVE0:	HLL B,[POINT 7,0]	;POINT TO FIRST FREE SPOT
	AOS B			;LEAVE ROOM FOR THE HEADER
CSAVE1:	ILDB C,A		;GET NEXT BYTE
	CAIN C,CR		;END ON CR
	 SETZ C,
	CAIN C,LF		;END ON LINE FEED
	 SETZ C,

CSAVE2:	IDPB C,B		;STORE THE BYTE
	HRRZ D,B		;GET ADDRESS WE JUST STORED IN
	CAME D,CE1ST		;GOING OVER THE FIRST COMMAND?
	 JRST CSAVE3
	HRRZ D,(D)		;GET ADDRESS OF NEXT ONE
	HRRZS (D)		;TIE IT OFF
	MOVEM D,CE1ST		;SAVE NEW ADDRESS
	SOS CECNT		;DECREMENT THE COUNT
CSAVE3:	HRRZ D,B		;GET ADDRESS AGAIN
	CAIE D,CEBFEN		;PAST THE BUFFER?
	 JRST CSAVE4		;NO
	MOVE B,[POINT 7,CESAVE]	;YES, RESET TO THE TOP
	JRST CSAVE2		;AND TRY AGAIN

CSAVE4:	JUMPN C,CSAVE1		;GET NEXT CHARACTER IF NOT THE END
	HRRZ A,B		;GET ADDRESS OF LAST BYTE
	AOS A			;BECOMES FIRST FREE LOCATION
	CAIL A,CEBFEN		;STILL IN THE BUFFER?
	 MOVEI A,CESAVE		;NO, WRAP AROUND
	EXCH A,CEFFL		;SAVE IT, A POINTS TO THE NEW BLOCK
	HRRM A,@CELAST		;LINK THIS ONE IN
	MOVE B,CELAST		;GET ADDRESS OF LAST ONE
	HRLZM B,(A)		;LINK FROM NEW ONE TO OLD ONE
	MOVEM A,CELAST		;UPDATE LAST COMMAND POINTER
	AOS CECNT		;INCREMENT COUNT

CSAVE5:	CALL PION		;ALLOW ^C AGAIN
	POP P,D			;RESTORE EVERYTHING
	POP P,C
	POP P,B
	POP P,A
        RET


; HISTORY COMMAND

.HISTO::NOISE <about recent exec commands>
	MOVEI B,[FLDDB. .CMCFM,CM%SDH,,<confirm to print entire history>,,
		[FLDDB. .CMNUM,CM%SDH,^D10,<integer "n" for last "n" commands>]]
	CALL	FLDSKP		;CONFIRMATION OR NEW COMMAND
	 CMERRX			;SOME TYPE OF ERROR
	STKVAR <HSTNUM,CELPOS,CELPTR>
	LDB D,[331100,,(C)]	;SEE WHAT WE GOT
	CAIN D,.CMCFM		;CONFIRM?
	 JRST [SETOM HSTNUM	;EFFECTIVELY INFINITY
	       JRST HIST1]	       
	MOVEM B,HSTNUM		;SAVE AMOUNT OF HISTORY
	CONFIRM
HIST1:	SETZM CELPOS		;ENTRY ZERO
	SKIPN C,CELAST		;CURRENT MOST RECENT ENTRY
	 RET			;NOTHING THERE
	MOVEM C,CELPTR
HIST2:	MOVE D,CELPOS		;GET LINE COUNT
	MOVEI B,1(C)		;GET PAST HEADER
	HLL B,[POINT 7]		;MAKE INTO BYTE POINTER
	ETYPE < -%4Q: %2M %_>
	SOSN HSTNUM		;DECREMENT COUNTER
	 RET			;NO MORE WANTED

; GO TO PREVIOUS LINE

	HLRZ C,@CELPTR		;TAKE THE LEFT HAND LINK
	SKIPN C			;CHECK FOR END OF LIST
	 RET
	MOVEM C,CELPTR		;UPDATE POINTER
	AOS CELPOS		;INCREMENT THE LINE NUMBER
	JRST HIST2		;PROCESS THIS LINE


; AGAIN COMMAND

.AGAIN::MOVEI B,[FLDDB. .CMCFM,CM%SDH,,<confirm to redo last command>,,
		[FLDDB. .CMTXT,CM%SDH,,<command to be executed first>]]
	CALL FLDSKP		;CONFIRMATION OR NEW COMMAND
	 CMERRX			;SOME TYPE OF ERROR
	LDB D,[331100,,(C)]	;SEE WHAT WE GOT
	CAIN D,.CMCFM		;CONFIRM?
	 JRST AGINOK		;YES, SKIP NEW STUFF

	MOVE C,[POINT 7,ATMBUF]	;POINT TO THE NEW COMMAND
	MOVEI A,.CTTRM		;AND TO THE TERMINAL
OAGAIN:	ILDB B,C		;GET NEXT CHAR
	JUMPE B,OAGIN1		;CHECK FOR END
	CAIN B,.CHCNN		;^N?
	 MOVEI B,CR		;YES, MULTI LINE STUFF
	STI			;STUFF IT
	 ERJMP STIBDX
	JRST OAGAIN		;DO THE REST
OAGIN1:	MOVEI B,CR		;END WITH CR
	STI
	 ERJMP STIBDX
	MOVEI B,[FLDDB. .CMCFM]	;PARSE THE CR TO SYNC WITH AGAIN<CR>
	CALL FIELD
AGINOK:	MOVE C,CELAST		;GET ADDRESS OF LAST COMMAND STRING
	HLRZ C,(C)		;SKIP ONE MORE
	AOS C			;SKIP PAST THE HEADER
	HLL C,[POINT 7,0]	;MAKE IT A POINTER
	MOVEI A,.CTTRM
AGAIN1:	IBP C			;POINT TO NEXT BYTE
	HRRZ D,C		;CHECK FOR WRAP AROUND
	CAIL D,CEBFEN		;STILL IN THE BUFFER?
	 MOVE C,[POINT 7,CESAVE,6] ;NO, RESET
	LDB B,C			;GET NEXT CHAR
	JUMPE B,AGAIN2		;CHECK FOR END
	STI			;STUFF IT
	 ERJMP STIBDX
	JRST AGAIN1		;DO THE REST
AGAIN2:	MOVEI B,CR		;ADD CR TO THE END
	STI
	 ERJMP STIBDX
AGAIN3:	SETOM CEBPTR		;DON'T SAVE THIS IN THE EDIT BUFFER
	MOVE A,CELAST		;GET POINTER TO "REDO" COMMAND
	HLRZ A,(A)		;NOW POINTER TO PREVIOUS COMMAND
	MOVEM A,CELAST		;FORGET THE "REDO" FROM HISTORY
	RET			;ALL DONE


;  REDO COMMAND
.REDO::	SETOM CEBPTR		;DON'T SAVE THIS IN THE EDIT BUFFER
	MOVEI B,[FLDDB. .CMCFM,CM%SDH,,<prefix of previous command>,,
		[FLDDB. .CMTXT,CM%SDH]]
	CALL FLDSKP		;CONFIRM OR NEW COMMAND
	 CMERRX			;SOME TYPE OF ERROR
	HRLI C,331100		;GET POINTER TO THE FUNCTION CODE
	LDB C,C			;GET THE FUNCTION CODE
	CAIE C,.CMTXT		;ANYTHING THERE?
	 ERROR <Previous command prefix required>
	CONFIRM			;CONFIRM IT

	TRVAR <CADLFG,CEDUMB,CABKFG,CELPOS,CECPOS,CELPTR,CEDSEA,CENUMR,CEKBC>
	SETOM CADLFG		;TELL SEARCH WE ARE IN REDO MODE
	SETOM CEDSEA		;FORCE A SEARCH
	SETZM CELPOS		;INITIALIZE STUFF
	MOVE A,CELAST		;SET POINTERS TO FIRST ONE
	MOVEM A,CELPTR
	CALL CESRCH		;SEARCH FOR THE COMMAND
	SKIPN C,CELPTR		;FIND IT?
	 ERROR <Command prefix not found>
	AOS C			;SKIP PAST THE HEADER
	HLL C,[POINT 7,0]	;MAKE IT A POINTER
	MOVEI A,.CTTRM
	JRST AGAIN1		;GO STUFF IT



;	UTEXAS-20 COMMAND LINE EDITOR

CEDIT::	MOVEI B,[FLDDB. .CMCFM,CM%SDH,,<confirm to enter command EDITOR>,,
		[FLDDB. .CMNUM,CM%SDH,^D10,<number of previous command>,,
		[FLDDB. .CMTXT,CM%SDH,,<prefix of previous command>]]]
	CALL FLDSKP		;CONFIRM OR NEW COMMAND
	 CMERRX			;SOME TYPE OF ERROR
	TRVAR <CADLFG,CEDUMB,CABKFG,CELPOS,CECPOS,CELPTR,CEDSEA,CENUMR,CEKBC>
	SETZM CEDSEA		;ASSUME NORMAL MODE
	LDB D,[331100,,(C)]	;SEE WHAT WE GOT
	CAIN D,.CMCFM		;CONFIRM?
	 JRST CEDITU		;YES, EDIT LAST COMMAND
	AOS CEDSEA		;NO, ASSUME SEARCH MODE; ATMBUF CONTAINS STRING
	CAIN D,.CMTXT		;TEXT?
	 SETOM CEDSEA		;YES
	MOVEM B,CENUMR		;SAVE IN CASE OF NUMBER
	CONFIRM

CEDITU::MOVEI A,.CTTRM		;GET OLD MODE WORD
	RFMOD
	PUSH P,B		;SAVE THIS FOR LATER
	TXZ B,TT%IGN		;MAKE SURE IT SEES TT%WAK BITS
	TXO B,TT%WAK		;WAKE ON EVERYTHING
	TXZ B,TT%ECO		;TURN OFF ECHOING
	TXZ B,TT%PGM		;TURN OFF PAGING (^S, ^Q)
	TXZ B,TT%TAB		;SPACES INSTEAD OF TAB
	SFMOD
	STPAR
	MOVE B,[052525,,553125]	;PASS CR, ^I, FORMAT LF, NO NULLS
	MOVE C,[252525,,652400]	;FORMAT ESCAPE
	SFCOC
	MOVEI A,.FHJOB
	SETZ B,			;NO TERMINAL INTERRUPTS
	STIW
	SETZM CELPOS		;INITIALIZE LINE NUMBER
	MOVE A,CELAST		;GET THE FIRST COMMAND POINTER
	MOVEM A,CELPTR		;INITIALIZE FOR CETOP
	SETZM CADLFG		;TELL SEARCH WE ARE IN EDIT MODE
	SKIPE CEDSEA		;SEARCH MODE?
	 CALL CESRCH		;YES, SO BEGIN DEFFERENTLY
	SETZM CEDUMB		;ASSUME SMART TERMINAL
	SKIPN CEFLAG		;EMACS MODE?
	 JRST CETOP		;YES, SIMULATE UP CURSOR
	MOVE A,COJFN		;ALTER MODE, GET TERMINAL TYPE
	GTTYP
	SKIPN EEOLTB(B)		;IS IT SMART?
	 SETOM CEDUMB		;NO
	SETZM CADLFG		;INITIALIZE STUFF
	SETZM CABKFG
	JRST CETOP		;SIMULATE INITIAL UP CURSOR


; SEARCH FOR INITIAL STRING - 
;   CELPTR AND A CONTAINS POINTER TO FIRST COMMAND
;   CELPOS AND CELPTR UPDATED ON RETURN

CESRCH:	SKIPL CEDSEA		;SEARCH MODE OR NUMBER MODE
	 JRST CENUMM		;NUMBER MODE
	MOVE C,A		;BASE STRING HEADER
	MOVE B,[POINT 7,1(C)]	;BASE STRING BYTE POINTER
	MOVE A,[POINT 7,ATMBUF]	;POINT TO THE PREFIX STRING
	STCMP
	SKIPN A			;STRING ARE EQUAL?
	 RET			;YES, SO RETURN
	TXNE A,SC%SUB		;SUBSTRING?
	 RET			;YES, SO RETURN

; GO TO PREVIOUS LINE

	HLRZ A,@CELPTR		;TAKE THE LEFT HAND LINK
	SKIPN A			;CHECK FOR END OF LIST
	 JRST CESRCL		;END OF LIST
	AOS CELPOS		;INCREMENT THE LINE NUMBER
	MOVEM A,CELPTR		;UPDATE POINTER
	JRST CESRCH		;PROCESS THIS LINE

CESRCL:	MOVE A,CELAST		;END OF LIST, GO BACK TO THE FIRST LINE
	MOVEM A,CELPTR		;RESET THE POINTER
	SETZM CELPOS		;RESET LINE NUMBER
	SKIPE CADLFG		;A REDO COMMAND?
	 JRST CESRC1		;YES, DO DIFFERENT
	TYPE <%Prefix not found - editing last command>
	RET

CESRC1:	SETZM CELPTR		;SIGNAL NOT FOUND
	RET


; NUMBER MODE

CENUMM:	SKIPGE C,CENUMR		;ONLY ALLOW POSITIVE NUMBERS
	 RET			;RETURN OTHERWISE POINTING AT CURRENT	
CENUMA:	HLRZ A,@CELPTR		;TAKE THE LEFT HAND LINK
	SKIPN A			;CHECK FOR END OF LIST
	 JRST CENUML		;END OF LIST
	AOS CELPOS		;INCREMENT THE LINE NUMBER
	MOVEM A,CELPTR		;UPDATE POINTER
	SOJG C,CENUMA		;CONTINUE IF MORE TO GO
	RET			;RETURN POINTING TO CURRENT LINE

CENUML:	TYPE <%Requested command line lost - positioning at first command>
	RET


CETOP:	TYPE <
>				;CR
	CALL EEOLN		;ERASE TO END OF LINE
	MOVE A,CELPTR		;POINT TO THE CURRENT LINE
	AOS A			;SKIP PAST THE HEADER
	HLL A,[POINT 7,0]	;MAKE IT A POINTER
	MOVE B,[POINT 7,CETSAV]	;POINT TO THE TEMP BUFFER
CETOP0:	ILDB C,A		;GET NEXT BYTE
	HRRZ D,A		;CHECK FOR WRAP AROUND
	CAIE D,CEBFEN		;TOO FAR?
	 JRST CETOP1		;NO
	MOVE A,[POINT 7,CESAVE]	;YES, RESET THE POINTER
	JRST CETOP0		;AND START OVER

CETOP1:	IDPB C,B		;MOVE IT
	SKIPE C			;END ON NULL BYTE
	 JRST CETOP0		;DO THE REST

	SETZM CECPOS		;INITIALIZE POSITION
	MOVE A,[POINT 7,CETSAV]	;GET A POINTER TO IT
	MOVEM A,CEBPTR		;SAVE IT
	SKIPN CEDUMB		;WRITE LINE FOR DUMB TERMINALS
	 JRST CETOP2
	CALL CENUMB
	MOVE A,CEBPTR
	PSOUT
	TYPE <
>
CETOP2:	TYPE <    >		;MAKE ROOM FOR THE LINE NUMBER
	MOVE A,CEBPTR
	SKIPN CEDUMB		;EMACS OR SMART ALTER MODE?
	 PSOUT			;YES, WRITE IT OUT
	ETYPE <
>		;BACK TO THE BEGINNING
	CALL CENUMB		;WRITE THE NUMBER
	JRST CEINC		;GET COMMAND INPUT CHARACTER




CENUMB:
IFN NICSW,<
	ETYPE < [>
>;IFN NICSW
	MOVEI A,.CTTRM		;OUTPUT LINE# AS "DD:"
	MOVN B,CELPOS		;GET (NEGATIVE) LINE NUMBER
IFE NICSW,<
	JUMPE B,CENUM1		;DO CURRENT LINE DIFFERENT
	MOVE C,[NO%LFL!NO%OOV!NO%AST!FLD(3,NO%COL)!FLD(12,NO%RDX)]
>;IFE NICSW
IFN NICSW,<
	MOVX C,FLD(12,NO%RDX)
>;IFN NICSW
        NOUT
	 JFCL
IFN NICSW,<
	ETYPE <]>
>;IFN NICSW
IFE NICSW,<
        ETYPE <:>
	RET			;ALL DONE

CENUM1:	ETYPE < **:>		;FOR CURRENT LINE
>;IFE NICSW
	RET



; GET THE NEXT INPUT CHARACTER

CEINC:	SKIPN CEFLAG		;EMACS MODE?
	 JRST ECEINC		;YES, DIFFERENT COMMANDS

	SETZ P3,		;ASSUME NO NUMERIC ARGUMENT
ACEINC:	PBIN			;GET ALTER MODE COMMAND
	CAIL A,"0"		;BIGGER THAN 0?
	 CAILE A,"9"		;SMALLER THAT 9?
	  JRST ACEIN1		;NOT A NUMBER, KEEP LOOKING
	IMULI P3,^D10		;NUMBER, UPDATE THE COUNT
	ADD P3,A		;ADD THIS ONE IN
	SUBI P3,"0"		;CONVERT TO BINARY
	JRST ACEINC		;GET THE REST OF THE COMMAND

ACEIN1:	CAIN A,CR		;^M - EXIT AND DO COMMAND
	 JRST CEEXIT
	CAIE A,"E"		;E - EXIT AND DO COMMAND
	 CAIN A,"e"
	  JRST CEEXIT
	CAIN A,.CHCNU		;^U - START OVER
	 JRST CETOP
	CAIN A,.CHLFD		;FL - NEXT LINE
	 JRST CEDOWN
	CAIN A,.CHESC		;ESC - PREVIOUS LINE
	 JRST CEUP
	CAIN A,.CHCNR		;^R - RETYPE LINE
	 JRST CATYPE
	CAIE A,"L"		;^L - TYPE LINE AND START OVER
	 CAIN A,"l"
	  JRST CARTYP
	CAIE A,"P"		;P - RETYPE LINE
	 CAIN A,"p"
	  JRST CATYPE
	CAIE A,"Q"		;Q - ABORT
	 CAIN A,"q"
	  JRST CEQUIT
	CAIN A,.CHCNC		;^C - ABORT
	 JRST CEQUIT
	CAIE A,"D"		;D - DELETE CHARACTERS
	 CAIN A,"d"
	  JRST CADEL
	CAIE A,"H"		;"H" - DELETE TO END, THEN INSERT
	 CAIN A,"h"
	  JRST CAHACK
	CAIE A,"I"		;"I" - ENTER INSERT MODE
	 CAIN A,"i"
	  JRST CAINST

;	CONTINUED ON NEXT PAGE

	CAIE A,"R"		;"R" - DELETE THEN INSERT
	 CAIN A,"r"
	  JRST CADEIN
	CAIE A,"W"		;"W" - MOVE OVER WORDS
	 CAIN A,"w"
	  JRST CAFORW
	CAIE A,"X"		;"X" - EXTEND LINE
	 CAIN A,"x"
	  JRST CAEXTN
	CAIE A,"Z"		;"Z" - DELETE WORDS
	 CAIN A,"z"
	  JRST CADELZ
	CAIN A,":"		;":" - DELETE REST OF LINE
	 JRST CACOLN
	CAIN A,"\"		;"\" - TRANSPOSE PREVIOUS TWO CHARS
	 JRST CETRAN
	CAIN A,.CHDEL		;RUB - MOVE CURSOR LEFT
	 JRST CALEFT
	CAIN A," "		;SPACE - MOVE CURSOR RIGHT
	 JRST CARIGH
	CAIN A,.CHTAB		;TAB - MOVE TO END OF LINE
	 JRST CAEOLN
	CAIN A,"?"		;? - GIVE HELP MESSAGE
	 JRST CAHELP
	CALL CEBELL		;ERROR, RING THE BELL
	JRST CEINC		;TRY AGAIN



;	HERE TO ENTER INSERT MODE

CAINST:	CALL CAFLSH		;FLUSH ANYTHING WE HAD GOING
CANST0:	PBIN			;GET NEXT CHARACTER
	CAIN A,.CHESC		;ESCAPE?
	 JRST CEINC		;YES, EXIT
	CAIN A,.CHTAB		;A TAB?
	 JRST CAINOK		;YES, LET IT PASS
	CAIN A,.CHCNC		;CONTROL C?
	 JRST CEQUIT		;YES, QUIT
	CAIL A," "		;SOME CONTROL CODE?
	 CAIN A,.CHDEL		;OR RUBOUT?
	  SKIPA			;YES, ERROR
	   JRST CAINOK		;ITS OK
	CALL CEBELL		;ERROR, RING BELL
	JRST CANST0		;AND TRY AGAIN

CAINOK:	MOVE C,CEBPTR		;GET THE POINTER
	SKIPE CEDUMB		;DUMP TERMINAL?
	 PBOUT			;YES, DISPLAY THE CHARACTER
CAINS1:	ILDB B,C		;GET ONE THAT WAS THERE
	SKIPN CEDUMB		;SMART TERMINAL?
	 PBOUT			;YES, OUTPUT IT
	DPB A,C			;REPLACE IT
	JUMPE A,CAINS2		;EXIT AFTER A NULL BYTE
	MOVE A,B		;SET UP TO REINSERT THE ONE
	JRST CAINS1
CAINS2:	AOS CECPOS		;UPDATE OUR POSITION
	IBP CEBPTR		;AND OUR POINTER
	SKIPE CEDUMB		;SMART TERMINAL
	 JRST CAINST		;NO, GET SOME MORE
	ETYPE <
>		;POSITION THE CURSOR
	CALL CENUMB		;MOVE PAST THE LINE NUMBER
	MOVE A,COJFN		;POINT TO THE TERMINAL
	HRROI B,CETSAV		;POINT TO THE STRING
	MOVN C,CECPOS		;GET COUNT
	SKIPE C			;DON'T GO FOREVER HERE
	 SOUT			;MOVE PAST THE OLD CHARACTERS
	JRST CAINST		;DONE, GET SOME MORE


;	HERE TO DELETE N CHARACTERS

CADEL:	CALL ALTDEL		;DO ALTER MODE DELETE
	JRST CEINC		;DONE


;	HERE TO DELETE N CHARACTERS THEN INSERT TEXT

CADEIN:	CALL ALTDEL		;DO ALTER MODE DELETE
	CALL CAFLDE		;SIGNAL END OF DELETE
	JRST CAINST		;SO THE INSERT


;	ALTER MODE DELETE ROUTINE

ALTDEL:	MOVE A,CEBPTR
	ILDB B,A
	SKIPN B
	 RET
	CALL CAFLBK		;FLUSH BACKSPACE MARKER
	SKIPG P3		;ZERO OR BAD ARGUMENT?
	 MOVEI P3,1		;YES, MAKE IT THE DEFAULT
	SETZ C,			;NEW COUNTER
	SKIPE CEDUMB		;SMART TERMINAL
	 CALL CADELF		;NO, SIGNAL DELETE
	MOVE B,CEBPTR		;GET THE POINTER
ALTDL1:	ILDB A,B		;GET NEXT CHARACTER
	JUMPE A,ALTD1A		;END?
	AOS C			;NO, INCREMENT COUNT
	SKIPE CEDUMB		;SMART TERMINAL?
	 PBOUT			;NO, ECHO CHARACTER
	SOJG P3,ALTDL1
	JRST ALTDL2
ALTD1A:	SETO A,			;WENT TOO FAR, BACKUP POINTER
	ADJBP A,B
	MOVEM A,B
ALTDL2:	SKIPN C
	 RET
	MOVE A,CEBPTR
ALTDL3:	ILDB C,B		;GET FIRST CHARACTER
	IDPB C,A		;SAVE IN NEW POSITION
	JUMPN C,ALTDL3
	SKIPE CEDUMB		;SMART TERMINAL?
	 RET			;NO, DONE
ALTDL4:	MOVE A,CEBPTR		;REWRITE THE SCREEN
	PSOUT
	CALL EEOLN
	ETYPE <
>		;POSITION THE CURSOR
	CALL CENUMB		;MOVE PAST THE LINE NUMBER
	MOVE A,COJFN		;POINT TO THE TERMINAL
	HRROI B,CETSAV		;POINT TO THE STRING
	MOVN C,CECPOS		;GET COUNT
	SKIPE C			;DON'T GO FOREVER HERE
	 SOUT			;MOVE PAST THE OLD CHARACTERS
	RET


;	HERE TO RETYPE THE LINE

CATYPE:	CALL CAFLSH		;FLUSH EVERYTHING
	SKIPN CEDUMB		;SMART TERMINAL?
	 JRST CEDISP		;YES, THIS IS A JOB FOR EMACS
	MOVE A,CEBPTR		;FINISH THE LINE
	PSOUT
	ETYPE <
>				;GO TO NEW LINE
	JRST	CINST1		;WRITE IT OUT




;	HERE TO FINISH TYPING THE LINE AND START OVER

CARTYP:	CALL CAFLSH
	SETZM CECPOS		;RESET CHARACTER PSOITION
	SKIPN CEDUMB		;SMART TERMINAL?
	 JRST CARTP1		;YES
	MOVE A,CEBPTR		;FINISH THE LINE
	PSOUT
CARTP1:	MOVE A,[POINT 7,CETSAV]	;RESET POINTER
	MOVEM A,CEBPTR
	ETYPE <
>				;NEW LINE
	JRST CETOP2		;AND START OVER





;	HERE TO HACK AND INSERT

CAHACK:	CALL CAFLBK
	SKIPN CEDUMB		;SMART TERMINAL?
	JRST CAHAK1		;YES, DO IT THE EASY WAY
	CALL CADELF		;SIGNAL DELETE
	MOVE A,CEBPTR		;GET THE REST OF THE STRING
	PSOUT			;OUTPUT IT
	TYPE <\\>		;END OF DELETE
	SETZM CADLFG
CAHAK1:	SETZ A,			;CHOP OFF THE REST OF THE STRING
	MOVE B,CEBPTR		;GET COPY OF POINTER
	IDPB A,B		;CURSOR IS ONE POSITION PAST POINTER
	CALL EEOLN		;JUST IN CASE
	JRST CAINST		;START INSERTING



;	HERE TO MOVE OVER WORDS

CAFORW:	CALL CAFLSH
	SKIPG P3
	 MOVEI P3,1
CAFRW1:	CALL F.WORD		;GET COUNT TO NEXT WORD
	ADDM B,CECPOS		;UPDATE POSITION
	MOVN C,B		;GET NEGATIVE COUNT
	MOVE A,COJFN		;MOVE OVER
	MOVE B,CEBPTR
	SKIPE C
	 SOUT			;WRITE IT OUT
	MOVEM B,CEBPTR
	SOJG P3,CAFRW1
	JRST CEINC		;DONE



;	HERE TO DELETE N WORDS

CADELZ:	CALL CAFLBK
	PUSH P,CEBPTR		;SAVE THE POINTER
	SKIPG P3		;ZERO OR NO ARGUMENT?
	 MOVEI P3,1		;YES, MAKE IT THE DEFAULT
	SETZ D,			;KEEP COUNT HERE
CADLZ1:	CALL F.WORD		;GET COUNT TO NEXT WORD
	SUB D,B			;KEEP NEGATIVE COUNT
	ADJBP B,CEBPTR		;UPDATE POINTER
	MOVEM B,CEBPTR
	SOJG P3,CADLZ1
	SKIPE A,CEDUMB		;SMART TERMINAL?
	JRST CADLZ2		;NO.
	MOVE A,CEBPTR		;DESTINATION POINTER
	POP P,CEBPTR		;SOURCE POINTER
	JRST M.FIX		;FIX IT UP
CADLZ2:	CALL CADELF		;SIGNAL DELETE
	MOVE A,COJFN		;WRITE OUT DELETED STUFF
	MOVE B,(P)		;POINT TO DELETED STUFF
	MOVE C,D		;NUMBER OF CHARACTERS
	SKIPE C			;SKIP IF NONE
	 SOUT
	POP P,CEBPTR		;FIX THE POINTER
	MOVE A,CEBPTR
CADLZ3:	ILDB C,B		;GET FIRST CHARACTER
	IDPB C,A		;SAVE IN NEW POSITION
	JUMPN C,CADLZ3
	JRST CEINC		;DONE



;	HERE TO EXTEND THE LINE

CAEXTN:	CALL CAFLSH
	MOVE A,CEBPTR		;GET THE POINTER
	PSOUT			;WRITE IT OUT
	SETO B,			;BACKUP THE POINTER
	ADJBP B,A
	SETZ A,			;GET COUNT TOO
CAXTN1:	ILDB A,CEBPTR		;GET NEXT CHARACTER
	JUMPE A,CAXTN2
	AOS CECPOS		;UPDATE POSITION
	JRST CAXTN1
CAXTN2:	MOVEM B,CEBPTR		;SAVE NEW POINTER
	JRST CAINST		;GO TO INSERT MODE



;	HERE TO JUMP TO THE END OF A LINE

CAEOLN:	CALL CAFLSH
	MOVE A,CEBPTR		;GET POINTER
	PSOUT			;WRITE IT OUT
	SETO B,			;BACK IT UP
	ADJBP B,A
	SETZ A,			;GET COUNT TOO
CAEOL1:	ILDB A,CEBPTR		;GET NEXT CHARACTER
	JUMPE A,CAEOL2
	AOS CECPOS		;UPDATE POSITION
	JRST CAEOL1
CAEOL2:	MOVEM B,CEBPTR		;SAVE NEW POINTER
	JRST CEINC		;DONE



;	HERE TO DELETE THE REST OF THE LINE

CACOLN:	CALL CAFLBK
	SKIPN CEDUMB		;SMART TERMINAL?
	JRST CACLN1		;YES, SKIP THIS
	CALL CADELF		;SIGNAL DELETE
	MOVE A,CEBPTR		;GET POINTER
	PSOUT			;WRITE THE RESTO OF THE STRING
	TYPE <\\>		;SIGNAL NO MORE DELETE
	SETZM CADLFG
CACLN1:	SETZ A,			;CHOP OFF THE REST OF THE STRING
	MOVE B,CEBPTR		;GET COPY OF POINTER
	IDPB A,B		;CURSOR IS ONE POSITION PAST POINTER
	CALL EEOLN		;JUST IN CASE
	JRST CEINC		;ALL DONE



;	HERE TO MOVE TO RIGHT

CARIGH:	CALL CAFLSH
	SKIPG P3		;ARGUMENT OK?
	 MOVEI P3,1		;FIX IT UP
CARIG1:	ILDB A,CEBPTR		;GET NEXT CHARACTER
	JUMPE A,CARIG2		;END OF LINE
	AOS CECPOS		;UPDATE POSITION
	PBOUT			;MOVE OVER
	SOJG P3,CARIG1		;DO THE REST
	JRST CEINC		;DONE

CARIG2:	SETO A,			;WENT TOO FAR
	ADJBP A,CEBPTR		;BACK UP
	MOVEM A,CEBPTR
	JRST CEINC		;DONE





;	HERE TO MOVE TO THE LEFT

CALEFT:	CALL CAFLDE
	SKIPN CECPOS		;BEGINNING OF LINE?
	 JRST CEINC		;YES, SKIP
	SKIPN P3		;NO ARGUMENT?
	 MOVEI P3,1		;MAKE IT A 1
	CAML P3,CECPOS		;ARGUMENT TOO BIG?
	 MOVE P3,CECPOS		;YES, TRIM IT DOWN
	SKIPE CEDUMB		;SMART TERMINAL
	 JRST CALFT1		;NO
	MOVN C,P3		;FIX THE POINTER
	ADJBP C,CEBPTR
	MOVEM C,CEBPTR
	MOVN A,P3		;FIX POSITION
	ADDM A,CECPOS
	JRST CINST1		;POSITION CURSOR

CALFT1:	CALL CABAKF		;SIGNAL BACK MOVEMENT
CALFT2:	LDB A,CEBPTR		;GET THIS CHARACTER
	PBOUT			;OUTPUT IT
	SETO B,			;MOVE THE POINTER BACK
	ADJBP B,CEBPTR		;BACK UP THE POINTER
	MOVEM B,CEBPTR
	SOS CECPOS
	SOJG P3,CALFT2		;DO THE REST
	JRST CEINC		;GET NEXT COMMAND


; ROUTINES TO PRINT \ AND \\ FOR DUMB TERMINAL ALTER MODE


CAFLSH:	CALL CAFLBK		;FLUSH OUT BACKSPACE CHARACTER
	CALL CAFLDE		;FLUSH OUT DELETE CHARACTER
	RET



CAFLBK:	SKIPN CEDUMB
	 RET
	SKIPN CABKFG		;WERE WE BACKSPACING?
	 RET			;NO, NOTHING TO DO
	SETZM CABKFG		;RESET THE FLAG
	TYPE <\>		;SIGNAL END OF BACKSPACE
	RET



CAFLDE:	SKIPN CEDUMB		;DUMB TERMINAL?
	 RET			;YES, RETURN
	SKIPN CADLFG		;WERE WE IN A DELETE?
	 RET			;NO
	SETZM CADLFG		;RESET FLAG
	TYPE <\\>		;SIGNAL END OF DELETE
	RET


CABAKF:	SKIPN CEDUMB
	 RET
	SKIPN CABKFG		;SET?
	ETYPE <\>		;NO, SIGNAL
	SETOM CABKFG		;SET BACKSPACE FLAG
	RET


CADELF:	SKIPN CEDUMB
	 RET
	SKIPN CADLFG		;SET?
	ETYPE <\\>		;NO, SIGNAL
	SETOM CADLFG		;SET DELETE FLAG
	RET


;	EMACS MODE BEGINS HERE

ECEINC:	MOVEI A,.CTTRM		;ALLOW 8 BIT INPUT
	RFMOD			;GET THE MODE WORD
	PUSH P,B		;SAVE IT
	TXZ B,TT%DAM		;BINARY MODE
	SFMOD
	PBIN			;GET EDIT CHARACTER
	POP P,B			;RESTORE MODE WORD
	PUSH P,A		;SAVE CHARACTER
	MOVEI A,.CTTRM
	SFMOD
	POP P,A			;RESTORE CHARACTER
	SKIPN CEMETA		;META KEY IN USE?
	 TRZ A,200		;NO, TRIM PARITY BIT
	TRZE A,200		;META KEY USED?
	 JRST METAN1		;YES, PROCESS IT
	CAIN A,CR		;^M - EXIT AND DO EDITED COMMAND
	 JRST CEEXIT
	CAIN A,.CHCNP		;^P - EDIT PREVIOUS COMMAND
	JRST CEUP
	CAIE A,.CHBEL		;^G - ABORT
	 CAIN A,.CHCNC		;^C - ABORT
	  JRST    CEQUIT
	CAIN A,.CHDEL		;RUBOUT - DELETE CHAR AT LEFT OF CURSOR
	 JRST CERUB
	CAIN A,.CHCNB		;^B - CURSOR LEFT
	  JRST CELEFT
	CAIN A,.CHCNF		;^F - CURSOR RIGHT
	 JRST CERIGH
	CAIN A,.CHCNN		;^N - CURSOR DOWN
	 JRST CEDOWN
	CAIN A,.CHCND		;^D - DELETE CHARACTER AT CURSOR
	 JRST CERMSP
	CAIN A,.CHCNE		;^E - MOVE TO END OF LINE
	 JRST CEMEND
	CAIN	A,.CHCNA	;^A - MOVE TO BEGINNING OF LINE
	 JRST CEBEGN
	CAIN A,.CHVTB		;^K - KILL TO END OF LINE
	 JRST CEKILL
	CAIN A,.CHCNT		;^T - TRANSPOSE CHARACTERS
	 JRST CETRAN
	CAIN A,.CHCNW		;^W - SAME AS M-RUB
	 JRST METARB
	CAIN A,.CHCNY		;^Y - YANK KILL BUFFER
	 JRST CEYANK
	CAIN A,.CHCUN		;^_ - HELP MESSAGE
	 JRST CEHELP
	CAIE A,.CHFFD		;^L - REDISPLAY LINE
	 CAIN A,.CHCNR		;^R - REDISPLAY LINE
	  JRST CEDISP

;	CONTINUED ON NEXT PAGE

	CAIN A,.CHTAB		;TAB - INSERT WITHOUT V
	 JRST CINSRT
	CAIN A,.CHESC		;<ESC> - META PREFIX
	 JRST METAIN
	CAIE A,.CHCNQ		;^Q - TAKE NEXT CHAR LITERALLY
	 CAIN A,.CHCNV		;^V - TAKE NEXT CHAR LITERALLY
	  JRST CRTLV
	CAIGE A," "		;SOME OTHER CONTROL CHARACTER?
	 JRST CEINC		;YES, IGNORE IT
	JRST CINSRT		;INSERT THIS CHARACTER

CRTLV:	PBIN			;GET THE CHARACTER
	JRST CINSRT		;PROCESS IT




; AN ESCAPE HAS BEEN ENTERED, GET THE NEXT COMMAND CHARACTER

METAIN:	PBIN			;GET THE NEXT WORD
METAN1:	CAIE A,"F"		;M-F - FORWARD TO END OF WORD
	 CAIN A,"f"
	  JRST METAF
	CAIE A,"B"		;M-B - BACK TO BEGINNING OF WORD
	 CAIN A,"b"
	  JRST METAB
	CAIE A,"D"		;M-D - DELETE TO END OF WORD
	 CAIN A,"d"
	  JRST METAD
	CAIN A,.CHDEL		;M-RUB - DELETE BACK TO START OF WORD
	 JRST METARB
	CAIN A,.CHESC		;M-ESC - STUFF COMMAND WITH <ESC>
	 JRST METAES
	CAIN A,"?"		;M-? - STUFF COMMAND WITH ?
	 JRST METAQU
	CALL CEBELL		;ERROR, RING BELL
	JRST CEINC		;TRY AGAIN



; HERE TO INSERT A CHARACTER INTO THE COMMAND LINE

CINSRT:	MOVE C,CEBPTR		;GET THE POINTER
CINST:	ILDB B,C		;GET ONE THAT WAS THERE
	DPB A,C			;REPLACE IT
	JUMPE A,CINST0		;EXIT AFTER A NULL BYTE
	PBOUT			;OUTPUT IT
	MOVE A,B		;SET UP TO REINSERT THE ONE
	JRST CINST
CINST0:	AOS A,CECPOS		;UPDATE EVERYTHING
	IBP CEBPTR

CINST1:	MOVE B,CEBPTR		;SEE WHAT WE'RE SUPPOSED TO POINT TO
	ILDB A,B		;IF WE'RE SUPPOSED TO BE AT THE END
	JUMPE A,CEINC		; OF THE LINE, WE'RE ALREADY THERE
	ETYPE <
>		;POSITION THE CURSOR
	CALL CENUMB		;MOVE PAST THE LINE NUMBER
	MOVE A,COJFN		;POINT TO THE TERMINAL
	HRROI B,CETSAV		;POINT TO THE STRING
	MOVN C,CECPOS		;GET COUNT
	SKIPE C			;DON'T GO FOREVER HERE
	 SOUT			;MOVE PAST THE OLD CHARACTERS
	JRST CEINC		;DONE





; MOVE THE CURSOR TO THE LEFT

CELEFT:	SKIPN CECPOS		;AT BEGINNING OF BUFFER?
	JRST CEINC		;YES, DO NOTHING
	LDB C,CEBPTR		;GET CHARACTER WE ARE GOING TO
	SETO B,
	ADJBP B,CEBPTR		;DECR BYTE PTR
	MOVEM B,CEBPTR
	SOS CECPOS		;DECR CHARACTER POSITION
	CAIGE C," "		;SOME CONTROL CHARACTER?
	 JRST CINST1		;YES, DON'T MESS UP
	CALL CEBACK		;BACK UP
	JRST CEINC


; ERASE LAST CHARACTER

CERUB:	SKIPN CECPOS		;AT BEGINNING OF BUFFER?
	 JRST CEINC		;YES, DON'T DO ANYTHING
	MOVE A,CEBPTR		;GET POINTER
	ILDB C,A		;SEE IF WE ARE AT END OF LINE
	SETO A,			;GET A -1
	ADJBP A,CEBPTR		;DECREMENT THE BYTE POINTER
	MOVEM A,CEBPTR		;SAVE IT
	SOS CECPOS		;AND DECREMENT CHARACTER POSITION
	JUMPN C,CERMSP		;IF NOT AT END OF LINE, RETYPE WHOLE THING
	CALL CEBACK		;BACK UP SOME
	JRST CEKILL		;AND KILL REST OF LINE




; MOVE THE CURSOR TO THE END OF THE LINE

CEMEND:	MOVE B,CEBPTR		;SEE IF WE'RE POINTING AT ZERO BYTE
	ILDB A,B
	JUMPE A,CEMND1		;AT END OF LINE, QUIT
	AOS CECPOS
	PBOUT			;MOVE OVER
	JRST CEMEND+1
CEMND1:	MOVNI C,1
	ADJBP C,B
	MOVEM C,CEBPTR		;MAKE BYTE POINTER AGREE WITH CURSOR
	JRST CEINC


; MOVE THE CURSOR TO THE RIGHT

CERIGH:	MOVE B,CEBPTR		;SEE IF WE'RE POINTING AT ZERO BYTE
	ILDB A,B
	JUMPE A,CEINC		;AT END OF BUFFER, DO NOTHING
	PBOUT			;MOVE OVER
	AOS CECPOS		;INCR CHARACTER POSITION
	IBP CEBPTR		;INCREMENT POINTER
	JRST CEINC




; MOVE TO THE NEXT COMMAND LINE

CEDOWN:	HRRZ A,@CELPTR		;TAKE THE RIGHT HAND LINK
	SKIPN A			;CHECK FOR END OF LIST
	 JRST CEDWN1		;NOT AT END, SKIP THIS
	SOS CELPOS		;DECREMENT THE LINE NUMBER
	MOVEM A,CELPTR		;UPDATE POINTER
	JRST CETOP		;PROCESS THIS LINE

CEDWN1:	MOVE A,CE1ST		;END OF LIST, GO BACK TO THE FIRST LINE
	MOVEM A,CELPTR		;RESET THE POINTER
	MOVE A,CECNT		;GET RIGHT LINE NUMBER
	SOS A
	MOVEM A,CELPOS		;SET IT
	JRST CETOP		;PROCESS THIS LINE




; MOVE TO THE PREVIOUS COMMAND LINE

CEUP:	HLRZ A,@CELPTR		;TAKE THE LEFT HAND LINK
	SKIPN A			;CHECK FOR END OF LIST
	 JRST CEUP1		;NOT AT END
	AOS CELPOS		;INCREMENT THE LINE NUMBER
	MOVEM A,CELPTR		;UPDATE POINTER
	JRST CETOP		;PROCESS THIS LINE

CEUP1:	MOVE A,CELAST		;END OF LIST, GO BACK TO THE FIRST LINE
	MOVEM A,CELPTR		;RESET THE POINTER
	SETZM CELPOS		;RESET LINE NUMBER
	JRST CETOP		;PROCESS THIS LINE




; HERE TO DELETE THE CHARACTER AT THE CURSOR

CERMSP: MOVE B,CEBPTR		;GET DESTINATION POINTER
	MOVEI	A,1
	ADJBP   A,CEBPTR	;POINTER TO SOURCE
	LDB     C,A		;ZERO BYTE?
	JUMPE   C,CEINC		;YES, QUIT
	SETZ    C,		;NO, MOVE THE TEXT
	SIN
	ETYPE <
>		;START OVER
	CALL CENUMB		;WRITE THE LINE NUMBER
	HRROI A,CETSAV		;AND THE LINE
	PSOUT
	CALL EEOLN
	JRST CINST1		;POSITION THE CURSOR




; HERE TO MOVE THE CURSOR TO THE BEGINNING OF THE LINE

CEBEGN:	MOVEI A,CETSAV		;FIX POINTER
	HLL A,[POINT 7,0]
	MOVEM A,CEBPTR
	SETZM CECPOS		;RESET POINTER TO BEGINNING OF LINE
	ETYPE <
>		;MOVE CURSOR TO BEGINNING
	CALL CENUMB		;WRITE THE LINE NUMBER
	JRST CEINC		;GET NEXT COMMAND




; HERE TO KILL EVERYTHING TO THE RIGHT OF THE CURSOR

CEKILL:	MOVE A,[POINT 7,CEKBUF] ;POINT TO KILL BUFFER
	MOVE B,CEBPTR		;ANY TO WHAT WE ARE KILLING
	SETZ C,			;AND ON ZERO BYTE
	SOUT			;SAVE IT
	SETZ A,			;CHOP OFF THE REST OF THE STRING
	IDPB A,B		;ADD A NULL TO THE END OF THE KILL BUFFER
	MOVE B,CEBPTR		;GET COPY OF POINTER
	IDPB A,B		;CURSOR IS ONE POSITION PAST POINTER
	CALL EEOLN		;ERASE IT FROM THE SCREEN
	JRST CEINC		;GET NEXT COMMAND




; HERE TO YANK THE KILL BUFFER

CEYANK:	MOVE A,[POINT 7,CEKBUF]	;GET POINTER TO KILL BUFFER
	CALL BCOUNT		;GET NUMBER OF CHARACTERS IN THERE
	MOVEM B,CEKBC		;SAVE IT
	MOVE A,CEBPTR		;GET BUFFER POINTER
	CALL BUFFS		;SAVE THE END OF THE LINE
	MOVE B,A		;SAVE POINTER
	MOVE A,CEKBC		;GET COUNT
	ADJBP A,CEBPTR		;MAKE ROOM FOR THE KILLED TEXT
	SETZ C,			;END ON A ZERO BYTE
	SOUT			;MOVE END OF LINE OVER
	MOVE A,CEBPTR		;GET POINTER TO HOLE
	MOVE B,[POINT 7,CEKBUF]	;AND TO KILLED TEXT
CEYNK1:	ILDB C,B		;GET NEXT BYTE
	SKIPN C			;AT THE END?
	 JRST CEYNK2		;YES
	IDPB C,A		;NO, STORE IT
	JRST CEYNK1		;DO THE REST
CEYNK2:	MOVE B,CEBPTR		;GET POINTER TO REST OF STRING
	MOVE A,COJFN		;PRIMARY OUTPUT
	SOUT			;UPDATE SCREEN
	MOVE A,CEKBC		;GET LENGTH OF ADDED TEXT
	ADDM A,CECPOS		;UPDATE POSITION
	ADJBP A,CEBPTR		;MOVE TO END OF UNKILLED TEXT
	MOVEM A,CEBPTR		;SAVE UPDATED POINTER
	JRST CINST1		;POSITION THE CURSOR




; HERE TO SWAP THE CHARACTER AT THE CURSOR AND THE ONE BEFORE IT

CETRAN:	SKIPN CECPOS		;BEGINNING OF LINE?
	 JRST CEINC		;YES, SKIP
	MOVE B,CEBPTR
	ILDB A,B		;END OF LINE?
	JUMPE A,CEINC
	MOVE B,CEBPTR		;GET LOCAL POINTER
	MOVEI A,1		;SCOOT OVER ONE
	ADJBP A,B
	LDB C,A			;CHANGE THE CHARACTERS IN THE BUFFER
	LDB D,B
	DPB D,A
	DPB C,B
	ETYPE <
>		;REWRITE THE LINE
	CALL CENUMB
	HRROI A,CETSAV
	PSOUT
	JRST CINST1		;POSITION CURSOR


; HERE TO MOVE TO THE BEGINNING OF THE NEXT WORD

METAF:	CALL F.WORD		;GET DESTINATION
	ADDM B,CECPOS		;UPDATE POSITION
	JUMPE B,CEINC		;NO MOVEMENT, STOP
	MOVE C,B		;NUMBER OF CHARACTERS TO MOVE
	ADJBP B,CEBPTR		;UPDATE POINTER
	PUSH P,B		;SAVE IT
	MOVE B,CEBPTR		;START OF WHAT WE WANT TO TYPE
	MOVE A,COJFN		;PRIMARY OUTPUT
	SOUT			;PRINT OVER ONE WORD
	POP P,CEBPTR		;UPDATE POINTER
	JRST CEINC		;MOVE CURSOR OVER



; HERE TO MOVE TO THE BEGINNING OF THE PREVIOUS WORD

METAB:	CALL B.WORD		;GET DESTINATION
	JUMPE B,CEINC		;SKIP IF NO MOVEMENT
	MOVNS B			;MAKE IT NEGATIVE
	MOVE C,B		;GET A COPY OF IT
	ADJBP C,CEBPTR		;UPDATE THE POINTER
	MOVEM C,CEBPTR
	ADDM B,CECPOS		;UPDATE POSITION
	JRST CINST1		;UPDATE CURSOR

METAB1:	PUSH P,B		;SAVE NUMBER OF CHARACTERS TO BACK UP
	CALL CEBACK		;BACK UP ONE
	POP P,B			;GET COUNT BACK
	AOJN B,METAB1		;DECREMENT COUNT
	JRST CEINC		;POSITION CURSOR



; HERE TO DELETE UP TO THE BEGINNING OF THE NEXT WORD

METAD:	CALL F.WORD		;GET DESTINATION
	MOVE A,B		;GET COPY OF OFFSET
	ADJBP A,CEBPTR		;POINTER TO DESTINATION
	JRST M.FIX		;MOVE EVERYTHING


; HERE TO DELETE BACK TO THE BEGINNING OF THE PREVIOUS (OR THIS) WORD

METARB:	SKIPN CECPOS		;AT THE BEGINNING OF THE LINE?
	 JRST CEINC		;YES, DONT DO THIS
	MOVE A,CEBPTR		;GET POINTER
	ILDB B,A		;AT THE END OF THE LINE?
	PUSH P,B		;SAVE LAST CHARACTER
	CALL B.WORD		;GET DESTINATION
	MOVN D,B		;MAKE IT NEGATIVE
	MOVE A,D
	ADDM A,CECPOS		;FIX UP POSITION
	ADJBP A,CEBPTR		;GET DESTINATION POINTER
	EXCH A,CEBPTR		;FOOL M.FIX - WE ARE NOW A M-D
	POP P,B			;GET CHAR WE SAVED
METAR1:	JUMPE D,METAR2		;NEED TO MOVE THE CURSOR OVER
	PUSH P,A		;SAVE THE POINTER
	CALL CEBACK		;BACK UP
	POP P,A			;RESTORE THE POINTER
	AOJA D,METAR1
METAR2:	JUMPE B,CEKILL		;IF WE'RE AT EOL, JUST KILL IT




; HERE TO FIX THINGS UP AFTER METAD, METARB, OR ALTER MODE DELETE

M.FIX:	PUSH P,A		;A HAS END OF WORD TO STUFF IN KILL BUFFER
	MOVE B,CEBPTR		;B HAS START OF IT
	MOVE D,[POINT 7,CEKBUF]	;POINT TO KILL BUFFER
	CAMN A,B		;DOING ANYTHING?
	 JRST M.FIX3		;NO, DON'T LOOP FOREVER
M.FIX2:	ILDB C,B		;GET A CHARACTER OF DELETED STRING
	IDPB C,D		;SAVE IT IN THE KILL BUFFER
	CAME A,B		;SAVED ALL OF THE WORD YET?
	 JRST M.FIX2		;NO, DO NEXT CHARACTER
	SETZ C,			;GET A NULL BYTE
	IDPB C,D		;TIE OFF THE KILL BUFFER
M.FIX3:	POP P,B			;GET COPY OF DESTINATION POINTER
	SKIPN CEDUMB		;EMACS OR SMART ALTER?
	 PSOUT			;YES, OVERWRITE THE SCREEN
	CALL EEOLN		;CLEAN THINGS UP
	MOVE A,CEBPTR		;GET CURRENT POINTER
M.FIX1:	ILDB C,B		;GET FIRST CHARACTER
	IDPB C,A		;SAVE IN NEW POSITION
	JUMPN C,M.FIX1		;DONE?
	JRST CINST1		;POSITION THE CURSOR


; SUBROUTINE TO RETURN NUMBER OF SPACES UNTIL START OF NEXT WORD

F.WORD:	SETZ B,			;INITIALIZE COUNT
	MOVE C,CEBPTR		;GET LOCAL COPY OF POINTER
	ILDB A,C		;GET THIS CHARACTER
	JUMPE A,[RET]		;END OF LINE, QUIT
	CAIL A,"0"
	 CAILE A,"9"
	  SKIPA
	   JRST F.WRD2
	CAIL A,"A"
	 CAILE A,"Z"
	  SKIPA
	   JRST F.WRD2
	CAIL A,"a"
	 CAILE A,"z"
	  SKIPA
	   JRST F.WRD2
F.WRD1:	ILDB A,C		;GET NEXT CHARACTER
	AOS B			;UPDATE COUNT
	JUMPE A,[RET]		;END OF LINE
	CAIL A,"0"
	 CAILE A,"9"
	  SKIPA
	   JRST F.WRD2
	CAIL A,"A"
	 CAILE A,"Z"
	  SKIPA
	   JRST F.WRD2
	CAIL A,"a"
	 CAILE A,"z"
	  SKIPA
	   JRST F.WRD2
F.WRD2:	ILDB A,C		;GET NEXT CHARACTER
	AOS B			;INCREMENT COUNT
	JUMPE A,[RET]		;END OF LINE
	CAIL A,"0"
	 CAILE A,"9"
	  SKIPA
	   JRST F.WRD2
	CAIL A,"A"
	 CAILE A,"Z"
	  SKIPA
	   JRST F.WRD2
	CAIL A,"a"
	 CAILE A,"z"
	  SKIPA
	   JRST F.WRD2
	RET			;YES, DONE.


; SUBROUTINE TO RETURN NUMBER OF SPACES UNTIL START OF PREVIOUS WORD

B.WORD:	SETZ B,			;INITIALIZE COUNT
	MOVE C,CEBPTR		;GET LOCAL COPY OF POINTER
	MOVE D,CECPOS		;LOCAL COPY OF POSITION
	JUMPE D,[RET]		;BEGINNING OF LINE, EXIT
	ILDB A,C		;GET THIS CHARACTER
	CAIL A,"0"
	 CAILE A,"9"
	  SKIPA
	   JRST B.WRD0
	CAIL A,"A"
	 CAILE A,"Z"
	  SKIPA
	   JRST B.WRD0
	CAIL A,"a"
	 CAILE A,"z"
	  SKIPA
	   JRST B.WRD0
	JRST B.WRD1		;NO, IN THE MIDDLE OF A WORD
B.WRD0:	LDB A,CEBPTR		;GET WORD BEFORE THIS ONE
	CAIL A,"0"
	 CAILE A,"9"
	  SKIPA
	   JRST B.WRD2
	CAIL A,"A"
	 CAILE A,"Z"
	  SKIPA
	   JRST B.WRD2
	CAIL A,"a"
	 CAILE A,"z"
	  SKIPA
	   JRST B.WRD2

;	CONTINUED ON NEXT PAGE

B.WRD1:	SETO A,			;BACKUP THE POINTER
	ADJBP A,C
	MOVE C,A
	LDB A,C			;GET NEXT ONE
	SOS D			;UPDATE COUNT
	AOS B			;UPDATE THIS TOO
	JUMPE D,[RET]		;CHECK FOR BEGINNING OF LINE
	CAIL A,"0"
	 CAILE A,"9"
	  SKIPA
	   JRST B.WRD2
	CAIL A,"A"
	 CAILE A,"Z"
	  SKIPA
	   JRST B.WRD2
	CAIL A,"a"
	 CAILE A,"z"
	  SKIPA
	   JRST B.WRD2
	JRST B.WRD1
B.WRD2:	SETO A,			;BACKUP THE POINTER
	ADJBP A,C
	MOVE C,A
	LDB A,C			;GET NEXT CHARACTER
	SOS D			;UPDATE EVERYTHING
	AOS B
	JUMPE D,[RET]		;CHECK FOR BEGINNING OF LINE
	CAIL A,"0"
	 CAILE A,"9"
	  SKIPA
	   JRST B.WRD2
	CAIL A,"A"
	 CAILE A,"Z"
	  SKIPA
	   JRST B.WRD2
	CAIL A,"a"
	 CAILE A,"z"
	  SKIPA
	   JRST B.WRD2
	SOS B			;ADJUST IF NOT BEGINNING OF LINE
	RET			;ALL DONE


; HERE TO STICK AN ESCAPE OR QUESTION MARK ON THE END OF THE COMMAND

METAES:	SKIPA B,[.CHESC]	;STUFF ESCAPE WITH THE COMMAND
METAQU:	MOVEI B,"?"		;STUFF ? WITH THE COMMAND
METAEQ:	ILDB A,CEBPTR		;LOOK FOR THE END OF THE LINE
	JUMPE A,METEQ1
	JRST METAEQ		;TRY AGAIN
METEQ1:	DPB B,CEBPTR		;STUFF THE NEW CHARACTER
	IDPB A,CEBPTR		;ADD A ZERO BYTE
	MOVEI C,CETSAV		;STUFF LINE HERE WITH NO CR AT END
	HRLI C,440700		;MAKE A POINTER
	MOVEI A,.CTTRM
	CFIBF			;CLEAR THE TYPE AHEAD
METEQ2:	ILDB B,C		;GET NEXT CHAR
	JUMPE B,CEQUIT
	STI			;STUFF IT
	 ERJMP STIBAD
	JRST METEQ2



; HERE WHEN DONE. STUFF THE EDITED COMMAND INTO THE TERMINALS INPUT BUFFER

CEEXIT:	MOVEI C,CETSAV		;POINT TO CURRENT LINE
	HRLI C,440700
	MOVEI A,.CTTRM		;GET THE TERMINAL DESIGNATOR
	CFIBF
CEEX2:	ILDB B,C		;GET NEXT CHAR
	JUMPE B,CEEX3		;END ON A ZERO BYTE
	STI			;STUFF IT
	 ERJMP STIBAD
	JRST    CEEX2		;DO THE REST

CEEX3:	MOVEI B,CR
	STI
	 ERJMP STIBAD

CEQUIT: MOVEI Q1,ETTYMD		;LOAD EXEC TTY MODES
	CALL LTTYMD
	MOVEI A,.CTTRM		;RESTORE PAGE MODE IF WE NEED TO
	POP P,B
	STPAR
	SETOM CEBPTR		;DON'T SAVE THIS
	ETYPE <
>
	RET



; ROUTINE TO REDISPLAY THE LINE

CEDISP:	ETYPE <
>				;GO TO A NEW LINE
	CALL EEOLN		;JUST TO BE SURE
	CALL CENUMB		;DO THE LINE NUMBER
	HRROI A,CETSAV		;POINT TO COMMAND LINE
	PSOUT			;WRITE IT OUT
	JRST CINST1		;POSITION THE CURSOR




; HERE WHEN STI FAILS BECAUSE THE TERMINAL INPUT BUFFER IS FULL AND
; WE CAN'T READ TO TAKE ANY OF IT OUT BECAUSE WE'RE TOO BUSY PUTTING
; MORE STUFF IN SO WE WIND UP WITH AN ILLEGAL INSTRUCTION TRAP WITH
; INTERRUPTS DISABLED AND TERMINAL ECHO TURNED OFF.
;
; STIBAD: ENTRY FROM COMMAND EDITOR (RESET TTY MODES WHEN DONE)
; STIBDX: ENTRY FROM/REDO COMMAND

STIBAD:	SKIPA C,[CEQUIT]	;WANT TO RESTORE TTY MODES
STIBDX:	MOVEI C,AGAIN3		;DON'T RESTORE TTY MODES OR SAVE COMMAND
	ETYPE <%@?Can't stuff - Command line too long>
	MOVEI A,.PRIIN		;FLUSH THE BUFFER
	CFIBF
	JRST (C)		;GO FINISH UP AND RETURN TO PROMPT

	

; ROUTINE TO SEND A BELL TO THE TERMINAL

CEBELL:	MOVE A,COJFN		;REDO THE CCOC
	RFCOC
	PUSH P,B		;SAVE MODE
	TLC B,1B32!1B33		;SEND ACTUAL CODE
	SFCOC
	MOVEI B,.CHBEL		;SEND THE BELL
	BOUT
	POP P,B			;RESTORE
	SFCOC
	RET


; ROUTINE TO BACK THE CURSOR UP ONE PLACE

CEBACK:	MOVE A,COJFN		;GET THE TERMINAL TYPE
	RFMOD			;GET MODE WORD
	PUSH P,B		;SAVE IT
	TXZ B,TT%DAM		;NO TRANSLATION
	SFMOD
	GTTYP
	CAIG B,BCOPMX		;ALL WE KNOW ABOUT NOW
	SKIPN A,BCOPTB(B)	;GET STRING TO DUMP
	 JRST CEBAK2		;NONE - DO NOTHING
	TLNN A,-1		;STRING OR PNTR?
	 TLOA A,-1		;PNTR TO TEXT
	  HRROI A,EEOLTB(B)	;STRING - POINT TO IT INSTEAD
	PSOUT			;DUMP IT
CEBAK2:	MOVE A,COJFN		;RESTORE MODE WORD
	POP P,B			;GET OLD MODE
	SFMOD			;DO IT
	RET



; ROUTINE TO ERASE ALL CHARACTERS TO THE END OF LINE

EEOLN:	PUSH P,A		;SAVE THIS
	PUSH P,B		;THIS TOO
	MOVE A,COJFN		;CURRENT OUTPUT JFN
	RFMOD			;GET MODE WORD
	PUSH P,B		;SAVE IT
	TXZ B,TT%DAM		;NO TRANSLATION
	SFMOD
	GTTYP			;GET TERMINAL TYPE
	CAIG B,EOLNMX		;ALL WE KNOW ABOUT NOW
	SKIPN A,EEOLTB(B)	;GET STRING TO DUMP
	 JRST EEOLN2		;NONE - DO NOTHING
	TLNN A,-1		;STRING OR PNTR?
	 TLOA A,-1		;PNTR TO TEXT
	  HRROI A,EEOLTB(B)	;STRING - POINT TO IT INSTEAD
	PSOUT			;DUMP IT
EEOLN2:	MOVE A,COJFN		;RESTORE MODE WORD
	POP P,B			;GET OLD MODE
	SFMOD			;DO IT
	POP	P,B		;RESTORE THIS
	POP	P,A		;THIS TOO
	RET

;	ERASE TO END OF LINE TABLE

EEOLTB:	0			;(0)TTY33
	0			;(1) TTY35
	0			;(2) TTY37
	0			;(3) TI/EXECUPORT
	0			;(4) ADM-3
	BYTE (7).CHCNW,0	;(5) DATAMEDIA-2500
	BYTE (7).CHESC,"K",0	;(6) HP264x
	BYTE (7)"~",.CHCNO,0	;(7) HAZELTINE-1500
	0			;(8) TERMINET
	0			;(9) IDEAL
	BYTE (7)36,0		;(10) VT05
	BYTE (7).CHESC,"K",0	;(11) VT50
	0			;(12) LA30
	0			;(13) GT40
	0			;(14) LA36
	BYTE (7) .CHESC,"K",0	;(15) VT52
	BYTE(7).CHESC,"[","K",0	;(16) VT100
	0			;(17) LA38
	0			;(18) LA120
	0			;(19) MOD 43
	BYTE (7) .CHESC,"T",0	;(20) SOROC IQ120
	BYTE (7) .CHCBS,0	;(21) GILLOTINE
	BYTE (7) .CHESC,"K",0	;(22) TELERAY 1061
	0			;(23) TEKTRONIX 4025
	0			;(24) ANN ARBOR
	BYTE (7) .CHESC,"K",0	;(25) HEATH H19
	BYTE (7) .CHESC,25,0	;(26) CONCEPT 100
	0			;(27) IBM 3101
	BYTE (7) .CHESC,"T",0	;(28) TELEVIDEO 912
	0			;(29) TEKTRONIX 4023
	BYTE (7) .CHCRB,0	;(30) DATAMEDIA 1520
	BYTE (7) .CHESC,"[","K",0 ;(31) AMBASSADOR
	BYTE (7) .CHCNP,.CHCNU,0	;(32)DTC-382
	0			;(33) UNUSED
	0			;(34) UNUSED
	BYTE (7) .CHESC,"[","K",0 ;(35) VT125
	BYTE (7) .CHESC,"[","K",0 ;(36) VK100-GIGI
	0			;(37) UNUSED
	0			;(38) UNUSED
	0			;(39) UNUSED
	BYTE (7) 177,5,0	;(40) IMLAC (LM2)
	BYTE (7) 177,5,0	;(41) IMLAC (3600)
	BYTE(7).CHESC,"[","K",0	;(42) WYSE-75
EOLNMX== .-EEOLTB-1

;	BACK UP CURSOR ONE PLACE TABLE
BCOPTB:	BYTE (7).CHBSP,0	;(0)TTY33
	BYTE (7).CHBSP,0	;(1) TTY35
	BYTE (7).CHBSP,0	;(2) TTY37
	BYTE (7).CHBSP,0	;(3) TI/EXECUPORT
	BYTE (7).CHBSP,.CHSPC,.CHBSP,0 ;(4) ADM-3
	BYTE (7).CHBSP,0	;(5) DATAMEDIA-2500
	BYTE (7).CHBSP,0	;(6) HP264x
	BYTE (7).CHBSP,0	;(7) HAZELTINE-1500
	BYTE (7).CHBSP,0	;(8) TERMINET
	BYTE (7).CHBSP,0	;(9) IDEAL
	BYTE (7).CHBSP,0	;(10) VT05
	BYTE (7).CHBSP,0	;(11) VT50
	BYTE (7).CHBSP,0	;(12) LA30
	BYTE (7).CHBSP,0	;(13) GT40
	BYTE (7).CHBSP,0	;(14) LA36
	BYTE (7).CHBSP,0	;(15) VT52
	BYTE(7).CHESC,"[","D",0	;(16) VT100
	BYTE (7).CHBSP,0	;(17) LA38
	BYTE (7).CHBSP,0	;(18) LA120
	BYTE (7).CHBSP,0	;(19) MOD 43
	BYTE (7).CHBSP,.CHSPC,.CHBSP,0 ;(20) SOROC IQ120
	BYTE (7) .CHCNA,0	;(21) GILLOTINE
	BYTE (7) .CHBSP,0	;(22) TELERAY 1061
	BYTE (7).CHBSP,0	;(23) TEKTRONIX 4025
	BYTE (7).CHBSP,0	;(24) ANN ARBOR
	BYTE (7) .CHBSP,0	;(25) HEATH H19
	BYTE (7) .CHBSP,0	;(26) CONCEPT 100
	BYTE (7) .CHESC,"D",0	;(27) IBM 3101
	BYTE (7) .CHBSP,0	;(28) TELEVIDEO 912
	BYTE (7).CHBSP,.CHSPC,.CHBSP,0 ;(29) TEKTRONIX 4023
	BYTE (7).CHBSP,.CHSPC,.CHBSP,0 ;(30) DATAMEDIA 1520
	BYTE (7) .CHESC,"[","D",0 ;(31) AMBASSADOR
	BYTE (7) .CHBSP,0	;(32)HAZELTINE ESPRIT
	BYTE (7).CHBSP,.CHSPC,.CHBSP,0 ;(33) FREEDOM-100
	0			;(34) UNUSED
	BYTE (7) .CHESC,"[","D",0 ;(35) VT125
	BYTE (7) .CHESC,"[","D",0 ;(36) VK100-GIGI
	0			;(37) UNUSED
	0			;(38) UNUSED
	0			;(39) UNUSED
	BYTE (7) .CHBSP,0	;(40) IMLAC (LM2)
	BYTE (7) .CHBSP,0	;(41) IMLAC (3600)
	BYTE(7).CHESC,"[","D",0	;(42) WYSE-75
BCOPMX== .-BCOPTB-1



;	ROUTINE TO TYPE A HELP MESSAGE FOR EMACS MODE


CEHELP:	CALL BLANK1		;CLEAR THE SCREEN
	HRROI A,EMSHLP		;POINT TO THE STRING
	PSOUT			;WRITE IT OUT
	JRST CEDISP		;REDISPLAY THE LINE

EMSHLP:	ASCIZ /
This is the Emacs mode command editor.  To exit, type a Control-G.

Return		Execute edited command
Control-N	Edit the next command line
Control-P	Edit the previous command line
Control-F	Move forward one character
Control-B	Move back one character
Control-L	Redisplay the command line
Control-E	Move to the end of the line
Control-A	Move to the beginning of the line
Control-T	Swap the character at the cursor with the one before it
Control-D	Delete the character at the cursor
Control-K	Delete everything to the right of the cursor
Control-Y	Yank text from kill buffer
Control-Q	Quote the next character for insert
Rubout		Delete the character to the left of the cursor
Escape  F	Move to the beginning of the next word
Esc B	(M-B)	Move to the beginning of the previous word
Esc D	(M-D)	Delete up to the beginning of the next word
Esc Rub	(M-Rub)	Delete back to the beginning of the previous word
Esc Esc	(M-Esc)	Add an Escape to the end of the command and exit
Esc ?	(M-?)	Add a question mark to the end of the command and exit
others		Insert this character at the cursor /



; ROUTINE TO TYPE HELP MESSAGE FOR ALTER MODE

CAHELP:	CALL BLANK1		;TRY TO BLANK THE SCREEN
	HRROI A,ALTHLP		;POINT TO THE STRING
	PSOUT			;WRITE IT OUT
	JRST CETOP

ALTHLP:	ASCIZ /
This is the Alter mode command editor.

Return		Execute edited command
E		Execute edited command
Q		Return to command level
Line Feed	Edit the next command line
Escape		Edit the previous command line
Control-U	Ignore editing up to now and start over
I		Enter insert mode (exit with an escape)
nSPACE		Move forward n characters
nRUB		Move back n characters
nW		Move forward n words
Tab		Move to the end of the line
X		Move to the end of the line and enter insert mode
Control-L	Redisplay the command line, move cursor to beginning
Control-R	Redisplay the command line, stay at current cursor position
P		Redisplay the command line, stay at current cursor position
\		Swap the character at the cursor with the one before it
nD		Delete n characters at the cursor
nR		Delete n characters then enter insert mode
:		Delete everything to the right of the cursor
H		Delete the rest of the line and enter insert mode/



;	COMMAND EDIT INTERRUPT ROUTINE

.CEPSI::SKIPN CLF		;AT COMMAND LEVEL?
	 DEBRK			;NO, DON'T DO THIS
	SKIPE .P		;DO WE HAVE A SAVED STACK POINTER?
	 MOVE P,.P		;YES, RESTORE IT
	CALL RLJFNS		;RELEASE PARSED JFN'S
	MOVE A,[POINT 7,CBUF]	;LOOK AT THE COMMAND BUFFER
	ILDB B,A		;GET THE NEXT CHARACTER
	JUMPN B,.-1		;KEEP LOOKING FOR A NULL
	SETO C,			;FOUND IT
	ADJBP C,A		;BACK UP ONE CHARACTER
	MOVEI A,.PRIIN		;LOOK AT THE TERMINAL
	SIBE			;ANYTHING THERE?
	 JRST [	MOVE A,C	;YES, ADD IT TO THE BUFFER
		MOVE B,[RD%RIE+^D80]
		SETZ C,		;NO PROMPT, QUIT WHEN TTY BUFFER IS EMPTY
		RDTTY		;GET IT
		 ETYPE <%_%%Can not find rest of command, Continuing>
		IDPB C,A	;ASCIZ THE STRING
		JRST .+1 ]	;READY TO GO NOW
	CALL CSAVE		;SAVE THE COMMAND IN PROGRESS
	PUSH P,P		;SAVE THE STACK POINTER

	TRVAR <CADLFG,CEDUMB,CABKFG,CELPOS,CECPOS,CELPTR,CEDSEA,CENUMR,CEKBC>
	SETZM CEDSEA		;INITIALIZE STUFF
	CALL CEDITU		;GO TO THE EDITOR
	POP P,P			;FLUSH THE TRVARS
	MOVE A,LEV1PC		;GET THE RETURN ADDRESS
	HRRI A,CMDIN4		;CHANGE IT
	TXO A,PC%USR		;RETURN TO USER CODE
	MOVEM A,LEV1PC		;RESTORE FIXED PC
	DEBRK			;PARSE EDITED COMMAND


;	"SET INTERRUPT-CHARACTER (FOR COMMAND EDITOR TO) CHAR" COMMAND

.SCEIC::NOISE (for command editor to)
	STKVAR <ICHAR>		;CHARACTER TO INTERRUPT ON
	MOVEI B,CEICLS		;POINT TO THE LIST
	CALL FLDSKP		;GET THE CHARACTER
	 JRST [ ETYPE <%@?Character not available%_>
		RET ]
	HRRZ C,1(C)		;POINT TO THE STRING
	LDB B,[POINT 7,(C),13]	;GET THE CHARACTER
	TXZ B,1B29!1B30		;MAKE IT A CONTROL CHARACTER
	MOVEM B,ICHAR		;SAVE IT
	NOISE (for command editor)
	CONFIRM			;CONFIRM THE COMMAND
	SKIPL A,CEPSIC		;GET THE OLD CHARACTER
	 DTI			;IF ONE WAS ASSIGNED THEN DEASSIGN IT
	HRLZ A,ICHAR		;GET THE NEW ONE
	HLRZM A,CEPSIC		;SAVE IT
	HRRI A,^D31		;SET THINGS UP
	ATI			;ASSIGN NEW INTERRUPT CHARACTER
	RET			;DONE


.SNCEI::NOISE (for command editor)
	CONFIRM			;COMFIRM "SET NO INTERRUPT-CHARACTER"
	SKIPGE A,CEPSIC		;DO WE HAVE ONE?
	 RET			;NO, QUIT
	DTI			;WE HAD ONE, DEASSIGN IT
	SETOM CEPSIC		;SAY WE DON'T HAVE ONE
	RET			;DONE


;	COMMAND EDIT INTERRUPT CHARACTER LIST

CEICLS:	FLDDB. .CMTOK,CM%SDH,<POINT 7,[ASCIZ .^@.]>,,,Z1
Z1:!	FLDDB. .CMTOK,CM%SDH,<POINT 7,[ASCIZ .^A.]>,,,Z2
Z2:!	FLDDB. .CMTOK,CM%SDH,<POINT 7,[ASCIZ .^a.]>,,,Z3
Z3:!	FLDDB. .CMTOK,CM%SDH,<POINT 7,[ASCIZ .^B.]>,,,Z4
Z4:!	FLDDB. .CMTOK,CM%SDH,<POINT 7,[ASCIZ .^b.]>,,,Z5
Z5:!	FLDDB. .CMTOK,CM%SDH,<POINT 7,[ASCIZ .^D.]>,,,Z6
Z6:!	FLDDB. .CMTOK,CM%SDH,<POINT 7,[ASCIZ .^d.]>,,,Z7
Z7:!	FLDDB. .CMTOK,CM%SDH,<POINT 7,[ASCIZ .^G.]>,,,Z8
Z8:!	FLDDB. .CMTOK,CM%SDH,<POINT 7,[ASCIZ .^g.]>,,,Z9
Z9:!	FLDDB. .CMTOK,CM%SDH,<POINT 7,[ASCIZ .^H.]>,,,Z10
Z10:!	FLDDB. .CMTOK,CM%SDH,<POINT 7,[ASCIZ .^h.]>,,,Z11
Z11:!	FLDDB. .CMTOK,CM%SDH,<POINT 7,[ASCIZ .^K.]>,,,Z12
Z12:!	FLDDB. .CMTOK,CM%SDH,<POINT 7,[ASCIZ .^k.]>,,,Z13
Z13:!	FLDDB. .CMTOK,CM%SDH,<POINT 7,[ASCIZ .^N.]>,,,Z14
Z14:!	FLDDB. .CMTOK,CM%SDH,<POINT 7,[ASCIZ .^n.]>,,,Z15
Z15:!	FLDDB. .CMTOK,CM%SDH,<POINT 7,[ASCIZ .^P.]>,,,Z16
Z16:!	FLDDB. .CMTOK,CM%SDH,<POINT 7,[ASCIZ .^p.]>,,,Z17
Z17:!	FLDDB. .CMTOK,CM%SDH,<POINT 7,[ASCIZ .^Q.]>,,,Z18
Z18:!	FLDDB. .CMTOK,CM%SDH,<POINT 7,[ASCIZ .^q.]>,,,Z19
Z19:!	FLDDB. .CMTOK,CM%SDH,<POINT 7,[ASCIZ .^S.]>,,,Z20
Z20:!	FLDDB. .CMTOK,CM%SDH,<POINT 7,[ASCIZ .^s.]>,,,Z21
Z21:!	FLDDB. .CMTOK,CM%SDH,<POINT 7,[ASCIZ .^X.]>,,,Z22
Z22:!	FLDDB. .CMTOK,CM%SDH,<POINT 7,[ASCIZ .^x.]>,,,Z23
Z23:!	FLDDB. .CMTOK,CM%SDH,<POINT 7,[ASCIZ .^Y.]>,,,Z24
Z24:!	FLDDB. .CMTOK,CM%SDH,<POINT 7,[ASCIZ .^y.]>,<Control character,
	Written as ^X>

	END

