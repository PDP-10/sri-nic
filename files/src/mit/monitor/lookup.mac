; UPD ID= 280, SNARK:<4.1.MONITOR>LOOKUP.MAC.12,  20-Feb-80 09:15:41 by MILLER
;MORE TCO 4.2603. IMPROVE CODE
; UPD ID= 275, SNARK:<4.1.MONITOR>LOOKUP.MAC.11,  19-Feb-80 10:34:45 by MILLER
;TCO 4.2603. REMOVE ILSTP3 BUGHLT
;<OSMAN.MON>LOOKUP.MAC.1, 10-Sep-79 15:41:25, EDIT BY OSMAN
;TCO 4.2412 - Move definition of BUGHLTs, BUGCHKs, and BUGINFs to BUGS.MAC
;<4.MONITOR>LOOKUP.MAC.9, 13-Aug-79 17:04:16, EDIT BY DBELL
;TCO 4.2393 - FIX NAMSTP TO NOT LOOK AT DIRORA FOR NON-DISK DEVICES
;<4.MONITOR>LOOKUP.MAC.8, 21-Mar-79 13:02:47, EDIT BY BOSACK
;BE NOINT DURING FREE STG MANIPULATIONS IN DEVSTEP
;<4.MONITOR>LOOKUP.MAC.7, 12-Mar-79 10:30:54, Edit by KONEN
;MODIFY CODE IN DEVSTP TO USE CHKMNO INSTEAD OF CHKMNT
;<4.MONITOR>LOOKUP.MAC.6,  4-Mar-79 18:14:37, EDIT BY KONEN
;UPDATE COPYRIGHT FOR RELEASE 4
;<KONEN>LOOKUP.MAC.3,  7-Jul-78 15:35:39, Edit by KONEN
;WHEN STEPPING THRU STRUCTURES, MAKE SURE USER HAS MOUNTED IT
;<4.MONITOR>LOOKUP.MAC.3, 14-Oct-78 00:34:48, EDIT BY DBELL
;CHANGE CHKWLD SO IT CAN BE CALLED AT ALTERNATE ENTRY POINT FOR WILD% JSYS
;<4.MONITOR>LOOKUP.MAC.2,  6-Jul-78 09:38:29, Edit by HEMPHILL
;MAKE DEVSTP INTERNAL
;<4.MONITOR>LOOKUP.MAC.1,  5-Jul-78 16:56:49, Edit by HEMPHILL
;FIX DEVSTP TO CHANGE STRUCTURE NAME INSTEAD OF LEAVING IT AS PS:


;THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY ONLY BE USED
;  OR COPIED IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
;COPYRIGHT (C) 1976,1977,1978,1979 BY DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.

	SEARCH PROLOG
	TTITLE LOOKUP
	SWAPCD

;SPECIAL AC DEFINITIONS USED HEREIN

DEFAC (STS,P1)			;SEE GTJFN FOR FUNCTIONS
DEFAC (JFN,P2)
DEFAC (DEV,P4)
DEFAC (F1,P5)

; Name lookup
; Call:	A		; Iowd # full words in string,1st word of string
;			; OR 0 IF STEPPING
;	FLAG NREC	; =1 for no partial string recognition
;	FILOPT(JFN)	; Should address the last byte of input
;	CALL NAMLUK	; For recognition
; Or
;	CALL NAMLKX	; For no recognition
; Return
;	+1	; Match is impossible
;	+2	; Ambiguous
;	+3	; Match, the complete string replaces the input
; A contains address of fdb for the first file of the name
; B contains the location of the pointer whose rh points to the fdb
; Clobbers a,b,c,d, and bits norec1, mtchf, and ambgf

NAMLKX::TQOA <NREC1>		; Enter here for recognition
NAMLUK::TQZ <NREC1>
	SE1CAL
	TQZA <UNLKF>
NAMLUU:	TQO <UNLKF,NREC1>
	TQZ <MTCHF,AMBGF>
	TQNE <ASTF>		; If output stars
	JRST NAMLO1		;OUTPUT STARS
	PUSH P,A		; Save a
	TXNE F1,STRSF!DIRSF!NAMSF	;STEPPING?
	JRST NAMSTP		; Yes.
	LOAD A,FILUC,(JFN)	;GET COMPOSITE DIR NUMBER
	HRLZ A,A		;FROM UNIQUE CODE AND
	HRR A,FILDDN(JFN)	;directory number of this file
	HLRZ B,DEV
	SETZ C,			; NO MASK BLOCK
	HRRZ D,DEV		; GET ADDRESS ONLY
	CALL @DLUKD(D)		; Map the directory, and lock it
	 JRST [	TQO <NNAMF>	; Nameless device
		POP P,A
		TQNN <UNLKF>	; Null name and no directory
		JRST SK2RET	; Yields success if normal lookup
		RETSKP]		; And single skip if called from extluk
	 JRST NAMFAI		;FAILURE, RETURN ERROR CODE
	POP P,A
	HRRZ D,DEV
	CALLRET @NLUKD(D)	; Continue with device dependent portion

;THIS ROUTINE WAS AN ATTEMPT TO FIX A COMND BUG THAT DID
;NOT SUCCEED. IT HAS BEEN REMOVED SINCE IT FIXED NOTHING AND
;BROKE PARSE ONLY GTJFN.

   REPEAT 0,<
NAMLKO:	JUMPE A,NAMLO1		;IF STEPPING, ALLOW THIS
	HRRZ C,A		;GET POINTER TO NAME STRING
	MOVE C,1(C)		;GET FIRST WORD OF FILE NAME
	HRRZ D,DEV		;GET DEVICE TABLE INDEX
	CAIN D,DSKDTB		;DSK?
	TLNE C,774000		;NULL NAME?
   >				;END OF REPEAT 0
NAMLO1:	SKIPA A,FILFDB(JFN)	;NO, RETURN FDB TO CALLER
	RETBAD (GJFX33)		;NULL NAME IS NOT ALLOWED
	TQNN <UNLKF>
	JRST SK2RET		; Then always give gooD return
	RETSKP

NAMSTP:	TQNE <STEPF>
	TQO <NAMXF>
	TQNE <STEPF>
	TQNE <NAMSF>		; Is name to be stepped?
	JRST NAMST1		; Yes.
NAMST4:	LOAD A,FILUC,(JFN)	;BUILD COMPOSITE DIRECTORY
	HRLZ A,A		;NUMBER FROM UNIQUE CODE AND
	HRR A,FILDDN(JFN)	;directory number
	HLRZ B,DEV		;GET UNIT NUMBER (IF RELAVENT)
	TQNE <STEPF>
	TQO <DIRXF>
	LOAD C,FILDMS,(JFN)	;GET ADR OF WILD MASK IF ANY
	HRRZ D,DEV
	CALL @DLUKD(D)		; Step directory
	 JRST NAMFAI		; Stepping nameless device fails
	 JRST NAMS3B		; NO DIRECTORIES LEFT
	HRRM A,FILDDN(JFN)	;SAVE THE DIR NUMBER
	HRRZ A,DEV		;SEE IF THIS IS A DISK
	CAIE A,DSKDTB		;WELL?
	JRST NAMST8		;NO, THEN DON'T LOOK AT DIRECTORIES
	MOVE A,DIRORA		;GET POINTER TO DIR NAME STRING
	LOAD A,DRNAM,(A)	;FROM MAPPED DIRECTORY
	ADD A,DIRORA		;GET ABSOLUTE ADDRESS
	CALL STORDN		;STORE THE NAME IN THE JFN BLOCK
	 JRST NAMFAI		;IT FAILED TO GET ENOUGH ROOM
NAMST8:	TQNN <STEPF>		; STEPPING DIRECTORY?
	JRST NAMST2		; NO
	LOAD A,FILDMS,(JFN)	;GET DIRECTORY WILD MASK
	JUMPE A,[TQNN <NAMSF>	;STEPPING THE NAME?
		SKIPE 0(P)	;NO. WANT TO SET DIR ONLY?
		JRST NAMST2	;GO FIND NAME
		HRRZ B,DEV	;SEE IF THIS IS A DSK
		CAIN B,DSKDTB	;IF NOT, DONT UNLOCK DIR
		CALL USTDIR	;FREE DIR
		JRST NOWLDN]	;AND DONE
	HRRZ A,DEV		;ADDRESS ONLY
	HRRZ A,DLUKD(A)		;MAKE SURE IT REALLY WORKED
	CAIE A,MDDDIR		;DID IT?
	JRST [	MOVEI A,GJFX17	;NO
		JRST NAMFAI]	;GO GIVE AN ERROR
	LOAD A,FILDMS,(JFN)	;RESTORE THE MASK POINTER
	CALL CHKDIR		; SEE IF IT IS THE CORRECT DIRECTORY
	 JRST NAMST4		;NOT CORRECT. GO TRY AGAIN
	TQNN NAMSF		;STEPPING NAME?
	SKIPE 0(P)		;NO. IS THERE A REAL NAME?
	JRST NAMST1		;YES. GO FINISH UP
	JRST NOWLDN		;NO. ALL DONE. RETURN THIS DIRECTORY


NAMST1:	PUSH P,F1
	TQZ <STEPF>
	LOAD A,FILUC,(JFN)	;BUILD FULLWORD DIR NUMBER
	HRLZ A,A		; ...
	HRR A,FILDDN(JFN)	; ...
	HLRZ B,DEV
	SETZ C,
	HRRZ D,DEV
	CALL @DLUKD(D)		; Set directory
	 JRST NAMFA1
	 JRST NAMFA1
	AND F1,[EXTXF!NAMXF!DIRXF]
	IORM F1,(P)
	POP P,F1
NAMST2:	MOVE A,(P)		; Get lookup pointer
	MOVE C,FILOPT(JFN)	; GET FILOPT
	TQNE <NAMSF>		;STEPPING NAME
	MOVEM C,0(P)		; AND SAVE IT
NAMST7:	HRRZ D,DEV
	CALL @NLUKD(D)		; Step the name
	 JRST NAMST3		; No more
	 JRST NAMST3		; AMBIGUOUS. TREAT AS NON-EX
	TQNN <STEPF>		; STEPPING NAME?
	JRST NOWLDN		; NO
	LOAD A,FILNMS,(JFN)	;HAVE A MASK FOR THE NAME?
	JUMPE A,NOWLDN		;IF ZERO NO
	PUSH P,B		; SAVE FDB ADDRESS
	MOVE B,A		; FOR THE COMPARE
	MOVE A,-1(P)		;THE STRING
	HRLI A,(<POINT 7,0,35>)	;MAKE IT A POINTER
	CALL CHKWLD		;SEE IF IT IS A MATCH
	 JRST [	POP P,(P)	;DONT NEED FDB ANYMORE
		CALL FIXCMN	; DO COMMON FIXUP
		TQNE <UNLKF>	; DID IT UNLOCK THE DIR?
		JRST NAMST7	;AND GO STEP AGAIN
		MOVEM A,0(P)	; YES. SAVE THIS PLACE
		JRST NAMST1]	; AND GO TO SET DIR AGAIN
	POP P,B			; RESTORE FDB ADDRESS
NOWLDN:	SUB P,BHC+1		; CLEAN UP THE STACK
	TQZ <STEPF>
	JRST SK2RET		; Double skip

NAMST3:	TQNN <DIRSF>		; ABLE TO STEP DIRECTORY
NAMS3B:	JRST [	CALL DEVSTP	;NO, SEE IF STR CAN BE STEPPED
		 JRST NAMFAI	;NO, GIVE FAILURE RETURN
		JRST NAMS3A]	;STR WAS STEPPED
	TQO <STEPF>
NAMS3A:	TQNE <NAMSF>
	SETZM (P)		; Cause first name to be set
	JRST NAMST4

NAMFA1:	POP P,F1
NAMFAI:	SUB P,BHC+1
	SE1CAL
	RET

;ROUTINE TO STEP TO NEXT STRUCTURE IF ANY

DEVSTP::TQNN <STRSF>		;IS STEPPING ALLOWED FOR STRUCTURES?
	RETBAD (GJFX32)		;NO, TAKE ERROR RETURN
	HRRZ B,FILDEV(JFN)	;SEE IF THIS IS THE DSK
	CAIE B,DSKDTB		;STEPPING IS ONLY ALLOWED FOR STR'S
	RETBAD (GJFX32)		;NOT A DSK, TAKE ERROR RETURN
DEVST1:	INCR STR,(JFN)		;STEP TO NEXT STRUCTURE
	LOAD A,STR,(JFN)	;GET STR NUMBER
	CAIL A,STRN		;IS THIS A LEGAL NUMBER?
	JRST DEVSTE		;NO, NO MORE STRUCTURES
	CALL STRCNV		;GET UNIQUE CODE FOR THIS STR
	 JRST DEVST1		;NO SUCH STRUCTURE
	STOR A,FILUC,(JFN)	;STORE NEW UNIQUE CODE
	CALL CHKMNO		;CHECK IF USER MOUNTED THIS STRUCTURE
	 JRST DEVST1		;NO, GET NEXT ONE
	NOINT			;INTERLOCK POSSIBLE BLOCK CHANGE
	HLRZ A,FILDDN(JFN)	;GET POINTER TO OLD STRUCTURE NAME
	CALL CNVSIX		;REPLACE IT WITH NEW STRUCTURE NAME
	 RETBAD (,<OKINT>)	;CAN'T, TAKE ERROR RETURN
	HRLZM A,FILDDN(JFN)	;STORE NEW POINTER, ZERO DIRECTORY NUMBER
	OKINT			;POINTER SAFE NOW
	TQNN <DIRSF>		;STEPPING DIRECTORIES ALSO?
	JRST [	CALL SDIRN	;NO, SET UP THE NEW DIR # OF THIS DIR
		 JRST DEVST1	;THERE IS NONE ON THIS STR
		RETSKP]		;DONE
	TQO <DIRXF>		;MARK THAT THE DIR CHANGED
	RETSKP			;SUCCESSFULLY STEPPED TO NEXT STR

DEVSTE:	DECR STR,(JFN)		;LEAVE STR POINTING TO A LEGAL STR
	RETBAD (GJFX32)		;NO MORE STR'S TO STEP TO

; Extension lookup
; Call:	RH(FILDDN(JFN))	; The directory number
;	LH(FILNEN(JFN))	; The file name string block location
;	LH(A)		; Minus number of full words in string
;	RH(A)		; Location of first word of string -1
;	FILOPT(JFN)	; Location of last byte of input if recognition
;	CALL EXTLUK	; For recognition
; Or
;	CALL EXTLKX	; For no recognition
; Return
;	+1	; Error, no match
;	+2	; Ambiguous
;	+3	; Match
;	A	; Location of fdb of first version
;	B	; Location of pointer to fdb  in a
; Directory locked
; Clobbers a,b,c,d,filopt(jfn), and bits mtchf, ambgf, norec1

EXTLUK::TQZA <NREC1>
EXTLKX::TQO <NREC1>
	TQZA <UNLKF>
EXTLUU::TQO <UNLKF,NREC1>
	SE1CAL
	TQNE <ASTF>
	JRST [	MOVE A,FILFDB(JFN) ;RETURN ANY FDB TO CALLER
		TQNN <UNLKF>
		JRST SK2RET
		RETSKP]
	PUSH P,A
	TQNN <EXTSF>
	TXNE F1,STRSF!DIRSF!NAMSF	;STEPPING?
	JRST EXTSTP		; Stepping
	PUSH P,F1
	CALL EXTNLK		; Get pointer to fdb for this name
	 JRST [	SUB P,BHC+2
		RET]		; ????? name wasn't there!!!!!
	 JRST [	POP P,F1
		POP P,A
		TQNN <UNLKF>
		JRST SK2RET
		RETSKP]
	POP P,F1		; Restore f1
	TQZ <MTCHF,AMBGF>
	POP P,A
	HRRZ D,DEV
	CALLRET @ELUKD(D)	; Continue with device dependent portion

EXTSTP:	TQNE <STEPF>
	TQO <EXTXF>
	TQNE <STEPF>
	TQNE <EXTSF>		; Stepping extension?
	JRST EXTST1		; Yes.
EXTST4:	PUSH P,FILOPT(JFN)
	HLRZ A,FILNEN(JFN)
	ADD A,[POINT 7,0,35]
	MOVEM A,FILOPT(JFN)
	PUSH P,F1
	CALL EXTNLK
	 JFCL
	 JRST [	POP P,F1
		POP P,FILOPT(JFN)
		JRST EXTFAI]	; Failed
	AND F1,[EXTXF!NAMXF!DIRXF]
	IORM F1,(P)
	POP P,F1
	POP P,FILOPT(JFN)
	JRST EXTST2

EXTST1:	PUSH P,F1
EXTST8:	TQZ <STEPF>
	CALL EXTNLK		; Lookup name for this file
	 JFCL
	 JRST [	POP P,F1
		JRST EXTFAI]
	POP P,F1
	; ..

	; ..
EXTST2:	MOVE A,(P)
	MOVE C,FILOPT(JFN)	; GET FILOPT
	TQNE <EXTSF>		; STEPPING EXTENSION?
	MOVEM C,0(P)		; YES SAVE IT
EXTST7:	HRRZ D,DEV
	CALL @ELUKD(D)
	 JRST EXTST3		; No more extensions
	 JRST EXTST3		; AMBIGUOUS. TREAT AS NON-EX
	TQNN <STEPF>		; STEPPING EXTENSION?
	JRST NOWLDE		; NO
	LOAD A,FILEMS,(JFN)	; SEE IF A MASK
	JUMPE A,NOWLDE		; IF ZERO, NO.
	PUSH P,B		; SAVE THE FDB
	MOVE B,A		; GET MASK TO B
	MOVE A,-1(P)		; GET BASE OF STRING
	HRLI A,(<POINT 7,0,35>)	; FORM SP TO STRING
	CALL CHKWLD		; SEE IF A MATCH
	 JRST [	POP P,B		; GET FDB OF NONMATCH
		CALL FIXCMN	; DO COMMON FIXUP
		TQNE <UNLKF>	; DID IT UNLOCK THE DIR?
		JRST EXTST7	; GO STEP THE EXTENSION
		MOVEM A,0(P)	; YES. SAVE THIS PLACE
		JRST EXTST1]	; AND GO SET DIR AGAIN
	POP P,B			; USE THIS FDB
NOWLDE:	SUB P,BHC+1		; CLEAR OUT FILOPT,OLD ARG
	TQZ <STEPF>
	JRST SK2RET		; Success

EXTST3:	TXNN F1,DIRSF!NAMSF	;STEPPING?
	JRST [	CALL DEVSTP	; SEE IF THE STRUCTURE CAN BE STEPPED
		 JRST EXTFAI	; NO, GIVE ERROR RETURN
		JRST .+1]	; STR WAS STEPPED, GO TRY AGAIN
	TQNE <EXTSF>
	SETZM (P)
	TQO <STEPF>
	JRST EXTST4

EXTNLK:	HLRZ A,FILNEN(JFN)
	CALL FIXSTR		; MAKE UP ARG FOR LOOKUP ROUTINE
	CALLRET NAMLUU

EXTFAI:	SUB P,BHC+1
	RETBAD (GJFX19)

; Get pointer to an fdb
; Call:	LH(FILDDN(JFN))	; Device name block location
;	RH(FILDDN(JFN))	; Directory number
;	LH(FILNEN(JFN))	; File name block location
;	RH(FILNEN(JFN)	; Extension block location
;	RH(FILVER(JFN))	; File version number
;	CALL GETFDB
; Return
;	+1	; Not found - FDB OF NON-EXISTENT FDB IN A IF ANY
;	+2	; Found, a has location of the fdb
; Leaves directory locked and psi off
; Clobbers a,b,c,d

GETFDB::SE1CAL
	SKIPN FILFDB(JFN)	;HAVE AN FDB YET?
	TQNN <ASTF>
	SKIPA			;OKAY
	 BUG(ASTJFN)
	SAVEAC <F,F1>		;SAVE FILE SYS AC'S
	HRRZ A,DEV		;GET ADDRESS
	HRRZ F,NLUKD(A)
	CAIE F,MDDNAM
	BUG(MDDJFN)
	CALL FSTGFB		; TRY TO USE FDB ADR IN FILFDB(JFN)
	 SKIPA			; THAT FDB ADR IS BAD
	JRST GETFD1		; FDB ADR IS GOOD
	SETZM FILFDB(JFN)	; CLEAR OUT FDB ADDRESS
	HRRZ A,FILVER(JFN)	; Get the version number in a
	MOVX F,OLDNF!IGDLF
	TQO <NREC>
	TLZ F1,-1
	CALL VERLKX
	 RET			;NONE THERE
	JUMPE A,R		;MAKE SURE ONE RETURNED
	MOVEM A,FILFDB(JFN)	; SAVE THE FDB ADDRESS
GETFD1:	RETSKP

;SPECIAL ENTRY GIVING ARGS IN TEMP REGISTERS:
;	T1/ JFN

GETFDT::SE1CAL
	SAVEPQ			;SAVE REGISTERS
	MOVE JFN,T1		;MOVE JFN
	SETZB F1,STS		;NOTHING INTERESTING
	HRRZ DEV,FILDEV(JFN)	;SET UP DEV POINTER
	CALLRET GETFDB		;GO DO IT

; Version lookup
; Call:	LH(FILDDN(JFN))	; Device name block location
;	RH(FILDDN(JFN))	; Directory number
;	LH(FILNEN(JFN))	; File name block location
;	RH(FILNEN(JFN)	; Extension block location
;	A		; Version number to find 0 => most recent
;			; -1 => next higher than most recent
;	CALL VERLUK
; Return
;	+1	; Not found
;	+2	; Found, a points to the pertinent fdb
; Leaves directory locked and psi off if successfull
; Clobbers a,b,c,d

VERLKX:	TQOA <UNLKF>
VERLUK::TQZ <UNLKF>
	SE1CAL
	TQNE <ASTF>
	JRST [	MOVE B,FILFDB(JFN) ;RETURN ANY FDB
		RETSKP]		;RETURN GOOD
	PUSH P,A		; Preserve a
	TQNN <VERSF,EXTSF>
	TXNE F1,NAMSF!DIRSF!STRSF	; STEPPING?
	JRST VERSTP		; YES, Stepping
	PUSH P,F1		; Save f1, since extluu will clobber
	CALL VERELK		; Lookup extension (name directory etc)
	 JRST [	SUB P,BHC+2
		RET]
	 JRST [	POP P,F1
		POP P,(P)
		TQNN <UNLKF>	; FROM VERLUK?
		RETSKP		; YES. A NO NAME DEVICE THEN
		RET]
	POP P,F1
	POP P,A			; Restore version to look up
	HRRZ D,DEV
	CALLRET @VLUKD(D)

VERSTP:	TQNE <STEPF>
	TQNE <VERSF>		; Stepping versions?
	JRST VERST1
VERST4:	PUSH P,FILOPT(JFN)
	HRRZ A,FILNEN(JFN)
	ADD A,[POINT 7,0,35]
	MOVEM A,FILOPT(JFN)
	PUSH P,F1
	CALL VERELK
	 JFCL
	 JRST [	POP P,F1
		POP P,FILOPT(JFN)
		JRST VERFAI]	; Failure
	AND F1,[EXTXF!NAMXF!DIRXF]
	IORM F1,(P)
	POP P,F1
	POP P,FILOPT(JFN)
	JRST VERST2

VERST1:	PUSH P,F1
	TQZ <STEPF>
	CALL VERELK		; Find the extension
	 JRST [	POP P,F1
		JRST VERFAI]
	 JRST 	[MOVX T1,DESX9	; INVENT AN APPROPRIATE ERROR
		POP P,F1
		JRST VERFAI]	; AND GIVE ERROR
	POP P,F1
VERST2:	MOVE A,(P)
	HRRZ D,DEV
	CALL @VLUKD(D)		; Step the version
	 JRST VERST3		; None left
	SUB P,BHC+1
	TQZ <STEPF>
	RETSKP			; Success

VERST3:	TXNN F1,EXTSF!NAMSF!DIRSF
	JRST [	CALL DEVSTP	; SEE IF STR CAN BE STEPPED
		 JRST VERFAI	; NO, GIVE FAILURE RETURN
		JRST .+1]	;STR WAS STEPPED
	MOVNI A,2		; SET UP FOR STAR VERSION
	TQNE <VERSF>
	MOVEM A,0(P)		; TO FIND OLDEST VERSION
	TQO <STEPF>
	JRST VERST4

VERELK:	HRRZ A,FILNEN(JFN)
	CALL FIXSTR		; MAKE UP ARG FOR LOOKUP ROUTINE
	CALLRET EXTLUU

VERFAI:	SUB P,BHC+1
	RET


;SUBROUTINE TO COMPARE A STRING TO A WILD-CARD STRING.
;ARGS:	T1/  BYTE POINTER TO STRING TO BE CHECKED
;	T2/  BYTE POINTER TO WILDCARD STRING
;	T3/  [ INSTRUCTION TO GET CHAR OF WILD STRING INTO Q1 USING T2
;	       INSTRUCTION TO GET CHAR OF TEST STRING INTO Q1 USING T1 ]
;	T4/  NOT CHANGED, CAN BE USED AS INDEX AC IN BYTE POINTERS
;
;RETURNS +1:	T1/ 0	  NO MATCH
;		T1/ -1	  NO MATCH, BUT STRING IS SUBSET OF WILD STRING
;
;	 +2:	TEST STRING IS MATCHED BY WILD STRING.
;
;CALL AT CHKWLD FOR MOST APPLICATIONS, WHERE IT SETS UP DEFAULT STUFF.



CHKWLD::TLNN T2,-1		;WERE WE GIVEN ONLY AN ADDRESS?
	HRLI T2,(POINT 7,0,35)	;YES, MAKE POINTER TO NEXT WORD
	MOVEI T3,[ILDB Q1,T2	;POINT TO INSTRUCTIONS TO LOAD CHARACTERS
		  ILDB Q1,T1]	;FROM NORMAL MONITOR SPACE


CHKWLS::SAVEQ			;SAVE SOME AC'S
	STKVAR <SVPTR,SVMSK>	;ALLOCATE STORAGE
	SETZB Q2,SVMSK		;INITIALIZE OLD CHAR AND MASK

CHKWLL:	XCT 0(T3)		;GET NEXT CHAR OF MASK
	JUMPE Q1,[CAIN Q2,"*"	;DID WILD STRING END IN ASTERISK
		RETSKP		;YES, STRINGS MATCH
		XCT 1(T3)	;GET NEXT CHAR FROM TEST STRING
		JUMPN Q1,FAIL	;IF NOT ALSO DONE, STRETCH MASK
		RETSKP]		;OTHERWISE STRINGS MATCH
	MOVE Q2,Q1		;SAVE NEWEST CHAR FOR LATER USE
	CAIN Q2,"*"		;FULL WILDCARD?
	JRST [	MOVEM T1,SVPTR	;YES, REMEMBER CURRENT POINTERS
		MOVEM T2,SVMSK	;IN CASE WE HAVE TO STRETCH MASK
		JRST CHKWLL]	;CONTINUE
	XCT 1(T3)		;GET NEXT CHAR OF TEST STRING
	JUMPE Q1,RETO		;IF NO MORE, PARTIAL MATCH
	CAME Q1,Q2		;CHARACTERS FROM THE TWO STRINGS MATCH?
	CAIN Q2,WLDCHR		;OR IS THIS THE SINGLE WILDCARD CHAR?
	JRST CHKWLL		;YES, CONTINUE

FAIL:	SKIPN T2,SVMSK		;WAS THERE A PREVIOUS ASTERISK?
	JRST RETZ		;NO, THEN STRINGS DON'T MATCH
	IBP SVPTR		;YES, ADVANCE THE TEST STRING POINTER
	MOVE T1,SVPTR		;GET NEW POINTER
	JRST CHKWLL		;TRY AGAIN

;COMMON ROUTINE TO MAKE UP DEVICE DEPENDENT ARGUMENT POINTER
;FROM THE STRING POINTED TO BY A

FIXSTR:	PUSH P,B		; MUST NOT CLOBBER B
	PUSH P,A		; SAVE IT
	HRLI A,(<POINT 7,0,35>)	;MAKE A STRING POINTER
	ILDB B,A		;GET A BYTE
	JUMPN B,.-1		;CYCLE UNTIL THE NULL
	HRRZ B,(P)		;GET START
	SUBI B,-1(A)		;CALCULATE NUMBER OF WORDS
	POP P,A			;GET BASE
	HRL A,B			;COUNT
	POP P,B			;RESTORE B
	RET			;AND DONE

;COMMON FIX UP LOGIC FOR FAILURES TO CHKWLD

FIXCMN:	MOVE A,-1(P)		; THE VALUE
	HRLI A,(<POINT 7,0,35>)
	MOVEM A,FILOPT(JFN)	; NEW POINTER
	MOVEI A,(A)
	CALLRET FIXSTR		; GO DO ARG STUFF

;THIS ROUTINE IS CALLED BY THE DIRECTORY STEPPING LOGIC IN NAMLUK
;TO SEE IF THE DIRECTORY SPECIFIED IN FILDDN MATCHES THE WILD MASK
;IN FILDMS
;IF A MATCHING DIRECTORY IS FOUND, FILDIR(JFN) IS UPDATED WITH
;  THE NEW DIRECTORY NAME

CHKDIR:	CALL USTDIR		;FREE DIR
	HRRZ A,FILDDN(JFN)	;GET DIRECTORY NUMBER
	LOAD B,FILUC,(JFN)	;GET STR NUMBER
	HRL A,B			;BUILD A 36 BIT DIRECTORY NUMBER
	CALL GDIRST		;GET NAME
	 RETBAD()		;FAILED. RETURN CODE
	PUSH P,A		;SAVE POINTER
	NOINT			;PREVENT INTERRUPTIONS
	CALL USTDIR		;FREE UP DIRECTORY
	POP P,A			;RESTORE POINTER TO DIRECTORY
	MOVE D,A
	MOVE A,[POINT 7,0(D),34] ;SET UP STRING POINTER
	LOAD B,FILDMS,(JFN)	; GET THE MASK
	CALL CHKWLD		; GO COMPARE THEM
	 RETBAD (,OKINT)	; NO MATCH. RETURN ERROR
	OKINT			; GOOD
	RETSKP			; A MATCH

	TNXEND
	END
