;[MIT-XX]SSY:<MONITOR.M5>MEXEC.MAC.3, 25-Mar-84 14:22:31, Edit by BERLIN
;3054 Fix 3053 so it might work
;[MIT-XX]SSY:<MONITOR.M5>MEXEC.MAC.2, 22-Mar-84 21:45:54, Edit by TEK
;3053 make remote lines hangup on LOGOUT/DETACH
;[MIT-XX]PS:<BERLIN.M5>MEXEC.MAC.26, 28-Feb-83 16:23:57, Edit by BERLIN
;3032 ISI merge Assume no IMP if no MULTInet
;	Save reason going down for IMP
;	Shut off networks when we go down
;	Don't call IMICHK due to startup race
;	Don't hang up TVT's
;	But hang up all others for MICOM port selector
;[MIT-XX]SSY:<BERLIN.M5>MEXEC.MAC.23, 20-Jan-83 16:39:56, Edit by ROBERT
;3024 Print out [hostname going down...] instead of [system going down...]
;<BERLIN.M5>MEXEC.MAC.21,  9-Oct-82 04:05:39, Edit by BERLIN
;3007 Turn off FINGR jsys for now
;<BERLIN.M5>MEXEC.MAC.19,  7-Oct-82 16:22:31, Edit by BERLIN
;3005 Add FINGR jsys
;<BERLIN.M5>MEXEC.MAC.18,  5-Oct-82 21:09:44, Edit by JTW
;3003 Add MYCHAD to GETAB tables
;<BERLIN.M5>MEXEC.MAC.17, 14-Sep-82 15:01:19, Edit by BERLIN
;1023 Doin't print row of *** for bugxxx
;<BERLIN.M5>MEXEC.MAC.12, 30-Aug-82 21:40:47, Edit by BERLIN
;1017 NETHST moved to extended section (GETAB)
;1002 Revoke to old way of answering "Why reload?"
;1001 Multinet merge
;	Remove calls to IMPBEG etc., MNTCHK now done by seperate fork
;	Put a clzff at sjlgo4 to get rid of possible bad interactions with the
;	upt from doing it after upmapping pages
;	CHAOSnet changes
;	Changes for multinet, add some routines for GETAB tables,
;	call MNTINI at RUNDD
;	CHKR calls IMICHK to prevent buffer lockups
;1000 V5 merge
;	Announce [system going down] only if <= 24 hours away

;257 Open accounting file in FROZEN instead of RESTRICTED mode
;256 Add NETHST table for finger to use
;243 If logged into CTY, can shut down system
;241 Add entry to logout accounting block for per-job page traps
;169 Prettier going down messages (hours and minutes)
;163 Reduce period of disk-space annoyances to 30 mins.
;149 Ignore UXXFAI if debugging
;133 no "Why reload?" if dbugsw <> 0
;99 SUPDUP is here
;16 Terminal type setting fix
;15 Bring system up standalone if CHECKD finds many disk errors
;14 Only WHEEL (not OPR) can enter MDDT
;13 Increase length of shutdown message
;12 Report estimated up-time on going-down message
;7 Various GETAB fork tables added
;6 Add GTBLT jsys

; UPD ID= 555, SNARK:<5.MONITOR>MEXEC.MAC.69,  20-Mar-82 19:41:30 by PAETZOLD
;TCO 5.1766 - Turn on FH%EPN in PMAP call in SJLGO4.  PM%EPN does not work.
; UPD ID= 535, SNARK:<5.MONITOR>MEXEC.MAC.68,  12-Mar-82 14:40:21 by PAETZOLD
;TCO 5.1753 - Turn on PM%EPN in PMAP call in logout code.  Prevents PAGLCKs
; UPD ID= 497, SNARK:<5.MONITOR>MEXEC.MAC.67,   4-Mar-82 13:56:46 by MURPHY
;TCO 5.1744 - Refers to changes made approx June, 1980.  Make default
;  settings of system messages more like release 4.
; UPD ID= 481, SNARK:<5.MONITOR>MEXEC.MAC.66,  23-Feb-82 11:08:38 by MILLER
;TCO 6.1054. Complete merges from rel. 6
; UPD ID= 440, SNARK:<5.MONITOR>MEXEC.MAC.65,  25-Jan-82 00:01:42 by MURPHY
;TCO 5.1697 - XSSEV%, etc.  Move GETPAT and GETDMS to FORK.MAC
; UPD ID= 407, SNARK:<5.MONITOR>MEXEC.MAC.64,  18-Jan-82 10:37:36 by MILLER
;TCO 5.1678 again. Enhance check in ATACH for specific TTY designator
; UPD ID= 404, SNARK:<5.MONITOR>MEXEC.MAC.63,  15-Jan-82 16:24:28 by MILLER
;More TCO 5.1678. Check for same job number
; UPD ID= 399, SNARK:<5.MONITOR>MEXEC.MAC.62,  15-Jan-82 13:41:30 by MILLER
;TCO 5.1678. Make detach of object job in ATACH race-free.
; UPD ID= 393, SNARK:<5.MONITOR>MEXEC.MAC.61,  13-Jan-82 12:10:44 by MILLER
;TCO 6.1054. ADD GTOKM IN ATTACH.
; UPD ID= 386, SNARK:<5.MONITOR>MEXEC.MAC.60,   9-Jan-82 18:30:36 by MILLER
;TCO 5.1661. Unlatch MOS cotrollers after TGHA runs
; UPD ID= 331, SNARK:<5.MONITOR>MEXEC.MAC.59,  30-Nov-81 14:00:13 by MOSER
;TCO 5.1614 MAKE CJ%ETF WORK WITH CJ%FIL.
; UPD ID= 247, SNARK:<5.MONITOR>MEXEC.MAC.58,   6-Oct-81 15:21:24 by MOSER
;MORE TCO 5.1512 FIX A BUG.
; UPD ID= 222, SNARK:<5.MONITOR>MEXEC.MAC.57,  28-Sep-81 16:20:34 by PAETZOLD
;TCO 5.1544 - CORRECT CALCULATION FOR UPPER LIMIT OF VBOOT GROUP IN GSMDSK
; UPD ID= 209, SNARK:<5.MONITOR>MEXEC.MAC.56,  23-Sep-81 13:41:05 by MURPHY
;DITTO
; UPD ID= 187, SNARK:<5.MONITOR>MEXEC.MAC.55,  16-Sep-81 17:50:34 by MURPHY
;TCO 5.1514 - Start SYSERR fork earlier in RUNDD so messages from FE don't pile up.
; UPD ID= 184, SNARK:<5.MONITOR>MEXEC.MAC.54,  16-Sep-81 12:09:35 by SCHMITT
;More TCO 4.1051 - Remove definition of USGMUP, it is in STG
; UPD ID= 182, SNARK:<5.MONITOR>MEXEC.MAC.53,  15-Sep-81 16:51:13 by SCHMITT
;TCO 4.1.1051 - Make system restart entry include Monitor uptime
; UPD ID= 179, SNARK:<5.MONITOR>MEXEC.MAC.52,  15-Sep-81 16:26:04 by MOSER
;TCO 5.1512 ADD SE1ENT TO JOBCOF.
; UPD ID= 134, SNARK:<5.MONITOR>MEXEC.MAC.51,   1-Sep-81 16:22:40 by GRANT
;Fix the check for DETACHed before CALL TTHNGU in LOG1 - dataset line was not
;being hung up if user was not logged in
; UPD ID= 57, SNARK:<5.MONITOR>MEXEC.MAC.50,  21-Jul-81 15:22:56 by GRANT
;Change "PS:" to "system structure"
;TCO 5.1375 - Fix bugs in ATACH JSYS
; UPD ID= 19, SNARK:<5.MONITOR>MEXEC.MAC.49,  12-Jul-81 15:44:27 by PAETZOLD
;Replace .FHSLF with .TTDES at DETMS3+3
; UPD ID= 18, SNARK:<5.MONITOR>MEXEC.MAC.48,  11-Jul-81 17:45:10 by PAETZOLD
;TCO 5.1407 - Make sure we dont ask to lock more memory than is on
; replacable queue in GSMD2
; UPD ID= 2289, SNARK:<5.MONITOR>MEXEC.MAC.47,   2-Jul-81 13:36:37 by PAETZOLD
;TCO 5.1393 - Change reference of BUGINT from immediate to full word
; UPD ID= 2265, SNARK:<5.MONITOR>MEXEC.MAC.46,  26-Jun-81 18:07:46 by MURPHY
;TCO 5.1376 - JOBCOF, FLOGO, FRKNOP
; UPD ID= 2125, SNARK:<5.MONITOR>MEXEC.MAC.45,   4-Jun-81 10:11:31 by GRANT
;Make sure all 23 bits of address get returned in GETSEG
; UPD ID= 2069, SNARK:<5.MONITOR>MEXEC.MAC.44,  22-May-81 16:48:23 by ZIMA
;TCO 5.1344 - Correct ATACH and DTACH privilege checking for batch jobs.
; UPD ID= 2056, SNARK:<5.MONITOR>MEXEC.MAC.43,  21-May-81 10:46:10 by SCHMITT
;More of TCO 5.1308
; UPD ID= 1967, SNARK:<5.MONITOR>MEXEC.MAC.42,   8-May-81 14:24:43 by SCHMITT
;More of TCO 5.1308 - Check for system shutdown in CHKR loop
; UPD ID= 1941, SNARK:<5.MONITOR>MEXEC.MAC.41,   5-May-81 17:06:32 by SCHMITT
;TCO 5.1308 - Latch HSYST1 to -1 when system shutdown
; UPD ID= 1921, SNARK:<5.MONITOR>MEXEC.MAC.40,   1-May-81 11:33:52 by PAETZOLD
;TCO 5.1301 add SCOUNT to GETAB tables, also bump SCOUNT in SETSN
; UPD ID= 1910, SNARK:<5.MONITOR>MEXEC.MAC.39,  30-Apr-81 16:29:05 by CHALL
;Inform the victim of a LOGOUT about the killer and his terminal
; UPD ID= 1817, SNARK:<5.MONITOR>MEXEC.MAC.38,  17-Apr-81 09:42:10 by WACHS
;TCO 5.1287 Restrict the possible answers to Why Reload question
; UPD ID= 1778, SNARK:<5.MONITOR>MEXEC.MAC.37,  31-Mar-81 17:43:13 by MURPHY
;Default is shutdown messages at 5 and 1 min
; UPD ID= 1719, SNARK:<5.MONITOR>MEXEC.MAC.36,  16-Mar-81 16:37:05 by MURPHY
;Add "PS:" to system expunge message
; UPD ID= 1569, SNARK:<5.MONITOR>MEXEC.MAC.35,  19-Feb-81 14:07:50 by HALL
;TCO 5.1180 - Move DST to non-zero section
; Fix EXEC0 so that it can run in section 1, because call to SETMPG
;  can get to GDSTX
; BSRAD - Use extra stack location and avoid clobbering PC
; GOTSWM - Change BLT to initialize SYSFK table
; UPD ID= 1496, SNARK:<5.MONITOR>MEXEC.MAC.34,  26-Jan-81 13:25:47 by ENGEL
;GET RID OF THE LCS CALLS. NOT PART OF NEXT RELEASE ANYMORE
; UPD ID= 1485, SNARK:<5.MONITOR>MEXEC.MAC.33,  24-Jan-81 23:20:07 by ZIMA
;TCO 5.1240 - Fix connect time calculation in CPGCON checkpoint routine.
; UPD ID= 1479, SNARK:<5.MONITOR>MEXEC.MAC.32,  22-Jan-81 12:37:41 by ZIMA
;TCO 5.1238 - expunge properly on logout.
; UPD ID= 1292, SNARK:<5.MONITOR>MEXEC.MAC.31,  18-Nov-80 18:11:05 by MURPHY
;FIX BUG IN JOBCOF - MAKE DETACH HAPPEN BEFORE LOGOUT
; UPD ID= 1286, SNARK:<5.MONITOR>MEXEC.MAC.30,  18-Nov-80 14:40:13 by OSMAN
; UPD ID= 1248, SNARK:<5.MONITOR>MEXEC.MAC.29,   7-Nov-80 15:01:32 by SCHMITT
;TCO 5.1194 - Fix code at USGIN7 to not cause CHKPNT errors
; UPD ID= 1221, SNARK:<5.MONITOR>MEXEC.MAC.28,   2-Nov-80 11:48:37 by HALL
;TCO 5.1180 - MOVE THE DST TO NON-ZERO SECTION
;	CHKR - RUN IN SECTION 1
;	GSMDX - RUN IN SECTION 1
;tco 5.1189 - Make entry vector two words
; UPD ID= 1221, SNARK:<5.MONITOR>MEXEC.MAC.28,   2-Nov-80 11:48:37 by HALL
;TCO 5.1180 - MOVE THE DST TO NON-ZERO SECTION
;	CHKR - RUN IN SECTION 1
;	GSMDX - RUN IN SECTION 1
; UPD ID= 1143, SNARK:<5.MONITOR>MEXEC.MAC.27,   8-Oct-80 15:14:08 by MURPHY
;BUG IN JOBCOF
; UPD ID= 1103, SNARK:<5.MONITOR>MEXEC.MAC.26,   2-Oct-80 09:28:08 by MURPHY
;DITTO
; UPD ID= 1081, SNARK:<5.MONITOR>MEXEC.MAC.25,   1-Oct-80 11:53:31 by MURPHY
;FIX ACVAR, ETC.
; UPD ID= 975, SNARK:<5.MONITOR>MEXEC.MAC.24,  29-Aug-80 08:41:47 by ENGEL
;ADD LCS INITIALIZATION CALL
; UPD ID= 972, SNARK:<5.MONITOR>MEXEC.MAC.23,  25-Aug-80 16:53:39 by HALL
;TCO 5.1139 - ADD FAILING PC AND LSTERR TO OUTPUT WHEN FORK 0 CRASHES
; UPD ID= 965, SNARK:<5.MONITOR>MEXEC.MAC.22,  25-Aug-80 16:28:07 by ENGEL
;TCO 5.1136 - ADD DEVLKK
; UPD ID= 932, SNARK:<5.MONITOR>MEXEC.MAC.21,  20-Aug-80 14:59:31 by LYONS
;TCO 5.1062 WRITE VERIFICATION ON WRITE FOR DISKS
; UPD ID= 841, SNARK:<5.MONITOR>MEXEC.MAC.20,   5-Aug-80 16:20:06 by OSMAN
;tco 5.1109 - Add PDV support to SSAVE and GET
; UPD ID= 812, SNARK:<5.MONITOR>MEXEC.MAC.19,  30-Jul-80 11:03:46 by MURPHY
;WEFLAG - DON'T WRITE-PROTECT MONITOR IF NON-0
; UPD ID= 789, SNARK:<5.MONITOR>MEXEC.MAC.18,  23-Jul-80 17:20:10 by R.ACE
;TCO 5.1112 - REMOVE VESTIGIAL "MOVE T1,FORKX" AT JOBCF1+2
; UPD ID= 747, SNARK:<5.MONITOR>MEXEC.MAC.17,   8-Jul-80 17:50:12 by HALL
;FIX LYONS' EDIT TO CHKUM1
; UPD ID= 723, SNARK:<5.MONITOR>MEXEC.MAC.15,   2-Jul-80 11:28:18 by LYONS
;Fix ILMNRF in SAVE% JSYS by maping read only page to non-existant page
; with no access, and fooling SAVEB1 into thinking page is really there
;Fix missing checks for tty detached when we get CTRLTT in LOG1
;Fix time race in CHKUM1 that can cause J0NRUN
;Fix reason why system down as told to IMP
;Fix CTY login after ^ECEASE if it was prohibited before
;ARPAnet can cause UPDL overflows if user in JSYS which locks tty data
;A job with PSI for carrier off does not get it until reattach time.
; UPD ID= 703, SNARK:<5.MONITOR>MEXEC.MAC.14,  26-Jun-80 09:52:06 by LYONS
;Add code to call ACJ on an implicit logout (i.e. thru a hangup of a dataset)
; UPD ID= 700, SNARK:<5.MONITOR>MEXEC.MAC.13,  25-Jun-80 17:26:40 by MURPHY
;FIRST SHUTDOWN MESSAGE CONTROLLED BY SF%MS1
; UPD ID= 698, SNARK:<5.MONITOR>MEXEC.MAC.12,  25-Jun-80 17:05:46 by GRADY
;TCO 5.1079 - FIX RACE AT LDTAC2, BUT UNLOKK DEVLKK AND GO OKINT TOO.
; UPD ID= 666, SNARK:<5.MONITOR>MEXEC.MAC.10,  16-Jun-80 19:06:25 by LYONS
;FIX RACE AT LDTAC2, WHERE CTRLTT MAY NOT BE RIGHT
; UPD ID= 662, SNARK:<5.MONITOR>MEXEC.MAC.9,  16-Jun-80 17:23:27 by KONEN
;TCO 5.1063 - REMOVE PS: AS NAME OF PRIMARY STRUCTURE
; UPD ID= 597, SNARK:<5.MONITOR>MEXEC.MAC.8,   3-Jun-80 17:45:02 by MURPHY
;FACTSW BITS TO CONTROL SYSTEM MESSAGES
; UPD ID= 498, SNARK:<5.MONITOR>MEXEC.MAC.7,  30-Apr-80 15:06:35 by GRANT
;TCO 5.1030 - Add description to ?FULL
; UPD ID= 468, SNARK:<5.MONITOR>MEXEC.MAC.6,  23-Apr-80 15:52:58 by LYONS
;pushed literals as PC dont allow for non zero sections
; UPD ID= 445, SNARK:<5.MONITOR>MEXEC.MAC.5,  15-Apr-80 11:01:18 by HALL
;MOVE LOGDES AND JB0TT INTO RSDAT
; UPD ID= 401, SNARK:<5.MONITOR>MEXEC.MAC.4,   2-Apr-80 15:52:50 by HALL
;FIX LOWER CASE IN PREVIOUS EDIT
; UPD ID= 394, SNARK:<5.MONITOR>MEXEC.MAC.3,   1-Apr-80 15:44:01 by HALL
;MAKE JB0TT AND USGMUP BE PART OF RSVAR PSECT
; UPD ID= 374, SNARK:<5.MONITOR>MEXEC.MAC.2,  26-Mar-80 13:36:09 by ENGEL
;STOP EDDT SYMBOL FROM PRINTING
; UPD ID= 288, SNARK:<4.1.MONITOR>MEXEC.MAC.447,  21-Feb-80 10:58:17 by MURPHY
;NEW FKINT DEFS
; UPD ID= 266, SNARK:<4.1.MONITOR>MEXEC.MAC.446,  15-Feb-80 17:39:58 by MURPHY
;PROPER LENGTH FOR QTIMES TABLE IN GETAB
; UPD ID= 240, SNARK:<4.1.MONITOR>MEXEC.MAC.445,   1-Feb-80 14:40:27 by ENGEL
; UPD ID= 110, SNARK:<4.1.MONITOR>MEXEC.MAC.444,   7-Dec-79 16:30:00 by SCHMITT
;TCO 4.1.1051 - CALC. MONITR UPTIME IN SEC AND GIVE TO USAGE JSYS FOR RESTART
; UPD ID= 106, SNARK:<4.1.MONITOR>MEXEC.MAC.443,   7-Dec-79 09:34:57 by R.ACE
;TCO 4.2591 - SECTION-0 PAGE TABLE SHARE COUNT PROBLEM FROM SSAVE
;ADD ERJMP AFTER SOUT IN LITERAL AFTER SSAVB4
; UPD ID= 91, SNARK:<4.1.MONITOR>MEXEC.MAC.442,   5-Dec-79 09:13:00 by OSMAN
;tco 4.1.1044 - Make EXEC command in mini-exec do implicit RESET
;<4.1.MONITOR>MEXEC.MAC.441, 16-Nov-79 13:47:41, EDIT BY MILLER
;PREVIOUS CHANGES UNDER TCO 4.1.1021
;<4.1.MONITOR>MEXEC.MAC.440, 16-Nov-79 13:00:38, EDIT BY MILLER
;ADD TTFSMS BUGINF
;<4.1.MONITOR>MEXEC.MAC.439, 16-Nov-79 11:46:24, EDIT BY MILLER
;CHANGE ALLMSG TO TIME-OUT TTMSG
;<4.MONITOR>MEXEC.MAC.438, 15-Oct-79 14:07:08, EDIT BY MILLER
;REMOVE CKDFRK BUGHLT. IF CFORK FAILS, RETURN +1
;<4.MONITOR>MEXEC.MAC.437, 12-Oct-79 14:14:29, Edit by KONEN
;CORRECT CHKAC JSYS IN DEALING WITH STRUCTURES
;<4.MONITOR>MEXEC.MAC.436, 26-Sep-79 16:46:01, EDIT BY HALL
;PEEK JSYS - CALL BLTMU1 INSTEAD OF BLTMU FOR EXTENDED ADDRESSING
;<4.MONITOR>MEXEC.MAC.435, 12-Sep-79 16:09:36, EDIT BY HALL
;STCRJB - ENTER SECTION 1 IN ORDER TO CALL BLTMU
;<4.MONITOR>MEXEC.MAC.434, 10-Sep-79 16:56:18, EDIT BY HALL
;TCO 4.2452 - IN STCRJB SET UP T2 CORRECTLY FOR CALL TO BLTMU
;<OSMAN.MON>MEXEC.MAC.1, 10-Sep-79 15:44:06, EDIT BY OSMAN
;TCO 4.2412 - Move definition of BUGHLTs, BUGCHKs, and BUGINFs to BUGS.MAC
;<4.MONITOR>MEXEC.MAC.432,  5-Sep-79 14:30:26, EDIT BY ZIMA
;More 4.2406 - clean it up a bit
;<4.MONITOR>MEXEC.MAC.431, 22-Aug-79 06:44:05, EDIT BY R.ACE
;TCO 4.2414 - ADD SE1ENT AT LOGO TO PREVENT ILLUUO'S
;<4.MONITOR>MEXEC.MAC.430, 17-Aug-79 12:58:12, EDIT BY HALL
;LDET2 - FIX TYPO IN TOMCZAK'S EDIT
;<4.MONITOR>MEXEC.MAC.429, 16-Aug-79 16:15:38, EDIT BY TOMCZAK
;TCO#4.2406 - code added in job startup, logout, and two detaching
;routines to insure that CTY always defaults to refusing links
;<4.MONITOR>MEXEC.MAC.428, 16-Aug-79 14:23:24, EDIT BY OSMAN
;CHANGE DIRBAD TO DRBAD TO NOT CONFLICT WITH DIRBAD BUGCHK IN DIRECT
;<4.MONITOR>MEXEC.MAC.427, 14-Aug-79 10:37:46, EDIT BY DBELL
;TCO 4.2395 - HANDLE ERRORS DURING SAVE JSYS WHICH CAN HANG UP A JOB
;<4.MONITOR>MEXEC.MAC.426, 11-Aug-79 08:33:57, EDIT BY HALL
;IN JOB INITIALIZATION, INITIALIZE FLKCNT AND FLKOWN
;<4.MONITOR>MEXEC.MAC.425, 30-Jul-79 09:29:36, EDIT BY MILLER
;SET JOB 0 PRIORITY WORD TO MFRKWD
;<4.MONITOR>MEXEC.MAC.424, 28-Jul-79 16:31:24, EDIT BY ZIMA
;TCO 4.2357 - Fix CRJOB security bug by connecting created job to
; creator's login directory around STCRJB+13
;<4.MONITOR>MEXEC.MAC.423, 24-Jul-79 10:10:09, EDIT BY DBELL
;MORE TCO 4.2230 - WHEN GET A JOB 0 CRASH, TYPE OUT NEW PC TO GO TO
;<4.MONITOR>MEXEC.MAC.422,  2-Jul-79 13:43:37, EDIT BY R.ACE
;FIX SPELLING OF "CANCELED"
;<4.MONITOR>MEXEC.MAC.421, 27-Jun-79 13:07:10, Edit by KONEN
;STORE ASCII TIME AND DATE FOR TYPEOUT AT BUGHLT
;<4.MONITOR>MEXEC.MAC.420, 25-Jun-79 18:38:17, Edit by LCAMPBELL
; Yet ANOTHER ancient bug at ELOGO which would cause a job to be
; unlogoutable by anyone after a user without privs tried to log it out
;<4.MONITOR>MEXEC.MAC.419, 19-Jun-79 16:36:01, Edit by LCAMPBELL
; TCO 4.2298 - Fix race at ELOGO which caused GLREM2s
;<4.MONITOR>MEXEC.MAC.418, 18-Jun-79 12:40:22, EDIT BY DBELL
;TCO 4.2291 - MAKE "SHUTDOWN COMPLETE" TYPE BY USING RIGHT TERMINAL DESIGNATOR
;<4.MONITOR>MEXEC.MAC.417, 10-Jun-79 14:57:00, EDIT BY MILLER
;DON'T CALL RUNMO1 IF A 2020
;<4.MONITOR>MEXEC.MAC.416, 30-Apr-79 12:55:43, Edit by MCLEAN
;<4.MONITOR>MEXEC.MAC.415, 25-Apr-79 15:16:58, EDIT BY OSMAN
;MOVE OURNAM INITIALIZATION TO STG
;<4.MONITOR>MEXEC.MAC.414, 25-Apr-79 00:04:16, Edit by MCLEAN
;<4.MONITOR>MEXEC.MAC.413, 25-Apr-79 00:01:32, Edit by MCLEAN
;CHANGE FROM GETOK ON LOGOUT OVER QUOTA TO LOGOUT
;<4.MONITOR>MEXEC.MAC.412, 17-Apr-79 17:25:54, EDIT BY ZIMA
;TCO 4.2233 - Pass proper flags to CHKBAT in T3 in call at EXEC0+15
;<4.MONITOR>MEXEC.MAC.411, 13-Apr-79 11:10:28, EDIT BY BOSACK
;FIX TYPO IN IMUMAP
;<4.MONITOR>MEXEC.MAC.410, 12-Apr-79 14:51:47, EDIT BY HALL
;TCO 4.2230 - SYSTEM STARTUP ERROR HANDLING -- ADD JB0INT, ETC.
;<4.MONITOR>MEXEC.MAC.409,  9-Apr-79 11:25:31, EDIT BY MILLER
;FIX CODE AT GSMDSK AND GSMD2 TO COMPUTE AVAILABLE MEMORY PROPERLY
;<4.MONITOR>MEXEC.MAC.408,  9-Apr-79 08:49:06, EDIT BY HALL
;<4.MONITOR>MEXEC.MAC.407,  5-Apr-79 14:35:47, EDIT BY HALL
;<4.MONITOR>MEXEC.MAC.406,  5-Apr-79 14:34:49, EDIT BY HALL
;<4.MONITOR>MEXEC.MAC.405,  5-Apr-79 14:21:55, EDIT BY HALL
;<4.MONITOR>MEXEC.MAC.404,  5-Apr-79 13:19:59, EDIT BY HALL
;<4.MONITOR>MEXEC.MAC.403,  5-Apr-79 12:52:54, Edit by MCLEAN
;<4.MONITOR>MEXEC.MAC.402,  5-Apr-79 12:46:56, EDIT BY HALL
;<4.MONITOR>MEXEC.MAC.401,  5-Apr-79 12:06:35, EDIT BY HALL
;BEGINNING CLEANUP OF SYSTEM STARTUP ERROR HANDLING
;<4.MONITOR>MEXEC.MAC.400,  5-Apr-79 11:08:22, Edit by MCLEAN
;REMOVE 1 ARG FROM GTOKM
;<4.MONITOR>MEXEC.MAC.399,  3-Apr-79 14:12:16, EDIT BY MILLER
;FIX USGINI TO HANDLE MANGLED CHECKPOINT FILE.
;<4.MONITOR>MEXEC.MAC.398,  2-Apr-79 21:30:32, EDIT BY ZIMA
;Add missing AC in JUMPL at LOG1+14
;<4.MONITOR>MEXEC.MAC.397, 10-Mar-79 13:30:54, EDIT BY MILLER
;FIX FAST GET CODE.
;<4.MONITOR>MEXEC.MAC.396,  7-Mar-79 18:29:12, EDIT BY MILLER
;<4.MONITOR>MEXEC.MAC.395,  7-Mar-79 17:20:37, EDIT BY MILLER
;<4.MONITOR>MEXEC.MAC.394,  7-Mar-79 16:57:50, EDIT BY MILLER
;<4.MONITOR>MEXEC.MAC.393,  7-Mar-79 14:43:00, EDIT BY MILLER
;MORE IMPROVEMENTS TO FAST GET. USE MSETPT WHENEVER POSSIBLE
;<4.MONITOR>MEXEC.MAC.392,  7-Mar-79 12:20:20, Edit by MCLEAN
;FIX IT SO FLOGO RUNS IN SECTION 1
;<4.MONITOR>MEXEC.MAC.391,  6-Mar-79 14:12:26, EDIT BY MILLER
;FIX FAST GET TO CREATE SHARE POINTERS INSTEAD OF INDIRECT POINTERS
;<4.MONITOR>MEXEC.MAC.390,  4-Mar-79 18:27:47, EDIT BY KONEN
;UPDATE COPYRIGHT FOR RELEASE 4
;<4.MONITOR>MEXEC.MAC.389,  2-Mar-79 15:28:04, Edit by MCLEAN
;FIX GTOKM MACROS FOR ERROR RETURNS
;<4.MONITOR>MEXEC.MAC.388, 26-Feb-79 16:47:02, EDIT BY HALL
;TCO 1967 - MAKE TSTFST CSKED WHILE FAST-GET TABLE IS LOCKED
;<4.MONITOR>MEXEC.MAC.387, 20-Feb-79 10:17:02, Edit by KONEN
;FIX ILMADR BUGHLT FROM CHECKPOINTING TOO LARGE A JOB NUMBER
;<4.MONITOR>MEXEC.MAC.386, 17-Feb-79 13:35:32, EDIT BY DBELL
;MAKE IMALC STORE PAGE NUMBER IN SYMPAG INSTEAD OF USING JSB STACK
;<4.MONITOR>MEXEC.MAC.385,  7-Feb-79 10:21:14, EDIT BY OSMAN
;SET UP OURNAM AND OURCNT HERE, SO NON-DECNET SYSTEMS ARE CONSISTENT
;<4.MONITOR>MEXEC.MAC.384,  4-Feb-79 22:33:30, EDIT BY GILBERT
;Start EDDT in section MSEC1 on EDDT$G to MDDT.
;<4.MONITOR>MEXEC.MAC.383, 29-Jan-79 03:56:20, EDIT BY DBELL
;CHANGE HSYPAG TO HSYBLK
;<4.MONITOR>MEXEC.MAC.382, 26-Jan-79 00:23:00, EDIT BY ZIMA
;TCO 4.2170 - Prevent UXXCKP BUGHLTS on restart when CHECKPOINT.BIN.1
; has been deleted and not expunged.
;<4.MONITOR>MEXEC.MAC.381, 18-Jan-79 19:21:50, EDIT BY MILLER
;CHANGE UNPAGE TO ONLY TURN OFF PAUSE ON END
;<4.MONITOR>MEXEC.MAC.380, 15-Jan-79 07:42:57, EDIT BY GILBERT
;More TCO 4.2155:
;	Fix various bugs in .IMOPR and boot code.
;<4.MONITOR>MEXEC.MAC.379, 14-Jan-79 15:02:29, Edit by MCLEAN
;REMOVE TTMVSP CALL
;<4.MONITOR>MEXEC.MAC.378,  8-Jan-79 06:51:34, EDIT BY GILBERT
;TCO 4.2155 - Implement hidden symbol tables:
;	Make boot process (GETSWM) understand hidden symbol tables.
;	Add .IMOPR subroutine for MDDT and SNOOP% to map symbols.
;<4.MONITOR>MEXEC.MAC.377,  5-Jan-79 13:10:55, Edit by MCLEAN
;MAKE LOGOUT HAVE GETOK FOR OVER QUOTA
;<4.MONITOR>MEXEC.MAC.375,  3-Jan-79 20:10:42, EDIT BY GILBERT
;ADD A DUMMY DEFINITION OF .IMOPR FOR DDT VERSION 41
;<4.MONITOR>MEXEC.MAC.374, 20-Dec-78 09:51:57, EDIT BY OSMAN
;<4.MONITOR>MEXEC.MAC.373, 19-Dec-78 15:47:02, EDIT BY MURPHY
;ADD BLOCK PRIORITY TO SCHED CALLS
;SET JOB'S NODE NAME TO SYSTEM'S AT INITIALIZATION
;<4.MONITOR>MEXEC.MAC.372, 11-Dec-78 19:13:10, Edit by MCLEAN
;FIX TODDT TO BE IN SEC 1
;<4.MONITOR>MEXEC.MAC.371, 28-Nov-78 10:52:35, EDIT BY MILLER
;<4.MONITOR>MEXEC.MAC.370, 26-Nov-78 19:04:31, EDIT BY MILLER
;DO OKSKED IF CALL STADYN IN ATACH FAILS
;<4.MONITOR>MEXEC.MAC.369, 23-Nov-78 15:53:41, EDIT BY JBORCHEK
;<4.MONITOR>MEXEC.MAC.368, 22-Nov-78 14:38:35, EDIT BY JBORCHEK
;DELETE LHOSTN SIMULATION BACK TO A TABLE STARTING AT NOHOST
;<4.MONITOR>MEXEC.MAC.367, 16-Nov-78 12:38:26, EDIT BY MILLER
;<4.MONITOR>MEXEC.MAC.366, 16-Nov-78 12:31:36, EDIT BY MILLER
;FIX FSTGET TO USE VECSET INSTEAD OF SEVEC
;<4.MONITOR>MEXEC.MAC.364, 10-Nov-78 10:54:33, EDIT BY OSMAN
;CHANGE CPYTUS TO CPYTU1 FOR SESSION REMARK, LOGICAL LOCATION, AND SKIP RETURN SO POINTER ISN'T UPDATED TWICE
;<4.MONITOR>MEXEC.MAC.363,  9-Nov-78 13:25:14, EDIT BY OSMAN
;TCO 4.2083 - CHANGE .WAIT TO WAIT1
;tco 4.2083 - change HALTF to WAIT in LGOUT code
;<4.MONITOR>MEXEC.MAC.360, 31-Oct-78 17:21:58, EDIT BY JBORCHEK
;MAKE LHOSTN 3 WORDS LONG
;<4.MONITOR>MEXEC.MAC.359, 24-Oct-78 16:27:19, EDIT BY OSMAN
;TCO 4.2060 - ADD .JILLO
;<4.MONITOR>MEXEC.MAC.358, 23-Oct-78 21:15:20, Edit by MCLEAN
;TCO 4.2063 ADD BATSTF FOR BATCH FLAGS
;<4.MONITOR>MEXEC.MAC.356, 23-Oct-78 16:29:54, EDIT BY ENGEL
;MAKE "FULL" "?FULL"
;<4.MONITOR>MEXEC.MAC.355, 19-Oct-78 23:26:10, Edit by MCLEAN
;ADD LOGOMS CALL FOR OPR
;SNARK:<4.MONITOR>MEXEC.MAC.354, 17-Oct-78 14:28:28, Edit by MCLEAN
;FIX LOG2 TO HAVE PID ADDRESS IN T1
;<4.MONITOR>MEXEC.MAC.353,  1-Oct-78 22:19:53, EDIT BY DBELL
;TCO 4.2027 - ADD .JISTM ENTRY TO GETJI
;<4.MONITOR>MEXEC.MAC.352, 28-Sep-78 13:55:21, Edit by LCAMPBELL
; Fix NSKDIS when detaching NVT (ARPA)
;<4.MONITOR>MEXEC.MAC.351, 26-Sep-78 14:29:59, Edit by LCAMPBELL
; Cause GTRPI to return milliseconds again
;<4.MONITOR>MEXEC.MAC.350,  8-Sep-78 09:25:18, EDIT BY ENGEL
;SAVE T3 ACROSS CALL TO GTSVIF AT GTSVI:
;<4.MONITOR>MEXEC.MAC.349,  1-Sep-78 15:20:12, EDIT BY JBORCHEK
;REMOVE SYMBOLS IMPLBT AND NOHOST
;<4.MONITOR>MEXEC.MAC.348, 28-Aug-78 19:23:29, Edit by LCAMPBELL
; Simulate IMPHRT and HSTSTS GETABs so old utilities still work.
;<4.MONITOR>MEXEC.MAC.347, 25-Aug-78 13:35:55, Edit by MCLEAN
;REMOVE CALL TO PLRSTS
;<4.MONITOR>MEXEC.MAC.346, 25-Aug-78 09:38:17, EDIT BY ENGEL
;GET RID OF OPEN FLAGS FOR THE FFFFP AT USDIN1:
;<4.MONITOR>MEXEC.MAC.345, 23-Aug-78 11:48:58, EDIT BY R.ACE
;TCO 4.1992 - CHANGE MTASSP TO CALL RUNDII INSTEAD OF RUNDIR
;<4.MONITOR>MEXEC.MAC.344, 17-Aug-78 13:38:45, Edit by LCAMPBELL
;<4.MONITOR>MEXEC.MAC.343, 17-Aug-78 12:30:49, EDIT BY LCAMPBELL
;FIX RACE IN CRJOB WHICH CAUSES WRONG AC'S TO BE PASSED OCCASIONALLY
; (MISSING MEXEC.MAC.342 HEADER LINE OMITTED BY cower)
;<4.MONITOR>MEXEC.MAC.341, 16-Aug-78 14:47:05, EDIT BY COWER
;changed getji to check that word wanted (ac3) not negative
;<4.MONITOR>MEXEC.MAC.340, 16-Aug-78 01:45:29, Edit by MCLEAN
;REMOVE SE0ENT/SE1ENT FROM TODDT
;<4.MONITOR>MEXEC.MAC.339, 16-Aug-78 01:22:46, Edit by MCLEAN
;ADD GETOK FOR ENTRY TO MDDT
;<4.MONITOR>MEXEC.MAC.338,  4-Aug-78 12:01:11, EDIT BY MILLER
;MUST BE NOSKED WHEN CALLING ASSPTL
;<4.MONITOR>MEXEC.MAC.337,  4-Aug-78 08:45:35, EDIT BY MILLER
;FIX SOME TYPEOS
;<4.MONITOR>MEXEC.MAC.336,  4-Aug-78 08:00:57, EDIT BY MILLER
;FIX FSTMAP ROUTINE.
;<4.MONITOR>MEXEC.MAC.335,  3-Aug-78 19:16:34, EDIT BY MILLER
;FIX MORE TYPEOS
;<4.MONITOR>MEXEC.MAC.334,  3-Aug-78 12:07:55, EDIT BY MILLER
;FIX TYPEOS
;<4.MONITOR>MEXEC.MAC.333,  3-Aug-78 11:14:59, EDIT BY MILLER
;TCO 1967. ADD FAST-GET CODE
;<4.MONITOR>MEXEC.MAC.332, 28-Jul-78 15:20:11, Edit by ENGEL
;ELIMINATE NOSKED AT LCTAC2+7 - FIX ARPA NSKDIS PROBLEM
;<4.MONITOR>MEXEC.MAC.331, 27-Jul-78 13:18:35, Edit by PORCHER
;FIX ILL WRITE TO CHECKPOINT FILE AT USGIN7...
;<4.MONITOR>MEXEC.MAC.330, 20-Jul-78 09:51:55, Edit by ENGEL
;FIX PROBLEM CREATED BY BORCHECK AT STCJB1 - CHANGE HRRZM TO MOVEM AND
; CHANGE THE CAMN TO USE A REGISTER
;<4.MONITOR>MEXEC.MAC.329, 14-Jul-78 12:50:26, EDIT BY MILLER
;CHANGE TODDT TO ENTER MDDT IN SECTION "MSEC1"
;TCO # 1902 - MAKE JOB 0 UPDATE FULL PAGES IN CHECKPOINT FILE
;<4.MONITOR>MEXEC.MAC.327,  6-Jul-78 01:28:45, Edit by JBORCHEK
;MUST SIMULATE SOME OF THE ARPA TABLES NOW
;<4.MONITOR>MEXEC.MAC.325, 28-Jun-78 11:10:22, EDIT BY OSMAN
;ADD .JIT20/.SJT20 - TCO # 1927
;<4.MONITOR>MEXEC.MAC.324, 26-Jun-78 02:23:37, Edit by JBORCHEK
;FIX HSTSTS TABLE SIZE
;<4.MONITOR>MEXEC.MAC.323, 23-Jun-78 15:44:36, EDIT BY OSMAN
;FREEZE FORKS ON "^P" ONLY.  (USED TO FREEZE ON "^EQUIT" TOO)
;TCO 1926
;<4.MONITOR>MEXEC.MAC.322, 21-Jun-78 00:34:01, Edit by MCLEAN
;ADD GOKLCK
;<4.MONITOR>MEXEC.MAC.321, 20-Jun-78 15:05:48, Edit by ENGEL
;ELIMINATE THE JSBSTF CALL AT JOBCF1
;<4.MONITOR>MEXEC.MAC.320, 14-Jun-78 06:01:38, Edit by JBORCHEK
;DELETE ERROR MSG DUE TO BUGTP=0
;<4.MONITOR>MEXEC.MAC.319, 13-Jun-78 13:31:59, EDIT BY MILLER
;SHUFFLE CODE AROUND GSMLER TO MAP MMAP INTO BOOT SPACE BEFORE LOCKING
;<4.MONITOR>MEXEC.MAC.318,  3-Jun-78 17:02:25, Edit by GILBERT
;Suppress SSAVE flags to DDT typeout
;<4-NEW>MEXEC.MAC.317,  1-Jun-78 17:17:15, Edit by FORTMILLER
;START BOOT AT LAST INSTRUCTION ON LAST PAGE
;<4.MONITOR>MEXEC.MAC.316, 31-May-78 13:45:43, Edit by KIRSCHEN
;MAKE RESTART SYSERR ENTRY EVEN IF NO OPERATOR ENTRY OF DATE AND TIME
;<4.MONITOR>MEXEC.MAC.315, 18-May-78 14:32:55, Edit by KIRSCHEN
;<3A.MONITOR>MEXEC.MAC.21, 16-May-78 13:07:48, EDIT BY MILLER
;TCO 1887. ADD NSWPGS GETAB ENTRY
;<4.MONITOR>MEXEC.MAC.313, 13-May-78 13:14:00, Edit by HALL
;TCO 1900 - CALL ATSINI AT RUNDD7
;<4.MONITOR>MEXEC.MAC.312, 20-Apr-78 14:41:02, EDIT BY MILLER
;MAKE SURE T3 HAS DIR NUMBER IN IT AT ATACH6
;<4.MONITOR>MEXEC.MAC.311,  9-Apr-78 01:59:06, Edit by BORCHEK
;CRJOB FIXES AT STCJB1
;<4.MONITOR>MEXEC.MAC.310,  3-Mar-78 09:56:48, EDIT BY MILLER
;DETERMINE LOW MESSAGE BY COMPARING AGAINST SYWRND
;<4.MONITOR>MEXEC.MAC.309,  1-Mar-78 13:46:08, Edit by PORCHER
;<4.MONITOR>MEXEC.MAC.308,  1-Mar-78 12:04:36, Edit by PORCHER
;Move accounting shift change initialization to before SETSPD
;<4.MONITOR>MEXEC.MAC.307, 28-Feb-78 17:29:08, Edit by PORCHER
;<4.MONITOR>MEXEC.MAC.306, 28-Feb-78 13:14:17, Edit by PORCHER
;<4.MONITOR>MEXEC.MAC.305, 28-Feb-78 11:32:10, Edit by PORCHER
;Bug fixes for accounting shift changes . . .
;<4.MONITOR>MEXEC.MAC.303, 20-Feb-78 12:24:56, Edit by PORCHER
;<4.MONITOR>MEXEC.MAC.302, 20-Feb-78 11:20:53, Edit by PORCHER
;Add stuff for accounting shift changes
;<4.MONITOR>MEXEC.MAC.301, 16-Feb-78 09:21:29, Edit by PORCHER
;Add stuff for session runtime and console time
;<4.MONITOR>MEXEC.MAC.300, 31-Jan-78 00:34:24, Edit by MCLEAN
;ADD MTA ON LINE REQUEST OF SETSPD
;<4.MONITOR>MEXEC.MAC.299, 28-Jan-78 23:15:18, Edit by PORCHER
;Make GETs of PA1050 and RMS come from SYS: if execute-only
;<4.MONITOR>MEXEC.MAC.298, 28-Jan-78 18:23:39, Edit by PORCHER
;<4.MONITOR>MEXEC.MAC.297, 28-Jan-78 17:37:53, Edit by PORCHER
;<4.MONITOR>MEXEC.MAC.296, 28-Jan-78 17:29:08, Edit by PORCHER
;Add execute-only GET code
;<4.MONITOR>MEXEC.MAC.295, 25-Jan-78 13:30:58, EDIT BY MILLER
;FIX TYPEO IN SYSJOB CHANGE
;<3A.MONITOR>MEXEC.MAC.15, 25-Jan-78 13:26:13, EDIT BY MILLER
;USE NEW RUNDIR ROUTINE TO RUN SYSJOB
;<3A.MONITOR>MEXEC.MAC.14, 25-Jan-78 12:48:19, EDIT BY MILLER
;RUN MOS DIAG IN JOB 0 AND AT SYSTEM STARTUP
;<4.MONITOR>MEXEC.MAC.292,  3-Jan-78 16:14:50, EDIT BY MILLER
;<4.MONITOR>MEXEC.MAC.291,  3-Jan-78 16:13:44, EDIT BY MILLER
;FIX MAPPING OF EPT FOR BOOT TO USE SETMPG
;<3-MONITOR>MEXEC.MAC.287, 13-Dec-77 16:23:59, Edit by HESS
;TCO 1889 - FIX TO SESSION END LOGGING
;<4.MONITOR>MEXEC.MAC.289,  6-Dec-77 20:53:30, EDIT BY MCCLURE
;CALL DUPINI
;<3.SM10-RELEASE-3>MEXEC.MAC.9,  5-Dec-77 12:59:52, EDIT BY MILLER
;DON'T RECORD "ALLOCATED BUT ZERO" PAGES
;<4.MONITOR>MEXEC.MAC.287,  5-Dec-77 12:23:04, EDIT BY MILLER
;MOVE RQTAD1 SET UP TO DTESRV
;<3.SM10-RELEASE-3>MEXEC.MAC.7,  5-Dec-77 10:33:20, EDIT BY MILLER
;DON'T SAVE ALL ZERO PAGES.
;<3-MONITOR>MEXEC.MAC.286, 17-Nov-77 16:01:05, EDIT BY KIRSCHEN
;FIX TYPO ON PREVIOUS EDIT
;<4.MONITOR>MEXEC.MAC.284, 10-Nov-77 23:53:27, EDIT BY BOSACK
;UPDATE DDTPRS IN ULKINI
;<4.MONITOR>MEXEC.MAC.283,  6-Nov-77 16:11:32, Edit by MCLEAN
;ADD CODE FOR RELOAD ON KS
;<4.MONITOR>MEXEC.MAC.282, 26-Oct-77 17:34:31, EDIT BY CROSSLAND
;FIX SO THAT SYSTEM GOING DOWN IN 2 HOURS MESSAGES OCCURS ONLY ONCE
;INCREASE OVERHEAD PAGES DURING BOOT PHASE TO ALLOW MONMIN TO WORK
;<4.MONITOR>MEXEC.MAC.281, 23-Oct-77 20:15:56, EDIT BY CROSSLAND
;MAKE HALT MESSAGE ONLY COME OUT 2 HOURS BEFORE HALT
;<4.MONITOR>MEXEC.MAC.280, 20-Oct-77 13:11:47, EDIT BY HURLEY
;FIX ATTACH AC CLOBBERAGE
;<4.MONITOR>MEXEC.MAC.279,  5-Oct-77 13:08:35, Edit by HESS
;JOB 0 - SEND MESSAGE TO PULSAR WHEN MTA STATUS CHANGE FLAG SET

;COPYRIGHT (C) 1976,1977,1978,1979 BY DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.

	SEARCH PROLOG,SERCOD,ACTSYM
IFN MNET,<
	SEARCH MNTPAR
>	;1001 If a multinet system

	TTITLE MEXEC

;1000 begin addition
	EXTN <REMTCJ>		;UNTIL THESE GET INTO GLOBS
IFN MNET,<
	EXTN <CHKIMP>
	EXTN <IMICHK>	
>
IFE MNET,<
	EXTN <CHAINI>
	EXTN <CHAON>
	EXTN <CHASBS>
	EXTN <CHPMXT>
>
;1000 End addition
	EXTN <MOSULE>

;SWAPPABLE MONITOR ROUTINES, JSYS'S, ETC. - D. MURPHY


;AC DEFINITIONS USED HEREIN

DEFAC (FX,Q3)			;FORK INDEX

;NOTE: THE NEXT TWO LOCATIONS MUST BE TOGETHER. GETAB REQUIRES IT

RSI LOGDES,LOGTTY		;DESIGNATOR FOR LOG MSGS - DEF IN PARAMS
RSI JB0TT,0			;DESIG FOR JOB 0 AND ERR MSGS

MICHN==:1B34+1B35		;CHANNELS THAT MONITOR ENABLES
EXWTIM==:^D120			;NUMBER MINUTES BETWEEN AUTO EXPUNGES

	SWAPCD

;LINKAGE TO MDDT

MDDT=:<MSEC1,,MDDTX>		;TRY TO START IN SECTION 1

;REGULAR SUBSYSTEM NAMES FOR INCLUSION IN SNAMES TABLE AT STARTUP

SBSNMS:	SIXBIT /EXEC/
	SIXBIT /(PRIV)/
NSBSNM==.-SBSNMS

;TABLE DEFINES SPECIAL PURPOSE FOR FIRST FEW JOBS

SPECJT:	XWD 0,RUNDD		;JOB 0 IS ALWAYS DISK CHECKER, ETC.

NSPECJ==.-SPECJT		;NUMBER OF SPECIAL JOBS

	RESCD

;CODE TO INITIALIZE JOB ON FIRST STARTUP.  ALSO INVOKES SYSTEM
;INITIALIZATION IF FIRST JOB AFTER SYSTEM STARTED FROM SCRATCH
;SYSIFG IS 0 WHEN SYSTEM IS JUST STARTING

EXEC0::	MOVX 1,LOGIOB		;SAY JOB CREATION IN PROGRESS
	IORM 1,JOBBIT
	SETZM FPC
	MOVSI 1,(UMODF)		;SIMULATE CALL FROM USER
	MOVEM 1,FFL
	MCENTR
	SKIPE SYSIFG		;NEW SYSTEM?
	JRST GOTSWM		;NO
	MOVEI T1,MFRKWD		;GET SPECIAL PRIORITY FOR MONITOR FORKS
	MOVEM T1,JOBSKD		;AND SET THIS JOB AS SUCH
repeat 0,<
 ** previous two lines may get commented out, replace with
    CALL SETHIQ
>;1001
	CALL SEBINI		;INIT SYSERR FACILITY
	CALL FSIINI		;GO MOUNT THE PUBLIC STRUCTURE
	CALL SWPINI		;SWAPPER CAN NOW BE INITIALIZED
				;IT MUST BE CALLED AFTER NSSUN AND
				;  THE SDB FOR PS ARE SET UP BY FSIINI
	MOVEI T1,PSNUM		;T1/ STRUCTURE NUMBER (PUBLIC STRUCTURE)
	MOVEI T2,HOMPGA		;T2/ ADDRESS OF PAGE TO USE FOR BAT BLOCKS
	MOVX T3,MI%MSG		;T3/ FLAGS TO TELL OPERATOR, FIX INCONSISTENT
	CALL CHKBAT		;AND NOW THE BAT BLOCKS CAN BE CHECKED
				; AND THE OVERFLOW SWAPPING ADDRESSES
				; IN THE BAT BLOCKS PROCESSED
REPEAT 1,<			;TEMPORARY UNTIL REV 10 IS IN
	PUSH P,CASHF		;TURN OFF THE CACHE
	CALL CASHOF		;THIS REDUCES PROBLEMS CAUSED BY MAP INST
>
	CALL GETSWM		;GET SWAPPABLE MONITOR
REPEAT 1,<			;TEMPORARY UNTIL REV 10 IS IN
	POP P,CASHF		;RESTORE CACHE
	SKIPE CASHF		;WAS CASH ON BEFORE?
	CALL CASHON		;YES, TURN IT BACK ON
>
	CALL RESLCK		;LOCK DOWN SOME RESIDENT FREE SPACE
	SKIPE VSMFLG		;SWAP MONITOR NEED TO BE FORCED OUT TO DISK?
	JRST [	SETOM SKEDFC	;YES, FORCE IT ALL TO HAPPEN
		MOVEI T1,1000	;1 SECOND OF SLEEP TIME
		DISMS		;SHOULD BE LONG ENOUGH FOR THE SWAPABLE
				;MONITOR TO GET OUT, WITH OUT ANY PROBLEMS.
		SETZM VSMFLG	;STOP FORCING DATA VERIFICATION
		SETZM SKEDFC	;MAKE SURE WE DONT SPEND EXTRA TIME SWAPPING, TOO
		JRST .+1]	;BACK TO THE MAIL LINE CODE

;AT THIS POINT THE SWAPPABLE MONITOR HAS BEEN LOADED.  IF THE MONITOR WAS
;STARTED AT 144, IT HAS ALSO BEEN SWAPPED OUT TO THE DISK.
; IF IT IS DESIRABLE TO PATCH THE SWAPPABLE MONITOR A BREAKPOINT CAN
; BE PUT HERE.  NO PART OF THE SWAPPABLE MONITOR WILL HAVE BEEN EXECUTED YET.

;INITIALIZE THE FORK STRUCTURE FOR THIS JOB. ASSIGN FIRST WORD OF FKPTRS
;AND SYSFK TO THIS FORK. MAKE EACH REMAINING WORD OF FKPTRS POINT TO NEXT
;AVAILABLE SLOT AND FREJFK POINT TO THE FIRST AVAILABLE SLOT
;INITIALIZE REMAINING WORDS OF SYSFK TO -1

GOTSWM:	MOVEI 1,FKPTRS		;1/NAME OF FORK STRUCTURE LIST
	MOVEI 2,NUFKS		;2/NUMBER OF WORDS IN LIST
	CALL ILIST		;INITIALIZE FREE WORDS IN FKPTRS
	MOVE 1,0(1)		;POINT TO SECOND FREE SLOT
	MOVEM 1,FREJFK		;MAKE FREE LIST START WITH SECOND SLOT
	SETZM FKPTRS		;TAKE FIRST SLOT FO THIS FORK
	MOVE 1,FORKX		;GET SYSTEM-WIDE INDEX FOR THIS FORK
	HRRZM 1,SYSFK		;STORE IN JOB STORAGE AREA
				;Note that this clears all the flag bits
				; (defined in FORK) in LH of SYSFK
	MOVEI T1,NUFKS-2	;T1/ NUMBER OF WORDS TO COPY
	MOVEI T2,SYSFK+1	;T2/ STARTING SOURCE WORD
	SETOM (T2)		;INITIALIZE IT TO -1
	MOVEI T3,1(T2)		;T3/ STARTING DESTINATION WORD
	CALL XBLTA		;INITIALIZE BLOCK TO -1 (EXCEPT FIRST WORD)
	MOVE T1,[JTBIFR]	; Initialize JTB free bit table
	MOVEM T1,JTBFRE		;  ..
	SETOM FKLOCK		;INIT FORK LOCK FOR THIS JOB
	SETZM FLKCNT		;CLEAR NEST COUNT
	SETOM FLKOWN		;CLEAR OWNING FORK

;SET UP FOR INTERRUPTS TO BE PROCESSED BY THE MONITOR
;IF AN INTERRUPT OCCURS ON A CHANNEL WHOSE BIT IS SET IN MONCHN,
;THE MONITOR WILL GO TO EXECI
;CHANNELS 34 AND 35 ARE ACTIVATED HERE, AND CTRL/P IS ASSIGNED
;TO THEM IN THE MINI-EXEC

	SETOM TTJTIW
	MOVE 1,[XWD ITFFL,EXECI] ;GO TO EXECI ON INTERRUPT
	MOVEM 1,MONBK
	MOVEI 1,400000		;1/THIS FORK
	MOVEI 2,MICHN		;2/CHANNELS TO ENABLE
	MOVEM 2,MONCHN		;MAKE THE MONITOR TAKE INTERRUPTS ON THEM
	AIC			;ACTIVATE CHANNELS 34 AND 35

	JRST JBI0		;CONTINUE IN SWAPPABLE CODE

;JOB INITIALIZATION...
;SYSIFG IS 0 IF SYSTEM IS BEING STARTED

	SWAPCD

JBI0:	CALL JBFINI		;INIT FILE SYS FOR THIS JOB
	SKIPE SYSIFG		;SYSTEM INITIALIZED?
	JRST SYSINE		;YES

;SYSTEM IS BEING STARTED. DO ONCE-ONLY INITIALIZATION

	SETOM FGLOCK		;INIT FAST GET LOCK
	SETOM SYLNLK		;INIT SYSTEM LOGICAL NAME LOCK
	SETOM CRJLCK		;INIT LOCK OF CRJOB DATA BASE
	CALL FILINI		;INIT FILE SYSTEM
	SETOM GOKLCK		;INIT GETOK LOCK
	SETOM TIMLCK		;INIT LOCK ON TIMER Q'S
	MOVE 1,[XWD SBSNMS,SNAMES]
	BLT 1,SNAMES+NSBSNM-1	;MOVE REGULAR SUBSYSTEM NAMES TO TABLE
	MOVNI 1,NSBSNM		;INIT TABLE POINTER WITH NEG COUNT
	MOVEM 1,SNMPT
	SETOM SNMLCK		;AND INIT LOCK
	MOVE T1,[JOBONT,,JOBONT+1]
	SETOM JOBONT		;NO JOBS ARE YET OWNED BY ANYONE
	BLT T1,JOBONT+NJOBS-1	; ..
	CALL PIDINI		;INITIALIZE THE IPCF DATA BASE AND FORKS
	CALL SLNINI		;INITIALIZE SYSTEM LOGICAL NAMES
	SETOM UTLOCK		;INITIALIZE THE UTEST JSYS DATA BASE
	CALL GETNAM		;INITIALIZE STRING CONTAINING
				; MONITOR VERSION AND NAME
	CALL NAMINI		;INITIALIZE NODE NAME TO "TOPS20", IF DECNET
	MOVEI T1,TMZONE		;INITIALIZE TIMZON
	MOVEM T1,TIMZON
	SETOM ACTLCK		;INITIALIZE LOCK ON ACCT WINDOW PAGES
	SETOM ACTOFN		;NO OFN FOR ACCT VALIDATION DATA FILE YET
	SETOM AVALON		;ALWAYS TURN ON ACCT VALIDATION TILL STATED OTHERWISE
	; ..

;JOB INITIALIZATION...
;THIS CODE IS REACHED FOR ALL JOBS, INCLUDING FIRST ONE AFTER SYSTEM
;STARTUP

SYSINE:	MOVE T1,JOBNO		;INITIALIZE THE PID QUOTA
	CALL PIDJBI		;  AND SEND QUOTA
	CALL ENQJBI		;INITIALIZE ENQ/DEQ QUOTA
	MOVE T1,JOBNO		;GET JOB NUMBER
	SETZM CRJFLG		;ASSUME NOT A CREATE-JOB STARTUP
	HLRZ T2,JOBPT(T1)	;CHECK FOR SPECIAL STARTUP FLAG
	CAIE T2,-2		;FROM CRJOB?
	JRST SYSIN1		;NO. NORMAL STARTUP.
	MOVE T2,CRJTTY		;CRJOB. HERE IS THE REQUESTED TTY.
	HRLM T2,JOBPT(T1)	;PUT IT IN JOBPT OF NEW JOB.
	MOVEM T2,CTRLTT		;AND IN THE JSB
	SETOM CRJFLG		;FLAG IN JSB THIS IS A CRJOB STARTUP
SYSIN1:	JUMPL T2,SYSIN2		;JUMP IF JOB IS DETACHED
	CALL TTYASN		;ASSIGN CONTROLLING TTY
	 JRST SYSIN9
	MOVE T2,CTRLTT		;GET TTY NUMBER
	CALL TTCKSP		;GO SEE IF SPEED SETTING NEEDED
SYSIN2:	MOVE T1,TODCLK
	MOVEM T1,CONSTO		;SET CONSOLE TIME ON
	CALL LGTAD
	MOVEM T1,CTIMON		;SET DATE/TIME CONNECT
	SETZM JSSRTM		;Reset session runtime
	SETZM JSSCTM		; and session console time
	MOVE T1,[OURNAM,,LLSR]	;BLT POINTER TO INITIALIZE NODE NAME
	BLT T1,LLSR+WPN-1	;MAKE JOB'S NODE NAME BE OUR LOCAL NAME
	MOVX T1,LOGIOB		;SAY JOB CREATION FINISHED
	ANDCAM T1,JOBBIT

;JOBS 0 THROUGH NSPECJ-1 ARE SPECIAL. SPECJT CONTAINS ADDRESS TO WHICH
;TO TRANSFER. FOR NOW, ONLY JOB 0 IS SPECIAL, AND IT GOES TO RUNDD.
;SEE IF THIS IS A SPECIAL JOB

	MOVE 1,JOBNO		;FIRST FEW JOBS ARE SPECIAL,
	CAIGE 1,NSPECJ		;IS THIS ONE OF THEM?
	JRST [	MOVEI 2,OPERDN	;YES, GET DIRECTORY NUMBER OF <OPERATOR>
		HRRM 2,JOBDIR(1) ;INDICATE LOGGED IN AS <OPERATOR>
		STOR 2,JSDIR	;SAVE AS CONNECTED DIRECTORY
		SETZRO JSCDF	;NO STRING IN JSB
		MOVE 2,STRTAB+PSNUM ;GET SDB ADDRESS OF PRIMARY STRUCTURE
		LOAD 2,STRUC,(2) ;GET ITS UNIQUE STRUCTURE CODE
		STOR 2,JSUC	;SAVE AS CONNECTED STRUCTURE CODE
		MOVE 2,[[3
			 ASCIZ "OPERATOR"],,USRNAM]
		BLT 2,USRNAM+2	;SET UP DEFAULT USER NAME STRING
		HRRZ 2,SPECJT(1)
		JRST 0(2)]	;GO DO THE SPECIAL FUNCTION

;NOT A SPECIAL JOB. SET UP TERMINAL INFORMATION

	MOVE A,CTRLTT		; GET CONTROLLING TERMINAL
	JUMPL A,SYSINP		;NO TTY. DON'T INIT TTY PARAMETERS
	CALL CHKPTY		;IS IT A PTY?
	 SKIPA			;NO. INIT TTY PARAMETERS
	JRST SYSINP		;YES. DON'T INIT TTY PARAMETERS

;1001 Begin modification
	MOVEI T1,.PRIIN
	GTTYP			;99 If SUPDUP terminal,
	CAIN 2,.TTSUP		;99 Skip this stuff
	 JRST SYSINP		;99
	MOVE T2,NORMTF
	SFMOD
	STPAR
	MOVE T2,CTRLTT
repeat 0,< ;16 remove some TCP code
	CALL CHKNVT		; NETWORK TERMINAL?
	 JRST [	CALL CHKTVT	; SEE IF A TCP VIRTUAL TERMINAL
		 JRST SYSINQ	; NEITHER.  MUST BE NORMAL.
		JRST SYSINO]	; TVT.  IDEAL
SYSINO:	SKIPA T2,[.TTIDL]	; SOMEKIND OF NET TERMINAL -- IDEAL
SYSINQ:	MOVE 2,NORMTY		; Normal kind of terminal
;1001 End modification
>;16 
	SKIPGE TTSTAT(B)	;16 Is it remote?
	 SKIPA B,NORMTY		;16 Yes, reset to standard type
	GTTYP			;16 Else get old one so setu correctly
	MOVEI T1,.PRIOU
	STTYP
	MOVE 2,TTICB1
	MOVE 3,TTICB2
	SFCOC
	HRLOI T1,(TL%CRO+TL%COR+TL%SAB+TL%ABS+TL%STA)
	MOVE T2,CTRLTT		;Get controlling TTY#
	CAMN T2,CTYLNO		;Starting job on CTY?
	TXZ T1,TL%ABS		;Yes - so set refuse links
	MOVEI T2,-1		;ALL REMOTE
	TLINK			;BREAK LINKS, CLEAR ACCEPT
	 JFCL

;GO START THE EXEC. IF SYSTEM IS STAND-ALONE, TELL THE USER

SYSINP:	SKIPE CRJFLG		;IF CREATED JOB, GO SET IT UP.
	JRST STCRJB		; ..
	MOVE T1,DBUGSW
	CAIGE 1,2		;DEBUG MODE OPERATION?
	JRST STEX		;NO, GO START EXEC
	TMSG <
[Caution--System is stand-alone]
>
	JRST STEX		;WARN USERS FIRST

SYSIN9:	SETOM CTRLTT		;INDICATE DETACHED SO LOGOUT WON'T
	MOVE T2,JOBNO		; TRY TO WRITE ON THIS TERMINAL
	HRROS JOBPT(T2)		;..
	SKIPL CRJFLG		;IS THIS JOB BEING CREATED BY CRJOB JSYS?
	JRST FLOGO1		;NO. GO KILL THE JOB
	MOVEM T1,CRJANS		;YES. SAVE ERROR CODE FROM TTYASN
	JRST LOGO		;GO KILL THE JOB

;HERE AT STARTUP OF JOB BY CRJOB JSYS.

STCRJB:	MOVE Q1,JOBNO		;CARRY AROUND MY JOB NUMBER
	HRLM Q1,CRJONJ		;TELL CREATOR, IF WE GET THERE.
	MOVE Q2,CRJAC1		;AND CONTROL FLAGS OF CRJOB AC1
	MOVE T1,CRJONJ		;GET CREATOR'S JOB NUMBER
	TXNE Q2,CJ%OWN		;CREATOR WANTS TO OWN ME?
	MOVEM T1,JOBONT(Q1)	;YES. REMEMBER WHO HE IS.
	MOVE T1,CRJSLO		;SIGNAL ON LOGOUT?
	TXNN Q2,CJ%SLO		; ..
	MOVEI T1,0		;NO. CLEAR THE PID
	MOVEM T1,JSLOPD		;SAVE THE PID FOR THE SIGNAL
	JN CJ%LOG,Q2,STCJB1	;JUMP IF WANTS TO LOG IN
	HRRZ T1,CRJONJ		;NO LOGIN, GET CREATOR'S JOB NUMBER
	HRRZ T1,JOBDIR(T1)	; TO FETCH CREATOR'S LOGIN DIRECTORY
	STOR T1,JSDIR		;AND MAKE IT OUR CONNECTED DIRECTORY
	MOVE T1,STRTAB+PSNUM	;POINT TO THE PRIMARY SDB
	LOAD T1,STRUC,(T1)	; AND FETCH THE PRIMARY STRUCTURE UNIQUE CODE
	STOR T1,JSUC		;SET IN JSB, COMPLETING CONNECT TO PRIMARY STR
	SETZM CAPENB		;MAKE SURE I HAVE NO CAPS ENABLED
	HLLZS CAPMSK		;OR POTENTIAL
	MOVE T1,CRJOJC		;GET OWNING JOB'S CAPS
	AND T1,CRJCAM		;MASKED, IF ASKED
	TXNE Q2,CJ%CAP		;DOES HE WANT TO GIVE ME HIS?
	HRRM T1,CAPMSK		;YES, I'LL TAKE THEM, UNTIL LOGIN JSYS
	JRST STCJ1A		;DONE WITH LOGIN-ISH STUFF

;HERE IF CJ%LOG IS ON IN CALL. I AM TO TRY TO LOG THIS JOB IN.

STCJB1:	HRROI B,CRJUSR		;POINT TO THE USER NAME STRING
	MOVX T1,RC%EMO		;EXACT MATCH ONLY
	RCUSR			; AND CONVERT TO USER NUMBER
	 ERJMP SCJXXX		;PASS FAILURE CODE BACK
	TXNE T1,RC%NOM!RC%AMB	;FILES ONLY, NO MATCH OR
	JRST SCJXX1		; AMBIGUOUS? FAIL. CAN'T LOG IN.
	MOVEM T3,CRJUSR		;STORE THE NUMBER
	HRRZ T3,T3		;CLEAN FOR CAMN LATER
	MOVE T4,CRJOJC		;GET CREATOR'S CAPS
	HRRZ T1,CRJONJ		;AND JOB NUMBER
	HRRZ T1,JOBDIR(T1)	;CREATOR'S LOGIN DIRECTORY
	TRNN T4,SC%WHL!SC%OPR	;PRIVILEGED CREATOR?
	CAMN T1,T3		;OR LOGGING IN AS SAME USER?
	JRST STCJ1E		;YES. NO NEED FOR PSWD CHECK.
	TXZE Q2,<CJ%NPW!CJ%NUD>	;NO, SO REQUIRE PASSWORD, AND LOGIN DATE
	JRST [	MOVEI T1,CRJBX1	;ILLEGAL REQUEST
		JRST SCJXXX]
STCJ1E:	LOAD T1,CJ%ACT,Q2	;WHAT KIND OF ACCOUNT DO WE USE?
	CAIE T1,.CJUCA		;USE CURRENT ACCOUNT OF CREATOR
	CAIN T1,.CJUAA		;OR ARG BLOCK ACCOUNT?
	JRST STCJ1C		;YES, IT'S IN THE COMMON STORAGE.
	SETZM CRJACT		;USE DEFAULT
   ;FALL THRU

   ;CAN FALL IN
STCJ1C:	MOVEI T1,0		;BUILD FLAGS FOR LOGIN JSYS
	TXNE Q2,CJ%NPW		;NO PASSWORD NEEDED?
	TRO T1,1		;RIGHT.
	TXNE Q2,CJ%NUD		;NO UPDATE LOGIN DATE?
	TRO T1,2		;RIGHT. TELL LOGIN.
	HRRM T1,CRJFLG		;STORE FOR IT TO SEE
	MOVE T1,CRJUSR		;LET'S DO THE LOGIN NOW.
	HRROI T2,CRJPSW		;PASSWORD, IF ANY.
	MOVE T3,CRJACT		;AND ACCOUNT
	LOGIN			;SEE IF THIS IS ALL VALID.
	 JRST SCJXXX		;APPARENTLY NOT.
	HRRO T1,CRJCAM		;ASKED TO LIMIT CAPABILITIES?
	ANDM T1,CAPENB		;DO SO IF NOT -1
	ANDM T1,CAPMSK		; ..
STCJ1A:	MOVE T2,CRJCPU		;GET TIME LIMIT FOR THIS JOB
	JUMPE T2,SCJBNL		;JUMP IF NO LIMIT
	MOVE T1,[.FHJOB,,.TIMRT] ;SET TIME LIMIT FOR JOB
	MOVEI T3,.ICMSE		;ON MACHINE-SIZE EXC CHANNEL, SO PANIC
	TIMER			;DO IT
	 JRST SCJXXX		;GIVE BACK FAILURE
SCJBNL:	MOVEI T1,.FHSLF		;SET UP TO DO SPJFN
	MOVE T2,CRJPJF		;FROM THIS ARGUMENT
	TXNE Q2,CJ%FIL		;IS THERE BOTH AN EXEC AND AN INFERIOR?
	TXNN Q2,CJ%ETF		; ..
	SKIPA			;NO. DO THE SPJFN HERE.
	JRST STCJ1D		;YES. ONLY DO THE SPJFN ON THE INFERIOR
	TXNE Q2,CJ%SPJ		;REQUESTED TO DO SPJFN?
	SPJFN			;YES, DO IT.
STCJ1D:	HLLZS CRJFLG		;NO FLAGS FOR A LATER LOGIN
	TXNN Q2,CJ%FIL		;WANT TO RUN A FILE?
	JRST CJSTEX		;NO. JUST GO GET THE EXEC.
STCJB2:	TXNE Q2,CJ%ETF		;WANT A FILE. AN EXEC TOO?
	JRST STCJB3		;YES.
	MOVX T1,GJ%OLD!GJ%SHT	;GET THE REQUESTED FILE IN TOP FORK
	HRROI T2,CRJFIL		;POINT TO THE TEXT
	GTJFN			;GET JFN FOR REQUESTED FILE
	 JRST SCJXXX		;CAN'T
	HRLI T1,.FHSLF		;OK, GET IT INTO THIS FORK.
	GET
	ERJMP SCJXX4		;IF GET FAILS, QUIT.
;NOTE: THIS CODE RUNS IN SECTION 0 FOR SOME UNKNOWN REASON. IN
;ORDER FOR THIS CALL TO BLTMU TO WORK CORRECTLY, THIS CODE TEMPORARILY
;ENTERS SECTION 1. IF STRCJB IS MADE TO RUN ENTIRELY IN SECTION 1, THESE
;MACROS SHOULD BE REMOVED.
	SE1ENT
	MOVEI T1,20		; Length of AC block
	XMOVEI T2,CRJFAC	; From there
	SETZ T3,
	TXNE Q2,CJ%ACS		;AC SET REQUESTED?
	CALL BLTMU
	SE0ENT
	MOVEI T1,.FHSLF		;GET THE ENTRY VECTOR
	GEVEC			;GET THE ENTRY VECTOR
	TLNN T2,777000		;TOPS10 STYLE?
	JRST STCJ2A		;NO. TOPS20 STYLE, IF ANYTHING.
	HRRZ T3,CRJEVO		;OLD STYLE. WHERE DOES START POINT?
	CAILE T3,1		;START OR REENTER, I HOPE.
	JRST SCJXX3		;NO. FAIL.
	UMOVE T2,120		;GET JOBSA
	TRNE T3,-1		;OR IF 1,
	UMOVE T2,124		;GET JOBREN
	SKIPA
STCJ2A:	ADD T2,CRJEVO		;NEW STYLE, ADD OFFSET TO BASE.
	HRRZM T2,-1(P)		;WHERE MRETN WILL GO.
	HRLI T2,1		;INDICATE JOB HAS ALREADY SET CRJANS
	HLLM T2,CRJFLG		; BY MAKING FLAG POSITIVE
	SETOM CRJANS		;SAY WE HAVE SUCCEEDED.
	PUSHJ P,SCJWTA		;WAIT FOR ATTACH, IF WANTED
	JRST MRETN		;AND GO TO USER MODE.

;HERE IF WANT BOTH A FILE AND AN EXEC.

STCJB3:	MOVX T1,GJ%OLD!GJ%SHT	;GET A JFN FOR THE FILE.
	HRROI T2,CRJFIL		;WITH SUPPLIED NAME
	GTJFN
	 JRST SCJXXX		;CAN'T FIND THE FILE.
	PUSH P,T1		;SAVE JFN A MOMENT
	MOVX T1,CR%CAP		;CREATE THE NEW FORK, MY CAPS.
	TXNE Q2,CJ%ACS		;WANT SOME AC'S LOADED?
	TXO T1,CR%ACS		;YES, HAVE CFORK LOAD THEM.
	MOVEI T2,CRJFAC		;HERE ARE THE AC'S
	CFORK			;MAKE ME A FORK! (YOU'RE A FORK)
	 JRST SCJXX2		;CAN'T DO IT.
	EXCH T1,0(P)		;GET BACK JFN, SAVE FHANDLE
	HRL A,0(P)		;SET UP FOR THE GET
	GET
	ERJMP SCJXX2		;CAN'T GET THE FILE
	MOVE T1,0(P)		;HANDLE OF INFERIOR
	MOVE T2,CRJPJF		;PRIMARY I/O FOR IT
	TXNE Q2,CJ%SPJ		;IF REQUESTED,
	SPJFN			;SET IT.
	POP P,T1		;INFERIOR FORK HANDLE.
	HRLZS T1		;FORK,,0
	HRR T1,CRJEVO		;WHERE TO START IT.
CJSTEX:	CALL SCJPRA		;SET UP PRARG FOR EXEC
	HRLI T2,1		;INDICATE JOB HAS ALREADY SET CRJANS
	HLLM T2,CRJFLG		; BY MAKING FLAG POSITIVE
	SETOM CRJANS		;DONE WITH THE JSYS
	PUSHJ P,SCJWTA		;WAIT FOR ATTACH, IF REQUESTED
	JRST STEX		;AND GO GET AND START THE EXEC.

;CALL THIS ROUTINE BEFORE GOING TO MRETN FROM CRJOB PATHS. IT WILL
;WAIT FOR JOB TO BECOME ATTACHED, IF THAT'S REQUESTED BY CALLER.

SCJWTA:	TXNN Q2,CJ%WTA		;WANT TO WAIT?
	RET			;NO.
	MOVE T1,JOBNO		;YES. GET MY JOB NUMBER
	MOVEI T1,JOBPT(T1)	;AND JOBPT SLOT FOR THIS JOB
	CALL DISGE		;WAIT FOR LH TO BECOME POSITIVE
	RET			;NOW ATTACHED. RETURN.

SCJXX3:	MOVEI T1,SFRVX1		;BAD ENTRY VECTOR OFFSET
	JRST SCJXXX		;RETURN THAT ERROR
SCJXX2:	POP P,0(P)		;ADJUST STACK POINTER
SCJXX4:	HRRZ T1,LSTERR		;AND RETURN THIS FORK'S LAST ERROR
	JRST SCJXXX		; TO CREATOR
SCJXX1:	MOVEI T1,CRJBX5		;UNKNOWN NAME FOR LOGIN
SCJXXX:	SKIPGE CRJFLG		;IS THIS JOB BEING CREATED
	HRRZM T1,CRJANS		;YES. SET RH NON-ZERO.
	MOVE T1,JOBNO		;MAKE SURE I'M NOT OWNED, SO
	SETOM JOBONT(T1)	;THIS LOGOUT CAN GO THROUGH
	JRST LOGO		;AND KILL OFF THIS STARTED JOB.

;ROUTINE TO SET UP PRARG FOR EXEC TO READ IN NEW JOB

NCJPRA==3			;NUMBER OF ARGUMENT ITEMS
LCJPRA==6			;LENGTH OF BLOCK TO SET

SCJPRA:	TRVAR <<SCJPRB,10>>	;SPACE TO BUILD PRARG BLOCK
	PUSH P,T1		;PRESERVE FORKX,,SFRKV OFFSET
	MOVEI T1,NCJPRA		;NUMBER OF ARGUMENTS
	MOVEM T1,SCJPRB		;INTO THE BLOCK
	MOVEI T1,SCJPRB		;POINT TO BLOCK WITH PUSH POINTER
	PUSH T1,[1B0+3B6+2B12+CR%PRA]	;I AM A CRJOB PRARG
	PUSH T1,[1B0+4]		;WORD 4 IS ANOTHER DATUM
	PUSH T1,[1B0+5]		;WORD 5 IS ANOTHER DATUM
	MOVE T2,CRJEXF		;FLAGS FOR EXEC IS ONE DATUM
	TXNE Q2,CJ%FIL		;IF THERE IS A PROGRAM
	TXO T2,1B1		;TURN ON "THERE'S A FORK" BIT
	PUSH T1,T2		;FLAGS TO ARG BLOCK
	POP P,T2		;RESTORE FORKX,, ENT-VEC-OFFSET
	TXNE Q2,CJ%FIL		;IF THERE IS A PROGRAM
	PUSH T1,T2		;PUT IT IN BLOCK
	MOVE T1,[.PRAST,,.FHSLF] ; SET MY OWN PRARG BLOCK
	MOVEI T2,SCJPRB		;HERE'S THE BLOCK TO SET
	MOVEI T3,LCJPRA		;HERE'S ITS LENGTH
	PRARG			;SET IT
	ERJMP SCJXX4		;CATCH TRAP IF FAILED
	RET			;SUCCESS.

;SYSTEM INITIALIZATION.  RUN ONCE ONLY BY JOB 0.

	SWAPCD

RUNDD::	MOVEI T1,RUNDD3		;GO TO RUNDD3 IF AN INTERRUPT OCCURS
	MOVEM T1,JB0XFR		;SAVE THE ADDRESS FOR JB0INT
	MOVEI T1,JB0INT		;GO TO THE JOB 0 INTERRUPT HANDLER ON
				; INTERRUPT FOR ENABLED CHANNELS
	HRRM T1,MONBK		;SET THIS FOR THE SCHEDULER
	MOVE T1,CTYLNO		;GET CTY LINE NUMBER
	MOVEI T1,.TTDES(T1)	;CONVERT TO 400000+N
	MOVEM T1,JB0TT		;CONTROLLING TERMINAL FOR JOB 0
	HRRM T1,PRIMRY		;AND PRIMARY OUTPUT FOR US
	MOVSI 1,777
	ANDCAM 1,CAPENB		;FLUSH ANY SUPERIOR FORK CAPS
	CALL ASCINI		;Initialize accounting shift change stuff
	CALL RESLCK		;BE SURE ADEQUATE RES FREE SPACE
	CALL SERINI		;START SYSERR LOGGING
	SKIPN PROFLG		;WANT PRIMARY PROTOCOL?
	JRST RUNDI7		;NO. SKIP ALL PRIMARY STUFF
	MOVEI A,.PRIOU		;YES. FIRST WAIT FOR CTY TO STOP
	DOBE			;"
	CALL TTSPIN		;INITIALIZE TERMINAL SPEEDS TO NULL
	CALL PROINI		;TURN ON PRIMARY PROTOCOL
	CALL DTRMDS		;TELL -11 NOT TO ANSWER DATA SETS

;TRY TO GET TIME AND DATE FROM THE 11. DTE SERVICE SENDS THE REQUEST TO
;THE 11 AND STORES ITS ANSWER IN TAD11. IF THE 11 DOES NOT KNOW, IT
;RETURNS -1. IN THIS CASE, ASK THE OPERATOR FOR THE TIME. IF THE 11 HAS
;IT, DON'T ASK THE OPERATOR

	SKIPE SMFLAG		;IF SM10 THEN WE ALREADY HAVE TIME AND DATE CORRECT
	JRST RUNDD3
	SETZM TAD11		;ZERO TIME CELL
	CALL RQTAD1		;REQUEST TIME/DATE FROM 11
	 JFCL			;THIS FAILURE CAN'T OCCUR
	SKIPN TAD11		;HAS 11 SENT TIME/DATE YET?
	JRST .-1		;NO. WAIT UNTIL IT DOES
	MOVE B,TAD11		;GET TIME SENT FROM -11
	SETOM TAD11		;YES. RESET TO INDICATE NOT SET BY 11
	CAMN B,[-1]		;DOES THE -11 HAVE IT?
	JRST RUNDI7		;NO
	DMOVE C,TAD11+1		;YES. GET REST OF IDCNV ARGS
	IDCNV			;CONVERT TO INTERNAL
	 JRST RUNDI7		;FAILED. GET FROM OPERATOR THEN
	MOVEM B,CRSTAD		;LET IT FIND IT LATER

	;..
;RUNDD...
;SET SYSTEM TIME AND DATE IF THE 11 PROVIDED IT

	;..
RUNDI7:	MOVEI 1,101
	DOBE
	SKIPN 1,CRSTAD		;DO WE HAVE A SAVED TIME FROM CRASH?
	JRST [	MOVX A,SF%MST	;NO. SAY IS A MANUAL START
		IORM A,FACTSW	;""
		JRST RUNDD3]
	STAD			;YES, SET IT
	 JFCL
	SETZM CRSTAD

;Initialize checkpoint interval

RUNDD3:	MOVEI T1,RUNDI4		;GO TO RUNDI4 IF AN INTERRUPT OCCURS
	MOVEM T1,JB0XFR		;SAVE THE ADDRESS FOR JB0INT
	MOVE T1,[^D<10*60000>]	;SET DEFALUT CHECKPOINT INTERVAL
	MOVEM T1,CKPINV		;...

;RUN SETSPD TO SET LINE SPEEDS, SYSTEM LOGICAL NAMES, OTHER SYSTEM
;PARAMETERS

	MOVX T1,GJ%OLD!GJ%SHT!GJ%PHY ;YES. SET LINE SPEEDS
	HRROI T2,SETSPD		;GET POINTER TO "SYSTEM:X-SETSPD.EXE"
	SETZ T3,		;3/OFFSET 0 IN ENTRY VECTOR
	CALL RUNDII		;GO RUN IT
	 JRST [	HRROI T1,[ASCIZ/
%%No SETSPD
/]
		PSOUT
		MOVEI T1,.PRIOU ;WAIT UNTIL THE TERMINAL
		DOBE		; STOPS SO THE NEXT MESSAGE IS OK
		JRST .+1]	;SAY IT FAILED
	CALL GETNAM		;DO AGAIN,SINCE SYSTEM: MAY BE REDEFINED

;IF DBUGSW IS 0 OR 1, TELL ALL USERS THAT SYSTEM IS RESTARTING

RUNDD6:	MOVE 1,DBUGSW
	CAIE 1,0
	CAIN 1,1		;REGULAR STARTUP?
	SKIPA
	JRST RUNDI4		;NO, DON'T NOTIFY WORLD
	SETO 1,
	HRROI 2,[ASCIZ /
System restarting, wait...
/]
	TTMSG
	;..
;RUNDD...

;GET DATE AND TIME FROM OPERATOR UNLESS 11 SENT IT EARLIER

	;..
RUNDI4:	MOVEI T1,RUNDI1		;GO TO RUNDI1 IF AN INTERRUPT OCCURS
	MOVEM T1,JB0XFR		;SAVE THE ADDRESS FOR JB0INT
	CALL LGTAD		;DOES SYSTEM HAVE TIME AND DATE?
	CAME A,[-1]
	JRST RUNDI1		;YES

;133 Begin addition
	MOVX T1,GJ%OLD!GJ%SHT	; If CHRON exists...
	HRROI T2,[ASCIZ |SYSTEM:CHRON.EXE|]
	GTJFN
	 JRST RUNDI3		; It doesn't
	RLJFN			; We just want to see if it's there...
	 JFCL
	JRST RUNDI1		; Bypass time-setting and let it happen later
; If CHRON doesn't exist, ask poor operator
;133 End addition

RUNDI3:	TMSG <
Enter current date and time: >
RUNDI2:	CALL RDDGTD		;GET TAD INTO 2
	PUSH P,2		;SAVE TAD JUST ENTERED
	TMSG <
You have entered >
	MOVEI 1,.PRIOU
	MOVE 2,0(P)
	MOVX 3,1B1+1B2+1B4+1B5+1B10+1B11+1B17
	ODTIM			;TYPE IT IN VERBOSE FORMAT
	MOVE 2,0(P)
	CAMGE 2,SYSTAD		;IS IT GREATER THAN SYSTEM LOAD TAD?
	JRST [	MOVEI 1,.PRIIN	;CLEAR TYPE AHEAD
		CFIBF
		MOVEI 1,.PRIOU
		DOBE		;WAIT FOR TYPE OUT TO STOP
		TMSG <,
that cannot be correct.
Please try again in form MMM-DD-YY HHMM >
		JRST RUNDI2]
	TMSG <,
 is this correct (Y,N) >
	CALL YESNO		;GET VERIFICATION
	JUMPE A,RUNDI3		;IF 'NO', TRY AGAIN
	POP P,1			;CONFIRMED, RECOVER IT
	STAD			;SET IT
	 JFCL
	; ..

;RUNDD...

;DECIDE WHETHER TO RUN CHECKD OR NOT. IF CHKBT FOUND ERRORS, FACTSW HAS
;SF%BTE SET; RUN CHECKD TO DO A BIT TABLE CONSISTENCY CHECK. IF BIT
;TABLE FILE DOESN'T EXIST, MI%ASG IS SET IN SDB. DON'T RUN CHECKD.
;(OPERATOR WILL HAVE TO RUN IT WITH THE REBUILD FUNCTION). IF DOING
;RECONSTRUCTION OF ROOT-DIRECTORY OR REBUILD OF BIT TABLE, STARTF HAS
;MI%BTB SET; RUN CHECKD TO DO A REBUILD OF THE BIT TABLE.  IF DOING
;A REFRESH OF THE FILE SYSTEM, DON'T TRY TO RUN CHECKD. IF NONE OF
;THE ABOVE, ASK THE OPERATOR UNLESS AUTO RELOADING. IN ALL CASES,
;ONLY PS IS MOUNTED AT THIS POINT, SO CHECKD IS ONLY RUN ON PS.

	;..
RUNDI1:	MOVEI T1,RUNDD1		;GO TO RUNDD1 IF AN INTERRUPT OCCURS
	MOVEM T1,JB0XFR		;SAVE THE ADDRESS FOR JB0INT
	CALL LOGSST		;LOG RESTART IN SYSERR FILE
	SKIPN AVALON		;RUNNING ACCOUNT VALIDATION?
	JRST RUNDI5		;NO, PROCEED
	CALL ENACT		;INITIALIZE THINGS FOR ACCT VALIDATION
	 JRST [	TMSG <
<SYSTEM>ACCOUNTS-TABLE.BIN not found - Account validation is disabled
>
		SETZM AVALON	;TURN OFF VALIDATION
		JRST .+1]	;AND PROCEED

RUNDI5:	MOVX T4,MI%BTB		;IF REBUILDING THE BIT TABLE (BIT IS
	TDNE T4,STARTF		; SET BY FILINI)
	JRST RUNDC2		;ALWAYS RUN CHECKD IN REBUILD MODE
	MOVE 2,DBUGSW		;IF DEBUGGING,
	CAIN 2,2
	JRST RUNDD2		;DON'T RUN CHECKD
	MOVX T4,MI%RFS		;IF REFRESHING (BIT IS SET
	TDNE T4,STARTF		; BY FSIINI)
	JRST RUNDD2		;DON'T RUN CHECKD (IT ISN'T THERE)
	MOVE T2,STRTAB+PSNUM	;POINT TO SDB FOR PS
	MOVE T2,SDBSTS(T2)	;GET STATUS BITS FOR PS
	MOVE T1,FACTSW
	TXNE T1,SF%BTE		;BIT TABLE ERRORS?
	TXNE T2,MI%ASG		;YES. ARE DISK ASSIGNMENTS PROHIBITED?
	SKIPA			;YES. DON'T RUN CHECKD
	JRST RUNDC1		;BIT TABLE ERRORS BUT BT FILE EXISTS. RUN CHECKD
	TXNN A,SF%MST		;MANUAL STARTUP?
	JRST RUNDD2		;NO. NO QUESTIONS AND NO CHECKD
	;..

;CHECKD NOT REQUIRED.  SEE IF OPERATOR WANTS IT

	;..
	TMSG <Run CHECKD? >
	CALL YESNO
	JUMPE A,RUNDD2		;JUMP IF NO
RUNDC1:	SKIPA T1,[-1,,[ASCIZ/[Checking file consistency]
/]]
RUNDC2:	HRROI T1,[ASCIZ/[Rebuilding bit table]
/]
	PSOUT
	MOVSI 1,(GJ%OLD!GJ%PHY!GJ%SHT)
	HRROI 2,[ASCIZ /SYSTEM:CHECKD.EXE/]
	MOVX T3,SF%CDR		;SAY CHECKD NOW RUNNING
	IORM T3,FACTSW		;DO IT
	SETZ T3,		;NORMAL ENTRY POINT
	MOVX T4,MI%BTB
	TDNE T4,STARTF		;REBUILDING BIT TABLE?
	MOVEI T3,3		;YES. START AT SPECIAL ENTRY POINT
	CALL RUNDII		;GO START IT
	 JRST [	MOVX T1,SF%CDR	;NOT RUNNING
		ANDCAM T1,FACTSW
		JRST RUNDD1]	;FAILED
	SETZM STARTF		;INDICATE STARTUP IS COMPLETE
	MOVX T1,SF%CDR		;SAY CHECKD NOT RUNNING ANYMORE
	ANDCAM T1,FACTSW	;""
	JRST RUNDD2		;PROCEED

;FAILED TO FIND CHECKD WHEN RUNNING IT WAS REQUIRED BY THE SYSTEM
;OR REQUESTED BY THE OPERATOR. PRETEND THAT IT RAN AND FOUND
;ERRORS. IF IT IS RUN LATER AND FINDS PS TO BE OK, IT WILL CLEAR
;SF%CDE.
;IT ALSO CAUSES THE 'FILE STRUCTURE NEEDS REPAIR' MESSAGE BELOW
;AND PREVENTS SYSJOB FROM DOING ITS USUAL THING

RUNDD1:	MOVEI T1,RUNDD2		;GO TO RUNDD2 IF AN INTERRUPT OCCURS
	MOVEM T1,JB0XFR		;SAVE THE ADDRESS FOR JB0INT
	TMSG <
No CHECKD
>
	SETZM STARTF		;INDICATE STARTUP COMPLETED
	MOVX T4,SF%CDE		;PRETEND CHECKD FOUND ERRORS
	IORM T4,FACTSW
	;..
;RUNDD...

;IF DEBUGGING, TELL ALL USERS. IF CHECKD FOUND ERRORS, TELL ALL USERS
;THEN PROCEED AS USUAL

	;..
RUNDD2:	MOVEI 1,RUNDD7		;GO TO RUNDD7 IF AN INTERRUPT OCCURS
	MOVEM T1,JB0XFR		;SAVE THE ADDRESS FOR JB0INT
	MOVEI 1,101
	DOBE			;WAIT FOR ANY CHECKD OUTPUT
	MOVE 1,DBUGSW
	CAIL 1,2		;DEBUG MODE OPERATION?
	JRST [	SETO 1,		;YES, DIFFERENT MESSAGE
		HRROI 2,[ASCIZ /
[System is stand-alone]
/]
		TTMSG
		JRST RUNDE1]
	MOVX 1,SF%CDE
	TDNE 1,FACTSW		;DID CHECKD FIND DISK ERRORS?
	JRST [	MOVX 1,SF%RMT+SF%PTY+SF%LCL+SF%NVT	;15 YES, DISALLOW
		ANDCAM 1,FACTSW	;15 ALL NON-CTY LOGINS
		CALL LCKINI##	;15 KEEP EDDT AROUND AND
		MOVEI 1,2	;15 SET SYSTEM INTO DEBUG MODE
		MOVEM 1,DBUGSW	;15 
		HRROI 2,[ASCIZ /
[System not in operation - file structure needs repair]
/]
		SETO 1,
		TTMSG
		JRST RUNDE1]

;INITIALIZE SYSERR LOGGING AND START ACCOUNTING

RUNDE1:	MOVE 1,JB0TT		;JOB 0 TTY
	CAIE 1,377777		;REAL TTY?
	JRST RUNDD4		;YES
	MOVEI 1,ERRPT		;GET NAME OF SYSTEM ERROR FILE
	CALL PUTNAM		;ADD STRUCTURE NAME
	MOVSI 1,(GJ%FOU!GJ%PHY!GJ%SHT)	;NONE, SO OPEN FILE FOR MESSAGES
	HRROI 2,ERRPT		;GET NAME OF SYSTEM ERROR FILE
	GTJFN
	 BUG(NOSERF)
	MOVE 2,[44B5+1B20]
	OPENF
	 BUG(SERFOF)
RUNDD4:	HRRM 1,PRIMRY		;USE IT FOR OUTPUT
	CALL USGINI		;START ACCOUNTING
	;..

;RUN SETSPD AGAIN. THIS TIME, START IT AT A SPECIAL PLACE TO MAKE
;IT COPY THE DUMP FILE.

	;..
	MOVX T1,SF%CDE		;DON'T CREATE DUMP.CPY IF THE BIT
	TDNE T1,FACTSW		; TABLE IS BAD
	JRST RUNDD7		;CHECKD FOUND ERRORS IN THE BT
	MOVX T1,GJ%OLD!GJ%PHY!GJ%SHT
	HRROI T2,SETSPD		;GET POINTER TO "SYSTEM:X-SETSPD.EXE"
	MOVEI T3,3		;3/ OFFSET 3 IN ENTRY VECTOR
	CALL RUNDII		;GO RUN IT
	 JFCL			;IGNORE FAILURE

;DO NETWORK-RELATED FUNCTIONS

RUNDD7:	MOVEI T1,RUNDD8		;GO TO RUNDD8 IF AN INTERRUPT OCCURS
	MOVEM T1,JB0XFR		;SAVE THE ADDRESS FOR JB0INT
;Begin modification
IFN MNET,<
	CALL MNTINI		; Initialize Multinet tables etc.
>
IFE MNET,<
;3032	CALL IMPBEG		;START NCP FORK, IF ANY.
	CALL CHAINI		;INITIALIZE CHAOSNET AND ASSOCIATED FORKS
>
;1001 End modification
	CALL KDPINI		;INIT THE KDP(KMC11/DUP11) CODE
	CALL NSPINI		;INIT DECNET FORK AND DATA BASE
	CALL ATSINI		;INITIAALIZE APPLICATIONS TERMINAL SERVICE
	TMSG <
Running DDMP

>
RUNDD8:	MOVEI T1,RUNDD5		;GO TO RUNDD5 IF AN INTERRUPT OCCURS
	MOVEM T1,JB0XFR		;SAVE THE ADDRESS FOR JB0INT
	AOS SYSIFG		;INDICATE NO LONGER IN STARTUP
				; (NEXT JOB WON'T GO THROUGH RUNDD)
	CALL DONSJ		;START NEXT SPECIAL JOB

;CREATE FORK UNDER JOB 0 AND RUN SYSJOB IN IT. SYSJOB READS A COMMAND
;FILE, WHOSE NAME IS DETERMINED BY THE SETTING OF DBUGSW. IF CHECKD
;HAS NOT BLESSED THE PRIMARY STRUCTURE (SF%CDE IS SET IN FACTSW), SYSJOB
;DOES NOT READ A COMMAND FILE.  AMONG OTHER THINGS, THIS WILL PREVENT
;LOGINS FROM TERMINALS OTHER THAN THE CTY

	MOVX T1,<GJ%OLD!GJ%PHY!GJ%SHT>
	HRROI T2,[ASCIZ /SYSTEM:SYSJOB.EXE/]
	SETZM T3		;MAIN ENTRY POINT
	CALL RUNDIR		;RUN SYSJOB AND RETURN
	 JRST [	 TMSG<
No SYSJOB
>
		JRST .+1]
RUNDD5:	MOVEI 1,1		;KEEP JOB 0 IN QUEUE 1 ALWAYS
	MOVEM 1,JOBBIT		;SET PRIORITY FOR CHKR
	MOVEI T1,CHKR		;GO TO CHKR IF AN INTERRUPT OCCURS
	MOVEM T1,JB0XFR		;SAVE THE ADDRESS FOR JB0INT
	SETZM EXPFRK		;CLEAR FORK HANDLE
	SKIPN SMFLAG		;IF NOT 2020
	CALL RUNMO1		; RUN MOS MEM DIAG
	SE1ENT			;1001 Enter section 1, then
	JRST CHKR		;GO DO BACKGROUND

;JB0INT - HERE WHEN INTERRUPT OCCURS IN FORK 0

;THIS ROUTINE IS POINTED TO BY MONBK. THE SCHEDULER TRANSFERS
;CONTROL TO HERE WHEN AN INTERRUPT OCCURS ON CHANNEL 34 OR 35 IN
;FORK 0. JB0XFR CONTAINS THE ROUTINE TO WHICH THIS CODE TRANSFERS
;AFTER CLEANING THINGS UP

;NOTE: THIS ROUTINE PRINTS THE CONTENTS OF MONPC, WHICH TYPICALLY
;CONTAINS THE PC AT THE TIME OF THE ERROR. HOWEVER, THIS MAY NOT ALWAYS
;BE THE CASE. THAT'S WHY IT SAYS "PROBABLE PC".

JB0INT:	MOVE P,UPP		;RESET THE STACK
	ADD P,BHC+4		; TO SIMULATE JSYS ENTRY
	MOVEI 1,<UACB>B39-1	;SETUP AC BASE
	MOVEM 1,ACBAS		; TO POINT TO THE FIRST BLOCK
	MOVE P1,MONPC		;SAVE THE PC WHERE ERROR OCCURRED
	MOVEI T1,J0EMER		;IN CASE OF EMERGENCY
	HRRM T1,MONBK		; DON'T EVEN DO ALL THIS
	SETZM NSKED		;BE OKSKED
;1001	SETZM CRSKED		;BE NOT 'CRITICAL SECTION'
	SETZM SLOWF
	SETOM INTDF		;IN CASE OVERLY OKINT
	CALL CLRINT		;CLEAR THE INTERRUPT SYSTEM
	MOVE T1,FORKX		;T1/ FORK NUMBER
	SETZM T2		;T2/ ALL INTERRUPT LEVELS
	CALL JSBSTF		;CLEAN THE JSB STACK
	MOVE T1,FORKX		;T1/ FORK NUMBER
	SETZM T2		;T2/ ALL LEVELS
	CALL GOKFRE		;CLEAN UP GETOK QUEUES (SHOULDN'T HAVE ANY)
	HRROI T1,[ASCIZ /
%MONITOR: Job 0 crash, probable PC /]
	PSOUT			;TELL OPERATOR THAT WE DIED
	MOVEI T1,.PRIOU		;PRIMARY OUTPUT DEVICE
	MOVE T2,P1		;GET PC AT TIME OF ERROR
	MOVEI T3,^D8		;OCTAL
	NOUT			;GIVE THE PC
	ERJMP .+1		;IGNORE ERRORS
	HRROI T1,[ASCIZ /, continuing at PC /]
	PSOUT			;MORE INFORMATION
	MOVEI T1,.PRIOU		;PRIMARY OUTPUT DEVICE
	MOVE T2,JB0XFR		;CONTINUATION ADDRESS
	MOVEI T3,^D8		;OCTAL
	NOUT			;GIVE THE PC
	ERJMP .+1		;IGNORE ERRORS
	HRROI T1,[ASCIZ/, last error was /]
	PSOUT
	MOVEI T1,.PRIOU		;PRIMARY OUTPUT DEVICE
	MOVE T2,LSTERR		;CONTINUATION ADDRESS
	MOVEI T3,^D8		;OCTAL
	NOUT			;GIVE THE PC
	ERJMP .+1		;IGNORE ERRORS
	HRROI T1,[ASCIZ/
/]				;FINISH WITH A CRLF
	PSOUT			;TYPE IT
	MOVEI T1,JB0INT		;BACK TO HERE IF ANOTHER INTERRUPT
	HRRM T1,MONBK		; NOW THAT WE SURVIVED THIS ROUTINE
	MOVE T1,JB0XFR		;SEE WHERE WE ARE TO GO NEXT
	JRST 0(T1)		; AND GO THERE

;HERE WHEN AN ERROR OCCURRED WHILE IN JB0INT. GIVE UP.

J0EMER:	BUG (STRTER)

;CLRINT - CLEAR THE INTERRUPT SYSTEM

CLRINT:	MOVEI 1,400000		;DEACTIVATE SOFTWARE INTERRUPT CHANNELS
	SETO 2,			; FOR THIS PROCESS

	DIC
	CALL DTIALL		;IN CASE PROGRAM TURNED ANY ON
	MOVE 2,PSIBW
	CIS			;CLEAR ALL INTERRUPTS IN PROGRESS
	RET
;ROUTINE TO RUN A PROGRAM IN A FORK UNDER JOB 0
; A/ GTJFN T1 ARGS
; B/ GTJFN T2 ARGS
; C/ OFFSET IN ENTRY VECTOR WHERE WE START FORK
;	CALL RUNDII
;	  or
;	CALL RUNDIR
;RETURNS +1: FAILED, PROGRAM NOT RUN
;	 +2: RUNDII - PROGRAM RAN TO COMPLETION, FORK KILLED
;	     RUNDIR - PROGRAM STARTED,  A/ FORK HANDLE

RUNDIR:	TDZA T4,T4		;NO WAIT FLAG
RUNDII::SETOM T4		;WAIT FLAG
	STKVAR<EVEC,WFLAG,FKHNDL,FILJFN>
	MOVEM C,EVEC		;SAVE OFFSET IN ENTRY VECTOR
	MOVEM T4,WFLAG		;SAVE WAIT FLAG
	GTJFN
	 RET			;FAILED
	MOVEM T1,FILJFN		;SAVE JFN
	MOVX T1,CR%CAP		;XMIT CAPABILITIES
	CFORK			;CREATE A FORK FOR CHECKD
	 JRST [	EXCH T1,FILJFN	;SAVE ERROR CODE. GET JFN
		RLJFN		;RELEASE IT
		 NOP
		MOVE T1,FILJFN	;GET BACK ERROR CODE
		RET]		;AND DONE
	MOVEM T1,FKHNDL		;SAVE FORK HANDLE
	PUSH P,CAPENB		;SAVE ENABLED CAPABILITIES
	HLLOS CAPENB		;MAKE THIS A WHEEL
	MOVE T2,JOBBIT		;SET TO SAME AS OURS
	SPRIW			;BY SETTING PRIORITY WORD
	ERJMP .+1		;JUST IN CASE
	POP P,CAPENB		;RESTORE CAPABILITIES
	HRL T1,FKHNDL		;FORK HANDLE TO LH
	HRR T1,FILJFN		;JFN TO RH
	GET
	 ERJMP [MOVE T1,FKHNDL	;GET FORK HANDLE
		KFORK		;KILL THE FORK
		RET]		;AND DONE
	MOVE T1,FKHNDL		;GET FORK HANDLE
	MOVE 2,EVEC		;2/OFFSET IN ENTRY VECTOR
	SFRKV			;START AT MAIN ENTRY
	 ERJMP [MOVE T1,FKHNDL	;GET HANDLE
		KFORK		;KILL FORK
		RET]
	SKIPN WFLAG		;WANT TO WAIT?
	RETSKP			;NO. RETURN NOW
	WFORK
	KFORK
	RETSKP			;ALL DONE
;ROUTINE TO MAKE RESTART ENTRY IN SYSERR FILE

LOGSST:	TRVAR <<RDDBFR,.RLBSZ>>
	SAVEQ
	JE SF%MST,FACTSW,LOGSS3	;JUMP IF AUTO RESTART
	SKIPE DBUGSW		;133 Or if in other than timesharing mode
	 JRST LOGSS1		;133 
LOGSS1:	TMSG <Why reload? >	;MANUAL RESTART, FIND OUT WHY
	HRROI T1,RDDBFR
	MOVX T2,RD%BRK+RD%BEL+RD%CRF+20*5
	MOVEI T3,0
	RDTTY			;GET ANSWER
	 JFCL

;1002 *** use old way of checking answer
	LDB T3,[POINT 7,RDDBFR,6] ;GET FIRST CHAR OF ANSWER
	CAIN T3,"?"		;HELP WANTED?
	JRST [	HRROI T1,LOGMSG	;YES, TYPE MESSAGE
		PSOUT
		JRST LOGSS1]	;TRY AGAIN
	CAIN T3,.CHLFD		;NULL ANSWER?
	JRST [	HRROI T1,[ASCIZ/? Null answer is not allowed!
/]
		PSOUT
		JRST LOGSS1]
	SETZ T3,		;FLUSH TERMINATOR (PRESUMABLY NL)
	DPB T3,T1
;1002 end of replaced 'why reload' code

repeat 0,<	;1002 flush new code
	SETZ T3,		;FLUSH TERMINATOR (PRESUMABLY NL)
	DPB T3,T1
	MOVE T1,[-RLALEN,,RLATAB] ;SET TO VERIFY HIS ANSWER
	CALL MATRLA		;SEE IF ANSWER MATCHES TABLE
	 JRST LOGSS2		;NO, TELL HIM HIS CHOICES
	AOBJP T1,LOGSS3		;YES, SEE IF IT'S UNIQUE
	CALL MATRLA		;ANY OTHER MATCHES?
	 JRST LOGSS3		;NO, THIS IS A WINNER
LOGSS2:	HRROI T1,LOGMSG		;TYPE LEGAL ANSERS
	PSOUT
	JRST LOGSS1		;TRY, TRY AGAIN
>	;1002 end repeat 0

LOGSS3:	MOVX T1,RL%LEN
	MOVX T2,RL%SIZ
	CALL ALCSEB		;GET SYSERR STORAGE
	 JRST [BUG(SYSERF)
		RET]
	MOVEM T1,Q1
	MOVE T2,[-NWHYIT,,WHYIT]
	CALL SEBCPY		;COPY DATA INTO BLOCK
	 JFCL
	MOVE T2,[-1,,[SEBPTR RL%OPR,SBTSTR,RDDBFR]]
	MOVE T3,FACTSW
	TXNN T3,SF%MST		;USE OPR ANSWER IF MANUAL START
	MOVE T2,[-1,,[SEBPTR RL%HLT,SBTWD,BUGHLT]]
	MOVE T1,Q1		;USE BUGHLT ADDRESS OTHERWISE
	CALL SEBCPY
	 JFCL
	MOVE T1,Q1
	CALL QUESEB		;QUEUE BLOCK FOR SYSERR FILE
	RET
;ROUTINE TO SEE IF RDDBFR MATCHES ENTRY IN TABLE
;CALL T1/AOBJN POINTER TO TABLE
;RETURNS +1 NO MATCH
;RETURNS +2 MATCH
MATRLA:	MOVE T2,[POINT 7,RDDBFR,] ;POINTER TO HIS ANSWER
	MOVE T3,[POINT 7,(T1),]   ;POINTER TO LEGAL ANSWERS
MATRL1:	ILDB T4,T2		;GET NEXT CHAR OF HIS ANSWER
	JUMPE T4,MATRL3		;DONE IF A ZERO CHARACTER
	CAIE T4," "		;END OF FIRST WORD?
	CAIN T4,.CHLFD		;END OF LINE?
	JRST MATRL3		;YES
	ILDB CX,T3		;NO, GET NEXT CHAR OF THIS ANSWER
	CAIN CX,(T4)		;MATCH?
	JRST MATRL2		;YES, KEEP ON GOINT
	AOBJN T1,MATRLA		;NO, TRY NEXT TABLE ENTRY
	RET			;NO MATCH -  NON SKIP RETURN
MATRL2:	TLNN T3,760000		;END OF THIS TABLE ENTRY?
	RETSKP			;YES, SKIP RETURN
	JRST MATRL1		;NO, LOOK AT NEXT CHARACTER HE TYPED
MATRL3:	CAME T2,[POINT 7,RDDBFR,6] ;ANYTHING BEFORE THE END-OF-LINE?
	RETSKP			;YES, TAKE MATCH-RETURN
	RET			;NO, NON-MATCH

RLATAB:	ASCIZ	/OPR/
	ASCIZ	/PARIT/
	ASCIZ	/POWER/
	ASCIZ	/STATI/
	ASCIZ	/HARDW/
	ASCIZ	/HALT/
	ASCIZ	/HUNG/
	ASCIZ	/PM/
	ASCIZ	/CM/
	ASCIZ	/SA/
	ASCIZ	/NEW/
	ASCIZ	/SCHED/
	ASCIZ	/OTHER/
RLALEN==.-RLATAB
LOGMSG:	ASCIZ #
LIST OF POSSIBLE WHY RELOAD ANSWERS (CAN BE ABBREVIATED)
OPERATOR SHOULD ANSWER THE EARLIEST ONE
IN TABLE WHICH APPLIES (WHEN MORE THAN ONE DOES)
ANY COMMENT (UP TO 72 CHARACTERS) MAY BE APPENDED TO AN ANSWER

PREVIOUS SYSTEM PROBLEM:
	OPR
	PARITY
	POWER
	STATIC
	HARDWARE
	HALT
	HUNG
	PM
	CM
	SA
DIFFERENT MONITOR WANTED:
	NEW
	SCHED
OPERATOR DOESNT KNOW OR NOT IN TABLE:
	OTHER
#

;POINTER TABLE TO BUILD RELOAD ENTRY

WHYIT:	SEBPTR 0,SBTEVC,SEC%RL	;EVENT CODE (IMMEDIATE)
	SEBPTR RL%SVN,SBTSTR,SVN ;SYSTEM NAME
	SEBPTR RL%STD,SBTWD,SYSTAD ;BUILD TAD
	SEBPTR RL%VER,SBTWD,[EXP SVNM] ;SYSTEM VERSION NUMBER
	SEBPTR RL%SER,SBTWD,APRSER ;APR SERIAL NUMBER
NWHYIT==.-WHYIT

;LOCAL ROUTINE TO READ TAD FROM CTY
;	CALL RDDTAD
; RETURN +1 ALWAYS, 2/ TAD

RDDGTD:	STKVAR <<RDDBFR,20>>
RDDGT1:	HRROI 1,RDDBFR
	MOVE 2,[RD%BRK+RD%BEL+RD%RAI+20*5]
	MOVEI 3,0
	RDTTY			;READ LINE FROM CTY
	 JRST RDDGT2		;FAILED, REPROMPT
	TXNN 2,RD%BTM		;BREAK CHAR TERMINATED INPUT?
	JRST RDDGT2		;NO, GARBAGE INPUT
	HRROI 1,RDDBFR
	MOVEI 2,0
	IDTIM			;CONVERT STRING TO TAD
	 JRST RDDGT2		;INVALID, REPROMPT
	RET			;OK, RETURN IT

RDDGT2:	TMSG <
? Invalid, please try again in form MMM-DD-YY HHMM: >
	JRST RDDGT1		;TRY AGAIN


;EACH SPECIAL JOB CALLS THIS TO DETACH AND START THE NEXT ONE

DONSJ:	CALL LOGONM		;RECORD START OF CURRENT JOB ON LOGGING TERMINAL
	MOVE 4,CTRLTT		;SAVE THIS JOB'S CONTROLLING TERMINAL
	DTACH			;DETACH THE CURRENT JOB
	MOVE 1,JB0TT
	HRRM 1,PRIMRY		;USE JOB 0 TTY FOR ANY OUTPUT
	MOVE 1,JOBNO		;GET CURRENT JOB NUMBER
	CAIL 1,NSPECJ-1		;MORE SPECIAL JOBS TO DO?
	JRST [	MOVX T1,SF%PTY!SF%CTY ;NO. ALLOW CTY AND PTY LOGINS
		IORM T1,FACTSW
		RET]		; AND DON'T CREATE ANOTHER JOB
	MOVE 2,4		;YES. GET LINE NUMBER FOR CALL
	CALLRET SPCSTJ		;START ANOTHER JOB ON SAME TTY

SPCSTJ:	NOSKED
	PUSH P,T2		;SAVE LINE NUMBER
	CALL STADYN		;GET ADDRESS OF DYNAMIC DATA
	 SKIPA			;NOT FULLY ACTIVE
	JRST [	POP P,2
		OKSKED
		RET]
	JUMPG T2,SPCST1		;IF TEMPORARILY ACTIVE, WAIT
	POP P,2			;GET LINE NUMBER BACK
	SETOM TTACTL(T2)	;INDICATE JOB STARTING
	MOVEI 1,JOBSRT		;REQUEST JOB STARTUP FROM SCHED
	HRL 1,2
	CALL SCDRQ7
	OKSKED
	RET

;LINE IS TEMPORARILY IN USE. WAIT UNTIL IT'S AVAILABLE

SPCST1:	POP P,1			;RESTORE LINE NUMBER
	OKSKED
	HRLZS T1		;T1/ (LINE NUMBER,,ROUTINE)
	HRRI T1,TSACT1		;ROUTINE TO WAIT FOR LINE
	PUSH P,T2
;1001	MOVSI T2,FHV1		;LOW BLOCK PRIORITY
;1001	HDISMS
	MDISMS			;1001
	POP P,T2
	JRST SPCSTJ

;GET SWAPPABLE MONITOR

	RESCD

;BOOT DEVICE TABLE--DISPATCH ON CONTENTS OF BOOTFL TO SELECT DEVICE

BOOTD:	PHASE 0
	JRST GSMDSK		;0 - DSK (VBOOT)
	REPEAT 2,<JRST GSMDSK>	;EVERYTHING IS DISK
IRBOOT::!JRST GSMIRB		;INTERNAL REBOOT
	DEPHASE
NBOOTD==.-BOOTD

GETSWM::
	SETZM SWPMWF		; INITIALIZE SWAPPABLE MON WRITERS FLAG
	SETOM SWPMLF		; INIT COUNT OF LOCKERS OF SWP MON
	SKIPN EDDTF		;KEEP EDDT?
	CALL ULKINI		;NO, UNLOCK IT
	NOSKED
	MOVE 1,BOOTFL		;GET DEVICE SELECTOR
	CAIL 1,NBOOTD		;LEGAL?
	BUG(ILBOOT)
	JRST BOOTD(1)		;GO TO SELECTED BOOTSTRAP

;COMMON EXIT POINT FOR ALL DEVICES

LOKSM3:	SETZ T1,
	MOVEI T2,HOMPGA
	CALL SETMPG		;CLEAR BOOT PAGE
	MOVE T1,DBUGSW		;WRITE PROTECT?
	CAIN T1,1		;?
	SKIPE WEFLAG
	CAIN T1,0
	CALL SWPMWP		;YES - IF NOT DEBUGGING
	OKSKED
	SKIPE SMLKF		;KEEP SWPMON LOCKED?
	CALL SWPMLK		;YES, RE-LOCK IT
	RET

RS(SWPMBP,1)			;STORAGE FOR SWPMON BOUND PAIR
RS(BOOTST,^D20)			;STORAGE FOR VBOOT COMMAND

;INTERNAL REBOOT - ASSUMES SWAP MON MAP FROM PREVIOUS RUN IS
;SAVED IN LOW CORE

GSMIRB:	CALL RESSMM		;RESTORE MON MAP
	JRST LOKSM3		;DONE

;THE DECTAPE BOOTSTRAP


;HERE TO BOOTSTRAP THE SWAPABLE MONITOR FROM DISK

GSMDSK:	HRRZ T1,BUTPGS		;GET END PAGE OF VBOOT AREA
	HLRZ T2,BUTPGS		;GET START PAGE OF VBOOT AREA
	SUB T1,T2		;COMPUTE # OF PAGES IN VBOOT AREA
	SUBI T1,1000		;TWO LESS SINCE WE DON'T LOCK BOOT'S EPT/MMAP
	LSH T1,-PGSFT		;GET PAGES
	MOVE T2,TOTRC		;GET TOTAL FREE
	SUB T2,T1		;COMPUTE FREE PAGES AFTER VBOOT
	SUB T2,SUMNR		;DISCOUNT FORK OVERHEAD PAGES
	SKIPG P1,T2		;SAVE IN P1
	BUG(BOOTCR)
	LSH P1,PGSFT		;CONVERT TO WORDS

; MAP BOOTSTRAP PAGES

	HRRZ P2,BUTPHY		;GET CORE ADDRESS OF FIRST PAGE
	LSH P2,-^D9		;CONVERT TO CORE PAGE #
	HLL P2,BUTPHY		;GET - # OF PAGES TO MAP
	MOVE P3,BUTVIR		;GET FIRST VIRTUAL ADR TO MAP
GSMD1:	HRRZ T1,P2		;GET PAGE # TO MAP
	MOVE T2,P3		;GET VIRTUAL ADDRESS
	CALL MAPPHA		;GO MAP A PHYSICAL PAGE
	 BUG(BOOTMP)
	ADDI P3,PGSIZ		;NEXT VIRTUAL ADDRESS
	AOBJN P2,GSMD1		;MAP REMAINING PAGES

	HRL T1,MMSPTN		;GET SPTN OF MONITOR MAP
	HRRI T1,KIEPT/PGSIZ	;FORM I.D. OF EPT
	HLRZ T2,BUTEPT		;GET VIRTUAL ADDRESS OF BOOT'S EPT
	TXO T2,PTRW		;ACCESS BITS
	CALL SETMPG		;GET INDIRECT POINTER TO EPT
	MOVEI T1,MMAP		;BUILD POINTER FOR VBOOT TO PAGE TABLE
	LSH T1,-PGSFT		; ...
	HRL T1,MMSPTN		; ...
	HRRZ T2,BUTEPT		;GET ADDRESS OF VBOOT PAGE TABLE PAGE
	TXO T2,PTRW		;TURN ON ACCESS BITS
	CALL SETMPG		;SET MAP

	HLLZ T1,BUTPGS		;GET STARTING ADDRESS FOR VBOOT
	HLR T1,BUTEPT		;GET ADDRESS OF VBOOT MMAP PAGE
	SUBI T1,1		;WANT LAST PAGE BELOW MMAP LOCKED
	CALL CGPLK		;CREATE A GROUP OF PAGES AND LOCK
GSMLER:	 BUG(BOOTLK)
	HRRZ T1,BUTEPT		;GET ADDRESS OF VBOOT EPT PAGE
	HRLZI T1,PGSIZ(T1)	;GET FIRST ADDRESS TO LOCK ABOVE EPT
	HRR T1,BUTPGS		;GET ADDRESS OF LAST PAGE TO LOCK
	CALL CGPLK		;CREATE AND LOCK
	 JRST GSMLER
	MOVEM T1,BOOTST		;SAVE PHYSICAL ADDR OF VBEND

	;..

;HERE TO LOAD THE SWAPABALE MONITOR. IT IS READ IN SECTIONS
;AS LARGE AS THE AMOUNT OF FREE CORE.

	MOVEI P2,NRCOD-1000	;INITIALIZE SWPMON LOAD LOOP
	MOVE T1,NRPLQ		;GET PAGES ON REPLACEABLE QUEUE
	LSH T1,PGSFT		;SHIFT TO CONVERT FROM PAGES
	CAMGE T1,P1		;ASKING FOR MORE PAGES THAN WE CAN GIVE?
	 MOVE P1,T1		;YES SO ADJUST NUMBER OF PAGES
GSMD2:				;HERE TO BOOT A PIECE OF SWAPPABLE MONITOR
	MOVEI T1,1000(P2)	;FIRST PAGE IN CURRENT GROUP
	ADD T1,P1		;COMPUTE LAST LOADABLE PAGE
	SUBI T1,1000		;OF CURRENT GROUP
	LSH T1,-PGSFT		;AS A PAGE #
	CAMLE T1,SWCEND		;UNDER END OF SWPMON?
	MOVE T1,SWCEND		;NO USE END INSTEAD
	LSH T1,PGSFT		;CONVERT BACK TO ADDR
	HRLI T1,1000(P2)	;NEW FROM PAGE
	MOVE P2,T1		;SAVE BOUND PAIR
	CALL CGPLK		;CREATE AND LOCK
	 JRST GSMLER		; LOCK FAILURE

	MOVE P3,[POINT 7,BOOTST] ;BUILD VBOOT COMMAND STRING
	MOVE T1,[POINT 7,BUTCMD]	;POINTER TO FILE SPEC
	CALL BSCPY		;COPY TO OUTPUT STRING
	MOVE T1,[POINT 7,[ASCIZ '/L(']] ;LOAD ONLY
	CALL BSCPY
	HLRZ T1,P2		;LOWER BOUND
	LSH T1,-PGSFT		;AS A PAGE NUMBER
	CALL BSOCT		;CONVERT TO STRING
	MOVEI T1,","
	IDPB T1,P3
	HRRZ T1,P2		;UPPER BOUND
	LSH T1,-PGSFT		;AS A PAGE NUMBER
	CALL BSOCT		; ...
	MOVE T1,[POINT 7,[ASCIZ /)
/]]
	CALL BSCPY		;END OF COMMAND
	;...

;WE ARE NOW READY TO LOAD A SECTION OF THE SWAPABLE MONITOR.
;CALL VBOOT TO DO THE IO.

	PUSH P,P1		;SAVE FREE CORE
	PUSH P,P2		;SAVE BOUND PAIR
	HLRZ T1,BUTEPT		;GET ADDRESS OF VBOOT EPT PAGE
	SETMM (T1)		;INSURE EPT UPDATED
	CALL PHYIOW		;WAIT FOR ALL IO TO FINISH
	PIOFF			;DISABLE INTERRUPT SYSTEM
	MOVEM P,FPC		;SAVE STACK POINTER
	MOVE T1,[POINT 7,BOOTST] ;GET POINTER TO COMMAND STRING
	HRRZ T2,BUTPGS		;GET ADDRESS OF LAST PAGE IN VBOOT AREA
VBCALL::JSP 16,777(T2)		;GO LOAD SOME MONITOR
				; CALL BOOT AT LAST INSTRUCTION ON
				; LAST PAGE WHICH IS A JRST TO VBOOT
	 BUG(BOOTER)
	MOVE P,FPC		;RECOVER STACK
	XCT SETPPI		;RESTORE APR PI ASSMT
	PION

	POP P,P2		;RESTORE BOUND PAIR
	POP P,P1		;RESTORE FREE CORE
	MOVE T1,P2		;UNLOCK SWPMON PAGES
	CALL GPULK		;...
	HRRZ T1,P2		;ARE WE DONE?
	LSH T1,-PGSFT		;...
	CAME T1,SWCEND		;...
	JRST GSMD2		;NO - ANOTHER CYCLE
	CALL GSMDX		;RESET VBOOT AREA
	JRST LOKSM3		;YES - ADJUST SWPMON

;SUBROUTINE TO RELEASE VBOOT AREA

GSMDX:	SE1CAL			;Section 1 because SETMPG can lead to GDSTX
	HLLZ T1,BUTPGS		;GET START ADDRESS OF VBOOT AREA
	HLRZ T2,BUTEPT		;GET ADDRESS OF VBOOT EPT PAGE
	HRRI T1,-PGSIZ(T2)	;GET LAST ADDRESS TO UNLOCK
	CALL GPULK		;...
	HRRZ T2,BUTEPT		;GET ADDRESS OF VBOOT EPT PAGE
	HRLZI T1,PGSIZ(T2)	;GET FIRST ADDRESS TO UNLOCK
	HRR T1,BUTPGS		;GET LAST ADDRESS TO UNLOCK
	CALL GPULK		;...
	HLRZ P1,BUTPGS		;GET START ADDRESS OF VBOOT PAGES
	HRRZ P2,BUTPGS		;GET ENDING ADDRESS OF VBOOT PAGES
GSMD3:	HRRZ T2,P1		;GET ADDRESS
	SETZ T1,		;DESTROY PAGE
	CALL SETMPG		; ...
	ADDI P1,1000		;NEXT PAGE
	CAMG P1,P2		;DONE ?
	JRST GSMD3		;NO - LOOP
	RET			;DONE

;SUBROUTINES FOR BOOTSTRAP MANIPULATION

;SUBROUTINE TO COPY FROM BP IN T1 TO BP IN P3

BSCPY:	ILDB T2,T1		;GET A CHAR
	JUMPE T2,R		;DONE?
	IDPB T2,P3		;NO - COPY CHAR
	JRST BSCPY		;LOOP

;SUBROUTINE TO OUTPUT T1 TO BP IN P3 AS A DECIMAL NUMBER

BSDEC:	MOVEI T3,^D10		;DECIMAL
	CALL BSRAD		;CONVERT
	RET

;SUBROUTINE TO OUTPUT T1 TO BP IN P3 AS AN OCTAL NUMBER

BSOCT:	MOVEI T3,^D8		;OCTAL
	CALL BSRAD		;CONVERT
	RET

;COMMON/CONVENTIONAL PDP10 UNSIGNED RADIX PRINT

;ACCEPTS:
;	T1/ NUMBER TO BE CONVERTED
;	T3/ RADIX

;	CALL BSRAD

;RETURNS+1: ALWAYS

BSRAD:	IDIV T1,T3		;GET Q & R
	MOVEI T2,"0"(T2)	;CONVERT TO ASCII
	PUSH P,T2		;SAVE THE CHARACTER ON THE STACK
	SKIPE T1		;DONE?
	CALL BSRAD		;NO - RECURSE
	POP P,T2		;RETRIEVE CHARACTER STORED ON STACK
	IDPB T2,P3		;OUTPT
	RET

;'MINI-EXEC' - SIMPLE COMMAND INTERPRETER FOR SPECIAL FUNCTIONS

	SWAPCD

EXEC2:	MOVE T1,JOBBIT
	IFXN. T1,LOGIOB		;LOGIN OR OUT?
	  BUG(EXILGO)
	  WAIT%			;YES, SOME KIND OF DISASTER. GO AWAY QUIETLY.
	ENDIF.
	MOVEI 1,100		;ESTABLISH CORRECT TTY MODES
	MOVE 2,NORMTF
	SFMOD
	MOVE 2,TTICB1
	MOVE 3,TTICB2
	SFCOC
	CALL DTIALL		;DISABLE ALL TERMINAL INTERRUPTS
	MOVE 1,[XWD 20,^D34]	;T1/ CTRL/P ON CHANNEL 34
	ATI			;ASSIGN CONTROL-P FOR INTERRUPTS
	MOVE 1,[ITFFL,,EXECI]	;SETUP TO GET INTERRUPTS IN MON
	MOVEM 1,MONBK
	MOVEI 1,.FHSLF		;T1/ THIS FORK
	MOVEI 2,MICHN		;T2/ CHANNELS TO ACTIVATE (34 AND 35)
	MOVEM 2,MONCHN		;SAVE THE CHANNELS
	AIC			;ACTIVATE THEM
	MOVE 2,JOBNO
	HRRZ 1,JOBDIR(2)
	IFE. T1
	  SETZM CAPMSK		;IF NOT LOGGED, FLUSH ALL CAPS
	  SETZM CAPENB
	  MOVE 3,CTRLTT
	  CAME 3,CTYLNO		;ALLOW MINI-EXEC ONLY ON CTY
	ANSKP.
	  HRLOI 3,777000	;GIVE ALL CAPS
	  MOVEM 3,CAPMSK
	  MOVEM 3,CAPENB
	  MOVEI 3,OPERDN	;YES, GET DIRECTORY NUMBER OF <OPERATOR>
	  MOVEM 3,JOBDIR(2) 	;INDICATE LOGGED IN AS <OPERATOR>
	  STOR 3,JSDIR	;SAVE AS CONNECTED DIRECTORY
	  SETZRO JSCDF	;NO STRING IN JSB
	  MOVE 3,STRTAB+PSNUM ;GET SDB ADDRESS OF STRUCTURE 0 (PUBLIC)
	  LOAD 3,STRUC,(3) ;GET ITS UNIQUE STRUCTURE CODE
	  STOR 3,JSUC	;SAVE AS CONNECTED STRUCTURE CODE
	  MOVE 3,[[3
	  	 ASCIZ "OPERATOR"],,USRNAM]
	  BLT 3,USRNAM+2	;SET DEFAULT USER NAME TO OPERATOR
	ENDIF.
	JN JBMX,,EXECT0		;IF BEEN IN MX BEFORE, DONT CHECK CAPS
	MOVE 1,CAPENB		;LOOK AT CAPS, ALLOW MINI-EXEC
	TRNE 1,SC%WHL		;ONLY IFWHEEL
	IFSKP.
	  SKIPE FORKN		;OTHERWISE,
	  HALTF			;HALTF IF BELOW EXEC
	  SETONE JSFLO		;REMEMBER THE FORCED LOGOUT
	  JRST LOGO		;LOGOUT IF TOP FORK
	ENDIF.
	SETONE JBMX		;REMEMBER THAT JOB WAS IN MINI-EXEC
	; ..

;MINI-EXEC...

EXECT0:	HRROI 1,[ASCIZ /MX>/]
	PSOUT			;DO PROMPT
EXECT1:	PBIN			;GET USER INPUT
	CAIN T1,.CHCRT		;FLUSH CR
	JRST EXECT1
	CAIL 1,"A"+40		;LC CHAR?
	CAILE 1,"Z"+40
	SKIPA			;NO
	SUBI 1,40		;YES, CONVERT
	CAIN T1,.CHLFD		;IGNORE BLANK LINE
	JRST EXECT0
	MOVSI 4,-NXCMD		;SCAN COMMAND TABLE
EXECT2:	HLRZ 2,XCMD(4)		;GET KEY LETTER FOR THIS COMMAND
	CAMN 1,2		;SAME AS JUST TYPED?
	JRST [	HRRZ 2,XCMD(4)	;YES, GET DISPATCH ADDRESS
		JRST 0(2)]	;GO TO IT
	AOBJN 4,EXECT2		;TRY ALL COMMANDS
	JRST EXERR		;NOT FOUND, INDICATE ERROR

;MINI-EXEC COMMANDS

DEFINE CM (NAM,LOC)<
	XWD "NAM",LOC>

XCMD:	CM B,EBLT		;BLT SWP MON
	CM D,EDMP		;DUMP ON FILE
	CM E,GEX		;EXEC
	CM G,EGET		;GET FILE
	CM J,EJMP		;JUMP TO ADDRESS
	CM R,EREST		;RESET
	CM S,EST		;START
	CM <^>,MRETN		;DO MRETN
	CM </>,TODDT		;GO TO MDDT
NXCMD==.-XCMD
;'/' - ENTER MDDT

TODDT:	SE1ENT
	GTOKM (.GOMDD,)		;ASK FOR PRIVS
	JRST MDDTX		;GO TO DDT


;'BLT SWP MON' - BLT SWAPPABLE CODE TO USER SPACE.  SHOULD DO RESET FIRST,
;THEN DUMP ON DTA--

EBLT:	TMSG <LT SWP MON>
	CALL OKGO
	MOVE 2,SWCEND		;LST PAGE
	LSH 2,^D9
	MOVE T1,[NRCOD,,NRCOD]
	XBLTMU [BLT 1,777(2)]
	JRST EXEC2
;'RESET'

EREST:	TMSG <ESET>
	CALL OKGO
	CALL DRESET		;DO THE RESET
	JRST EXEC2

;DRESET IS COMMON ROUTINE USED BY SEVERAL COMMANDS TO DO A RESET

DRESET:	MOVEI 1,-4
	KFORK			;KILL ALL FORKS
	MOVNI 1,1
	MOVSI 2,400000
	MOVE 3,[1B0+1000]	;CLEAR ALL PAGES FROM USER MAP
	PMAP
	MOVNI 1,1		;CLOSE ALL FILES
	CLOSF
	JFCL
	RET

;OKGO - ROUTINE TO LOOK FOR CONFIRMATION AFTER MINI-EXEC HAS
;TYPED THE COMPLETION OF THE COMMAND.

;	CALL OKGO

;RETURNS +1: CONFIRMATION FOUND
;IF NO CONFIRMATION WAS FOUND, GOES TO ERROR ROUTINE

OKGO:	PBIN
	CAIN T1,.CHCRT		;FLUSH CR
	JRST OKGO
	CAIN T1,.CHLFD		;CRLF MEANS GO
	RET
NODD1:	POP P,1			;ANYTHING ELSE MEANS ABORT
	JRST EXERR

;'EXEC'

GEX:	TMSG <XEC>
	CALL OKGO		;CONFIRM
	CALL DRESET		;CLEAR PREVIOUS PROGRAM TO GUARANTEE CINITF IN EXEC IS CLEAR


;HERE TO GET A NEW COPY OF THE EXEC. REACHED FROM MINI-EXEC 'EXEC'
;COMMAND OR WHEN A NEW JOB IS BEING CREATED.  IF FILE EXISTS,
;GOES TO START IT. IF NOT, PRINTS MESSAGE AND GOES TO MINI-EXEC

STEX:	MOVSI 1,(GJ%OLD!GJ%PHY!GJ%SHT)	;OLD FILE+SHORT FORM
	HRROI 2,[ASCIZ /SYSTEM:EXEC.EXE/]
	GTJFN
STEXF:	JRST [	SKIPE CRJFLG	;IS THIS A CRJOB FAILURE?
		JRST CRJMEX	;YES. GO GIVE FAIL CODE
		HRROI T1,[ASCIZ /NO EXEC/]
		PSOUT
		JRST EXCRR]
	HRLI 1,.FHSLF
	GET
	ERJMP STEXF		;CATCH FAILURE OF GET
	SKIPN CRJFLG		;CREATED JOB?
	JRST GEX1
	HRLI T2,1		;INDICATE JOB HAS ALREADY SET CRJANS
	HLLM T2,CRJFLG		; BY MAKING FLAG POSITIVE
	JRST GEX1

CRJMEX:	MOVEI T1,CRJBX2		;PREVENT CRJOB GETTING INTO MINIEXEC
	SKIPGE CRJFLG		;JOB STILL BEING CREATED
	MOVEM T1,CRJANS		;YES.  GIVE FAIL CODE TO CREATOR,
	JRST LOGO		;AND FLUSH OUT THIS JOB.

;'JUMP TO ADDRESS' - JUMP TO USER ADDRESS

EJMP:	TMSG <UMP TO >
	MOVEI 1,100
	MOVEI 3,^D8		;GET OCTAL ADDRESS
	NIN
	 JRST EXERR
	HRRZM 2,-1(P)		;SAVE ADDRESS
	BKJFN			;BACKUP TO READ TERMINATOR
	 JFCL
	CALL OKGO
	JRST MRETN		;RETURN TO USER ADDRESS ON STACK
;'GET FILE'

EGET:	TMSG <ET FILE >
	MOVSI 1,(1B2+1B4+1B16+1B17) ;OLD FILE,CONFIRM,IFOF,SHORT
	MOVE 2,[XWD 100,101]
	GTJFN
	JRST EXERR
	HRLI 1,400000		;THIS FORK
	GET
	JRST EXEC2

;'START' - STARTS PROGRAM GOTTEN VIA 'GET'

EST:	TMSG <TART>
	CALL OKGO
GEX1:	MOVE 1,EVADDR
	JUMPN 1,.+2
	UMOVE 1,120		;USE JOBSA
	MOVEM 1,-1(P)
	JRST MRETN

;'DUMP ON FILE'

EDMP:	TMSG <UMP ON FILE >
	MOVSI 1,(1B0+1B3+1B4+3B17) ;NEW V,PNT O/N,CONFRM,IFOF,SHRT
	MOVE 2,[XWD 100,101]
	GTJFN
	JRST EXERR
	HRLI 1,400000		;THIS FORK
	MOVE 2,[XWD -1000,520000] ;SAVE ALL ADDRESS SPACE
	SETZ 3,
	SSAVE
	JRST EXEC2

;ERROR CONDITION - PRINT A QUESTION MARK AND GO BACK TO START OF
;MINI-EXEC

EXERR:	TMSG <  ?>
	MOVEI 1,100
	CFIBF			;CLEAR INPUT BUFFER

;PRINT CARRIAGE RETURN/LINE FEED

EXCRR:	SKIPE CRJFLG		;IS THIS A CRJOB?
	JRST CRJMEX		;YES. GET OUT OF MINIEXEC.
	TMSG <
>
	JRST EXEC2

EXCRRW:	TMSG <
>
	JRST EXEC2

;PSI TRAPPED TO HERE

EXECI::	XCT FRKNOP		;NOP UNLESS MDDT BPT SET
	EXCH 1,ITFFL		;SAVE 1, GET TRAP FL
	TLNN 1,(UMODF)		;USER?
	JRST EXECI1		;NO
	HLLZM 1,FFL		;SET FLAGS
	MOVE 1,ITFPC		;SET PC
	MOVEM 1,FPC		;YES, ENTER MONITOR AT THAT LOC
	MOVE 1,ITFFL		;RESTORE AC1
EXECI2:	MCENTR
	SETOM PRIMRY
	SKIPE CRJFLG		;IS THIS A CRJOB?
	JRST CRJMEX		;YES. GET OUT OF MINIEXEC.
	MOVEI 1,100
	CFIBF			;CLEAR INPUT BUFFER
	CALL CLRINT		;CLEAR THE SOFTWARE INTERRUPT SYSTEM
	TRNN 2,2		;CHANNEL 34?
	JRST EXECI3
	MOVEI 1,-4
	FFORK			;FREEZE FORKS
	MOVEI 1,101
	CFOBF			;CLEAR OUTPUT BUFFER
	TMSG <
ABORT
>
	JRST EXEC2

EXECI1:	MOVE P,UPP		;RESTORE TOP OF PDL
	MOVE 2,1(P)		;GET USER PC
	MOVEM 2,FPC		;STORE PC
	HRLI 1,(UMODF)
	MOVEM 1,FFL
	JRST EXECI2

EXECI3:	TMSG <
INTERRUPT AT >
	MOVEI 1,101
	HRRZ 2,UPP
	HRRZ 2,1(2)		;GET TOP PC
	MOVEI 3,10		;RADIX
	NOUT			;PRINT ADDRESS
	 JFCL
	JRST EXCRRW		;TO MINI-EXEC IF SC%WHL

;JSYS TO ENTER MDDT

.MDDT::	MCENT
	MOVEI 1,SC%WHL		;14 Only wheels here
	TDNN 1,CAPENB
	JRST WHEELX		;NO PRIVS
	JRST TODDT

	RESCD

;HERE WHEN USER TYPES "EDDT$G" IN MDDT.  DON'T GO TO EDDT UNLESS IT
;IS LOADED AND LOCKED DOWN.  USERS WHO WANT TO ANYWAY CAN TYPE "DDTX$G".

EDDT==:<MSEC1,,.>		;START IN SECTION 1 ON EDDT$G FROM MDDT

	SKIPE DDTPRS		;IS EDDT PRESENT AND LOCKED?
	JRST DDTX		;YES, GO TO IT
	TMSG <
? EDDT is not locked down - call LCKINI from MDDT first
>
	JRST MDDTX		;RETURN TO MDDT


;BUGHLT IN JOB CONTEXT TRAPS TO HERE

EXBUGH::MOVE 1,UPDL		;RESET STACK, ETC.
	MOVEM 1,FPC		;SET PC
	MOVSI 1,(UMODF)
	MOVEM 1,FFL
	MCENTR
	SETOM TRAPC
	SETZM NSKED
	SETZM INTDF
	SKIPN JOBNO		;JOB 0?
	JRST CHKRI		;YES, INTERRUPT
	HRRZ 1,PRIMRY
	HRROI 2,[ASCIZ /
BUGHLT at /]
	SETZ 3,
	SOUT
	HRRZ 2,BUGHLT
	MOVEI 3,^D8
	NOUT
	JFCL
	TMSG <
>
	JRST ITRAP

	SWAPCD

;HALT SYSTEM - REQUIRES SC%MNT (OR SC%WHL ETC.) CAPABILITY
;ACCEPTS TIME OF SYSTEM SHUTDOWN AND INITIATES SHUTDOWN PROCESS,
;INCLUDING NOTIFYING USERS, ETC.  ALSO ACCEPTS TIME WHEN SYSTEM
;WILL BE BACK UP WHICH IS AVAILABLE FOR USER INFORMATION ONLY.
; 1/ SHUTDOWN TIME (GTAD FORMAT)
; 2/ EXPECTED UP TIME (GTAD FORMAT)
;	HSYS
; RETURNS +1: ERROR
; RETURNS +2: SUCCESS

.HSYS::	MCENT
	MOVE 2,CTRLTT		;243 logged in to cty?
	CAMN 2,CTYLNO		;243 if so,
	 JRST HSYSA		;243 dont worry about capabilities
	MOVE 2,CAPENB		;CHECK USER CAPABILITIES
	TXNN 2,SC%WHL+SC%OPR+SC%MNT ;USER ALLOWED TO DO HALT?
	RETERR(CAPX2)		;NO, RETURN BAD
HSYSA:	JUMPG 1,HSYS1		;243 JUMP UNLESS ABORTING SHUTDOWN
	MOVE T1,HSYST1		;GET OLD TIME
	JUMPE T1,HSYS0		;IF NONE, DONT TYPE MESSAGE
	SETZM HSYST1		;CLEAR OLD TIME
	CALL TADDIF		;GET MILLISECONDS TO SHUTDOWN
	HRROI T2,[ASCIZ/
[Shutdown canceled]
/]
	MOVX T3,SF%MS1
	TDNE T3,FACTSW		;WANT LEVEL 1 MESSAGES?
	SKIPGE HSYST3		;WAS A MESSAGE EVER PRINTED
	SKIPA
	CALL ALLMSG		;YES, INFORM USERS OF CANCELLATION
HSYS0:	SMRETN			;SUCCESSFUL RETURN

HSYS1:	PUSH P,1		;HOLD THE DESIRED SHUTDOWN
	CALL TADDIF		;COMPUTE MILLISECONDS TO SHUTDOWN
	TLNE 1,770000		;OVER A WEEK AHEAD, OR NEGATIVE?
	RETERR(TIMEX2)		;YES, GIVE BAD TIME FAILURE
	POP P,2			;RECOVER SHUTDOWN TIME
	MOVEM 2,HSYST1		;STORE FOR EXEC TO SEE
	SETOM HSYST3		;FLAG FOR FIRST MESSAGE
	UMOVE 2,2		;GET EXPECTED UP TIME
	CAMG 2,HSYST1		;CHECK RANGE
	SETZ 2,			;JUNK, ASSUME UNKNOWN
	MOVEM 2,HSYST4		;SAVE FOR EXEC TO TELL USERS
	UMOVE T2,T3		;3032 get reason for going down
	ANDI T2,17		;3032 restrict to 4 bits
	MOVEM T2,HSYST5		;3032 save for IMP
	AOS JB0FLG		;POKE JOB 0 TO DO MSG
	SMRETN

;COMPUTE TIME UNTIL SHUTDOWN IN MILLISECONDS
; A/ TAD OF SHUTDOWN
;	CALL TADDIF
; RETURN +1, A/ MILLISECONDS TO SHUTDOWN

TADDIF:	PUSH P,1
	CALL LGTAD		;GET CURRENT TIME AND DATE
	POP P,2
	SUBM 2,1		;GET POSITIVE DIFFERENCE OF TIMES
	CAML T1,[^D8,,0]	;WITHIN 8 DAYS?
	JRST [	MOVSI T1,377777	;NO, RETURN VERY LARGE NUMBER
		RET]
	MUL T1,[^D<24*3600*1000>]	;MILLISECONDS/DAY
	DIV T1,[1B17]		;SHIFT BINARY POINT
	RET

;HSYST1 AND HSYST4 ARE A GETAB TABLE

NHSYST==2			;NUMBER OF VALUES IN GETAB TABLE
NR HSYST1,1			;SYSTEM SHUTDOWN TIME OR 0
NR HSYST4,1			;EXPECTED UP TIME

NR HSYST2,1			;INTERVAL (IN MS) TO NEXT MSG TIME
NR HSYST3,1			;TIME OF NXT MSG IN MS BEFORE SHUTDOWN

;POINTS (IN MINUTES BEFORE SHUTDOWN) AT WHICH TO DO NOTIFICATION

CTIMS:	^D<BYTE (9) 60,30,15,10>
	^D<BYTE (9) 5,1,0>

;ROUTINE TO TYPE SYSTEM SHUTDOWN MESSAGE IF NECESSARY.
;CALLED ONLY BY JOB 0 CHKR.

CHKHSY:	SKIPE A,HSYST1		;SHUTDOWN ABORTED?
	CAMN A,[-1]		;OR IS SYSTEM SHUTDOWN?
	RET			;YES
	CALL TADDIF		;COMPUTE TIME UNTIL SHUTDOWN
	MOVE 3,HSYST3		;DUE TIME FOR MESSAGE
	CAMN 3,[-1]		;FIRST TIME HERE?
	JRST CHKHS3		;YES - GIVE MESSAGE ANYWAY
	CAMLE 1,HSYST3		;NO - MESSAGE DUE NOW?
	JRST [	SUB 1,HSYST3	;NO, COMPUTE INTERVAL TO NEXT MSG
		MOVEM 1,HSYST2	;LEAVE IT FOR CHKR
		RET]		;RETURN QUIETLY
CHKHS3:	ADDI 1,^D30000		;ROUND TO NEAREST MINUTE
	IDIVI 1,^D60000		;CONVERT TO INTEGER MINUTES
	JUMPLE 1,CHKHS4		;IF NO TIME LEFT, GO KILL SYSTEM
	CALL THSYS		;SEND MSG TO ALL TTYS
	CAILE 1,^D60		;LESS THAN AN HOUR?
	JRST [	MOVEI 2,^D60	;NO - SET NEXT MESSAGE FOR 1 HOUR NOW
		CAILE 1,^D120	;BETWEEN 1 AND 2 HOURS
		MOVEI 2,^D120	;MAKE FIRST NOTICE BE AT 1 HOUR
		JRST CHKHS5]
	MOVE 3,[POINT 9,CTIMS]	;SETUP TO FIND NEXT NOTIFY TIME
	ILDB 2,3		;GET A TIME FROM LIST
	CAMG 1,2		;SHORTER THAN ACTUAL TIME REMAINING?
	JRST .-2		;NO, KEEP LOOKING
CHKHS5:	IMULI 2,^D60000		;CONVERT MINUTES TO MILLISECONDS
	MOVEM 2,HSYST3		;SET AS NEXT MESSAGE TIME
	JRST CHKHSY		;FINAL CHECK AND RETURN

;SHUTDOWN TIME HAS ARRIVED, COMMENCE SHUTDOWN.

CHKHS4:	MOVX T1,SF%RMT!SF%LCL!SF%PTY
	ANDCAM T1,FACTSW	;ONLY ALLOW CTY TO LOGIN
	MOVX T1,SF%CTY		;MAKE SURE CTY CAN LOG IN
	IORM T1,FACTSW		;EVEN IF HE COULD NOT DO IT BEFORE
	CALL DWNMSG		;SEND LAST MESSAGE
	SETOM HSYST1		;CLEAR FLAGS IN CASE RESTARTED
	MOVSI T1,(1B1)		;CREATE FORK WITH SAME CAPS
	CFORK
	 BUG(HSYFRK)
	MOVEI T2,HSYS4		;SET IT TO START NEXT SHUTDOWN PHASE
	MSFRK			;START FORK IN MONITOR MODE
	RET

;FORK STARTED AT SHUTDOWN TIME
;COMMENCE SHUTDOWN. PREVENT NEW JOBS, LOGOUT EXISTING JOBS, HALT.

HSYS4:	MOVSI 1,(UMODF)
	MOVEM 1,FFL		;ESTABLISH USUAL JSYS CONTEXT
	SETZM FPC		;SET PC
	MCENTR
	MOVX T1,SF%RMT!SF%LCL!SF%PTY
	ANDCAM T1,FACTSW	;ONLY ALLOW CTY TO LOGIN
	MOVE 6,[XWD -NJOBS+1,1]	;START WITH JOB 1
	SKIPGE JOBRT(6)		;LOOK FOR EXISTING JOB
HSYS41:	AOBJN 6,.-1
	JUMPGE 6,HSYS7		;JUMP IF DONE
	HLRZ 1,JOBPT(6)		;CHECK CTRLTT FOR JOB
	CAMN 1,CTYLNO		;CTY?
	JRST HSYS41		;YES, DON'T FLUSH
	MOVEI 1,0(6)		;GET JOB NUMBER
	LGOUT			;LOG IT OUT
	 JFCL
	JRST HSYS41

HSYS7:	MOVEI 5,^D120000	;MAX TIME TO WAIT FOR JOBS TO FINISH
	ADD 5,TODCLK		;LOGGING OUT
HSYS8:	CAMG 5,TODCLK		;WAITED MAX TIME?
	JRST HSYS9		;YES, PROCEED WITH SHUTDOWN
	MOVE T2,HSYST4		;GET TIME BACK UP
	MOVEI T1,^D12		;SHOULD BE CODE FOR REASON FOR HALT
				;BUT FOR NOW, JUST SAY "SCHEDULED DOWN"
;1001	CALL IMPHLT		;TELL THE NETWORK WE ARE GOING AWAY
	CALL MNTHLT		;3032 Shut off networks
	MOVE 6,[XWD -NJOBS+1,1]	;START WITH JOB 1
	SKIPGE JOBRT(6)		;SEE IF ANY JOBS STILL EXIST
HSYS81:	AOBJN 6,.-1
	JUMPGE 6,HSYS9		;NONE FOUND, PROCEED
	HLRZ 1,JOBPT(6)		;CHECK FOR CTY JOB
	CAMN 1,CTYLNO
	JRST HSYS81		;YES, IGNORE
	MOVEI 1,^D1000		;NO, WAIT 1 SEC., THEN CHECK AGAIN
	DISMS
	JRST HSYS8

HSYS9:	CALL PHYLOG		;LOG DISK, TAPE STATISTICS
	SETZM DDTIME		;POKE DDMP
	AOS JB0FLG
	MOVEI 5,^D10		;WAIT 10 SEC MAX FOR JOB 0
HSYS91:	MOVEI 1,^D1000		;WAIT 1 SEC
	DISMS
	SKIPN DDTIME		;DDMP FINISHED?
	SOJG 5,HSYS91		;NO, WAIT MORE
	JUMPLE 5,HSYS9		;IF TIMED OUT, TRY AGAIN
	SKIPE IOIP		;WRITES IN PROGRESS?
	JRST .-1		;YES, WAIT FOR COMPLETION
	MOVE T1,CTYLNO
	TXO T1,.TTDES		;MAKE VALID DESIGNATOR
	HRROI T2,[ASCIZ /
Shutdown complete
/]
	TTMSG			;NOTIFY OPERATOR
	MOVEI T1,^D15000
	DISMS
	HALTF

;ROUTINE TO SEND GOING DOWN MESSAGE TO ALL LINES

THSYS:	CAILE T1,<^D60*^D24>	;1000 LESS THAN 24 HOURS AWAY?
	 RET			;1000 YES, SKIP IT
	STKVAR <TIM,<MSG,25>>	;13 Increase to 25 words
	MOVEM T1,TIM		;SAVE NUMBER OF MINUTES
	HRROI T1,MSG		;INIT PTR TO MSG
	HRROI T2,[ASCIZ /
[/]
	SETZ T3,
	SOUT
	HRROI T2,NOMNAM		;3024 PRINT OUT PARTICULAR HOST NAME
	SETZ T3,		;3024
	SOUT			;3024
	HRROI T2,[ASCIZ / going down/] ;3024
	SETZ T3,		
	SOUT			
	MOVE T2,TIM		;GET TIME
	CAILE T2,^D60		;LESS THAN ONE HOUR?
	JRST THSYS1		;NO - SPECIAL MESSAGE
	HRROI T2,[ASCIZ / in /]
	SETZ T3,
	SOUT
	MOVE T2,TIM		;GET TIME
	CAIN T2,1		;THE 'ONE' CASE?
	JRST [	HRROI T2,[ASCIZ /one minute!! for /]	;12
		JRST HSYS51]	;YES, SPECIAL MESSAGE
	MOVEI T3,^D10
	NOUT
	 JFCL
	HRROI T2,[ASCIZ / minutes/]
	SETZ T3,
	SOUT			;APPEND TO MESSAGE
THSYS1:	HRROI T2,[ASCIZ / at /]
	SETZ T3,0
	SOUT
	MOVE T2,HSYST1		;TELL ACTUAL TIME
	MOVEI T3,0
	ODTIM			;IN MESSAGE

;12 Begin modification
	HRROI T2,[ASCIZ / for /]
HSYS51:	SETZ T3,
	SOUT
	SKIPN 2,HSYST4		;HAVE A SCHEDULED UPTIME?
	 JRST HSYS53		;NO
	SUB 2,HSYST1		;GET TIME DIFFERENCE
	MULI 2,^D<60*24>	;TIMES NUMBER OF MINUTES IN A DAY
	LSH 3,1			;FLUSH DUPLICATE SIGN BIT
	LSHC 2,^D17		;GET NUMBER OF MINUTES
	JUMPL 2,HSYS53
	JUMPGE 3,.+2
	 AOJ 2,			;ROUND IT TOO
;169 Begin modification
	IDIVI 2,^D60		; Convert to hours and minutes
	PUSH P,3
	MOVEI 3,[ASCIZ / hour/]
	SKIPN (P)		; If no minutes
	 TLO 3,-1		; Make this final item
	SKIPE 2
	 CALL HSYSSU
	POP P,2
	JUMPE 2,HSYS52
	HRROI 3,[ASCIZ / minute/]
	CALL HSYSSU
;169 End modification
;12 End addition

HSYS52:	HRROI T2,MSG		;169 POINT TO CONSTRUCTED MSG
	MOVE T3,FACTSW
	MOVE T4,TIM
	SKIPL HSYST3		;THE FIRST TIME? OR...
	CAIG T4,5		;5 MIN OR LESS?
	CAIA			;YES, ALWAYS SEND
	TXNE T3,SF%MS1		;WANT LEVEL 1 MESSAGES?
	CALL ALLMSG		;SEND TO ALL LINES
	MOVE T1,TIM		;RESTORE TIME
	RET

;169 Begin addition

HSYS53:	HRROI 2,[ASCIZ /an unknown period.]
/]
	 SETZ 3,
	 SOUT
	 JRST HSYS52

; Routine for nice number output in HSYS
; 2/ number
; 3/ RH: address of unit string  LH: -1 for last thing in the list, 0 otherwise
HSYSSU:	MOVE 4,3		; Save this
	MOVEI 3,^D10		; First the number
	NOUT
	 TRN
	PUSH P,2		; Save number for "s" processing
	HRROI 2,(4)
	SETZ 3,
	SOUT
	POP P,3			; Do the "s"
	MOVEI 2,"s"
	CAIE 3,1
	 BOUT
	HRROI 2,[ASCIZ /.]
/]
	SKIPL 4
	 HRROI 2,[ASCIZ /, /]
	SETZ 3,
	SOUT
	RET
;169 End addition

;ROUTINE TO SEND LAST MESSAGE, INCLUDING EXPECTED UPTIME.

DWNMSG:	STKVAR <<MSG,20>>
	HRROI T1,MSG
	HRROI T2,[ASCIZ /
[/]
	SETZ T3,
	SOUT
	HRROI T2,NOMNAM		;3024 PRINT OUT SPECIFIC HOST NAME
	SETZ T3,
	SOUT
	HRROI T2,[ASCIZ/ down/] ;3024
	SETZ T3,
	SOUT
	SKIPN HSYST4		;HAVE AN UPTIME?
	JRST DWNMS1		;NO
	HRROI T2,[ASCIZ /, up again at /]
	SOUT
	MOVE T2,HSYST4		;GET UPTIME
	MOVEI T3,0		;STANDARD FORMAT
	ODTIM			;CONVERT TIME TO TEXT
DWNMS1:	HRROI T2,[ASCIZ /]
/]
	SETZ T3,
	SOUT
	HRROI T2,MSG		;HAVE TEXT, NOW SEND IT TO ALL LINES
	CALL ALLMSG
	RET

;PERIODIC (10 SEC) CHECK OF THINGS

CHKR::	XJRSTF [0
		MSEC1,,.+1]	;RUN IN SECTION 1
	SETZM JB0FLG		;CLEAR REQUEST FLAG
	MOVE 1,TODCLK
	ADD T1,CHKPER		;NOW PLUS MAX CHECK PERIOD
	MOVEM 1,CHKTIM		;LEAVE FOR SCHED TO CHECK
	CALL RESLCK		;LOCK OR UNLOCK RESIDENT FREE SPACE
	CALL DTEPOL		;GO SEE IF ANY DTE'S NEED ATTENTION
	SKIPL DRMJ0R		;DRUM JOB 0 REQUEST?
	CALL CHKDRM		;YES
	MOVE 1,DSKRCE		;DISK RECOVERABLE ERRORS
	CAME 1,CHKDRE		;DIFFERENT THAN LAST CHECK?
	CALL CHKDE1		;YES, GO PRINT INFO
	MOVE 1,DSKNRE		;DISK NON-REC ERRORS
	CAME 1,CHKDNE		;DIFFERENT?
	CALL CHKDSK		;PRINT INFO
	SKIPE MTAJB0		;MTA ON LINE INTERRUPT?
	CALL MTASSP		;YES REQUEST SETSPD
	SKIPE USGBEG		;CHECK USAGE QUEUE
	CALL USGMES		;HAVE SOMETHING - EMPTY QUEUE
	CALL CHKCKP		;CHECK ON CHECKPOINT
	CALL CHKASC		;Check for accounting shift change
	CALL DDMP0		;DISK BACKUP
	CALL CHKBGS		;CHECK IF TIME TO STORE ASCII TIME
	SKIPE A,HSYST1		;SHUTDOWN PROCESS ACTIVE?
	CAMN A,[-1]		;OR IS SYSTEM SHUTDOWN
	SKIPA			;SYSTEM SHUTDOWN OR PROCESS NOT ACTIVE
	CALL CHKHSY		;YES, CHECK IT
IFN MNET,<
	CALL CHKIMP		;1001 CHECK STATE OF ARPANET
;3032	CALL IMICHK		;1001 MAke sure IMP input Q's emptied
>
	MOVE A,TODCLK
	CAMGE A,UMSGTM		;TIME FOR USER MESSAGES?
	JRST CHKUM1		;NO
	CALL CHKDKS		;CHECK DISK SPACE
	CALL CHKDMS		;CHECK DRUM SPACE
	CALL CHKSPT		;CHECK SPT SPACE
	MOVE A,TODCLK		;SET TIME FOR NEXT MSG
	ADD A,[^D<30*60000>]	;163 IN 30 MINUTES
	MOVEM A,UMSGTM
CHKUM1:
;1001	CALL CHKNET		;CHECK STATE OF ARPANET
	CALL CHKMOS		;CHECK IF MEMORY DIAG NEEDS TO RUN
	MOVEI A,^D30000		;SETUP TO DISMISS FOR 30 SEC
	SKIPE B,HSYST1		;SHUTDOWN ACTIVE?
	CAMN B,[-1]		;OR SYSTEM SHUTDOWN?
	SKIPA			;NO SHUTDOWN OR ALREADY SHUTDOWN
	SKIPGE B,HSYST2		;YES, REASONABLE TIME TO WAIT?
	JRST CHKUM2		;NOT ACTIVE OR BAD TIME
	CAMLE A,B		;LESS THAN 30 SECONDS AWAY
	MOVE A,B		;YES, DISMISS UNTIL THEN
CHKUM2:	CALL SETBKT		;SETUP TIME FOR DISMISS TEST
	HRRI A,JB0TST		;OR JB0FLG
;1001	MOVSI B,FHV1		;LOW BLOCK PRIORITY
;1001	HDISMS
	MDISMS			;1001
	JRST CHKR

;MAXIMUM CHECK PERIOD - USED TO SET SCHEDULER ALARM

CHKPER:	^D<4*60000>		;4 MINUTES

	RESCD

JB0TST:	SKIPE JB0FLG		;EXPLICIT REQUEST?
	JRST 1(4)		;YES, WAKEUP
	JRST BLOCKT		;NO, GO TEST TIME

	SWAPCD

NR UMSGTM,1			;TIME OF NEXT USER MESSAGES
NR MOSFRK,1			;FORK I.D. OF MEM DIAG FORK
NR MTCHNG,1			;FLAG FOR MTA STATUS CHANGE

CHKH1:	CALL TTDECP		;OUTPUT DECIMAL
	MOVEI 2," "
	BOUT
CHKR1:	CALL LGTAD		;CURRENT TIME AND DATE
	JUMPL 1,CHKR2		;IF NOT SET
	MOVE 2,1
	MOVEI 1,101
	SETZ 3,
	ODTIM			;INCLUDE TAD WITH MESSAGE
CHKR2:	TMSG <
>
	RET

;INITIATE PAGE MOVEMENT TO DISK IF APPROPRIATE

DDMP0:	MOVE A,DRMFRE		;DRUM SPACE LOW?
	CAMGE A,DRMIN0
	JRST [	TMSG <DDMP: SWAP SPACE LOW ACTION.
>
		JRST DDMPA]
	MOVE A,TODCLK		;TIME FOR NEXT CYCLE?
	CAMGE A,DDTIME
	RET			;NO
DDMPA:	CALL DDMP		;DO THE WORK
	 RET			;DDMP FAILED. RUN IT AGAIN ASAP
	MOVX A,^D60000		;SET TIME FOR NEXT CYCLE AS 1 MINUTE
	ADD A,TODCLK		; FROM NOW.
	MOVEM A,DDTIME
	RET

; ROUTINE TO REQUEST SETSPD FOR MAGTAPE ON LINE

MTASSP:	SETZM MTAJB0		;CLEAR REQUEST FLAG
	MOVX T1,GJ%OLD!GJ%PHY!GJ%SHT
	HRROI T2,SETSPD		;GET POINTER TO "SYSTEM:X-SETSPD.EXE"
	MOVEI T3,4		;START AT ENTRY VECTOR POSITION 4
	CALL RUNDII		;RUN SETSPD AND WAIT UNTIL IT'S DONE
	 JFCL			;IGNORE FAILURE
	RET

;ROUTINE CALLED BY CHKR TO SEE IF ANY ACTION NEEDED FOR THE
;MOS MEMORY DIAGNOSTIC

CHKMOS:	SKIPN T1,MOSFRK		;NOW RUNNING?
	JRST CHKMO1		;NO. SEE IF WE SHOULD RUN IT
	RFSTS			;YES. SEE WHAT IT IS DOING
	LOAD T1,RF%STS,T1	;GET ITS STATUS
	CAIE T1,.RFHLT		;HALTED?
	CAIN T1,.RFFPT		;OR ERROR?
	SKIPA T1,MOSFRK		;YES.
	RET			;NO. ALL DONE THEN
	KFORK			;KILL THE PROCESS
	SETZM MOSFRK		;NO MORE FORK HERE
	CALL MOSULE		;UNLATCH CONTROLLER NOW

;HERE IF NO FORK NOW RUNNING. SEE IF ONE NEEDED

CHKMO1:	SKIPE ERRTBL		;HAVE SOME ENTRIES TO PROCESS
	CALL RUNMOS		;YES. START THE DIAG
	RET			;DONE

;ROUTINE TO RUN THE MOS MEM DIAGNOSTIC

RUNMOS:	TDZA T3,T3		;MAIN ENTRY POINT
RUNMO1:	MOVEI T3,1		;SYS START UP ENTRY
	MOVX T1,<GJ%OLD!GJ%SHT!GJ%PHY>
	HRROI T2,[ASCIZ /SYSTEM:TGHA.EXE/] ;THE DIAG
	CALL RUNDIR		;RUN TGHA
	 RET			;DIDN'T DO IT.
	MOVEM T1,MOSFRK		;SAVE FORK HANDLE FOR LATER
	RET			;AND DONE

;ROUTINE CALLED BY JOB 0 TO FINISH LOADING UP SYSERR BLOCK
;  FOR BUGHLT'S AND BUGCHK'S
;ACCEPTS IN T1/	ADDRESS OF SYSERR BLOCK
;RETURNS +1:	ALWAYS

LOGBUG::SAVEQ			;SAVE PERMANENT ACS
	TRVAR <BUGSP,BUGPNM,BUGTAD>
	MOVEM T1,Q1		;SAVE POINTER TO SYSERR BLOCK
	MOVEI T1,.PRIOU		;SEND MESSAGE TO CTY
	MOVE T4,SEBDAT+BG%FLG(Q1) ;GET TYPE OF BUG CHECK

repeat 0,<			;208
	HRROI T2,[ASCIZ/
********************
*BUG/]
>;208 end repeat 0

	SETZ T3,
;208 Begin addition
	RFPOS			;SEE WHERE CHARRIAGE IS NOW
	HRRZS T2
	JUMPE T2,LOGBF0		;DO CRLF IF NOT AT LEFT MARGIN
	HRROI T2,[ASCIZ/
/]
	SOUT			;START MESSAGE
LOGBF0:	HRROI T2,[ASCIZ/*** /]	;208
	SOUT			;208 Print prefix
	MOVE T2,SEBDAT+BG%DAT(Q1) ;GET TIME AND DATE OF BUG CHECK
	ODTIM			;TYPE OUT TIME AND DATE
	erjmp .+1		;261 Probably date/time not set yet, ignore
	HRROI T2,[ASCIZ/ BUG/]
;208 End
	SOUT			;START MESSAGE
	HRROI T2,[ASCIZ/HLT "/]
	CAIN T4,BG%CHK		;BUGCHK?
	HRROI T2,[ASCIZ/CHK "/]	;YES
	CAIN T4,BG%INF		;INFORMATIONAL BUG CHECK?
	HRROI T2,[ASCIZ/INF "/]	;YES
	SOUT
	MOVE T4,[POINT 6,SEBDAT+BG%NAM(Q1)]
LOGBF1:	ILDB T2,T4		;NOW TYPE OUT 6 CHAR NAME
	JUMPE T2,LOGBF2		;IF AT END, STOP TYPING
	ADDI T2," "		;TRANSLATE SIXBIT TO ASCII
	BOUT			;OUTPUT CHARACTER
	TLNE T4,770000		;AT END OF NAME YET?
	JRST LOGBF1		;NO, LOOP BACK FOR REST OF CHARS
LOGBF2:	HRROI T2,[ASCIZ/" at /]
	SOUT
;208	MOVE T2,SEBDAT+BG%DAT(Q1) ;GET TIME AND DATE OF BUG CHECK
;208	ODTIM			;TYPE OUT TIME AND DATE
	SETZB T2,BUGSP		;CLEAR POINTERS
	SKIPN Q2,BUGTP		;TABLE POINTER EXIST?
	 JRST LOGBF4
	HRROI T2,[ASCIZ/- /]	;208
	SOUT
LOGBF3:	MOVE T4,0(Q2)		;SEARCH FOR ADDRESS IN TABLE
	HLRZ T2,T4		;GET ADDRESS
	CAME T2,SEBDAT+BG%ADR(Q1)	;FOUND IT?
	AOBJN Q2,LOGBF3		;NO, LOOP BACK TIL WE DO
	JUMPGE Q2,[HRROI T2,[ASCIZ/Message not found for this address/]
		JRST LOGBF4]
	HRROI T2,0(T4)		;GET POINTER TO MESSAGE STRING
	HRRZM T2,BUGSP		;SAVE IT FOR SYSERR BLOCK
LOGBF4:	SOUT			;TYPE OUT STRING
	SETZM BUGPNM		;START WITH A NULL PROGRAM NAME
repeat 0,<			;208
	SKIPGE SEBDAT+BG%JOB(Q1)	;IS THERE A JOB?
	JRST LOGBF5		;NO, SKIP JOB/USER LINE
	HRROI T2,[ASCIZ/
*Job: /]
>;208 repeat 0

	HRRE T2,SEBDAT+BG%JOB(Q1) ;208 IS THERE A JOB?
	JUMPLE T2,LOGBF5	;208 NO, SKIP JOB/USER LINE
	HRROI T2,[ASCIZ/, Job /] ;208
	SOUT
	HRRZ T2,SEBDAT+BG%JOB(Q1)	;GET JOB NUMBER
	MOVEI T3,12		;TYPE IT IN DECIMAL
	NOUT
	 JFCL
	MOVE T2,JOBPNM(T2)	;GET PROGRAM NAME
	MOVEM T2,BUGPNM		;SAVE NAME OF PROGRAM
	HRROI T2,[ASCIZ/, User /]	;208
	SETZ T3,
	SOUT
	HRRZ T2,SEBDAT+BG%USR(Q1)	;GET USER LOGGED IN DIR NUMBER
	HRLI T2,USRLH		;TURN IT INTO PROPER FORMAT USER NUMBER
	DIRST			;TYPE OUT USER NAME
	 MOVEI T1,.PRIOU	;FAILED. RESTORE DESTINATION ADDRESS
LOGBF5:	SKIPG Q2,SEBDAT+BG%RCT(Q1)	;GET COUNT OF REGISTERS SAVED
	JRST LOGBF7		;NO REGISTERS TO BE TYPED
	HRROI T2,[ASCIZ/, Data /]	;208
	SOUT
	MOVEI T4,SEBDAT+BG%REG(Q1)	;GET POINTER TO REGISTER AREA
LOGBF6:	MOVE T3,[NO%MAG+10]	;TYPE THEM IN UNSIGNED OCTAL
	MOVE T2,0(T4)		;GET NEXT REG TO TYPE
	NOUT
	 JFCL
	SOJLE Q2,LOGBF7		;DONE?
	HRROI T2,[ASCIZ/, /]	;NO
	SETZ T3,
	SOUT
	AOJA T4,LOGBF6		;GO TYPE OUT REST

LOGBF7:	
repeat 0,<			;1023
	HRROI T2,[ASCIZ/
********************
/]
	SETZ T3,
	SOUT
>;1023
	MOVE T1,CRSTD1		;GET DATE OF BUGCHK
	CAMN T1,[-1]		;IS THERE ONE SET?
	CALL LGTAD		;NO, SEE IF IT IS SET NOW
	MOVEM T1,BUGTAD		;SAVE DATE AND TIME OF BUGCHK
	MOVE T1,Q1		;GO COPY REST OF DATA TO BLOCK
	MOVE T2,[-NBUGET,,BUGET]
	CALL SEBCPY
	 JFCL
	SOS BUGCNT		;COUNT DOWN THE QUEUED UP BLOCK COUNT
	SETZM BUGCHK		;CLEAR OUT LAST BUGCHK ADR
	RET			;FINISHED

BUGET:	SEBPTR BG%SVN,SBTSTR,SVN ;SYSTEM NAME
	SEBPTR BG%PNM,SBTWD,BUGPNM ;PROGRAM NAME
	SEBPTR BG%DAT,SBTWD,BUGTAD ;TIME AND DATE OF CRASH
	SEBPTR BG%MSG,SBTSTR,@BUGSP ;BUG MESSAGE
NBUGET==.-BUGET

;SEND TEXT TO ALL LINES, WAIT FOR COMPLETION
; 2/ PTR TO ASCIZ MESSAGE
;	CALL ALLMSG
; RETURN +1 ALWAYS, WAIT LONG ENOUGH FOR MESSAGE TO APPEAR ON 110 BAUD
;LINES.

ALLMSG::SETZ 1,			;SAY NO WAIT
   REPEAT 0,<
	HLRZ 3,2		;CHECK LH OF POINTER
	CAIN 3,-1		;DEFAULT?
	HRLI 2,(<POINT 7,0>)	;YES, DO IT
   >
	SETO T3,		;SAY ALL LINE
	TTMSG			;TYPE THE STUFF
	 ERJMP [BUG (TTFSMS)	;FAILED TO SEND MESSAGE
		JRST .+1]	;CONTINUE
	RET			; AND RETURN

CHKDRM:	HRROI 1,[ASCIZ /
*****DRUM ERR: /]
	PSOUT
	MOVSI 6,-NDRMEW		;# OF DRUM ERROR WORDS
	HRRI 6,DRMCFE		;FINISH AOBJN PTR
CHKD1:	MOVE B,0(6)		;GET WORD
	CALL TTOCTP		;PRINT IT
	TMSG <
	>
	AOBJN 6,CHKD1
	SETOM DRMJ0R		;RESET REQUEST FLAG
	RET			;RETURN

CHKDMS:	MOVE 1,DRMFRE
	CAMLE 1,DRMIN0		;DRUM SPACE LOW?
	RET			;NO
	HRROI 2,[ASCIZ /
[Caution--Swapping space low]
/]
	MOVX T3,SF%MS0
	TDNE T3,FACTSW		;WANT LEVEL 0 MESSAGES?
	CALL ALLMSG		;YES, DO IT
	HRROI 1,[ASCIZ /
*****Swapping space low, /]
	PSOUT
	MOVE 2,DRMFRE
	JRST CHKH1		;PRINT FREE COUNT

CHKSPT:	MOVE 1,SPTC
	CAMGE 1,SPC1		;SPT LOW?
	RET			;NO
	HRROI 2,[ASCIZ /
[Caution--SPT space low]
/]
	MOVE T3,FACTSW
	TXNE T3,SF%MS0		;WANT LEVEL 0 MESSAGES?
	CALL ALLMSG		;YES, DO IT
	HRROI 1,[ASCIZ /
*****SPT space low, /]
	PSOUT
	MOVN 2,[NOFN-SSPT]
	SUB 2,SPTC		;SPACE LEFT
	JRST CHKH1
;CHECK DSK SPACE

CHKDKS:	SKIPGE T1,EXPFRK	;EXPUNGE FORK RUNNING?
	RET			;YES - EXIT QUIETLY
	JUMPE T1,CKDKS1		;NO - EXISTS?
	SETZM EXPFRK		;YES - KILL IT
	KFORK			;...
CKDKS1:	SETZM T1		;ASSUME PUBLIC STRUCTURE
	CALL GSTRPG		;GET COUNT OF USED AND FREE PAGES ON STRUCTURE
	MOVE T1,T2		;GET FREE COUNT
	SUB 1,SYSSPC		;LESS 'BUFFER'
	CAILE 1,SYWRND		;LOW?
	RET			;NO
	PUSH P,2		;SAVE FREE COUNT
	HRROI 2,[ASCIZ /
[Caution--Disk space low on system structure]
/]
	MOVE T3,FACTSW
	TXNE T3,SF%MS0		;WANT LEVEL 0 MESSAGES?
	CALL ALLMSG		;YES, DO IT
	SKIPN T1,EXPTIM		;ENOUGH TIME SINCE LAST EXPUNGE?
	MOVX T1,<EXWTIM*^D60000> ;DONT DO EXPUNGES IN FIRST n MIN
	CAMG T1,TODCLK
	CALL EXPALL		;YES, DO EXPUNGE *
	HRROI 1,[ASCIZ /
*****Disk space low on system structure, /]
	PSOUT
	POP P,2			;RESTORE COUNT OF FREE PAGES
	CALLRET CHKH1

;ROUTINE TO DO EXPUNGE * WHEN DISK SPACE LOW
;START FORK AND MARK IT RUNNING
;	CALL EXPALL
;RETURNS +1 ALWAYS

NR EXPTIM,1		;TIME OF LAST EXPUNGE PLUS MIN INTERVAL
NR EXPFRK,1		;        0 := NO EXPUNGE FORK
			; -1,,FRKH := FORK RUNNING
			;  0,,FRKH := EXPUNGE DONE

EXPALL:	MOVX T1,CR%CAP		;PASS CAPABILITIES DOWN
	CFORK			;CREATE FORK
	 BUG (EXPAFK)
	HRROM T1,EXPFRK		;MARK FORK RUNNING
	MOVEI T2,EXPAL0		;START INFERIOR
	MSFRK			; IN MONITOR MODE
	RET			;RETURN (WAIT TILL DONE)

;EXPUNGE FORK STARTS HERE

EXPAL0:	MOVSI T1,(UMODF)	;SET FUNNY JSYS CONTEXT
	MOVEM T1,FFL
	SETZM FPC		;SET PC
	MCENTR
	CALL EXPAL1		;AWAY WE GO
	HRRZS EXPFRK		;SAY WE ARE DONE
	HALTF			;AND STOP

EXPAL1:	MOVX T2,SF%CDE!SF%BTE
	TDNE T2,FACTSW		;ANY BIT TABLE ERRORS?
	RET			;YES. DON'T EXPUNGE
	HRROI T2,[ASCIZ /
[Deleted files will be expunged from system structure in 30 seconds]
/]
	MOVE T3,FACTSW
	TXNE T3,SF%MS1		;WANT LEVEL 1 MESSAGES?
	CALL ALLMSG
	MOVEI T1,^D30000
	DISMS			;GIVE USERS TIME TO UNDELETE
	MOVX T1,RC%AWL		;ALLOW WILD CARDS
	HRROI T2,[ASCIZ "PS:<*>"]
	RCDIR			;GET FIRST DIRECTORY NUMBER
	 ERJMP [BUG (EXPRCD)
		JRST EXPAL3]	;WE TRIED
EXPAL2:	SETZ T1,		;NOTHING SPECIAL
	MOVE T2,T3		;PUT DIRECTORY NUMBER IN RIGHT PLACE
	DELDF			;EXPUNGE
	 ERJMP .+1		;IGNORE FAILURES
	MOVX T1,RC%STP!RC%AWL	;STEP TO NEXT
	MOVE T3,T2		;WHERE WE LEFT OFF
	HRROI T2,[ASCIZ "PS:<*>"] ;WHERE WE STARTED
	RCDIR			;...
	 ERJMP EXPAL3		;QUIT ON FAILURE
	TXNN T1,RC%NMD		;DONE?
	JRST EXPAL2		;NO - KEEP GOING

EXPAL3:	MOVX T1,<EXWTIM*^D60000>	;DONE, SET NEXT POSSIBLE TIME
	ADD T1,TODCLK
	MOVEM T1,EXPTIM
	HRROI T2,[ASCIZ /
[System structure expunge completed]
/]
	MOVE T3,FACTSW
	TXNE T3,SF%MS1		;WANT LEVEL 1 MESSAGES?
	CALL ALLMSG		;NOTIFY USERS
	RET			;DONE

CHKDSK:	RET			;NOP

CHKDE1:	RET			;NOP

;UTILITY NUMBER PRINTERS
;DECIMAL PRINT FOR LESS THAN 18 BIT NUMBERS
;OCTAL PRINT FOR MORE THAN 18 BIT NUMBERS DOES DDT HALFWORD FORMAT.

;B/ NUMBER TO PRINT
;	CALL TTXXXP	;XXX=(DEC,OCT)
;NUMBER PRINTED TO PRIMARY OUTPUT

TTDECP:	SKIPA C,[EXP ^D10]	;IN DECIMAL
TTOCTP::MOVEI C,^D8		;IN OCTAL
	MOVEI A,.PRIOU		;OUTPUT TO PRIMARY
	TLNN B,-1		;LH NON-0?
	JRST TTOCT1		;NO, SIMPLE PRINT
	PUSH P,B		;SAVE DATA
	HLRZ B,B		;PRINT LH
	NOUT
	 JFCL
	MOVEI B,","		;PRINT ,,
	BOUT
	BOUT
	POP P,B			;RECOVER DATA
	HRRZ B,B
TTOCT1:	NOUT			;PRINT RH
	 JFCL
	RET

;ANY INTERRUPT WILL EVENTUALLY TRAP TO HERE

CHKRI:	MOVE P,UPP
	ADD P,BHC+2		;RESET STACK
	SETZM SLOWF
	SETOM INTDF
	SETZM PSIBW
	HRROI 1,[ASCIZ /
*****Job 0 crash, continuing
/]
	PSOUT
	JRST CHKR

NR CHKDRE,1			;COUNT OF REC. ERRORS AT LAST REPORT
NR CHKDNE,1			; "" NON-REC. ""
NR CHKDMC,1

;CHKBGS - CHECK IF TIME TO STORE NEW ASCII TIME AND DATE FOR TYPEOUT
;	  AT BUGHLT TIME
;
;RETURNS:  +1,	ALWAYS

CHKBGS:	MOVE T1,TODCLK		;GET CURRENT DATE AND TIME
	CAML T1,BUGTMS		;TIME TO STORE ASCII STRING?
	SKIPGE TADIDT		;HAS TIME BEEN SET
	RET			;NO, NOT YET
	MOVX T2,<BUGINT>	;GET TIME INTERVAL FOR STORING STRING
	ADD T1,T2		;GET NEXT TIME FOR STORING STRING
	MOVEM T1,BUGTMS		;STORE
	MOVE T1,[POINT 7,BUGTIM] ;GET BYTE POINTER FOR STORING TIME
	MOVNI T2,1		;GET CURRENT TIME AND DATE
	SETZ T3,		; IN DEFAULT FORMAT
	ODTIM
	MOVE T2,"/"		;STORE DELIMITER FOR BUGMSG ROUTINE
	IDPB T2,T1
	RET

;ROUTINE TO FINISH LOGGING OF PARITY ERROR - RUN IN JOB 0 CONTEXT

; T1/ ADDRESS OF SYSERR BLOCK

PFCPJ0::SAVEQ
	HLRZ FX,SEBDAT+PT%JOB(T1) ;GET FORKX AT TRAP
	CAIE FX,-1
	SKIPGE FKPT(FX)
	RET			;IN SCHED OR FORK KILLED, NO DATA
	LOAD T2,FKJOBN		;GET JOB NUMBER
	HRRM T2,SEBDAT+PT%JOB(T1) ;REPORT IT
	HRRZ T3,JOBDIR(T2)	;GET LOGGED-IN DIRECTORY
	HRLI T3,USRLH		;MAKE IT A USER NUMBER
	MOVEM T3,SEBDAT+PT%USR(T1) ;REPORT IT
	MOVE T3,JOBPNM(T2)	;GET PROGRAM NAME
	MOVEM T3,SEBDAT+PT%PGM(T1) ;REPORT IT
	RET

;THE CHKAC JSYS - CHECK THE ACCESSABILITY OF A FILE OR DIRECTORY

;ACCEPTS IN 1/	COUNT OF ARGUMENTS
;	    2/	LOCATION OF ARGUMENT BLOCK
;	CHKAC
;RETURNS +1:	ERROR - ERROR CODE IN AC 1
;	 +2:	AC 1 = 0	ACCESS NOT ALLOWED
;		AC 1 = -1	ACCESS IS ALLOWED

;ARGUMENT BLOCK:
;	.CKAAC	DESIRED ACCESS CODE
;	.CKALD	LOGGED IN USER NUMBER OF THE USER DOING THE ACCESSING
;	.CKACD	CONNECTED STRUCTURE,,DIRECTORY OR POINTER TO STRUCTURE/
;		DIRECTORY STRING
;	.CKAEC	ENABLED CAPABILITIES OF THE USER
;	.CKAUD	STRUCTURE,,DIRECTORY OR POINTER TO STRUCTURE/DIRECTORY STRING
;		FOR FILE BEING ACCESSED
;		IF CK%JFN IS SET IN AC1, THIS IS JFN FOR FILE
;	.CKAPR	PROTECTION OF FILE BEING ACCESSED

.CHKAC::MCENT			;ENTER JSYS
	STKVAR <<SVT3T4,2>>
	UMOVE Q1,2		;GET LOCATION OF ARGUMENT BLOCK
	XCTU [HRRZ T1,1]	;GET LENGTH OF ARGUMENT BLOCK
	XCTU [HLL Q1,1]		;GET THE FLAGS
	TXNN Q1,CK%JFN		;SPECIFIING A JFN?
	CAIG T1,.CKAPR		;NO, NEED A PROTECTION
	CAILE T1,.CKAUD		;YES, DO NOT NEED THE PROTECTION WORD
	XCTU [SKIPA T1,.CKAEC(Q1)] ;LENGTH IS OK, GET CAPABILITIES
	RETERR (CKAX1)		;LENGTH IS TOO SHORT
	TRNE T1,SC%WHL!SC%OPR	;IS THIS USER A WHEEL?
	JRST CHKACT		;YES, ACCESS IS LEGAL ALWAYS
	XCTU [HRRZ P1,.CKAAC(Q1)] ;GET ACCESS CODE
	UMOVE T1,.CKAUD(Q1)	;GET THE JFN OR DIRECTORY DESIGNATOR
	TXNE Q1,CK%JFN		;IS USER GIVING A JFN?
	JRST CHKAC2		;YES
	CALL CNVSTD		;CONVERT TO A DIRECTORY NUMBER
	 RETERR ()		;ILLEGAL FORMAT OF STRING
CHKAC2:	MOVE P2,T1		;SAVE JFN OR DIR NUMBER IN P2
	UMOVE T1,.CKALD(Q1)	;GET THE LOGGED IN USER NUMBER
	LOAD T2,NMFLG,T1	;GET BITS 0-2
	CAIN T2,NUMVAL		;IS THIS A NUMBER?
	JRST CHKAC3		;YES, DONT NEED TO CONVERT THE STRING
	CALL CNVSTU		;CONVERT STRING TO USER NUMBER
	 RETERR ()		;FAILED
CHKAC3:	CALL CNVDIR		;CONVERT IT TO A DIR NUMBER
	MOVE P3,T1		;SAVE DIRECTORY # IN P3
	UMOVE T1,.CKACD(Q1)	;GET CONNECTED DIR # INTO P4
	CALL CNVSTD		;GET DIR NUMBER FROM STRING
	 RETERR ()		;FAILED TO GET A DIRECTORY NUMBER
	MOVE P4,T1		;SAVE DIR NUMBER FOR LATER
	TXNN Q1,CK%JFN		;GIVING A JFN?
	XCTU [HRLZ P5,.CKAPR(Q1)] ;NO, GET PROTECTION
	TXNE Q1,CK%JFN		;USER GIVING A JFN?
	JRST [	HRRZ T1,P2	;YES, GET IT
		CALL GETFPD	;GET PROT AND DIR #
		 RETERR (CKAX4)	;BAD JFN
		MOVE P2,T1	;SAVE DIR #
		HRLZ P5,T2	;SAVE PROTECTION
		JRST .+1]
	MOVE T1,P2		;MAP IN DIRECTORY OF FILE
	CALL SETDIR		;FIRST CHECK LEGALITY OF DIR #
	 RETERR (CKAX2)		;ILLEGAL DIR #
	ULKDIR			;UNLOCK DIR, BUT STAY NOINT
	CAIL P1,.CKADR		;IS THIS A DIRECTORY ACCESS CHECK?
	JRST CHKDIR		;YES, GO SET UP DIR PROTECTION VALUE
	MOVEI T4,<DP%RD>B35	;MUST ALSO CHECK READ ACCESS TO DIR
CHKAC0:	MOVSI Q2,40		;SET UP MASK WORD
	MOVN T1,P1		;GET CODE
	LSH Q2,0(T1)		;FORM THE ACCESS CHECK MASK
	TDNE Q2,P5		;IS THIS MODE ALLOWED FOR WORLD?
	JRST [	MOVE T1,DIRORA	;YES, NOW SEE IF LEGAL TO REF DIR
		LOAD T1,DRPRT,(T1) ;GET DIRECTORY PROTECTION
		TDNE T4,T1	;LEGAL TO REFERENCE IT?
		JRST CHKACT	;YES, THIS IS LEGAL THEN
		JRST .+1]	;NO, GO SEE IF THIS IS OWNER OR GROUP
	HLLZ T1,P5		;MAKE OWNER SUPERSET OF GROUP
	LSH T1,6
	IORM T1,P5		;DONT ALLOW GROUP MORE PRIVS THAN OWNER
	LSH Q2,^D12		;NOW SEE IF LEGAL FOR OWNER
	LSH T4,^D12		;DO SAME FOR DIR PROTECTION MASK
	MOVE T3,DIRORA		;GET BASE ADR OF MAPPED DIR
	LOAD T3,DRPRT,(T3)	;GET DIR PROTECTION
	MOVE T2,T3
	LSH T2,6		;MAKE OWNER SUPERSET OF GROUP
	IORM T2,T3		;T3 = DIR PROTECTION
	TDNE T4,T3		;LEGAL ACCESS FOR OWNER IN DIRECTORY?
	TDNN Q2,P5		;YES, IS FILE ACCESS LEGAL?
	JRST CHKACF		;IF NOT LEGAL FOR OWNER, THEN FALSE
	CAME P3,P2		;IS THIS FILE IN SAME DIR AS USER?
	CAMN P4,P2		;EITHER LOGGED IN OR CONNECTED
	JRST CHKACT		;YES, RETURN TRUE
	DMOVEM T3,SVT3T4	;SAVE T3 AND T4
	SETZ P4,		;FLAG FOR DIFFERENT STRUCTURES
	HLRZ T1,P2		;GET STRUCTURE TO ACCESS
	HLRZ T2,P3		;GET LOGGED IN STRUCTURE UNIQUE CODE
	CAMN T1,T2		;ARE THEY THE SAME?
	JRST CHKAC4		;YES, FORGET DOMESTIC STR TEST
	HLRZ T1,P2		;GET STRUCTURE UNIQUE CODE
	CALL CNVSTR		;GET STRUCTURE NUMBER
	 RETERR ()		;COULDN'T FIND STRUCTURE
	MOVE T2,T1		;SAVE STRUCTURE NUMBER
	CALL ULKSTR		;UNLOCK STRUCTURE FROM CNVSTR
	MOVE T2,STRTAB(T2)	;GET STRUCTURE DATA BLOCK ADDRESS
	MOVE T1,SDBSTS(T1)	;GET STATUS OF STRUCTURE
	TXNN T1,MS%DOM		;IS IT DOMESTIC?
	JRST CHKACF		;NO, RETURN FALSE
	MOVEI T2,MAXLW+1	;GET SOME JSB FREE SPACE
	CALL ASGJFR		; IN WHICH TO STORE USER NAME
	 RETERR (SACTX2)	;INSUFFICIENT RESOURCES
	MOVE P4,T1		;STORE FREE SPACE BLOCK ADDRESS
	AOS T1			;DON'T STEP ON HEADER
	HRLI T1,-1		;MAKE IT A POINTER
	MOVE T2,P3		;GET LOGGED IN DIRECTORY
	HRLI T2,USRLH		;MAKE IT A USER NUMBER
	DIRST			;GET USER NAME
	 JRST [ MOVEI T1,JSBFRE	;RELEASE FREE SPACE
		MOVE T2,P4
		CALL RELFRE
		RETERR ()]
	MOVE T1,P4		;GET ADDRESS OF NAME
	HLRZ T2,P2		;GET STUCTURE UNIQUE CODE
	CALL DIRLKX		;DOES USER HAVE A DIRECTORY ON THIS STR?
	 JRST [ MOVEI T1,JSBFRE	;NO DIRECTORY ON THAT STRUCTURE
		MOVE T2,P4	;RELEASE FREE SPACE
		CALL RELFRE
		JRST CHKACF]	;RETURN FALSE
	MOVE T2,P4		;GET ADDRESS OF JSB SPACE
	MOVE P4,T1		;STORE DIRECTORY NUMBER
	MOVEI T1,JSBFRE
	CALL RELFRE		;RETURN JSB SPACE
	HLL P4,P2		;ADD STR UNIQUE CODE TO DIR NUMBER
	CAMN P2,P4		;TRYING TO ACCESS OUR OWN DIRECTORY?
	JRST CHKACT		;YES, RETURN SUCCESS
	MOVE T1,P2		;MAP IN DESIRED DIRECTORY AGAIN
	CALL SETDIR
	 RETERR ()
	ULKDIR			;UNLOCK DIRECTORY
CHKAC4:	DMOVE T3,SVT3T4		;RESTORE T3 AND T4
	LSH Q2,-6		;NO, NOW SEE IF THIS IS SAME GROUP
	LSH T4,-6		;SAME FOR GROUP
	TDNE T4,T3		;LEGAL ACCESS TO DIR BY GROUPS?
	TDNN Q2,P5		;YES, LEGAL FOR GROUP?
	JRST CHKACF		;NO, RETURN FALSE
	CALL CPYDGP		;COPY DIR GROUPS INTO JSB
	 JRST CHKACF		;NO GROUPS
	MOVE P6,T1		;SAVE THE JSB POINTER
	SKIPN T1,P4		;TRYING TO ACCESS DIR ON PRIMARY STRUCTURE?
	MOVE T1,P3		;YES, GET LOGGED IN DIRECTORY
	CALL SETDIR		;GET INFO ABOUT THIS USER
	 RETERR (CKAX2)		;ILLEGAL DIRECTORY NUMBER
	ULKDIR			;UNLOCK THE DIRECTORY LOCK FROM GETDDB
	MOVE Q1,P6		;GET AOBJN POINTER TO DIR GROUP LIST
CHKAC1:	HLRZ T1,0(Q1)		;GET FIRST MEMBER OF GROUP
	CALL CHKUGP		;CHECK IT AGAINST USER GROUPS
	 SKIPA			;NO MATCH
	JRST [	MOVE A,P6	;MATCH FOUND
		CALL RELGRP	;RELEASE THE SPACE IN THE JSB
		JRST CHKACT]	;RETURN TRUE
	HRRZ T1,0(Q1)		;GET NEXT MEMBER OF GROUP
	CALL CHKUGP		;CHECK FOR MATCH
	 SKIPA			;NO MATCH
	JRST [	MOVE A,P6	;MATCHED!
		CALL RELGRP	;RELEASE THE JSB SPACE
		JRST CHKACT]	;RETURN TRUE
	AOBJN Q1,CHKAC1		;LOOP UNTIL LIST IS FINISHED
	MOVE A,P6		;RELEASE THE SPACE IN JSB
	CALL RELGRP
CHKACF:	TDZA T1,T1		;RETURN FALSE
CHKACT:	SETO T1,		;TRUE
	UMOVEM T1,1		;STORE ANSWER
	SMRETN			;AND RETURN

CHKDIR:	CAIL P1,.CKADR		;IS THIS A LEGAL FUNCTION CODE
	CAILE P1,.CKACF
	RETERR (CKAX3)		;NO, ILLEGAL ACCESS CODE
	SUBI P1,.CKADR		;SET UP FOR MASK BUILDING
	MOVE T4,DIRORA		;GET BASE OF DIR AREA
	LOAD T4,DRPRT,(T4)	;GET DIR PROTECTION
	HRL P5,T4		;ONLY WANT 18 BITS
	MOVEI T4,77		;DONT CARE ABOUT DIR PROTECTION CHECK
	JRST CHKAC0		;GO FINISH JSYS


;ROUTINE TO COPY A LIST OF GROUPS TO THE JSB
;	CALL CPYDGP	OR	CALL CPYUGP
;RETURNS +1:	NO GROUPS
;	 +2:	AOBJN POINTER TO LIST IN JSB RETURNED IN T1

CPYDGP::SE1CAL			;ENTER SEC 1
	MOVE D,DIRORA		;GET BASE OF DIR AREA
	LOAD D,DRDGP,(D)	;GET DIR GROUP LIST
	JRST CPYUG0		;ENTER COMMON CODE

CPYUGP::SE1CAL			;ENTER SEC 1
	MOVE D,DIRORA		;GET BASE OF DIR AREA
	LOAD D,DRUGP,(D)	;GET USER GROUP LIST
CPYUG0:	JUMPE D,R		;IF 0, NO LIST
	STKVAR <CPYUGA>
	ADD D,DIRORA		;GET ABS ADR OF LIST
	LOAD C,BLKTYP,(D)	;GET TYPE OF THIS BLOCK
	CAIE C,.TYGDB		;MUST BE A DIRECTORY GROUP BLOCK
	RET			;DIR IS SCREWED UP
	LOAD B,BLKLEN,(D)	;GET LENGTH OF BLOCK
	SOS B			;SKIP OVER HEADER
	MOVEM D,CPYUGA		;SAVE ADR OF LIST
	CALL ASGJFR		;GET A BLOCK FROM JSB
	 RET			;NO ROOM
	MOVE D,CPYUGA		;GET BACK ADR OF LIST
	HRRZ B,0(A)		;GET LENGTH OF DIR LIST
	MOVNS B			;SET UP AN AOBJN POINTER TO JSB
	HRL A,B
	MOVE C,A		;LEAVE POINTER IN A
CPYUGL:	MOVE B,1(D)		;GET NEXT ELEMENT IN LIST
	MOVEM B,0(C)		;STORE IN JSB
	AOS D			;STEP TO NEXT ELEMENT IN LIST
	AOBJN C,CPYUGL		;LOOP TIL LIST IS COPIED
	RETSKP			;RETURN SUCCESSFUL WITH POINTER IN A


;ROUTINE TO RELEASE A GROUP LIST FROM JSB
;ACCEPTS IN A/	POINTER TO LIST
;	CALL RELGRP
;RETURNS +1:	ALWAYS

RELGRP::HLRE B,A		;GET LENGTH OF BLOCK
	HRRZS	A		;INSURE IN THIS SECTION
	MOVNM B,(A)		;STORE LENGTH IN BLOCK
	HRRZ B,A		;GET ADR OF BLOCK
	MOVEI A,JSBFRE
	CALLRET RELFRE		;RELEASE THE BLOCK

;MDDT INTERNAL SUBROUTINE CALL.  THIS SUBROUTINE IS THE INTERFACE
;BETWEEN MDDT AND THE REST OF THE MONITOR.  CALL:
;
;	AC1/	FUNCTION CODE
;	AC2-AC4/ ARGUMENTS
;	CALL .IMOPR
;	  ERROR RETURN
;	SUCCESSFUL RETURN



.IMOPR::JUMPLE T1,R		;FAIL IF NOT POSITIVE
	CAIG T1,IMMAX		;FUNCTION LEGAL?
	SKIPN HSYBLK		;SYMBOLS HIDDEN? (FUNCTIONS SO FAR NEED THIS)
	RET			;NO, GIVE ERROR RETURN
	JRST @IMTAB-1(T1)	;GO TO PROPER ROUTINE



IMTAB:	IFIW	IMALC		;(1) ALLOCATE PAGES FOR USE
	IFIW	IMMAP		;(2) MAP PAGES OF THE SYMBOL SPACE
	IFIW	IMUMAP		;(3) UNMAP PAGES OF SYMBOLS

	IMMAX==.-IMTAB		;HIGHEST FUNCTION




;FUNCTION .IMALC.  ALLOCATES A PAGE FOR USE IN MAPPING SYMBOLS.  PAGE
;IS RELEASED WHEN FORK IS DESTROYED.  MULTIPLE CALLS WILL RETURN THE
;SAME PAGE.  ARGUMENTS:
;
;	T2/	NUMBER OF PAGES DESIRED (ONLY 1 IS LEGAL NOW)
;
;RETURNS PAGE NUMBER OF FIRST PAGE IN T1.


IMALC:	CAIE T2,1		;ASKING FOR ONE PAGE?
	RET			;NO, FAIL
	NOINT			;PREVENT INTERRUPTIONS
	SKIPE T1,SYMPAG		;PREVIOUSLY ALLOCATED A PAGE?
	JRST IMALCH		;YES, RETURN IT
	CALL ASGPAG		;GET A NEW JSB PAGE
	SETZ T1,		;NONE AVAILABLE
	MOVEM T1,SYMPAG		;REMEMBER FOR LATER USE
IMALCH:	OKINT			;INTERRUPTS OK NOW
	LSH T1,-PGSFT		;CONVERT TO PAGE NUMBER
	JUMPN T1,RSKP		;SKIP RETURN IF GOT A PAGE
	RET			;OTHERWISE FAIL

;FUNCTION .IMMAP.  MAP PAGES OF THE SYMBOL SPACE.  USED BY MDDT
;AND SNOOP JSYS.  ARGUMENTS:
;
;	T2/	PAGE IN SYMBOL SPACE TO MAP
;	T3/	PAGE IN MONITOR SPACE TO MAP TO
;	T4/	COUNT OF PAGES TO MAP.  1B0 SET IF WRITE ENABLED


IMMAP:	MOVE T1,T2		;SET UP PAGE NUMBER TO MAP
	HRL T1,SYMBAS		;AND PUT IN SPT INDEX OF SYMBOL MAP
	TDNN T2,[-1,,777000]	;SYMBOL SPACE EXISTS ONLY IN SECTION 0
IMMAP1:	TDNE T3,[-1,,776000]	;SEE IF PAGE IS SECTION 0 OR 1
	RET			;IF NOT, ERROR
	ANDI T3,777		;MAKE SECTION 1 SAME AS SECTION 0
	MOVE T2,T3		;GET PAGE WHERE WE MAP TO
	LSH T2,PGSFT		;TURN INTO ADDRESS
	TXZE T4,1B0		;WANT IT WRITE-ENABLED?
	TXO T2,PTRW		;YES, SET WRITE BIT
	TLNN T4,-1		;CHECK REST OF LEFT HALF
	TRNN T4,-1		;AND MAKE SURE HAVE NONZERO COUNT
	RET			;NO, ERROR
	ADDI T3,-1(T4)		;CALCULATE LAST PAGE TO BE MAPPED
	TRNE T3,777000		;MAKE SURE IT STAYS IN SECTION 0
	RET			;NO, ERROR
	MOVE T3,T4		;PUT COUNT IN RIGHT AC
	CALL MSETMP		;DO THE MAPPING
	RETSKP			;GOOD RETURN



;FUNCTION .IMUMP.  UNMAP SYMBOL PAGES.  ARGUMENTS ARE:
;
;	T2/	PAGE IN NORMAL SPACE WHERE SYMBOLS WERE MAPPED
;	T3/	COUNT OF PAGES TO UNMAP


IMUMAP:	MOVE T4,T3		;MOVE ARGS TO RIGHT ACS
	MOVE T3,T2		;SO CAN JOIN OTHER ROUTINE
	SETZM T1		;ZERO FOR UNMAP
	CALLRET IMMAP1		;GO DO THE WORK

;LOGOUT

.LGOUT::MCENT
	CAME 1,[-1]		;SELF?
	JRST ELOGO		;NO
	MOVSI 1,(SC%LOG)
	TDNN 1,CAPMSK		;LOG PERMITTED?
	RETERR (LOUTX4)		;NO, ERROR RETURN
	SETONE JSELO		;FLAG THAT JOB EXECUTED ITS OWN LGOUT
LOGO:	SE1ENT			;GET TO SECTION 1
	MOVE T1,JOBNO		;GET CORRECT JOB NUMBER
	CALL LGOGOK		;CHECK TO SEE IF LOGO LEGAL
	SKIPN FORKN		;TOP FORK?
	JRST FLOGO1		;YES
	NOINT
	HLRZ 1,FORKN		;NO, GET ITS NUMBER
	HRRZ 2,SYSFK(1)
	NOSKED
	MOVX T1,FKPSI0+PSILO%
	IORM 1,FKINT(2)		;REQUEST LOGOUT
	CALL PSIR4
	OKSKED
	OKINT
	JRST WAIT1		;WAIT FOR TOP FORK TO KILL THE JOB

;ROUTINE CALLED TO LOGOUT ANOTHER JOB.
;ACCEPTS:	A/ JOB NUMBER
;RETURNS:	+1 WITH LOGOUT REQUESTED

	RESCD			;MUST BE RESIDENT AS CALLED BY SCHEDULER

ELOGOO::NOSKD1			; prevent races
	SKIPGE JOBRT(T1)	; job exist?
	JRST [	OKSKD1			; no, fail
		RET]			;  ..
	HRRZ 2,JOBPT(1)		;TOP FORK OF OBJECT JOB
	MOVX T1,FKPSI0+PSILO%
	IORM 1,FKINT(2)		;REQUEST LOGOUT
	CALL PSIR4
	OKSKD1			;ALLOWING SCHEDULING AGAIN
	RET			;AND DONE

;THE FOLLOWING IS RUN IN THE TOP FORK OF A JOB TO RESPOND TO
;A LOGOUT REQUEST FROM ANOTHER JOB.
;HERE FROM PSI SERVICE DEBREAK.  FFL AND FPC SETUP.

	SWAPCD

FLOGO::	MCENTR			;SIMULATE ENTRY FROM USER
	; ..

;THE FOLLOWING CODE DOES THE ACTUAL LOGOUT.  IT RUNS ONLY IN
;THE TOP FORK OF THE JOB BEING LOGGED OUT

	; ..
FLOGO1:	MOVX 1,LOGIOB		;SAY JOB DESTRUCTION IN PROGRESS
	IORM 1,JOBBIT
	MOVEI 1,400000
	SETO 2,
	DIC			;DEACTIVATE INTERRUPTS AND KEYS
	CALL DTIALL
	CALL NETLGO		;RELEASE ANY JOB-WIDE NETWORK RESOURCES
	CALL INTLGO		;1001 Release any internet queues
	MOVEI T1,-4
	KFORK			;DELETE FORKS
	MOVE T1,JOBNO		;MARK THAT I AM NO LONGER OWNED
	SETOM JOBONT(T1)		; ..
	MOVSI T3,-NJOBS		;LOG OUT ANY JOBS WHICH I OWN
SJLGO1:	HRRZ T2,JOBONT(3)	;DO I OWN THIS ONE?
	CAME T2,JOBNO		; ..
	JRST SJLGO2		;NO.
	MOVEI T1,0(T3)		;YES. LOG IT OUT.
	LGOUT
	 JFCL			;SHOULD HAVE WORKED.
	SETOM JOBONT(T3)		;MAKE IT UNOWNED, SO IT FINISHES
SJLGO2:	AOBJN T3,SJLGO1		;SEE IF I OWN ANY MORE JOBS
	; ..

	; ..
SJLGO4:	MOVX T1,.FHSLF			;1001 FOR THIS FORK
	CLZFF				;1001 DO A CLZFF
		;1001 HOPEFULLY THAT CLZFF GETS RID OF ANY BAD INTERACTIONS 
		;1001 BETWEEN THINGS LIKE THE TCP AND THE UPT
	SETO T1,			;CLEAR USER MAP OF TOP FORK
	MOVSI 2,<.FHSLF!FH%EPN>		;THIS FORK
	MOVE 3,[PM%CNT!PM%EPN!<1000>B35] ;REQUEST 1000 PAGES
	PMAP
	 ERJMP .+1
	MOVE FX,FORKX
	LOAD 1,FKJSB		;GET JSB
	CALL WTSPT		;WAIT FOR SHR CNT OF 1
	SKIPL CTRLTT
	RESET			;RESET TTY MODES, ETC.
	CALL UNPAGE		;CLEAR PAGE MODE
	MOVE 1,[CZ%ARJ+CZ%ABT+400000] ;WAIT+FLUSH NONX + THIS FORK
	CLZFF
	MOVE 1,FORKX		;NOW KILL PIDS OF THIS FORK
	CALL PIDKFK		; INCLUDING JOB WIDE PIDS
	CALL CLKREL		;RELEASE TIMER BLOCKS
	MOVE 4,JOBNO
	HRRZ 1,JOBDIR(4)	;GET LOGIN DIR
	JUMPE 1,LOG1		;DON'T EXPUNGE IF NOT LOGGED IN
	HRLI T1,USRLH		;GET USER NUMBER
	CALL CNVDIR		;CONVERT IT TO A DIRECTORY NUMBER
	MOVE T2,T1		;SET UP FOR DELDF
	MOVX T1,DD%DTF		;DELETE TEMPORARY FILES
	PUSH P,T2		;SAVE DIR NUMBER
	DELDF			;EXPUNGE LOGIN DIR
	 ERJMP .+1		;DONT STOP ON ERRORS
	CALL GTCSCD		;GET CONNECTED STRUCTURE,,DIRECTORY
	POP P,T3		;GET BACK DIR # FROM LAST DELDF
	CAMN T1,T3		;ARE THEY THE SAME?
	JRST LOG0		;YES, DO NO EXPUNGE AGAIN
	MOVE T2,T1		;GET DIR NUMBER INTO 2
	MOVX T1,DD%DTF		;DELETE TEMPORARY FILES
	DELDF			;EXPUNGE CONNECTED DIR
	 ERJMP .+1		;DONT STOP ON ERRORS
LOG0:	CALL LOGSTR		;GO DECREMENT MOUNT COUNT FOR ALL STR'S
				; THIS JOB HAS MOUNTED
	MOVNI 1,1		;NOW RELEASE ALL ASSIGNED DEVICES
	RELD
	 JFCL
	MOVE 1,LOGDES
	DOBE			;WAIT FOR LOG TTY INACTIVE
	CALL LOGTOT		;SUMMARY TO LOG TTY
	CALL LOGTUS		;Perform USAGE for logout
LOG1:	HRRE 1,CTRLTT
	JUMPL 1,LOG2		;CONTROL TTY?
	MOVEI 1,400000(1)	;YES, PRINT LOGOUT MESSAGE
	RFMOD			;TURN OFF PAGE MODE
	TXZ 2,TT%PGM		;TO ALLOW THE MESSAGE TO COME OUT
	STPAR
	CALL LOGTOT
	HRLOI T1,(TL%CRO+TL%COR+TL%SAB+TL%ABS)
	SKIPGE T2,CTRLTT	;GET TTY
	 JRST LOG2		;IF DETACHED
	CAMN T2,CTYLNO		;Logging off CTY?
	TXZ T1,TL%ABS		;Yes - set refuse links
	MOVEI T2,-1
	TLINK			;BREAK LINKS, SET ACCEPT
	 JFCL
  REPEAT 1,<
	MOVEI T4,^D15		;WAIT FOR 15 SECONDS MAX
LOG21:	HRRE T1,CTRLTT		;GET TTY #
	JUMPL T1,LOG2		;NONE
	MOVEI T1,400000(1)	;GET DESIGNATOR
	SOBE			;LOGOUT MESSAGE COMPLETE?
	IFNSK.
	  MOVEI T1,^D1000	;NO, WAIT A SECOND
	  DISMS
	  SOJG T4,LOG21		;TRY AGAIN OR GIVE UP
	ENDIF.
   >
   REPEAT 0,<			;ALTERNATE WAY OF DOING THIS
	HRRE T1,CTRLTT		;GET TTY #
	JUMPL T1,LOG2		;NONE
	MOVEI T1,400000(1)	;GET DESIGNATOR
	DOBE			;WAIT FOR THE MESSAGE TO COMPLETE
   >
	MOVE T1,JOBNO
	HRRZ T1,JOBDIR(1)
;3072	JUMPN T1,LOG2		;IF LOGGED IN, DON'T HANG UP THE LINE
	SKIPG T2,CTRLTT		;3053 Get controlling terminal
	IFSKP.			;3053
	  CAML T2,CTYLNO	;3053 Is this line between 1 and CTY-1?
	  IFSKP.		;3053
	    SKIPGE TTSTAT(2)	;3053 Remote?
	      CALL TTHNGU	;3053 Yes, Hangup Dataset, Return
	  ENDIF.		;3053
	ENDIF.			;3053
;3053	SKIPGE T2,CTRLTT	;3032 If detached, don't hang up either
;3053	 JRST LOG2		;3032
;3054	CALL CHKTVT		;3032 And don't hang up if TVT
;3054	 CALL TTHNGU		;HANG UP LINE WHEN NOT LOGGED IN
LOG2:	MOVEI T1,SPIDTB+.SPQSR	;GET PID ADDRESS
	SKIPE SPIDTB+.SPQSR	;IS QUASAR RUNNING?
	CALL LOGOMS		;YES, SEND IT A MESSAGE
	 JFCL
	MOVEI T1,SPIDTB+.SPOPR	;GET ORION PID ADDRESS
	SKIPE SPIDTB+.SPOPR	;RUNNING?
	CALL LOGOMS		;YES, SEND IT A MESSAGE
	 JFCL
	SKIPE T1,JSLOPD		;IS THERE A PID IN JSB FOR LGOUT MSG?
	CALL LOGOMO		;YES. SEND THE LOGOUT MESSAGE TO CREATOR
	 JFCL
	JRST HLTJB

LGOGOK:	SAVET
	HRRZ T1,JOBDIR(T1)	;DIRECTORY
	JUMPE T1,R		;QUIT NOT LOGGED IN
	HRLI T1,USRLH
	CALL CNVDIR		;GET DIRECTORY NUMBER
	GTDAL			;GET ALLOCATION
	ERJMP R			;QUIT SOME ERROR
	UMOVE T1,T1		;GET ORIG ARGUMENT
	GTOKM (.GOLGO,<T2,T3,T1>,[RETERR ()])	 ;ASK PERMISSION
	RET			;RETURN TO CALLER

;LOGSTR - ROUTINE TO DECREMENT MOUNT COUNT FOR ALL STRUCTURES THIS
;	  JOB HAS MOUNTED.
;
;CALL:		CALL LOGSTR
;RETURNS: +1 ALWAYS

LOGSTR:	SAVEP
	LOCK JSSTLK		;LOCK THE JSB STRUCTURE INFO DATA
	MOVSI P1,-STRN		;SET UP TO LOOP OVER STR INFO BLOCKS IN JSB
	MOVEI P2,JSSTRT		;GET ADDRESS OF FIRST BLOCK TO LOOK AT

LGST10:	JE <JSMCI,JSXCL>,(P2),LGST20 ;IF THIS JOB DIDN'T MOUNT THIS STR, CHECK NEXT
	LOAD T1,JSSTN,(P2)	;GET UNIQUE CODE FOR THIS STRUCTURE
	CALL CNVSTR		;GET STRUCTURE # AND LOCK THE STRUCTURE
	 JRST LGST20		;FAILED, MUST ALREADY BE DISMOUNTED, GO ON
	MOVEM T1,P3		;SAVE STRUCTURE NUMBER
	JN JSXCL,(P2),[	MOVX T1,D1%INI ;IF MOUNTED EXCLUSIVELY BY THIS JOB,
			ANDCAM T1,DEVCH1+DVXST0(P3) ; MAKE STR GENERALLY AVAILABLE
			JRST .+1]
	JE JSMCI,(P2),LGST15	;IF MOUNT COUNT NOT INCREMENTED, GO UNLOCK STR
	MOVE T1,P3		;GET STRUCTURE NUMBER AGAIN
	MOVE T2,P2		;GET ADDRESS OF STR INFO BLOCK IN JSB
	MOVE T3,JOBNO		;GET JOB NUMBER
	CALL DECMNT		;GO DECREMENT THE MOUNT COUNT FOR THIS STR
	 JFCL			;IGNORE FAILURE, GO ON
LGST15:	MOVE T1,P3		;RESTORE STRUCTURE NUMBER
	CALL ULKSTR		;UNLOCK THE STRUCTURE NOW
LGST20:	ADDI P2,JSSTMX		;GET ADDRESS OF NEXT STR INFO BLOCK IN JSB
	AOBJN P1,LGST10		;GO CHECK NEXT STR INFO BLOCK

	UNLOCK JSSTLK		;DONE, UNLOCK THE JSB STR INFO LOCK
	RET			;RETURN

;THE FOLLOWING IMPLEMENTS LOGOUT OF A JOB OTHER THAN SELF.
;LEGAL IF USER IS SC%WHL OR SC%OPR, OR IF OTHER JOB IS SAME USER

ELOGO:	MOVE T2,JOBNO		;GIVEN JOB NUMBER TO LOGOUT
	CAIN T2,0(T1)		;SELF?
	RETERR(LOUTX1)		;YES, CAN'T SAY IT THAT WAY
	JUMPE T1,[RETERR (LOUTX5)] ;CANNOT LOGOUT JOB 0
	CAIGE T1,NJOBS		;REASONABLE NUMBER?
	CAIG T1,0
	RETERR(LOUTX2)		;NO
	MOVE P1,T1		; preserve target job number
	CALL LGOGOK		;GETOK CHECK
	NOSKED			; prevent races
	SKIPGE JOBRT(P1)	;EXISTS?
	RETERR(LOUTX2,OKSKED)	; no, fail
	MOVE T1,P1		; target job number
	CALL SETJSB		; map its JSB
	MOVE P2,T1		; preserve JSB address
	HRRZ T3,JOBDIR(P1)	;LOGIN DIRECTORY OF OBJECT JOB
	MOVE T1,JOBNO		; our job number
	XOR T3,JOBDIR(T1)	; our directory number
	TRNN T3,-1		;SAME AS THIS JOB?
	JRST ELOGO1		;YES, THAT'S OK
	HLRE T1,JOBPT(P1)	;GET TTY OF THE JOB BEING LOGGED OUT
	JUMPL T1,ELOGO3		;JUMP IF DETACHED
	CALL PTGETJ		;GET CONTROLLING JOB # IF TTY IS A PTY
	JUMPL T1,ELOGO3		;JUMP IF NOT A PTY JOB
	CAMN T1,JOBNO		;JOB BEING CONTROLLED BY JOB DOING THE LGOUT
	JRST ELOGO1		;YES, SO DO IT
ELOGO3:	HRRZ T3,JOBONT(P1)	;DO I OWN THAT JOB IN CRJOB SENSE?
	CAMN T3,JOBNO		; ..
	JRST ELOGO1		;YES. OK TO LOG IT OUT.
	MOVEI T3,SC%WHL+SC%OPR	;OTHERWISE MUST BE SC%WHL
	TDNN T3,CAPENB
	JRST [	CALL CLRJSB		; unmap the JSB
		RETERR(LOUTX3,OKSKED)]	; quit
ELOGO1:	SETOM JOBONT(P1)	;MAKE IT UNOWNED SO IT CAN LOG OUT
	SETONE JSOLO,(P2)	;FLAG IN IT THAT SOMEONE LGOUT'ED IT
	MOVE T1,JOBNO		;AND WHO IT WAS
	MOVEM T1,JSLOJB(P2)	; ..
	CALL CLRJSB		;LET GO OF THE JSB
	MOVE T1,P1		; target job number
	CALL ELOGOO		;LOG OUT THE TARGET JOB
	OKSKED
	SMRETN			;AND DONE

;LOGGING FUNCTIONS

;TYPE LOGOUT MESSAGE, DESTINATION DESIGNATOR IN 1

LOGTOT::SKIPE 2,JSLOJB		;DID SOMEONE ELSE LOG OUT THIS JOB?
	CALL LOGTOK		;YES - INFORM THE VICTIM
	HRROI 2,[ASCIZ /Logout/] ;16 pacifistic (changed from killed)
	CALLRET LOGUSD		;Log job and time used info, setup time for USAGE
				; and return from LOGTOT

;SUBROUTINE TO TELL A VICTIM ABOUT WHO LOGGED OUT HIS JOB

LOGTOK:	PUSH	P,T2		;SAVE JOB NUMBER OF MURDERER
	HRROI	T2,[ASCIZ /Killed by /]
	PUSHJ	P,LOGMES
	MOVE	T2,(P)		;GET KILLER BACK
	HRRZ	T2,JOBDIR(T2)
	JUMPE	T2,LOGTK1	;SKIP THIS IF HE'S NOT LOGGED IN
	HRLI	T2,USRLH	;ELSE OUTPUT USER'S NAME
	MOVE	T3,T1		;SAVE OUTPUT DESIGNATOR
	DIRST
	 MOVE	T1,T3		;IF ERROR, RESTORE OUTPUT DESIGNATOR
LOGTK1:	POP	P,T2		;GET JOB NUMBER
	HLRZ	T2,JOBPT(T2)	;GET CONTROLLING TERMINAL OF THAT JOB
	JUMPL	T2,LOGTK2	;IF JOB IS DETACHED SKIP THIS
	PUSH	P,T2		;ELSE SAVE TERMINAL NUMBER
	HRROI	T2,[ASCIZ /, TTY /]
	PUSHJ	P,LOGMES
	POP	P,T2		;GET TERMINAL NUMBER AGAIN
	MOVEI	T3,^D8		;PRINT IT IN OCTAL
	PUSHJ	P,LGNOUT
LOGTK2:	CALLRET	LOGCR		;OUTPUT A CRLF AND RETURN

;Perform USAGE for logout

LOGTUS:	MOVEI T1,.USLGO		;LOGOUT FUNCTION
	MOVEI T2,LOGLST
	USAGE			;USAGE JSYS
	 ERCAL XUSAGE		;REPORT FAILURE
	RET			;Return from LOGTUS

;LOGON MESSAGE, CALLED FROM .LOGIN

LOGONM::SKIPL 1,LOGDES
	DOBE			;WAIT FOR OTHER USE OF TTY TO FINISH
	HRROI 2,[ASCIZ /Login/]
	CALL LOGMES
	MOVE T2,CTRLTT		;T2/ LINE NUMBER
	CALL LOGJOB
	PUSH P,1
	MOVEI T1,.USLGI		;LOGIN FUNCTION
	MOVEI T2,LOGLST		;POINT TO PARAMETERS
	USAGE
	 ERCAL XUSAGE		;REPORT USAGE FAILURE
	POP P,1
	CALLRET LOGCR		;AND CRLF

XUSAGE:	SKIPN DBUGSW		;149 Ignore this if debugging
	BUG (UXXFAI)
	RET			;CONTINUE

;PARAMETER BLOCK FOR LOGIN/LOGOUT/SESSION CHANGE CALLS

LOGLST:	USENT. (.UTSEN,1,1)	;SESSION ENTRY TYPE
	USRTM. (JBRUNT)		;RUN-TIME
	USACT. (<-1,,ACCTSR>)	;ACCOUNT
	USSST. (CTIMON)		;SESSION START DATE/TIME
	USJTY. (-1)		;BATCH T/S FLAG
	USBJN. (JBBNAM)		;BATCH JOB NAME
	USBSN. (JBBSEQ)		;BATCH SEQ NUMBER
	USCOM. (<-1,,JSSRM+1>)	;SESSION REMARK
	USCCT. (CONCON)		;CONSOLE CONNECT TIME
	USPNM. (<SIXBIT "MONITR">,US%IMM)
	USPVR. ([EXP SVNM])	;MONITOR NAME AND VERSION
	USNM2. (<-1,,USRNAM+1>)	;USER NAME
	USUDC. (JSBTRP,,10)	;241 Number of page traps
	0			;END OF LIST

;CHANGED ACCOUNT NUMBER MESSAGE

LOGCJM::SKIPL 1,LOGDES
	DOBE
	HRROI 2,[ASCIZ /Changed/]
	CALL LOGUSD		;Log job and time used, setup for time for USAGE
	MOVE T2,JBRUNT		;Get session runtime
	ADDM T2,JSSRTM		;Update session runtime start for next session
	MOVE T2,CONCON		;Get session connect time
	ADDM T2,JSSCTM		;Update session console time start
	PUSH P,1		;SAVE OUTPUT DESIGNATOR
	MOVEI T1,.USSEN		;SESSION ENTRY CODE
	MOVEI T2,LOGLST		;PARAMS
	USAGE
	 ERCAL XUSAGE
	POP P,1			;RESTORE
	RET			;Return from LOGCJM

;Print job info, time used, and setup times for USAGE

LOGUSD:	CALL LOGMES		;Print message type
	MOVE T2,CTRLTT		;Get controlling terminal number
	CALL LOGJOB		;Type job and terminal info

	HRROI T2,[ASCIZ /,  Used /]
	CALL LOGMES		; . . .
	MOVE T2,JOBNO		;Get this job's number
	MOVE T2,JOBRT(T2)	;Get runtime of job
	MOVE T3,T2		;Copy it again
	SUB T3,JSSRTM		;Compute session runtime
	MOVEM T3,JBRUNT		;Save for USAGE
	CALL LOGTIM		;Print runtime

	HRROI T2,[ASCIZ / in /]
	CALL LOGMES		; . . .
	MOVE T2,TODCLK		;Get current uptime
	SUB T2,CONSTO		;Compute console time logged in
	MOVE T3,T2		;Copy console time
	SUB T3,JSSCTM		;Compute console time this session
	MOVEM T3,CONCON		;Save console time for USAGE
	CALL LOGTIM		;Print console time

	SKIPN JSSRTM		;Session start
	SKIPE JSSCTM		; at beginning of job?
	 SKIPA			;No-- print time this session
	JRST LOGUS2		;Yes-- don't repeat ourselves

	HRROI T2,[ASCIZ /,
  Used this session /]
	CALL LOGMES		; . . .
	MOVE T2,JBRUNT		;Get session time
	CALL LOGTIM		;Print it
	HRROI T2,[ASCIZ / in /]
	CALL LOGMES		; . . .
	MOVE T2,CONCON		;Get console time this session
	CALL LOGTIM		;Print it
LOGUS2:
	CALLRET LOGCR		;Finish with CRLF

;PRINT TIME FROM 2

LOGTIM:	JUMPL 1,R
	IDIVI 2,^D1000		;MS TO SECS
	IDIVI 2,^D60		;PEEL OFF SECONDS
	PUSH P,3
	IDIVI 2,^D60		;PEEL OFF MINUTES
	PUSH P,3
	CALL LOGNUM		;PRINT HOURS
	MOVEI 2,":"
	BOUT
	POP P,2
	CALL LOG2NM		;PRINT MINUTES
	MOVEI 2,":"
	BOUT
	POP P,2
	CALL LOG2NM		;PRINT SECONDS
	RET

;ATACH AND DETACH MESSAGES

;DETMSG - RECORD DETACHING OF JOB

;ACCEPTS:
;	T2/ LINE NUMBER

DETMSG:	STKVAR <DETMLN>
	MOVEM T2,DETMLN		;SAVE LINE NUMBER
	HRROI 2,[ASCIZ /Detached/] ;WORD FOR LOG TTY
	SKIPL 1,LOGDES
	DOBE
	CALL LOGMES
	MOVE T2,DETMLN		;T2/ LINE NUMBER
	CALL LOGJOB
				;*** DETACH ***
	CALLRET LOGCR		;CRLF AND RETURN

DETMS0:	ASUBR <ATAJN,ATALN>	;JOB # , LINE #
	HRROI 2,[ASCIZ /Detached job /]
	SKIPL 1,LOGDES
	DOBE
	CALL LOGMES
	MOVE 2,ATAJN		;GET REMOTE JOB NUMBER
	CALL LOGNUM
	HRROI 2,[ASCIZ / from TTY /]
	JRST ATAMS3

ATAMSG:	ASUBR <ATAJN,ATALN>	;JOB # , LINE #
	SKIPL 1,LOGDES
	DOBE
	HRROI 2,[ASCIZ /Attached job /]
	CALL LOGMES
	MOVE T2,ATAJN		;GET JOB NUMBER
	CALL LOGNUM		;PRINT IT
	HRROI 2,[ASCIZ / to TTY /]
ATAMS3:	CALL LOGMES
	MOVE T2,ATALN		;LINE NUMBER
	MOVEI 3,^D8		;PRINT IN OCTAL
	CALL LGNOUT
	CALL LOGJ2		;PRINT AND STORE TOD
				;*** ATTACH ***
	CALLRET LOGCR		; END WITH CRLF

;PRINTS  JOB 1, TTY 40, AT 12:34:56
;  OR    JOB 1, DETACHED, AT 12:34:56

;ACCEPTS:
;	T2/ LINE NUMBER

LOGJOB:	STKVAR <LOGJLN>
	MOVEM T2,LOGJLN		;T2/ LINE NUMBER
	HRROI 2,[ASCIZ / Job /]
	CALL LOGMES
	MOVE 2,JOBNO
	CALL LOGNUM
	MOVE 2,JOBNO
	HRRZ 2,JOBDIR(2)
	JUMPE 2,LOGJ3		;LOGGED IN NOW?
	HRROI 2,[ASCIZ /, User /]
	CALL LOGMES
	MOVE 2,JOBNO
	HRRZ 2,JOBDIR(2)
	HRLI 2,USRLH		;TURN IT INTO A 36 BIT USER NUMBER
	MOVE 3,1		;SAVE OUTPUT DESIGNATOR
	CAIL 1,0
	DIRST			;DIRECTORY NAME
	 MOVE 1,3		;IF ERROR, RESTORE OUTPUT DESIGNATOR
	HRROI 2,[ASCIZ /, Account /]
	CALL LOGMES
	CALL LOGACC
LOGJ3:	MOVE 2,LOGJLN
	JUMPL 2,LOGJ1		;IF NO CTRL TTY (DETACHED JOB)
	HRROI 2,[ASCIZ /, TTY /]
	CALL LOGMES
	MOVE 2,LOGJLN
	MOVEI 3,^D8		;PRINT TTY NUMBER IN OCTAL
	CALL LGNOUT
LOGJ2:	HRROI 2,[ASCIZ /,
  at /]
	CALL LOGMES
	PUSH P,1		;SAVE DESIGNATOR
	CALL LGTAD		;DO LOCAL GTAD
	MOVE 2,1
	POP P,1			;RESTORE DESTINATION
	JUMPL 1,R
	SETZ 3,			;STANDARD DATE AND TIME
	CAIL 2,0
	ODTIM
	RET

LOGJ1:	HRROI 2,[ASCIZ /, Detached/]
	CALL LOGMES
	JRST LOGJ2

LOGACC:	HRROI T2,ACCTSR		;POINT TO STRING
	MOVEI T3,0		;TERMINATE ON NULL
	CAIL T1,0		;VALID PNTR
	SOUT			;YES - OUTPUT STRING
	RET			;RETURN

LOGMES:	SETZ 3,
	SOUT
	RET

LOG2NM:	SKIPA 3,[EXP NO%LFL!NO%ZRO+^D2B17+^D10] ;Decimal, two digits
LOGNUM:	MOVEI 3,^D10		;DECIMAL FOR TIMES, ETC.
LGNOUT:	NOUT
	 JFCL
	RET

LOGCR:	HRROI 2,[ASCIZ /
/]
	SETZ 3,
	SOUT
	RET

;PRINTS   [JOB N DETACHED BY NAME] TO TTY OF JOB BEING ATTACHED
; OR UNATTACHED.
;ACCEPTS:	1/JOB # OF JOB BEING UNATTACHED
;		2/LINE # OF JOB BEING UNATTACHED
;		3/DIR # OF USER UNATTACHING THE JOB
;		4/TTY # OF USER UNATTACHING THE JOB

DETMS1:	TRVAR <<MSGBUF,25>,JOB,LINE,DIRN,DTTYN,TMPPTR>
	MOVEM 1,JOB		;SAVE INPUTS
	MOVEM 2,LINE
	MOVEM 3,DIRN
	MOVEM 4,DTTYN		;SAVE TTY # OF DETACHER
	HRROI 1,MSGBUF		;START FILLING BUFFER
	CALL LOGCR		;CRLF
	HRROI 2,[ASCIZ/[Job /]
	CALL LOGMES
	HRRZ 2,JOB		;JOB # TO BE PRINTED
	CALL LOGNUM
	HRROI 2,[ASCIZ/ detached by /]
	CALL LOGMES
	MOVE 2,DIRN
	MOVEM 1,TMPPTR		;SAVE PLACE IN BUFFER IN CASE DIRST FAILS
	DIRST			;GET USER WHO'S UNATTACHING THE JOB
	ERJMP DIRFIX
DETMS2:	SKIPGE DTTYN		;IS DETACHER ON A TTY?
	JRST DETMS3		;NO
	HRROI 2,[ASCIZ/ on terminal /]
	CALL LOGMES
	MOVE 2,DTTYN		;Get the TTY number
	MOVEI 3,10		;OCTAL NUMBER
	CALL LGNOUT
DETMS3:	HRROI 2,[ASCIZ/]/]
	CALL LOGMES
	CALL LOGCR		;CLOSE WITH CRLF
	MOVEI 1,.TTDES		;MAKE A TTY DESIGNATOR
	ADD 1,LINE		;TTY LINE NUMBER
	HRROI 2,MSGBUF		;POINT TO NOW-COMPLETED MESSAGE
	TTMSG			;SEND IT OUT
	RET

;UNATTACHER NOT LOGGED IN

DIRFIX:	MOVE 1,TMPPTR		;RESTORE BUFFER POINTER
	HRROI 2,[ASCIZ/user/]
	CALL LOGMES		;PLACE PSEUDO-NAME IN BUFFER
	JRST DETMS2		;FINISH ASSEMBLING THE MESSAGE

;INFO JSYS'S

.GJINF::MCENT
	CALL GTCSCD		;GET CONNECTED STRUCTURE CODE,,DIRECTORY
	MOVE 2,1		;RETURN CONNECTED STR/DIR NUMBER
	MOVE 3,JOBNO
	HRRZ 1,JOBDIR(3)
	SKIPE 1			;IF NOT LOGGED IN, RETURN 0
	HRLI 1,USRLH		;TURN THIS INTO A 36 BIT USER NUMBER
	MOVE 4,CTRLTT
MR4:	UMOVEM 4,4
MR3:	UMOVEM 3,3
MR2:	UMOVEM 2,2
MR1:	UMOVEM 1,1
	JRST MRETN

.TIME::	MCENT
	MOVE 1,TODCLK		;TIME SINCE SYSTEM STARTED
	MOVEI 2,^D1000		;DIVISOR FOR SECONDS
	JRST MR2		;RETURN 2 AC'S

.RUNTM::MCENT
	NOSKED
	CALL UCLOCK		;UPDATE CLOCKS
	OKSKED
	CALL FLOCK		;LOCK THE FORK STRUCTURE
	XCTU [HRRZ 1,1]	;FORK HANDLE
	CAIN 1,-5		;WHOLE JOB?
	JRST RUNTM1		;YES
	CALL SETJFK
	CALL SETLF1
	MOVE 1,FKRT(1)		;FORK RUN TIME FROM PSB
	SETO 4,			;1001 Say that a PSB needs unmapping
	JRST RUNTM2

RUNTM1:	NOINT
	SETZ 4,			;1001 Say we didn't map anything
	MOVE 1,JOBNO
	MOVE 1,JOBRT(1)
RUNTM2:	MOVE 3,TODCLK		;CURRENT TIME
	SUB 3,CONSTO		;LESS TIME ON, FOR CONSOLE TIME USED
	MOVEI 2,^D1000		;MILLISECONDS
RETA3:	UMOVEM 1,1		;RETURN VALUES IN 1,2,3
	UMOVEM 2,2
	UMOVEM 3,3
	JUMPN 4,CLFRET		;NEED TO UNMAP THINGS?
	CALL FUNLK		;NO- JUST UNLOCK THE FORK STUCTURE
	JRST MRETN

.GTRPI::MCENT
	CALL FLOCK		;LOCK THE FORK STRUCTURE
	CALL SETLFK
	MOVE 2,USWPCT(1)
	MOVE 3,PTTIM(1)
	IDIVI 3,^D100		;RETURN MILLISEC, NOT HPTIM UNITS
	MOVE 1,UTRPCT(1)
	JRST RETA3

;3005 begin addition
;Get/set finger info (last login tty and date/time)
;Accepts in	1/ Dir # or -1 for logged-in directory
;	FINGR
;Returns +1:	2/Date/time of last login
;		3/TTY of last login
;If 1B0 of TTY is set, rest of word is host number, suitable for CVHST

.FINGR::MCENT
	SMRETN			;3007 NOP for now!
	CAME T1,[-1]		;Want login directory?
	 IFSKP.
	  MOVE T1,JOBNO		;Yes, get my job number
	  HRRZ T1,JOBDIR(T1)	;Convert to login dir number
	  CALL CNVDIR		;Be sure we get a good directory number
	 ENDIF.
	CALL SETDIR		;Get directory in question
	 RETBAD ()		;Pass along error if problem
	MOVE T1,DIRORA		;Get address of directory origin
	LOAD T2,DRDAT,(T1)	;Read date of last login
	UMOVEM T2,2		;Give to user
	LOAD T3,DRTTY,(T1)	;Read last login TTY
	UMOVEM T3,3		;Give to user
	CALL USTDIR		;Unlock directory
	SMRETN			;OK, return

;3005 End addition
	
;GET DIRECTORY ALLOCATION
;ACCEPTS IN 1/	DIR # OR -1 FOR CONNECTED DIR
;	GTDAL
;RETURNS +1:	1/	LOGGED IN QUOTA
;		2/	CURRENT ALLOCATION
;		3/	LOGGED OUT QUOTA

.GTDAL::MCENT
	UMOVE T1,1		;GET DIR #
	CAMN T1,[-1]		;-1 MEANS CONNECTED DIRECTORY
	CALL GTCSCD		;GET CONNECTED DIR NUMBER
	CALL IGTDAL		;USE INTERNAL ROUTINE
	 ITERR()		;FAILED
	JRST MR3		;RETURN 1, 2 AND 3

;INTERNAL GTDAL, 1/ DIRECTORY #

IGTDAL::STKVAR <IGTDN>
	MOVEM T1,IGTDN		;SAVE DIR #
	CALL SETDIR		;MAP THE DIRECTORY IN
	 RETBAD ()		;FAILED
	HRRZ T1,IGTDN		;DIRECTORY NUMBER
	LOAD T2,CURSTR		;STRUCTURE NUMBER
	CALL GETCAL		;GET CURRENT ALLOCATION
	 JRST [	MOVE T3,DIRORA	;DIR NOT OPENED
		LOAD T1,DRLIQ,(T3) ;LOGGED IN QUOTA
		LOAD T2,DRDCA,(T3) ;CURRENT ALLOCATION
		LOAD T3,DRLOQ,(T3) ;LOGGED OUT QUOTA
		JRST IGTDX]	;EXIT
	MOVE T3,DIRORA		;GET BASE ADR OF MAPPED DIR
	MOVN T2,T1		;NEGATE PAGES LEFT
	LOAD T1,DRLIQ,(T3)	;GET LOGGED IN QUOTA
	ADD T2,T1		;ACTUAL USED
	LOAD T3,DRLOQ,(T3)	;GET LOGGED OUT QUOTA
IGTDX:	CALL USTDIR		;UNLOCK THE DIR
	RETSKP			;GOOD RETURN

;HIGH PRECISION TIME JSYS
;MADE RESIDENT FOR SPEED

	RESCD

.HPTIM::MCENT
	CAIL 1,0		;CHECK RANGE OF ARG
	CAIL 1,NHPTIM
	RETERR(HPTX1)		;UNDEFINED CLOCK
	JRST HPTTAB(1)

HPTTAB:	JRST HPT0		;ELAPSED TIME
	JRST HPT1		;FORK RUNTIME
NHPTIM==.-HPTTAB

HPT0:	NOSKED
	JSP 4,MTIME		;READ TODCLK IN 1E-5 SECOND UNITS
	OKSKED
	UMOVEM 1,1
	SMRETN

HPT1:	NOSKED
	CALL UCLOCK		;UPDATE USER RUNTIMES
	OKSKED
	MOVE 1,FKRT		;GET MILLISECOND PART
	IMULI 1,NTMS		;CONVERT TO HP UNITS
	ADD 1,RUNT2		;INCLUDE FRACTION OF MILLISECOND
	UMOVEM 1,1
	SMRETN

	SWAPCD

;6 BEGIN ADDITION FOR GTBLT JSYS
;BLT A PORTION OF A TABLE TO USER SPACE
;
;   T1/	START INDEX,,TABLE NUMBER
;   T2/	WORD COUNT,,USER DESTINATION ADDRESS
;	IF LH(T1) = -1 THEN IGNORE LH(T2) AND TRANSFER WHOLE TABLE.
;	GTBLT
; RETURNS:
;   +1:	FAILURE, ERROR CODE IN 1
;	   GTABX1 IF BAD TABLE NUMBER
;	   GTABX2 IF TOO MANY WORDS REQUESTED
;	   GTABX3 IF NOT PROPER CAPABILITY
;   +2:	SUCCESS
;

.GTBLT::MCENT				;SLOW JSYS ENTRY
	MOVSI T3,(SC%GTB)
	TDNN T3,CAPMSK
	 RETERR (GTABX3)		;IF NOT PROPER CAPABILITY
	HLRE T4,T1			;GET START INDEX OR -1
	HRRZ T3,T1			;GET TABLE NUMBER
	CAIL T3,GTBSIZ	
	 RETERR	(GTABX1)		;IF BAD TABLE NUMBER
	HLRZ T1,GTTAB(T3)		;GET TABLE SIZE
	HRRZ Q1,GTGET(T3)
	CAIE Q1,GTGETR
	 JRST GTBLT4			;IF TABLE WITH SPECIAL ACCESS ROUTINE
	JUMPL T4,GTBLT3			;IF WHOLE TABLE
	HLRZ Q1,T2			;GET WORD COUNT
	JUMPE Q1,GTBLT2			;IF ZERO WORDS REQUESTED, RETURN
	ADDI Q1,(T4)			
	CAILE Q1,(T1)	
	 RETERR	(GTABX2)		;IF COUNT + INDEX .GT. TABLE SIZE
 	ADD T4,GTTAB(T3)		;FORM LOC(TABLE ORIGIN[INDEX]
	HLRZ Q1,T2			;SET LWA+1 OF USER AREA FOR BLT
	ADDI Q1,(T2)			; = LOC(USER ADDRESS[COUNT])
	HRL T2,T4			;SET SOURCE START ADDRESS FOR BLT
GTBLT1:	XBLTMU [BLT T2,-1(Q1)]	 	;TRANSFER THE TABLE PIECE
GTBLT2:	SMRETN				;SUCCESS RETURN

;TRANSFER WHOLE TABLE.

GTBLT3:	HRL	T2,GTTAB(T3)		;SET SOURCE START ADDRESS FOR BLT
	ADDI	T1,(T2)			;SET LWA+1 OF USER AREA FOR BLT
	MOVEI	Q1,(T1)			;  = LOC(USER ADDRESS[TABLE SIZE])
	JRST	GTBLT1			;TRANSFER THE WHOLE TABLE

;TRANSFER TABLE WITH A SPECIAL ACCESS ROUTINE.

GTBLT4:	JUMPGE	T4,GTBLT5		;IF NOT WHOLE TABLE
	HRL	T2,T1			;SET COUNT = TABLE SIZE
	HRLI	T1,0			;SET INDEX = 0
	SETZ	T4,			;  (IN BOTH PLACES)
GTBLT5:	HLRZ	Q1,T2			;GET COUNT
	JUMPE	Q1,GTBLT7		;IF ZERO WORDS REQUESTED, RETURN
	ADDI	Q1,(T4)
	CAILE	Q1,(T1)		
	 RETERR	(GTABX2)		;IF COUNT + INDEX .GT. TABLE SIZE
	HRL	Q1,T3			;Q1 = TABLE NUMBER,,USER ADDRESS
	HRR	Q1,T2
	HLLZ	Q2,T2			;Q2 = -COUNT,,INDEX
	MOVNS	Q2
	HRR	Q2,T4
GTBLT6:	HLRZ	T3,Q1			;SET TABLE NUMBER FOR ACCESS ROUTINE
	HRRZ	T2,Q2			;SET INDEX FOR ACCESS ROUTINE
	XCT	GTGET(T3)		;GET TABLE WORD
	UMOVEM	T1,(Q1)			;SEND WORD TO USER
	HRRI	Q1,1(Q1)		;ADVANCE USER ADDRESS
	AOBJN	Q2,GTBLT6		;ADVANCE INDEX & IF --COUNT .GT. 0
GTBLT7:	SMRETN				;SUCCESS RETURN

;6 END ADDITION

;GET NUMBER OF TABLE AND FIRST WORD GIVEN SIXBIT SYMBOL
; 1/ SIXBIT 'TABLENAME'
;	SYSGT
; RETURN +1 ALWAYS,
;  1/ -LENGTH,,TABLENUMBER  OR 0

.SYSGT::MCENT
	MOVSI 4,-GTBSIZ
	CAMN 1,SYMTAB(4)
	JRST SYSGT1
	AOBJN 4,.-2
	XCTU [SETZM 2]		;NOT FOUND RETURN 0
	JRST MRETN

SYSGT1:	HLRZ 2,GTTAB(4)		;SIZE
	MOVN 2,2		;NEGATE IT
	HRLI 4,0(2)		;COMBINE WITH TABLE NUMBER
	UMOVEM 4,2		;GIVE TO USER
	HRRZ T3,T4		;GET TABLE NUMBER
	SETZ T2,		;GET OFFSET ZERO
	XCT GTGET(T3)		;GO GET THE FIRST ENTRY
	UMOVEM 1,1		;GIVE FIRST WORD TO USER
	JRST MRETN

;GET TABLE ENTRY
; 1/ INDEX,,TABLENUMBER
;	GETAB
; RETURN +1: ERROR
; RETURN +2: 1/ DATA

.GETAB::MCENT
	MOVSI 2,(1B1)
	TDNN 2,CAPMSK		;GETAB CAPABILITY EXISTS?
	RETERR(GTABX3)		;NO
	HLRZ 2,1		;INDEX OR -1
	MOVEI 3,0(1)		;TABLE NUMBER
	CAIL 3,GTBSIZ		;LEGAL NUMBER?
	RETERR(GTABX1)		;NO
	HLRZ 1,GTTAB(3)		;GET SIZE OF TABLE
	CAIN 2,-1		;INDEX OF -1?
	JRST RETN1		;YES, RETURN NEG OF TABLE SIZE
	CAIL 2,0(1)		;INDEX WITHIN BOUNDS?
	RETERR(GTABX2)
	XCT GTGET(T3)		;GET WORD
	UMOVEM 1,1		;RETURN IT TO USER
	SMRETN

RETN1:	XCTU [MOVNM 1,1]	;RETURN NEG OF LENGTH
	SMRETN

;TABLES FOR GTTAB
;ALL TABLES DEFINED WITH FOLLOWING MACRO WHICH TAKES NAME OF
;ANOTHER MACRO TO CALL FOR EACH TABLE.
;*NOTE* TABLE INDICES ARE DEFINED IN MONSYM - ORDER AND PLACE
;MUST BE PRESERVED IF TABLES ARE ADDED OR DELETED.  PLACE
;MAY BE HELD BY CALL WITH NO ARGS.

;THE ARGUMENT TO GTABS IS A MACRO TO BE CALLED FOR EACH TABLE.
;FIVE ARGUMENTS ARE GIVEN, SIXBIT TABLE NAME, LOCATION, LENGTH, ROUTINE,
;SYMBOLIC VALUE FOR TABLE NUMBER (FROM MONSYM)

DEFINE GTABS (XXX)<
	XXX JOBTTY,JOBPT,NJOBS
	XXX JOBRT,JOBRT,NJOBS
	XXX TICKPS,[^D1000],1
	XXX			;;FORMERLY JOBDIR
	XXX TTYJOB,0,NLINES,GTBTTF
	XXX NCPGS,TOTRC,1
	XXX DEVNAM,DEVNAM,NDEV
	XXX DEVCHR,DEVCHR,NDEV
	XXX DEVUNT,DEVUNT,NDEV
	XXX DSKERR,DSKRCE,NDSKEW
	XXX DRMERR,DRMCFE,NDRMEW
	XXX SYSVER,SVN,NSVNT
	XXX SYSTAT,SKDTM0,NSTAT
	XXX QTIMES,QSUM,NQUEUE
	XXX JOBNAM,JOBNAM,NJOBS
	XXX SNAMES,SNAMES,NNAMES
	XXX STIMES,STIMES,NNAMES
	XXX SPFLTS,SPFLTS,NNAMES
	XXX SSIZE,SSIZE,NNAMES
	XXX SNBLKS,SNBLKS,NNAMES
	XXX DBUGSW,DBUGSW,2
	XXX LOGDES,LOGDES,2
	XXX PTYPAR,0,1,GTBPTY
	XXX SYMTAB,SYMTAB,GTBSIZ
	XXX DWNTIM,HSYST1,NHSYST
	XXX JOBPNM,JOBPNM,NJOBS
	XXX BLDTD,SYSTAD,1
	XXX			;;FORMERLY LSTDRN
	XXX APRID,APRSER,1
	XXX HQLAV,HQLAV,NRJAVS
	XXX LQLAV,LQLAV,NRJAVS

IFE MNET,<
	XXX NETRDY,IMPRDY,IMPGTN	;ARPANET
>		;; Table is table only on non-multinet systems
IFN MNET,<
	XXX NETRDY,0,10,GNTRDY
>
;THE FOLLOWING TWO TABLES ARE LEFT FOR COMPATABILITY REASONS ONLY
;THEY RETURN HOST STATUS BY THE OLD-STYLE 8 BIT HOST NUMBER
	XXX IMPHRT,0,IMPLBT,GTBHRT	;ARPANET
	XXX HSTSTS,0,NHSTST,GTBHSS	;ARPANET
IFE MNET,<
	XXX HSTNAM,HSTNAM,NHSTN		;ARPANET
>
IFN MNET,<
	XXX HSTNAM,0,NHSTN,GHSTNM
>
;SIMULATE GHOSTN AND NETAWD
	XXX HOSTN,0,NHOSTS,GHOSTN	;ARPANET
IFE MNET,<
	XXX NETLSK,LSKT,NSKT		;ARPANET
	XXX NETFSK,FSKT,NSKT		;ARPANET
>
IFN MNET,<
	XXX NETLSK,0,NSKT,GNTLSK
	XXX GNTFSK,0,NSKT,GNTFSK
>
	XXX NETAWD,0,NSKT,GNTAWD	;ARPANET
IFE MNET,<
	XXX NETBAL,NETBAL,NSKT		;ARPANET
	XXX NETSTS,NETSTS,NSKT		;ARPANET
	XXX NETBUF,NETBUF,NSKT		;ARPANET
	XXX NETBTC,NETBTC,NSKT		;ARPANET
	XXX IMPLT1,IMPLT1,IMPNLK,,.IMPL1 ;ARPANET
	XXX IMPLT2,IMPLT2,IMPNLK,,.IMPL2 ;ARPANET
	XXX IMPLT3,IMPLT3,IMPNLK,,.IMPL3 ;ARPANET
	XXX IMPLT4,IMPLT4,IMPNLK,,.IMPL4 ;ARPANET
>
IFN MNET,<
	XXX NETBAL,0,NSKT,GNTBAL
	XXX NETSTS,0,NSKT,GNTSTS
	XXX NETBUF,0,NSKT,GNTBUF
	XXX NETBTC,0,NSKT,GNTBTC
	XXX IMPLT1,0,IMPNLK,GIMLT1,.IMPL1
	XXX IMPLT2,0,IMPNLK,GIMLT2,.IMPL2
	XXX IMPLT3,0,IMPNLK,GIMLT3,.IMPL3
	XXX IMPLT4,0,IMPNLK,GIMLT4,.IMPL4
>
	XXX LHOSTN,NOHOST,2		;ARPA HOST NUMBER, NVT COUNTER
	XXX JBONT,JOBONT,NJOBS		;OWNING JOB
	XXX NSWPGS,NSWPGS,1		;DEFAULT SWAPPING PAGES
	XXX SCOUNT,SCOUNT,NNAMES	;COUNT OF SETSN'S S FOR SUBSYSTEM
	XXX FKJOB,FKJOB,NFKS		;7 
	XXX FKPT,FKPT,NFKS		;7 
	XXX FKNR,FKNR,NFKS		;7 
	XXX FKWSP,FKWSP,NFKS		;7 
	XXX FORKX,FORKX,1		;7 
	XXX SYSFK,SYSFK,NUFKS		;7 
	XXX FKPTRS,FKPTRS,NUFKS		;7 
	XXX FKTAB,FKTAB,NLFKS/2		;7 
	XXX CHSTAT,CHAON,CHASBS		;1000
	XXX CHPMXT,CHPMXT,1		;1000
IFN MNET,<
	XXX NETHST,0,NSKT,GNTHST	;1017 Harder to find in distant section
>
IFE MNET,<
	XXX NETHST,NETHST,NSKT		;1017 On non-mnet systems...
>
	XXX MYCHAD,MYCHAD,1		;3003
  >

;ASSEMBLE SYMBOL TABLE

DEFINE SYMT (NAM,LOC,SIZ,ROUT,VALUE)<
   IFB <NAM>,<0>		;;LEAVE 0 IF PLACE RESERVED
   IFNB <NAM>,<
      IFB <VALUE>,<		;;IF VALUE WAS NOT SPECIFIED
	..X==.'NAM		;;GET NAME FROM MONSYM
.'NAM::!SIXBIT /NAM/>		;;CHECK TABLE INDEX, ASSEMBLE SIXBIT
      IFNB <VALUE>,<		;;IF VALUE WAS SPECIFIED
	..X==VALUE		;;GET NAME FROM MONSYM
VALUE::!SIXBIT /NAM/>>>		;;CHECK TABLE INDEX, ASSEMBLE SIXBIT

SYMTAB::!PHASE 0			;;MAKE TAGS BE RELATIVE TO 0
	GTABS SYMT		;;ASSEMBLE SYMTAB, CHECK INDEX MNEMONICS
GTBSIZ::DEPHASE

;ASSEMBLE POINTERS AND SIZES

DEFINE LOCT (NAM,LOC,SIZ,ROUT,VALUE)<
   IFB <NAM>,<0>		;;LEAVE 0 IF PLACE RESERVED
   IFNB <NAM>,<
	XWD SIZ,LOC>>

GTTAB::	GTABS LOCT

;DEFINE PROCESSING ROUTINE

DEFINE ACTR (NAM,LOC,SIZ,ROUT,VALUE)<
   IFB <NAM>, <SETZM T1>	;;NULL TABLE GIVES NULL ANSWER
   IFNB <NAM>,< IFB <ROUT>, <CALL GTGETR> ;;DFAULT PROCESSOR
   IFNB <ROUT>, <CALL ROUT> 	;;DO SPECIFIED PROCESS
        >
   >

GTGET:	GTABS ACTR		;DEFINE PROCESSING TABLES

;GENERAL GETTAB ROUTINE.
;	3/ TABLE NUMBER
;	2/ TABLE OFFSET
;RETURNS: +1 WITH T1/ ANSWER

GTGETR:	ADD T2,GTTAB(T3)	;GET TABLE BASE
	HRRZS T2		;CLEAR INDEX
	MOVE T1,0(T2)		;FETCH TABLE ENTRY
	RET			;AND DONE

;SUBSYSTEM STATISTICS LOGIC
; 1/ SIXBIT NAME OF SYSTEM PROGRAM BEING RUN OR (PRIV)
; 2/ SIXBIT NAME OF PROGRAM
;	SETSN
; RETURN +1: ALWAYS, NAME SET IN STATISTICS TABLE

.SETSN::MCENT
	NOINT
	MOVE 3,JOBNO
	MOVEM 2,JOBPNM(3)	;SET JOB PROGRAM NAME
	AOSE SNMLCK		;LOCK TABLE
	CBLK1			;OR WAIT TILL LOCKABLE
	HRLZ 3,SNMPT		;NEG COUNT OF ENTRIES
	CAMN 1,SNAMES(3)	;DESIRED NAME?
	JRST SNM1		;YES
	AOBJN 3,.-2		;NO, LOOKED AT ALL?
	MOVEI 3,0(3)
	CAIL 3,NNAMES-1		;TABLE NOW FULL?
	SKIPA 1,[SIXBIT /.OTHER/] ;YES, USE CATCH-ALL NAME
	JRST [ SETZM SCOUNT(3)	;ZERO THE COUNT
	       SOS SNMPT	;UPDATE POINTER
	       JRST .+1]	;CONTINUE WITH FLOW
	MOVEM 1,SNAMES(3)	;ADD NAME TO TABLE
SNM1:	MOVE 2,JOBNO
	HRRM 3,JOBNAM(2)	;PUT INDEX IN JOB TABLE
	AOS SCOUNT(3)		;BUMP THE SETSN COUNT
	SETOM SNMLCK		;UNLOCK TABLE
	OKINT
	SMRETN

NR SNMPT,1			;NEG COUNT OF ENTRIES IN SNAMES
NR SNMLCK,1			;LOCK FOR SNAMES TABLE

;PROGRAM NAME LOGIC

;SET NAME
; 1/ SIXBIT NAME OF PROGRAM
;	SETNM
; RETURN +1: ALWAYS, NAME SET AS PROGRAM NAME FOR JOB

.SETNM::MCENT
	MOVE 3,JOBNO		;GET THIS JOB NUMBER
	MOVEM 1,JOBPNM(3)	;SET THE NAME
	JRST MRETN

;GET NAME
;	GETNM
; RETURN +1: ALWAYS, 1/ SIXBIT NAME OF PROGRAM

.GETNM::MCENT
	MOVE 1,JOBNO
	MOVE 1,JOBPNM(1)
	JRST MR1		;RETURN 1 AC

;GETNAM -- SUBROUTINE TO CONSTRUCT VERSION AND SYSTEM NAME FROM TEXT
; IN THE FILE SYSTEM:MONNAM.TXT, OR IF THE FILE DOES NOT EXIST,
; TO USE THE DEFAULT TEXT ASSEMBLED INTO THE MONITOR IN THE BLOCK
; LABLED TSVN.  THE FORMAT OF THE RESULTING  TEXT IS:

; V D.DD.DD <TEXT>

; WHERE THE FIRST SEVERAL CHARACTERS IDENTIFY THE MONITOR VERSION AND ALWAYS
; COME FROM THE PREASSEMBLED STRING; AND THE <TEXT> COMES EITHER FROM
; THE FILE OR FROM THE PREASSEMBLED STRING.  THE ENTIRE STRING MAY
; BE UP TO 132(10) CHARACTERS LONG, SO <TEXT> MAY BE 122(10),
; OR 172(8) CHARACTERS LONG.  <TEXT> IN THE FILE SHOULD BE TERMINATED BY
; EOL.


GETNAM:	STKVAR <A1>		;RESERVE SPACE FOR ONE TEMP
	MOVE T1,[POINT 7,SVN]	;BYTE POINTER TO DESTINATION
	MOVEM T1,A1		;SAVE UPDATED PTR. TO DEST. STRING
	MOVX T1,GJ%SHT!GJ%OLD	;FLAG FOR SHORT GTJFN CALL AND OLD FILE ONLY
	HRROI T2,[ASCIZ /SYSTEM:MONNAM.TXT/] ;IMPLICIT STRING PTR TO FILE NAME
	GTJFN			;IS THERE A FILE?
	 JRST GETNA1		;NO FILE - DOESN'T MATTER WHY
	MOVX T2,<OF%RD+FLD(7,OF%BSZ)> ;FILE EXISTS, SET UP OPENF CALL
	OPENF			; ..
	 JRST GETNA1		;UNSUCCESFUL FOR ANY REASON, USE
				; DEFAULT STRING
	MOVEI T3,<NSVNT-VTSVNT>*5-1	;MAX. # OF BYTES WE CAN MOVE
	MOVE T4,A1		;RECALL BYTE PTR TO BUFFER
GETNA2:	BIN			;GET NEXT CHARACTER FROM FILE
	CAIE T2,.CHCRT		;IS IT A CARRIAGE RETURN?
	CAIN T2,.CHLFD		;NO, IS IT A LINE FEED?
	JRST GETNA3		;A CR OR A LF WAS ENCOUNTERED
	JUMPE T2,GETNA3		;JUMP ALSO IF IT'S A NULL
	IDPB T2,T4		;IT'S A GOOD CHARACTER, PUT INTO BUFFER
	SOJG T3,GETNA2		;JUMP IF WE HAVN'T EXHAUSTED ALL BUT
				; ONE BYTE POSITION IN BUFFER.
;MANUAL MERGE OF 1B CHANGES
GETNA3:	CLOSF			;YES, CLOSE FILE, RELEASE JFN
	 JFCL			;IGNORE FAILURE
	MOVE T1,T4		;GET STRING POINTER AGAIN
	HRROI T2,VTSVN		;IMPLICIT STRING POINTER TO VERSION
	SETZ T3,		;STOP ON A NULL
	SOUT			;MOVE PREASSEMBLED VERSION TO BUFFER
	RET			;EXIT

GETNA1:	HRROI T1,SVN		;IMPLICIT BYTE POINTER OF DESTINATION
	HRROI T2,TSVN		;IMPLICIT BYTE POINTER TO PREASSEMBLED
				; MONITOR NAME
GETNA5:	SETZ T3,		;SPECIFY TERMINATION ON A NULL
	SOUT			;MOVE PREASSEMBLED STRING TO BUFFER
				; THE MOVE INCLUDED A TERMINATING NULL
	RET			; SO -- WE'RE DONE


;GET JOB INFORMATION
; 1/ JOB #, OR -1 FOR SELF, OR TTY # + 400000
; 2/ -N,,USER ADR
; 3/ FIRST ENTRY DESIRED
;	GETJI
; RETURN +1: FAILURE
; RETURN +2: SUCCESS, ENTRIES STORED IN USER ARRAY
;REQUIRES GETAB CAPABILITY IF JOB OTHER THAN SELF

.GETJI::MCENT
	UMOVE P2,3		;GET NUMBER OF FIRST ENTRY DESIRED
	HRL P2,P2		;DUPLICATE IN BOTH HAVLES
	JUMPL P2,[RETERR (GTJIX1)] ;INSURE NOT NEGATIVE
	ADD P2,[-NGTJIT,,0]	;SETUP AOBJN PTR TO FIRST ENTRY
	JUMPGE P2,[RETERR (GTJIX1)] ;ALREADY BEYOND END OF TABLE
	UMOVE P3,2		;GET USER 'S ADR POINTER
	CAMN 1,[-1]		;SELF?
	JRST [	MOVE 1,JOBNO	;YES, GET THIS JOB NUMBER
		JRST GETJI5]	;SKIP CAPABILITY CHECK
	MOVX 2,SC%GTB
	TDNN 2,CAPMSK		;HAS GETAB CAPABILITY?
	RETERR (GTABX3)		;NO
	TRZE 1,400000		;TTY DESIGNATOR?
	JRST [	CAIL 1,0	;YES, LEGAL LINE NUMBER?
		CAIL 1,NLINES
		RETERR (GTJIX2)	;NO
		MOVE T2,T1	;T2/ LINE NUMBER
		CALL GTCJOB	;GET OWNING JOB NUMBER
	 	 JRST GETJI6	;JUMP IF NOT ACTIVE
		CAIN T3,-1	;IS THERE AN OWNING JOB?
		JRST GETJI6	;NO.
		MOVE T2,T3	;YES. PRESERVE JOB NUMBER
		HLRZ T3,JOBPT(T2) ;GET CONTROLLING TTY FOR JOB
		CAME 3,1	;SAME AS GIVEN TTY?
		JRST GETJI1	;NO, TTY IS ASSIGNED NOT CONTROLLING
		MOVE 1,2	;SETUP JOB NUMBER
		JRST .+1]	;CONTINUE WITH JOB NUMBER
	CAIL 1,0		;LEGAL JOB NUMBER?
	CAIL 1,NJOBS
	RETERR (GTJIX3)		;NO
GETJI5:	NOSKED			;DON'T ALLOW JOB TO LOG OUT
	SKIPGE JOBRT(T1)	;JOB EXISTS?
	RETERR (GTJIX4,<OKSKED>) ;NO. GIVE APPROPRIATE ERROR
	MOVEM 1,P1		;SAVE JOB NUMBER
	CALL SETJSB		;MAP IN JSB OF OBJECT JOB
	OKSKED			;OK TO ALLOW SCHEDULING. JOB CAN'T LOGOUT
				; SINCE ITS JSB IS MAPPED
	MOVEM T1,P4		;SAVE JSB OFFSET
GETJI2:	XCT GETJIT(P2)		;GET ITEM
	 UMOVEM 1,0(P3)		;GIVE IT TO USER (ROUTINES THAT SKIP HAVE ALREADY DONE THIS)
	AOBJP P3,GETJI3		;COUNT USER'S COUNT AND ADR
	AOBJN P2,GETJI2		;COUNT OUR COUNT AND ADR
GETJI3:	CALL CLRJSB		;UNMAP JSB OF OBJECT JOB
GETJIX:	UMOVEM P3,2		;UPDATE USERS PTR
	SMRETN

;GETJI...
;HERE IF TTY GIVEN AND NO CONTROLLING JOB
;GETJI6 - NO JOB OWNS THIS TERMINAL; GETJI1 - A JOB OWNS THIS TERMINAL
;BUT IT IS NOT THE JOB'S CONTROLLING TERMINAL

GETJI6:	SETOM T2		;INDICATE NO OWNING JOB
	SKIPA
GETJI1:	TLO 2,(1B1)		;SAY ASSIGNED
GETJI4:	XCTU [SKIPE 3]		;DOES USER WANT FIRST ENTRY?
	JRST GETJIX		;NO, NOTHING TO DO
	UMOVEM 2,0(P3)		;YES, STORE IT
	AOBJN P3,.+1		;UPDATE HIS POINTER
	JRST GETJIX		;RETURN

;TABLE OF GETJI ITEMS - WORD IS EXECUTED TO GET ITEM IN AC1

GETJIT:	MOVE 1,P1		;JOB NUMBER
	HLRE 1,JOBPT(P1)	;TTY NUMBER OR -1 IF DETACHED
	CALL GETSN5		;GET LOGIN DIRECTORY NUMBER
	CALL GETSN4		;GET CONNECTED STRUCTURE,,DIRECTORY
	CALL GETSN1		;SUBSYSTEM NAME
	MOVE 1,JOBPNM(P1)	;PROGRAM NAME
	MOVE 1,JOBRT(P1)	;RUN TIME
	CALL GETSN3		;JOB NUMBER OF OWNER OF PTY IF ANY
	CALL GETRTL		;GET RUNTIME LIMIT OF JOB
	CALL GETBB		;GET BATCH BIT
	CALL GETJID		;GET DENSITY
	LOAD T1,JSMTP,(P4)	;GET MAGTAPE PARITY DEFAULT
	CALL GETJIM		;GET MAGTAPE DATA MODE
	CALL GETJRS		;GET MAGTAPE RECORD SIZE
	LOAD T1,JSDFS,(P4)	;GET DEFERRED SPOOLING BIT
	CALL GETSN6		;GET THE LOGGED IN DIRECTORY NUMBER
	CALL GETJSR		;GET SESSION REMARK
	MOVE T1,LSTLGN(P4)	;PICK UP LAST LOGIN D&T
	MOVE T1,JSSRTM(P4)	;(.JISRT) Get session start runtime
	MOVE T1,JSSCTM(P4)	;(.JISCT) Get SESsion start console time
	CALL GETT20		;GET TOPS20 COMMAND LEVEL FLAG
	MOVE T1,SRTTIM(P4)	;GET TIME JOB WAS INITIALIZED
	MOVE T1,BATSTF(P4)	;GET BATCH STREAM AND FLAGS WORD
	CALL GETLL		;GET LOGICAL LOCATION
NGTJIT==.-GETJIT

;ACTION ROUTINES FOR ITEMS NOT AVAILABLE IN SINGLE MOVE

;GET CONNECTED STRUCTURE,,DIRECTORY

;GET CONNECTED STRUCTURE,,DIRECTORY

GETSN4:	MOVE T1,P4		;T1/OFFSET FOR ADDRESSING JSB
	CALL GTOJCD		;GET CONNECTED STRUCTURE CODE,,DIRECTORY
	RET

;GET LOGGED DIR NUMBER

GETSN5:	HRRZ T1,JOBDIR(P1)	;GET DIR NUMBER
	SKIPE T1		;IF NOT LOGGED IN, RETURN 0
	HRLI T1,USRLH		;MAKE IT BE A 36 BIT USER NUMBER
	RET

;GET -1 OR 0 FOR TOPS20 COMMAND LEVEL OR USER LEVEL

GETT20:	LOAD T1,JBT20,(P4)	;GET TOPS20 BIT
	MOVN T1,T1		;BIT ON => -1 (AT TOPS20 COMMAND LEVEL), BIT OFF => 0 (NOT AT T20)
	RET

;GET THE LOGGED IN DIRECTORY NUMBER

GETSN6:	MOVEI T1,PSNUM		;DIR IS ON PUBLIC STR
	CALL STRCNV		;CONVERT IT
	 RETERR (,<CALL CLRJSB>)
	HRLZS T1		;GET UNIQUE CODE IN THE LEFT HALF
	HRR T1,JOBDIR(P1)	;GET THE DIRECTORY NUMBER
	RET			;AND RETURN

;GET SUBSYSTEM NAME

GETSN1:	HRRZ 1,JOBNAM(P1)	;GET STATISTICS INDEX
	MOVE 1,SNAMES(1)	;GET NAME
	RET

;GET JOB NUMBER OF OWNER OF PTY

GETSN3:	HLRE 1,JOBPT(P1)	;GET CONTROLLING TTY
	JUMPL 1,RETO		;RETURN -1 IF DETACHED
	CALL PTYGFK		;GET FORK WHICH OWNS PTY
	 JRST RETO		;NO PTY, RETURN -1
	MOVEM 1,FX
	LOAD 1,FKJOBN		;GET JOB NUMBER WHICH OWNS FORK
	RET


;GET BATCH BIT

GETBB:	HLRE T1,JOBPT(P1)	;GET CONTROLING TTY
	JUMPL T1,RETZ		;IF NONE, JOB NOT CONTROLLED BY BATCH
	CALL PTYGBB		;GET BATCH BIT
	 JRST RETZ		;NOT A PTY
	RET			;ANSWER IS IN T1


;GET MAGTAPE DENSITY

GETJID:	LOAD T1,JSMTD,(P4)	;GET DEFAULT DENSITY
	SKIPN T1		;USING SYSTEM DEFAULT?
	MOVEI T1,MTDFDN		;YES
	RET


;GET MAGTAPE DATA MODE

GETJIM:	LOAD T1,JSMTM,(P4)	;GET DEFAULT DATA MODE
	SKIPN T1		;USING SYSTEM DEFAULT
	MOVEI T1,MTDFDM		;YES
	RET


;GET MAGTAPE RECORD SIZE

GETJRS:	LOAD T1,JSMTR,(P4)	;GET RECORD SIZE
	SKIPN T1		;USING SYSTEM DEFAULT?
	MOVEI T1,MTDFRS		;YES
	RET

;GET RUNTIME LIMIT FOR THIS JOB

GETRTL:	LOAD T1,JOBRTP,(P1)	;GET POINTER TO RUNTIME LIMIT BLK
	JUMPE T1,R		;WAS NONE
	LOAD T1,TIMTIM,(T1)	;GET ACTUAL LIMIT
	RET

;GET SESSION REMARK

GETJSR:	MOVEI T2,JSSRM(P4)	;ADDRESS OF REMARK IN JSB
GU1:	UMOVE T1,0(P3)		;PLACE WHERE USER WANTS REMARK PUT
	HRRZ T3,P3		;GET USER ADDRESS FOR UPDATED POINTER
	CALL CPYTU1		;COPY REMARK TO USER SPACE
	RETSKP			;SKIP SO POINTER DOESN'T GET UPDATED TWICE!

;GET LOGICAL LOCATION

GETLL:	MOVEI B,LLSR-1(P4)	;ADDRESS OF LOCATION STRING (MINUS ONE FOR CPYTU1)
	CALLRET GU1		;USE STANDARD MAGIC FOR FINISHING UP

;CONVERT ASCIZ PTR TO SIXBIT WORD
; 1/ BYTE PTR TO ASCIZ STRING
;	CALL ASZSIX
; RETURN +1: FAILURE, ILLEGAL CHARACTER
; RETURN +2: 1/ WORD OF SIXBIT
;  ASCIZ STRING LONGER THAN 6 CHARACTERS IS TRUNCATED

ASZSIX::STKVAR <WSIX>		;DECLARE LOCAL VAR FOR SIXBIT WORD
	SETZM WSIX		;CLEAR SIXBIT WORD
	MOVE 3,[POINT 6,WSIX]
	MOVEI 4,6		;6 CHARS MAX
SNM3:	XCTBU [ILDB 2,1]	;GET CHAR FROM USER
	JUMPE 2,SNM4		;END OF STRING IF NULL
	CAIL 2,40		;LEGAL CHARACTER?
	CAIL 2,140
	RET			;NO, DO +1 RETURN
	SUBI 2,40		;CONVERT TO SIXBIT
	IDPB 2,3		;BUILD SIXBIT
	SOJG 4,SNM3		;COUNT CHARS
SNM4:	MOVE 1,WSIX		;GET SIXBIT
	RETSKP

;LIGHTS, SWITCHES, AND OTHER MAINTENANCE STUFF

.SWTCH:: MCENT
	MOVE 2,CAPENB
	TXNN 2,SC%WHL+SC%OPR+SC%MNT ;SUFFICIENT CAPABILITIES?
	JRST CAPXR		;NO
	SETZ T1,		;INIT ANSWER
	UMOVEM 1,1
	SMRETN

.LITES::MCENT
	MOVE 2,CAPENB
	TRNN 2,SC%WHL+SC%OPR+SC%MNT ;REQUIRES STATUS
	JRST CAPXR
	SMRETN

.USRIO::MCENT
	MOVEI 1,SC%WHL+SC%OPR+SC%MNT
	TDNN 1,CAPENB		;REQUIRES STATUS
CAPXR:	RETERR(CAPX2)		;RETURN BAD, USER LACKS CAPABILITIES
	MOVSI 1,(1B6)		;USER IO BIT
	IORM 1,0(P)		;PUT IT ON
	SMRETN

;PEEK - AC1:  N,,MONLOC
;       AC2:     USRLOC

.PEEK::	MCENT
	MOVEI 3,SC%WHL+SC%OPR+SC%MNT
	TDNN 3,CAPENB		;HAS NECESSARY CAPS?
	RETERR(CAPX2)		;NO
	MOVSI 5,0(1)		;SETUP BLT ARGS - FROM
	HRRI 5,0(2)		; .. TO
	MOVEI 6,0(2)
	HLRZ 3,1		;COUNT
	HRRZ T4,T1		; FIND MONITOR LIMIT
	ADD T4,T3
	ADDI 6,-1(3)		; .. TO LIMIT

;CHECK ALL PAGES OF SOURCE BLOCK FOR PROPER ACCESS

	MOVEI 1,0(1)		;GET MONITOR ADDRESS
PEEK1:	PUSH P,1
	MRPAC			;GET ACCESS OF MONITOR PAGE
	TLNN T1,-1		;LEGAL RANGE? ** TO BE CHANGED FOR XADR **
	TLNN 2,(PA%RD)		;READABLE?
	RETERR(PEEKX2)		;NO
	POP P,1
	IORI 1,777		;BUMP ADDRESS TO NEXT PAGE
	ADDI 1,1
	CAMGE 1,T4		;CHECKED ALL PAGES?
	JRST PEEK1		;NO, GO CHECK NEXT ONE
	UMOVE T3,T2		;GET TO ADDRESS FROM USER
	UMOVE T2,T1		;GET FROM ADDRESS AGAIN
	HLRZ T1,T2		;FIND SIZE
	HRLI T2,MSEC1		;SECTION 1 IN MONITOR
	CALL BLTMU1		;TRANSFER FROM MONITOR TO USER
	SMRETN

;ERROR - SC%WHL OR SC%OPR REQUIRED BUT NOT ENABLED

WHEELX:	ITERR(WHELX1)

;DETACH FROM CONTROLLING TTY

.DTACH::MCENT
	SKIPL T1,CTRLTT		;GET CONTROLLING TERMINAL
	CALL PTYGBB		;ARE WE CONTROLLED BY BATCH?
	 SKIPA			; NO, CONTINUE
	JUMPL T1,[MOVX T1,SC%WHL!SC%OPR ;IF CONTROLLED BY BATCH,
		TDNN T1,CAPENB	;MUST HAVE WHEEL OR OPR
		ITERR (CAPX1)	;NOT ENOUGH PRIVILEGES
		JRST .+1]	;OK, DO IT
	MOVX T1,.CTTRM		;FINISH OUTPUT ON CONTROLLING TERMINAL
	DOBE			; BECAUSE TTYDAS WILL RELEASE BUFFERS
	CALL LDTACH		;DO THE WORK
	MRETNG			;AND ALL DONE

;DTACH CALLED INTERNALLY

LDTACH:	STKVAR <LDTALN>
LDTAC2:	SKIPGE T2,CTRLTT	;DOES JOB HAVE A CONTROLLING TERMINAL?
	RET			;NO. DON'T DO ANYTHING
	HRLOI T1,(TL%CRO+TL%COR+TL%SAB+TL%ABS)
	CAMN T2,CTYLNO		;Detaching CTY?
	TXZ T1,TL%ABS		;Always leave CTY refusing links
	MOVEI T2,-1
	TLINK			;BREAK LINKS
	 JFCL
	CALL LCKDVL		;LOCK DEVICE LOCK, NO NOINT
	SKIPGE T2,CTRLTT	;GET CONTROLLING TTY
	 JRST [ UNLOKK DEVLKK	;NOT THERE, RELEASE DEVLKK
		PUSH P,T1	;SAVE TEST ROUTINE ADDR
		MOVE T2,LDTALN	;MIGHT BE DYNAMIC DATA LOCKED BY SOME JSYS
		MOVEI T3,"C"-100;SO GIVE JOB A ^C AND HOPE
		CALL TTPSRQ	;WONT HELP IF TRAPPING ^C
		POP P,T1	;PUT ADDRESS BACK
		OKINT		;GO OKINT AND
		RET ]		;RETURN
	MOVEM T2,LDTALN		;SAVE LINE NUMBER
	CALL STADYN		;POINT TO DYNAMIC DATA
	 JRST LDTAC3		;NOT ACTIVE. SHOULDN'T HAPPEN
	CALL TTFWAK		;WAKE UP PROCESS IN INPUT WAIT ON THIS LINE
	MOVE T2,LDTALN		;T2/ LINE NUMBER
	CALL TTYDAS		;DEASSIGN DYNAMIC DATA
	 JRST [	UNLOKK DEVLKK	;FAILED - UNLOCK DEVICE LOCK
		OKINT		;LCKDVL WENT NOINT
		TXZN T1,1B0	;ERROR OR WAIT?
		RET		;ERROR. CURRENTLY NO WAY TO HANDLE THIS
		HRL T1,LDTALN	;T1/(LINE NUMBER,,ADDRESS OF TEST ROUTINE)
		MDISMS		;WAIT UNTIL DEALLOCATION IS POSSIBLE
		JRST LDTAC2]	;TRY AGAIN
LDTAC3:	SETOM CTRLTT		;INDICATE JOB DOESN'T HAVE CONTROLLING TERMINAL
	MOVE T1,JOBNO
	HRROS JOBPT(T1)
	UNLOKK DEVLKK		;UNLOCK DEVICE LOCK
	HRRE T1,JOBDIR(T1)
	CAIE T1,0		;LOGGED IN?
	JRST [	MOVE T2,LDTALN	;T2/ LINE NUMBER
		CAML T2,CTYLNO	;3053 Is line between 1 and CTY-1?
		IFSKP.		;3053
		  SKIPGE TTSTAT(2) ;3053 Remote?
		    CALL TTHNGU	;3053 Yes, Hangup Dataset, Return
		ENDIF.		;3053
		CALL DETMSG	;YES. NOTE EVENT ON LOGGING TERMINAL
		JRST .+1]
	OKINT
	RET

;LDET2 - DETACH JOB FROM TERMINAL WITHOUT DEALLOCATING TERMINAL DATA

;RETURNS +1: ALWAYS

;PRESERVES T2

LDET2:	STKVAR<LDETSV>
	HRLOI T1,(TL%CRO+TL%COR+TL%SAB+TL%ABS)
	MOVE T2,CTRLTT		;GET CONTROLLING TERMINAL
	CAMN T2,CTYLNO		;Check for CTY
	TXZ T1,TL%ABS		;CTY should default to refuse links
	MOVEI T2,-1
	TLINK			;BREAK LINKS
	 JFCL
	CALL UNPAGE		;CLEAR PAGING
	MOVE 2,CTRLTT		;T2/ CONTROLLING TERMINAL NUMBER
	MOVEM T2,LDETSV		;SAVE IT
	MOVE 1,JOBNO
	HRRE T1,JOBDIR(T1)	;GET LOGGED IN DIRECTORY
	CAIE T1,0		;LOGGED IN?
	CALL DETMSG		;YES, DO MESSAGE AND EFACT
	SETOM CTRLTT		;INDICATE NO CONTROLLING TERMINAL
	MOVE T1,JOBNO		;GET JOB NUMBER
	HRROS JOBPT(T1)		;INDICATE NO CONTROLLING TERMINAL
	MOVE T2,LDETSV		;T2/ LINE NUMBER
	CALL LCKTTY		;POINT TO DYNAMIC DATA
	 SKIPA			;NOT ACTIVE
	CALL TTFWAK		;WAKE FORK IN INPUT WAIT ON THIS LINE
	CALL ULKTTY		;ALLOW DEALLOCATION
	MOVE T2,LDETSV		;RESTORE LINE NUMBER
	RET

;ROUTINE TO TURN OFF PAGE MODE FOR CONTROLLING TERMINAL.
;CLOBBERS A AND B

UNPAGE:	MOVEI A,.PRIOU		;THE CONTROLLING TERMINAL
	MOVEI B,.MOXOF		;CLEAR PAUSE ON END
	SETZM C
	MTOPR			;DO IT
	RET			;AND DONE

;PROCEDURE TO HANDLE DATASET CARRIER OFF OR PTY CLOSED.
;1001 DETACH JOB IMMEDIATELY, LOGOUT AFTER 10 MINUTES IF NOT REATTACHED
;1001 AND THE SYSTEM IS JOBS FULL (LOGOUT IS PROBABILISTIC, SO ALL SUCH JOBS DON'T
;1001 GO AT ONCE AFTER A NETWORK FLAP)
;INVOKED ON REQUEST BY PSI SERVICE

JOBCOF::SKIPGE SLOWF		;IN JSYS CONTEXT?
	JRST [	MCENTR		;NO, GET THERE
		PUSH P,[IFIW!MRETN]	;SETUP RETURN
		JRST .+1]
	SE1ENT			;GET INTO SECTION 1
	SAVET
	MOVE 1,JOBNO
	SKIPGE B,CTRLTT		;HAVE A CONTROLLING TTY?
	JRST JOBCF1		;NO
	CALL GTCJOB		;GET ITS OWNING JOB
	 JRST JOBCF2		;NONE. GO ON
	CAIN C,0(A)		;SAME AS THIS ONE?
	JRST JOBCF1		;YES. GO ON
JOBCF2:	SETOM CTRLTT		;NO. CLEAR THIS ASSIGNMENT
	MOVE T1,JOBNO
	HRROS JOBPT(T1)		;ALSO CLEAR CONTROLLING TTY HERE
JOBCF1:	CALL LDTACH		;DO LOCAL DETACH
	MOVE T1,JOBNO
	HRRZ 1,JOBDIR(1)	;SEE IF NOW LOGGED IN
	IFE. T1
	  MOVX T1,UMODF		;NO, RESET STACK AND LOGOUT
	  MOVEM T1,FFL
	  SETZM FPC
	  JRST FLOGO
	ENDIF.
	MOVE T1,BITS+.TICRF	;CHECK TO SEE WHAT THE TOP FORK THINKS
	TDNE T1,TTSPSI		; OF TAKING A CARRIER OFF INTERUPT
	 RET			;IT THINKS SO, SO LET IT TRY
;1001 begin modification
repeat 0, <
	CALL FFORKI		;INDIRECTLY FREEZE ALL INFERIORS
	MOVE 1,[^D<5*60000>]	;SETUP TO WAIT 5 MINUTES
	CALL SETBKT		;COMPUTE BLOCKT DATA
	HRRI 1,COFTST		;SETUP SPECIAL TEST
	MOVSI T2,FHV1		;LOW BLOCK PRIORITY
	HDISMS
>;end repeat 0
	MOVE T1,BITS+.TICRF	; SEE IF TOP FORK ENABLED
	TDNN T1,TTSPSI		; FOR CARRIER OFF PSI
	CALL FFORKI		;INDIRECTLY FREEZE ALL INFERIORS
	HRRZI 1,COFTST		;SETUP SPECIAL TEST
	MDISMS
;1001 End modification
	MOVE 1,JOBNO		;SEE IF NOW ATTACHED
	SKIPL JOBPT(1)
	IFSKP.
	  MOVX T1,UMODF		;USER PC FAKE
	  MOVEM T1,FFL
	  SETZM FPC
	  MCENTR		;RESET STACK, INIT JSYS CONTEXT
	  MOVE T1,JOBNO
	  HRRZ T1,JOBDIR(T1) 	;DIRECTORY
	  JUMPE T1,FLOGO1 	;DONT CHECK IF NOT LOGGED IN
	  HRLI T1,USRLH
	  CALL CNVDIR		;GET THE NUMBER OF THAT DIRECTORY
	  GTDAL			;GET ALLOCATION
	   ERJMP FLOGO1		;DONT TRY ACJ IF THERE IS AN ERROR
	  SETOM T1		;FAKE A LOGOUT WITH -1 AS ARG
	  GTOKM (.GOLGO,<T2,T3,T1>,FLOGO1) ;ASK ACJ, BUT IN ANYCASE,
				;LOG OUT THIS USER. (THIS IS ONLY TO BE NICE
				;TO ACJ, WHO MAY NOT BE NICE TO US)
	  JRST FLOGO1
	ENDIF.
	NOINT			;KEEP CONTROL
	HLRZ T2,JOBPT(T1)	;GET CONTROLLING TTY
	MOVEI T3,"C"-100	;FAKE A CONTROL-C
	CALL TTPSRQ		;""
	CALL RFORKI		;RESUME ALL INDIRECTLY FROZEN INFERIORS
	OKINT			;ALLOW INTS AGAIN
	RET

;SCHEDULER TEST FOR ABOVE. WAITS UNTIL JOB ATTACHED OR SPECIFIED TIME
;ELAPSED

	RESCD

COFTST:	LOAD 2,FKJOBN		;GET JOB NUMBER
	SKIPL JOBPT(2)		;NOW ATTACHED?
	JRST 1(4)		;YES, WAKEUP
;1001 Begin addition
	MOVE T2,TODCLK		;GET PRESENT TIME
	SUB T2,FKPGST(FX)	;SUBTRACT  TIME STARTED WAITING
	MOVEI T1,^D60000	;CHECK IT IN A MINUTE (OR LESS)
	CAMGE T2,[^D<10*60000>]	;AT LEAST 10 MIN. WAITING?
	JRST 0(4)		;NO, KEEP WAITING
	CAMLE T2,[^D<60*60000>]	; More than 1 hour waiting?
	JRST 1(4)		; Yes, return to be logged out
	SKIPE FREJOB		;JOBS FULL?
	JRST 0(4)		;NO, KEEP WAITING FOR USER TO COME BACK
	LOAD T2,FKJOBN		;YES, CHOOSE 1 IN 40 JOBS FOR LOGOUT
	XOR T2,TODCLK		;USE TIME TO RANDOMIZE
	TRNE T2,37		;THIS JOB TO GO?
	JRST 0(4)		;NO, KEEP WAITING
	JRST 1(4)		;YES, WAKE UP
;End addition
;1001	JRST BLOCKT		;NO, GO TEST TIME

	SWAPCD

;ATTACH JOB TO TTY

;ACCEPTS:
;	T1/ FLAGS,,JOB NUMBER TO ATTACH TO
;	T2/ USER NUMBER OF JOB IN AC 1
;	T3/ POINTER TO PASSWORD STRING
;	T4/ DESIGNATOR FOR TERMINAL TO BE USED IF AT%TRM FUNCTION OF 1
;	    IS ON.

;	ATACH

;RETURN +1: FAILURE, ERROR CODE IN 1
;RETURN +2: SUCESS.

.ATACH::MCENT
	SAVEAC <Q1,Q2,FX>	;DEFINE ALL Q'S TO USE AS WORK REGS
	STKVAR <ATACJN,ATACDR,ATACLN,ATACUN>
	MOVEM T2,ATACUN		;STASH THE USER NUMBER
	UMOVE Q1,1		;BITS MODIFYING THE ATACH
	TXNE Q1,AT%TRM		;PROXY ATTACH
	JRST ATACH1		;YES.  DO NOT CARE ABOUT USER NUMBER
	HLRZ T3,T2		;GET UNIQUE CODE OF USER NUMBER
	CAIE T3,USRLH		;IS THIS A LEGAL USER NUMBER?
	RETERR (ATACX3)		;NO, GIVE ERROR RETURN
ATACH1:	MOVEI T1,0(T1)		;GET OBJECT JOB NUMBER
	JUMPE T1,[RETERR (ATACX1)] ;CAN'T ATTACH TO JOB 0
	MOVEM T1,ATACJN		;SAVE JOB NUMBER TO ATTACH TO
	CAIGE T1,NJOBS		;REASONABLE JOB NUMBER?
	SKIPGE JOBRT(T1)	;AND JOB EXISTS?
ATACH5:	RETERR(ATACX1)		;NO
	TXNN Q1,AT%TRM		;PROXY ATTACH
	IFNSK.			;IF NOT
	 CAMN T1,JOBNO		;TRYING TO DO HIS JOB?
	 RETERR (ATACX2)	;YES. ERROR
	ELSE.
	 UMOVE FX,4		;GET TTY NUMBER TO ATACH THE JOB TO
	 ANDI FX,377777		;JUST LINE NUMBER PART
	 SKIPG FX		;VALID TTY NUMBER?
	 RETERR (ATACX7)	;NO, FAIL
	 CAIL FX,NLINES		;EXISTANT LINE?
	 RETERR (ATACX1)	;NO. FAIL.
	ENDIF.
	HRRZ T3,JOBDIR(T1)	;DIRECTORY OF  OTHER JOB
	MOVEM T3,ATACDR		;SAVE DIRECTORY NO. FOR FACT FILE
	CAIE T3,0(T2)		;SAME AS SPECIFIED?
	RETERR(ATACX3)		;NO
	; ..

	; ..
;SEE IF USER CAN LEGALLY ATTACH OTHER JOB.  ATTACH IS LEGAL IF
;BOTH JOBS ARE SAME USER, IF THIS USER IS SC%WHL, OR IF
;USER GIVES PROPER PASSWORD
;ALSO, ATACH IS LEGAL IF JOB BEING ATTACHED IS OWNED BY THE
;SAME USER AS THE OWNER OF THE PTY CONTROLLING THE JOB DOING THE
;ATACH AND THE JOB DOING THE ATACH IS NOT YET LOGGED IN.
;ALSO, IF OWNER OF PTY IS AN ENABLED WHEEL OR OPR, JOB
;ON PTY MAY ALWAYS DO ATACH.
;ALSO, LEGAL IF OBJECT JOB IS OWNED BY ATACH-ER, DUE TO CRJOB.
;IN ADDITION, ATTACHING TO A JOB CONTROLLED BY BATCH IS ILLEGAL
;WITHOUT BEING LOGGED-IN WITH WHEEL OR OPR PRIVS ENABLED.

	MOVE T1,ATACJN		;GET OBJECT JOB NUMBER
	MOVX T2,<-1,,T4>	;GETJI ARGUMENT POINTER
	MOVX T3,.JIBAT		;SEE IF UNDER CONTROL OF BATCH
	GETJI			;GET THE INFORMATION
	 SETZ T4,		;CONTINUE, CATCH THIS LATER
	JUMPL T4,[MOVE T2,JOBNO	;BATCH JOB.  USER MUST BE LOGGED-IN
		MOVX T1,SC%WHL!SC%OPR ; WITH WHEEL OR OPR ENABLED
		SKIPE JOBDIR(T2) ;TEST LOGIN
		TDNN T1,CAPENB	;IS LOGGED-IN, TEST CAPS
		 RETERR (CAPX1)	;NOT GOOD ENOUGH
		JRST .+1]	;OK, CONTINUE IN-LINE
	TXNE Q1,AT%NAT		;DOING ATACH OR UNATTACH?
	IFSKP.			;IF ATTACH
	 HRRZ T4,CTRLTT		;ASSUME THIS IS THE TTY #
	 TXNE Q1,AT%TRM		;IS IT A PROXY?
	 MOVE T4,FX		;YEP
	 MOVE T3,ATACDR		;GET USER NUMBER
	 HRLI T3,USRLH		;MAKE IT USABLE BY OTHERS
	 GTOKM (.GOATJ,<T3,T4>,[RETERR()]) ;LET ACJ SNIFF THIS
	ENDIF.
	MOVE T3,ATACDR		;REFETCH OTHER USER NUMBER
	MOVE T2,JOBNO		;GET THIS JOB NUMBER
	HRRZ T2,JOBDIR(T2)	;GET USER NUMBER FOR THIS JOB
	CAMN T2,T3		;SAME AS OTHER JOB?
	JRST ATACH3		;YES, NO FURTHER LEGALITY CHECKS
	JUMPN T2,ATACH6		;PTY OWNER IS IRRELEVANT IF NOT LOGGED IN
	MOVE T1,CTRLTT		;SEE IF I AM ON A PTY
	JUMPL T1,ATACH6		;JUMP IF NO CONTROLLING TTY
	CALL PTGETJ		;GET CONROLLING JOB # OR -1
	JUMPL T1,ATACH6		;NON-PTY DOING THE ATACH IF -1
	HRRZ T4,JOBDIR(T1)	;T4 GETS OWNER OF PTY
	XCTU [HRRZ T3,T2]	;GET OWNER OF JOB BEING ATACHED
	CAMN T3,T4		;THE SAME?
	JRST ATACH3		;YES, SO NO PASSWORD NEEDED
	CALL GJCAPS		;GET CAPABILITIES OF OWNER OF PTY
	TXNE T1,SC%WHL+SC%OPR	;PRIVILEGED?
	JRST ATACH3		;YES, SO NO PASSWORD NEEDED
ATACH6:	MOVE T3,ATACDR		;GET DIR NUMBER
	MOVEI T1,SC%WHL+SC%OPR
	TDNE T1,CAPENB		;THIS USER HAS CAPS?
	JRST ATACH3		;YES, NO FURTHER CHECKS
	MOVE T1,ATACJN		;SEE IF I OWN THE JOB
	HRRZ T1,JOBONT(T1)	;OWNER FIELD
	CAMN T1,JOBNO		;IS IT ME?
	JRST ATACH3		;YES, THEN IT'S LEGAL.
	UMOVE T1,2		;GET USER NUMBER FOR PASSWORD CHECK
	CALL CNVDIR		;GET USER'S LOGGED-IN DIRECTORY NUMBER
	UMOVE T2,T3		;GET PTR TO PASSWORD STRING
	TRNE T3,-1		;FAIL IF JOB NOT LOGGED IN
	CALL PASSWC		;PROPER PASSWORD?
	 JRST [	MOVE T2,T1	;SAVE FLAG
		MOVEI T1,^D3000	;NO, DELAY TO FOIL PASSWORD THIEVES
		SKIPN T2	;NEED TO SLEEP?
		DISMS
		RETERR(ATACX4)]	;NOW BOMB OUT

;USER HAS PROVEN RIGHT TO DO THIS. THE FOLLOWING DATA IS AVAILABLE:
;	JOBNO/ JOB NUMBER OF CALLER OF JSYS
;	CTRLTT/ TERMINAL AT WHICH CALLER IS RUNNING
;	ATACJN/ JOB NUMBER TO BE ATTACHED TO THIS TERMINAL

;USER WANTS TO ASSOCIATE THE JOB IN ATACJN WITH THE TERMINAL IN CTRLTT
;IF THE JOB IS CURRENTLY ATTACHED, IT MUST BE DETACHED FIRST

ATACH3:	TXNE Q1,AT%TRM+AT%NAT	;IS MY TTY TO BE USED?
	JRST ATACH9		;NOT BY DEFAULT, ANYWAY.
	SKIPGE FX,CTRLTT	;YES. GET MY TTY
	RETERR ATACX2		;I DON'T HAVE ONE. FAIL.
ATACH9:	TXNN Q1,AT%TRM		;USING A DIFFERENT LINE?
	JRST ATACHB		;NO
	HRRZ T2,FX		;YES, BETTER ASSIGN SOME DYNAMIC DATA
	NOSKED			;PREVENT STATE CHANGES
	CALL GTCJOB		;GET CONTROLLING JOB
	IFSKP.			;IF ASSIGNED
	 CAIE T3,-1		;THIS JOB?
	 RETERR (DEVX2,<OKSKED>)
	ENDIF.
	CALL TTYASC		;ASSIGN AS CONSOLE
	 RETERR(,<OKSKED>)
	OKSKED
ATACHB:	MOVE T1,ATACJN		;GET BACK OBJECT JOB NUMBER
	CALL SETJSB		;SETUP OTHER JOB'S JSB
	MOVEI Q2,0(T1)		;SAVE OFFSET FOR OTHER JOB'S JSB
	SKIPGE T2,CTRLTT(Q2)	;OTHER JOB NOW ATTACHED?
	JRST ATACH2		;NO. DON'T DETACH IT

;OBJECT JOB IS ATTACHED. DETACH IT FROM ITS CURRENT CONTROLLING
;TERMINAL AND DEALLOCATE THAT TERMINAL'S DATA

	MOVEM T2,ATACLN		;SAVE ITS CONTROLLING TERMINAL
	CALL LCKDVL		;LOCK DEVICE LOCK, GO NOINT
	NOSKED			;MUST DETACH IT FIRST
	CALL STADYN		;POINT TO DYNAMIC DATA
	 JRST [	OKSKED		;NOT ACTIVE. DON'T DEASSIGN IT
		JRST ATACH7]
	CALL TTFWAK		;WAKE FORK IN INPUT WAIT ON THIS LINE
	CALL REMTCJ		;1001 Avoid carrier off interrupts
	MOVE T2,ATACLN		;T2/ LINE NUMBER
	CALL TTYDAS		;DEASSIGN THE LINE
	 JRST [	PUSH P,T1	;SAVE THE ERROR CODE
		OKSKED
		CALL CLRLFK	;UNMAP THE JSB
		UNLOKK DEVLKK	;UNLOCK DEVICE LOCK
		OKINT		;LCKDVL WENT NOINT
		POP P,T1	;GET THE CODE BACK
		TXZN T1,1B0	;NEED TO WAIT?
		RETERR		;NO. RETURN FAILURE
		HRL T1,ATACLN	;T1/(LINE NUMBER,,ADDRESS OF TEST ROUTINE)
		MDISMS		;WAIT UNTIL DEALLOCATION IS POSSIBLE
		JRST ATACH3]	;TRY AGAIN
ATACH7:	SETOM CTRLTT(Q2)	;INDICATE JOB HAS NO CONTROLLING TERMINAL
	MOVE T1,ATACJN		;GET OBJECT JOB NUMBER
	HRROS JOBPT(T1)		;NO CONTROLLING TERMINAL AGAIN
	OKSKED
	UNLOKK DEVLKK		;UNLOCK DEVICE LOCK
	OKINT			;LCKDVL WENT NOINT
	MOVE T2,ATACLN		;T2/ LINE NUMBER OF DETACHED JOB
	MOVE T3,JOBNO		;GET THIS JOB NUMBER
	HRRZ T3,JOBDIR(T3)	;GET USER NUMBER FOR THIS JOB
	HRLI T3,USRLH		;MAKE IT BE A USER NUMBER
	MOVE T4,CTRLTT		;AND TTY # OF DETACHER
	CALL DETMS1		;TELL JOB IT'S BEING DETACHED
	; ..

;OBJECT JOB HAS BEEN DETACHED. DETACH CALLER FROM CONTROLLING TERMINAL
;AND ATTACH OBJECT JOB TO THAT TERMINAL. DON'T DEALLOCATE THE DYNAMIC
;DATA FOR THE TERMINAL

	;..
ATACH2:	TXNE Q1,AT%NAT		;REQUESTED NO ATTACH?
	JRST ATACH4		;YES
	MOVEM FX,ATACLN		;NO, MAKE SURE LINE RIGHT
	MOVE T2,FX		;prepare for LDET2
	NOINT			; ..
	CAMN FX,CTRLTT		;NEED TO GIVE AWAY MY TERMINAL?
	CALL LDET2		;YES, DETACH THIS JOB BUT KEEP DYNAMIC DATA
	NOSKED

;ASSIGN OBJECT JOB TO CORRECT TERMINAL

	MOVE T4,ATACJN		;GET OBJECT JOB
	MOVEM FX,CTRLTT(Q2)	;SET CTRLTT IN DEST JOB
	HRLM FX,JOBPT(T4)
	MOVEI T1,.TTDES(FX)	;T1/ DEVICE DESIGNATOR FOR TERMINAL
	CALL CHKDES 		;GET INDEX TO DEVICE TABLES
	 BUG(TTBAD1)
	MOVE T1,ATACJN		;GET OTHER JOB NUMBER
	HRLM T1,DEVUNT(T2)	;INDICATE OTHER JOB OWNS THE TERMINAL
	MOVE T2,ATACLN		;T2/ TERMINAL NUMBER
	MOVE T1,TTSPSI(Q2)	;T1/ INTERRUPT WORD FOR OTHER JOB
	MOVE T3,TTSDPS(Q2)	;T3/ DEFERRED INTERRUPT WORD FOR OTHER JOB
	CALL TTSINT		;SET INTERRUPT WORDS FOR THIS TERMINAL
	MOVE T1,ATACJN		;T1/ OTHER JOB
	CALL STCJOB		;SET THIS AS CONTROLLING THE TERMINAL
	OKSKED
	OKINT
	CALL CLRLFK		;CLEAR MAPPING OF JSB
	MOVE T1,ATACJN
	MOVE T2,ATACLN		;SET UP JOB/LINE INFO
	CALL ATAMSG		;DO LOGGING STUFF
	MOVE T1,JOBNO
	HRRE T1,JOBDIR(T1)
	JUMPE T1,LOGO		;VANISH IF NOT LOGGED IN
	SMRETN

;HERE IF CALLER REQUESTED "NO ATTACH", I.E. DETACHING REMOTE JOB

ATACH4:	CALL CLRLFK		;CLEAR MAPPING OF JSB
	MOVE T1,ATACJN		;SET JOB #
	MOVE T2,ATACLN		; AND LINE #
	CALL DETMS0		;DO LOG MSG AND FACT FILE ENTRY
	SMRETN

	ENDSV.			;END STKVAR

;USAGE UTILITIES FOR JOB 0

;USAGE VARIABLES

NR CKPGID,1			;PAGE IDENT OF CURRENT MAPPED PAGE UN CHECKPOINY FILE

;INIT USAGE DATA BASE

USGINI:	SAVEAC <Q1,Q2,FX>	;PRESERVE ALL TEMP WORK REGS
	STKVAR <CKPNJ,CKIDNT>
	SETOM USGLOK		;CLEAR LOCKS
	SETZM USQCNT		;EMPTY QUEUE
	SETZM USGBEG		;INIT QUEUE
	MOVEI T1,USGBEG-1
	MOVEM T1,USGEND		;TO BE EMPTY
	SETZM USGEOF		;INIT EOF POINTER
	SETZM CKPJFN		;NO JFN'S YET
	SETZM USGJFN		;...
	SETZM CKPGID		;NO PAGE MAPPED
	MOVE T1,TODCLK		;SETUP FIRST CHECKPOINT INTERVAL
	ADD T1,CKPINV
	MOVEM T1,CKPTIM		;TIME FOR FIRST CHECKPOINT
	MOVX T1,SF%CDE		;FILE SYSTEM OK?
	TDNE T1,FACTSW
	JRST [	TMSG <? System accounting will not be done due to file system errors
>
		RET]
USGIN1:	HRROI T2,USGFIL		;FILESPEC FOR USAGE FILE
	CALL USGOPN		;OPEN FILE
	 JRST [	CALL CRUSGF	;NONE - CREATE USAGE FILE
		 BUG (UXXCRE)
		JRST USGIN1]	;TRY AGAIN
	MOVEM T1,USGJFN		;STORE JFN
	TXO T1,CO%NRJ		;RETAIN JFN
	CLOSF			;THIS SHOULD CORRECT PAGE COUNT
	 JFCL			;SHOULDN'T HAPPEN
	MOVX T2,44B5+OF%RD!OF%WR ;257 Not restricted
	MOVE T1,USGJFN		;FETCH JFN
	OPENF			;OPEN FOR REAL NOW
	 BUG (UXXOPN)
	HRRZ T1,T1		;GET RID OF OPEN FLAGS
	FFFFP			;FIND-FIRST-FREE-FILE PAGE
	HRRZ Q1,T1		;SAVE PAGE NUMBER
	MOVE T1,USGJFN		;JFN AGAIN
	MOVE T2,[1,,.FBBYV]	;GET PAGE COUNT
	MOVEI T3,T4		; INTO T4
	GTFDB
	HRRZS T4		;PAGE # ONLY
	CAME Q1,T4		;CORRECT NUMBER
	BUG (USGHOL)
	JUMPE Q1,USGIN4		;EMPTY FILE IF 0
USGIN2:	SETZ Q2,		;INIT TO WORD 0
	JUMPL Q1,USGIN3		;MUST BE EMPTY IF NONE LEFT
	SOS T1,Q1		;WANT LAST PAGE
	HRL T1,USGJFN		; FROM USAGE FILE
	MOVX T2,PM%RD		;READ ONLY
	CALL USGMAP		;MAP PAGE
	MOVEI Q2,777		;SCAN BACK FROM END OF PAGE
	SKIPN T1,FPG0A(Q2)	; FOR FIRST NON-ZERO WORD
	SOJGE Q2,.-1		;...
	AOJE Q2,[SOJA Q1,USGIN2] ;PAGE WAS ALL ZEROS
				;ADJUST COUNT TO FIRST AVAIL WORD
	;..
	;..
USGIN3:	IMULI Q1,PGSIZ		;CALC EOF POINTER
	ADD Q1,Q2
USGIN4:	MOVEM Q1,USGEOF		;SETUP LOC

;CHECKPOINT INIT

USGIN5:	HRROI T2,CKPFIL		;FILE NAME FOR CHECKPOINT
	CALL USGOPN		;OPEN IT
	 JRST [	CALL CRCKPT	;NON-EX CREATE NEW ONE
		 BUG (UXXCKP)
		JRST USGIN5]
	MOVEM T1,CKPJFN		;SAVE JFN
	HRLZS T1		;START AT PAGE 0
	MOVEM T1,CKIDNT		;SAVE IDENT
	MOVX T2,PM%RD
	CALL USGMAP		;MAP PAGE
	MOVE Q1,FPG0A+1		;GET # OF JOBS IN FILE
	ERJMP CKPBAD		;IF NON-EX PAGE, FILE IS BAD
	MOVE T1,FPG0A+3		;SIZE OF CHECKPOINT RECORD
	CAIN T1,CKPSIZ		;BETTER BE SAME
	CAIGE Q1,NJOBS		;.GE. MAX JOBS IN MONITOR
CKPBAD:	JRST [	BUG (UXXFIT)
		CALL UNMAPC
		MOVE T1,CKPJFN	;CLOSE AND DELETE (EXPUNGE)
		TXO T1,CO%NRJ
		CLOSF
		 JFCL
		MOVE T1,CKPJFN
		TXO T1,DF%EXP
		DELF
		 JFCL
		SETZM CKPJFN
		JRST USGIN5]	;START OVER FOR CHECKPOINT
	MOVEM Q1,CKPNJ		;SAVE NUMBER OF JOBS IN FILE
	MOVE T1,FPG0A+2		;GET DATE/TIME OF LAST CHECKPOINT
	MOVEM T1,CKPDTL		;SAVE
	SKIPN USGEOF		;USAGE FILE EMPTY?
	JRST USGI6B		;YES - SKIP THIS
	HRLZ T1,CKPJFN		;START AT PAGE 0 AGAIN
USGIN6:	MOVEI Q2,PGSIZ/CKPSIZ	;NUMBER OF JOBS/PAGE
	SETZ FX,		;INIT OFFSET
	MOVX T2,PM%RD
	MOVEM T1,CKIDNT		;SAVE IDENT
	CALL USGMAP
	SKIP FPG0A		;TEST PAGE FOR GOODNESS
	ERJMP CKPBAD		;NOT GOOD IF INTERRUPT TAKES
USGI6A:	SKIPLE T4,FPG0A(FX)	; .GT. 0 MEANS WRITE IN PROGRESS
	MOVEM T4,USGEOF		;THIS IS ACTUAL USGEOF
	ADDI FX,CKPSIZ		;STEP TO NEXT ENTYR
	SOJLE Q1,USGI6B		;MORE JOBS TO DO?
	SOJG Q2,USGI6A		;YES - MORE IN THIS PAGE?
	MOVE T1,CKIDNT		;RESTORE LAST PAGE MAPPED
	AOJA T1,USGIN6		;STEP TO NEXT PAGE

USGI6B:	CALL UNMAPC		;UNMAP CHECKPOINT PAGE; THIS IS THE LAST TIME
				; WE WILL BE USING ONLY READ ACCESS
	MOVE T1,USGJFN		;GET USAGE FILE JFN
	MOVE T2,USGEOF		;CURRENT EOF
	SFPTR			;SET TO START WRITTING HERE
	 JFCL			;IGNORE ERRORS
	MOVX T1,SF%USG		;TURN ON USAGE JSYS
	IORM T1,FACTSW		;...
	;..
	;..
	MOVE T1,TODCLK		; GET MONITOR UPTIME IN MSEC
	IDIVI T1,^D1000		; MAKE IT SECONDS
	MOVEM T1,USGMUP		; AND STORE IT WHERE RESTART LIST KNOWS
	MOVE T1,TODCLK		; GET MONITOR UPTIME IN MSEC
	IDIVI T1,^D1000		; MAKE IT SECONDS
	MOVEM T1,USGMUP		; AND STORE IT WHERE RESTART LIST KNOWS
				;WRITE RESTART RECORD NOW
	MOVEI T1,.USENT		;GENERATE ENTRY
	MOVEI T2,RSTLST		;POINT TO RESTART LIST
	USAGE			;THIS WILL MAKE A RECORD ON USQ
	CALL USGMES		;IMMEDIATELY WRITE INTO FILE
	MOVEI Q1,1		;MERGE CHECKPOINT FILE
	SOS CKPNJ		; FOR JOBS 1 THRU NJOBS-1
	CALL LGTAD		;GET DATE/TIME
	MOVE Q2,T1		;SAVE IN Q2
USGIN7:	MOVE T1,Q1		;JOB #
	CALL USGSPG		;SET PAGE FOR THIS JOB
	SKIPGE 0(T4)		;IS ENTRY ACTIVE?
	JRST USGIN8		;NO, GET NEXT ENTRY
	MOVEI T2,.UTCKP		;RECORD TYPE FOR CHECKPOINT MERGE
	HRLM T2,1(T4)		;STORE IN HEADER
	HRRZ T3,1(T4)		;GET RECORD LENGTH
	CAIL T3,CKPSIZ		;IS LENGTH LESS THAN MAX SIZE?
	JRST [	BUG (CKPLEN)	;NO, THIS IS A BUG
		JRST USGIN8]	;AND IGNORE ENTRY
	ADD T3,T4		;ADD IN BASE
	HRLM T2,0(T3)		;STORE TYPE IN TRAILER ALSO
	MOVEM Q2,2(T4)		;SET ENTRY DATE/TIME TO NOW.
	CALL USGUP0		;UPDATE FOR THIS JOB
USGIN8:	CAMGE Q1,CKPNJ		;DONE?
	AOJA Q1,USGIN7		;NO - INCR AND PROCEDE
	CALL UNMAPC		;UNMAP CHECKPOINT PAGE
	CALLRET NXTASC		;Find next acct shift change time
				; and return from USGINI


;Initialize accounting shift change stuff
;Must be done before SETSPD is run!!!

ASCINI:	SETZM ASCPTR		;Indicate no accounting shift changes yet
	SETZM ASCTIM		; and no time set for next one
	SETOM ASCLOK		;Leave ASCPTR lock unlocked
	RET			;Return from ASCINI

;RESTART ENTRY DATA LIST

RSTLST:	USENT. (.UTRST,1,1)	;RESTART RECORD TYPE
	USSNM. (<-1,,SVN>)	;SYSTEM NAME STRING
	USMVR. ([EXP SVNM])	;SYSTEM VERSION NUMBER
	USPNM. (<SIXBIT "MONITR">,US%IMM)
	USPVR. ([EXP SVNM])	;MONITOR NAME/VERSION FOR USAGE
	USMBD. (SYSTAD)		;MONITOR BUILD DATE/TIME
	USMUP. (USGMUP)		; MONITOR UPTIME SINCE LAST RELOAD
	USLCK. (CKPDTL)		;DATE/TIME OF LAST CHECKPOINT
	USMUP. (USGMUP)		; MONITOR UPTIME SINCE LAST RELOAD
	USCP0. (APRSER)		;APR SERIAL NUMBER
	0			;END OF LIST
;ROUTINE TO OPEN A FILE FOR READ/WRITE

USGOPN:	MOVX T1,GJ%SHT!GJ%PHY!GJ%OLD
	GTJFN
	 RET			;NON-EX RETURN
	MOVX T2,44B5+OF%RD!OF%WR	;257 Not restricted
	OPENF			;OPEN FILE
	 RET			;FAILURE
	RETSKP			;OK - RETURN

;ROUTINE TO CREATE USAGE FILE

CRUSGF:	MOVX T1,GJ%SHT!GJ%PHY!GJ%FOU
	HRROI T2,USGFIL
	GTJFN
	 RET			;ERROR
	MOVX T2,44B5+OF%WR	;WRITE FIRST
	OPENF
	 RET			;FAILURE
	CALL USGNOD		;SET NO-DUMP
	HRLI T1,.FBBYV		;CHANGE THIS WORD
	TXO T1,CF%NUD
	MOVX T2,FB%RET		;RETENTION COUNT
	MOVEI T3,0		; TO BE 0
	CHFDB
	HRRZS T1		;JFN ONLY AGAIN
	CLOSF			;FIX ON DISK
	 JFCL
	RETSKP			;GOOD RETURN
;ROUTINE TO COPY CHECKPOINT ENTRY TO USAGE FILE
; T1/ PAGE IDENT
; T4/ ENTRY ADDRESS

USGUP0:	CALL USGUPS		;Perform file update
	SETOM 0(T4)		;SET ENTRY FREE
	RET			;RETURN FROM USGUP0

; Subroutine to copy current checkpoint entry into USAGE file entry

USGUPS:	SKIPGE 0(T4)		;ENTRY ACTIVE?
	 RET			;NO - NOTHING TO DO
	MOVE T1,USGEOF		;GET CURRENT EOF
	MOVEM T1,0(T4)		;SAVE IN CHECKPOINT
	MOVE T1,USGJFN		;JFN FOR USAGE FILE
	MOVEI T2,1(T4)		;ADDRS OF DATA
	HRLI T2,(POINT 36,,)	;FORM BP
	HRRZ T3,0(T2)		;GET LENGTH OF ITEM
	ADDM T3,USGEOF		;UPDATE USAGE EOF POINTER
	MOVNS T3		;MAKE NEGATIVE
	SOUT			;DUMP INTO FILE
	 ERCAL USGIOE		;REPORT IO ERROR
	MOVE T1,USGEOF		;CALC PAGE JUST WRITTEN
	LSH T1,-PGSFT
	HRL T1,USGJFN		;FORM IDENT
	MOVEI T2,1		;DO ONE PAGE
	UFPGS			;UPDATE FILE PAGE
	 ERCAL USGIOE		;REPORT FAILURE
	RET			;Return from USGUPS

;IO ERROR IN USAGE FILE

USGIOE:	MOVE T1,USGEOF		;REPORT BAD PAGE
	LSH T1,-PGSFT
	BUG (UXXWER,<<T1,D>>)
	RET			;CONTINUE
;ROUTINE TO CREATE A CHECKPOINT FILE

CRCKPT:	STKVAR <SCKJFN>
	HRROI T2,CKPFIL
	MOVX T1,GJ%SHT!GJ%PHY!GJ%NEW ;NEW ONLY
	GTJFN
	 ERJMP [MOVX T1,GJ%SHT!GJ%PHY!GJ%DEL	;HANDLE CASE OF THE
		HRROI T2,CKPFIL	; DELETED BUT NOT EXPUNGED FILE
		GTJFN		; TO PREVENT UXXCKP BUGHLTS
		 ERJMP R	;NOT THAT CASE
		HRLI T1,.FBCTL	;WORD IN FDB TO CHANGE
		MOVX T2,FB%DEL	;TO UNDELETE FILE
		SETZM T3	;CLEAR DELETED BIT
		CHFDB		;DO IT
		 ERJMP R	;FAILURE
		HRRZS T1	;CLEAR STUFF FROM LEFT HALF
		JRST .+1]	;AND CONTINUE
	MOVEM T1,SCKJFN		;SAVE FOR LATER
	MOVX T2,44B5+OF%WR!OF%RD ;READ/WRITE
	OPENF
	 RET			;FAILURE
	CALL USGNOD		;SET NO-DUMP
	NOINT			;APPEASE FREE SPACE ROUTINES
	MOVEI T1,CKPSIZ		;ALLOCATE BUFFER
	CALL ASGSWP		; FOR CHECKPOINT RECORD
	 RETBAD (,OKINT)	;NONE TO BE HAD
	MOVE Q2,T1		;SAVE BASE ADDRS
	MOVEI Q1,NJOBS		;INIT FOR NUMBER OF JOBS
	SETOM 0(Q2)		;-1 SHOWS FREE ENTRY
	MOVEM Q1,1(Q2)		;STORE # OF JOBS IN JOB 0
	CALL LGTAD
	MOVEM T1,2(Q2)		;DATE/TIME OF LAST CHECKPOINT
	MOVEI T1,CKPSIZ		;SIZE OF CHECKPOINT RECORD
	MOVEM T1,3(Q2)
	MOVE T1,SCKJFN		;GET JFN
	HRLI Q2,(POINT 36,,)	;FORM BP
CRCKP1:	MOVE T2,Q2		;COPY BP
	MOVNI T3,CKPSIZ		;SIZE OF ENTRY
	SOUT			;WRITE IT
	 ERJMP [OKINT		;UNDO NOINT
		RETBAD ()]	;AND GIVE ERROR
	SOJG Q1,CRCKP1		;LOOP OVER ALL JOBS
	CLOSF			;CLOSE FILE
	 JFCL
	HRRZ T1,Q2		;ADDRS OF TEMP BLOCK
	MOVEI T2,CKPSIZ		; ITS SIZE
	CALL RELSWP		;RELEASE STORAGE
	OKINT			;UNDO NOINT
	RETSKP			;GOOD RETURN
;ROUTINE TO UPDATE CHECKPOINT PAGE AND UNMAP IT

UNMAPC:	MOVEI T2,1		;1 PAGES
	SKIPE T1,CKPGID		;PAGE IDENT OF LAST PAGE MAPPED
	UFPGS			;UPDATE ON DISK
	 JFCL			;WE TRIED
	SETZB T1,CKPGID		;UNMAP PAGE, MARK NO PAGE MAPPED
	MOVEI T2,FPG0A
	CALLRET SETMPG		;...


;ROUTINE TO SET (MAP) CHECKPOINT FILE PAGE FOR JOB N
; T1/ JOB #
;RETURNS:	T4/ ENTRY ADDRESS
;		T1/ PAGE IDENT

USGSPG:	IMULI T1,CKPSIZ		;CALC CHECKPOINT LOC
	IDIVI T1,PGSIZ		;T1 := PAGE , T2 := LINE
	PUSH P,T2		;SAVE LINE
	HRL T1,CKPJFN		;FORM JFN,,PN
	MOVX T2,PM%RD!PM%WR	;READ/WRITE
	CALL USGMAP
	POP P,T4		;RESTORE OFFSET
	ADDI T4,FPG0A		;ADD IN BASE
	RET			; AND RETURN

;ROUTINE TO SET FB%NOD (NODUMP) FOR FILE JFN IN T1

USGNOD:	HRLI T1,.FBCTL		;SAY WORD 1
	TXO T1,CF%NUD		;NO UPDATE DIRECTORY
	MOVX T2,FB%NOD		;SET BIT AND MASK
	MOVX T3,FB%NOD
	CHFDB			;WRITE INTO FDB
	HRRZS T1		;RETURN JFN INTACT
	RET

;ROUTINE TO MAP A PAGE OF A FILE INTO FPG0
;CALL: T1/ JFN,,PAGE#
;      T2/ ACCESS BITS

USGMAP:	CAMN A,CKPGID		;IS THIS PAGE ALREADY MAPPED?
	 RET			;YES-- RETURN NOW FROM USGMAP
	PUSH P,T2		;SAVE ACCESS INFO
	PUSH P,T1		;SAVE PAGE ID
	MOVEI T2,1		;ONE PAGE TO UPDATE
	SKIPE T1,CKPGID		;GET CURRENT PAGE THAT'S MAPPED
	UFPGS			;UPDATE IT
	 JFCL			;WE TRIED
	POP P,T1		;RESTORE PAGE IDENT
	MOVEM T1,CKPGID		;REMEMBER NEW PAGE IDENT
	CALL JFNOFN		;CONVERT TO OFN,,PN
	 BUG (UXXMAP)
	POP P,T2		;RESTORE ACCESS INFO
	HRRI T2,FPG0A		;ADDRS TO MAP PAGE
	CALLRET SETMPG		;MAP THE PAGE
;USAGE QUEUED MESSAGE HANDLER

USGMES:	SAVEAC <Q1,Q2,FX>	;SAVE REGS
USGMS0:	SKIPN Q1,USGBEG		;ANYTHING ON QUEUE?
	RET			;NO - DONE
	LOAD T1,UQFCN,(Q1)	;GET FCN CODE
	CAILE T1,USGLGL		;CHECK VALID
USGBFC:	BUG (UXXILL)
	CALL @USGREQ(T1)	;DISPATCH
	CALL OFFUSQ		;REMOVE FROM QUEUE
	JRST USGMS0		;LOOP TILL DONE

;DISPATCH TABLE

USGREQ:	DTBDSP (USGENT)		;0 - WRITE ENTRY INTO FILE
	DTBDSP (USGCLS)		;1 - CLOSE OUT FILE
	DTBDSP (USGCKU)		;2 - CHECKUOINT
	DTBDSP (USGLGI)		;3 - LOGIN
	DTBDSP (USGLGO)		;4 - LOGOUT
	DTBDSP (USGSEN)		;5 - SESSION ENTRY
	DTBDSP (USGBFC)		;6 - ILLEGAL
	DTBDSP (USGBFC)		;7 - ILLEGAL
	DTBDSP (USGASU)		;10 - Accounting shift change
   USGLGL==.-USGREQ-1

;JOB 0 ROUTINE TO PERFORM CHECKPOINT TIMING

CHKCKP:	MOVE T1,TODCLK		;CURRENT TIME
	CAMGE T1,CKPTIM		;TIME FOR CHECKPOINT?
	RET			;NO - RETURN
	SAVEAC <Q1,Q2,FX>	;SAVE REGS
	MOVE T1,FACTSW		;CHECK IF ACCOUNTING
	TXNE T1,SF%USG		;???
	CALL USGCKP		;YES - CHECKPOINT ALL JOBS
	MOVE T1,TODCLK		;RESET NEXT TIME
	ADD T1,CKPINV		;ADD INTERVAL
	MOVEM T1,CKPTIM		;SAVE NEW TIME
	RET			;RETURN


;Job 0 routine to perform automatic accounting shift change

CHKASC:	SKIPE T1,ASCTIM		;Get next accounting shift change time
	CAMLE T1,TODCLK		;Time for change yet?
	 RET			;Not yet.
	SAVEAC <Q1,Q2,FX>	;Need all the Q's for this...
	MOVE T1,FACTSW		;Get current state bits
	TXNE T1,SF%USG		;Doing accounting today?
	 CALL USGASC		;Yes-- perform accounting shift change
;	CALLRET NXTASC		;Compute next time for change and return from CHKASC
; NXTASC - Compute next accounting shift change time
;
; Register usage in this routine:
; T1/	Current DOW/time table entry
; T2/	Time selected from table (-1 if none found yet)
; T3/	Bit for current DOW (day-of-week) being tested
; T4/	Current pointer to DOW/time table
; Q1/	Bit for DOW of today
; Q2/	Current time in seconds since midnight of the day being tested
;	(will be negative if other than today)

; DOW/time table entry format:
; LH:	Bit n on means that this entry valid on day-of-week (DOW) n
;	(0=Monday)
; RH:	Time-of-day when shift will occur on selected DOWs, in
;	seconds since midnight.

NXTASC::
	SAVEAC <Q1,Q2,FX>	;Need all the Q's
	LOCK ASCLOK		;Lock time table database

	MOVX T2,-1		;Use current date/time
	MOVX T4,0		;No options
	ODCNV			;Get time, day-of-week, etc.
	 ERJMP NXTAS7		;No date/time-- set next time to never
	HRRZ Q2,T4		;Save the seconds since midnight now
	MOVX Q1,1B0		;Get first bit for Monday
	MOVNI T1,(T3)		;Get -ve day of week (0=Monday)
	LSH Q1,(T1)		;Get bit for this day of week in Q1
	MOVE T3,Q1		;Start testing at today's DOW

	MOVX T2,^D<24*60*60>	;Indicate no time found yet

; Loop through table, once for each DOW in the future, until
;  next accounting shift change time is found

NXTAS1:	SKIPN T4,ASCPTR		;Get AOBJN pointer to DOW/time table
	 JRST NXTAS7		;No table-- set next time to infinity

; Loop through table for this DOW to see if any changes this day

NXTAS2:	MOVE T1,(T4)		;Get entry from table
	TDNN T1,T3		;Entry in effect this DOW?
	 JRST NXTAS3		;No-- skip it
	CAIGE Q2,(T1)		;Has the time for this change already past?
	CAIG T2,(T1)		; or have we already found an earlier time?
	 JRST NXTAS3		;Yes to either question-- skip entry
	HRRZ T2,T1		;Found a reasonable time-- remember it

NXTAS3:	AOBJN T4,NXTAS2		;Loop through whole table

	CAIGE T2,^D<24*60*60>	;Find a valid entry?
	 JRST NXTAS8		;Yes-- go compute time from now

; No time found this DOW-- step to next day in future and search table again

	TDNE T3,Q1		;Back to today?
	 JUMPL Q2,NXTAS7	;Yes-- give up if not first time
	SUBI Q2,^D<24*60*60>	;Step current time back another day
	LSH T3,-1		;Shift to next DOW
	TXNE T3,1B7		;Beyond Sunday?
	 MOVX T3,1B0		;Yes-- reset back to Monday
	JRST NXTAS1		;Keep searching table

; No table or no entries with any DOW's-- set next time to infinity

NXTAS7:	SETZ T2,		;Indicate no time set
	JRST NXTAS9		;Store and return

; Found next applicable table entry-- find out when the change should occur

NXTAS8:	SUB T2,Q2		;Compute seconds from now till
				; when entry time will occur
	IMULI T2,^D1000		;Convert to TODCLK units of MS
	ADD T2,TODCLK		;Compute TODCLK time when we will change

NXTAS9:	MOVEM T2,ASCTIM		;Save next change time
	UNLOCK ASCLOK		;Unlock ASCPTR database
	RET			;Return from NXTASC
;WRITE ENTRY INTO FILE FROM QUEUE

USGENT:	MOVE T1,USGJFN		;GET JFN
	MOVEI T2,UQDAT(Q1)	;POINT TO DATA
	HRLI T2,(POINT 36,,)	;FORM BP
	HRRZ T3,UQDAT(Q1)	;GET LENGTH OF ITEM
	ADDM T3,USGEOF		;UPDATE EOF POINTER
	MOVNS T3		;NEGATE
	SOUT			;WRITE IN FILE
	 ERCAL USGIOE		;REPORT ERROR
	MOVE T1,USGEOF		;CALC PAGE JUST WRITTEN
	LSH T1,-PGSFT
	HRL T1,USGJFN		;FORM IDENT
	MOVEI T2,1		;DO ONE PAGE
	UFPGS			;UPDATE FILE PAGE
	 ERCAL USGIOE		;OH WELL...
	RET			;DONE

;CLOSE OUT CURRENT FILE AND START A NEW ONE

USGCLS:	STKVAR <NJFN>
	CALL CRUSGF		;CREATE A NEW FILE
	 JRST [	BUG (UXXCL1)
		RET]		;JUST EXIT - NOTHING DONE
	HRROI T2,USGFIL		;NOW OPEN IT
	CALL USGOPN
	 JRST [	BUG (UXXCL2)
		RET]		;TOUGH AGAIN
	MOVEM T1,NJFN		;SAVE NEW JFN
	MOVE T1,USGJFN		;GET CURRENT JFN
	HRLI T1,.FBCTL		;THIS WORD
	TXO T1,CF%NUD		;DONT UPDATE DIR
	MOVX T2,FB%NOD		;SET TO CLEAR THIS BIT
	SETZ T3,		; TO ALLOW FILE TO DUMP
	CHFDB
	 ERJMP .+1		;WE TRIED
	HRRZS T1		;RESTORE JFN
	CLOSF			;CLOSE OUT FILE
	 BUG (UXXCL3)
	SETZM USGEOF		;SETUP FOR NEW FILE
	MOVE T1,NJFN
	MOVEM T1,USGJFN		;NOW HAVE NEW FILE TO USE
	UNLOCK (USGLOK)		;UNLOCK WAITER
	RET			;RETURN
;ROUTINE TO SET CHECKPOINT FROM QUEUE
;RETURNS: Q2/ PAGE IDENT

UCKSET:	HRRZ T1,UQDAT+2(Q1)	;GET JOB #
	CALL USGSPG		;SET CHECKPOINT PAGE
	MOVE Q2,T1		;SAVE IDENT
	MOVEI T1,2(T4)		;SET FROM,,TO FOR CLEAR
	HRLI T1,1(T4)		;...
	SETZM 1(T4)		;ZERO FIRST WORD
	BLT T1,CKPSIZ-1(T4)	;CLEAR
	MOVEI T1,1(T4)		;POINT TO DESTINATION
	HRLI T1,UQDAT(Q1)	; LHS := DATA
	HRRZ T2,UQDAT(Q1)	;GET LENGTH
	ADD T2,T4		;LAST WORD OF XFER
	BLT T1,0(T2)		;MOVE DATA
	SETZM 0(T4)		;MARK ITEM INUSE
	RET			;RETURN DONE

;HANDLE USAGE LOGIN

USGLGI:	CALL UCKSET		;COPY DATA TO CHECKPOINT
	CALLRET UNMAPC		;EXIT AND UNMAP PAGE

;HANDLE USAGE LOGOUT

USGLGO:	CALL UCKSET		;COPY DATA TO CHECKPOINT
	MOVE T1,Q2		;SETUP IDENT
	CALL USGUP0		;UPDATE USAGE FILE (CLEAR CKPT)
	CALLRET UNMAPC		;EXIT AND UNMAP PAGE

;HANDLE SESSION END

USGSEN:	HRRZ T1,UQDAT+2(Q1)	;SETUP JOB NUMBER
	CALL USGSPG		;MAP CHECKPOINT ENTRY
	PUSH P,T4		;SAVE ADDRS
	HRRZ T3,1(T4)		;CALC POINTER TO CHECKPOINT DATA
	ADDI T3,CKOFF(T4)
	HRRZ T2,UQDAT(Q1)	;CALC POINTER INTO QUEUE ENTRY
	ADDI T2,CKOFF+1(Q1)	; FOR CKPT DATA
	MOVE T4,1(T2)		;UPDATE CHECKPOINT FILE
	MOVEM T4,1(T3)		; DATA FOR RUNTIME AND
	MOVE T4,2(T2)		; CONSOLE CONNECT TIME
	MOVEM T4,2(T3)
	POP P,T4		;RESTORE ADDRS
	CALL USGUP0		;MERGE INTO USAGE FILE(T1 AND T4 SETUP)
	CALL UCKSET		;COPY NEW CHECKPOINT INFO
	HRRZ T1,1(T4)		;NOW SETUP TO CLEAR CHECKPOINT
	ADDI T1,CKOFF(T4)
	SETZM 1(T1)		;DATA FOR RUTIME AND CONNECT
	SETZM 2(T1)		;...
	CALLRET UNMAPC		;UNMAP CHECKPOINT PAGE
;ROUTINE TO UPDATE CHECKPOINT ENTRY FOR A SINGLE JOB
; T1/ JOB NUMBER

CPOINT:	SETZM ASCFLG		;Don't perform accounting shift change
CPONT0:	SAVEAC <Q1,Q2,FX>	;SAVE REGS
	STKVAR <PGID,CPAD,CPIP>	;Page ident, chekpoint address,
				; checkpoint item AOBJN pointer
	MOVE Q1,T1		;SAVE JOB # IN Q1
	CALL USGSPG		;SET CHECKPOINT PAGE
	MOVEM T1,PGID		;Save checkpoint page address in PGID
	MOVEM T4,CPAD		;Save address within page in CPAD
	HRRZ FX,1(T4)		;GET LENGTH OF ENTRY
	ADDI FX,CKOFF(T4)	;POINT TO CHECKPOINT DATA
	HRLI FX,-CKITMS		;FORM AOBJN PNTR
	MOVEM FX,CPIP		;Save checkpoint item pointer
	CALL LGTAD		;GET CURRENT DATE/TIME
	MOVEM T1,2(T4)		; INTO CHECKPOINT RECORD
	MOVE T1,Q1		;JOB #
	NOSKED			;DO THIS NOSKED
	SKIPN JOBDIR(T1)	;JOB LOGGED IN?
	JRST [	OKSKED		;NO - JUST RETURN
		JRST CPNT3]
	CALL SETJSB		;MAP JSB FOR JOB
	OKSKED			;JOB IS NOW FIXED IN MY MAP
	MOVE T3,T1		;SAVE PNTR IN T3
	MOVEI Q2,0		;INIT INDEX TO 0
CPNT1:	XCT CPTBL(Q2)		;FETCH WORD
	MOVEM T1,0(FX)		;STORE
	AOS Q2			;STEP TO NEXT TABLE ENTRY
	AOBJN FX,CPNT1

	SKIPN ASCFLG		;This accounting shift change also?
	 JRST CPNT2		;No-- go on

; Accounting shift change-- update USAGE file

	MOVE T1,PGID		;Get page ident
	MOVE T4,CPAD		;Address within page
	PUSH P,T3		;Save JSB pointer
	CALL USGUPS		;Make new USAGE entry
	SETZM 0(T4)		;Indicate checkpoint entry still in use
	POP P,T3		;Restore JSB pointer

; Reset job statistics and set new checkpoint entry

	MOVE FX,CPIP		;Get checkpoint item pointer
	MOVEI Q2,0		;INIT INDEX TO 0
CPNT11:	MOVE T1,0(FX)		;Get old value
	XCT SETBL(Q2)		;Reset current value of data item
	XCT CPTBL(Q2)		;Get new value of data item
	MOVEM T1,0(FX)		;STORE
	AOS Q2			;STEP TO NEXT TABLE ENTRY
	AOBJN FX,CPNT11

CPNT2:	CALL CLRJSB		;UNMAP JSB
CPNT3:	RET			;RETURN FROM CPOINT

;CHECKPOINT DATA TABLE

CPTBL:	MOVE T1,CTIMON(T3)	;(0) SESSION START TIME
	CALL CPGCON		;(1) GET CONNECT TIME
	CALL CPGRTM		;(2) JOB RUN TIME

;Checkpoint data routines

CPGCON:	MOVE T1,TODCLK		;CURRENT DATE/TIME
	SUB T1,CONSTO(T3)	; LESS START TIME
	SUB T1,JSSCTM(T3)	; from start of session
	RET			;GIVES CONNECT TIME

CPGRTM:	MOVE T1,JOBRT(Q1)	;Get job runtime
	SUB T1,JSSRTM(T3)	; from start of session
	RET			;Return from CPGRTM

;Session End data table

SETBL:	CALL SESCTI		;(0) Date/time of session start
	ADDM T1,JSSCTM(T3)	;(1) Console time start of session
	ADDM T1,JSSRTM(T3)	;(2) Runtime start of session

;Session End data routines

SESCTI:	CALL LGTAD		;Get current date/time
	MOVEM T1,CTIMON(T3)	;Set start of new session
	RET			;Return from SESCTI


;PERFORM CHECKPOINT OVER ALL JOBS

USGCKU:	CALL USGCKP		;DO WORK
	JRST USGULR		;Unlock waiter and return

;Perform accounting shift change

USGASU:	CALL USGASC		;Do work
USGULR:	UNLOCK (USGLOK)		;UNLOCK WAITER
	RET			;RETURN

;Internal routine to perform checkpoint of all jobs
; or accounting shift change

USGCKP:	SETZM ASCFLG		;Note not accounting shift change
	JRST USGC00		;Continue

USGASC:	SETOM ASCFLG		;Note accounting shift change
USGC00:	MOVEI Q1,NJOBS-1	;MAX JOBS TO DO

; Loop over all active jobs

USGCK0:	SKIPN JOBDIR(Q1)	;JOB EXIST AND IS LOGGED IN?
	JRST USGCK1		;NO - STEP TO NEXT
	MOVE T1,Q1		;COPY JOB #
	CALL CPONT0		;CHECKPOINT ONE JOB
USGCK1:	SOJG Q1,USGCK0		;LOOP OVER ALL
	MOVEI T1,0		;MAP JOB 0 ENTRY
	CALL USGSPG		;...
	MOVE Q1,T4		;POINTER TO ENTRY
	MOVE Q2,T1		;PAGE IDENT
	CALL LGTAD		;GET CURRENT DATE/TIME
	MOVEM T1,2(Q1)		;UPDATE DATE/TIME OF CKPOINT
	MOVE T1,Q2		;UNMAP PAGE
	CALLRET UNMAPC		; AND EXIT

	RESCD

	TNXEND
	END
