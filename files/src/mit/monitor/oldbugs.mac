; UPD ID= 509, SNARK:<5.MONITOR>BUGS.MAC.79,   6-Mar-82 20:59:15 by PAETZOLD
;Once again.  Fix comment from edit 504.  It is pretty bad when you have
; to fix a comment twice
; UPD ID= 508, SNARK:<5.MONITOR>BUGS.MAC.78,   6-Mar-82 20:53:28 by PAETZOLD
;Correct comment in previous edit
; UPD ID= 504, SNARK:<5.MONITOR>BUGS.MAC.77,   6-Mar-82 20:51:26 by PAETZOLD
;TCO 5.1750 - Add IMPAB2, document IMPABF.
; UPD ID= 485, SNARK:<5.MONITOR>BUGS.MAC.76,  24-Feb-82 12:17:55 by PAETZOLD
;TCO 5.1735 - EBSPER and IOPGF now contain the IOP word
; UPD ID= 429, SNARK:<5.MONITOR>BUGS.MAC.75,  22-Jan-82 06:46:38 by GRANT
;TCO 5.1695 - Add WAITNI
; UPD ID= 391, SNARK:<5.MONITOR>BUGS.MAC.74,  12-Jan-82 09:48:56 by PAETZOLD
;TCO 5.1665 - Add TTLOKB and TTULKB
; UPD ID= 370, SNARK:<5.MONITOR>BUGS.MAC.73,  22-Dec-81 11:21:20 by GRANT
;Document TTYBBO
; UPD ID= 335, SNARK:<5.MONITOR>BUGS.MAC.72,   2-Dec-81 20:42:17 by PAETZOLD
;Add comment to previous edit on behalf of MOSER
;Change ACTBAD to ACTBBD to avoid conflict with DIRECT
; UPD ID= 322, SNARK:<5.MONITOR>BUGS.MAC.71,  18-Nov-81 10:55:47 by MOSER
;Add ACTBAD
; UPD ID= 284, SNARK:<5.MONITOR>BUGS.MAC.70,  21-Oct-81 17:25:05 by GRANT
;TCO 5.1593 - Add NSPRSN
; UPD ID= 228, SNARK:<5.MONITOR>BUGS.MAC.69,  29-Sep-81 09:38:18 by DONAHUE
;TCO 5.1523 - MAKE CLRACE A BUGCHK
; UPD ID= 154, SNARK:<5.MONITOR>BUGS.MAC.68,   8-Sep-81 17:32:01 by GRANT
;NSPACK - part of TCO 5.1490
; UPD ID= 110, SNARK:<5.MONITOR>BUGS.MAC.67,  20-Aug-81 15:50:56 by ZIMA
;More of 5.1458.
; UPD ID= 107, SNARK:<5.MONITOR>BUGS.MAC.66,  20-Aug-81 15:19:09 by ZIMA
;TCO 5.1458 - Change IMPPHY to IMAN22 and IMPANX for Autopatch consistency.
; Add IM2NII as AN22 equivalent of IMPNII.
; UPD ID= 68, SNARK:<5.MONITOR>BUGS.MAC.65,  23-Jul-81 13:35:35 by PAETZOLD
; UPD ID= 67, SNARK:<5.MONITOR>BUGS.MAC.64,  23-Jul-81 12:22:36 by PAETZOLD
;IMPIOP
; UPD ID= 60, SNARK:<5.MONITOR>BUGS.MAC.63,  22-Jul-81 11:24:16 by MURPHY
;TCO 5.1428 - HPSCHK
; UPD ID= 43, SNARK:<5.MONITOR>BUGS.MAC.62,  17-Jul-81 16:16:56 by MURPHY
;TCO 5.1398 - MAPCLF
; UPD ID= 2312, SNARK:<5.MONITOR>BUGS.MAC.61,   8-Jul-81 15:39:16 by MURPHY
;TCO 5.1398 - PGUNDX
; UPD ID= 2261, SNARK:<5.MONITOR>BUGS.MAC.60,  26-Jun-81 18:06:13 by MURPHY
;TCO 5.1376 - ITRLGO, EXILGO
; UPD ID= 2229, SNARK:<5.MONITOR>BUGS.MAC.59,  19-Jun-81 16:30:13 by GRANT
;NSPBAD
; UPD ID= 2217, SNARK:<5.MONITOR>BUGS.MAC.58,  19-Jun-81 08:32:12 by GRANT
;DTEBAD
; UPD ID= 2170, SNARK:<5.MONITOR>BUGS.MAC.57,  10-Jun-81 15:47:33 by MURPHY
;REMOVE SCDOVF, INSERT SCDBAD
; UPD ID= 2121, SNARK:<5.MONITOR>BUGS.MAC.56,   3-Jun-81 17:04:04 by PAETZOLD
;MORE OF TCO 5.1318 ADD BAD DATA WORD TO UPTMPE AND EPTMPE
; UPD ID= 2081, SNARK:<5.MONITOR>BUGS.MAC.55,  26-May-81 15:12:16 by GRANT
;DTEIPR
; UPD ID= 2038, SNARK:<5.MONITOR>BUGS.MAC.54,  19-May-81 17:04:43 by PAETZOLD
;TCO 5.1335 ADD OKSKBG BUGHLT
; UPD ID= 2007, SNARK:<5.MONITOR>BUGS.MAC.53,  15-May-81 09:41:53 by SCHMITT
;tco 5.1319 - Change reference to C in SWPASF to T3
; UPD ID= 1987, SNARK:<5.MONITOR>BUGS.MAC.52,  14-May-81 10:39:57 by PAETZOLD
;FIX YET ANOTHER TYPO
; UPD ID= 1986, SNARK:<5.MONITOR>BUGS.MAC.51,  14-May-81 10:33:45 by PAETZOLD
;FIX A TYPO IN PREVIOUS
; UPD ID= 1983, SNARK:<5.MONITOR>BUGS.MAC.50,  13-May-81 09:36:49 by PAETZOLD
;TCO 5.1321 ADD IMPBLK BUGCHK AND IMPMMX BUGINF
; UPD ID= 1973, SNARK:<5.MONITOR>BUGS.MAC.49,  11-May-81 11:08:54 by PAETZOLD
;TCO 5.1318 ADD UPTMPE AND EPTMPE.  ALSO IMPROVE UNXMPE BY DISPLAYING
;SOME DATA
; UPD ID= 1934, SNARK:<5.MONITOR>BUGS.MAC.48,   4-May-81 15:33:53 by GRANT
;Add optional data to DELNDF
; UPD ID= 1927, SNARK:<5.MONITOR>BUGS.MAC.47,   4-May-81 09:43:00 by GRANT
;Add FORKN additional data to FLKNS
; UPD ID= 1890, SNARK:<5.MONITOR>BUGS.MAC.46,  26-Apr-81 21:37:48 by GRANT
;CHANGE DELNDF FROM HLT TO INF;  ADD NSPGON, NSPLAT, NSPNOD
; UPD ID= 1746, SNARK:<5.MONITOR>BUGS.MAC.45,  19-Mar-81 23:11:09 by MURPHY
;TTYSTP
; UPD ID= 1670, SNARK:<5.MONITOR>BUGS.MAC.44,  11-Mar-81 17:14:21 by MURPHY
;Change SKDCL1, remove SKDCL2
; UPD ID= 1620, SNARK:<5.MONITOR>BUGS.MAC.43,   2-Mar-81 07:48:31 by WACHS
;TCO 5.1267 - Add TM8AEI
; UPD ID= 1591, SNARK:<5.MONITOR>BUGS.MAC.42,  26-Feb-81 17:42:07 by MURPHY
;NODTEN
; UPD ID= 1571, SNARK:<5.MONITOR>BUGS.MAC.41,  19-Feb-81 15:09:37 by HALL
;TCO 5.1180 - Change optional data on GDSTX0
; UPD ID= 1539, SNARK:<5.MONITOR>BUGS.MAC.40,   9-Feb-81 12:54:30 by HALL
;TCO 5.1180 - Add GDSTX0 BUGHLT
; UPD ID= 1527, SNARK:<5.MONITOR>BUGS.MAC.39,   6-Feb-81 12:47:19 by ZIMA
;TCO 5.1258 - Remove DMPRLF.
; UPD ID= 1467, SNARK:<5.MONITOR>BUGS.MAC.38,  21-Jan-81 21:51:05 by GRANT
;DTERES
; UPD ID= 1461, SNARK:<5.MONITOR>BUGS.MAC.37,  20-Jan-81 17:37:06 by MURPHY
;TTQADX
; UPD ID= 1410, SNARK:<5.MONITOR>BUGS.MAC.36,   6-Jan-81 15:07:15 by MURPHY
;NOINTL
; UPD ID= 1368, SNARK:<5.MONITOR>BUGS.MAC.35,  18-Dec-80 11:11:26 by WACHS
; TCO 5,1206 ADD TM78 BUG DEFINITIONS
; UPD ID= 1330, SNARK:<5.MONITOR>BUGS.MAC.34,   1-Dec-80 17:29:52 by LYONS
; UPD ID= 1306, SNARK:<5.MONITOR>BUGS.MAC.33,  21-Nov-80 16:46:48 by ELFSTROM
; FIX TYPO IN ABKSKD
; UPD ID= 1272, SNARK:<5.MONITOR>BUGS.MAC.32,  14-Nov-80 15:55:04 by ELFSTROM
; CHANGE SYNTAX OF DOCUMENTATION FOR CKPLEN
; UPD ID= 1247, SNARK:<5.MONITOR>BUGS.MAC.31,   7-Nov-80 15:00:59 by SCHMITT
;TCO 5.1194 - Add CKPLEN
; UPD ID= 1230, SNARK:<5.MONITOR>BUGS.MAC.30,   4-Nov-80 11:50:08 by GRANT
;Add RESCHK
; UPD ID= 1229, SNARK:<5.MONITOR>BUGS.MAC.29,   4-Nov-80 11:44:43 by ELFSTROM
;make DIAG JSYS uppercase in DGUTPG, remove some empty Action: sections,
;make GTFDB3 upper- and lowercase, fix syntax of text in various BUGHLT's
; UPD ID= 1136, SNARK:<5.MONITOR>BUGS.MAC.27,   6-Oct-80 16:31:17 by LYONS
;document some more bughlts
; UPD ID= 1107, SNARK:<5.MONITOR>BUGS.MAC.26,   2-Oct-80 13:11:27 by HALL
;ADD DXBTNF FOR UHLER
; UPD ID= 1100, SNARK:<5.MONITOR>BUGS.MAC.25,   1-Oct-80 17:42:00 by MILLER
;add description for SCDUUO
; UPD ID= 1098, SNARK:<5.MONITOR>BUGS.MAC.24,   1-Oct-80 16:23:44 by HALL
;IMPROVE ON GTFDB3
; UPD ID= 1097, SNARK:<5.MONITOR>BUGS.MAC.23,   1-Oct-80 16:16:58 by BLOUNT
;Remove ATNOMS
; UPD ID= 1066, SNARK:<5.MONITOR>BUGS.MAC.22,  30-Sep-80 11:02:24 by GRANT
;Document NSPRTH
; UPD ID= 948, SNARK:<5.MONITOR>BUGS.MAC.21,  21-Aug-80 18:32:14 by ENGEL
;CHANGE RELODR TO RELORD
; UPD ID= 946, SNARK:<5.MONITOR>BUGS.MAC.19,  21-Aug-80 13:08:25 by ENGEL
; UPD ID= 940, SNARK:<5.MONITOR>BUGS.MAC.17,  20-Aug-80 15:19:38 by ENGEL
;TCO #5.1136 - CHANGE ALL LOCKS TO CONFORM TO THE NEW LOCK SCHEME
; UPD ID= 901, SNARK:<5.MONITOR>BUGS.MAC.16,  14-Aug-80 15:45:16 by LYONS
;TCO 5.1062 - Add a SWPXXX bughlt and change SWPUPT,SWPPSB,SWPPT, and SWPPTP
;to be only bugchks
; UPD ID= 847, SNARK:<5.MONITOR>BUGS.MAC.15,   6-Aug-80 17:33:10 by MURPHY
;LLLKDB
; UPD ID= 827, SNARK:<5.MONITOR>BUGS.MAC.14,   4-Aug-80 10:27:08 by GRANT
;Add optional data to RESBAD, RESBAZ, and RESBND
; UPD ID= 793, SNARK:<5.MONITOR>BUGS.MAC.13,  23-Jul-80 21:33:43 by MURPHY
;NOMCCD
; UPD ID= 781, SNARK:<5.MONITOR>BUGS.MAC.12,  23-Jul-80 11:01:43 by MURPHY
;NEGJRT should have been a CHK
; UPD ID= 766, SNARK:<5.MONITOR>BUGS.MAC.11,  18-Jul-80 17:30:38 by LEACHE
;Make RELRNG a BUGCHK
; UPD ID= 762, SNARK:<5.MONITOR>BUGS.MAC.10,  18-Jul-80 15:20:28 by MURPHY
;NEGJRT
; UPD ID= 726, SNARK:<5.MONITOR>BUGS.MAC.9,   2-Jul-80 12:11:17 by LYONS
; UPD ID= 696, SNARK:<5.MONITOR>BUGS.MAC.8,  25-Jun-80 15:30:49 by DBELL
;TCO 5.1078 - ADD ADDITIONAL DATA TO DIRECTORY RELATED BUGCHKS
; UPD ID= 643, SNARK:<5.MONITOR>BUGS.MAC.7,  16-Jun-80 01:29:58 by DBELL
;TCO 5.1066 - ADD FUNCTION CODE AS ADDITIONAL DATA FOR OVRDTA
; UPD ID= 562, SNARK:<5.MONITOR>BUGS.MAC.6,  28-May-80 11:30:12 by KONEN
;ADD DNOPT0 AND GTFDB3
; UPD ID= 515, SNARK:<4.1.MONITOR>BUGS.MAC.169,  13-May-80 10:24:53 by DBELL
;ADD ADDITIONAL DATA TO LOTS OF PHYP2 BUGS
; UPD ID= 425, SNARK:<4.1.MONITOR>BUGS.MAC.168,   9-Apr-80 15:31:51 by DBELL
;DOCUMENT DGUTPG, DGZTPA, AND MTARIN BUGHLTS
; UPD ID= 422, SNARK:<4.1.MONITOR>BUGS.MAC.167,   9-Apr-80 09:51:36 by ENGEL
;DOCUMENT SERFRK
; UPD ID= 418, SNARK:<4.1.MONITOR>BUGS.MAC.166,   8-Apr-80 11:53:17 by LYONS
;DOCUMENT ARPA BUGHLTS
; UPD ID= 415, SNARK:<4.1.MONITOR>BUGS.MAC.165,   5-Apr-80 12:47:30 by DBELL
;FIX RP4SSC BUG DEFINITION
; UPD ID= 412, SNARK:<4.1.MONITOR>BUGS.MAC.164,   4-Apr-80 14:07:04 by ELFSTROM
; UPD ID= 402, SNARK:<4.1.MONITOR>BUGS.MAC.163,   2-Apr-80 16:36:30 by ELFSTROM
; UPD ID= 398, SNARK:<4.1.MONITOR>BUGS.MAC.162,   2-Apr-80 14:29:25 by ELFSTROM
; UPD ID= 390, SNARK:<4.1.MONITOR>BUGS.MAC.161,  28-Mar-80 14:52:13 by DBELL
;FIX ARGUMENTS FOR NOBAT1 AND NOBAT2 BUGCHKS
; UPD ID= 381, SNARK:<4.1.MONITOR>BUGS.MAC.160,  26-Mar-80 16:31:05 by HALL
;fix typo
; UPD ID= 377, SNARK:<4.1.MONITOR>BUGS.MAC.159,  26-Mar-80 15:28:24 by DBELL
;INSERT SOME MORE RP20 BUGS AND UPPERCASE DSKALC BUGS
; UPD ID= 355, SNARK:<4.1.MONITOR>BUGS.MAC.158,  26-Mar-80 11:06:09 by DBELL
;TCO 4.1.1119 - INSERT PHYP2 BUG DEFINITIONS FOR RP20 DISKS
; UPD ID= 353, SNARK:<4.1.MONITOR>BUGS.MAC.157,  25-Mar-80 12:23:37 by HALL
;CLEANUP of APRSRV BUG's
; UPD ID= 350, SNARK:<4.1.MONITOR>BUGS.MAC.156,  24-Mar-80 17:04:05 by ELFSTROM
; UPD ID= 327, SNARK:<4.1.MONITOR>BUGS.MAC.155,  12-Mar-80 19:34:43 by ELFSTROM
; UPD ID= 316, SNARK:<4.1.MONITOR>BUGS.MAC.154,  11-Mar-80 10:30:47 by GRANT
; UPD ID= 315, SNARK:<4.1.MONITOR>BUGS.MAC.153,  11-Mar-80 10:20:32 by ELFSTROM
; UPD ID= 313, SNARK:<4.1.MONITOR>BUGS.MAC.152,  10-Mar-80 16:42:52 by GRANT
;Document DUPCOR
; UPD ID= 311, SNARK:<4.1.MONITOR>BUGS.MAC.150,  10-Mar-80 16:04:39 by ELFSTROM
; UPD ID= 300, SNARK:<4.1.MONITOR>BUGS.MAC.149,  29-Feb-80 16:33:56 by ELFSTROM
; UPD ID= 298, SNARK:<4.1.MONITOR>BUGS.MAC.148,  28-Feb-80 16:29:48 by ELFSTROM
; UPD ID= 296, SNARK:<4.1.MONITOR>BUGS.MAC.147,  27-Feb-80 13:11:18 by ELFSTROM
; UPD ID= 293, SNARK:<4.1.MONITOR>BUGS.MAC.146,  22-Feb-80 15:03:18 by ELFSTROM
; UPD ID= 281, SNARK:<4.1.MONITOR>BUGS.MAC.144,  20-Feb-80 10:48:07 by ELFSTROM
; UPD ID= 260, SNARK:<4.1.MONITOR>BUGS.MAC.143,  13-Feb-80 15:27:58 by HALL
;Add analysis to APRNX1
; UPD ID= 255, SNARK:<4.1.MONITOR>BUGS.MAC.142,   8-Feb-80 13:51:05 by HALL
;remove mpedev - the code is commented out of aprsrv
;more aprsrv
; UPD ID= 253, SNARK:<4.1.MONITOR>BUGS.MAC.141,   7-Feb-80 17:18:25 by HALL
;more aprsrv bughlt's
;Change ILPSEC BUGCHK to BUGHLT
; UPD ID= 250, SNARK:<4.1.MONITOR>BUGS.MAC.140,   6-Feb-80 17:25:49 by HALL
;ADD SOME APRSRV BUGHLT'S
; UPD ID= 248, SNARK:<4.1.MONITOR>BUGS.MAC.139,   6-Feb-80 10:16:56 by ELFSTROM
; UPD ID= 222, SNARK:<4.1.MONITOR>BUGS.MAC.138,  24-Jan-80 16:13:31 by HALL
;remove pagem BUGHLT's ilrnsk and ilppt2 - code is assembled out
; UPD ID= 211, SNARK:<4.1.MONITOR>BUGS.MAC.137,  21-Jan-80 12:32:34 by HALL
;UBANXM - MAKE THE OPTIONAL DATA NAMES LEGAL
; UPD ID= 210, SNARK:<4.1.MONITOR>BUGS.MAC.136,  18-Jan-80 16:26:42 by HALL
; UPD ID= 209, SNARK:<4.1.MONITOR>BUGS.MAC.135,  18-Jan-80 15:11:26 by HALL
;MORE PAGEM BUGHLTS
; UPD ID= 207, SNARK:<4.1.MONITOR>BUGS.MAC.134,  16-Jan-80 17:07:42 by HALL
;ADD PAGEM BUGHLTS
; UPD ID= 203, SNARK:<4.1.MONITOR>BUGS.MAC.133,  16-Jan-80 13:44:24 by ENGEL
;IMPROVE THE SPELLING
; UPD ID= 187, SNARK:<4.1.MONITOR>BUGS.MAC.132,   8-Jan-80 09:09:11 by GRANT
;Document NSPSRV BUGHLTs
; UPD ID= 182, SNARK:<4.1.MONITOR>BUGS.MAC.131,   3-Jan-80 09:04:03 by R.ACE
;ADD COPYRIGHT NOTICE
; UPD ID= 175, SNARK:<4.1.MONITOR>BUGS.MAC.130,  21-Dec-79 16:18:02 by GRANT
;Document DTESRV BUGHLTs
; UPD ID= 174, SNARK:<4.1.MONITOR>BUGS.MAC.129,  21-Dec-79 09:10:15 by GRANT
;Document TTYSRV BUGHLTs
; UPD ID= 173, SNARK:<4.1.MONITOR>BUGS.MAC.128,  20-Dec-79 15:41:59 by OSMAN
;Document STZERO
; UPD ID= 172, SNARK:<4.1.MONITOR>BUGS.MAC.127,  20-Dec-79 15:38:09 by OSMAN
;Document NOFEFS
; UPD ID= 171, SNARK:<4.1.MONITOR>BUGS.MAC.126,  20-Dec-79 15:24:18 by OSMAN
;Document NOBTBN
; UPD ID= 169, SNARK:<4.1.MONITOR>BUGS.MAC.125,  20-Dec-79 14:27:52 by OSMAN
;Document NEWROT
; UPD ID= 168, SNARK:<4.1.MONITOR>BUGS.MAC.124,  20-Dec-79 14:22:39 by OSMAN
;Document NEWBAK
; UPD ID= 167, SNARK:<4.1.MONITOR>BUGS.MAC.123,  20-Dec-79 14:16:51 by OSMAN
;Document IDXNOS
; UPD ID= 166, SNARK:<4.1.MONITOR>BUGS.MAC.122,  20-Dec-79 14:00:01 by OSMAN
;Document IBOFN%F
; UPD ID= 165, SNARK:<4.1.MONITOR>BUGS.MAC.121,  20-Dec-79 13:54:21 by OSMAN
;Document BOOTLK
; UPD ID= 164, SNARK:<4.1.MONITOR>BUGS.MAC.120,  20-Dec-79 13:40:03 by OSMAN
;Document FILRID
; UPD ID= 162, SNARK:<4.1.MONITOR>BUGS.MAC.119,  19-Dec-79 16:45:44 by OSMAN
;Document FILMAP
; UPD ID= 161, SNARK:<4.1.MONITOR>BUGS.MAC.118,  19-Dec-79 15:31:23 by OSMAN
;Document FILIRD
; UPD ID= 160, SNARK:<4.1.MONITOR>BUGS.MAC.117,  19-Dec-79 15:20:22 by OSMAN
;Document FILBTB
; UPD ID= 159, SNARK:<4.1.MONITOR>BUGS.MAC.116,  19-Dec-79 14:55:24 by OSMAN
;Document BTBCRT
; UPD ID= 158, SNARK:<4.1.MONITOR>BUGS.MAC.115,  19-Dec-79 14:46:38 by OSMAN
;Document BTBCR1
; UPD ID= 157, SNARK:<4.1.MONITOR>BUGS.MAC.114,  19-Dec-79 14:36:11 by OSMAN
;Document BADXTB
; UPD ID= 156, SNARK:<4.1.MONITOR>BUGS.MAC.113,  19-Dec-79 14:15:55 by OSMAN
;Document BADXT1
; UPD ID= 155, SNARK:<4.1.MONITOR>BUGS.MAC.112,  18-Dec-79 16:15:05 by KONEN
;Add more bugs
; UPD ID= 154, SNARK:<4.1.MONITOR>BUGS.MAC.111,  18-Dec-79 10:37:29 by OSMAN
;Document BADROT
; UPD ID= 153, SNARK:<4.1.MONITOR>BUGS.MAC.110,  18-Dec-79 10:20:18 by OSMAN
;Document BADREC
; UPD ID= 152, SNARK:<4.1.MONITOR>BUGS.MAC.109,  18-Dec-79 09:38:57 by OSMAN
;Document UXXOPN
; UPD ID= 151, SNARK:<4.1.MONITOR>BUGS.MAC.108,  18-Dec-79 09:28:38 by OSMAN
;Document UXXMAP
; UPD ID= 149, SNARK:<4.1.MONITOR>BUGS.MAC.107,  18-Dec-79 09:07:41 by OSMAN
;Document UXXILL
; UPD ID= 148, SNARK:<4.1.MONITOR>BUGS.MAC.106,  17-Dec-79 11:26:13 by OSMAN
;Document UXXCRE
; UPD ID= 147, SNARK:<4.1.MONITOR>BUGS.MAC.105,  17-Dec-79 11:16:38 by OSMAN
;Document UXXCKP
; UPD ID= 146, SNARK:<4.1.MONITOR>BUGS.MAC.104,  17-Dec-79 10:45:01 by OSMAN
;Document TTBAD1
; UPD ID= 145, SNARK:<4.1.MONITOR>BUGS.MAC.103,  17-Dec-79 10:22:57 by OSMAN
;Document STRTER
; UPD ID= 144, SNARK:<4.1.MONITOR>BUGS.MAC.102,  17-Dec-79 10:12:37 by OSMAN
;Document ILBOOT
; UPD ID= 143, SNARK:<4.1.MONITOR>BUGS.MAC.101,  17-Dec-79 09:58:33 by OSMAN
;Document HSYFRK
; UPD ID= 142, SNARK:<4.1.MONITOR>BUGS.MAC.100,  17-Dec-79 09:52:22 by OSMAN
;Document EXPAFK
; UPD ID= 141, SNARK:<4.1.MONITOR>BUGS.MAC.99,  17-Dec-79 09:41:52 by OSMAN
;Document BOOTMP
; UPD ID= 140, SNARK:<4.1.MONITOR>BUGS.MAC.98,  17-Dec-79 09:11:20 by OSMAN
;Document BOOTER
; UPD ID= 139, SNARK:<4.1.MONITOR>BUGS.MAC.97,  17-Dec-79 08:54:24 by OSMAN
;Document BOOTCR
; UPD ID= 138, SNARK:<4.1.MONITOR>BUGS.MAC.96,  17-Dec-79 08:32:57 by OSMAN
;Remove "submit an SPR" lines
; UPD ID= 137, SNARK:<4.1.MONITOR>BUGS.MAC.95,  15-Dec-79 16:51:17 by KONEN
;Add collection of bugs
; UPD ID= 135, SNARK:<4.1.MONITOR>BUGS.MAC.94,  13-Dec-79 11:14:50 by OSMAN
;Document NSPUDF
; UPD ID= 134, SNARK:<4.1.MONITOR>BUGS.MAC.93,  13-Dec-79 10:57:42 by OSMAN
;DOCUMENT NOXADR
; UPD ID= 132, SNARK:<4.1.MONITOR>BUGS.MAC.92,  13-Dec-79 10:48:03 by OSMAN
;Document DRUMP1
; UPD ID= 131, SNARK:<4.1.MONITOR>BUGS.MAC.91,  13-Dec-79 10:26:02 by OSMAN
;Document DDLCOR
; UPD ID= 128, SNARK:<4.1.MONITOR>BUGS.MAC.90,  12-Dec-79 15:37:43 by OSMAN
;Document DUPUBA
; UPD ID= 126, SNARK:<4.1.MONITOR>BUGS.MAC.89,  12-Dec-79 15:31:46 by OSMAN
;Document KMCIII
; UPD ID= 125, SNARK:<4.1.MONITOR>BUGS.MAC.88,  12-Dec-79 14:48:24 by OSMAN
;Document NLWA and NCDWA
; UPD ID= 122, SNARK:<4.1.MONITOR>BUGS.MAC.87,  10-Dec-79 15:08:24 by DBELL
;DOCUMENT ALL PHYP4 BUGS
; UPD ID= 120, SNARK:<4.1.MONITOR>BUGS.MAC.86,  10-Dec-79 09:51:29 by OSMAN
;Document DZCLRB
; UPD ID= 118, SNARK:<4.1.MONITOR>BUGS.MAC.85,  10-Dec-79 09:36:11 by OSMAN
;Document RH11CC
; UPD ID= 117, SNARK:<4.1.MONITOR>BUGS.MAC.84,  10-Dec-79 09:17:56 by OSMAN
;document RH1ICF
; UPD ID= 116, SNARK:<4.1.MONITOR>BUGS.MAC.83,  10-Dec-79 09:16:52 by OSMAN
; UPD ID= 115, SNARK:<4.1.MONITOR>BUGS.MAC.82,  10-Dec-79 08:57:37 by OSMAN
;Document CLRACE
; UPD ID= 109, SNARK:<4.1.MONITOR>BUGS.MAC.81,   7-Dec-79 10:02:52 by OSMAN
;Document NOUBWA
; UPD ID= 108, SNARK:<4.1.MONITOR>BUGS.MAC.80,   7-Dec-79 09:56:52 by OSMAN
;Document PFCDP
; UPD ID= 107, SNARK:<4.1.MONITOR>BUGS.MAC.79,   7-Dec-79 09:45:38 by OSMAN
;Document IONXM
; UPD ID= 99, SNARK:<4.1.MONITOR>BUGS.MAC.78,   5-Dec-79 16:40:39 by OSMAN
;Document SMNOFR
; UPD ID= 92, SNARK:<4.1.MONITOR>BUGS.MAC.77,   5-Dec-79 09:28:41 by OSMAN
;Remove duplicate IMPNII and NSKDT2
; UPD ID= 89, SNARK:<4.1.MONITOR>BUGS.MAC.76,   5-Dec-79 07:51:12 by R.ACE
;DOCUMENT IPCOVL
; UPD ID= 86, SNARK:<4.1.MONITOR>BUGS.MAC.75,   4-Dec-79 17:09:27 by MILLER
;ALPHABETIZE OUT-OF-ORDER ENTRIES
; UPD ID= 81, SNARK:<4.1.MONITOR>BUGS.MAC.74,   3-Dec-79 11:13:58 by GRANT
;PUT GIVTMR IN THE PROPER PLACE
; UPD ID= 77, SNARK:<4.1.MONITOR>BUGS.MAC.73,  30-Nov-79 16:56:55 by ZIMA
;TCO 4.2585 - Make NETRBG a BUGCHK and document.
; UPD ID= 75, SNARK:<4.1.MONITOR>BUGS.MAC.72,  30-Nov-79 14:34:18 by MURPHY
;ALPHABETIZE ILLFLT, BADPTR, SWPSTL
; UPD ID= 69, SNARK:<4.1.MONITOR>BUGS.MAC.71,  30-Nov-79 11:16:37 by HALL
;delete bugchk's for enq because code was removed
; UPD ID= 64, SNARK:<4.1.MONITOR>BUGS.MAC.70,  30-Nov-79 10:05:22 by R.ACE
;ADD ALPHABETIC INDEX
; UPD ID= 60, SNARK:<4.1.MONITOR>BUGS.MAC.69,  29-Nov-79 14:00:34 by MILLER
;TCO 4.1.1036. ADD INCFLK BUGCHK
; UPD ID= 55, SNARK:<4.1.MONITOR>BUGS.MAC.68,  29-Nov-79 11:43:52 by MILLER
;MOVE TTFSMS TO ITS PROPER PLACE
; UPD ID= 43, SNARK:<4.1.MONITOR>BUGS.MAC.67,  28-Nov-79 15:55:34 by OSMAN
;Document PI5ERR
; UPD ID= 27, SNARK:<4.1.MONITOR>BUGS.MAC.66,  28-Nov-79 07:50:30 by R.ACE
;TCO 4.2579 - MAKE ILLUUO A BUGHLT
; UPD ID= 25, SNARK:<4.1.MONITOR>BUGS.MAC.65,  27-Nov-79 15:17:59 by OSMAN
;Document NWJTBE
; UPD ID= 22, SNARK:<4.1.MONITOR>BUGS.MAC.64,  27-Nov-79 14:16:00 by OSMAN
;Finish documenting FLKTIM
; UPD ID= 17, SNARK:<4.1.MONITOR>BUGS.MAC.63,  27-Nov-79 10:41:23 by OSMAN
;Document FLKNS
; UPD ID= 15, SNARK:<4.1.MONITOR>BUGS.MAC.62,  27-Nov-79 10:27:25 by OSMAN
;Fix some typos
; UPD ID= 14, SNARK:<4.1.MONITOR>BUGS.MAC.61,  27-Nov-79 10:21:38 by OSMAN
;Document FLKTIM
; UPD ID= 7, SNARK:<4.1.MONITOR>BUGS.MAC.60,  21-Nov-79 14:34:23 by OSMAN
;Document FKCTNZ
;<4.1.MONITOR>BUGS.MAC.59, 19-Nov-79 14:30:31, EDIT BY OSMAN
;Document FRKSLF, ILJRFN, MAP41F
;<4.1.MONITOR>BUGS.MAC.58, 16-Nov-79 13:48:48, EDIT BY MILLER
;<4.1.MONITOR>BUGS.MAC.57, 16-Nov-79 12:59:47, EDIT BY MILLER
;ADD TTFSMS BUGINF
;<4.1.MONITOR>BUGS.MAC.56, 14-Nov-79 13:06:56, EDIT BY MURPHY
;REPAGINATE LISTING
;<4.1.MONITOR>BUGS.MAC.55, 13-Nov-79 14:28:38, EDIT BY MURPHY
;SWPSTL
;<4.1.MONITOR>BUGS.MAC.54, 13-Nov-79 07:12:04, EDIT BY R.ACE
;TCO 4.1.1018 - REPEAT 0 AROUND EFACF1 AND EFACF3
;<4.1.MONITOR>BUGS.MAC.53, 13-Nov-79 06:34:30, EDIT BY R.ACE
;<4.1.MONITOR>BUGS.MAC.52, 13-Nov-79 05:59:22, EDIT BY R.ACE
;DOCUMENT ILLDMS,IMPUUO,SKDPF1,MONPDL
;ADD PC TO ILLFLT
;<4.1.MONITOR>BUGS.MAC.51,  6-Nov-79 05:34:34, EDIT BY R.ACE
;DOCUMENT PInERR,LUUMN0,STKOVF,SBSERF,LUUMON,ILLUUO
;<4.MONITOR>BUGS.MAC.50,  3-Nov-79 16:33:16, EDIT BY R.ACE
;DOCUMENT EFACF3,EFACF1,ILGOKM,GOKFCN,RCVNOE,SNPLKF,SNPODB,SNPUNL
;<4.MONITOR>BUGS.MAC.49, 29-Oct-79 10:26:03, EDIT BY R.ACE
;REMOVE CPYFU1 BUGCHK
;<4.MONITOR>BUGS.MAC.48, 25-Oct-79 19:52:22, EDIT BY DBELL
;ADD ADDITIONAL DATA TO DX2HLT BUGINF
;<4.MONITOR>BUGS.MAC.47, 23-Oct-79 16:11:17, EDIT BY GRANT
;ADD RCVTMR, CHANGE GOKTMR TO GIVTMR
;<4.MONITOR>BUGS.MAC.46, 22-Oct-79 11:44:47, EDIT BY MURPHY
;BADPTR
;<4.MONITOR>BUGS.MAC.45, 17-Oct-79 13:56:50, EDIT BY DBELL
;FINISH PHYH2 BUG DOCUMENTATION
;<4.MONITOR>BUGS.MAC.44, 17-Oct-79 13:17:53, EDIT BY DBELL
;MORE PHYH2 BUGS
;<4.MONITOR>BUGS.MAC.43, 16-Oct-79 17:24:07, EDIT BY DBELL
;BEGIN DOCUMENTATION OF PHYH2 BUGS
;<4.MONITOR>BUGS.MAC.42, 16-Oct-79 15:31:20, EDIT BY DBELL
;FINISH REST OF PHYSIO BUGS
;<4.MONITOR>BUGS.MAC.41, 15-Oct-79 14:22:10, EDIT BY MILLER
;GET RID OF CKDFRK
;<4.MONITOR>BUGS.MAC.39, 12-Oct-79 11:45:44, EDIT BY DBELL
;ADD SOME MORE PHYSIO BUGS
;<4.MONITOR>BUGS.MAC.37, 11-Oct-79 14:52:00, Edit by LCAMPBELL
; Add some ARPANET bugs
;<4.MONITOR>BUGS.MAC.36,  9-Oct-79 15:42:38, EDIT BY ENGEL
;ADD MTMSG AND TPBLKB
;<4.MONITOR>BUGS.MAC.35,  9-Oct-79 10:11:31, EDIT BY ENGEL
;BADTYP
;<4.MONITOR>BUGS.MAC.34,  8-Oct-79 16:44:04, EDIT BY ENGEL
;ADD CDILVT
;<4.MONITOR>BUGS.MAC.33,  8-Oct-79 16:36:28, EDIT BY ENGEL
;ADD DMPRLF
;<4.MONITOR>BUGS.MAC.32,  8-Oct-79 16:11:36, EDIT BY ENGEL
;ADD BLKF1 AND BLKF2
;<4.MONITOR>BUGS.MAC.31,  8-Oct-79 15:37:51, EDIT BY ENGEL
;ADD MORE WORDS TO PREVIOUSLY DOCUMENTED BUGS.
;<4.MONITOR>BUGS.MAC.30,  8-Oct-79 15:12:41, EDIT BY ENGEL
;ADD ASGREQ,ASGREP,RESBAD,RESBND AND RESBAZ
;<4.MONITOR>BUGS.MAC.29,  8-Oct-79 14:48:20, EDIT BY ENGEL
;ADD RELINT,ASGINT AND RELBAD
;<4.MONITOR>BUGS.MAC.28,  8-Oct-79 14:20:44, EDIT BY ENGEL
;ADD RELRNG,RELFRM AND ASGFR0
;<4.MONITOR>BUGS.MAC.26,  8-Oct-79 11:49:30, EDIT BY DBELL
;ADD SOME PHYSIO BUG DOCUMENTATION
;<4.MONITOR>BUGS.MAC.23,  3-Oct-79 11:54:29, EDIT BY GRANT
;ADD ARGUMENT NAMES FOR NSPSRV AND NSPINT BUGS
;<4.MONITOR>BUGS.MAC.22, 29-Sep-79 20:32:47, EDIT BY R.ACE
;CHANGE ILLFPT TO ILLFLT BECAUSE IT SCREWS UP PAGEM ASSEMBLY
;<4.MONITOR>BUGS.MAC.21, 28-Sep-79 15:19:46, EDIT BY MURPHY
;ADD ILLFPT
;<4.MONITOR>BUGS.MAC.20, 26-Sep-79 11:55:55, EDIT BY MURPHY
;MAKE THIS ASSEMBLE AS PART OF PROLOG
;<4.MONITOR>BUGS.MAC.19, 17-Sep-79 12:26:13, Edit by LCAMPBELL
; Add documentation for IMAN22 BUGs (AN22 driver)
;<4.MONITOR>BUGS.MAC.18, 17-Sep-79 08:27:05, EDIT BY OSMAN
;CHANGE MODULE NAMES FROM IMAN22 TO IMPPHY
;<4.MONITOR>BUGS.MAC.8, 12-Sep-79 10:37:36, EDIT BY DBELL
;FIX DX2DNF ENTRY
;<4.MONITOR>BUGS.MAC.7, 12-Sep-79 08:17:49, EDIT BY OSMAN
;CHANGE MODULE NAMES FROM IMPANX TO IMPPHY
;<4.MONITOR>BUGS.MAC.6, 11-Sep-79 17:30:29, EDIT BY DBELL
;ADD DX2DNF BUGINF


;THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED OR
;  COPIED ONLY IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
;COPYRIGHT (C) 1979 BY DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.

;-A-

DEFBUG(INF,AABPIP,ATSSRV,HARD,<ATDPPE - PROTOCOL ERROR. DATA PIPE BEING ABORTED>,<<T4,D>,<T3,D>>,<

Cause:	This BUG is not documented yet.

Action:

Data:

>)


DEFBUG(CHK,ABDHTC,ATSSRV,HARD,<ANCDAT - INVALID HTN RECEIVED ON CONTROL PIPE>,<<T2,D>,<T3,D>,<T1,D>,<T4,D>>,<

Cause:	This BUG is not documented yet.

Action:

Data:

>)


DEFBUG(INF,ABDHTD,ATSSRV,HARD,<ANDDAT - INVALID HTN RECEIVED ON DATA PIPE>,<<T2,D>,<T3,D>,<T1,D>,<T4,D>>,<

Cause:	This BUG is not documented yet.

Action:

Data:

>)


DEFBUG(INF,ABDILN,ATSSRV,HARD,<ATRINM - PACKET LENGTH NOT 1 IN INTERRUPT MESSAGE>,<<T2,D>,<T4,D>,<T3,D>,<P1,D>>,<

Cause:	This BUG is not documented yet.

Action:

Data:

>)


DEFBUG(INF,ABDINT,ATSSRV,HARD,<ATRINM - BAD DATA IN INTERRUPT MESSAGE>,<<T4,D>,<T1,D>,<T3,D>,<P1,D>>,<

Cause:	This BUG is not documented yet.

Action:

Data:

>)


DEFBUG(INF,ABDOPT,ATSSRV,HARD,<ANDCNR - ATS OPTIONAL DATA COUNT NOT 1>,<<T2,D>,<T3,D>,<T1,D>>,<

Cause:	This BUG is not documented yet.

Action:

Data:

>)


DEFBUG(INF,ABDPK1,ATSSRV,HARD,<ANDDAT - WRONG PACKET TYPE RECEIVED ON DATA PIPE>,<<T2,D>,<T1,D>,<T3,D>,<P1,D>>,<

Cause:	This BUG is not documented yet.

Action:

Data:

>)


DEFBUG(INF,ABDPK2,ATSSRV,HARD,<ATRINM - WRONG PACKET TYPE RECEIVED ON DATA PIPE>,<<T2,D>,<T1,D>,<T3,D>,<P1,D>>,<

Cause:	This BUG is not documented yet.

Action:

Data:

>)


DEFBUG(HLT,ABKSKD,PAGEM,SOFT,<ADDRESS BREAK FROM SCHEDULER CONTEXT>,,<

Cause:	A page failure occurred while the monitor was running in scheduler
	context, and the page fail word indicated an address break. Address
	breaks can only be set in code that runs in process context.
>)


DEFBUG(CHK,ACTBBD,JSYSA,HARD,<VERACT - ACCOUNT FILE CORRUPTED>,,<

Cause:	While verifying an account an invalid address was found either in
	the hash table or in a chain pointer in the accounting file.
	This is caused by corruption of the accounts file.

Action:	Rebuild and install a new accounting file using ACTGEN.
>)



DEFBUG(HLT,ADDONF,NSPSRV,SOFT,<ADDOBJ-LLLKUP FAILED>,,<

Cause:	An attempt was made to add a new DECnet logical link to the data
	base and it was discovered that the logical link was already there.

Action:	Look at the dump.  You should be able to tell which routine handed
	ADDLNK the bad block number.

>)


DEFBUG(CHK,AIBREJ,ATSSRV,HARD,<ANDINB - NSP REJECTED ATS INPUT BUFFER>,<<T2,D>,<T3,D>,<T1,D>,<T4,D>>,<

Cause:	This BUG is not documented yet.

Action:

Data:

>)


DEFBUG(INF,AINBTN,ATSSRV,HARD,<ATRINM - 'INVALID BTN' MESSAGE RECEIVED>,<<T4,D>,<T3,D>,<T2,D>,<P1,D>>,<

Cause:	This BUG is not documented yet.

Action:

Data:

>)


DEFBUG(CHK,AINSCT,ATSSRV,HARD,<ANDDAT - INPUT MESSAGE IS TOO SHORT>,<<T4,D>,<T2,D>,<T1,D>,<T3,D>>,<

Cause:	This BUG is not documented yet.

Action:

Data:

>)


DEFBUG(CHK,AINTRC,ATSSRV,HARD,<ANDINT - INTERRUPT MESSAGE RECEIVED ON CONTROL PIPE>,<<T2,D>,<T3,D>>,<

Cause:	This BUG is not documented yet.

Action:

Data:

>)


DEFBUG(CHK,AN2BG1,IMAN22,SOFT,<AN22 bug>,<<T1,BSEL0>,<T2,SEL2>,<T3,CALLER>>,<

Cause:	An inconsistent condition in the AN22 has been detected, such as
	interrupting when no interrupts were expected.

Action:	These can be caused by races between the interrupt routines in
	the 2020 and the AN22 microcode.  They occur a few times a day
	with apparently no ill effect.  Unless they occur extremely
	often, or in conjunction with other (ARPANET-related) bugs,
	they can be ignored.

Data:	BSEL0 and SEL2 are the contents of BSEL0 and SEL2 in the AN22's KMC11.
	CALLER is the PC of the routine which detected the condition.

>)


DEFBUG(HLT,AN2BNR,IMAN22,SOFT,<AN2STI - Input buffer not ready>,,<

Cause:	The monitor attempted to start input from the AN22 without
	first having readied an input buffer.
>)


DEFBUG(CHK,AN2BPK,IMAN22,SOFT,<Bad AN22 packing type decision>,,<

Cause:	The AN22 driver has attempted to unpack an ARPANET buffer
	in a mode which is not implemented.
>)


DEFBUG(CHK,AN2CEX,IMAN22,SOFT,<Checksum error in transfer block for AN22 microcode>,,<

Cause:	A checksum error was detected in the transfer block for the AN22
	microcode (PS:<SYSTEM>AN22.MICROCODE).

Action:	Try obtaining a new copy of the microcode;  the copy which the monitor
	attempted to load was either copied or built incorrectly.
	To force the monitor to load the microcode while the system runs,
	shut the ARPANET off and back on again (with ^ESET ARPANET ON/OFF).

Data:

>)


DEFBUG(CHK,AN2CFM,IMAN22,SOFT,<Cannot GTJFN PS:<SYSTEM>AN22.MICROCODE>,<<T1,LSTERR>>,<

Cause:	The AN22 driver could not get a JFN on PS:<SYSTEM>AN22.MICROCODE.
	This could be caused by absence of that file or by disk trashage.

Action:	Check to see that the file exists in the proper place.  If it does,
	check the state of PS: to insure that a GTJFN will succeed on the file.

Data:	LSTERR is the monitor's error code returned from the failing GTJFN.

>)


DEFBUG(CHK,AN2CKS,IMAN22,SOFT,<Checksum error loading AN22 microcode>,,<

Cause:	A checksum error in the AN22 microcode was detected.  This means
	that the microcode file is bad.

Action:	Apparently the microcode for the AN22 (PS:<SYSTEM>AN22.MICROCODE)
	was either built or copied incorrectly.  Obtain and install a new
	copy of the microcode.  To force the monitor to load the microcode,
	shut the ARPANET off and back on again (with ^ESET ARPANET ON/OFF).

Data:

>)


DEFBUG(CHK,AN2COM,IMAN22,HARD,<Cannot OPENF PS:<SYSTEM>AN22.MICROCODE>,<<T1,LSTERR>>,<

Cause:	The OPENF for PS:<SYSTEM>AN22.MICROCODE failed.  This indicates
	either disk trashage.

Action:	Check the state of PS: to insure that it is not trashed.

Data:	LSTERR is the monitor's error code returned by the failing OPENF.

>)


DEFBUG(CHK,AN2DNS,IMAN22,SOFT,<DRAM loading not supported>,,<

Cause:	The AN22 microcode file contains DRAM frames.  The AN22 driver
	cannot load DRAM into the KMC11.

Action:	The AN22 microcode (PS:<SYSTEM>AN22.MICROCODE) was either
	built or copied incorrectly.  Install a new copy.

Data:

>)


DEFBUG(CHK,AN2HNG,IMAN22,HARD,<AN22 hung>,<<T1,BSEL0>>,<

Cause:	The AN22 microcode is hung:  it refuses to respond to commands.

Action:	This probably indicates either bad microcode in the AN22, or
	a hardware problem in the AN22's KMC11.

Data:	BSEL0 is the contents of BSEL0.  It contains the most recently
	attempted command code.

>)


DEFBUG(INF,AN2IER,IMAN22,SOFT,<IMIERR called>,<<T1,SEL2>>,<

Cause:	This means that the IMP has dropped its ready line (IMP RDY).
	This can be caused by any one of several things:

	o	The IMP has crashed.
	o	The IMP has declared the host tardy.  This means
		that the 2020 has not been accepting data from
		the network fast enough.
	o	The handshaking between the 2020 and the IMP has
		gotten out of synch.

Action:	Since this is really a catch-all error message, no specific
	recommendations can be made.  To analyze the situation further,
	see what other BUGCHKs or BUGINFs are occurring.  If the IMP
	is crashing, contact the Network Control Center at BBN (phone
	(617) 661-0100).

Data:	SEL2 is the contents of the SEL2 register in the AN22.  It contains
	status bits relevant to the IMP/Host interface.  See the AN22
	functional specification for a description of these bits.

>)


DEFBUG(CHK,AN2MCV,IMAN22,HARD,<AN22 microcode verify error>,<<T1,DESIRD>,<T2,ACTUAL>>,<

Cause:	The AN22 driver read different data from the AN22's KMC11 CRAM
	than the data it has just loaded.

Action:	This indicates a hardware malfunction in the AN22's KMC11.

Data:	DESIRD is the data the 2020 attempted to load.  ACTUAL is what
	was read out of the same location.

>)


DEFBUG(HLT,AN2NUA,IMAN22,SOFT,<No UBA mapping registers left>,,<

Cause:	All the Unibus adapter mapping registers have been used up.
>)


DEFBUG(INF,AN2OVF,IMAN22,HARD,<AN22 input data overflow>,,<

Cause:	The IMP sent a message to the 2020 which is longer than the
	maximum allowable message size.  This could indicate either
	a malfunction in the IMP (hardware or software), a hardware
	malfunction in the AN22, or a software bug in the AN22 driver.

Action:	Investigate further.

Data:

>)


DEFBUG(CHK,AN2UCV,IMAN22,SOFT,<AN22 microcode version skew>,<<T1,ACTUAL>,<T2,DESIRD>>,<

Cause:	A different version of microcode than what the AN22 driver expects
	has been installed.

Action:	Check to make sure that you have the correct version of the microcode.

Data:	ACTUAL is the microcode loaded.  DESIRD is the version of microcode
	for which the monitor was built.

>)


DEFBUG(CHK,AN2ULM,IMAN22,HARD,<Unknown line type in AN22 microcode>,,<

Cause:	Garbage was detected in the AN22 microcode (PS:<SYSTEM>AN22.MICROCODE).

Action:	The microcode was either built or copied incorrectly.  Insure that
	you have a good copy of the microcode.

Data:

>)


DEFBUG(CHK,ANCPCL,ATSSRV,HARD,<ATCLCP - PIPE BEING CLOSED IS NOT ON CHAIN>,<<T4,D>,<T3,D>,<T2,D>,<T1,D>>,<

Cause:	This BUG is not documented yet.

Action:

Data:

>)


DEFBUG(CHK,ANCROD,ATSSRV,HARD,<ANCOOK - 'OK TO DO OUTPUT' WHEN OUTPUT NOT REJECTED>,<<T2,D>,<T3,D>>,<

Cause:	This BUG is not documented yet.

Action:

Data:

>)


DEFBUG(CHK,ANDPCL,ATSSRV,HARD,<ATCLDP - PIPE BEING CLOSED IS NOT ON CHAIN>,<<T4,D>,<T3,D>,<T2,D>,<T1,D>>,<

Cause:	This BUG is not documented yet.

Action:

Data:

>)


DEFBUG(CHK,ANDROD,ATSSRV,HARD,<ANDOOK - 'OK TO DO OUTPUT' WHEN OUTPUT NOT REJECTED>,<<T2,D>,<T3,D>>,<

Cause:	This BUG is not documented yet.

Action:

Data:

>)


DEFBUG(CHK,ANOCCL,ATSSRV,HARD,<ATCLDP - NON-ZERO OUTPUT COUNT WHEN CLOSING PIPE>,<<T2,D>,<T3,D>,<T4,D>>,<

Cause:	This BUG is not documented yet.

Action:

Data:

>)


DEFBUG(CHK,ANOEOM,ATSSRV,HARD,<ANCDAT - ATS CONTROL PIPE INPUT HAS NO END-OF-MESSAGE>,<<T2,D>,<T3,D>,<T1,D>>,<

Cause:	This BUG is not documented yet.

Action:

Data:

>)


DEFBUG(CHK,ANOHOS,ATSSRV,HARD,<ANDRHN - ATS CANNOT READ HOST NAME>,<<T2,D>,<T3,D>,<T1,D>,<T4,D>>,<

Cause:	This BUG is not documented yet.

Action:

Data:

>)


DEFBUG(CHK,ANOINT,ATSSRV,HARD,<ATRINM - ATS CANOT READ INTERRUPT MESSAGE>,<<T2,D>,<T3,D>,<T1,D>,<T4,D>>,<

Cause:	This BUG is not documented yet.

Action:

Data:

>)


DEFBUG(CHK,ANOLKP,ATSSRV,HARD,<ATBDLK - ATLKDP FAILED AT CALL FROM NSP>,<<T3,D>>,<

Cause:	This BUG is not documented yet.

Action:

Data:

>)


DEFBUG(CHK,ANOOPT,ATSSRV,HARD,<ANDRDA - ATS CANNOT READ OPTIONAL DATA>,<<T2,D>,<T3,D>,<T1,D>,<T4,D>>,<

Cause:	This BUG is not documented yet.

Action:

Data:

>)


DEFBUG(CHK,ANORSS,ATSSRV,HARD,<ANDRSS - ATS CANNOT READ SEGMENT SIZE>,<<T2,D>,<T3,D>,<T1,D>,<T4,D>>,<

Cause:	This BUG is not documented yet.

Action:

Data:

>)


DEFBUG(CHK,ANTBPQ,ATSSRV,HARD,<ATRTBP - TERMINAL NOT IN QUEUE>,<<T2,D>,<T4,D>,<T3,D>,<T1,D>>,<

Cause:	This BUG is not documented yet.

Action:

Data:

>)


DEFBUG(CHK,ANTDAP,ATSSRV,HARD,<ATRTDP - TERMINAL NOT ON DATA PIPE CHAIN>,<<T4,D>,<T2,D>,<T3,D>,<T1,D>>,<

Cause:	This BUG is not documented yet.

Action:

Data:

>)


DEFBUG(CHK,ANTJFN,ATSSRV,HARD,<ATRTJF - TERMINAL NOT ON JFN CHAIN>,<<T4,D>,<T2,D>,<T3,D>,<T1,D>>,<

Cause:	This BUG is not documented yet.

Action:

Data:

>)


DEFBUG(CHK,AOKINC,ATSSRV,HARD,<ANCOOK - 'OK TO SEND INTERRUPT MESSAGE' ON CONTROL PIPE>,<<T2,D>,<T1,D>>,<

Cause:	This BUG is not documented yet.

Action:

Data:

>)


DEFBUG(CHK,AOKIND,ATSSRV,HARD,<ANDOOK - 'OK TO SEND INTERRUPT MESSAGE' ON DATA PIPE>,<<T2,D>,<T1,D>>,<

Cause:	This BUG is not documented yet.

Action:

Data:

>)


DEFBUG(CHK,AOVULS,ATSSRV,HARD,<ATULST - OVERLY UNLOCKING JFN STRUCTURE>,<<T1,D>>,<

Cause:	This BUG is not documented yet.

Action:

Data:

>)


DEFBUG(CHK,AOVULT,ATSSRV,HARD,<ATULTD - OVERLY UNLOCKING TERMINAL DATA>,<<T2,D>>,<

Cause:	This BUG is not documented yet.

Action:

Data:

>)


DEFBUG(INF,APINCZ,ATSSRV,HARD,<ANDCLZ - ATS CANNOT CLOSE LINK>,<<T2,D>,<T3,D>,<T1,D>,<T4,D>>,<

Cause:	This BUG is not documented yet.

Action:

Data:

>)


DEFBUG(INF,APINOP,ATSSRV,HARD,<ANDCRT - ATS CANNOT OPEN LINK>,<<T2,D>,<T3,D>,<T1,D>,<T4,D>>,<

Cause:	This BUG is not documented yet.

Action:

Data:

>)


DEFBUG(HLT,APRAPE,APRSRV,HARD,<ADDRESS PARITY ERROR>,,<

Cause:	An APR interrupt occurred because a memory controller
	signaled that it had received from the processor an
	address with even parity. The monitor has printed a 
	description of the problem on the CTY.

Action:	Using SBUS diag 0 for all memory controllers, check for the
	address parity error bit(s). Test thoroughly the bus and
	controller.
>)


DEFBUG(HLT,APRNX1,APRSRV,HARD,<NXM DETECTED BY APR>,,<

Cause:	An APR interrupt occurred because the processor attempted to
	access a memory that did not respond within a preset time. This
	can indicate broken hardware or a software bug. The monitor
	has printed a description of the problem on the CTY. 

Action:	The analysis of this BUGHLT is extremely complicated. 
	The physical address from the error register is printed on the
	CTY ("ERA="). If there is physical memory at this address, the
	problem is probably in the hardware. If the address does not
	exist, the problem may be in either hardware or software.

	One software problem that has led to this BUGHLT in the past
	is code that returns an SPT slot to the free pool while leaving
	a pointer to that slot in some page table. The content of
	the SPT entry, instead of being a pointer to memory, is a
	pointer to another SPT slot. 

	In this case, a page fault will have occurred just before the 
	interrupt. The PC will point into the page fault handler.  The page
	fault word and PC (TRAPSW and TRAPPC, respectively) will
	indicate the virtual address and instruction at the time of
	the page fault. Tracing this virtual address to the SPT will
	produce the erronenous SPT entry.

	Note, however, that this BUGHLT is rarely caused by software
	in the field. The hardware is probably broken.
 >)


DEFBUG(HLT,APRNX2,APRSRV,HARD,<NXM DETECTED BY APR>,,<

Cause:	A page fault occurred, indicating that the processor
	attempted to access a memory that did not respond within
	a preset time, and the monitor is presently processing an
	interrupt or running in the scheduler, and the interrupt
	system is turned on. Since non-existent memory also
	produces an APR interrupt, which results in an APRNX1 BUGHLT,
	this BUGHLT does not normally occur.

Action:	See APRNX1. Note, however, that the occurrence of this BUGHLT
	instead of APRNX1 may indicate a failure in the interrupt
	system.
>)


DEFBUG(CHK,AQOCCP,ATSSRV,HARD,<ATCLCP - QUEUED OUTPUT WHEN CLOSING PIPE>,<<T2,D>,<T3,D>,<T4,D>>,<

Cause:	This BUG is not documented yet.

Action:

Data:

>)


DEFBUG(CHK,AQOCDP,ATSSRV,HARD,<ATCLDP - QUEUED OUTPUT WHEN CLOSING PIPE>,<<T4,D>,<T3,D>,<T1,D>>,<

Cause:	This BUG is not documented yet.

Action:

Data:

>)


DEFBUG(CHK,AQONRO,ATSSRV,HARD,<ATDOMG - AP%NRO NOT SET WHEN OUTPUT IS QUEUED>,<<T2,D>,<T3,D>>,<

Cause:	This BUG is not documented yet.

Action:

Data:

>)


DEFBUG(CHK,ARCASS,JSYSF,HARD,<ARCF: File dir # and mapped dir # do not match>,,<

Cause:	This BUG is not documented yet.

Action:

>)


DEFBUG(CHK,ARCVER,IPCF,HARD,<ARCMSG: NOUT failed>,,<

Cause:	This BUG is not documented yet.

Action:

>)


DEFBUG(CHK,ARCVSM,ATSSRV,HARD,<ANDDAT - RECEIVED DATA ON PIPE WITH SECOND MESSAGE>,<<T4,D>,<T3,D>,<T1,D>,<T2,D>>,<

Cause:	This BUG is not documented yet.

Action:

Data:

>)


DEFBUG(HLT,ARSTXX,JSYSF,SOFT,<ARRST: FDB dissappeared for destination file>,,<

Cause:	The FDB for a file being restored from offline does not exist.

Action:

>)


DEFBUG(CHK,ASAASG,DSKALC,SOFT,<DSKASA - ASSIGNING ALREADY ASSIGNED DISK ADDRESS>,<<T1,STRCOD>,<T2,SECTOR>>,<

Cause:	The sector being assigned on the disk is already assigned.
	May happen during creation of structure when assigning
	swapping space, and the sector is already assigned in the
	BAT blocks.

Action:

Data: Structure Unique Code, Sector Number on Disk Relative
		to Start of Structure

>)


DEFBUG(CHK,ASGBAD,DSKALC,SOFT,<DSKASA - ASSIGNING BAD DISK ADDRESS>,<<T3,STRCOD>,<T2,SECTOR>>,<

Cause:	The sector being assigned was not within the legal range
	of sector numbers.

Action:

Data: Structure Unique Code, Sector Number on Disk Relative
		to Start of Structure

>)


DEFBUG(CHK,ASGBPG,DSKALC,SOFT,<INIBTB-FAILED TO ASSIGN BAD PAGE(S)>,<<T1,STRCOD>,<T2,AMOUNT>>,<

Cause:	The bit table is being initialized; home blocks, pages
	in the BAT blocks, and swapping space are being assigned.
	Address(es) in the BAT blocks were not assigned.

Action:

Data: Structure Unique Code, Number of Addresses not Assigned

>)


DEFBUG(HLT,ASGFR0,FREE,HARD,<ASGFRE - ILLEGAL TO ASSIGN 0 FREE SPACE>,,<

Cause:	An illegal request for free space is being made.  The calling routine
	is asking for zero words of free space.

Action:		Look at the dump.  By backing up the stack you
		should be able to tell what routine called for the illegal
		free space. 


>)


DEFBUG(CHK,ASGINT,FREE,HARD,<ASGFRE CALLED OKINT>,<<C,D>>,<

Cause:	This is a free space problem.  Calls to swapable free space 
	routines should be made only while the calling process is NOINT.  The
	calling routine is not protecting itself from losing free space.  It is
	OKINT.  Since it is OKINT it could get interupted and never return,
	thus losing the free block assigned.

Action:	The data supplied gives the address of the calling routine.  Make
	the routine be NOINT until it has ensured that the block will be
	freed when it is interrupted (e.g. JSB stack).


>)


DEFBUG(CHK,ASGREP,FREE,HARD,<ILLEGAL PRIORITY GIVEN TO ASGRES>,,<

Cause:	This is a free space problem.  The caller is asking for resident
	free space.  In T3 the caller gives a priority for this request.
	The priority determines how ASGRES is going to handle this request
	when free space is low.  This priority is out of range.

Action:	If the problem persists change the BUGCHK to a BUGHLT and look
	through the dump to find the caller.


>)


DEFBUG(CHK,ASGREQ,FREE,HARD,<ILLEGAL POOL NUMBER GIVEN TO ASGRES>,,<

Cause:	This is a free space problem.  The caller is requesting resident
	free space.  In T2 the caller is providing a pool number for where
	the free space should come from.  This pool number is incorrect.

Action:	If the problem persists change the BUGCHK to a BUGHLT to find the
	culprit. The caller putting a bad value into T2. 


>)


DEFBUG(HLT,ASGSW2,PAGEM,SOFT,<SWPOMG-CANNOT ASSIGN RESERVED DRUM ADDRESS>,,<

Cause:	The monitor is swapping a group of pages to a set of contiguous
	pages in the swapping space. The swapping space manager has
	provided a starting address for a block of free pages. An attempt
	to assign one of the pages has failed. This indicates an
	inconsistency in the monitor's data or a race condition.
	For example, a context switch may have occurred when it was
	not expected.
>)


DEFBUG(CHK,ASGSWB,SWPALC,SOFT,<SWPINI-CANNOT ASSIGN BAD ADDRESS>,,<

Cause:	Cannot assign bad drum address because it is an illegal
	address or already assigned.

Action:

>)


DEFBUG(CHK,ASMGCL,ATSSRV,HARD,<ATCLDP - SECOND MESSAGE WHEN CLOSING PIPE>,<<T2,D>,<T3,D>,<T4,D>>,<

Cause:	This BUG is not documented yet.

Action:

Data:

>)


DEFBUG(HLT,ASOFNF,DISC,SOFT,<DELFIL: ASGOFN GAVE FAIL RETURN FOR LONG FILE XB>,,<

Cause:	A long file was being deleted and ASGOFN could not assign a system file
	number (OFN).  This usually happens because there were not enough OFN 
	slots.

Action:	If this happens frequently, rebuild the monitor with more OFN slots.

>)


DEFBUG(HLT,ASTJFN,LOOKUP,SOFT,<GETFDB: CALLED FOR JFN WITH OUTPUT STARS>,,<

Cause:	The monitor tried to get a pointer to the FDB of an output file, and 
	the file specification used as an argument to GTJFN contains asterisks.

>)


DEFBUG(CHK,ATCCCP,ATSSRV,HARD,<ATCLCP - NON-ZERO TERMINAL COUNT WHEN CLOSING PIPE>,<<T2,D>,<T3,D>,<T4,D>>,<

Cause:	This BUG is not documented yet.

Action:

Data:

>)


DEFBUG(CHK,ATCCDP,ATSSRV,HARD,<ATCLDP - NON-ZERO TERMINAL COUNT WHEN CLOSING PIPE>,<<T2,D>,<T3,D>,<T4,D>>,<

Cause:	This BUG is not documented yet.

Action:

Data:

>)




DEFBUG(CHK,ATOUT,ATSSRV,HARD,<ATGTOU - OUTPUT COUNT INCONSISTENCY>,<<T1,D>,<P1,D>,<P2,D>>,<

Cause:	This BUG is not documented yet.

Action:

Data:

>)


DEFBUG(CHK,ATPCDP,ATSSRV,HARD,<ATCLDP - NON-ZERO TERMINAL POINTER WHEN CLOSING PIPE>,<<T2,D>,<T3,D>,<T4,D>>,<

Cause:	This BUG is not documented yet.

Action:

Data:

>)


DEFBUG(INF,ATST10,ATSSRV,HARD,<ANCDAT - BUFFER RETURNED BECAUSE LINK ABORTED>,<<T1,D>>,<

Cause:	This BUG is not documented yet.

Action:

Data:

>)


DEFBUG(INF,ATST11,ATSSRV,HARD,<AT%NIO SET AT ANDDAT>,<<T2,D>>,<

Cause:	This BUG is not documented yet.

Action:

Data:

>)


DEFBUG(CHK,ATST13,ATSSRV,HARD,<TERMINAL NOT ON DATA PIPE AT ANDDAT>,<<T2,D>>,<

Cause:	This BUG is not documented yet.

Action:

Data:

>)


DEFBUG(INF,ATSTM1,ATSSRV,HARD,<DATA PIPE CONNECT REJECTED AT ANDCND>,<<T4,D>,<T3,D>,<T2,D>>,<

Cause:	This BUG is not documented yet.

Action:

Data:

>)


DEFBUG(INF,ATSTM4,ATSSRV,HARD,<ANDDAT - BUFFER RETURNED BECAUSE LINK ABORTED>,<<T1,D>>,<

Cause:	This BUG is not documented yet.

Action:

Data:

>)


DEFBUG(INF,ATSTM9,ATSSRV,HARD,<CONTROL PIPE CONNECT REJECTED AT ANCCND>,<<T4,D>,<T3,D>,<T2,D>>,<

Cause:	This BUG is not documented yet.

Action:

Data:

>)

;-B-

DEFBUG(INF,BADACK,KDPSRV,HARD,<bad DDCMP ACK>,<<T1,D>,<T2,D>>,<

Cause:	This BUG is not documented yet.

Action:

Data:

>)


DEFBUG(CHK,BADBAK,FILINI,HARD,<FILIN2 - BACKUP COPY OF ROOT DIRECOTRY IS NOT GOOD>,,<

Cause:	This BUG is not documented yet.

Action:

>)


DEFBUG(CHK,BADBAT,DSKALC,HARD,<BAT BLOCKS UNREADABLE>,,<

Cause:	BAT block header contains bad information.

Action:

>)


DEFBUG(HLT,BADDAC,DIRECT,SOFT,<INSACT - NULL ACCOUNT STRING SEEN>,,<

Cause:	A null account string was given for insertion into the FDB by the
	monitor during the creation of a file or while executing a SACTF JSYS.

>)


DEFBUG(CHK,BADHDR,KDPSRV,HARD,<bad DDCMP header>,<<T1,D>,<T2,D>>,<

Cause:	This BUG is not documented yet.

Action:

Data:

>)


DEFBUG(CHK,BADIDX,FILINI,HARD,<IDXINI: PARTIALLY UNSUCCESSFUL INDEX TABLE REBUILD>,,<

Cause:	This BUG is not documented yet.

Action:

>)


DEFBUG(HLT,BADPTR,PAGEM,SOFT,<BAD SECTION POINTER - SECMAP>,,<

Cause:	The section pointer being deleted was not one of the
types (share or indirect) expected.
>)

DEFBUG(HLT,BADREC,FILINI,hard,<FILINI - Reconstruction of ROOT-DIRECTORY failed>,,<

Cause:	One of the following failures occurred during attempted reconstruction
	of the root directory during system startup:  could not
	get OFN for backup root-directory; could not get OFN for the root-
	directory; could not assign a page in the job data area to build the 
	backup index block; or the backup root-directory is clobbered.

>)


DEFBUG(HLT,BADROT,FILINI,HARD,<FILIN2: ROOT-DIRECTORY IS INVALID>,,<

Cause:	When the system was coming up, BLKSCN was called to check the
	consistency of the root directory.  This error means that
	BLKSCN found that the root directory had an unrecognizable type,
	the last block did not have the expected length, or some block
	had an incorrect format.

Action:	Use EDDT to break after BLKSCN and examine the error code in AC1.
	This code will sometimes indicate what is wrong with the root
	directory.  If other BUGCHKs or BUGINFs occur with this BUGHLT, they
	also can provide helpful information.

	If the system can be brought up using another structure as PS:,
	the bad structure can sometimes be fixed with various tools such
	as FILDDT.  If this restoration fails, the pack can be started
	afresh and pertinent DUMPER backup tapes can be used to restore the
	structure.
>)


DEFBUG(CHK,BADTAB,JSYSA,HARD,<VERACT - SPURIOUS HASH TABLE ENCOUNTERED>,,<

Cause:	This BUG is not documented yet.

Action:

>)


DEFBUG(HLT,BADTTY,TTYSRV,SOFT,<TRANSFER TO NONEXISTENT TTY CODE>,,<

Cause:	The transfer vector for a non-existent TTY line type was
	referenced.

Action:	Look at the dump.  The stack should indicate which routine caused
	the reference.

>)


DEFBUG(HLT,BADTYP,TAPE,HARD,<BAD LABEL FIELD DESC>,,<

Cause:	This is a bug in TAPE.  The internal routines in TAPE have a table 
	with codes that describe the type of data in particular label fields
	(octal,string,decimal).  One of these tables has a code that is
	out of range.

Action:	Try to find out where the out of-range-code came from.


>)


DEFBUG(HLT,BADXT1,FILINI,soft,<INDEX TABLE MISSING AND CAN NOT BE CREATED>,,<

Cause:	During system startup, MAKIDX failed to recreate the index
	table file.  This will occur, for instance, if one of the following
	conditions exist: ASGJFR fails to get free space, STRST fails to create
	a filespec; GTJFN fails to create the file; OPENF fails to open it.
>)


DEFBUG(CHK,BADXT2,FILINI,HARD,<INDEX TABLE MISSING AND WAS CREATED>,,<

Cause:	This BUG is not documented yet.

Action:

>)


DEFBUG(HLT,BADXTB,FILINI,soft,<FILIN2: Could not initialize index table>,,<

Cause:	This can happen either because IDXINI failed during normal
	system startup, or because MAKIDX failed during a special startup
	while PS: was being created.
>)


DEFBUG(HLT,BKUPDF,PAGEM,SOFT,<BKUPD - BAD CST1 ENTRY OR INCONSISTENT CST>,,<

Cause:	A routine has been called to swap a core page to disk or drum.
	It has decided to swap to the disk. The BUGHLT indicates that
	no back address was found in the CST. This usually indicates
	bad data in the CST or a bad pointer in a page table.
>)


DEFBUG(CHK,BLKF1,IO,HARD,<BYTINA: BLKF SET BEFORE CALLING SERVICE ROUTINE>,,<

Cause:	This is a consistancy check in BYTINX.  The enviornment is in IO where sequential
	input is being processed.  The code is getting ready to jump to the
	device dependant code.  Before doing so it sees if a bit (BLKF) is 
	set in STS (AC 8).  This bit indicates that the service routine wants
	to block.  Therefore, no matter what the device dependant routines
	do the process will ultimately block.  It is unlikely that this is
	being done on purpose.  It is more likely that somewhere BLKF is
	not being cleaned up prolerly.

Action:	If this is becoming a problem change the BUGCHK to a BUGHLT and
	look at the dump.If FILSTS for the current JFN has the bit on then 
	the problem gets a little tricky since the previous use of it left
	BLKF on.  If BLKF is off in FILSTS then somewhere past the call to
	CHKJFN it is being turned on.

>)


DEFBUG(CHK,BLKF2,IO,HARD,<BYTOUA: BLKF SET BEFORE CALL TO SERVICE ROUTINE>,,<

Cause:	This is a consistancy check in BYTOUA.  The environment is in IO just
	before it gets ready to call the device dependant routines to do output.
	Bit BLKF in STS (AC 8) is on.  It should be off.  It causes the process
	to block.  It is unlikely that this sort of apriori knowledge is
	available.  It is more likely that this is an error.

Action:	If the problem persists change the BUGCHK to a BUGHLT and look at
	the dump.  If FILSTS for the current JFN has the BLKF bit on then
	the last one to user the JFN left it in that state.  A hard problem
	to find.  If BLKF is off in FILSTS then somewhere after the call to 
	CHKJFN the bit is being set on not reset.

>)


DEFBUG(CHK,BLKF3,JSYSF,HARD,<CLZDO: BLKF SET BEFORE CALL TO SERVICE ROUTINE>,,<

Cause:	This BUG is not documented yet.

Action:

>)


DEFBUG(CHK,BLKF4,JSYSF,HARD,<.GDSTS: BLKF SET BEFORE CALL TO DEVICE ROUTINE>,,<

Cause:	This BUG is not documented yet.

Action:

>)


DEFBUG(CHK,BLKF5,JSYSF,HARD,<.MTOPR: BLKF SET BEFORE CALL TO DEVICE ROUTINE>,,<

Cause:	This BUG is not documented yet.

Action:

>)


DEFBUG(CHK,BLKF6,JSYSF,HARD,<.SDSTS: BLKF SET BEFORE CALL TO DEVICE ROUTINE>,,<

Cause:	This BUG is not documented yet.

Action:

>)


DEFBUG(HLT,BOOTCR,MEXEC,hard,<GETSWM - NOT ENOUGH CORE FOR SWPMON>,,<

Cause:	The computation of space available came out negative.  This
	computation takes TOTRC, subtracts boot's space as computed as
	the difference between the halves of the contents of BUTPGS, then
	subtracts the contents of SUMNR.
>)


DEFBUG(HLT,BOOTER,MEXEC,hard,<GETSWM - ERROR LOADING SWPMON>,,<

Cause:	The monitor calls BOOT with a JSP CX,777(T2) in order to
	load a section of the swappable monitor.  This transfers to
	the VBOOT tag within BOOT, which does the work and takes a
	skip return if there are not errors.

	It takes a non-skip return if there is an error, in which case
	BOOTER results.

Action:	BOOTER has been observed when memory parity errors exist, so
	check for this and do memory corrective maintenance.
>)


DEFBUG(HLT,BOOTLK,MEXEC,soft,<GSMDSK - FAILED TO LOCK NEEDED PAGES>,,<

Cause:	CGPLK is called three times during the booting of the
	swappable monitor, firstly to lock BOOT itself in, then to lock
	BOOT's executive process table, and lastly to lock the swappable 
	monitor's area.  If any of the calls to CGPLK fail, BOOTLK occurs.
>)


DEFBUG(HLT,BOOTMP,MEXEC,soft,<GSMDSK - CANNOT MAP BOOTSTRAP PAGES>,,<

Cause:	The call to MAPPHA which was attempting to map a page for
	BOOT failed.  MAPPHA fails if the requested page was already locked,
	which implies corrupted data in some monitor table.
>)


DEFBUG(HLT,BTBCR1,FILINI,soft,<FILINI - NO BIT TABLE FILE AND UNABLE TO CREATE ONE>,,<

Cause:	MNTBTB failed, so the system restart logic called CRTBTB to
	create a new bit table.  CRTBTB failed too, so the BTBCR1 BUGHLT
	happened.  CRTBTB will fail if INIBTB fails, which can happen if
	DSKASA fails to assign a disk page, or if SWPASN fails to assign
	swapping space.
>)


DEFBUG(HLT,BTBCRT,FILINI,soft,<FILINI - COULD NOT INITIALIZE BIT TABLE FOR PUBLIC STRUCTURE>,,<

Cause:	During special system startup in which PS: was being refreshed,
	CRTBTB failed to build a new bit table.  See CRTBT1 for more detail
	on why CRTBTB fails.
>)

;-C-

DEFBUG(CHK,CDBDIN,CDRSRV,HARD,<CD11 LOST INTERRUPT ENABLE>,<<T4,D>>,<

Cause:	This BUG is not documented yet.

Action:

Data:

>)


DEFBUG(HLT,CDILVT,CDRSRV,HARD,<ILLEGAL DEVICE FUNCTION CODE>,,<

Cause:	In CDRSRV an illegal function code was specified.  The 
	function codes allow for opening, closing, reseting, etc.  A code
	was specified that is out of range.  

Action:	Use the stack to find the routine that is specifying the wrong code.
	The code is usually specified as the address field of a CALL
	instruction.


>)

;& Begin addition
DEFBUG(INF,CHCFRX,CHAOS,SOFT,<CHAOS - RAN OUT OF FORK SLOTS>,,<

Cause:	Incompetence

Action:	Panic
>)

DEFBUG (HLT,CHIFRK,CHAOS,SOFT,<CHAINI: CFORK failed for background Chaos fork>,,<
>)

DEFBUG (HLT,CHLFRK,CHAOS,SOFT,<CHAINI: CFORK failed for local-routing fork>,,<
>)

DEFBUG(CHK,CHACLB,CHAOS,SOFT,<CHFCC: NOSKDP/OKSKDP lock over-decremented>,<<T1,LOCK>>,<
>)

DEFBUG(INF,CHADWN,CHAOS,SOFT,<CHAOSnet now logically down>,,<
>)

DEFBUG(INF,CHADNV,CHAOS,SOFT,<Orphaned NVT connection released>,,<
>)

DEFBUG(INF,CHAGCO,CHAOS,SOFT,<CHAGCF: killing tardy server fork>,,<
>)

DEFBUG(CHK,CHAIAB,CHAOS,SOFT,<CHIACK: releasing packet pending a send>,<<PKT,PKTREF>,<T3,LINK>,<T2,MAGIC>>,<
>)

DEFBUG(CHK,CHAIDO,CHAOS,SOFT,<CHIDAT: duplicate packet seen on out-of-order list>,,<
>)

DEFBUG(CHK,CHAINH,CHAOS,SOFT,<CHSINI: didn't get my hardware host address from -11>,,<
>)

DEFBUG(CHK,CHALCK,CHAOS,SOFT,<CHKLCK: routine called unprotectedly>,,<
>)

DEFBUG(CHK,CHAMCR,CHAOS,SOFT,<CHADCL: quick-close request for non-NVT>,,<
>)

DEFBUG(CHK,CHANJL,CHAOS,SOFT,<Not at JSYS level when should be>,,<
>)

DEFBUG(CHK,CHSLCR,CHAOS,SOFT,<CHALCR: locally-routed packet has bad LH link>,,<
>)

DEFBUG(CHK,CHANCV,CHAOS,SOFT,<Invalid NVT index found in connection>,<<CONN,CONREF>,<T1,CHASTA>>,<
>)

DEFBUG(CHK,CHANFP,CHAOS,SOFT,<RELPKT: Packet not freeable now>,<<PKT,PKTREF>>,<
>)

DEFBUG(CHK,CHANHT,CHAOS,SOFT,<CHSINI: Problems finding or reading SYSTEM:HOSTS2.BIN>,<<T1,PROB>>,<
>)

DEFBUG(INF,CHANRU,CHAOS,SOFT,<No Room for unhandled RFC (in packet space or in RFC handler window)>,,<
>)

DEFBUG(INF,CHAOLP,CHAOS,SOFT,<CHAPGC: Very old but still active packet found>,<<Q2,PKTREF>,<T1,OLD>>,<
>)

DEFBUG(CHK,CHAOOL,CHAOS,SOFT,<CHIDT2: Out of order list disappeared (?)>,,<
>)

DEFBUG(CHK,CHAORP,CHAOS,SOFT,<CHAPGC: Orphaned packet found; freeing it>,<<Q2,PKTREF>,<T1,OLD>,<T3,SIZE>>,<
>)

DEFBUG(CHK,CHAPGL,CHAOS,SOFT,<CHAPGC: looping forever in packet GC>,,<
>)

DEFBUG(CHK,CHAPOO,CHAOS,SOFT,<CHPKIA: Packet still on out-of-order list!>,,<
>)

DEFBUG(CHK,CHAQHI,CHAOS,SOFT,<CHAQCK: Inactive Q header passed to Q routine>,,<
>)

DEFBUG(CHK,CHARBC,CHAOS,SOFT,<RELCON: Bad connection index found>,,<
>)

DEFBUG(CHK,CHARFB,CHAOS,SOFT,<RFCFRE: RCTAB entry deletion problems>,,<
>)

DEFBUG(CHK,CHASPS,CHAOS,SOFT,<SNDPKT: handed non-vanilla packet>,<<PKT,PKTREF>,<T1,LINK>>,<
>)

DEFBUG(INF,CHATBF,CHAOS,SOFT,<Chaos background fork appears hung>,<<T2,WHAT>,<T3,WHEN>,<T4,FLAGS>,<Q2,NOW>>,<
>)

DEFBUG(CHK,CHATSO,CHAOS,SOFT,<CHATTS: non-NVT connection marked as having NVT output>,,<
>)
DEFBUG(INF,CHAUHR,CHAOS,SOFT,<Unhandled RFC>,<<T1,CONTC1>,<T2,CONTC2>,<T3,LENGTH>>,<
>)

DEFBUG(INF,CHAUPN,CHAOS,SOFT,<CHAOSnet now logically up>,,<
>)

DEFBUG(CHK,CHAVSN,CHAOS,SOFT,<CHAVSO: Asked to start output on non-NVT>,,<
>)

DEFBUG(CHK,CHAXIB,CHAOS,SOFT,<CHAXIN: packet not xmit-active when done to -11>,<<T1,WHAT>,<PKT,PKTREF>,<T2,MAGIC>>,<
	[T2 (MAGIC) is only valid when debugging]
>)

DEFBUG(CHK,CHAXMP,CHAOS,SOFT,<CHAXMT: pending-xmit flag set already illegally>,<<PKT,PKTREF>>,<
>)

DEFBUG(CHK,CHAXOD,CHAOS,SOFT,<CHXMTT: Packet waiting too long for room in -11>,,<
>)

DEFBUG(CHK,CHAZWN,CHAOS,SOFT,<CHISTS: ATTEMPT TO SET WINDOW TO LEQ 0>,<<T1,WINSIZ>,<CONN,CONREF>>,<
>)

;& End addition

;& Begin addition
DEFBUG(CHK,CHA11S,CHAOS,SOFT,<CHFCC: NFE-11 seems to be wedged>,,<
>)

DEFBUG(CHK,CHABDC,CHAOS,SOFT,<CHKCNB: invalid connection ref>,<<CONN,CONREF>,<T2,WHERE>>,<

Cause:	Someone has given a bad connection-block reference to someone else.
	CONREF is the bad reference, and WHERE is the caller to CHKCNB (+1).

Action:	Suspect something may be wrong.
>)

DEFBUG(CHK,CHABDP,CHAOS,SOFT,<CHKPKT: invalid packet ref>,<<PKT,PKTREF>,<T2,WHERE>,<T3,WHY>,<T4,LINKS>>,<
>)

DEFBUG(CHK,CHABDR,CHAOS,SOFT,<CHKPKT: invalid packet link field>,<<PKT,PKTREF>,<T2,WHERE>,<T3,WHY>,<T4,LINKS>>,<
>)

DEFBUG(HLT,CHNVBQ,CHAOS,SOFT,<CHINVT: NVT-has-data Q screwed up>,,<

Cause: Incompetence, or timing screw

Action: Curse, watch system reload self
>)

DEFBUG(CHK,CHT7IN,CHAOS,SOFT,<CHTTC7: Bad conn in NVT-has-data Q>,,<

Cause:	Incompetence, or timing screw

Action: Shrug shoulders
>)

DEFBUG(HLT,CHT7QB,CHAOS,SOFT,<CHTTC7: NVT-has-data Q screwed up>,,<

Cause:	Incompetence, or timing screw

Action: Curse, watch system reload self
>)

DEFBUG(INF,CHVTNA,TTYSRV,SOFT,<CHVTNA: input Q'd for inactive Chaos NVT>,,<

Cause:	Chaos NVT has become inactive behind your back.

Action: Try wondering what's going on.  The input packets have ostensibly
	been freed (good luck)!
>)

;& End addition



DEFBUG(CHK,CKPLEN,MEXEC,HARD,<USGINI - ILLEGAL CHECKPOINT ENTRY LENGTH>,,<

Cause:	While executing USGINI, an active checkpoint entry was found with an illegal
	length.  This could be caused by a trashed CHECKPOINT.BIN file.

Action:	Delete CHECKPOINT.BIN and reload system.

>)

DEFBUG(CHK,CLRACE,PHYH11,hard,<UNABLE TO CLEAR REGISTER ACCESS ERROR>,,<

Cause:	This BUGCHK occurs only on the 2020.  It will happen if the
	CLRRAE routine fails to find an existing unit.  The CLRRAE is looking
	for an existing unit to select in order to clear the register access
	error.

	If no existent unit is found, the attempt to clear the register
	access error will cause another error immediately, so the BUGCHK
	is provided to indicate that none was found. The CDB is then
	set offline. The set online function of DIAG% can be used to turn it
	back online when the problem is corrected.

>)


DEFBUG(CHK,CLZABF,JSYSF,HARD,<CLZFFW: SERVICE ROUTINE BLOCKED ON AN ABORT CLOSE>,,<

Cause:	This BUG is not documented yet.

Action:

>)


DEFBUG(INF,CLZDIN,NSPSRV,SOFT,<CLZSDI - Could not send DI>,,<

Cause:	This BUG is not documented yet.

Action:

Data:

>)


DEFBUG(CHK,CRDBAK,JSYSF,HARD,<CRDIR3: COULD NOT MAKE BACKUP COPY OF ROOT-DIRECTORY>,,<

Cause:	This BUG is not documented yet.

Action:

>)


DEFBUG(CHK,CRDBK1,JSYSF,HARD,<CRDIR4:COULD NOT MAKE BACKUP COPY OF ROOT-DIRECTORY>,,<

Cause:	This BUG is not documented yet.

Action:

>)


DEFBUG(CHK,CRDNOM,JSYSF,HARD,<CRDIR-FAILED TO MAKE MAIL.TXT FILE>,,<

Cause:	This BUG is not documented yet.

Action:

>)


DEFBUG(CHK,CRDOLD,JSYSF,HARD,<CRGDGB: OLD FORMAT CRDIR IS ILLEGAL>,,<

Cause:	This BUG is not documented yet.

Action:

>)


DEFBUG(CHK,CRDSDF,JSYSF,HARD,<CRDIR1: SETDIR FAILED ON NEW DIRECTORY>,,<

Cause:	This BUG is not documented yet.

Action:

>)


DEFBUG(CHK,CRSPAG,JSYSA,HARD,<VERACT - ACCOUNT DATA BLOCK CROSSES A PAGE BOUNDARY>,,<

Cause:	This BUG is not documented yet.

Action:

>)


DEFBUG(HLT,CST2I1,PAGEM,SOFT,<PAGE TABLE CORE POINTER AND CST2 FAIL TO CORRESPOND>,,<

Cause:	A routine has been called to change the map for a page of a
	process. The page is being mapped to a file page that is not
	already shared. The code is going to create an entry for the
	file page in the SPT so that the destination can have a
	share pointer. The page pointer in the index block contains
	a core address. The BUGHLT indicates that the owner of the
	core page is not the file page that points to it. This means
	that there is an inconsistency in the monitor's data.
>)


DEFBUG(HLT,CST2I2,PAGEM,SOFT,<MVPT-CST2 INCONSISTENT>,,<

Cause:	A routine has been called to move a page from one page table
	to another. The source page table has an immediate pointer to
	a page in memory. The BUGHLT indicates that the CST entry for
	that page contains a different owner from the source identifier that
	points to it. This indicates an inconsistency in the monitor's
	data.
>)


DEFBUG(HLT,CST2I3,PAGEM,SOFT,<PAGE TABLE CORE POINTER AND CST2 FAIL TO CORRESPOND>,,<

Cause:	A routine has been called to remove a page from a process's
	map. The map contains a share pointer to a file page. The
	SPT entry to which the map points contains a core page number.
	The BUGHLT indicates that the CST entry for that core page
	does not point back to the SPT entry.
>)

;-D-

DEFBUG(INF,DDCSTR,KDPSRV,HARD,<DDCMP restarted>,<<T1,D>>,<

Cause:	This BUG is not documented yet.

Action:

Data:

>)


DEFBUG(INF,DDCTIM,KDPSRV,HARD,<DDCMP timed out>,<<T2,D>>,<

Cause:	This BUG is not documented yet.

Action:

Data:

>)


DEFBUG(HLT,DDLCOR,KDPSRV,soft,<NO CORE FOR DDCMP>,,<

Cause:	This can only happen on the 2020.

	This BUGHLT occurs when DDINI gets a failure return from ASGRES,
	meaning that no free space is available for the DDCMP line buffers.
>)


DEFBUG(CHK,DEABAD,DSKALC,SOFT,<DSKDEA - DEASSIGNING BAD DISK ADDRESS>,<<T3,STRCOD>,<T2,SECTOR>>,<

Cause:	The sector being deassigned was not within the legal
	range of sector numbers.

Action:

Data: Structure Unique Code, Sector Number of Disk Relative
	to Start of Structure

>)


DEFBUG(CHK,DEAUNA,DSKALC,SOFT,<DEDSK-DEASSIGNING UNASSIGNED DISK ADDRESS>,<<T1,STRCOD>,<T2,SECTOR>>,<

Cause:	The disk address being deassigned was never assigned.


Action:

Data: Structure Unique Code, Sector Number of Disk Relative
	to Start of Structure

>)


DEFBUG(INF,DELBDD,JSYSF,HARD,<DELDIR: BAD DIRECTORY DELETED. REBUILD BIT TABLE>,,<

Cause:	This BUG is not documented yet.

Action:

>)


DEFBUG(INF,DELNDF,NSPSRV,SOFT,<DELNOD-LLLKUP FAILED>,<<T2,CALLER>>,<

Cause:	An attempt to remove a DECnet logical link block from the data
	base failed.  

ACTION:	THIS SHOULD BE EASILY RECOVERED FROM BY THE MONITOR.
	IF IT PERSISTS, CHANGE IT TO A BUGHLT AND LOOK AT THE DUMP.
	THE ROUTINE MAKING THE CALL TO DELNOD SHOULD BE A VERY GOOD
	CLUE AS TO WHY THIS IS OCCURRING.

Data:	CALLER - PC of the calling routine

>)


DEFBUG(CHK,DEVUCF,DEVICE,SOFT,<DEVAV - UNEXPECTED CHKDES FAILURE>,,<

Cause:	While checking to see if a device is available to the job,
	an invalid device designator was passed to a subroutine.

Action:

>)


DEFBUG(HLT,DGUTPG,DIAG,HARD,<DIAG - LOCKED PAGE LIST PAGE LOCKED AT DIAG UNLOCK>,,<

Cause:	The subroutine DGUNLK was called to release the interlock for the
	DIAG JSYS.  In the case that user pages were locked down, the left
	half of the location DIAGFK contains the page containing a list of
	the locked pages.  The routine DGEXFL should have previously been
	called to release this page.  However, DGUNLK found that the page
	was still assigned.
>)


DEFBUG(HLT,DGZTPA,DIAG,HARD,<DIAG - LOCKED PAGE LIST PAGE WAS ZERO>,,<

Cause:	The routine DGEXFL in the module DIAG was called to unlock any
	user pages when terminating use of the DIAG JSYS.  A pointer to
	a list of these pages should be in the left half of location
	DIAGFK.  But this pointer was zero.  (But this BUGHLT should
	never occur, since DGEXFL returns if the pointer is zero.)
>)


DEFBUG(CHK,DIRACT,DIRECT,SOFT,<ACTBAD: ILLEGAL FORMAT FOR DIRECTORY ACCOUNT BLOCK IN DIRECTORY:>,<<A,DIRNUM>,<B,STRNAM>,<C,ADDR>>,<

Cause:	File account string block is not correct in symbol table.

Action: Check SYSERR for file.  Delete and expunge it, then
	restore the file.

Data: Directory Number, Sixbit Structure Name, Address in directory

>)


DEFBUG(CHK,DIRB2L,DIRECT,SOFT,<RLDFB2: DIRECTORY FREE BLOCK TOO LARGE IN DIRECTORY:>,<<A,DIRNUM>,<B,STRNAM>,<C,ADDR>>,<

Cause:	Bad directory block being returned.

Action: Run CHECKD to reclaim lost pages.

Data: Directory Number, Sixbit Structure Name, Address in directory

>)


DEFBUG(CHK,DIRB2S,DIRECT,SOFT,<RLDFB1: DIRECTORY FREE BLOCK TOO SMALL IN DIRECTORY:>,<<A,DIRNUM>,<B,STRNAM>,<C,ADDR>>,<

Cause:	Bad directory block being returned.  Disk space will be
	lost until CHECKD run on structure.

Action: Run CHECKD to reclaim lost space.

Data: Directory Number, Sixbit Structure Name, Address in directory

>)


DEFBUG(CHK,DIRBAD,DIRECT,HARD,<SETDI4: SMASHED DIRECTORY NUMBER:>,<<A,D>,<D,D>>,<

Cause:	No path to this bugchk.

Action:

Data:

>)


DEFBUG(CHK,DIRBAF,DIRECT,SOFT,<RLDFB5: BLOCK ALREADY ON DIRECTORY FREE LIST IN DIRECTORY:>,<<A,DIRNUM>,<B,STRNAM>,<C,ADDR>>,<

Cause:	Directory block returned already.

Action:

Data: Directory Number, Sixbit Structure Name, Address in directory

>)


DEFBUG(CHK,DIRBCB,DIRECT,SOFT,<RLDFB3: DIRECTORY FREE BLOCK CROSSES PAGE BOUNDARY IN DIRECTORY:>,<<A,DIRNUM>,<B,STRNAM>,<C,ADDR>>,<

Cause:	Bad directory block being returned.

Action: Run CHECKD to reclaim lost pages.

Data: Directory Number, Sixbit Structure Name, Address in directory

>)


DEFBUG(CHK,DIRBLK,DIRECT,SOFT,<BLKSCN: ILLEGAL BLOCK TYPE IN DIRECTORY:>,<<A,DIRNUM>,<B,STRNAM>,<C,ADDR>>,<

Cause:	Unknown code in directory block.

Action: Delete directory and rebuild it.

Data: Directory Number, Sixbit Structure Name, Address in directory

>)


DEFBUG(CHK,DIRDNL,DIRECT,SOFT,<ULKDIR-DIRECTORY NOT LOCKED, DIRECTORY NUMBER:>,<<T1,Dirnum>,<T2,Strnam>>,<

Cause:	Trying to unlock a directory never locked, or directory
	number is garbage.

Action:

Data: Directory Number, Sixbit Structure Name

>)


DEFBUG(CHK,DIREXT,DIRECT,SOFT,<EXTBAD: ILLEGAL FORMAT FOR DIRECTORY EXTENSION BLOCK IN DIRECTORY:>,<<A,DIRNUM>,<B,STRNAM>,<C,ADDR>>,<

Cause:	File extension block is not correct in symbol table.

Action: Check SYSERR for file.  Delete and expunge it,
	then restore it.

Data: Directory Number, Sixbit Structure Name, Address in directory

>)


DEFBUG(CHK,DIRFDB,DIRECT,SOFT,<ILLEGAL FORMAT FOR FDB IN DIRECTORY:>,<<A,DIRNUM>,<B,STRNAM>,<C,ADDR>>,<

Cause:	This BUG is not documented yet.

Action:

Data:

>)


DEFBUG(CHK,DIRFKP,DIRECT,HARD,<SETDIR-DIR PAGE 0 BELONGS TO FORK IN DIRECTORY:>,<<B,D>,<SETDNM,D>>,<

Cause:	No path to this BUGCHK.

Action:

Data:

>)


DEFBUG(CHK,DIRFRE,DIRECT,SOFT,<FREBAD: ILLEGAL FORMAT FOR DIRECTORY FREE BLOCK IN DIRECTORY:>,<<A,DIRNUM>,<B,STRNAM>,<C,ADDR>>,<

Cause:	Directory free block is not correct.

Action: Rebuild Directory.

Data: Directory Number, Sixbit Structure Name, Address in directory

>)


DEFBUG(CHK,DIRIFB,DIRECT,SOFT,<RLDFB4: ILLEGAL BLOCK TYPE ON DIRECTORY FREE LIST IN DIRECTORY:>,<<A,DIRNUM>,<B,STRNAM>,<C,ADDR>>,<

Cause:	No path to the BUGCHK.

Action:

Data:

>)


DEFBUG(CHK,DIRNAM,DIRECT,SOFT,<NAMBAD: ILLEGAL FORMAT FOR DIRECTORY NAME BLOCK IN DIRECTORY:>,<<A,DIRNUM>,<B,STRNAM>,<C,ADDR>>,<

Cause:	File name block is not correct in symbol table.

Action: Delete and expunge file, then restore it.

Data: Directory Number, Sixbit Structure Name, Address in directory

>)


DEFBUG(CHK,DIRPG0,DIRECT,SOFT,<DR0CHK: ILLEGAL FORMAT FOR DIRECTORY PAGE 0 IN DIRECTORY:>,<<A,Dirnum>,<B,Strnam>>,<

Cause:	Directory header contains incorrect information.

Action: Delete directory and rebuild it.

Data: Directory Number, Sixbit Structure Name

>)


DEFBUG(CHK,DIRPG1,DIRECT,SOFT,<DRHCHK: DIRECTORY HEADER BLOCK IS BAD IN DIRECTORY:>,<<A,DIRNUM>,<B,STRNAM>,<C,ADDR>>,<

Cause:	Directory header contains incorrect information.

Action: Delete directory and rebuild it.

Data: Directory Number, Sixbit Structure Name, Address in directory

>)


DEFBUG(CHK,DIRRHB,DIRECT,SOFT,<RLDFB6: ATTEMPTING TO RETURN A HEADER BLOCK IN DIRECTORY:>,<<A,DIRNUM>,<B,STRNAM>,<C,ADDR>>,<

Cause:	Address of block being returned is illegal.

Action:

Data: Directory number, Sixbit Structure Name, Address in directory

>)


DEFBUG(CHK,DIRSY1,DIRECT,SOFT,<DELDL8: DIRECTORY SYMBOL TABLE FOULED UP FOR DIRECTORY:>,<<A,Dirnum>,<B,Strnam>>,<

Cause:	Disordered directory symbol table found while expunging
	directory or rebuilding symbol table.

Action: Rebuild symbol table.  If that fails, delete directory
	with DELETE command and DIRECTORY subcommand.

Data: Directory Number, Sixbit Structure Name.

>)


DEFBUG(CHK,DIRSY2,DIRECT,SOFT,<MDDNAM: SYMBOL TABLE FOULED UP IN DIRECTORY:>,<<A,Dirnum>,<B,Strnam>>,<

Cause:	Bad symbol table format found when looking up a directory.

Action: Rebuild symbol table.

Data: Directory Number, Sixbit Structure Name

>)


DEFBUG(CHK,DIRSY3,DIRECT,HARD,<LOOKUP: SYMBOL SEARCH FOULED UP IN DIRECTORY:>,<<C,Dirnum>,<B,Strnam>>,<

Cause:	Found disordered symbol table while looking for string in
	a directory.

Action: Rebuild symbol table.

Data: Directory Number, Sixbit Structure Name

>)


DEFBUG(CHK,DIRSY4,DIRECT,SOFT,<NAMCM4: DIRECTORY SYMBOL TABLE FOULED UP IN DIRECTORY:>,<<A,Dirnum>,<B,Strnam>>,<

Cause:	Found disordered symbol table while comparing name strings.

Action: Rebuild symbol table.

Data: Directory Number, Sixbit Structure Name

>)


DEFBUG(CHK,DIRSY5,DIRECT,HARD,<SYMBAD: ILLEGAL FORMAT FOR DIRECTORY SYMBOL TABLE IN DIRECTORY:>,<<A,Dirnum>,<B,Strnam>>,<

Cause:	Symbol table header contains incorrect information.

Action: Rebuild symbol table.

Data: Directory Number, Sixbit Structure Name

>)


DEFBUG(CHK,DIRSY6,DIRECT,SOFT,<RBLDST: PREMATURELY RAN OUT OF ROOM IN SYMBOL TABLE IN DIRECTORY:>,<<A,Dirnam>,<B,Strnam>>,<

Cause:	Ran out of space while rebuilding symbol table on DELDF JSYS.

Action: Split directory into mre directories.

Data: Directory Number, Sixbit Structure Name

>)


DEFBUG(CHK,DIRULK,DIRECT,HARD,<ULKMD2: ATTEMPT TO UNLOCK ILLEGALLY FORMATTED DIR, DIR NUMBER:>,<<T1,Dirnum>,<T2,Strnam>>,<

Cause:	Tried to unlock a directory that is disordered, or bad
	argument given to subroutine to unlock directory.

Action:

Data: Directory Number, Sixbit Structure Name

>)


DEFBUG(CHK,DIRUNS,DIRECT,HARD,<UNSBAD: ILLEGAL FORMAT FOR DIRECTORY USER NAME BLOCK IN DIRECTORY:>,<<A,Dirnum>,<B,Strnam>>,<

Cause:	User name string block incorrect in symbol table.

Action: Check SYSERR for file.  Delete and expunge it,
	then restore the file.

Data: Directory Number, Sixbit Structure Name

>)


DEFBUG(INF,DLDEF,TTYSRV,HARD,<LOGICAL NAME DEFINE FAILED FOR FE CTY>,,<

Cause:	This BUG is not documented yet.

Action:

>)


DEFBUG(INF,DN20ST,DTESRV,HARD,<DTESRV- DN20 STOPPED>,<<B,D>>,<

Cause:	This BUG is not documented yet.

Action:

Data:

>)


DEFBUG(HLT,DNOPT0,DISC,HARD,<DSKCLZ-JFNOFN FAILED FOR PAGE 0>,,<

Cause:	There is no path to this BUGHLT.  It is not assembled into the monitor.

>)



DEFBUG(CHK,DRMFUL,PAGEM,SOFT,<DRUM COMPLETELY FULL>,,<

Cause:	The monitor is attempting to swap a core page to the
	drum. There is no space available.  The general handling
	of drum assignments should insure that here are always a
	few pages available for "critical" assignments such as
	this case. It is possible that some pathological user
	program could overtax the normal reserves and so cause this
	failure.
>)


DEFBUG(HLT,DRMIBT,SWPALC,HARD,<DRMASN-BIT TABLE INCONSISTENT>,,<

Cause:	During the assignment of drum a page, DRMCNT for a track showed
	there was space on that track.  There was no free space available
	according to the bit table for the track, however.

Action:

>)


DEFBUG(HLT,DRMNFR,SWPALC,HARD,<DRMAM-CANNOT FIND PAGE WHEN DRMFRE NON-0>,,<

Cause:	During assignment of multiple contiguous drum addresses,
	DRMFRE said there was space on the drum.  However, none
	of the DRMCNT's for each track showed any free space.

>)


DEFBUG(HLT,DRUMP1,STG,soft,<DRMIO - DRUMP ON BUT NO DRUM CODE IN SYSTEM>,,<

Cause:	This can only happen on the 2020.

	This BUGHLT occurs at DRMIOM if DRUMP contains a positive number.
	DRUMP contains DRMN, which, if positive, causes the DRUMP1 BUGHLT code
	not to be assembled.
>)


DEFBUG(CHK,DSKBT1,DSKALC,HARD,<DSK BIT TABLE FOULED, CANNOT FIND FREE PAGE ON TRACK WITH NON-0 COUNT>,<<T2,STRCOD>,<T3,CYLNDR>>,<

Cause:	The bit table for this disk cylinder indicated there
	were free pages for assignment.  However, none could be
	found.

Action:

Data: Structure Unique Code, Cylinder Number

>)


DEFBUG(CHK,DSKBT3,DSKALC,SOFT,<DISK BIT TABLE ALREADY LOCKED AT LCKBTB>,<<T1,SPTIDX>>,<

Cause:	Structure bit table being locked is already locked.

Action:

Data: Offset in SPT for Entry to Copy into BTBBAS SPT and SPTH slots.

>)


DEFBUG(INF,DSRLST,KDPSRV,HARD,<Dataset ready lost>,<<T2,D>>,<

Cause:	This BUG is not documented yet.

Action:

Data:

>)


DEFBUG(HLT,DST2SM,SWPALC,SOFT,<SWPINI-DST TOO SMALL>,,<

Cause:	There are more pages for swapping than there are
	entries in the DST.

>)


DEFBUG(INF,DT11DN,DTESRV,HARD,<DTECHK- 10 LOST TO11DN INTERRUPT>,,<

Cause:	This BUG is not documented yet.

Action:

Data:

>)


DEFBUG(CHK,DTEBAD,DTESRV,SOFT,<INVALID MESSAGE QUEUED TO DN20>,,<

Cause:	A message whose first byte is neither a 130 (node init) or a 106
	(route header) has been sent to the DN20.

Action:	The DN20 will ignore the message but confusion may arise in TOPS-20's
	resident free space, possibly leading to a BUGHLT.  If this happens
	change DTEBAD to a BUGHLT to capture more immediate information.

>)


DEFBUG(CHK,DTECAR,DTESRV,HARD,<CARRIER FNC WITH NO LINE NUMBER>,<<A,D>>,<

Cause:	This BUG is not documented yet.

Action:

Data:

>)


DEFBUG(INF,DTECDM,DTESRV,HARD,<DTESRV- TO -10 COUNTS DO Not MATCH>,<<A,D>>,<

Cause:	This BUG is not documented yet.

Action:

Data:

>)


DEFBUG(CHK,DTEDAT,DTESRV,HARD,<TAKTOD- ILLEGAL FORMAT FOR TIME/DATE>,,<

Cause:	This BUG is not documented yet.

Action:

Data:

>)


DEFBUG(CHK,DTEDEV,DTESRV,HARD,<ILLEGAL DEVICE>,<<A,D>>,<

Cause:	This BUG is not documented yet.

Action:

Data:

>)


DEFBUG(INF,DTEDIN,DTESRV,HARD,<DTESRV- TO -10 IN PROGRESS ON DOORBELL>,<<A,D>>,<

Cause:	This BUG is not documented yet.

Action:

Data:

>)


DEFBUG(INF,DTEDME,DTESRV,HARD,<DTESRV- ZERO Q COUNT>,<<A,D>>,<

Cause:	This BUG is not documented yet.

Action:

Data:

>)


DEFBUG(CHK,DTEERR,DTESRV,HARD,<DTESRV-DTE DEVICE ERROR>,<<A,D>,<F,D>>,<

Cause:	This BUG is not documented yet.

Action:

Data:

>)


DEFBUG(CHK,DTEIDP,DTESRV,HARD,<BAD INDIRECT PACKET>,<<A,D>>,<

Cause:	This BUG is not documented yet.

Action:

Data:

>)


DEFBUG(CHK,DTEIFR,DTESRV,HARD,<DTESRV-ILLEGAL FNC REQUEST>,<<A,D>>,<

Cause:	This BUG is not documented yet.

Action:

Data:

>)


DEFBUG(INF,DTEIPR,DTESRV,SOFT,<DTESRV - PROTOCOL INITIALIZED ON DTE>,<<T1,DTENUM>>,<

Cause:	BOOT JSYS was execute to initialize protocol.

Data:	DTENUM - the DTE number

>)

DEFBUG(INF,DTELDB,DTESRV,HARD,<DTECHK- 11 LOST DOORBELL>,,<

Cause:	This BUG is not documented yet.

Action:

Data:

>)


DEFBUG(INF,DTELPI,DTESRV,HARD,<DTECHK- DTE LOST PI ASSIGNMENT>,<<B,D>>,<

Cause:	This BUG is not documented yet.

Action:

Data:

>)


DEFBUG(CHK,DTEMCC,DTESRV,HARD,<DOFRGM-DN20 DISAGRESS WITH COUNT>,<<A,D>>,<

Cause:	This BUG is not documented yet.

Action:

Data:

>)


DEFBUG(CHK,DTEODD,DTESRV,HARD,<TAKLC-ODD BYTE COUNT FOR LINE CHARACTERS>,,<

Cause:	This BUG is not documented yet.

Action:

Data:

>)



DEFBUG(CHK,DTEP2S,DTESRV,HARD,<TO10DN-PACKET TOO SMALL>,,<

Cause:	This BUG is not documented yet.

Action:

Data:

>)


DEFBUG(CHK,DTEPGF,DTESRV,HARD,<DTE TRANSFER PAGE FAIL>,<<A,D>>,<

Cause:	This BUG is not documented yet.

Action:

Data:

>)


DEFBUG(INF,DTEPNR,DTESRV,HARD,<DTESRV- INCORRECT INDIRECT SETUP>,<<A,D>>,<

Cause:	This BUG is not documented yet.

Action:

Data:

>)


DEFBUG(HLT,DTERES,DTESRV,SOFT,<RESIDENT FREE SPACE OVERWRITTEN>,<<A,DNMCDT>>,<

Cause:	A DTE transfer has written beyond the assigned resident free space area.
	This only pertains to DECnet front ends.

Action:	Check the data base to see if the original call to assign free space
	requested enough space.  Also, check to see if there is something
	unusual about the information in the comm region.  This is probably
	a software error but if all else fails, maybe the DTE is transfering
	more than it should be.

Data:	DNMCDT - the DTE number

>)

DEFBUG(HLT,DTETBE,DTESRV,SOFT,<To 10 byte pointer incorrect>,<<A,DN10DT>>,<

Cause:	A "to -10 done" has occurred and the byte pointer that the microcode
	last changed does not match the byte pointer that the monitor has 
	computed and believes should be there when the the transfer is over.

Action:	The problem is probably in the DTE.  You should have Field Service 
	run DTE diagnostics.

Data:	DN10DT - The DTE number.

>)


DEFBUG(CHK,DTETIP,DTESRV,HARD,<DTETDN-TO10 DONE RECEIVED WITH NO TRANSFER IN PROGRESS>,<<A,D>>,<

Cause:	This BUG is not documented yet.

Action:

Data:

>)


DEFBUG(CHK,DTETTY,DTESRV,HARD,<NON-TTY DEVICE>,<<A,D>>,<

Cause:	This BUG is not documented yet.

Action:

Data:

>)


DEFBUG(CHK,DTEUIF,DTESRV,HARD,<DTESRV-UNIMPLEMENTED FUNCTION FROM 11>,<<A,D>>,<

Cause:	This BUG is not documented yet.

Action:

Data:

>)


DEFBUG(HLT,DUPCOR,KDPSRV,SOFT,<No core for DUP11>,,<

Cause:	In attempting to set up a DUP line table, a request for resident
	free space from the network pool failed.

Action:	Look at the dump and verify that the network pool of free
	space was indeed exhausted.  (Location RESUTB+.RESNP should contain
	a non-negative number less than 100 to cause this BUGHLT.)  If this
	happens often, you should consider rebuilding the monitor with more 
	resident free space allocated to DECnet.

>)


DEFBUG(HLT,DUPUBA,KDPSRV,soft,<no Unibus Address>,,<

Cause:	This can only happen on the 2020.

	It happens if the ALUBWA routine takes a failure return instead of
	delivering a unibus adaptor window, which is needed to communicate
	with the KMC11.
>)


DEFBUG(CHK,DVCHRX,JSYSF,HARD,<DVCHR1 - UNEXPECTED CHKDES FAILURE WITHIN .DVCHR>,,<

Cause:	This BUG is not documented yet.

Action:

>)


DEFBUG(CHK,DX2DIE,PHYX2,HARD,<PHYX2 - DX20 HALTED>,<<T1,D>>,<

Cause:	This BUG is not documented yet.

Action:

>)


DEFBUG(INF,DX2DNF,PHYX2,HARD,<PHYX2 - DRIVE NUMBER NOT FOUND IN UDBS>,<<T4,DRIVE>>,<

Cause:	A DX20 returned an 8-bit drive number, and routine DRVSRC was
	called to determine which UDB was associated with that drive
	number.  None of the currently existing UDBs had that number.

Data:	DRIVE - The unit of the DX20 that was not found.
>)


DEFBUG(CHK,DX2FGS,PHYX2,HARD,<PHYX2 - FAIL TO GET SENSE BYTES>,,<

Cause:	This BUG is not documented yet.

Action:

>)


DEFBUG(CHK,DX2FUS,PHYX2,HARD,<PHYX2 - FAIL TO UPDATE SENSE BYTES>,,<

Cause:	This BUG is not documented yet.

Action:

>)


DEFBUG(INF,DX2HLT,PHYX2,HARD,<PHYX2 - DX20 HALTED>,<<T1,CHAN>,<T2,DX20>,<T3,REG1>,<T4,2AND26>>,<

Cause:	The DX20 controller's microcode is no longer running.  This could
	be due to a microcode-detected fatal error.  Or, the microcode
	could have been halted by a program such as DX20LD.

Action:	Use DX20LD to reload or restart the microcode.  If the DX20 still
	refuses to run, call field service.

Data:	CHAN/	The channel number.
	DX20/	The controller number which halted.
	REG1/	Contents of device register 1 (status register).
	2AND26/	Device register 2 in left half (error register), and
		device register 26 in right half (possible error code).
>)


DEFBUG(CHK,DX2IDM,PHYX2,HARD,<PHYX2 - ILLEGAL DATA MODE AT DONE INT>,<<T2,D>>,<

Cause:	This BUG is not documented yet.

Action:

>)


DEFBUG(INF,DX2IDX,PHYX2,HARD,<PHYX2 - ILLEGAL RETRY BYTE POINTER>,,<

Cause:	This BUG is not documented yet.

Action:

>)


DEFBUG(CHK,DX2IEC,PHYX2,HARD,<PHYX2 - ILLEGAL ERROR CLASS CODE>,<<T1,D>>,<

Cause:	This BUG is not documented yet.

Action:

>)


DEFBUG(CHK,DX2IFS,PHYX2,HARD,<PHYX2 - ILLEGAL FUNCTION AT START IO>,<<Q1,D>>,<

Cause:	This BUG is not documented yet.

Action:

>)


DEFBUG(INF,DX2IRF,PHYX2,HARD,<PHYX2 - ILLEGAL FUNCTION DURING RETRY>,,<

Cause:	This BUG is not documented yet.

Action:

>)


DEFBUG(CHK,DX2MCF,PHYX2,HARD,<PHYX2 - DX20 MICROCODE CHECK FAILURE>,,<

Cause:	This BUG is not documented yet.

Action:

>)


DEFBUG(INF,DX2N2S,PHYX2,HARD,<PHYX2 - MORE TU70S THAN TABLE SPACE, EXCESS IGNORED>,,<

Cause:	This BUG is not documented yet.

Action:

>)


DEFBUG(CHK,DX2NRT,PHYX2,HARD,<DX2ERR - IS.NRT SET ON SUCCESSFUL RETRY>,,<

Cause:	This BUG is not documented yet.

Action:

>)


DEFBUG(CHK,DX2NUD,PHYX2,HARD,<PHYX2 - CHANNEL DONE INTERRUPT BUT NO UNIT ACTIVE>,,<

Cause:	This BUG is not documented yet.

Action:

>)


DEFBUG(CHK,DX2NUE,PHYX2,HARD,<PHYX2 - NO ACTIVE UDB AND DX20 COMPOSITE ERROR SET>,<<T4,D>,<T1,D>>,<

Cause:	This BUG is not documented yet.

Action:

>)


DEFBUG(CHK,DX2RFU,PHYX2,HARD,<PHYX2 - ERROR RECOVERY CONFUSED>,,<

Cause:	This BUG is not documented yet.

Action:

>)


DEFBUG(INF,DX2UNA,PHYX2,HARD,<PHYX2 - ATTENTION INTERRUPT AND UDB NOT ACTIVE>,,<

Cause:	This BUG is not documented yet.

Action:

>)


DEFBUG(CHK,DX2UPE,PHYX2,HARD,<PHYX2 - FAIL TO UPDATE SENSE BYTES DURING INITIALIZATION>,,<

Cause:	This BUG is not documented yet.

Action:

>)


DEFBUG(CHK,DXBASD,PHYP2,HARD,<PHYP2 - ASYCHRONOUS STATUS FROM NON-POSITIONING DRIVE>,<<T1,CHAN>,<T2,CTRL>,<T3,UNIT>>,<

Cause:	Not documented yet.
>)


DEFBUG(CHK,DXBDIE,PHYP2,HARD,<PHYP2 - DX20B MICROCODE HALTED>,<<T1,CHAN>,<Q2,DX20>>,<

Cause:	Not documented yet.
>)


DEFBUG(CHK,DXBDMI,PHYP2,SOFT,<PHYP2 - DX20B MICROCODE IS INVALID>,<<T1,CHAN>,<Q2,DX20>>,<

Cause:	Not documented yet.
>)


DEFBUG(CHK,DXBDNF,PHYP2,HARD,<PHYP2 - DRIVE PRESENTING ASYCHRONOUS STATUS NOT FOUND>,,<

Cause:	Not documented yet.
>)


DEFBUG(CHK,DXBEUI,PHYP2,HARD,<PHYP2 - ERROR TRYING TO INITIALIZE A UNIT>,<<T1,CHAN>,<Q2,DX20>,<T2,UNIT>>,<

Cause:	Not documented yet.
>)


DEFBUG(CHK,DXBEWC,PHYP2,HARD,<PHYP2 - ERROR PRESENT WHEN CONNECTING TO A UNIT>,<<T1,CHAN>,<T2,CTRL>,<T3,UNIT>,<T4,20AND2>>,<

Cause:	Not documented yet.
>)


DEFBUG(HLT,DXBFEX,PHYP2,SOFT,<PHYP2 - ILLEGAL FUNCTION STARTING IO>,,<

Cause:	The routine DX2SIO in PHYP2 was called to start a transfer
	operation for an IORB, but the function code from the IORB
	was illegal.
>)


DEFBUG(CHK,DXBFGS,PHYP2,HARD,<PHYP2 - FAILED TO GET SENSE BYTES>,,<

Cause:	Not documented yet.
>)


DEFBUG(CHK,DXBFUS,PHYP2,HARD,<PHYP2 - FAILED TO UPDATE SENSE BYTES>,,<

Cause:	Not documented yet.
>)


DEFBUG(INF,DXBHLT,PHYP2,HARD,<PHYP2 - DX20B CONTROLLER HALTED>,<<T1,CHAN>,<T2,DX20>,<T3,REG1>,<T4,2AND26>>,<

Cause:	Not documented yet.
>)


DEFBUG(CHK,DXBIEC,PHYP2,SOFT,<PHYP2 - UNKNOWN ERROR CODE FROM DX20>,<<T2,CHAN>,<Q2,DX20>,<T1,STATUS>>,<

Cause:	Not documented yet.
>)


DEFBUG(HLT,DXBIF2,PHYP2,SOFT,<PHYP2 - ILLEGAL FUNCTION STACKING IO>,,<

Cause:	The routine DX2STK in PHYP2 was called to stack a second
	transfer command, but the function in the IORB was illegal.
>)


DEFBUG(HLT,DXBILF,PHYP2,SOFT,<PHYP2 - ILLEGAL FUNCTION AT DONE INTERRUPT>,,<

Cause:	The routine DX2INT in PHYP2 was called to handle a done interrupt
	for a drive.  The IORB which finished I/O contained a function
	code which was illegal.
>)


DEFBUG(HLT,DXBLTF,PHYP2,SOFT,<PHYP2 - LATENCY OPTIMIZATION FAILURE>,,<

Cause:	The routine DX2LAT in PHYP2 was called by PHYSIO to find the best
	IORB for a unit.  However, after scanning all IORBs in the transfer
	wait queue for the unit, no IORB was found that could be returned.
>)


DEFBUG(HLT,DXBMSR,PHYP2,SOFT,<PHYP2 - MULTIPLE SECTORS INDICATED IN ECC RECOVERY>,,<

Cause:	The routine ECCERR in PHYP2 was called to recover from an ECC error
	on a unit.  After correcting the error, the routine ECCUCL in PHYSIO
	was called to update the CCW list.  That routine skipped, indicating
	that more sectors must be read to complete the transfer.  However,
	the RP20 is formatted in pages, and no transfer is ever longer than
	a page, so the skip return should never occur.
>)


DEFBUG(CHK,DXBNFI,PHYP2,HARD,<PHYP2 - NOP FUNCTION FAILED IN INITIALIZATION>,,<

Cause:	Not documented yet.
>)


DEFBUG(CHK,DXBNUD,PHYP2,HARD,<PHYP2 - NO UNIT ACTIVE FOR DONE INTERRUPT>,<<T1,CHAN>,<Q2,DX20>>,<

Cause:	Not documented yet.
>)


DEFBUG(HLT,DXBTNF,PHYP2,SOFT,<PHYP2 - UNIT TYPE NOT FOUND IN TABLE>,,<

Cause:	The routine DX2INI was called to initialize a UDB for an RP20 disk.
	It converted the hardware drive type into the internal drive
	type, and then looked in the physical parameter table (DSKUTP)
	for that type, so that the disk parameters could be obtained.
	The drive type could not be found.
>)


DEFBUG(CHK,DXBTTS,PHYP2,HARD,<PHYP2 - TABLES TOO SMALL FOR THIS MANY DRIVES>,,<

Cause:	Not documented yet.
>)


DEFBUG(CHK,DXBUA1,PHYP2,HARD,<PHYP2 - DONE INTERRUPT AND UNIT WAS NOT ACTIVE>,<<T1,CHAN>,<T2,CTRL>,<T3,UNIT>>,<

Cause:	Not documented yet.
>)


DEFBUG(CHK,DXBUNA,PHYP2,HARD,<PHYP2 - ATTENTION INTERRUPT AND UNIT WAS NOT ACTIVE>,<<T1,CHAN>,<T2,CTRL>,<T3,UNIT>>,<

Cause:	Not documented yet.
>)


DEFBUG(CHK,DXBZEC,PHYP2,HARD,<PHYP2 - ZERO ECC BYTE RETURNED>,,<

Cause:	Not documented yet.
>)


DEFBUG(HLT,DZCLRB,TTYSRV,hard,<UNABLE TO RESET DZ11>,,<

Cause:	This BUGHLT can only occur on the 2020.

	The DZCLR bit is written to the DZ to cause the DZ to clear.  Then
	the code loops, continually checking the DZCLR bit, waiting for
	it to come on, which signals that the DZ has cleared.

	The loop counts up to 2**18, under the assumption that this is
	ample time for the DZ to clear.  If the DZCLR bit does not come on
	after the 2**18 runs out, the DZCLRB BUGHLT occurs.
>)


DEFBUG(CHK,DZLINT,TTYSRV,HARD,<DZ11 LOST INTERRUPT ENABLE>,<<T2,D>>,<

Cause:	This BUG is not documented yet.

Action:

Data:

>)


DEFBUG(CHK,DZOVER,TTYSRV,HARD,<DZ11 SILO OVERRUN>,<<T1,D>>,<

Cause:	This BUG is not documented yet.

Action:

Data:

>)

;-E-

DEFBUG(CHK,EBSPER,APRSRV,HARD,<IO page fail from EBUS parity error>,<<Q1,IOP>,<T1,DATA>>,<

Cause:	An APR interrupt occurred because a word with even parity
	was received by the AR from the EBUS during a PI cycle.
	The monitor has printed a description of the problem on the
	CTY and created a SYSERR block, which will be written into
	the SYSERR file.

Data:	IOP - IOP word
	DATA - bad data
>)

REPEAT 0,<

;EFACF1 AND EFACF3 ARE HERE FOR RELEASE 4 DOCUMENTATION PURPOSES ONLY.
;THEY WERE INVOKED BY THE EFACT JSYS, WHICH WILL NOT EXIST IN MONITORS
;LATER THAN RELEASE 4.

DEFBUG(CHK,EFACF1,JSYSA,SOFT,<EFACT: CLOSF FAILED TO CLOSE FACT FILE.>,<<A,ERRCOD>>,<

Cause:	While processing the EFACT JSYS, the monitor received an error
	from a CLOSF JSYS closing the file PS:<ACCOUNTS>FACT.BIN.

Action:	Depends upon the error code.

Data:	ERRCOD - Error code returned by CLOSF JSYS

>)


DEFBUG(CHK,EFACF3,JSYSA,SOFT,<EFACT: FAILED TO WRITE INTO FACT FILE>,<<B,ERRCOD>>,<

Cause:	While processing the EFACT JSYS, the monitor received an error
	from a BOUT JSYS writing the file PS:<ACCOUNTS>FACT.BIN.

Action:	Depends upon the error code.

Data:	ERRCOD - Error code returned by BOUT JSYS

>)
> ;END REPEAT 0


DEFBUG(HLT,EPTMPE,APRSRV,HARD,<PFCDPE: PARITY ERROR OCCURRED IN THE EPT>,<<T1,PFW>,<T2,PADR>,<T3,BDATA>>,<

Cause:	An AR or ARX parity error occurred in page zero.  Another parity
	error occurred when testing EPT for errors.  The first error 
	probably happened during EPT relative addressing.  T1 has the
	page fail word.  T2 has the physical address.  T3 has the bad
	data word.

>)

DEFBUG(CHK,EXILGO,MEXEC,SOFT,<EXECI - Interrupt during login or logout>,,<

Cause: Control has passed to the mini-exec because the top fork hit
a terminating condition or monitor interrupt.  The top fork EXEC may
have been wiped out.  In addition, the job was trying to log in or
out.

Action: The fork is put into an infinite wait state since any other
action might lead to further itraps, interrupts, looping, etc.
>)


DEFBUG(HLT,EXPAFK,MEXEC,soft,<EXPALL: JOB 0 CFORK FAILED>,,<

Cause:	This will happen if the CFORK JSYS fails to create a fork
	for doing the system-wide expunge of structure PS:.

	This could most likely happen if all the fork slots are used up.
>)


DEFBUG(CHK,EXPRCD,MEXEC,HARD,<EXPALL: RCDIR FAILURE>,,<

Cause:	This BUG is not documented yet.

Action:

>)

;-F-

DEFBUG(HLT,FATCDP,APRSRV,HARD,<FATAL CACHE DIRECTORY PARITY ERROR>,<<A,CONIAP>>,<

Cause:	An APR interrupt occurred because a physical page number with
	even parity was encountered in the cache directory. 

Data:	CONIAP - Result of CONI APR
>)


DEFBUG(HLT,FATMER,APRSRV,HARD,<FATAL MEMORY ERROR>,,<

Cause:	An APR interrupt occurred indicating an SBUS error and no
	MB parity error. However, no MOS controller reports an error.
	The monitor is unable to determine the cause of the SBUS error.
	The monitor has printed a description of the problem on the CTY. 

Action:	Diagnose the memory system.
>)


DEFBUG(CHK,FEBAD,FESRV,HARD,<FEHSD-WRONG FE>,,<

Cause:	This BUG is not documented yet.

Action:

Data:

>)


DEFBUG(CHK,FEBFOV,FESRV,HARD,<FEHSD-BUFFER OVERFLOW>,<<A,D>,<C,D>>,<

Cause:	This BUG is not documented yet.

Action:

Data:

>)


DEFBUG(CHK,FEOCPB,DSKALC,SOFT,<FEFSYS - FAILED TO BACKUP ROOT-DIRECTORY>,<<T1,STRCOD>>,<

Cause:	A copy of the Root-Directory was not made due to one of the
	following errors:
	    1.  Not enough free space
	    2.  Could not get jfn
	    3.  Root-Directory or symbol table is bad

Action:

Data:	Structure unique code

>)


DEFBUG(CHK,FEUSTS,FESRV,HARD,<FESSTS-UNKNOWN STATUS>,,<

Cause:	This BUG is not documented yet.

Action:

Data:

>)


DEFBUG(CHK,FILBAK,FILINI,HARD,<FILCRD: COULD NOT CREATE BACKUP OF ROOT-DIR>,,<

Cause:	This BUG is not documented yet.

Action:

>)


DEFBUG(CHK,FILBOT,FILINI,HARD,<COULD NOT CREATE BOOTSTRAP.BIN FILE>,,<

Cause:	This BUG is not documented yet.

Action:

>)


DEFBUG(HLT,FILBTB,FILINI,soft,<UNABLE TO WRITE BIT TABLE FILE>,,<

Cause:	This BUGHLT will occur when FILRFS is refreshing PS:
	FILRFS calls WRTBTB to write the bit table, and WRTBTB fails
	for a reason other than MSTRX6 (home blocks are bad).  WRTBTB
	will fail for several reasons, including: GETBTB failed to get
	a JFN on the bit table file, the OPENF failed, CHFDB, GTFDB, or
	MODHOM.

Action:	Use EDDT to specifically determine what is failing.
>)


DEFBUG(CHK,FILCCD,FILINI,HARD,<Could not create directory>,,<

Cause:	This BUG is not documented yet.

Action:

>)


DEFBUG(CHK,FILFEF,FILINI,HARD,<Could not create Front End File System>,,<

Cause:	This BUG is not documented yet.

Action:

>)


DEFBUG(CHK,FILHOM,FILINI,HARD,<UNABLE TO REWRITE HOME BLOCKS IN WRTBTB>,,<

Cause:	This BUG is not documented yet.

Action:

>)


DEFBUG(HLT,FILIRD,FILINI,soft,<FILINW: COULD NOT INITIALIZE THE ROOT DIRECTORY>,,<

Cause:	This will occur during special system startup if FILRFS,
	while trying to build PS:, gets a failure return from DIRINI, which
	is trying to initialize the root directory.  DIRINI will fail if its
	call to MAPDIR fails, or if the SETZM which first touches the directory
	fails.  MAPDIR will fail if either the structure or directory number
	is out of range, or if MAPIDX fails to map in the index table.

Action:	Use EDDT to determine exactly what is failing and why.
>)


DEFBUG(CHK,FILJB1,FILINI,HARD,<FILCRD: No room to create standard system directories>,,<

Cause:	This BUG is not documented yet.

Action:

>)


DEFBUG(HLT,FILMAP,FILINI,soft,<FILIN2: COULD NOT MAP IN ROOT-DIRECTORY>,,<

Cause:	During standard system startup, SETDIR failed to map in the
	root directory for consistency checking.  SETDIR will fail if CNVSTR
	fails to convert structure number data, or if MAPDIR fails to map in
	the directory, or if DR0CHK finds a directory header inconsistency.

Action:	Use EDDT to figure out exactly which reason is the cause.
>)


DEFBUG(HLT,FILRID,FILINI,soft,<FILINW: INDEX TABLE ALREADY SET UP FOR ROOT DIR>,,<

Cause:	This BUGHLT will occur if, during a refresh in the FILRFS routine
	during system startup, the SETIDX call fails.  That call is trying to
	set up the index table for the root directory for PS:.  SETIDX fails if
	it is passed a directory number that is out of range, or if the index
	table is already set up but at a different spot than that requested in
	the current call.
>)

DEFBUG(CHK,FIXBAD,FILINI,HARD,<Could not re-write Home Blocks to point to FE Filesystem>,,<

Cause:	This BUG is not documented yet.

Action:

>)


DEFBUG(CHK,FIXBDB,FILINI,HARD,<COULD NOT RE-WRITE HOME BLOCKS TO POINT TO BOOTSTRAP.BIN>,,<

Cause:	This BUG is not documented yet.

Action:

>)


DEFBUG(CHK,FKCTNZ,FORK,soft,<FORK LOCK NEST COUNT NON-ZERO>,<<JOBNO,JOB>,<FORKN,JBFORK>>,<

Cause:	The FLOCK routine has encountered the nest count for the fork lock
	being non-zero, which should not be, since the lock has just been locked
	for the first time.  This is probably due to some other software not
	having cleared the nest count from some previous lock.

Data:	JOBNO -	Job whose fork discovered the non-zero nest count.

	FORKN - Jobwide fork index of the discovering fork.

>)


DEFBUG(CHK,FKWSP1,SCHED,HARD,<LOADBS-UNREASONABLE FKWSP>,<<T1,D>,<T2,D>,<T3,D>>,<

Cause:	This BUG is not documented yet.

Action:

>)


DEFBUG(CHK,FLKINT,FORK,HARD,<FLOCK-CALLED WHILE NOINT>,,<

Cause:	This BUG is not documented yet.

Action:

>)


DEFBUG(CHK,FLKNS,FORK,soft,<FUNLK-LOCK NOT SET>,<<FORKN,JOBFRK>>,<

Cause:	The FUNLK routine, which unlocks the fork lock, detected
	that the lock was already unlocked.  This should not be, since anyone
	calling FUNLK to unlock the lock presumably first called FLOCK to lock
	it!

Data:	JOBFRK - Job fork number of fork desiring the lock


>)


DEFBUG(CHK,FLKTIM,FORK,soft,<FLOCK-FORK LOCK TIMEOUT>,<<FORKN,JOBFRK>,<JOBNO,JOB>,<FLKOWN,OWNER>>,<

Cause:	A fork has been waiting a "long time" for the fork lock.
	This bugchk announces that the system is assuming that some fork has
	neglected to unlock the fork lock, and the waiting fork is being
	given the lock even though someone else still has it.

	The code could be in error here.  The measure of a "long time" is
	calculated according to how many times the lock has been asked for
	and denied.  This number will grow at a rate proportional to the number
	 of forks desiring the lock.  Hence the FLKTIM could occur falsely if
	many forks are all trying to get the fork lock at the same time.

Data:	JOBFRK - Job fork number of fork desiring the lock

	JOB    - Job number desiring the lock

	OWNER  - Job fork number of fork currently holding the lock
>)


DEFBUG(CHK,FRKBAL,PAGEM,HARD,<AGESET-FORK NOT IN BALSET>,,<

Cause:	This BUG is not documented yet.

Action:

>)


DEFBUG(CHK,FRKNDL,SCHED,HARD,<FORK NOT PROPERLY DELETED>,,<

Cause:	This BUG is not documented yet.

Action:

>)


DEFBUG(HLT,FRKPTE,PAGEM,HARD,<BADCPG-FATAL ERROR IN FORK PT PAGE>,,<

Cause:	A hardware error (AR/ARX parity error or MB parity error) was
	detected when the monitor referenced a page in memory that
	contained a process's page table. The monitor has printed
	an analysis of the error on the CTY, and A SYSERR entry will be
	created when the monitor is rebooted.
>)


DEFBUG(HLT,FRKSLF,FORK,soft,<SUSFK - GIVEN SELF AS ARG>,,<

Cause:	Some routine in the monitor has erroneously tried to suspend
	itself with SUSFK.

>)

;-G-

DEFBUG(HLT,GDSTX0,SWPALC,SOFT,<GDSTX CALLED FROM SECTION 0>,<<0(P),PC>>,<

Cause:	A routine in SWPALC that provides an address in the DST was called
	from section 0 on a machine that runs extended addressing. This
	is dangerous because the routine returns a 30-bit address, and the
	caller will probably use the address in an index register, thus
	losing the section number.

Action:	It is essential that any code that references the DST run in a non-zero
	section. The long-term solution is to study the entire stack and make
	all the code run in section 1. For the short term, it may be possible
	to insert an SE1CAL at the beginning of the routine that called GDSTX.
	Note that this may lead to other problems, including slower performance
	and ILMNRF BUGHLT's.

Data:	PC - the PC from which GDSTX was called

>)

DEFBUG(INF,GIVTMR,JSYSA,SOFT,<GIVOK TIMEOUT>,<<T2,FUNC>>,<

Cause:	The access control job has not responded with a GIVOK within the
	designated time period.

Action:	If this consistently happens with the same function code, you
	should see if the processing of the function can be made faster.

	If there is no obvious function code pattern, you may need to
	increase the timeout period or rework the way in which the
	access control program operates.

Data:	FUNC - the GETOK function code 


>)


DEFBUG(HLT,GLFNF,SCHED,HARD,< GLREM - FORK NOT FOUND>,,<

Cause:	The scheduler is trying to remove a process from its linked list of
	runnable processes (the GOLIST).  The BUGHLT occurs because the 
	scheduler does not find the process in the GOLIST.  This indicates an
	inconsistency in the scheduler's data base.

>)


DEFBUG(CHK,GTFDB1,DISC,SOFT,<DSKINS: GETFDB FAILURE.>,,<

Cause:	Cannot find newly created file data block to mark file as being
	temporary.

Action:

>)


DEFBUG(HLT,GTFDB2,DISC,SOFT,<NEWLFP: GETFDB FAILURE FOR OPEN FILE.>,,<

Cause:	Cannot find FDB for a long file, even though the FDB for that file
	was found previously.  The file is opened, but the FDB is gone.

>)


DEFBUG(HLT,GTFDB3,DISC,SOFT,<DSKREN-GETFDB FAILURE FOR OPEN FILE>,,<

Cause:	The RNAMF JSYS has detected a monitor internal error. It has created
	an FDB for the destination file, and an internal routine that
	finds an FBD in a directory has returned with a failure,
	indicating an inconsistency in the newly-created FDB.

>)


DEFBUG(HLT,GTFDB6,JSYSF,SOFT,<CRDI0A: CANNOT DO GETFDB ON ROOT-DIRECTORY >,,<

Cause:	There was an error in creating the Root-Directory.  Either the
	FDB could not be mapped, or the index table could not be set up.

>)

;-H-

DEFBUG(CHK,HARDCE,APRSRV,HARD,<HARD CACHE ERRORS--CACHE DESELECTED>,,<

Cause:	The hardware has detected an AR or ARX parity error that occurs
	only when an address is referenced through the cache. An attempt
	to reference the same address from memory with the cache turned
	off has succeeded. This has happened more than the allowable
	maximum number of times. The monitor will turn off the cache and
	proceed.
	The monitor has printed a description of the problem on the
	CTY and created a SYSERR block, which will be written into
	the SYSERR file.

Action:	The monitor will continue to run without the cache.
	However, when the front end reloads the monitor at some future
	time, the front end will enable the cache. Change its configuration
	file in order to avoid this until the cache is fixed.
>)

DEFBUG(CHK,HPSCHK,SCHED,SOFT,<SCHEDULER - EXCESSIVE TIME IN HIGH PRIORITY>,<<T2,JOBNO>,<FX,FRKNO>>,<

Cause:	A fork has entered a high priority scheduling condition, i.e.
PIBMP, CSKED, or JP%SYS, and has remained compute-bound for more than
5 seconds.  The fork has probably malfunctioned in some way, and
the high scheduling priority is affecting overall system response.

Action:	The high priority status is disabled until the fork itself
clears the condition.
>)


DEFBUG(CHK,HSHERR,JSYSA,HARD,<VERACT - HASH VALUE OUT OF RANGE>,,<

Cause:	This BUG is not documented yet.

Action:

>)


DEFBUG(HLT,HSYFRK,MEXEC,soft,<HSYS-JOB 0 CFORK FAILED>,,<

Cause:	This will occur if the CFORK JSYS fails to create a fork for
	shutting down the system.

	This failure will occur if the forks are totally used up, or if job
	0 has used the maximum number of forks permitted.  NUFKS contains this
	maximum number.
>)

;-I-

DEFBUG(HLT,IBCPYW,PAGEM,SOFT,<COPY-WRITE POINTER IN INDEX BLOCK>,,<

Cause:	A page fault occurred because a process attempted to write into 
	a page whose access was copy-on-write. The BUGHLT indicates that
	the page table is an index block, which should never have copy-
	on-write access.
>)


DEFBUG(HLT,IBOFNF,FILINI,soft,<FILINI: ASOFN FAILURE FOR ROOT DIRECTORY IB>,,<

Cause:	During normal system startup, the call to SETRDO failed
	to set an OFN for the PS: root directory.  SETRDO fails if there is
	no SDB for the structure, of if ASROFN fails to assign an OFN.
>)


DEFBUG(CHK,IDFOD1,SCHED,HARD,<AT MENTR - INTDF OVERLY DECREMENTED>,,<

Cause:	This BUG is not documented yet.

Action:

>)


DEFBUG(CHK,IDFOD2,SCHED,HARD,<AT MRETN - INTDF OVERLY DECREMENTED>,,<

Cause:	This BUG is not documented yet.

Action:

>)


DEFBUG(HLT,IDXNOS,FILINI,soft,<FILINI - COULD NOT ASSIGN FREE SPACE FOR IDXTAB>,,<

Cause:	During a refresh start (PS: is being built), if the call
	to ASGPAG for getting buffer space for the index table fails, this
	BUGHLT happens.  ASGPAG will fail if JBCOR has no 1-bits left in
	it, meaning that there are no free pages left in free space.
>)


DEFBUG(HLT,ILAGE,PAGEM,SOFT,<BAD AGE FIELD IN CST0>,,<

Cause:	The age of a memory page contains an unexpected value. One of the
	following happened:

	1) A page fault occurred and the age was either PSDEL or an
	undefined age LESS THAN PSASN.

	2) A process attempted to assign the page and its age was PSDEL,
	PSSPQ, or an undefined age LESS THAN PSASN.
>)


DEFBUG(HLT,ILBOOT,MEXEC,soft,<GETSWM-ILLEGAL VALUE OF BOOTFL>,,<

Cause:	BOOTFL is an index into a table designating the device from which
	to boot the swappable monitor.  ILBOOT occurs if this index is
	too large.  Note, however, that if it's negative, ILBOOT will not
	occur!
>)


DEFBUG(HLT,ILCHS1,PHYSIO,HARD,<PHYSIO - ILLEGAL CHANNEL STATUS AT SIO>,,<

Cause:	The STRTIO routine was called to begin IO for an IORB, but the
	channel status indicated that the channel was already active
	doing a stacked command.
>)


DEFBUG(HLT,ILCHS2,PHYSIO,HARD,<PHYSIO - ILLEGAL CHANNEL STATE AT STKIO>,,<

Cause:	The STKIO routine was called to set up a second command for
	a channel, but the channel status indicated it already had
	a second command in progress.
>)


DEFBUG(HLT,ILCNSP,PHYSIO,HARD,<PHYSIO - ILLEGAL CALL TO CONSPW>,,<

Cause:	The routine CONSPW was called to remove an element from the
	position wait queue of a unit, but the arguments are illegal.
	Either the arguments are null, or CONSPW is trying to remove more
	than one element because it was passed more than one arguement.

>)


DEFBUG(HLT,ILCNST,PHYSIO,HARD,<PHYSIO - ILLEGAL CALL TO CONSTW>,,<

Cause:	The routine CONSTW was called to remove an element from the
	transfer wait queue of a unit, but the arguments are illegal.
	Either the arguments are null, or CONSTW is trying to remove more than
	one element because it was massed more than one arguement.

>)


DEFBUG(HLT,ILCST1,PAGEM,SOFT,<ILLEGAL ADDRESS IN CST1 ENTRY, CANNOT RESTART>,,<

Cause:	The monitor is attempting to complete I/O that was taking place
	when the system crashed. The backup address in the CST is
	invalid for some core page. Note: This code is executed only
	if the monitor is manually started at location EVRST. This is
	not a recommended procedure.
>)


DEFBUG(HLT,ILDEST,PAGEM,HARD,<ILLEGAL DESTINATION IDENTIFIER TO SETMPG OR SETPT>,,<

Cause:	A routine has been called to change the map for a page. The
	caller provided a source identifier for a page table (an SPT
	index) rather than a single page. The BUGHLT indicates that
	the caller provided as a destination a file page. This is
	illegal when the source is a page table.
>)


DEFBUG(CHK,ILDRA1,SWPALC,HARD,<DASDRM-ILLEGAL OR UNASSIGNED DRUM ADDRESS>,,<

Cause:	This BUG is not documented yet.

Action:

>)

DEFBUG(HLT,ILDRA2,SWPALC,SOFT,<DRMIAD-ILLEGAL DRUM ADDRESS>,,<

Cause:	AN illegal drum address was given to the DRMIAD subroutine, which
	computes disk tracks and sectors.

>)


DEFBUG(HLT,ILFPTE,PAGEM,SOFT,<ILLFPT: ILLEGAL SECTION NUMBER REFERENCED>,,<

Cause:	A routine was called to translate a virtual address into an
	internal identifier. The BUGHLT indicates that the caller provided a
	monitor address that contained an invalid section number. This
	can mean any of the following:

	1. The section number is larger than the maximum possible.

	2. On a machine that does not support extended addressing, a
	non-zero section number was provided.

>)


DEFBUG(HLT,ILGDA1,SWPALC,SOFT,<GDSTX - BAD ADDRESS>,,<

Cause:	A bad drum address was given to the GDSTX routine, which converts drum
	address into indexes into the DST table.  Consequently, the GDSTX
	routine did not try to compute the index.

>)



DEFBUG(HLT,ILGDA2,SWPALC,SOFT,<GDSTX - BAD ADDRESS>,,<

Cause:	Bad index into the DST was computed from a drum address that was given
	to GDSTX for conversion.

>)


DEFBUG(CHK,ILGOKM,JSYSA,SOFT,<ILLEGAL FUNCTION FOR GETOKM CALL>,<<T1,GOKFCN>>,<

Cause:	The GETOKM routine was called with an unknown function code.
	GETOKM handles internal GETOK requests from the monitor.

Data:	GOKFCN - GETOK function code

>)


DEFBUG(CHK,ILIBPT,PAGEM,HARD,<BAD POINTER TYPE IN INDEX BLOCK>,<<W1,D>>,<

Cause:	This BUG is not documented yet.

Action:

>)


DEFBUG(HLT,ILIRBL,PHYSIO,HARD,<PHYSIO - IORB LINK NOT NULL AT ONFPWQ>,,<

Cause:	The routine ONFPWQ was called to place an IORB at the front
	of the position wait queue for a unit.  But the link field
	in the IORB pointing to the next IORB was not null.
>)


DEFBUG(CHK,ILJRFN,FORK,soft,<JFKRFH - BAD JRFN, IGNORED>,,<

Cause:	Routine JFKRFH was erroneously called with a fork number which
	is out of range.  The correct range is a value less than NUFKS.
	JFKRFH changes a fork number into a fork handle.

>)


DEFBUG(CHK,ILLDMS,APRSRV,SOFT,<BADDMS: ILLEGAL DMS JSYS FROM MONITOR CONTEXT>,<<KIMUPC,PC>>,<

Cause:	The monitor has issued a JSYS that requests a service of the
	RMS-20 package.  These JSYSs are legal in user mode only.
	An illegal instruction trap will be given to the current
	process.

DATA:	PC - PC in monitor address space where JSYS was invoked

>)


DEFBUG(CHK,ILLFLT,APRSRV,SOFT,<KA10 FLT PT INSTRUCTION IN MONITOR>,<<KIMUPC,PC>>,<

Cause:	The monitor has executed an instruction whose op code is
	obsolete. It was a floating point instruction on the KA10.
	The microcode treats it as an MUUO. Since these instructions
	have been removed from the monitor, it is likely that an
	instruction has been overwritten.

DATA:	PC - PC in monitor address space where instruction was executed

>)

DEFBUG(HLT,ILLGO,PHYH2,HARD,<INVALID CHANNEL LOGOUT>,,<

Cause:	The routine CKERR was called to check for channel errors after
	an IO operation.  The operation supposedly succeeded according
	to the IORB status bits.  But then, in verifying for a
	short style IORB that the IO was done correctly, the page number
	contained in the channel logout area did not match the number of the
	page on which the IORB wanted to perform IO.
>)


DEFBUG(HLT,ILLIND,PAGEM,SOFT,<ILLEGAL INDIRECT>,,<

Cause:	The microcode was computing an effective address for a monitor
	reference. It followed an indirect reference to a word that had
	both bits 0 and 1 set. This is an illegal format.
>)


DEFBUG(INF,ILLSTR,NSPSRV,SOFT,<NSPTSK-ILLEGAL INIT MESSAGE>,<<Q1,DTE>>,<

Cause:	This BUG is not documented yet.

Action:

Data:

>)


DEFBUG(CHK,ILLTAB,LOGNAM,HARD,<TABLK2: TABLE NOT IN PROPER FORMAT>,,<

Cause:	This BUG is not documented yet.

Action:

>)


DEFBUG(HLT,ILLUUO,APRSRV,SOFT,<KIBADU: ILLEGAL UUO FROM MONITOR CONTEXT>,<<KIMUFL,FLAGS>,<KIMUPC,PC>,<KIMUEF,EFFADR>>,<

Cause:	The monitor has executed an instruction that the microcode
	treats as an MUUO. The op code is not 104 (for a JSYS) or one
	of the KA10 floating point instructions.

Action:	Look for the software bug. Repeated occurrence of this
	BUGHLT may indicate a hardware problem.
DATA:	FLAGS  - Processor flags when MUUO was executed
	PC     - PC in monitor address space where MUUO was executed
	EFFADR - Effective address of MUUO
>)


DEFBUG(HLT,ILMNRF,PAGEM,SOFT,<ILLEGAL REFERENCE TO MON ADR SPACE>,<<T1,PFW>,<T2,FLAGS>,<T3,PC>>,<

Cause:	The monitor made an illegal reference to an address in its map
	and was not prepared to handle the error. The possible errors
	include illegal read, write, and section number. See the page
	fail word for the reason code.

	This BUGHLT can also occur if an unrecoverable AR/ARX parity
	error is detected on certain monitor references. In this
	case, the analysis of the error will already have been
	printed on the CTY.
>)


DEFBUG(HLT,ILOFN1,PAGEM,SOFT,<MSCANP-ILLEG IDENT>,,<

Cause:	A routine has been called to scan the pages of a file to find
	the first non-zero page. Its arguments include an OFN
	associated with the file. The BUGHLT occurs because the caller
	has passed a 0.
>)


DEFBUG(HLT,ILOKSK,SCHED,,<OKSKED EXECUTED WHEN NOT NOSKED>,,<

Cause:	A process has declared itself to be OKSKED and ready to cease running
	(dismiss) until some event occurs.  This BUGHLT occurs because the
	process is OKSKED, indicating a mismatch of NOSKED and OKSKED states.

>)


DEFBUG(HLT,ILPAG1,PAGEM,SOFT,<SWPOT0-INVALID PAGE>,,<

Cause:	A routine was called to swap out a page in core. The BUGHLT
	indicates that the caller provided a bad argument, resulting
	in one of the following:

	1. The page is not in core.

	2. The page is part of the resident monitor.

	3. The page is locked in memory.

	4. The page is already being swapped.
>)


DEFBUG(HLT,ILPAGN,PAGEM,SOFT,<MRKMPG-INVALID PAGE NUMBER>,,<

Cause:	A routine has been called to mark a page as modified (to
	set the CORMB flag in CST0). The BUGHLT indicates that the
	core page number provided by the caller is invalid.
>)


DEFBUG(HLT,ILPDAR,PHYSIO,HARD,<PHYSIO - ILLEGAL DISK ADDRESS IN PAGEM REQUEST>,,<

Cause:	The routine PHYSIO was called to queue up an IORB for PAGEM, but
	the disk or swapping address, or unit was illegal.  All such
	arguments should have been checked by the caller.

>)


DEFBUG(CHK,ILPID1,IPCF,HARD,<CREPID: ATTEMPT TO CREATE ILLEGAL PID>,,<

Cause:	This BUG is not documented yet.

Action:

>)


DEFBUG(CHK,ILPID2,IPCF,HARD,<DELPID: VALIDATED PID TURNED ILLEGAL>,,<

Cause:	This BUG is not documented yet.

Action:

>)


DEFBUG(HLT,ILPLK1,PAGEM,SOFT,<MLKPG-ILLEGAL ARGS>,,<

Cause:	A routine was called to create a page in the monitor's
	address space. But the caller provided a page identifier that either
	did not point to the monitor's map, or pointed to an existing page
	in the monitor's map.
>)


DEFBUG(HLT,ILPPT1,PAGEM,HARD,<UPDOFN-BAD POINTER IN PAGE TABLE>,,<

Cause:	The monitor is updating on the disk the index block for a file.
	The index block contains an address of a file page that is
	incorrect for one of the following reasons:

	1. It is a memory address of non-existent memory or in the
	resident monitor.
	2. There is no disk address for the page.
>)


DEFBUG(HLT,ILPPT3,PAGEM,SOFT,<BAD POINTER IN PAGE TABLE>,,<

Cause:	A page fault occurred because a process touched a page whose
	map entry contained access bits of 0, indicating non-existent
	page. But when the monitor mapped the page table, the page's
	entry was not 0. A non-existent page should always be
	represented by an all-zero entry.
>)


DEFBUG(HLT,ILPSEC,APRSRV,SOFT,<ILLEGAL SECTION NUMBER>,<<TRAPPC,PC>,<TRAPSW,PFW>>,<

Cause:	While running in scheduler context, the monitor made a reference to an
	address whose section number exceeded 37.

Data:	PC - PC when instruction was executed
	PFW - page fail word
>)


DEFBUG(HLT,ILPTN1,PAGEM,SOFT,<MRPACS-ILLEG PTN>,,<

Cause:	A routine has been called to determine the possible access to a
	page. Its arguments include the SPT index for the page table
	associated with the page. The BUGHLT occurs because the caller has
	passed a 0.
>)


DEFBUG(HLT,ILRBLT,PHYSIO,HARD,<PHYSIO - IORB LINK NOT NULL AT ONF/STWQ>,,<

Cause:	One of the routines ONFTWQ or ONSTWQ was called to insert an IORB
	into the transfer wait queue, but the link word for that IORB
	was not zero.  IORBs should always contain a null link when
	they are created or removed from a queue, so that many queue
	handling errors can be detected.
>)


DEFBUG(HLT,ILRFPD,PAGEM,SOFT,<PDL-OV IN ILLEGAL PAGE REFERENCE>,,<

Cause:	The monitor made an illegal reference to an address and was
	prepared to handle the error. However, its stack overflowed in
	processing the error.
>)


DEFBUG(HLT,ILSPTH,PAGEM,SOFt,<SETPT-SPTH INCONSISTENT WITH XB>,,<

Cause:	A routine has been called to change the map for a page of a
	process. The page is being mapped to a file page for which
	the index block has a share pointer. The share pointer points
	to an SPT slot. The BUGHLT indicates that the SPT slot is not
	owned by the file page whose map word points to it. This
	indicates an inconsistency in the monitor's data.
>)


DEFBUG(HLT,ILSPTI,PAGEM,SOFT,<ILLEGAL SPT INDEX GIVEN TO SETMXB>,,<

Cause:	A routine has been called to change the map for a page. The
	caller provided a source identifier for a page table (an SPT
	index) rather than a single page. The BUGHLT indicates that
	the source identifier is an invalid SPT index, larger than the
	maximum value allowed.
>)


DEFBUG(HLT,ILSRC,PAGEM,SOFT,<ILLEGAL SOURCE IDENTIFIER GIVEN TO SETPT>,,<

Cause:	A routine has been called to change the map for a page. The 
	caller is expected to provide an identifier for the source
	that is of the form (SPT index,,page number). The BUGHLT
	indicates that the right half of the identifier contains an illegal
	value (that exceeds 777).
>)


DEFBUG(HLT,ILSTP3,LOOKUP,SOFT,<VERLUK: IMPOSSIBLE SKIP RETURN FROM EXTLUU>,,<

Cause:	During the look-up of a file version, a subroutine was called.  The
	subroutine gave a skip return, which means the version number is
	ambiguous.  It is also likely that a random error occurred.

>)


DEFBUG(HLT,ILSWPA,PAGEM,SOFT,<SWPIN - ILLEGAL SWAP ADDRESS>,,<

Cause:	A routine has been called to swap a page into core. The backup
	address for the page is of an illegal format.
>)


DEFBUG(HLT,ILTWQ,PHYSIO,HARD,<PHYINT - TWQ OR PWQ INCORRECT>,,<

Cause:	In the PHYINT routine to handle an interrupt, after the lower
	level interrupt code has returned, a check is made to see if
	the IORB returned matched the first element of either the position
	wait queue or the transfer wait queue.  The returned IORB did not match
	the first element in the queue checked.
>)


DEFBUG(HLT,ILTWQP,PHYSIO,HARD,<PHYSIO - PWQ OR TWQ TAIL POINTER INCORRECT>,,<

Cause:	The pointer to the last element in the position wait queue or
	transfer wait queue (UDBPWQ or UDBTWQ) points to an IORB which
	has a non-null link to further IORBs.  This is checked in various
	routines such as ONTWQ, ONPWQ, ONSTWQ, ONFPWQ, CONSTW, or CONSPW.
>)


DEFBUG(HLT,ILULK1,PAGEM,SOFT,<MULKPG - TRIED TO UNLOCK PAGE NOT LOCKED>,,<

Cause:	A routine was called to unlock a core page, but the page was
	not in core, indicating it could not have been locked.
>)


DEFBUG(HLT,ILULK2,PAGEM,SOFT,<TRIED TO UNLOCK PAGE NOT LOCKED>,,<

Cause:	A routine was called to unlock a core page, but the page's
	lock count was 0.
>)


DEFBUG(HLT,ILULK3,PAGEM,SOFT,<MULKMP - ILLEGAL MONITOR ADDRESS>,,<

Cause:	A routine was called to unlock a core page in the monitor's
	address space. But the caller provided a page identifier that did not
	point to the monitor's map.
>)


DEFBUG(HLT,ILULK4,PAGEM,SOFT,<MULKCR - ILLEGAL CORE PAGE NUMBER>,,<

Cause:	A routine was called to unlock a core page. The caller provided
	a page number that was illegal because of one of the following:

	1. The page is never locked because it is part of the resident
	monitor

	2. The page does not exist in physical memory.
>)


DEFBUG(HLT,ILUST1,PHYSIO,HARD,<PHYSIO - UNIT STATUS INCONSISTENT AT SIO>,,<

Cause:	The STRTIO routine was called to start IO on a unit for an IORB,
	but the unit or controller status indicated that the unit was
	already active.  IO should never be started on an active drive.
>)


DEFBUG(CHK,ILUST2,PHYSIO,HARD,<PHYSIO - UNIT STATUS INCONSISTENT AT SPS>,,<

Cause:	The routine STRTPS was called to begin a positioning request
	for a unit, but the status indicated that the unit was already
	active and the transfer wait queue was nonempty.
>)


DEFBUG(HLT,ILUST3,PHYSIO,HARD,<PHYSIO - SCHSEK - IMPOSSIBLE UNIT STATUS>,,<

Cause:	The SCHSEK routine was called to start a position request for
	a unit, but the status of the unit indicated it was not idle.
	SCHSEK should only be called when a unit becomes inactive.
>)


DEFBUG(HLT,ILUST4,PHYSIO,HARD,<PHYSIO - CONTROLLER ACTIVE AT SPS>,,<

Cause:	The routine STRTPS was called to begin positioning on a
	unit, but the controller status indicated it was already
	busy.
>)


DEFBUG(HLT,ILUST5,PHYSIO,SOFT,<PHYSIO - ILLEGAL CHANNEL OR CONTROLLER STATE AT STKIO>,,<

Cause:	The STKIO routine was called to stack up a second command for a
	channel, so that the CDB and KDB (if it exists) should have been
	marked as active.  However, at least one of them wasn't active.
>)


DEFBUG(HLT,ILUST6,PHYSIO,SOFT,<PHYSIO - ILLEGAL UNIT STATE AT STKIO>,,<

Cause:	The STKIO routine was called to stack up a second command for
	a channel, but the unit either was not active or was doing
	positioning.
>)


DEFBUG(HLT,ILXBP,PAGEM,SOFT,<SETPT-BAD POINTER IN XB>,,<

Cause:	A routine has been called to change the map for a page of a
	process. The page is being mapped to a file page. The BUGHLT
	indicates that the index block for the file contains an indirect
	pointer in memory. Only share pointers and immediate pointers
	are legal for index blocks.
>)


DEFBUG(HLT,IM2NII,IMAN22,SOFT,<No IMP input buffers>,,<

Cause:	IMISRT was called to start input, but no input buffers
	were available.

>)


DEFBUG(INF,IMINX1,IMPANX,HARD,<UNUSUAL ANI INTERRUPT, CONI ANI IS>,<<T1,CONIAN>>,<

Cause:  An unexpected interrupt was generated by the AN10/AN20.

Action:  Check the AN10/AN20 hardware.

Data:  The data item displayed is a CONI ANI.

>)


DEFBUG(INF,IMINX2,IMPANX,HARD,<IMIERR CALLED, CONI ANI IS>,<<T1,CONIAN>>,<

Cause:  The IMP dropped its ready line, possibly only momentarily.  The
	IMP will drop its ready line if the 20 is tardy (takes more than
	15 seconds to accept data from the IMP), or if the IMP believes
	the 20 to be down.

Action:  Check the hardware and cabling between the IMP and the 20.
	Check to be sure the IMP has not stopped running.

Data:  The data displayed is the result of a CONI ANI.

>)


DEFBUG(INF,IMPABF,IMPDV,HARD,<ASNTBF FAILED>,,<

Cause:	An attempt was made to assign an ARPANET buffer.  No buffers 
	were available.  The code will wait 5 seconds and try again.

Action:	Amount of ARPANET buffer space (NNTBFS) should be increased.

>)

DEFBUG(CHK,IMPAB2,IMPDV,SOFT,<ASNTBF: ASNTBF FAILED WHEN NCPLCK SET>,<<JOBNO,JOB>,<FORKX,FORK>>,<

Cause:	A call was made to ASNTBF to get a new buffer.  It was found
	that we were out of network buffers.  But we had NCPLCK.  This
	would wedge the arpanet code.  We have unlocked NCPLCK.

>)


DEFBUG(HLT,IMPAFB,IMPDV,HARD,<IMPCQ: ATTEMPT TO UNLOCK BUFFER ON FREELIST>,,<

Cause:	A call was made to IMPCQ5 or IMPCQ1 to unlock a buffer, and
	that buffer was found to be in the freelist.

>)


DEFBUG(HLT,IMPALF,IMPDV,HARD,<IMPLKB: ATTEMPT TO LOCK BUFFER ON FREELIST>,,<

Cause:	A call was made to IMPLKB in an attempt to lock a buffer that is
	still in the freelist.

>)


DEFBUG(HLT,IMPAUF,IMPANX,SOFT,<IMPEIN: ATTEMPT TO UNLOCK BUFFER ON FREELIST>,,<

Cause:	A call was made to IMPEI and, in an attempt to release a buffer,
	the buffer was found to be in the freelist.

>)


DEFBUG(CHK,IMPBLK,NETWRK,SOFT,<SNDRFC: Sending RFC for a bad NCP link number>,<<T4,LINK>>,<

Cause:	SNDRFC is sending an RTS NCP control message for a link
	which is greater than LLINK or less than FNLINK.  If the link
	being sent is zero the foreign NCP will sent data for the 
	connection over the control link.

>)


DEFBUG(INF,IMPBSC,IMPDV,HARD,<Message has bad size or count>,<<T1,D>,<T2,D>,<T3,D>,<T4,D>>,<

Cause:	This BUG is not documented yet.

Action:

>)


DEFBUG(HLT,IMPCCF,IMPDV,HARD,<CANNOT CREATE IMP FORK>,,<

Cause:	IMPBEG called RUNDD to create a fork in
	job 0 for the IMP.  The RUNDD call to CFORK failed.

>)


DEFBUG(INF,IMPCTH,IMPDV,HARD,<IMPNCL TOO HIGH>,,<

Cause:	This BUG is not documented yet.

Action:

>)


DEFBUG(INF,IMPCUL,IMPDV,HARD,<RECD CTL MSG FOR UNKNOWN LINK>,<<T1,D>,<T2,D>,<T3,D>>,<

Cause:	This BUG is not documented yet.

Action:

>)


DEFBUG(INF,IMPHIF,IMPDV,HARD,<HSTINI FAILED TO FIND HOST NAME FILE>,,<

Cause:	This BUG is not documented yet.

Action:

>)


DEFBUG(CHK,IMPHNW,IMPDV,HARD,<LHOSTN DISAGREES WITH THE IMP>,,<

Cause:	This BUG is not documented yet.

Action:

>)


DEFBUG(INF,IMPIFC,IMPDV,HARD,<ILL FMT CTL MSG>,<<T2,D>,<T3,D>>,<

Cause:	This BUG is not documented yet.

Action:

>)


DEFBUG(CHK,IMPIFH,IMPDV,HARD,<IMPGC-IMPOSSIBLE FAILURE OF IMPHFL>,,<

Cause:	This BUG is not documented yet.

Action:

>)

DEFBUG(CHK,IMPIOP,IMPANX,HARD,<AN20 CAUSED AN IO PAGE FAIL>,,<

Cause:	The AN20 (or AN10) has caused an IO Page Fail.  

Action:	The AN20 has been shutdown.

>)



DEFBUG(INF,IMPLAE,IMPDV,HARD,<IMPOPL: Link already exists>,<<T2,D>,<T3,D>>,<

Cause:	This BUG is not documented yet.

Action:

>)


DEFBUG(INF,IMPLEO,IMPDV,HARD,<Cannot find LT entry for output message>,<<T1,D>,<T2,D>>,<

Cause:	This BUG is not documented yet.

Action:

>)


DEFBUG(CHK,IMPLTF,IMPDV,HARD,<IMPLT FULL>,,<

Cause:	This BUG is not documented yet.

Action:

>)


DEFBUG(INF,IMPMMX,IMPDV,HARD,<MESSAGE STUCK OR OVERDUE TOO LONG>,<<T1,LINK>,<T2,HOST>>,<

Cause:	A link has a message stuck in output or rfnm overdue for to
	long.  The link has been deleted.

>)


DEFBUG(INF,IMPMSL,IMPDV,HARD,<PKMSG - MSG TOO LARGE>,,<

Cause:	This BUG is not documented yet.

Action:

>)


DEFBUG(INF,IMPMSO,IMPDV,HARD,<MESSAGE STUCK IN OUTPUT QUEUE>,<<T1,D>,<T2,D>>,<

Cause:	This BUG is not documented yet.

Action:

>)


DEFBUG(INF,IMPMUL,IMPDV,HARD,<RECEIVED MSG FOR UNKNOWN LINK>,<<T1,D>,<T2,D>>,<

Cause:	This BUG is not documented yet.

Action:

>)


DEFBUG(HLT,IMPNBC,IMPDV,HARD,<PKMSG: NEGATIVE RESIDUAL BYTE COUNT>,,<

Cause:	While transferring bytes from a source buffer to a network
	output buffer, a negitive byte count was detected.

>)


DEFBUG(INF,IMPNEA,TTYSRV,HARD,<NVT RECEIVED BYTES EXCEEDING ALLOCATION>,,<

Cause:	This BUG is not documented yet.

Action:

>)


DEFBUG(HLT,IMPNII,IMPANX,SOFT,<No IMP input buffers>,,<

Cause:	IMISRT was called to start input, but no input buffers
	were available.

>)


DEFBUG(HLT,IMPNIT,IMPANX,HARD,<no internal TCP buffers>,,<

Cause:	An attempt to allocate a TCP buffer failed due to a lack of free
	buffers.

>)


DEFBUG(INF,IMPNMA,IMPDV,HARD,<PKBY1: NO MSG ALLOCATION>,<<T2,D>,<T3,D>>,<

Cause:	This BUG is not documented yet.

Action:

>)


DEFBUG(INF,IMPREA,IMPDV,HARD,<RECD EXCESS ALL>,<<T1,D>,<T2,D>>,<

Cause:	This BUG is not documented yet.

Action:

>)


DEFBUG(INF,IMPREM,IMPDV,HARD,<UPBRB: Received excessive messages>,<<T1,D>,<T2,D>,<T3,D>>,<

Cause:	This BUG is not documented yet.

Action:

>)


DEFBUG(HLT,IMPRMI,IMPDV,HARD,<IMP - REGULAR MESSAGE ON IRREG QUEUE>,,<

Cause:	While processing messages on the IRREG message queue, a
	regular message was found.

>)


DEFBUG(INF,IMPRNE,IMPDV,SOFT,<RECD NCP ERR>,<<T1,HOST>,<T2,TYPE>,<T3,ARG1>,<T4,ARG2>>,<

Cause:	An NCP ERR message was received from a foreign host.  This could
	be caused either by bugs in the local NCP, or in the foreign NCP.

Action:	These can be ignored unless they are frequent.

Data:	Host number, error type, and the arguments of the error message (which
	depend on the particular error being reported).
>)


DEFBUG(INF,IMPRNO,IMPDV,HARD,<RFNM OVERDUE>,<<T1,D>,<T2,D>>,<

Cause:	This BUG is not documented yet.

Action:

>)


DEFBUG(CHK,IMPTMB,TTYSRV,HARD,<NVTXG1: TOO MANY BREAKS OUTSTANDING>,,<

Cause:	This BUG is not documented yet.

Action:

>)


DEFBUG(HLT,IMPUBF,IMPDV,HARD,<IMULKB: ATTEMPT TO UNLOCK BUFFER ON FREELIST>,,<

Cause:	In the routine IMULKB, an attempt was made to unlock a buffer that
	was on the freelist.

>)


DEFBUG(HLT,IMPUFB,IMPDV,HARD,<IMIP1: ATTEMPT TO UNLOCK BUFFER ON FREELIST>,,<

Cause:	In the routine IMIP, an attempt was made to unlock a buffer that
	was on the freelist.

>)


DEFBUG(INF,IMPURT,IMPDV,HARD,<IMPDV received unexpected RET>,<<T1,D>,<T2,D>>,<

Cause:	This BUG is not documented yet.

Action:

>)


DEFBUG(HLT,IMPUUO,APRSRV,HARD,<IMPOSSIBLE MUUO>,,<

Cause:	The monitor was called at its MUUO handler because the user
	executed an MUUO. However, the op code reported by the
	microcode is in the range 1-37, which should have caused
	an LUUO.
>)


DEFBUG(CHK,IMPUX0,IMPDV,HARD,<IMP JB0 FORK - UNEXPECTED INTERRUPT>,,<

Cause:	This BUG is not documented yet.

Action:

>)


DEFBUG(INF,IMPXBO,IMPDV,HARD,<IRREG MSG BUFFER OVERFLOW>,,<

Cause:	This BUG is not documented yet.

Action:

>)


DEFBUG(INF,IMPXUT,IMPDV,HARD,<Received irreg msg with unknown link or type>,<<T1,HOST>,<T2,LINK>,<T3,TYPE>,<T4,SUBTYP>>,<

Cause:	An irregular message with an unknown link (message-id) or type
	was received.

Action:	This could be caused by protocol experimentation by, or bugs in
	the NCPs of, foreign hosts.  Unless they are extremely frequent,
	they can generally be ignored.

Data:	Host, link, message type, and subtype, of the offending message.

>)


DEFBUG(CHK,INCFLK,SCHED,SOFT,<Fork lock set at return to user>,,<

Cause:	Coding error has neglected to unlock the fork lock.

Action:	The monitor unlocks the fork lock before returning
	to the user. However,  this BUGCHK may be indicative
	of other failures to properly release resources

>)



DEFBUG(INF,INDCNT,DTESRV,HARD,<DTESRV- BAD INDIRECT COUNT>,,<

Cause:	This BUG is not documented yet.

Action:

Data:

>)


DEFBUG(HLT,INVDTE,DTESRV,SOFT,<DTEQ- INVALID DTE SPECIFIED>,,<

Cause:	The DTE request queuer for outgoing messages has been given
	an invalid (greater than 3) DTE number.

Action:	Look at the dump.  The stack should indicate the calling
	routine.

>)


DEFBUG(HLT,IONXM,APRSRV,SOFT,<I/O NXM ON UNIBUS DEVICE>,,<

Cause:	This BUGHLT can only happen on the 2020.  It means a unibus
	address referenced in an IO instruction, such as RDIO, WRIO, or TIOE,
	did not exist.

	References to nonexistent unibus addresses generate a page fail
	code 20.  The 2020 code checks to see if the PI system is on, and if 
	so, the BUGHLT occurs.  The 2020 has a routine called UBGOOD to test to
	see if a unibus address exists (used to see what devices are 
	connected).  The UBGOOD routine turns the PI system off so that it can
	test for a nonexistent unibus address without crashing the machine.
>)


DEFBUG(HLT,IOPGF,APRSRV,SOFT,<IO PAGE FAIL>,<<Q1,IOP>>,<

Cause:	An APR interrupt occurred because an interrupt instruction caused
	a page failure. This probably indicates that the interrupt instruction
	provided by the monitor referenced a page that was not in memory.
	The monitor has already checked for a DTE that made the reference
	and found none. (However, it is possible for a software bug
	to cause a DTE to generate an I/O page fail that the monitor
	cannot detect.)  The monitor has printed a description of the problem on 
	the CTY.

Data:	IOP - IOP word

>)


DEFBUG(CHK,IPCFKH,IPCF,HARD,<CHKPDD: COULD NOT FIND LOCAL FORK HANDLE>,,<

Cause:	This BUG is not documented yet.

Action:

>)


DEFBUG(CHK,IPCFRK,IPCF,HARD,<PIDINB: CANNOT CREATE FORKS FOR IPCF>,,<

Cause:	This BUG is not documented yet.

Action:

>)


DEFBUG(CHK,IPCJB0,IPCF,HARD,<PIDINI: NOT IN CONTEXT OF JOB 0>,,<

Cause:	This BUG is not documented yet.

Action:

>)


DEFBUG(CHK,IPCMCN,IPCF,HARD,<MESREC: MESSAGE COUNT WENT NEGATIVE>,,<

Cause:	This BUG is not documented yet.

Action:

>)


DEFBUG(HLT,IPCOVL,IPCF,SOFT,<PIDINI: PIDS AND FREE POOL OVERLAP, IPCF WILL NOT WORK!>,,<

Cause:	The value of SWFREE so small that it will make it impossible to
	distinguish a free PID from an in-use PID by examining the contents
	of an entry in PIDTBL.  This BUG should appear the first time the
	monitor is run, and it should NEVER appear in the field.  Refer to
	the description of PIDTBL at the beginning of IPCF for more details.

Action:	Move the PSECT that contains SWFREE so that SWFREE is greater
	than MAXPID.

>)


DEFBUG(CHK,IPCSOD,IPCF,HARD,<GETMES: SENDER'S COUNT OVERLY DECREMENTED>,,<

Cause:	This BUG is not documented yet.

Action:

>)

DEFBUG(CHK,ITRLGO,SCHED,SOFT,<ITRAP - Instruction trap while logging in or out>,,<

Cause:	An instruction trap has occurred while a job is logging out or in.
This is unexpected and may cause the job to hang because of resources
not released.

Action: Attempt to continue the logout as if the JSYS had completed
successfully.
>)

;-J-

DEFBUG(HLT,J0NRUN,SCHED,SOFT,<JOB 0 NOT RUN FOR TOO LONG, PROBABLE SWAPPING HANGUP>,,<

Cause:	The monitor creates a job (job 0) that exists for the life of the 
	system.  The top fork of this job (fork 0) runs periodically to 
	perform essential functions.  The BUGHLT occurs when the scheduler 
	detects that fork 0 has not run in too long a time.

	Possible causes for fork 0's not running include the following:
		1. A disk failure that prevents fork 0 from updating the disk
		2. Removal of a  mounted structure
		3. Logic errors in the monitor.

>)


DEFBUG(HLT,JSBNIC,PAGEM,SOFT,<SETPPG-JSB NOT IN CORE>,,<

Cause:	The monitor is establishing the context for running a
	process by making its per-job area be part of the
	monitor's map. It is about to copy the SPT entry for the
	JSB into a special SPT slot. But the JSB is not in core.
>)


DEFBUG(HLT,JTENQE,SCHED,SOFT,<JTENQ WITH BAD NSKED>,,<

Cause:	A process has attempted to lock the JSYS trap lock and found
	it already locked. The process will enter a queue and dismiss until
	the lock becomes available. The BUGHLT occurs because when the process
	decrements its NOSKED counter, the value does not go to 0. This
	means that the process is still NOSKED or it was OKSKED when it
	should have been NOSKED.
>)


;-K-

DEFBUG(CHK,KLIOVF,DTESRV,HARD,<DTESRV-KLINIK DATA BASE TOO LARGE>,<<C,D>>,<

Cause:	This BUG is not documented yet.

Action:

Data:

>)


DEFBUG(INF,KMCBRK,KDPSRV,HARD,<KMC11 broken>,<<Q2,D>>,<

Cause:	This BUG is not documented yet.

Action:

Data:

>)


DEFBUG(INF,KMCFST,KDPSRV,HARD,<KMC11 too fast>,,<

Cause:	This BUG is not documented yet.

Action:

Data:

>)


DEFBUG(HLT,KMCIII,KDPSRV,hard,<KMC11 illegal input interrupt>,<<T1,QPNTR>,<T2,STSBTS>>,<

Cause:	This can only occur on the 2020.

	It happens at KMC11 interrupt level for one of two reasons.  Either
	the putter and taker queue pointers were equivalent, or the "input
	ready" bit was not on in the status word.

Data:	QPNTR	- Pointer to queue

	STSBTS	- Result of doing RDIO on status bit word from KMC11
>)


DEFBUG(INF,KMCLOD,KDPSRV,HARD,<KMC11 LOAD FAILED>,,<

Cause:	This BUG is not documented yet.

Action:

Data:

>)


DEFBUG(CHK,KMCNTI,KDPSRV,HARD,<KMC11 not taking input>,,<

Cause:	This BUG is not documented yet.

Action:

Data:

>)


DEFBUG(INF,KMCNXM,KDPSRV,HARD,<KMC11 NXM>,,<

Cause:	This BUG is not documented yet.

Action:

Data:

>)


DEFBUG(HLT,KPALVH,APRSRV,SOFT,<KEEP ALIVE CEASED>,,<

Cause:	The immediate cause of this BUGHLT is the execution of
	location 71. The front end does this if the monitor has
	not updated its keep-alive counter recently. This usually
	indicates that the monitor is looping and preventing the
	scheduler from running. This can be due to a software
	bug or hardware that interrupts abnormally frequently.
	This BUGHLT can be caused manually by requesting the
	front end to jump to location 71.

Action:	Look at the CTY output to see which case occurred. Look at
	the PC to see where the monitor was
	running. If the crash was done manually, the PC will
	contain 72.
>)

;-L-

DEFBUG(HLT,LCKDIR,DIRECT,SOFT,<ATTEMPT TO LOCK DIRECTORY TWICE FOR SAME FORK>,,<

Cause:	A fork is trying to lock a directory it has already locked.

>)

DEFBUG(CHK,LLLKBD,NSPSRV,SOFT,<UNLOCK LL LOCK WHEN NOT LOCKED>,,
<

Cause:	Call to unlock logical link lock when it was not locked.

Action: Continue.

Data:	None
>)


DEFBUG(CHK,LNGDIR,DIRECT,SOFT,<LONG DIRECTORY FILE IN DIRECTORY:>,<<T3,Dirnum>>,<

Cause:	Subdirectory has incorrect superior directory.

Action: Rebuild index table.

Data: Directory number

>)

DEFBUG(CHK,LNMILI,LOGNAM,HARD,<LNMLUK: ILLEGAL VALUE OF LOGICAL NAME TABLE INDEX>,,<

Cause:	This BUG is not documented yet.

Action:

>)

DEFBUG(CHK,LOKINT,FUTILI,SOFT,<LOCK BEING LOCKED WHILE OKINT>,<<T1,LOCK>,<T2,CALLER>>,<

Cause:	A routine is locking a lock while OKINT.

Action:	Make the process be NOINT for the duration of the lock being locked

Data:	Caller's address in T2, Lock index and flags in T1

>)

DEFBUG(HLT,LOKODR,FUTILI,SOFT,<LOCK REQUESTED OUT OF ORDER>,<<T4,LOKREQ>,<T3,LOKOWN>>,<

Cause:	There is a priority locking scheme in the monitor.  A lock is
	being requested, that should have been locked previously.

Action:	

Data:	LOKREQ - the requested lock
	LOKOWN - the highest lock held thus far
>)

DEFBUG(HLT,LOKWRG,FUTILI,SOFT,<WRONG FORK IS RELEASING LOCK>,<<T4,LOKREQ>,<T3,FORK>>,<

Cause:	A fork is trying to unlock a fork it has never owned, or unlocking
	it too many times.

Action:

Data:	LOKREQ - the requested lock
	FORK   - the fork trying to release the lock
>)


DEFBUG(CHK,LP2IEN,LINEPR,HARD,<LINEPRINTER LOST INTERRUPT ENABLE>,<<U,D>>,<

Cause:	This BUG is not documented yet.

Action:

Data:

>)


DEFBUG(HLT,LUUMN0,APRSRV,SOFT,<LUUO IN MONITOR CONTEXT>,,<

Cause:	While running in section 0, the monitor has executed an LUUO.
	The flags and PC are stored in LUUBLK and LUUBLK+1, respectively.
>)


DEFBUG(HLT,LUUMON,APRSRV,SOFT,<.LBCHK: ILLEGAL LUUO FROM MONITOR CONTEXT>,,<

Cause:	While running in a non-zero section, the monitor executed an
	LUUO. The LUUO block is at the 4 locations starting at .LUTRP.
	Note that the hardware reference manual incorrectly states that
	an LUUO in exec mode becomes an MUUO.
>)

;-M-

DEFBUG(HLT,MAP41F,FORK,soft,<MAPF41 FAILED TO SKIP>,,<

Cause:	The MAPFKH routine calls itself recursively in order to
	find every fork in a specified tree.  For each fork found, the
	instruction following the call to MAPFKH is executed.  MAPFKH
	finally skip-returns in order not to fall into that coinstruction
	at .+1.  The recursive calls skip-return too, merely because they
	fall through the same RETSKP instruction.

	The MAP41F BUGHLT should never happen, and is merely a placeholder
	for the impossible non-skip return from the recursive call to
	MAPFKH.

>)


DEFBUG(HLT,MAPBT1,DSKALC,SOFT,<OFN FOR BIT TABLE IS ZERO>,,<

Cause:	There is no OFN for the file structure bit table currently being
	mapped.

>)

DEFBUG(CHK,MAPCLF,SCHED,SOFT,<FAILED TO CLEAR MAPS WHEN KILLING JOB>,,<

Cause:	A call to MSETPT to clear the job map or process map for
	the top fork of a job being killed has failed.

Action:	Continue.
>)


DEFBUG(HLT,MDDJFN,LOOKUP,SOFT,<GETFDB: CALLED FOR NON-MDD DEVICE>,,<

Cause:	The monitor tried to get a FDB for a device other than a structure.

>)


DEFBUG(HLT,MNTLNG,DSKALC,SOFT,<MNTBTB - BIT TABLE IS A LONG FILE>,,<

Cause:	While mounting the structure, the monitor discovered that the bit table
	for the structure is a long file.
Action: Use CHECKD to rebuild the file structure bit table.  If that does not
	work, recreate the structure.
>)


DEFBUG(HLT,MONPDL,APRSRV,SOFT,<STACK FAULT IN MONITOR>,,<

Cause:	The monitor has executed a PUSH instruction that
	caused a stack overflow.  The central processor
	detected this condition and reported it to the monitor.
	KIMUPC contains the PC of the failing instruction.
>)


DEFBUG(HLT,MPEUTP,APRSRV,HARD,<PFCDPE-UNKNOWN TRAP ON TEST REFERENCE>,,<

Cause:	The monitor was processing an AR or ARX parity error when a
	second error occurred. The monitor retries the reference that
	caused the original error and is prepared to handle a second
	error. However, the BUGHLT indicates that the second error
	(caused by the retry) was not an AR or ARX parity error and
	thus was not expected.
>)


DEFBUG(CHK,MPIDXO,DIRECT,SOFT,<MAPIDX - No OFN for Index Table File>,,<

Cause:	No system file number for structure index table.  Cannot map
	structure index table file.

Action:

Data:

>)


DEFBUG(CHK,MSGCLB,KDPSRV,HARD,<DDCMP transmit message clobbered>,,<

Cause:	This BUG is not documented yet.

Action:

Data:

>)


DEFBUG(CHK,MSGPTR,KDPSRV,HARD,<Bad msg pointer>,,<

Cause:	This BUG is not documented yet.

Action:

Data:

>)


DEFBUG(CHK,MTANOA,MAGTAP,HARD,<IRBDN2: IRBDON CALLED FOR AN ACTIVE IORB>,,<

Cause:	This BUG is not documented yet.

Action:

>)


DEFBUG(CHK,MTANOI,MAGTAP,HARD,<GETUBF: NO QUEUED IORB'S FOR INPUT>,,<

Cause:	This BUG is not documented yet.

Action:

>)


DEFBUG(CHK,MTANOQ,MAGTAP,HARD,<IRBDN1: IRBDON CALLED FOR NON-QUEUED UP IORB>,,<

Cause:	This BUG is not documented yet.

Action:

>)


DEFBUG(CHK,MTAORN,MAGTAP,HARD,<MTDIR0: MAGTAPE IORB OVERRUN>,,<

Cause:	This BUG is not documented yet.

Action:

>)


DEFBUG(HLT,MTARIN,MAGTAP,HARD,<MTAINT: INTERRUPT RECEIVED FOR NONACTIVE IORB>,,<

Cause:	A done interrupt occurred for a magtape IORB, and PHYSIO called
	one of the routines MTAINT, MTDINT, or MTPINT to handle the done
	IORB.  However, the indicated IORB was not marked as being active.
>)


DEFBUG(INF,MTMSG,TAPE,HARD,<FAILED TO SEND MT MESSAGE TO "TAPE" CONTROLLER>,<<T1,ERRCOD>>,

Cause:	This message is from TAPE.  TAPE sends IPCF messages to MOUNTR under 
	certain conditions, such as volume switch.  TAPE was unable to send
	the IPCF message.  The user program involved will get an error
	return to its tape operation.

Action:	There are many reasons IPCF refuses to send a message.  The IPCF error
	code is passed back to the user.  If it is a resource problem, try
	to improve system resources.  If it seems like a monitor bug, change
	the BUGINF to a BUGHLT and find out what the monitor is doing wrong
	(For example, it might be using the wrong PID).


>)


DEFBUG(CHK,MTOFAL,FILATS,HARD,<CPYFU2 FAILED IN MTOAAT>,,<

Cause:	This BUG is not documented yet.

Action:

>)

;-N-

DEFBUG(INF,NABPIP,NRMSRV,HARD,<NRCPCZ - Protocol error. Control pipe being aborted>,<<T4,D>,<T3,D>>,<

Cause:	This BUG is not documented yet.

Action:

Data:

>)


DEFBUG(CHK,NATASG,NRMSRV,HARD,<ATS request for assigning an assigned terminal>,<<T4,D>,<T2,D>,<T1,D>,<T3,D>>,<

Cause:	This BUG is not documented yet.

Action:

Data:

>)


DEFBUG(INF,NBDBUL,NRMSRV,HARD,<TELUSR - Incorrect BULA in RESPONSE message>,<<T4,D>,<T3,D>,<T1,D>,<P2,D>>,<

Cause:	This BUG is not documented yet.

Action:

Data:

>)


DEFBUG(INF,NBDRCD,NRMSRV,HARD,<NRMTOK - Invalid request code (RCODE) received>,<<T4,D>,<T3,D>,<T2,D>,<T1,D>>,<

Cause:	This BUG is not documented yet.

Action:

Data:

>)


DEFBUG(INF,NBDRDA,NRMSRV,HARD,<NRNVER - Invalid RSPDATA count in RESPONSE message>,<<T1,D>,<T4,D>,<T3,D>,<P2,D>>,<

Cause:	This BUG is not documented yet.

Action:

Data:

>)


DEFBUG(INF,NBDRDC,NRMSRV,HARD,<TELUSR - Invalid RSPDATA count in RESPONSE message>,<<T4,D>,<T3,D>,<T1,D>,<P2,D>>,<

Cause:	This BUG is not documented yet.

Action:

Data:

>)


DEFBUG(INF,NBDRRC,NRMSRV,HARD,<NRRJER - Invalid RSPDATA count in RESPONSE message>,<<T1,D>,<T4,D>,<T3,D>,<P2,D>>,<

Cause:	This BUG is not documented yet.

Action:

Data:

>)


DEFBUG(INF,NBDRRS,NRMSRV,HARD,<HRSPER - Invalid RSPCODE in RESPONSE message>,<<T1,D>,<T4,D>,<T3,D>,<P2,D>>,<

Cause:	This BUG is not documented yet.

Action:

Data:

>)


DEFBUG(INF,NBDRSC,NRMSRV,HARD,<NRNVER - Invalid RSPDATA in RESPONSE message>,<<T1,D>,<T4,D>,<T3,D>,<P2,D>>,<

Cause:	This BUG is not documented yet.

Action:

Data:

>)


DEFBUG(INF,NBDRSD,NRMSRV,HARD,<NRRJER - Invalid RSPDATA in RESPONSE message>,<<T1,D>,<T4,D>,<T3,D>,<P2,D>>,<

Cause:	This BUG is not documented yet.

Action:

Data:

>)


DEFBUG(INF,NBDSDC,NRMSRV,HARD,<STATUS - Invalid STSDATA count in STATUS message>,<<T4,D>,<T3,D>,<T1,D>,<Q1,D>>,<

Cause:	This BUG is not documented yet.

Action:

Data:

>)


DEFBUG(INF,NBDSOS,NRMSRV,HARD,<STATUS - Invalid operational status in STATUS message>,<<T4,D>,<T3,D>,<T1,D>,<Q1,D>>,<

Cause:	This BUG is not documented yet.

Action:

Data:

>)


DEFBUG(INF,NBDSTR,NRMSRV,HARD,<STATUS - Invalid RTYPE in STATUS message>,<<T4,D>,<T3,D>,<T1,D>,<Q1,D>>,<

Cause:	This BUG is not documented yet.

Action:

Data:

>)


DEFBUG(INF,NBDSTY,NRMSRV,HARD,<STATUS - Invalid subtype in STATUS message>,<<T4,D>,<T3,D>,<T1,D>,<Q1,D>>,<

Cause:	This BUG is not documented yet.

Action:

Data:

>)


DEFBUG(HLT,NCDWA,CDRSRV,soft,<KSINI: NO CARDREADER UBA WINDOW>,,<

Cause:	This can only occur on the 2020.

	It means the ALUBWA routine gave a failure return, meaning no
	unibus adaptor window is available with which to talk to the
	cardreader.
>)


DEFBUG(INF,NCPFUN,NETWRK,HARD,<NCP FSM RECEIVED FUNNY INPUT>,<<T1,D>,<T2,D>,<UNIT,D>>,<

Cause:	This BUG is not documented yet.

Action:

Data:

>)


DEFBUG(CHK,NDBDEL,NSPSRV,SOFT,<NSP - Error in deleting node name from table>,,<

Cause:	This BUG is not documented yet.

Action:

Data:

>)


DEFBUG(INF,NDINIT,NSPSRV,SOFT,<NSP - Could not add first entry to node table>,,<

Cause:	This BUG is not documented yet.

Action:

Data:

>)


DEFBUG(CHK,NEGJRT,SCHED,SOFT,<UCLOCK: NEGATIVE JOBRT DETECTED>,<<T2,JOBNO>>,<

Cause:	The job runtime (JOBRT) is negative for an existing job.  This
	would cause the job to appear non-existant to most JSYSes.

Action:	Use a reasonable value for JOBRT (0) and logout the job.

Data:	T2/ Job number

>)

DEFBUG(HLT,NETBAF,NETWRK,HARD,<RLNTBF: ATTEMPT TO RELEASE BUFFER ALREADY ON FREE LIST>,,<

Cause:	An attempt was made to release an ARPAnet buffer, but the buffer
	was found to already be on the free list.

>)


DEFBUG(HLT,NETBAU,NETWRK,HARD,<ASNTBF: ATTEMPT TO ASSIGN A BUFFER ALREADY IN USE>,,<

Cause:	An attempt was made to assign an ARPAnet buffer, but the chosen buffer
	was not marked as free, indicating it was in use somewhere else.

>)


DEFBUG(CHK,NETDET,NETWRK,HARD,<NVTDET: COULD NOT CLOSE NVT>,<<T1,D>>,<

Cause:	This BUG is not documented yet.

Action:

Data:

>)


DEFBUG (CHK,NETRBG,NETWRK,SOFT,<RLNTBF: ATTEMPT TO RELEASE BUFFER AT GARBAGE LOCATION>,,<

Cause:	The release-network-buffer routine has been passed an address which
	was not in the legal range of addresses as contained in NETFRE+3 (lower)
	and NETFRE+4 (upper).  The bad pointer is not used for releasing buffers
	so some actual buffer space may be lost for the purposes of allocation.

Action:	If the occurrence is frequent or reproducible, change the BUGCHK to a
	BUGHLT and get one or more dumps to submit with an SPR.  In the dump,
	T2 will have the bad pointer, and the stack may be examinied to find
	the guilty caller.


Data:

>)


DEFBUG(HLT,NETRBL,NETWRK,HARD,<ASNTBF: REQUEST FOR BUFFER LARGER THAN MAXWPM>,,<

Cause:	A request was made to allocate an ARPAnet buffer that was larger than
	the maximum possible size.

>)


DEFBUG(HLT,NETWNS,NETWRK,HARD,<WATNOT: WAS CALLED FROM SCHEDULER LEVEL.>,,<

Cause:	The WATNOT scheduler dismiss routine was called, but the process
	was already in the scheduler.
>)


DEFBUG(HLT,NEWBAK,FILINI,soft,<FILRFS - NEWIB FAILURE FOR BACKUP ROOT-DIR>,,<

Cause:	This BUGHLT happens when NEWIB fails to assign a backup
	index block for the  PS: root directory.  This will happen if DSKASA
	fails to assign a disk address, or if ASROFN fails to assign an
	OFN.
>)


DEFBUG(HLT,NEWROT,FILINI,soft,<FILRFS - NEWIB FAILURE FOR ROOT-DIRECTORY>,,<

Cause:	This is identical to NEWBAK, except it is for the
	primary root directory rather than the backup root directory.
>)


DEFBUG(INF,NINRSP,NRMSRV,HARD,<NRSTTR - Inconsistent RESPONSE message received>,<<T4,D>,<T3,D>,<Q1,D>,<Q3,D>>,<

Cause:	This BUG is not documented yet.

Action:

Data:

>)


DEFBUG(HLT,NLWA,LINEPR,soft,<L2INI:  No lineprinter window available>,,<

Cause:	This can only  happen on the 2020.

	It means that ALUBWA gave a failure return instead of correctly
	assigning a unibus adaptor window with which to talk to the lineprinter.
>)


DEFBUG(CHK,NO2PRT,DSKALC,HARD,<FEFSYS-NO DUAL-PORTED DISK. USING LOGICAL 0>,,<

Cause:	This BUG is not documented yet.

Action:

>)


DEFBUG(HLT,NOACB,SCHED,SOFT,<MENTR - NO MORE AC BLOCKS>,,<

Cause:	When a JSYS is executed from within the monitor, the 
	AC's of the current process are stored in a special area in the 
	monitor.  This area consists of several 20-word blocks that are used 
	successively as one JSYS invokes another.  The BUGHLT indicates that a 
	JSYS has been called but that no 20-word block is left in which to 
	store the contents of the AC's.  This usually means that the counter 
	that the monitor uses to keep track of these blocks has been 
	clobbered.
>)


DEFBUG(HLT,NOADXB,PAGEM,SOFT,<RELOFN-NO DSK ADR FOR XB>,,<

Cause:	A routine has been called to release an OFN. The OFN is the
	identifier for the index block of a file that is being closed.
	This routine forces the index block into memory. The backup
	address for the index block should be on the disk. The BUGHLT
	indicates that the backup address is not on the disk.
>)


DEFBUG(CHK,NOALCM,IPCF,HARD,<ALCMES: CANNOT SEND MESSAGE TO ALLOCATOR>,<<T1,D>>,<

Cause:	This BUG is not documented yet.

Action:

>)


DEFBUG(INF,NOARCS,IPCF,HARD,<ARCMSG: PID for QUASAR is not valid>,,<

Cause:	This BUG is not documented yet.

Action:

>)


DEFBUG(CHK,NOBAT1,DSKALC,HARD,<FAILED TO WRITE PRIMARY BAT BLOCK>,<<T1,CKUNUM>>,<

Cause:	Primary BAT blocks were not written due to one of the following
	errors:
	    1.  Invalid unit or channel specified
	    2.  Channel and unit is not a disk device
	    3.  Hardware error

Action:

Data:	Channel, controller, and unit numbers (12 bits each)

>)


DEFBUG(CHK,NOBAT2,DSKALC,HARD,<FAILED TO WRITE SECONDARY BAT BLOCK>,<<T1,CKUNUM>>,<

Cause:	Secondary BAT blocks were not written due to one of the following
	errors:
	    1.  Invalid unit or channel specified
	    2.  Channel and unit is not a disk device
	    3.  Hardware error

Action:

Data:	Channel, controller, and unit numbers (12 bits each)

>)


DEFBUG(CHK,NOBTB,FILINI,HARD,<FILINI - UNABLE TO OPEN BIT TABLE FILE>,,<

Cause:	This BUG is not documented yet.

Action:

>)


DEFBUG(HLT,NOBTBN,FILINI,soft,<FILINI - UNABLE TO GET SIZE OF BOOTSTRAP.BIN FILE>,,<

Cause:	This BUGHLT should never occur.  The routine that must fail for this
	BUGHLT to occur should never be called, since BOTSIZ will be 0
	on a normal startup, or some non-negative number if the FSIDIA
	routine asked the typist for a number.
>)


DEFBUG(HLT,NOCTY,TTYSRV,SOFT,<UNABLE TO ALLOCATE DATA FOR CTY>,,<

Cause:	During initialization of terminal lines, a call to ASGRES was made
	to get resident free space for the CTY's data base.  The call got
	a failure return - no free space available.


>)


DEFBUG(CHK,NODIR1,IPCF,HARD,<SPLMES: DIRST FAILED ON EXISTING DIRECTORY NAME>,,<

Cause:	This BUG is not documented yet.

Action:

>)


DEFBUG(CHK,NODTEN,DTESRV,SOFT,<DTESRV - NO DTE BUFFERS AVAILABLE IN CRITICAL CASE>,,<

Cause:	A buffer is needed for a queued protocol message to a front-end
	-11 via a DTE.  There are no buffers available, and the
	caller is not prepared to handle failure.

Action:	Assume the message was sent.
>)

DEFBUG(HLT,NOFEFS,FILINI,soft,<FILINI - UNABLE TO GET SIZE OF FRONT END FILE SYSTEM>,,<

Cause:	This BUGHLT occurs if GTFESZ fails to get the size of
	the front end file system, which only happens if ASGPAG fails.
>)


DEFBUG(HLT,NOFNDU,DEVICE,SOFT,<FNDUNT-CANNOT FIND DEVICE FOR JFN>,,<

Cause:	The block that describes the JFN, or the table used to initialize
	the device for the JFN, is clobbered.
>)

DEFBUG(HLT,NOINTL,NSPINT,SOFT,<CALL TO ROUTINE NOT PRESENT IN THIS CONFIGURATION>,,<

Cause:	Internal links are not assembled into this monitor, but a
	routine in the NSPINT module was called.

>)


DEFBUG(CHK,NOINTR,SCHED,HARD,<ITRAP AND PREVIOUS CONTEXT WAS NOINT>,,<

Cause:	This BUG is not documented yet.

Action:

>)


DEFBUG(HLT,NOIORB,PHYSIO,HARD,<SETIRB - MISSING IORB>,,<

Cause:	The routine SETIRB was called for an active unit to return
	the currently active IORB for the unit, but the position wait
	queue or transfer wait queue was empty.
>)


DEFBUG(HLT,NOLEN,DISC,SOFT,<UPDLEN: NO LENGTH INFO FOR OFN>,,<

Cause:	The table OFNLEN, which gives the file length for each OFN, has
	an invalid entry for the OFN in question.
>)


DEFBUG(HLT,NOMCCD,TTYSRV,SOFT,<TTYSRV: ROUTINE CALLED FOR LINE TYPE NOT SUPPORTED>,,<

Cause:	Control passed to a routine not present in this monitor configuration.

Action:	See if TTNUS flag on for relevant line.  Examine stack for path.

>)

DEFBUG(HLT,NOPGT0,DISC,SOFT,<OPNLNG: NO PAGE TABLE 0 IN LONG FILE.>,,<

Cause:	There is no page 0 for long file being opened.

>)


DEFBUG(CHK,NOPID,IPCF,HARD,<PIDKFL: PID DISAPPEARED>,,<

Cause:	This BUG is not documented yet.

Action:

>)


DEFBUG(HLT,NORSXF,DTESRV,SOFT,<FAILED TO GET SPACE FOR MASTER DTE>,,<

Cause:	While attempting to initialize RSX20F protocol for the console
	front end, the call to ASGRES (assign resident free space) failed.

>)


DEFBUG(HLT,NOSEB2,APRSRV,SOFT,<PGMPE-NO SYSERR BUFFER AVAILABLE>,,<

Cause:	An AR or ARX parity error has occurred, and the monitor
	is creating a SYSERR block. The BUGHLT indicates that no
	free space is available for the SYSERR block. UPTPFW
	contains the page fail word.
>)


DEFBUG(CHK,NOSERF,MEXEC,HARD,<CANNOT GTJFN ERROR REPORT FILE>,,<

Cause:	This BUG is not documented yet.

Action:

>)


DEFBUG(CHK,NOSKTR,SCHED,HARD,<ITRAP FROM  OR CSKED CONTEXT>,,<

Cause:	This BUG is not documented yet.

Action:

>)


DEFBUG(CHK,NOSLNM,LOGNAM,HARD,<SLNINI: CANNOT CREATE SYSTEM LOGICAL NAME>,,<

Cause:	This BUG is not documented yet.

Action:

>)


DEFBUG(CHK,NOSPLM,GTJFN,SOFT,<RELJFN: COULD NOT SEND SPOOL MESSAGE TO QUASAR>,,<

Cause:	Could not tell QUASAR of spooled file for output.

Action:

>)


DEFBUG(HLT,NOTOFN,PAGEM,SOFT,<UPDOF0-ARG NOT OFN>,,<

Cause:	A routine has been called to write onto the disk an updated
	index block for a file. However, the identifier that was
	provided by the caller is not a valid id for a file.  (It is not an 
	OFN.)
>)


DEFBUG(HLT,NOUBWA,PHYH11,soft,<RH2NCH: NO UNIBUS WINDOW FOR RH11>,,<

Cause:	This BUGHLT can only occur on the 2020.

	It happens when the call to ALUBWA from the disk initialization
	code gets a failure return.  The only reason ALUBWA would give
	such a failure return is if no more unibus adapter windows are
	available.
>)


DEFBUG(CHK,NOUTF1,DISC,SOFT,<SPLOPN: NOUT OF DIRECTORY NUMBER FAILED>,,<

Cause:	NOUT JSYS failed in trying to open the spooled disk file.

Action:

>)


DEFBUG(CHK,NOUTF2,IPCF,HARD,<SPLMES: NOUT OF GENERATION NUMBER FAILED>,,<

Cause:	This BUG is not documented yet.

Action:

>)


DEFBUG(HLT,NOXADR,STG,soft,<EXTENDED ADDRESSING CONFUSION>,,<

Cause:	This BUGHLT will occur if the monitor is built to
	use extended addressing (EXADF is non-0), and either the APRID
	instruction states that this machine does not have extended
	addressing, or the monitor is only built to use one section (MSEC1
	is 0).
>)


DEFBUG(CHK,NOXRFH,FORK,HARD,<DASFKH - ATTEMPT TO DEASSIGN NONEXISTANT RFH, IGNORED>,,<

Cause:	This BUG is not documented yet.

Action:

>)


DEFBUG(CHK,NPWQPD,PHYSIO,HARD,<PHYSIO - NULL PWQ AT POSITION DONE>,,<

Cause:	A position-done interrupt occured, and the routine PHYPDN was
	called to move IORBs from the position wait queue into the
	transfer wait queue, but the position wait queue was empty.
>)


DEFBUG(CHK,NRFTCL,PHYSIO,HARD,<PHYSIO - NO REQUESTS FOUND FOR CYLINDER SEEKED>,,<

Cause:	The routine PHYPDN was called on a position-done interrupt
	to transfer any IORBs that were on the position wait queue
	into the transfer wait queue; but no IORBs were found which
	were for this cylinder.
>)


DEFBUG(CHK,NRMHTN,NRMSRV,HARD,<NRM PROTOCOL ERROR-TERMINAL NOT ACTIVE>,,<

Cause:	This BUG is not documented yet.

Action:

Data:

>)


DEFBUG(CHK,NRMPQB,NRMSRV,HARD,<PIPDQ - pipe not in background process queue>,<<T3,D>,<Q1,D>,<T4,D>,<T2,D>>,<

Cause:	This BUG is not documented yet.

Action:

Data:

>)


DEFBUG(CHK,NRSND,ATSSRV,HARD,<NRM/ATS - CONTROL PIPE ADDRESS ZERO>,,<

Cause:	This BUG is not documented yet.

Action:

Data:

>)


DEFBUG(HLT,NSKDIS,SCHED,HARD,<DISMISS WHILE NOSKED OR WITH NON-RES TEST ADDRESS>,,<

Cause:	A process has declared its intention to cease running (dismiss) until
	a particular event occurs. The scheduler will test for the occurrence
	of the event by calling a routine that the process has provided.  The
	BUGHLT occurs if one of the following happens:
		1. The process has already declared itself to be 
		NOSKED, thereby preventing the running of other processes;
		2. The test routine is in  part of the monitor's swappable code
		and could therefore cause an illegal page fault in the 
		scheduler.

>)


DEFBUG(CHK,NSKDT2,PAGEM,SOFT,<PGRTRP-BAD NSKED OR INTDF>,,<

Cause:	When a page fault occurred, the running process's indicator
	of interruptibility had an abnormally low value. This could
	cause interruptions to occur when they should not. The monitor
	has set the value to prevent interruptions, but this indicates
	a bug in which too many OKINT's have been executed.
>)


DEFBUG(CHK,NSPACK,NSPSRV,SOFT,<Can't get resident free space for NSP ACKs>,,<

Cause:	When NSP is initialized it makes a series of calls to ASGRES to
	acquire a pool of blocks to be used for sending ACKs.

Action:	This shouldn't happen but if you get 1 or 2 it's ok.  More that
	a couple and you should start investigating by making it a BUGHLT.

>)


DEFBUG(INF,NSPBAD,NSPSRV,SOFT,<NSP has received an unintelligible message>,,<

Cause:	An NSP message has been received which was not in proper format.

Action:

>)


DEFBUG(CHK,NSPBAL,NSPINT,SOFT,<XNSCRT - Nascent block already locked>,,<

Cause:	This BUG is not documented yet.

Action:

>)


DEFBUG(CHK,NSPBPN,NSPSRV,SOFT,<BAD NSP PORT NUMBER>,<<T1,BADDTE>>,<

Cause:	This BUG is not documented yet.

Action:

Data:

>)


DEFBUG(CHK,NSPEXB,NSPINT,SOFT,<.NSINB - Driver provided extraneous buffer>,,<

Cause:	This BUG is not documented yet.

Action:

>)


DEFBUG(INF,NSPFRE,NSPINT,SOFT,<NSP - NO FREE SPACE FOR NSP SEGMENT>,,<

Cause:	This BUG is not documented yet.

Action:

>)


DEFBUG(HLT,NSPFRK,NSPSRV,SOFT,<NSPINI-CFORK FAILED>,<<T1,REASON>>,<

Cause:	When the system comes up, a fork is created under JOB 0 in which
	the DECnet NSP background task runs.  The monitor was unable to
	create the fork.

Data:	REASON - the reason code returned by the CFORK JSYS when it failed.

>)

DEFBUG(INF,NSPGON,NSPSRV,SOFT,<NSP - Logical link look up failed>,,<

Cause:	The NSP timer has discovered a message on its resend queue and
	the logical link owning the message is no longer in the logical
	link data base.

Action:	

>)


DEFBUG(INF,NSPLAT,NSPSRV,SOFT,<NSP response is LATE>,<<T4,NODE>>,<

Cause:	NSP has resent a message a number of times and received no response.

Action:	Normally this is caused by heavy network traffic or a highly
	congested node in the network;  the network software should continue
	to function without major difficulty.  If the condition persists,
	check the quality of the communication path to the node that is not
	responding.

Data:	NODE - the node number(OCTAL) to which we are trying to send
>)


DEFBUG(CHK,NSPLNQ,NSPSRV,SOFT,<REMQUE - Link not queued>,,<

Cause:	This BUG is not documented yet.

Action:

Data:

>)


DEFBUG(INF,NSPNOD,NSPSRV,SOFT,<NSP got a message from an unknown node>,,<

Cause:	An incoming NSP connection attempt was from a node we don't know.
	Either, it was a Phase II node and its name is not in our data base
	or it was from a Phase III node and we were unable to interpret the
	node number.

Action:	The first case indicates that there is a node in the network whose
	node name has not been assigned through NCP.  If you want to
	communicate with the node  NCP>SET NODE number NAME name.

	The second case should be filtered by the DN20.  If it happens the
	DN20 has a bug in Transport.
>)


DEFBUG(CHK,NSPPHV,NSPSRV,HARD,<ULKPIP - Pipe has vanished>,,<

Cause:	This BUG is not documented yet.

Action:

Data:

>)


DEFBUG(CHK,NSPPWA,NSPSRV,HARD,<LOKPIP - Pipe went away>,,<

Cause:	This BUG is not documented yet.

Action:

Data:

>)


DEFBUG(CHK,NSPRSN,NSPSRV,SOFT,<NSP - NUMBER OF ENTRIES COUNT AND ACTUAL QUEUE LENGTH DON'T AGREE>,,<

Cause:	

Action:	

Data:

>)

DEFBUG(CHK,NSPRTH,NSPSRV,SOFT,<NSPTSK- INVALID ROUTING HEADER>,<<T1,LINE>,<T2,BADBYT>>,<

Cause:	An invalid routing header has been detected on a DECnet message.

Action:  If this BUGCHK happens frequently, inform your network administrator.

Data:	LINE - the number of the line which received the invalid message

	BADBYT - the invalid byte


>)


DEFBUG(INF,NSPSTR,NSPSRV,SOFT,<STRMSG - Could not add node to known node table>,,<

Cause:	This BUG is not documented yet.

Action:

Data:

>)


DEFBUG(HLT,NSPUDF,STG,soft,<UNSUPPORTED NETWORK FUNCTION>,,<

Cause:	If the monitor is not built for decnet (DCN is 0), and
	a decnet utility routine is called, this BUGHLT will occur.
	Invoking the following routines will cause this BUGHLT:
	DEDMCB (shut links to dead MCB), NSPSPC (get a network buffer), and
	NSPQ (put a message in the scheduler queue).
>)


DEFBUG(INF,NSTSRP,NRMSRV,HARD,<STATUS - Asynchronous STATUS-REPORT received>,<<Q3,D>,<T2,D>,<T1,D>,<T3,D>>,<

Cause:	This BUG is not documented yet.

Action:

Data:

>)


DEFBUG(HLT,NULQTA,PAGEM,SOFT,<QCHK - NO QUOTA INFO SETUP>,,<

Cause:	The monitor is checking the disk quota to see if a page can be
	added to a file. However, this OFN's pointer into the allocation
	tables is 0, an illegal value. Either the caller provided a bad
	OFN, or the SPT entry for the OFN is incorrect.
>)


DEFBUG(INF,NUNRRC,NRMSRV,HARD,<MONBUG - Unexpected RSPCODE in RESPONSE message>,<<T1,D>,<T4,D>,<T3,D>,<P2,D>>,<

Cause:	This BUG is not documented yet.

Action:

Data:

>)


DEFBUG(INF,NUNRSP,NRMSRV,HARD,<RSPPE - Unexpected RESPONSE message received>,<<T4,D>,<T3,D>,<Q3,D>,<T1,D>>,<

Cause:	This BUG is not documented yet.

Action:

Data:

>)


DEFBUG(INF,NUNSTR,NRMSRV,HARD,<STRPE - Unexpected STATUS-REPORT received>,<<T4,D>,<T3,D>,<T1,D>>,<

Cause:	This BUG is not documented yet.

Action:

Data:

>)


DEFBUG(CHK,NWJTBE,FORK,soft,<NO FREE JTB BLOCKS>,,<

Cause:	Word JTBFRE in the JSB has bit n on if JSYS trap block n is
	available.  The NEWJTB routine assigns trap blocks, looking in JTBFRE
	for a bit on.  If no bit is found to be on in JTBFRE, the NWJTBE bugchk
	occurs.
>)

;-O-

DEFBUG(HLT,OFFONX,JSYSF,SOFT,<ARRST: File marked offline has index blk ptr>,,<

Cause:	In restoring an offline file, it was discovered the file already
	has some contents.
>)


DEFBUG(HLT,OFFSPE,PAGEM,SOFT,<OFFSPQ- PAGE NOT ON SPMQ>,,<

Cause:	A routine has been called to remove a core page from the special
	memory queue. If a page is on the queue, its age should be
	PSSPQ. The BUGHLT indicates that the age is incorrect. The
	entry may or may not actually be on the queue. The caller is
	expected to ensure that the page is on the queue.
>)


DEFBUG(HLT,OKSKBG,SCHED,SOFT,<OKSKD0 - OKSKED WHEN NOT NOSKED>,<<CX,ADR>>,<

Cause:	An OKSKED or OKSKD1 was done when the code was not NOSKED.
	This is bad as sensitive code may be getting messed up due to
	races etc...  A NSKDIS would probably have resulted when a 
	DISMS was done later on.

>)


DEFBUG(HLT,OPOPAC,SCHED,HARD,<MRETN - TRIED TO OVER-POP AC STACK>,,<

Cause:	When a JSYS is executed from within the monitor, the 
	AC's of the current process are stored in a special area in the 
	monitor.  This area consists of several 20-word blocks that are used
	successively as one JSYS calls another.  

	As each nested JSYS returns, the monitor's pointer to this area of 
	memory is decremented.  The BUGHLT indicates that the pointer has
	been decremented too far.  This indicates either a clobbered pointer,
	or an attempt to return from a JSYS without having entered one.

>)


DEFBUG(HLT,OVFLOW,PAGEM,SOFT,<ASOFN - ALLOCATION TABLE OVERFLOW>,,<

Cause:	The monitor maintains information for disk quota enforcement
	in two parallel tables called the allocation tables. These
	contain one entry for each directory to which at least one OFN 
	is assigned (that has at least one file open). The size
	of these tables is the maximum number of OFN's; therefore even
	if every OFN were associated with a unique directory, there
	should be enough room in the allocation tables. The BUGHLT
	indicates that the tables have overflowed.
>)


DEFBUG(INF,OVRDTA,PHYSIO,HARD,<PHYSIO - OVERDUE TRANSFER ABORTED>,<<T1,CHAN>,<T2,CONTRL>,<T3,UNIT>,<T4,FUNC>>,<

Cause:	The routine UNICKT checks the status of each unit periodically.  During
	one such check, some unit had an active IORB which timed out.  The IO 
	operation had been started, but not completed within 17 seconds.  This
	BUGINF can be followed by other BUGINFs or BUGCHKs when the device 
	finally responds (such as PH2DNA).

Action:	If the involved device is a tape drive controlled by a DX20, a
	common cause of the BUGINF is the microcode halting.  Reloading
	the microcode will fix the problem.  Other causes are hardware
	failures, and field service should examine the problem.

Data:	CHAN/	The channel number.
	CONTRL/	The controller number (-1 if no controller).
	UNIT/	The unit number.
	FUNC/	THE OPERATION THAT FAILED.
>)

;-P-

DEFBUG(CHK,P11PAR,PHYH11,HARD,<PHYH11 -- CONTROL WRITE PARITY ERR>,<<T1,D>,<T2,D>>,<

Cause:	This BUG is not documented yet.

Action:

Data:

>)


DEFBUG(CHK,P1NED1,PHYH11,HARD,<PHYH11 - RH11 NON EX DISK READING REGISTER>,<<T1,D>,<T2,D>>,<

Cause:	This BUG is not documented yet.

Action:

Data:

>)


DEFBUG(INF,P1NED3,PHYH11,HARD,<PHYH11 - NON EX DISK ON DONE OR ATN INTERRUPT>,<<T1,D>,<T2,D>>,<

Cause:	This BUG is not documented yet.

Action:

Data:

>)


DEFBUG(CHK,P2RAE1,PHYH2,HARD,<PHYH2 - RH20 REGISTER ACCESS ERROR READING REGISTER>,<<T1,DATAI>,<T2,CONI>,<T3,CHAN>>,<

Cause:	The routine RDREG was called to read a mass-buss register, but
	the read failed due to a register access error from the RH20.
	This is almost always due to a hardware malfunction.

Action:	Call field service.

Data:	DATAI/	The result of a DATAI done after the error was detected.
	CONI/	The CONI which showed the register access error.
	CHAN/	The channel number.
>)


DEFBUG(CHK,P2RAE2,PHYH2,HARD,<PHYH2 - REGISTER ACCESS ERR WRITING REG>,<<T1,DATAI>,<T2,DATA>,<T3,CONI>,<T4,CHAN>>,<

Cause:	The routine WTREG was called to write a mass-buss register,
	but the write failed due to a register access error from the
	RH20.  This is almost always due to a hardware malfunction.

Action:	Call field service.

Data:	DATAI/	The result of a DATAI done after the error was detected.
	DATA/	The register and data that was attempted to be written.
	CONI/	The CONI which showed the register access error.
	CHAN/	The channel number.
>)


DEFBUG(CHK,P2RAE3,PHYH2,HARD,<PHYH2 - REGISTER ACC ERR ON DONE OR ATN INTERRUPT>,<<T1,DATAI>,<T2,CONI>,<T3,CHAN>>,<

Cause:	The routine PHYINT was called to process an interrupt for the
	RH20, and a check was made to see if a register access error
	occured, and it did.  This is almost always due to a hardware
	malfunction.

Action:	Call field service.

Data:	DATAI/	The result of a DATAI done after the error was detected.
	CONI/	The CONI which showed the register access error.
	CHAN/	The channel number.
>)


DEFBUG(CHK,P2RAEX,PHYH11,HARD,<PHYH11 - REGISTER ACCESS ERR WRITING REG>,<<T1,D>,<T2,D>,<T3,D>>,<

Cause:	This BUG is not documented yet.

Action:

Data:

>)


DEFBUG(HLT,PAGLCK,PAGEM,SOFT,<DESPT-PAGE LOCKED>,,<

Cause:	The monitor is attempting to deassign a slot in the non-OFN
	part of the SPT tables. The caller is expected to ensure that
	the SPT is no longer in use. The BUGHLT indicates that the
	SPT slot is associated with a page that has been locked into
	memory even though the SPT share count is 0. This indicates
	an inconsistency in the monitor's data base. Probably the page
	was used as a page table, and not all its page pointers were
	cleared properly. A page table is locked in memory once for
	each page in memory to which it points.
>)


DEFBUG(HLT,PAGNIC,PAGEM,SOFT,<GETCPP-PAGE NOT IN CORE>,,<

Cause:	A routine was called to convert a virtual address or page id
	to its corresponding core page. But the page table is not in
	core.
>)


DEFBUG(HLT,PFCDP,APRSRV,hard,<MEMORY PARITY ERROR>,,<

Cause:	This BUGHLT can only occur on the 2020.  It means a page failure
	caused by a memory parity error has occured.
>)


DEFBUG(HLT,PGNDEL,PAGEM,SOFT,<REMFPB-PAGE NOT COMPLETELY DELETED>,,<

Cause:	A page has been marked as partially deleted and placed on a
	queue. The routine that processes the queue has found that the
	page still has a backup on disk. The routine that marked the
	page should have deleted all backup pages.
>)


DEFBUG(HLT,PGUNDX,PAGEM,SOFT,<PGUNTD-IN NESTED TRAP>,,<

Cause: Attempt to use a special untrap address while in a nested trap.
>)

DEFBUG(CHK,PH1IHM,PHYH11,HARD,<PHYH11 - ILLEGAL HDW MODE - WORD MODE ASSUMED>,,<

Cause:	This BUG is not documented yet.

Action:

Data:

>)


DEFBUG(CHK,PH1PIE,PHYH11,HARD,<PHYH11 - RH11 LOST INTERRUPT ENABLE>,<<T2,D>>,<

Cause:	This BUG is not documented yet.

Action:

Data:

>)


DEFBUG(INF,PH2DNA,PHYH2,HARD,<PHYH2 - DONE INTERRUPT AND CHANNEL NOT ACTIVE>,<<T2,CHAN>>,<

Cause:	The routine RH2INT was called to handle an interrupt on the
	RH20 and the CONI said done was up, but no IO transfer was
	in progress.  If an OVRDTA had previously occured, and the
	device finally responds, this BUGINF can happen.  This usually
	indicates a hardware failure.

Action:	Call field service.

Data:	CHAN/	The channel number.
>)


DEFBUG(CHK,PH2IHM,PHYH2,HARD,<PHYH2 - ILLEGAL HDW MODE - WORD MODE ASSUMED>,,<

Cause:	The routine RH2CCW was called to generate a channel transfer
	word, and one of it's arguments is the data mode to use.  But
	the data mode supplied was illegal.
>)


DEFBUG(CHK,PH2PIM,PHYH2,HARD,<PHYH2 - RH20 LOST PI ASSIGNMENT>,<<T2,CHAN>>,<

Cause:	The routine RH2CHK was called for a periodic check on the status
	of the RH20, and it discovered that the channel assignment of
	the RH20 changed from what it should be.  This usually indicates
	a hardware malfunction.

Action:	Call field service.

Data:	CHAN/	The channel number.
>)


DEFBUG(HLT,PH2WUI,PHYH2,HARD,<WRONG UNIT INTERRUPTED>,,<

Cause:	The routine RH2INT was called to handle an interrupt, and it
	determined that IO had finished for a unit.  The operation was a write 
	operation.  The CONI said that a particular unit completed the IO, but
	that was not the unit to which the IO was begun.  This BUGHLT occurs on
	the second such error for a particular IORB.
>)


DEFBUG(HLT,PHYCH1,PHYSIO,HARD,<PHYSIO - HOME BLOCK CHECK IORB ALREADY ON TWQ>,,<

Cause:	The SCHXFR routine was called to select the next IORB for IO on
	a channel, and one of the units needed it's home blocks checked.
	Then in moving the special home block IORB onto the front of the
	transfer wait queue, it was noticed that the IORB was already on
	the queue.
>)


DEFBUG(INF,PHYCH2,PHYSIO,HARD,<PHYSIO - HOME BLOCK CHECK IORB TIMED OUT>,,<

Cause:	In the PHYCHK routine,which checks the status of all units, the
	special home block check IORB was discovered to be overdue.
	See OVRDTA for additional information.
>)


DEFBUG(INF,PHYCH3,PHYSIO,HARD,<PHYSIO - HOME BLOCK CHECK IORB TIMED OUT BUT WAS NOT ON TWQ>,,<

Cause:	In the PHYCHK routine to check the status of all units, the
	special home block IORB was discovered to be overdue.  However,
	the unit status indicated that the unit was not active, or the
	first IORB on the TWQ was not the home block check IORB.
>)


DEFBUG(HLT,PHYICA,PHYSIO,HARD,<PHYINI - ILLEGAL ARGUMENT TO CORE ALLOC>,,<

Cause:	The routine PHYALC was called asking for a nonpositive number
	of words.  This routine is called to allocate resident storage
	for data such as CDB's, KDB's, and UDB's.
>)


DEFBUG(INF,PHYICE,PHYSIO,HARD,<PHYINI - FAILED TO ASSIGN RESIDENT STG>,,<

Cause:	The routine PHYALC was called to allocate storage for data such
	as a CDB, KDB, or UDB, but there was not enough free resident
	storage to allocate it.  The monitor will simply forget about
	any device for which it cannot build tables.
>)


DEFBUG(HLT,PHYLTF,PHYSIO,HARD,<PHYSIO - SCHLTM - UNEXPECTED LATOPT FAILURE>,,<

Cause:	The routine SCHLTM was called to do disk latency optimization,
	by scanning all units for the best IORB.  A unit was found to have a
	nonnull transfer wait queue, but the lower level code to select the
	best IORB for that unit gave the non-skip return, indicating that no
	IORBs existed.
>)


DEFBUG(CHK,PHYNIR,PHYSIO,HARD,<PHYSIO - NULL INTERRUPT ROUTINE AT OPERATION DONE>,,<

Cause:	The routine DONIRB, when terminating a long IORB, attempted to notify
	higher level code about the finished IORB, but the field in the IORB
	that contained the address to call was zero.
>)


DEFBUG(HLT,PHYP0E,PHYSIO,HARD,<PHYALZ - PAGE 0 STORAGE EXHAUSTED>,,<

Cause:	The routine PHYALZ was called to allocate storage from page 0,
	but no more room is left.  Notice that there are currently no
	callers of this routine, implying that execution of PHYALZ was caused
	some error not directly connected with this section of code.
>)


DEFBUG(CHK,PI1ERR,APRSRV,HARD,<UNEXPECTED UNVECTORED INTERRUPT ON CHANNEL 1>,,<

Cause:	The monitor has received an unvectored hardware interrupt on PI
	channel 1.  Currently, there is no processing assigned to this
	channel.  This could possibly indicate faulty hardware that is
	generating spurious PI requests.
>)


DEFBUG(CHK,PI2ERR,APRSRV,HARD,<UNEXPECTED UNVECTORED INTERRUPT ON CHANNEL 2>,,<

Cause:	The monitor has received an unvectored hardware interrupt on PI
	channel 2.  Currently, there is no processing assigned to this
	channel.  This could possibly indicate faulty hardware that is
	generating spurious PI requests.
>)


DEFBUG(CHK,PI4ERR,APRSRV,HARD,<UNEXPECTED UNVECTORED INTERRUPT ON CHANNEL 4>,,<

Cause:	The monitor has received an unvectored hardware interrupt on PI
	channel 4.  Currently, there is no processing assigned to this
	channel.  This could possibly indicate faulty hardware that is
	generating spurious PI requests.
>)


DEFBUG(CHK,PI5ERR,STG,hard,<UNEXPECTED UNVECTORED INTERRUPT ON CHANNEL 5>,,<

Cause:	If no devices are supposed to exist on the system which cause
	unvectored interrupts on channel 5, and more than ten such interrupts
	happen, this bugchk will occur.

	This bugchk is only possible if your system has no dectape and no
	card punch and no papertape reader.

	It has been observed that the DX20 occasionally causes random
	interrupts.  Having the bugchk not happen until ten such interrupts
	have been received tends to prevent the bugchk from happening.
>)


DEFBUG(CHK,PI6ERR,STG,HARD,<UNEXPECTED UNVECTORED INTERRUPT ON CHANNEL 6>,,<

Cause:	This BUG is not documented yet.

Action:

>)


DEFBUG(CHK,PIDFLF,IPCF,HARD,<CREPID: FREE PID LIST FOULED UP>,,<

Cause:	This BUG is not documented yet.

Action:

>)


DEFBUG(CHK,PIDOD1,IPCF,HARD,<MUTCHO: PID COUNT OVERLY DECREMENTED>,,<

Cause:	This BUG is not documented yet.

Action:

>)


DEFBUG(CHK,PIDOD2,IPCF,HARD,<DELPID: OVERLY DECREMENTED PID COUNT>,,<

Cause:	This BUG is not documented yet.

Action:

>)


DEFBUG(HLT,PIITRP,SCHED,HARD,<INSTRUCTION TRAP WHILE PI IN PROGRESS OR IN SCHEDULER>,,<

Cause:	An error occurred, resulting in an illegal instruction trap. If a JSYS
	were being executed by the monitor, the process would receive an
	error return.  However, in this case the error occurred  while a
	hardware interrupt (PI) was being processed, or while the monitor was
	executing code that starts the scheduler cycle.

>)


DEFBUG(HLT,PISKED,SCHED,HARD,<ENTERED SCHEDULER WITH PI IN PROGRESS>,,<

Cause:	The monitor started to execute the main scheduler routine.  The
	hardware indicates that a hardware interrupt is being held. Since
	hardware interrupts operate at a higher priority than the scheduler,
	this should not happen.
>)


DEFBUG(HLT,PITRAP,PAGEM,SOFT,<PAGER TRAP WHILE PI IN PROGRESS>,,<

Cause:	A page fault occurred while a hardware interrupt was in progress.
	This can be the result of hardware failure or a software bug. If
	the page fail word indicates an AR or ARX parity error, the monitor
	has printed an analysis of the problem on the CTY, and a SYSERR
	entry will be created when the monitor is rebooted.
>)


DEFBUG(CHK,PM2SIO,PHYM2,HARD,<PHYM2 - ILLEGAL FUNCTION AT START IO>,,<

Cause:	This BUG is not documented yet.

Action:

>)


DEFBUG(CHK,PM8SIO,PHYM78,HARD,<PHYM78 - ILLEGAL FUNCTION AT START IO>,,<

Cause:	This BUG is not documented yet.

Action:

>)

DEFBUG(HLT,PRONX2,APRSRV,HARD,<NXM DETECTED BY PROCESSOR>,,<

Cause:	A page fault occurred, indicating that the processor
	attempted to access a memory that did not respond within
	a preset time, and the monitor is presently running in
	process context, and the interrupt system is on. Since
	non-existent memory also produces an APR interrupt,
	which results in an APRNX1 BUGHLT,
	this BUGHLT does not normally occur.

Action:	See APRNX1. Note, however, that the occurrence of this BUGHLT
	instead of APRNX1 may indicate a failure in the interrupt
	system.
>)


DEFBUG(HLT,PSBNIC,PAGEM,SOFT,<SETPPG-PSB NOT IN CORE>,,<

Cause:	The monitor is establishing the context for running a
	process by making its per-process area be part of the
	monitor's map. It is about to copy the SPT entry for the
	PSB into a special SPT slot. But the PSB is not in core.
>)


DEFBUG(CHK,PSINSK,SCHED,HARD,<PSI FROM NOSKED OR CRSKED CONTEXT>,,<

Cause:	This BUG is not documented yet.

Action:

>)


DEFBUG(HLT,PSISTK,SCHED,HARD,<PSI STORAGE STACK OVERFLOW>,,<

Cause:	A software interrupt occurred while a process was running
	in the monitor. The monitor is saving information regarding
	the state of the process so that in can restore that state
	when the process dismisses the interrupt. The BUGHLT indicates
	that the storage area has overflowed.

>)


DEFBUG(HLT,PTAIC,PAGEM,SOFT,<SWPIN - PT PAGE ALREADY IN CORE>,,<

Cause:	A routine has been called to swap a page into core. The id for
	the page indicates that it is a data page. The BUGHLT
	occurred because the entry in its page table contains a core
	address.
>)


DEFBUG(HLT,PTDEL,PAGEM,SOFT,<DESPT-PT NOT DELETED>,,<

Cause:	The monitor is attempting to deassign a slot in the non-OFN
	part of the SPT tables. It assumes that the slot was used as a
	page table. The BUGHLT occurs because the SPT entry or its
	backup address is on disk. The caller probably has used the
	wrong routine in releasing an OFN.
>)


DEFBUG(HLT,PTMPE,APRSRV,HARD,<PAGE TABLE PARITY ERROR>,,<

Cause:	A page fault occurred indicating a page table parity error.
	That is, the pager encountered a page table mapping with
	incorrect parity.
>)


DEFBUG(HLT,PTNIC1,APRSRV,SOFT,<SWPIN - PAGE TABLE NOT IN CORE>,,<

Cause:	A routine has been called to map a page table into a special
	page used only by the swapping routines. The caller is expected
	to provide an identifier for a page that is in memory. When a
	page is in memory, the page table that points to it must be
	in memory. The BUGHLT indicates that the storage address for
	the page table is not a valid core page. This can indicate that the
	page is not in memory or that its memory address is larger
	than the physical memory on the machine. The most likely
	cause is corruption of the monitor's data base.
>)


DEFBUG(HLT,PTNON0,PAGEM,SOFT,<SETPT0 - PREVIOUS CONTENTS NON-0>,,<

Cause:	A routine has been called to change the map for a page of a
	process. The caller is expected to have unmapped any previous
	contents of the page. The BUGHLT indicates that the page table
	contains a non-zero pointer for the page.
>)


DEFBUG(HLT,PTOVRN,PAGEM,SOFT,<UPDPGS-COUNT TOO LARGE>,,<

Cause:	A routine has been called to update, on the disk, pages of a
	file to which a specified index block (OFN) points. The caller
	provides a starting page and a count. The BUGHLT occurs
	because the sum of the two extends beyond the end of the
	index block.
>)


DEFBUG(HLT,PVTRP,APRSRV,HARD,<PROPRIETARY VIOLATION TRAP>,,<

Cause:	A page fault occurred, indicating a proprietary violation while
	the monitor was running in scheduler context. That is, an
	instruction in a public page attempted to reference a
	concealed page. Since TOPS-20 uses only concealed mode, this
	BUGHLT should never happen.
>)


DEFBUG(HLT,PWRFL,APRSRV,HARD,<FATAL POWER FAILURE>,,<

Cause:	The monitor has been started at the power-fail recovery
	code and is attempting to recover. However, the loss
	of power that preceded this occurred too quickly to
	allow an orderly shutdown. Therefore the monitor will
	be reloaded.
>)


DEFBUG(CHK,PWRRES,APRSRV,HARD,<POWER RESTART>,,<

Cause:	The monitor has been started at the power fail recovery code
	and is attempting to recover. This BUGCHK will be followed by
	one of the following messages:
		"Attempting to continue system"
		"PWRDWN .NE. -1, restarting"
	The first will be printed if an orderly shutdown was
	accomplished before the power fail. If so, the system will
	continue. Otherwise, the second message will be printed,
	the monitor will BUGHLT, and the front end will reload
	the monitor.
>)


DEFBUG(HLT,PYILUN,PHYSIO,HARD,<PHYSIO - ILLEGAL UNIT NUMBER>,,<

Cause:	The routine SETUDB was called to find the UDB and KDB pointers
	given the CDB and unit number, but the unit number given was
	out of range.
>)

;-Q-

;-R-

DEFBUG(CHK,RCVNOE,JSYSA,SOFT,<RCVOK - NO ENTRY FOUND IN QUEUE>,,<

Cause:	The RCVOK JSYS has detected that the list of unprocessed GETOK
	requests is empty, but the count of entries in the list is nonzero.
>)


DEFBUG(CHK,RCVTMR,JSYSA,SOFT,<RCVOK TIMEOUT - IGNORING ACCESS CONTROL JOB>,,<

Cause:	The access control job did not do a RCVOK within the designated time
	period.  A GETOK request was pending.

Action:	The access control job should be examined to see if its receiving
	requests can be made faster.

>)


DEFBUG(CHK,RELBAD,FREE,HARD,<RELFRE-BAD BLOCK BEING RELEASED>,<<CX,D>,<A,D>,<B,D>,<C,D>>,<

Cause:	This is a free space problem.  The block being returned does not fit
	into the free space.  When blocks are returned to the free space pool,
	there is a consistancy check preformed.  The block is merged into
	existing blocks that follow it in free space.  This block overlaps
	into existing free blocks.  It can not be merged.

Action:	If the problem persists, change the BUGCHK to a BUGHLT.  Looking at
	the stack will show the caller.  It is possible that the length of the
	current block is incorrect.  It is equally likely that the
	block(s) before this block (in free space) have had incorrect
	lengths on return.  Thus, the caller may not be the culprit.



>)


DEFBUG(HLT,RELFRM,FREE,HARD,<ILLEGAL TO DEASSIGN 0 FREE SPACE>,,<

Cause:	This is a free space problem.  The calling routine is trying to release
	a block of storage of zero length.  It is illegal to free a block of 
	zero length.

Action:	Look at the dump.  Backing up the stack will show which routine made
	the call to release the storage.


>)


DEFBUG(CHK,RELINT,FREE,HARD,<RELFRE CALLED OKINT>,<<A,D>>,<

Cause:	This is a free space problem.  The calling routine is trying to release
	a swapable free space block while it is OKINT.  This is dangerous since
	it could get interrupted and loose the block.  All
	free space actions should occur while NOINT.

Action:	The data supplied gives the address of the calling routine.  Make
	the routine become NOINT when it removes the address of the block
	about to be released from the database.  The routine 
	can be made OKINT when control is returned to it.

>)


DEFBUG(HLT,RELORD,FUTILI,SOFT,<LOCK REQUESTED OUT OF ORDER>,<<T4,LOKREQ>,<T3,LOKOWN>>,<

Cause:	There is a priority locking scheme in the monitor.  A lock is
	being released without first releasing the locks that were locked
	after it.  Thus, the locking and unlocking sequences are not in the
	same order.
Action:	

Data:	LOCK - the index into LCKTAB of this lock
>)

DEFBUG(CHK,RELRNG,FREE,HARD,<RELFRE: BLOCK OUT OF RANGE>,<<B,D>,<A,D>,<D,D>>,<

Cause:	This is a free space problem.  The caller to the free space
	routines is trying to return a block that was not given
	out by the free space manager.  The block is outside the
	range of free space management.

Action:	Look through the dump.  By looking at the stack you
	should be able to determine who called for the releasing
	of the block.
>)


DEFBUG(CHK,RESBAD,FREE,HARD,<RELRES: ILLEGAL ADDRESS PASSED TO RELRES>,<<T1,BADADR>,<T2,CALLER>>,<

Cause:	This is a free space problem.  The caller is trying to release some
	resident free space.  The address being specified is not a legal
	resident free space address.

Action:	If the problem persists change the BUGCHK to a BUGHLT and find the
	caller.  The caller is providing an illegal address.
	Find where the caller get the address and how that location gets
	modified.

Data:	BADADR - the address given to the free space manager

	CALLER - the PC when the free space manager was called

>)


DEFBUG(CHK,RESBAZ,FREE,HARD,<RELRES: FREE BLOCK RETURNED MORE THAN ONCE>,<<T1,BADADR>,<T2,CALLER>>,<

Cause:	This is a free space problem.  The caller is returning a block to 
	residnet free space.  The block being returned is already a released
	block in the resident free space pool.  Thus, the caller is either
	returning the same block twice or has a completely random address which
	is incorrect.

Action:	If the problem persists change the BUGCHK to a BUGHLT.  The caller
	may or may not be the culprit.  It is possible that some other
	routine  is picking up the wrong address and releasing it.

Data:	BADADR - the address given to the free space manager

	CALLER - the PC when the free space manager was called


>)


DEFBUG(CHK,RESBND,FREE,HARD,<RELRES: RELEASING SPACE BEYOND END OF RESIDENT FREE POOL>,<<T1,BADADR>,<T2,CALLER>>,<

Cause:	This is a free space problem.  The caller is trying to release resident
	free space.  The address passed to RELRES is outside the range of the
	resident free space pool.

Action:	If the problem persists change the BUGCHK to a BUGHLT.  


Data:	BADADR - the address given to the free space manager

	CALLER - the PC when the free space manager was called

>)


DEFBUG(HLT,RESCHK,FREE,SOFT,<RELRES:  RESIDENT FREE SPACE WAS OVERWRITTEN>,<<T1,BADADR>,<T2,CALLER>>,<

Cause:	Resident free space has been overwritten.

Action: Look at the header of the free space segment; it contains the PC of the
	assigner of the space.  Try to figure out why more space was used
	than was requested.

Data:	BADDAR - Address passed to RELRES

	CALLER - PC when RELRES was called

>)


DEFBUG(CHK,RFILPF,APRSRV,HARD,<REFILL ERROR PAGE FAIL>,,<

Cause:	A page fault occurred indicating a refill error. This condition
	is indicated by a "hard" failure code of 22 in the page fail
	word and should occur only under KI-style paging.
	TOPS-20 does not use this style of
	paging. The monitor will retry the instruction.
>)


DEFBUG(HLT,RH11CC,PHYH11,soft,<PHYH11 - ILLEGAL CHANNEL COMMAND WORD>,,<

Cause:	This BUGHLT can only occur on the 2020.

	This BUGHLT will happen if the CHSTRT routine encounters an address of
	0 in the channel control word.  The right half of the channel control 
	word is the address.
>)


DEFBUG(HLT,RH1ICF,PHYH11,soft,<PHYH11 - INVALID CHANNEL FUNCTION>,,<

Cause:	This BUGHLT can only happen on the 2020.

	The CHSTRT routine is called to perform disk operations.  On the
	call, Q1 is supposed to contain a function code, and T2 is supposed
	to contain the value to be used for a DATAO.  However, -1 in Q1
	denotes that T2 contains the DATAO but that no function is to
	be done.

	The BUGHLT will occur if T2 is 0, or if T2 is non-0 and Q1 is 0,
	which can only occur due to some caller supplying CHSTRT with
	bad arguments.
>)


DEFBUG(HLT,RH2ICF,PHYH2,HARD,<PHYRH2 - INVALID CHANNEL FUNCTION>,,<

Cause:	The routine CHSTRT was called to start IO on the channel,
	but the supplied arguments were illegal.  Either no DATAO
	word was specified, or the function code was zero.
>)


DEFBUG(HLT,RP4FEX,PHYP4,SOFT,<PHYP4 - ILLEGAL FUNCTION>,,<

Cause:	The routine RP4SIO was called to start IO for a unit, but
	the function code supplied in the IORB was out of range.
>)


DEFBUG(HLT,RP4IF2,PHYP4,SOFT,<PHYP4 - ILLEGAL FUNCTION AT STKIO>,,<

Cause:	The routine RP4STK was called to start stacked IO for a
	unit, but the function code supplied in the IORB was out
	of range.
>)


DEFBUG(HLT,RP4IFC,PHYP4,SOFT,<PHYP4 - ILLEGAL FUNCTION AT CNV>,,<

Cause:	The routine RP4CNV was called to return the cylinder associated
	with an IORB.  The routine checked the function in the IORB, and
	it was illegal.
>)


DEFBUG(HLT,RP4ILF,PHYP4,HARD,<PHYP4 - ILLEGAL FUNCTION ON INTERRUPT>,,<

Cause:	The routine RP4INT was called by the channel routine to handle
	a non-attention interrupt.  The function code for the IORB that
	IO was done for was either illegal, or else the function was
	one which did not transfer data.  Functions which do not transfer
	data should give an attention interrupt.
>)


DEFBUG(HLT,RP4LTF,PHYP4,SOFT,<PHYP4 - FAILED TO FIND TWQ ENTRY AT RP4LTM>,,<

Cause:	The routine RP4LTM was called to find the entry on the transfer
	wait queue which had the best latency.  But after searching the
	queue, no IORB was found to return.  This routine should only
	be called when the transfer wait queue is nonempty.
>)


DEFBUG(HLT,RP4PNF,PHYP4,SOFT,<PHYP4 - DISK PHYSICAL PARAMETERS NOT FOUND>,,<

Cause:	The routine RP4INI was called to initialize a UDB for a disk.
	It converted the hardware drive type into the internal drive
	type, and then looked in the physical parameter table (DSKUTP)
	for that type, so that the disk parameters could be obtained.
	The drive type could not be found.
>)


DEFBUG(CHK,RP4SSC,PHYP4,HARD,<PHYP4 - STUCK SECTOR COUNTER>,<<T1,D>,<T2,D>>,<

Cause:	During initialization of a disk unit in the routine RP4INI,
	the sector counter for the disk was examined to see if it
	was changing as it should.  After watching the value for
	100000 times, it never varied.

Action:	Call field service to fix the disk.  >)


DEFBUG(HLT,RP4UNF,PHYP4,HARD,<PHYP4 - UNIT TYPE NOT FOUND:>,<<T1,D>>,<

Cause:	During initialization of a disk in the routine RP4INI, the
	hardware drive type of the disk was read, and then the XTYPE
	table was searched for the corresponding internal drive type.
	The search failed, indicating the disk was of an unknown type.
>)


DEFBUG(HLT,RPGERR,PAGEM,HARD,<BADCPG-FATAL ERROR IN RESIDENT PAGE>,,<

Cause:	A hardware error (AR/ARX parity error or MB parity error) was
	detected when the monitor referenced a page in memory that
	contained part of the resident monitor. The monitor has printed
	an analysis of the error on the CTY, and A SYSERR entry will be
	created when the monitor is rebooted.
>)


DEFBUG(HLT,RSMFAI,PAGEM,HARD,<RESSMM-FAILED TO ASSIGN SWAP MON PAGE>,,<

Cause:	The monitor is trying to restore the swappable monitor from the
	swapping space after a system crash. It is unable to assign a
	page in the swapping space to which a monitor page was previously
	written. Note: This code is executed only if the monitor is
	manually started at location EVLDGO. This is not a recommended
	procedure.
>)

;-S-

DEFBUG(INF,SBSERF,APRSRV,SOFT,<SBSERR-COULD NOT GET ERROR BLOCK>,,<

Cause:	An APR interrupt occurred because a memory controller detected
	an error in its own operation or in information received over
	the S bus or from a memory module. The monitor has determined
	that a MOS controller is involved. Normally the monitor creates
	a block and records information about the error for later
	retrieval by TGHA. However, no free space is available, so this
	information will be lost.
>)


DEFBUG(HLT,SCDUUO,SCHED,HARD,<UUO IN SCHEDULER>,,<

Cause:	An illegal instruction has been executed while in
	the scheduler's context. Since the scheduler's PSB
	is only a prototype PSB and UPT, allowing this MUUO
	to behave like others results in bizarre errors
	that mask the original problem. This BUGHLT should
	be analyzed like an ILLUUO.

Action:	Most likley a software bug. Analyze this like any other
	ILLUUO.

>)


DEFBUG(HLT,SCPT01,PAGEM,SOFT,<SCNPT - ENTRY IS NOT AN IMMEDIATE POINTER>,,<

Cause:	A routine has been called to release all pages to which a specified
	page table points. The caller must ensure that all pointers
	are immediate pointers to core with no disk backup. The BUGHLT
	indicates that a pointer was not an immediate pointer.
>)


DEFBUG(HLT,SCPT02,PAGEM,HARD,<SCNPT - PAGE WAS NOT DELETED>,,<

Cause:	A routine has been called to release all pages to which a specified
	page table points. The caller must ensure that all pointers
	are immediate pointers to core with no disk backup. The BUGHLT
	indicates that a page had backup on disk.
>)


DEFBUG(CHK,SEBISS,SYSERR,HARD,<SEBCPY-INSUFFICIENT STRING STORAGE IN BLOCK>,,<

Cause:	This BUG is not documented yet.

Action:

>)


DEFBUG(CHK,SEBUDT,SYSERR,HARD,<SEBCPY-UNKNOWN DATA TYPE>,<<T1,D>,<T4,D>>,<

Cause:	This BUG is not documented yet.

Action:

>)


DEFBUG(HLT,SECEX1,PAGEM,SOFT,<SETMPG-ATTEMPT TO MAP NON-EX SECTION>,,<

Cause:	A routine has been calld to modify a process's map for one
	or more pages. A virtual address was provided. The caller is
	expected to provide a valid address. The BUGHLT indicates that
	a section that does not exist in the process's map was
	specified.
>)


DEFBUG(CHK,SERFOF,MEXEC,HARD,<CANNOT OPENF ERROR REPORT FILE>,,<

Cause:	This BUG is not documented yet.

Action:

>)


DEFBUG(HLT,SERFRK,SYSERR,HARD,<SERINI-CANNOT CREATE SYSERR FORK>,,<

Cause:	The cause of this BUGHLT is that Job 0 was unable to create a 
	SYSERR fork.  The specific JSYS that fails is the CFORK JSYS,
	and the dump should have the reason for the failure.  Look at
	LSTERR to determine the reason the CFORK failed.

Action:	The action needed to remedy this problem depends on the error returned
	by CFORK.  Look at that code and try to determine how to 
	undo what it is complaining about.


>)


DEFBUG(CHK,SERGOF,SYSERR,HARD,<SETOFI-CANNOT GTJFN/OPEN SYSERR FILE>,,<

Cause:	This BUG is not documented yet.

Action:

>)


DEFBUG(HLT,SHRNO0,PAGEM,SOFT,<DESPT-SHARE COUNT NON-ZERO>,,<

Cause:	The monitor is attempting to deassign a slot in the non-OFN
	part of the SPT tables. The caller is expected to have ensured
	that the SPT slot is no longer in use. The BUGHLT indicates
	that the share count for the SPT slot is non-zero, indicating
	that some process is using the slot.
>)


DEFBUG(HLT,SHROFD,PAGEM,SOFT,<DWNSHR-OFN SHARE COUNT UNDERFLOW>,,<

Cause:	A routine has been called to decrement the share count for
	an OFN. The BUGHLT indicates that the count was already 0.
>)


DEFBUG(HLT,SHROFN,PAGEM,SOFT,<UPSHR-OFN SHARE COUNT OVERFLOW>,,<

Cause:	The share count for an OFN has been incremented beyond the
	maximum value. It should not be possible for a user program
	to cause this.
>)


DEFBUG(HLT,SKDCL1,SCHED,HARD,<CALL TO SCHEDULER WHEN ALREADY IN SCHEDULER>,,<

Cause:	Code running in scheduler context has attempted to dismiss, block
	or page fault thereby trying to enter scheduler context again.
	This might result from an unexpected page fault or faulty logic,
	i.e. the code doing the dismiss was not expected to be run
	in scheduler context.

>)


DEFBUG(HLT,SKDMPE,APRSRV,HARD,<MPE IN SCHEDULER OR PI CONTEXT>,,<

Cause:	A page fault occurred indicating an AR or ARX parity error
	while the monitor was processing an interrupt or running
	the scheduler. This BUGHLT occurs regardless of whether the
	error is repeated when the reference is retried or not.
	The monitor has printed a description of the problem on the CTY.
	A SYSERR block has been created and will be placed in the
	SYSERR file when the monitor is rebooted.
>)


DEFBUG(HLT,SKDPF1,APRSRV,SOFT,<PAGE FAIL IN SCHED CONTEXT>,,<

Cause:	A page fault occurred while the monitor was running in scheduler
	context, and the page fail word did not indicate a "hard"
	failure. This is probably a software bug because the
	scheduler executes only resident code.  One cause of this failure is a
	reference to a piece of swappable code or data that is not currently in
	memory. The flags and PC are in TRAPFL and TRAPPC; UPTPFW contains 
	the page fail word.
>)


DEFBUG(HLT,SKDTRP,SCHED,HARD,<INSTRUCTION TRAP WHILE IN SCHEDULER>,,<

Cause:	An error occurred, resulting in an illegal instruction
	trap. If a JSYS is being executed by the monitor, the
	process normally receives an error return when this happens.
	However, in this case the error occurred in the scheduler,
	and there is no recovery.

>)


DEFBUG(HLT,SMNOFR,APRSRV,soft,<NO FREE SPACE FOR SM10 VECTORS>,,<

Cause:	The monitor called ASGRES to obtain some free space
	for the unibus adaptor windows.  ASGRES gave a failure return,
	which supposedly means there is no free space left.  This is strange
	since UNBINI, which is calling ASGRES, is only called from SYSLD1 once
	per unibus adaptor during system startup, and hence free space should 
	not be used up.
>)


DEFBUG(CHK,SNPIC,JSYSA,SOFT,<SNPFN3: INSTRUCTION BEING REPLACED HAS CHANGED>,,<

Cause:	This BUG is not documented yet.

Action:

>)


DEFBUG(CHK,SNPLKF,JSYSA,SOFT,<SNPFN0: CANNOT LOCK DOWN PAGE INTO MONITOR>,,<

Cause:	The .SNPLC function of the SNOOP JSYS was trying to lock pages
	from the user address space into the monitor address space.
	It called the SETIOP routine in PAGEM to do this, and SETIOP
	returned +1 indicating failure.

>)


DEFBUG(CHK,SNPODB,JSYSA,SOFT,<SNPF4C: COUNT OF INSERTED BREAK POINTS OVERLY DECREMENTED>,,<

Cause:	The .SNPRB function of the SNOOP JSYS was removing breakpoints,
	and the number of breakpoints in the linked list was greater
	than the breakpoint count.

>)


DEFBUG(CHK,SNPUNL,JSYSA,SOFT,<SNPF5A: CANNOT UNLOCK SNOOP PAGE>,,<

Cause:	The .SNPUL function of the SNOOP JSYS received a failure
	return from the SETIOP routine in PAGEM while trying to unlock
	a page that was locked with the .SNPLC function.

>)


DEFBUG(HLT,SPTFL1,PAGEM,SOFT,<SPT COMPLETELY FULL>,,<

Cause:	The monitor is attempting to assign to a process a slot in the
	non-OFN part of the SPT tables. Normally a linked list points to
	the free slots. The header is now 0, indicating either that there
	is confusion in the list or there is not available slot. The
	monitor normally protects aginst this event by refusing to
	assign additional SPT slots when the available number falls
	below a fixed minimum. This BUGHLT indicates a failure of
	this mechianism or corruption of the free list.
>)


DEFBUG(HLT,SPTFL2,PAGEM,SOFT,<SPT COMPLETELY FULL>,,<

Cause:	A routine has been called to change the map for a page of a
	process. The page is being mapped to a file page that is not
	already shared. The code is going to create an entry for the
	file page in the SPT so that the destination can have a
	share pointer. The choice of a share pointer over an indirect
	pointer was made because the count of available SPT slots
	exceeded a threshold. The BUGHLT occurred because the head
	of the queue of free SPT slots contains a zero, indicating
	that there are no free slots. This means that there is an
	inconsistency in the monitor's data.
>)


DEFBUG(HLT,SPTPIC,PAGEM,SOFT,<SWPIN - SPT PAGE ALREADY IN CORE>,,<

Cause:	A routine has been called to swap a page into core. The id for
	the page indicates that it is a page table. The BUGHLT
	occurred because the SPT
	entry for that page table already contains a core address.
>)


DEFBUG(HLT,SPTSHR,PAGEM,SOFT,<UPSHR-SPT SHARE COUNT OVERFLOW>,,<

Cause:	The share count for an SPT slot (not an OFN) has been
	incremented beyond the maximum value. This can be caused
	by a pathological program.
>)


DEFBUG(CHK,SPWRFL,APRSRV,HARD,<SPURIOUS POWER FAIL INDICATION>,,<

Cause:	A power-fail indication was given, and the monitor has
	executed its sequence for an orderly power-down. The machine
	is still running after a long delay, so the monitor has
	declared the power-fail warning to be a mistake. The system
	will restart as if power had failed.
>)


DEFBUG(CHK,SRQBAD,SCHED,HARD,<SCDRQ-BAD CALL TO SCDRQ7>,,<

Cause:	SCDRQ7 has been called with a function it does not know about.

Action:	Fix the call or fix SCDRQ7 to know about this function.

>)


DEFBUG(HLT,STKOVF,APRSRV,SOFT,<MONITOR STACK OVERFLOW>,,<

Cause:	The monitor's stack overflowed when it entered a common routine
	used for creating temporary storage. This routine adds a
	quantity to the stack pointer (AC 17) and then executes a manual check
	for stack overflow, so it does not go through the normal
	hardware stack fault logic.
>)


DEFBUG(HLT,STRBAD,PAGEM,SOFT,<ASOFN-ILLEGAL STRUCTURE NUMBER>,,<

Cause:	A routine has been called to assign an OFN (index block). The
	caller provided a structure number that was invalid, either
	because that number can never exist, or because it does not
	exist now.
>)


DEFBUG(HLT,STRTER,MEXEC,soft,<FATAL ERROR WHILE PROCESSING PREVIOUS STARTUP ERROR>,,<

Cause:	When a software channel 34 or 35 interrupt happens on fork
	0, the monitor transfers control to the code specified in the right 
	half of MONBK.  This address will often be the starting address of 
	JB0INT.  JB0INT handles errors in fork 0.  While JB0INT is doing its 
	error recovery, it sets MONBK to J0EMER, so that this STRTER BUGHLT
	will occur if another error happens during JB0INT execution.
>)


DEFBUG(HLT,STZERO,FILINI,HARD,<FILINI: STRTAB ENTRY FOR PS IS 0>,,<

Cause:	This will happen if the code that is supposed to set up
	the STRTAB entry for PS: was never executed.  If this happens,
	some data has been corrupted.

>)


DEFBUG(CHK,SUMNR1,SCHED,HARD,<AJBALX-SUMBNR INCORRECT>,<<T3,D>,<T4,D>>,<

Cause:	This BUG is not documented yet.

Action:

>)


DEFBUG(CHK,SUMNR2,SCHED,HARD,<WSMGR-SUMNR INCORRECT>,<<T3,D>,<T4,D>>,<

Cause:	This BUG is not documented yet.

Action:

>)


DEFBUG(CHK,SWPASF,DSKALC,SOFT,<CHKBAT-FAILED TO ASSIGN BAD SWAPPING ADDRESS>,<<T3,STRNAM>,<CKBDRA,ADDR>>,<

Cause:	Swapping address was not assigned due to illegal address or
	already assigned.

Action:

Data:	Sixbit Structure Name, Address to be Assigned

>)


DEFBUG(CHK,SWPFPE,PAGEM,HARD,<SWAP ERROR IN SENSITIVE FILE PAGE>,,<

Cause:	This BUG is not documented yet.

Action:

>)


DEFBUG(CHK,SWPIBE,PAGEM,HARD,<SWAP ERROR IN INDEX BLOCK>,,<

Cause:	A hardware error occurred while the monitor was reading or
	writing an index block either from the file space or
	the swapping area. Future attempts to read this block
	will generate an error. Future attempts to write it may
	produce the same BUGCHK. The page will be marked in the BAT
	blocks.

Action:

>)


DEFBUG(CHK,SWPJSB,PAGEM,HARD,<SWAP ERROR IN JSB PAGE>,,<

Cause:	A hardware error occurred while the monitor was reading or
	writing a page in a process's per-job area in the swapping
	space. Future attempts to read this page
	will generate an error. Future attempts to write it may
	produce the same BUGCHK. The page will be marked in the BAT
	blocks.
>)


DEFBUG(HLT,SWPMNE,PAGEM,HARD,<SWAP ERROR IN SWAPPABLE MONITOR>,,<

Cause:	A hardware error occurred when the monitor was reading a
	page of the swappable monitor from the swapping space.
	A SYSERR entry will be created when the monitor is rebooted,
	but the BAT blocks will not be marked.
>)


DEFBUG(CHK,SWPPSB,PAGEM,HARD,<SWAP ERROR IN PSB PAGE>,,<

Cause:	A hardware error occurred when the monitor was reading or writing
	a page in a process's per-process area to or from the swapping space.
	The monitor will continue to run in an attempt to update the BAT 
	blocks, but will crash with a SWPXXX bughlt as soon as the disk has 
	been updated.  If the monitor is unable to update the disk (in the case
	of the page having the error is needed to update the bat blocks), the
	system will stop with a J0NRUN bughlt, and the flag indicating that
	a serious swap error exists will be set.
>)


DEFBUG(CHK,SWPPT,PAGEM,HARD,<SWAP ERROR IN UNKNOWN PT>,,<

Cause:	A hardware error occurred when the monitor was reading or writing
	a page table in the swapping space. The monitor is unable to
	identify the page table.
	The monitor will continue to run in an attempt to update the BAT 
	blocks, but will crash with a SWPXXX bughlt as soon as the disk has 
	been updated.  If the monitor is unable to update the disk (in the case
	of the page having the error is needed to update the bat blocks), the
	system will stop with a J0NRUN bughlt, and the flag indicating that
	a serious swap error exists will be set.
>)


DEFBUG(CHK,SWPPTP,PAGEM,HARD,<SWAP ERROR IN UNKNOWN PT PAGE>,,<

Cause:	A hardware error occurred when the monitor was reading or writing
	a page from the file system or swapping space. The monitor is
	unable to identify the owning page table.
	The monitor will continue to run in an attempt to update the BAT 
	blocks, but will crash with a SWPXXX bughlt as soon as the disk has 
	been updated.  If the monitor is unable to update the disk (in the case
	of the page having the error is needed to update the bat blocks), the
	system will stop with a J0NRUN bughlt, and the flag indicating that
	a serious swap error exists will be set.
>)


DEFBUG(CHK,SWPSTL,PAGEM,SOFT,<SWAP SPACE TOO LOW AT STARTUP>,,<

Cause:	Insufficient swap space has been allocated for reasonable
	operation.  The swapping space should be at least 4 times
	the size of main (MOS/core) memory.
>)

DEFBUG(CHK,SWPUPT,PAGEM,HARD,<SWAP ERROR IN UPT, OR PSB>,,<

Cause:	A hardware error occurred when the monitor was reading or
	writing a special page (PSB, JSB or user page table) in
	the swapping space.
	The monitor will continue to run in an attempt to update the BAT 
	blocks, but will crash with a SWPXXX bughlt as soon as the disk has 
	been updated.  If the monitor is unable to update the disk (in the case
	of the page having the error is needed to update the bat blocks), the
	system will stop with a J0NRUN bughlt, and the flag indicating that
	a serious swap error exists will be set.
>)

DEFBUG (HLT,SWPXXX,DSKALC,HARD,<UNRECOVERABLE SWAP ERROR FOR CRITICAL PAGE>,,<

Cause:	The monitor had a swap error for a PSB, PT, PTP, or UPT.
	At the time of the error, a BUGCHK reported the problem,
	and allowed the system to continue to record the error in
	SYSERR, and rewrite the BATBLOCK.

>)



DEFBUG(CHK,SYMNOM,JSYSA,HARD,<Unable to map symbol table page>,,<

Cause:	This BUG is not documented yet.

Action:

>)


DEFBUG(CHK,SYMNOU,JSYSA,HARD,<Unable to unmap symbol table page>,,<

Cause:	This BUG is not documented yet.

Action:

>)


DEFBUG(CHK,SYSERF,MEXEC,HARD,<LOGSST-NO SYSERR STORAGE FOR RESTART ENTRY>,,<

Cause:	This BUG is not documented yet.

Action:

>)

;-T-

DEFBUG(CHK,TM2CCI,PHYM2,HARD,<PHYM2 - TM02 SSC OR SLA WONT CLEAR>,,<

Cause:	This BUG is not documented yet.

Action:

>)


DEFBUG(CHK,TM2HER,PHYM2,HARD,<TM2ERR - IS.HER SET ON SUCCESSFUL RETRY>,,<

Cause:	This BUG is not documented yet.

Action:

>)


DEFBUG(CHK,TM2IDM,PHYM2,HARD,<PHYM2 - ILLEGAL DATA MODE AT DONE INT>,,<

Cause:	This BUG is not documented yet.

Action:

>)


DEFBUG(INF,TM2IDX,PHYM2,HARD,<PHYM2 - ILLEGAL RETRY BYTE POINTER>,,<

Cause:	This BUG is not documented yet.

Action:

>)


DEFBUG(CHK,TM2IF2,PHYM2,HARD,<PHYM2 - ILLEGAL FUNCTION ON COMMAND DONE>,,<

Cause:	This BUG is not documented yet.

Action:

>)


DEFBUG(INF,TM2IRF,PHYM2,HARD,<PHYM2 - ILLEGAL FUNCTION DURING RETRY>,,<

Cause:	This BUG is not documented yet.

Action:

>)


DEFBUG(INF,TM2N2S,PHYM2,HARD,<PHYM2 - MORE DRIVES THAN TABLE SPACE, EXCESS IGNORED>,,<

Cause:	This BUG is not documented yet.

Action:

>)


DEFBUG(CHK,TM2NUD,PHYM2,HARD,<PHYM2 - CHANNEL DONE INTERRUPT BUT NO UNIT ACTIVE>,,<

Cause:	This BUG is not documented yet.

Action:

>)


DEFBUG(CHK,TM2RFU,PHYM2,HARD,<PHYM2 - ERROR RECOVERY CONFUSED>,<<T1,D>,<Q1,D>,<T3,D>>,<

Cause:	This BUG is not documented yet.

Action:

>)


DEFBUG(INF,TM2UNA,PHYM2,HARD,<PHYM2 - DONE INTERRUPT AND UDB NOT ACTIVE>,<<Q1,D>,<P3,D>,<T1,D>>,<

Cause:	This BUG is not documented yet.

Action:

>)

DEFBUG(CHK,TM8ADI,PHYM78,HARD,<PHYM78 - DONE INTERRUPT ON ASYNCHRONOUS STATUS>,,<

CAUSE:	This BUG is not documented yet.

Action:

>)

DEFBUG(INF,TM8AEI,PHYM78,HARD,<PHYM78 - ASYNCHRONOUS ERROR INTERRUPT>,<<T1,ICODE>>,<

Cause:	The TM78 gave an asynchronous error interrupt.

Action:	None. The TM78 has been cleared and restarted.

Data:	ICODE/	The interrupt code associated with this interrupt
>)

DEFBUG(CHK,TM8FRS,PHYM78,HARD,<PHYM78 - TM78 FAILED TO RESET>,,<

Cause:	This BUG is not documented yet.

Action:

>)
DEFBUG(INF,TM8N2S,PHYM78,HARD,<PHYM78 - MORE DRIVES THAN TABLE SPACE, EXCESS IGNORED>,,<

Cause:	This BUG is not documented yet.

Action:

>)
DEFBUG(CHK,TM8NUD,PHYM78,HARD,<PHYM78 - CHANNEL DONE INTERRUPT BUT NO UNIT ACTIVE>,,<

Cause:	This BUG is not documented yet.

Action:

>)
DEFBUG(CHK,TM8SNS,PHYM78,HARD,<CAN'T SENSE TU78 STATUS>,,<

Cause:	This BUG is not documented yet.

Action:

>)




DEFBUG(HLT,TNTTMM,IMPDV,HARD,<TOO MANY TELENET MESSAGES AT TNTOUT IN IMPDV>,,<

Cause:	This condition occurs if there are more than two active requests
	for output queued to a single ARPAnet terminal.

>)


DEFBUG(INF,TPBLKB,TAPE,HARD,<MTFLSH returned with BLKF set>,,<

Cause:	This BUGINF is from TAPE.  The tape being read has encountered an
	EOF.  The I/O being done on it is non-blocking I/O.  The monitor 
	tries to clean-up all the outstanding requests (IORB's) before
	processing the trailer labels.  In order to clean up the IORB's
	it would have to block, which it cannot do.  This is a monitor bug.

Action:	No user action is helpful with this bug.


>)


DEFBUG(CHK,TRPSIE,SCHED,HARD,<NO MONITOR FOR TRAPPED FORK>,,<

Cause:	This BUG is not documented yet.

Action:

>)


DEFBUG(HLT,TTBAD1,MEXEC,soft,<BAD DEVICE DESIGNATOR FOR TERMINAL AT ATACH2>,,<

Cause:	The call to CHKDES failed.  This should not happen, since the terminal
	number involved comes from Q3, which is either the number of terminal
	controlling the job, or a user-supplied terminal number from the user's
	AC4.  If a user-supplied number is being used, it was range-checked by
	comparing it to NLINES.  If it is the number of the controlling
	terminal, the job was already verified to be attached somewhere, so
	this BUGHLT should not occur.
>)


DEFBUG(CHK,TTCVOR,TTYSRV,SOFT,<TCOVTA: T1 has been clobbered; bad value: >,<<T1,FUNC>>,<

Cause:	Someone is clobbering T1 during a call to TTLNK3; this should be found.
	For the time being, I'm just catching it and error'ing out.

Action:	Wish hard for 5 years to rewrite TTYSRV (by which time Twenex will
	be totally obsolete, of course).
>)

DEFBUG(HLT,TTDAS1,SCHED,HARD,<HLTJB: UNABLE TO DEASSIGN CONTROLLING TERMINAL>,,<

Cause:	The monitor is killing the last (top) fork in a job and is trying to
	deassign the job's controlling terminal.  The attempt has failed for an
	unexpected reason (one that will not be corrected if the fork waits a
	while).  This indicates inconsistency in the monitor's data base.

>)


DEFBUG(INF,TTFSMS,MEXEC,SOFT,<Failed to send system message>,,<

Cause: Most likely reason for failure is that RSX20F
cannot complete the previous TTMSG request. Typically this
is caused by a hung DH11 line, but could be a software bug
as well.
>)



DEFBUG(HLT,TTICN0,TTYSRV,SOFT,<TCI - NO BUFFER POINTER BUT COUNT NON-0>,,<

Cause:	At TCI0 (get a character from the line's input buffer) the pointer to
	the dynamic data base for the line was 0.  This could either be a
	coding error or the resident table containing the pointers was
	clobbered.

Action:	Look at the dump.  The stack should indicate which routine called
	TCI0 without the pointer.

>)


DEFBUG(CHK,TTILEC,TTYSRV,HARD,<TTSND-UNRECOGNIZED ESCAPE CODE>,<<1,CHAR>,<2,LINE>>,<

Cause:	An unknown function escape character was found in the output
	stream of a terminal. This is an internal software error.

Action:	What a concept!

>)


DEFBUG(HLT,TTLOKB,TTYSRV,SOFT,<BAD TTY LOCK IN TTLCK>,,<

Cause:	The monitor tried to lock a tty line and discovered the lock
	count was overdecremented.

>)

DEFBUG(CHK,TTNAC1,FILMSC,HARD,<LINE NOT ACTIVE AT PTYOPN>,,<

Cause:	This BUG is not documented yet.

Action:

>)


DEFBUG(HLT,TTNAC3,DSKALC,HARD,<CTY NOT ACTIVE AT FSIPBO>,,<

Cause:	The monitor tried to write to the CTY, but the CTY was not available to
	output a character.  The line is not active.

Action:	Call Digital Field Service.

>)


DEFBUG(HLT,TTNAC4,DSKALC,HARD,<CTY NOT ACTIVE AT FSIPBI>,,<

Cause:	CTY was not available to read in a character.

Action:	Call Digital Field Service.

>)


DEFBUG(HLT,TTNAC5,DSKALC,HARD,<CTY NOT ACTIVE AT FSIINI>,,<

Cause:	While mounting the public structure, the monitorfound ithad no CTY on
	which to output information.	

Action:	Call Digital Field Service.

>)


DEFBUG(CHK,TTNAC7,TTYSRV,HARD,<DEALLOCATING INACTIVE LINE>,<<T2,D>>,<

Cause:	This BUG is not documented yet.

Action:

>)


DEFBUG(HLT,TTNAC8,DEVICE,SOFT,<CANNOT ASSIGN TERMINAL AT DEVINI>,,<

Cause:	The monitor could not assign a terminal to a job because
	    1.  Failed to get resident storage
	    2.  Line is not fully active; it is okay for system messages
		and sendalls.  Need a CNTRL/C on line.
	    3.  Programming error

Action:

>)


DEFBUG(HLT,TTOCN0,TTYSRV,SOFT,<TTSTO - NO BUFFER BUT COUNT NON-0>,,<

Cause:	At TTSTO5 (get a character from the line's output buffer) the
	pointer to the line's data base was 0.  This could either be a coding
	error or the resident table containing the pointers has been
	clobbered.

Action:	Look at the dump.  The stack should indicate which routine made
	the call without a pointer.

>)


DEFBUG(HLT,TTONOB,TTYSRV,SOFT,<TTY OUTPUT - NO BUFFER BUT COUNT NON-0>,,<

Cause:	At TTSND7 (send a character to a line) the pointer to the
	line's data base was 0.  This is either a coding error or the resident
	table containing the pointers was clobbered.

Action:	Look at the dump.  The stack should indicate which routine
	made the call without a pointer.

>)

DEFBUG(CHK,TTQADX,TTYSRV,SOFT,<TTYSRV-UNKNOWN FUNCTION REQUESTED>,<<T3,ADR>>,<

Cause:	TTQAD has been called with a routine address which is not
	in its local table of known routines.

Action:	Look at the stack to see find the call to TTQAD, then find
	the name of the routine being passed and add it to the TQFNT
	table.
>)


DEFBUG(CHK,TTULKB,TTYSRV,HARD,<BAD TTY UNLOCK IN ULKTT>,,<

Cause:	The monitor tried to unlock the tty and it was allready 
	unlocked.
>)

DEFBUG(CHK,TTYBBO,TTYSRV,HARD,<TTYSRV-BIG BUFFER OVERFLOW>,,<

Cause:	The buffer for incoming TTY characters was full.  (The character
	was discarded and the line XOFFed.)

Action:

>)


DEFBUG(CHK,TTYNTB,TTYSRV,HARD,<RAN OUT OF TTY BUFFERS>,,<

Cause:	This BUG is not documented yet.

Action:

>)

DEFBUG(INF,TTYSTP,TTYSRV,HARD,<TTYSRV - LINE HAS BEEN SHUT OFF BECAUSE OF EXCESSIVE INPUT RATE>,<<T2,LINE>>,<

Cause:	A terminal line on RSX20F is generating input at an excessive
	rate.  It is being shut off for 3 seconds by having its input
	speed set to 0.

Diagnosis: This can result from a noisy line which has a high input
	baud rate.  If an EIA line, it may be too long and so
	picks up electrical noise.  This problem can be prevented
	by eliminating the noise or reducing the input speed.

>)


DEFBUG(HLT,TWQNUL,PHYSIO,HARD,<PHYSIO - PWQ OR TWQ WAS NULL AT A SEEK OR TRANSFER COMPLETION>,,<

Cause:	When IO completed on a unit, either OFFTWQ or OFFPWQ was called to
	remove the current IORB from the position wait queue or the transfer 
	wait queue.  The error occured because the queue was empty.
>)

;-U-

DEFBUG(HLT,UBANXM,PAGEM,SOFT,<I/O NMX FROM UNIBUS DEVICE>,<<UPTPFW,PFW>,<UPTPFO,PC>>,<

Cause:	The monitor tried to reference a non-existent device on the
	UNIBUS. This BUGHLT occurs only on the 2020.
>)


DEFBUG(HLT,UIONIR,PHYSIO,HARD,<UDSKIO - NO IORB FOR NOSKED FORK>,,<

Cause:	The routine UDSKIO was called to do special IO for a fork,
	and to do the IO it uses one of a group of preallocated IORBs.
	But there were no free IORBS left, and the fork could not
	block because it was NOSKED.
>)


DEFBUG(CHK,ULKBAD,TTYSRV,HARD,<UNLOCKING TTY WHEN COUNT IS ZERO>,<<T2,D>>,<

Cause:	This BUG is not documented yet.

Action:

>)

DEFBUG(CHK,ULKINT,FUTILI,SOFT,<LOCK BEING UNLOCKED WHILE OKINT>,<<T1,LOCK>,<T2,CALLER>>,<

Cause:	A routine is unlocking a lock while OKINT.

Action:	Make the process be NOINT for the duration of the lock being locked

Data:	Caller's address in T2, Lock index and flags in T1

>)


DEFBUG(CHK,ULKSTZ,FUTILI,HARD,<OVERLY DECREMENTED STRUCTURE LOCK>,,<

Cause:	This BUG is not documented yet.

Action:

>)


DEFBUG(CHK,UNBFNF,SCHED,HARD,<UNBLK1 - FORK NOT FOUND>,,<

Cause:	This BUG is not documented yet.

Action:

>)


DEFBUG(HLT,UNFWSS,PHYSIO,SOFT,<UNIT NOT FOUND CREATING SDB FOR STRUCTURE>,,<

Cause:	The routine SETSTR was called to build an SDB for a structure.
	One of its arguments is the channel, controller, and unit numbers
	of a unit which had already been known to exist.  But when the
	routine CHKCKU was called to find the UDB of the unit, the routine
	failed to find the unit.
>)


DEFBUG(HLT,UNPGF1,APRSRV,HARD,<MEMPAR-PARITY ERROR DURING MEM SCAN>,,<

Cause:	A page fault occurred while the monitor was scanning memory
	looking for an MB parity error. The monitor expects to cause
	such a fault when it references the bad word in memory. However,
	the PC indicates that the error occurred somewhere other than
	in the instruction that is expected to fail.  The monitor has printed
	a description of the problem on the CTY. A SYSERR block has been
	created and will be placed in the SYSERR file when the monitor is
	rebooted.  If the memory scan has detected any errors, the monitor has
	printed a description of them on the CTY, too.
>)


DEFBUG(HLT,UNPGF2,APRSRV,HARD,<UNKNOWN PAGE FAILURE TYPE>,,<

Cause:	A page fault has occurred and the page fail word indicates
	a "hard" error. The monitor has read the type of failure from
	the page fail word and one of the following is true:

	1. The hardware is never supposed to generate the code.
	2. The code is valid, but the scheduler is running, and this
	code should never be generated from scheduler context.
>)


DEFBUG(CHK,UNPIRX,SCHED,HARD,<UNPIR-NO PSI IN PROGRESS>,,<

Cause:	This BUG is not documented yet.

Action:

>)


DEFBUG(HLT,UNXMPE,APRSRV,HARD,<PFCDPE-UNEXPECTED PARITY ERROR TRAP>,<<T1,PFW>,<T2,PADR>>,<

Cause:	The monitor was processing an AR or ARX parity error when
	a second error occurred. The monitor retries the reference
	that caused the original error and is prepared to handle
	a second error. However, the BUGHLT indicates that the
	error occurred during the processing but not during the retry.
>)

DEFBUG(HLT,UPTMPE,APRSRV,HARD,<PFCDPE: PARITY ERROR IN UPT>,<<T1,PFW>,<T2,PADR>,<T3,BDATA>>,<

Cause:	The monitor was processing an AR or ARX parity error in page 
	zero.  A parity error occurred when checking data in the UPT.
	The first parity error probably occurred during UPT relative
	addressing.  T1 has the page fail word and T2 has the physical
	address.  T3 has the bad data word.

>)



DEFBUG(INF,USGHOL,MEXEC,HARD,<LOST PAGE(S) IN USAGE FILE>,,<

Cause:	This BUG is not documented yet.

Action:

>)


DEFBUG(HLT,UXXCKP,MEXEC,soft,<COULDN'T CREATE CHECKPOINT FILE>,,<

Cause:	The file PS:[ACCOUNTS]CHECKPOINT.BIN.1 could not be referenced
	for one reason or another.  The code first attempts a GTJFN (GJ%PHY,
	GJ%OLD) and an OPENF (OF%RD,OF%WR,OF%RTD), one of which must fail
	for UXXCKP to be a possibility.

	After the above GTJFN or OPENF has failed, then a GTJFN (GJ%PHY,GJ%NEW)
	is attempted.  If this succeeds, then UXXCKP will occur if a failure
	happens on one of the following: the subsequent OPENF (OF%WR,OF%RD),
	the call to ASGSWP to allocate CKPSIZ words, or the SOUT writing
	CKPSIZ words to the checkpoint file.

	If the GTJFN (GJ%PHY,GJ%NEW) fails, then another GTJFN (GJ%PHY,GJ%DEL)
	is attempted, and its failure will cause UXXCKP.  If this GTJFN
	succeeds, however, then a CHFDB (turning off FB%DEL to undelete the
	file) is done, and its failure will also cause UXXCKP.

Action:	Use EDDT to patch the system so that you can bring up the system
	without the checkpoint file being referenced.  Then get the checkpoint
	file into a state such that none of the above failures will occur.
>)


DEFBUG(CHK,UXXCL1,MEXEC,HARD,<UNABLE TO CREATE NEW USAGE FILE>,,<

Cause:	This BUG is not documented yet.

Action:

>)


DEFBUG(CHK,UXXCL2,MEXEC,HARD,<UNABLE TO OPEN NEW USAGE FILE>,,<

Cause:	This BUG is not documented yet.

Action:

>)


DEFBUG(CHK,UXXCL3,MEXEC,HARD,<UNABLE TO CLOSE USAGE FILE>,,<

Cause:	This BUG is not documented yet.

Action:

>)


DEFBUG(HLT,UXXCRE,MEXEC,soft,<CANNOT CREATE USAGE FILE>,,<

Cause:	If the GTJFN (GJ%PHY,GJ%OLD) or the OPENF (OF%RD,OF%WR,
	OF%RTD) on the file pointed to by CKPFIL (PS:[ACCOUNTS]
	CHECKPOINT.BIN.1) fails, then another GTJFN (GJ%FOU) and OPENF
	(OF%WR) is attempted in order to create a new checkpoint file.
	If these latter GTJFN and OPENF fail, the UXXCRE BUGHLT occcurs.

Action:	Analyze the error code from the failing JSYS, and fix the
	checkpoint file so that the error does not happen.
>)


DEFBUG(CHK,UXXFAI,MEXEC,HARD,<USAGE JSYS FAILURE>,,<

Cause:	This BUG is not documented yet.

Action:

>)


DEFBUG(INF,UXXFIT,MEXEC,HARD,<CHECKPOINT FILE NOT IN CORRECT FORMAT FOR THIS SYSTEM, REBUILDING...>,,<

Cause:	This BUG is not documented yet.

Action:

>)


DEFBUG(HLT,UXXILL,MEXEC,soft,<USGMES: ILLEGAL FUNCTION CODE>,,<

Cause:	The USAGE JSYS causes entries in the usage queue.  Each
	entry has a dispatch offset which is used by USGMES as an index into
	a vector for calling the appropriate support routine.

	If the dispatch offset is too large, this BUGHLT occurs.  Since the
	monitor itself is creating the entries in the queue, such a mismatch
	should never occur.
>)


DEFBUG(HLT,UXXMAP,MEXEC,soft,<USGMAP: CALL TO JFNOFN FAILED>,,<

Cause:	USGMAP wants to map a page of a file into FPG0 via SETMPG.
	It calls JFNOFN to convert the JFN.PN atom to OFN.PN, which SETMPG
	wants.  If JFNOFN fails, this BUGHLT occurs.  Some reasons that JFNOFN 
	will fail are: JFN is not associated with a disk file; JFN is not open;
	attempt to create a new page table for a file that is not open for 
	writing; attempt to create a new page table for a directory file; 
	attempt to create a new page table for which there is no room on disk.

>)


DEFBUG(HLT,UXXOPN,MEXEC,soft,<UNABLE TO OPEN USAGE FILE>,,<

Cause:	USGINI invoked OPENF (OF%RD,OF%WR,OF%RTD), which failed to open the
	file pointed to by USGFIL, probably PS:[ACCOUNTS]SYSTEM-DATA.BIN.
>)


DEFBUG(CHK,UXXWER,MEXEC,HARD,<WRITE ERROR IN USAGE FILE>,<<T1,D>>,<

Cause:	This BUG is not documented yet.

Action:

>)

;-V-

DEFBUG(CHK,VTSTMP,TTYSRV,SOFT,<Excessive terminal padding requested>,<<T3,D>>,<

Cause:	Incorrectly written VTS Terminal-dependent routine

Action:	Rewrite routine to request less than 255 ms. of padding

Data:	Useless, already truncated to 8 bits.
>)

DEFBUG(CHK,VTSMNL,TTYSRV,SOFT,<No NEWLINE function in DPY table entry>,<<T3,TYPE>>,<

Cause:	The VTS Display table for this terminal type does not contain
	a DP.NL (newline) function. This function is required.

Action:	Get the table right.

Data:	Terminal type number, as in GTTYP.
>)

DEFBUG(CHK,VTSOUX,TTYSRV,SOFT,<Invalid VTS DPY table entry>,<<T1,D>>,<

Cause:	VTS Display tables improperly written, unknown entry type

Action:	Fix bad entry in TTYTBL.MAC

Data:	DPY Table entry
>)

DEFBUG(CHK,VTSUPF,TTYSRV,SOFT,<Assumed DPY Table Entry Missing in Update Routine>,,<

Cause:	The VTS cursor updating routine VTUPD assumed the presence of
	a TTY display table entry which did not in fact exist. This
	is an internal software error.

Action:	Seek a Wizard
>)

;-W-

DEFBUG(HLT,WAITNI,FORK,SOFT,<WAIT JSYS while not interruptable>,<<FORKX,FORK>>,<

Cause:	We are about to put a process in the wait state but it is not
	interruptable.

Action:

Data:	The fork number.

>)


DEFBUG(CHK,WRTBT4,DSKALC,SOFT,<ASOFN ON BIT TABLE FILE FAILED>,<<T2,STRCOD>>,<

Cause:	Could not assign an OFN for the structure bit table.

Action:

Data:	Structure Unique Code

>)


DEFBUG(CHK,WRTCPB,DSKALC,HARD,<WRTBTB - FAILED TO BACKUP ROOT-DIRECTORY>,<<T1,STRCOD>>,<

Cause:	The bit table is being written.  The backup root-directory or
	symbol table may not have been written, or there may not be
	enough free space on the pack.

Action:

Data:	Structure Unique Code

>)


DEFBUG(HLT,WRTLNG,DSKALC,SOFT,<WRTBTB - BIT TABLE IS A LONG FILE>,,<

Cause:	The FDB for a file structure bit table has the FB%LNG bit set, which
	says the file is a long file.

>)


DEFBUG(CHK,WSPNEG,PAGEM,HARD,<SOSWSP-WSP NEGATIVE>,<<FX,D>,<T2,D>>,<

Cause:	This BUG is not documented yet.

Action:

>)


DEFBUG(HLT,WSSPNA,PAGEM,SOFT,<WSSFKP-FORK SPECIAL PAGE BAD AGE>,,<

Cause:	The monitor is swapping out all pages of a process. It is
	trying to swap out one of the special pages (JSB, PSB, etc.).
	The page should be in core and locked, but it is not
	assigned (its age is LESS THAN PSASN).
>)


DEFBUG(HLT,WSSPNC,PAGEM,SOFT,<WSSFKP-FORK SPECIAL PAGE NOT IN CORE>,,<

Cause:	The monitor is swapping out all pages of a process. It is
	trying to swap out one of the special pages (JSB, PSB, etc.).
	The page should be in core and locked, but it is not in core.

>)

;-X-

DEFBUG(CHK,XBWERR,PAGEM,HARD,<UPDOFN-DSK WRITE ERROR ON XB>,,<

Cause:	This BUG is not documented yet.

Action:

>)


DEFBUG(HLT,XSCORE,PAGEM,SOFT,<CST TOO SMALL FOR PHYSICAL CORE PRESENT>,,<

Cause:	A routine has been called to map a specified core page to a
	specified virtual page. The BUGHLT indicates that the caller
	provided a page number of a core page that does not exist.
	(The number is too large). This BUGHLT can occur if a monitor
	that is built for less than 256K is booted on a machine whose
	memory exceeds 256K.

Action:	If the monitor was built for less than 256K, and there
	is more than 256K of memory on the system, rebuild the monitor
	for the correct amount of memory.
>)

;-Y-

;-Z-

