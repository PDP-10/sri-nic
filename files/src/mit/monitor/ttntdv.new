;<BERLIN>TTNTDV.MAC.5, 20-Aug-82 00:43:43, Edit by BERLIN
;1012 Fix for net conection dropping that caused crash
;<BBN-5-MONITOR>TTNTDV.MAC.9, 10-Feb-82 11:50:33, Edit by TAPPAN
; Terminated STKVAR's (ENDSV.) Fix incorrect merge in NVTDET
;<BBN-4-MONITOR>TTNTDV.MAC.9, 25-Aug-81 11:34:35, Edit by TAPPAN
; 100: Modifications to support CHAOS NVT's also
; UPD ID= 80, SNARK:<5.MONITOR>TTNTDV.MAC.16,  27-Jul-81 09:11:36 by PAETZOLD
;UPDATE COPYRIGHT INFORMATION
; UPD ID= 76, SNARK:<5.MONITOR>TTNTDV.MAC.15,  26-Jul-81 22:44:55 by PAETZOLD
;TCO 5.1434 - Add code to increment NETBTC for ARPANET NVT's
; UPD ID= 20, SNARK:<5.MONITOR>TTNTDV.MAC.14,  12-Jul-81 16:26:47 by PAETZOLD
;TCO 5.1408 - Remove POP in TTMSN1 as it messes up the stack
; UPD ID= 2049, SNARK:<5.MONITOR>TTNTDV.MAC.13,  20-May-81 13:18:48 by PAETZOLD
;TCO 5.1337 REMOVE OKSKED FROM NVTCOB AS ITS CALLER DOES AN OKSKD1
; UPD ID= 1946, SNARK:<5.MONITOR>TTNTDV.MAC.12,   6-May-81 14:44:16 by PAETZOLD
;TCO 5.1314 MAKE A NEW ENTRY POINT TO NVTDET THAT DOES NOT DESTROY ITS
;RETURN ADDRESS
; UPD ID= 1896, SNARK:<5.MONITOR>TTNTDV.MAC.11,  28-Apr-81 16:44:07 by MURPHY
;TSALP BECOMES TTSAL2
; UPD ID= 1878, SNARK:<5.MONITOR>TTNTDV.MAC.10,  23-Apr-81 17:41:15 by LYONS
;FIX INCR/DECR BUG
; UPD ID= 1831, SNARK:<5.MONITOR>TTNTDV.MAC.9,  17-Apr-81 14:19:41 by MURPHY
;CHANGES TO SENDALL LOGIC
;TTSND NOW HAS SKIP RETURN
; UPD ID= 1514, SNARK:<5.MONITOR>TTNTDV.MAC.8,   3-Feb-81 18:02:01 by MURPHY
;TTXON =) TTXONA
; UPD ID= 1102, SNARK:<5.MONITOR>TTNTDV.MAC.7,   2-Oct-80 09:19:39 by MURPHY
;FIX TRVAR
; UPD ID= 1099, SNARK:<5.MONITOR>TTNTDV.MAC.6,   1-Oct-80 16:33:29 by MURPHY
;FIX ACVAR
; UPD ID= 692, SNARK:<5.MONITOR>TTNTDV.MAC.5,  24-Jun-80 20:50:05 by MURPHY
;CHANGE LINE TYPE DISPTACH
; UPD ID= 667, SNARK:<5.MONITOR>TTNTDV.MAC.3,  16-Jun-80 19:09:06 by LYONS
;BUG: IF WE RUN OUT OF NVTS, WE CAN ILMNRF FROM THE ASNVT JSYS
; UPD ID= 648, SNARK:<5.MONITOR>TTNTDV.MAC.2,  16-Jun-80 12:09:37 by MURPHY
;CLEAN UP VECTOR TABLE COMMENTS
;<4.MONITOR>TTNTDV.MAC.54, 25-Oct-79 10:51:28, EDIT BY ZIMA
;TCO 4.2548 - ADD NOP AFTER CALL TO TTCHI AFTER NVTUPB IN ORDER TO
; PREVENT NSKDIS BUGHLTS CAUSED BY CHANGED TTCHI CALL/RETURN CONVENTION
;<4.MONITOR>TTNTDV.MAC.53, 20-Sep-79 14:23:39, EDIT BY MURPHY
;CHANGE FORMAT OF DEVICE DISPATCH MACROS
;<4.MONITOR>TTNTDV.MAC.52, 19-Sep-79 14:52:53, EDIT BY MURPHY
;CHANGE VECTOR OFFSET NAMES
;<OSMAN.MON>TTNTDV.MAC.1, 10-Sep-79 16:14:36, EDIT BY OSMAN
;TCO 4.2412 - Move definition of BUGHLTs, BUGCHKs, and BUGINFs to BUGS.MAC
;<4.MONITOR>TTNTDV.MAC.2, 19-Apr-79 23:37:46, EDIT BY JBORCHEK
;Change break class symbols P<6-9> to K<6-9>
;New Telnet fixes
;<4.MONITOR>TTNTDV.MAC.17, 11-Mar-79 13:15:40, EDIT BY KONEN
;UPDATE COPYRIGHT FOR RELEASE 4
;<4.MONITOR>TTNTDV.MAC.16,  2-Feb-79 23:42:51, Edit by MCLEAN
;ADD VSFEXO FOR XOFF RECOGNITION IN FRONT-END	;ENABLE/DISABLE FRONT-END XOFF RECOGNITION

;<4.MONITOR>TTNTDV.MAC.15, 28-Dec-78 22:47:03, Edit by MCLEAN
;ADD VSTPLN	;STOP LINE

;<4.MONITOR>TTNTDV.MAC.14, 24-Oct-78 13:43:11, Edit by MCLEAN
;<4.MONITOR>TTNTDV.MAC.12, 22-Aug-78 12:15:32, EDIT BY JBORCHEK
;FIX UP REFERENCES TO NCP DATA BASE
;<4.MONITOR>TTNTDV.MAC.10, 16-Jun-78 08:00:08, Edit by JBORCHEK
;<3A.MONITOR>TTNTDV.MAC.7, 13-Jun-78 00:30:35, Edit by JBORCHEK
;DO SOME CLEAN UP
;<3A.MONITOR>TTNTDV.MAC.5,  7-Apr-78 21:56:30, Edit by BORCHEK
;INCREASE NVT OUTPUT BUFFER TO 40 WORDS AT NETTC8
;<3A.MONITOR>TTNTDV.MAC.4,  6-Apr-78 01:49:06, Edit by BORCHEK
;FIX BYTE POINTER AT NETTC8
;<3A.MONITOR>TTNTDV.MAC.3, 27-Mar-78 11:41:19, EDIT BY MILLER
;ADD TTYDIS AND TTYAWK AS TEMP FIX
;<3.SM10-RELEASE-3>TTNTDV.MACC.31, 20-Dec-77 10:03:53, EDIT BY KIRSCHEN
;CORRECTLY GET DYNAMIC DATA FOR TTYDIS CALL IN NVTNGC
;<4.MONITOR>TTNTDV.MAC.2,  5-Dec-77 15:46:18, EDIT BY CROSSLAND
;REMOVE MORE RCTE CODE AND DO NOT CLEAR OUTPUT BUFFERS IF IN SCED

;THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY ONLY BE USED
;  OR COPIED IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
;COPYRIGHT (C) 1976,1977,1978,1979,1980,1981 BY DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.

  IFN .NTFLG,<		;** THIS MODULE ONLY IF WANTED **
	SUBTTL NVT DEPENDENT CODE
IF1 <PRINTX IN TTNTDV PASS 1>
IF2 <PRINTX IN TTNTDV PASS 2>

;THIS MODULE IS NECESSARY TO SUPPORT THE NETWORK VIRTUAL TERMINALS (NVT)
;OVER THE ARPANET.

	SEARCH IMPPAR,MNTPAR	;MORE DEFINITIONS NEEDED BY THIS MODULE
	RESCD


;PARAMETERS

NEGTM0==^D30000			;NEGOTIATION TIME-OUT (BETWEEN 1 & 2 OF THESE)
TMSNTT==^D500			;TIME PER CHARACTER OF TTMSG BEFORE FLUSHING

;NVT SPECIAL CHARACTERS

IACCH==377			;INITIATE COMMAND
DNTCH==376			;DON'T
DOCH==375			;DO
WNTCH==374			;WON'T
WILCH==373			;WILL
SBCH==372			;SB BEGINNING OF SUB NEGOTIATION
GACH==371			;GA GO AHEAD
ELCH==370			;EL ERASE LINE
ECCH==367			;EC ERASE CHARACTER
AYTCH==366			;AYT ARE YOU THERE?
AOCH==365			;AO ABORT OUTPUT
IPCH==364			;IP INTERRUPT PROCESS
BRKCH==363			;BREAK
DMCH==362			;DM DATA MARK
NOPCH==361			;NOP
SECH==360			;SE END OF SUBNEGOTIATION

;NVT OPTION DEFINITIONS

BINOPT==0			;BINARY
ECHOPT==1			;ECHO
RCNOPT==2			;RECONNECTION
SGAOPT==3			;SUPPRESS GA
NAMOPT==4			;NEGOTIATE MESSAGE SIZE
STSOPT==5			;STATUS
TMKOPT==6			;TIMING MARK OPTION
RCTOPT==7			;RCTE OPTION
WILOPT==10			;OFFSET FOR REQUESTS
MAXOPT==^D18			;ONLY 1 HALF WORD OF OPTION BITS

;99
; SUPDUP special chars
%TDORS==214			; Output reset
;99
TTNETW=TTDEV
;BITS IN TTNETW
DEFSTR NVTYP,TTNETW,2,2		;99 Line type
.TYNNV==0			;99 New NVT
.TYONV==1			;99 Old NVT
.TYSUP==2			;99 SUPDUP terminal

;BITS IN TTNETW

DEFSTR PTITC,TTNETW,5,3		;COUNT, SYNC-INS
NV%WKS==1B8			;RCTE WAKEUP SEEN
MSKSTR NVWKS,TTNETW,NV%WKS
NV%RCS==1B9			;RCTE CHAAGE IN STATE
MSKSTR NVRCS,TTNETW,NV%RCS
NV%NNV==1B10			;NEW STYLE NVT
MSKSTR NVNNV,TTNETW,NV%NNV
NV%TMO==1B11			;NEGOTIATION TIME-OUT STARTED
MSKSTR NVTMO,TTNETW,NV%TMO
DEFSTR NVSTP,TTNETW,14,3	;CURRENT NVT STATE
;THE FOLLOWING NVT STATES ARE STORED IN TTNETW BITS 12-14 (NVSTP)
.DFWIL==1			;DEFERRED WILL
.DFWNT==2			;DEFERRED WONT
.DFDO==3			;DEFERRED DO
.DFDNT==4			;DEFERRED DONT
.DFIAC==5			;DEFERRED IAC
.DF300==6			;99 SUPDUP - 300 received
.DFCLC==7			;99 SUPDUP - reading console location
NV%GAB==1B15			;BIT IN TTNETW -- SUPPRESS GO-AHEAD
MSKSTR NVGAB,TTNETW,NV%GAB
NV%CRI==1B16			;BIT IN TTNETW, LAST CHAR IN WAS CR
MSKSTR NVCRI,TTNETW,NV%CRI
NV%CRP==1B17			;BIT IN TTNETW -- LAST CHAR OUT WAS CR
MSKSTR NVCRP,TTNETW,NV%CRP
DEFSTR PTNTO,TTNETW,26,9	;OUTPUT UNIT
DEFSTR PTNTI,TTNETW,35,9	;INPUT UNIT


TTBRKC=TTDDLN			;BREAK CLASSES FOR NVT'S
DEFSTR PBRCT,TTBRKC,8,9 ;BITS 0-8: OUTSTANDING BREAK COUNT
				;BITS 9-17: LAST RCTE COMMAND SENT
				;BITS 18-35: LAST BREAK CLASSES SENT
MAXBRC==777


NVTOPF=TTDDLN+1			;LH -- BIT FOR EACH OPTION IN PROGRESS
				;RH -- BIT FOR RESULT OF EACH OPTION

NVTLEN=TTDDLN+2




;TEMP CODE TO DO TTYDIS AND TTYAWK CODE. REMOVED FROM TTYSRV

;ROUTINES TO ADJUST LOCK STATUS BEFORE AND AFTER DISMISSING.
;THIS CODE PUTS AN ENTRY ON THE JSB STACK IN THE EVENT THE PROCESS
;IS INTERRUPTED WHILE DISMISSED.

;PUT ENTRY ON JSB STACK, AND GO OKINT
;ACCEPTS:	T2/ ADDRESS OF DYNAMIC DATA

TTYDIS::JE TTLCK,(T2),R		;159 THIS IS A HACK TO KEEP FSIINI HAPPY.
				;SINCE THE SWAPPABLE MONITOR IS NOT
				;LOADED YET, WE CAN'T USE THE NORMAL
				;LOCKING STATEGY. THIS IS ACCEPTABLE
				;HERE SINCE NO CONFUISION CAN RESULT.
	SKIPE INSKED		;IN THE SCHEDULER?
	RET			;YES. DON'T MANIPULATE THE JSB STACK
	SAVET			;SAVE ALL REGISTERS
	LOAD T1,TINTL,(T2)	;GET INTERNAL LINE NUMBER
	MOVEI T2,STKCD3		;GET PROPER CODE
	CALL JSBSTK		;QUEUE UP THE ENTRY
	OKINT			;ALLOW INTS NOW
	RET			;AND DONE

;DISMISS WAS SATISFIED. DEQUEUE THE ENTRY AND GO NOINT

TTYAWK::	JE TTLCK,(T2),R	;159 THIS IS A HACK TO KEEP FSIINI HAPPY.
				;SINCE THE SWAPPABLE MONITOR IS NOT
				;LOADED YET, WE CAN'T USE THE NORMAL
				;LOCKING STATEGY. THIS IS ACCEPTABLE
				;HERE SINCE NO CONFUISION CAN RESULT.
	SKIPE INSKED		;IN THE SCHEDULER?
	RET			;YES. DON'T MANIPULATE THE JSB STACK
	SAVET			;SAVE ALL REGISTERS
	NOINT			;PREVENT INTS
	LOAD T1,TINTL,(T2)	;GET INTERNAL LINE NUMBER
	MOVEI T2,STKCD3		;GET TYPE
	CALLRET JSFRMV		;REMOVE ENTRY AND DONE

;NVTCHK - SEE IF THIS LINE NUMBER IS A NVT AND GET ADDRESS OF DYNAMIC
; DATA IF IT IS

;ACCEPTS:
;	T2/ INTERNAL LINE NUMBER

;	CALL NVTCHK

;RETURNS +1: NOT A NVT OR NO DYNAMIC DATA
;		TTY DATA BASE NOT LOCKED
;	 +2: A NVT
;		T2/ ADDRESS OF DYNAMIC DATA
;		AND TTY DATA BASE LOCKED

	RESCD

NVTCHK::CAIL T2,NLINES		;LEGAL TERMINAL NUMBER
	RETBAD			;NO. FAILURE
	ACVAR <W1>		;GET AN AC TO WORK WITH
	LOAD W1,TTSTY,(T2)	;GET LINE TYPE FOR THIS LINE
	CAIE W1,TT.NVT		;IS IT A NVT?
	RETBAD			;NO. FAILURE
	CALL LCKTTY		;GET ADDRESS OF DYNAMIC DATA AND LOCK
	 JRST [CALL ULKTTY	;LINE NOT INITIALIZED UNLOCK
		RETBAD]		;AND RETURN
	RETSKP			;RETURN SUCCESS

	ENDAV.			;END ACVAR




;CHKNVT - SEE IF THIS LINE NUMBER IS A NVT

;ACCEPTS:
;	T2/ INTERNAL LINE NUMBER

;	CALL CHKNVT

;RETURNS +1: IF NOT NVT
;	 +2: IF NVT

	RESCD

CHKNVT::ACVAR <W1>		;GET AN AC TO WORK WITH
	LOAD W1,TTSTY,(T2)	;GET LINE TYPE FOR THIS LINE
	CAIE W1,TT.NVT		;IS IT A NVT?
	RETBAD			;NO. FAILURE
	RETSKP			;RETURN SUCCESS

	ENDAV.			;END ACVAR

;TTMSNT - TEST TO SEE IF SEND ALL SHOULD BE DONE

;ACCEPTS:
;	T1/ BYTE PTR TO MESSAGE
;	T2/ LINE NUMBER
;	T3/ COUNT

;RETURNS: +1 DO NOT SEND MESSAGE
;	  +2 SEND MESSAGE

	SWAPCD


TTMSNT:	SASUBR <MSPT,MSLN,MSCT>
	CALL LCKTTY		;GET DYNAMIC DATA ADDRESS IF IT EXIST
	 JRST TTMSN1		;NO DYNAMIC DATA DO NOT SEND
	SKIPG TTNETW(T2)	;ANY CONNECTIONS?
	JRST TTMSN1		;NO DO NOT SEND MESSAGE
	CALL ULKTTY		;YES UNLOCK TTY DATABASE
	AOS TTNOF		;INDICATE OUTPUT FOR NVTS
	MOVE T2,MSCT		;GET COUNT OF CHARACTERS IN MESSAGE
	IMULI T2,TMSNTT		;MULTIPLY BY ALLOWABLE TIME PER CHAR.
	ADD T2,TODCLK		;GET TIME MESSAGE TO BE DISCARDED
	MOVEM T2,ITMSTM		;SAVE TIME FOR NCPFORK
	RETSKP			;SEND MESSAGE


TTMSN1:	CALL ULKTTY		;UNLOCK TTY
	RETBAD			;NO DO NOT SEND MESSAGE

	ENDTV.			;END TRVAR


;TMSNTR - ROUTINE TO CLEAR ALL NVT SNDALL REQUEST
;CALLED NOSKED

	RESCD

TMSNTR::MOVE T3,NVTPTR		;GET AOBJN COUNTER FOR NVT'S
TMSNR1:	SKIPN T2,TTACTL(T3)	;GET ADDRESS OF DYNAMIC DATA
	 JRST TMSNR2		;IF NON-STANDARD BLOCK CHECK
	HRRZ T2,T2		;GET JUST ADDRESS
	JE TTSAL,(T2),TMSNR2	;IF DOING SENDALL CLEAR IT
	CALL CLRSAL		;CLEAR SENDALL FROM LINE
TMSNR2:	AOBJN T3,TMSNR1		;HAVE WE DONE ALL OF THE LINES
	RET			;YES RETURN


;TCOBN - ENTRY FOR BINARY OUTPUT. NO TRANSLATION NO LINKS.
;TCOBQ - ENTRY FOR BINARY OUTPUT. NO TRANSLATION NO LINKS.
; NO SPECIAL HANDELING


;ACCEPTS:
;	T1/ CHARACTER (UP TO 9 BITS)
;	T2/ ADDRESS OF DYNAMIC DATA

;	CALL TCOBN

;RETURNS +1: ALWAYS


TCOBQ:				;HERE FOR NOW EVENTUAL WILL GO PAST
				; SPECIAL CHARATER VECTOR CALL
TCOBN:	SAVELN			;SAVE LINE NUMBER
	ANDI T1,377		;8 BITS OF CHARACTER
	CALL TCOU6		;GO OUTPUT THE CHARACTER WITHOUT ADDING
				; PARITY OR DOING LINKS
	RET			;RETURN

;NVTIPU/NVTOPU - GET NVT INPUT/OUTPUT UNIT

;ACCEPTS:
;	T2/ ADDRESS OF DYNAMIC DATA

;	CALL NVTIPU/NVTOPU

;RETURNS +1: FAILURE NO UNITS FOR THIS NVT
;	 +2: SUCCESS
;		Q1/ (UNIT) INPUT/OUTPUT UNIT

NVTOPU::LOAD Q1,PTNTO,(T2)	;GET OUTPUT UNIT
	TRNA			;SKIP

NVTIPU::LOAD Q1,PTNTI,(T2)	;GET INPUT UNIT
	SETSEC Q1,ANBSEC	; In right section for tables
	SKIPG TTNETW(T2)	;UNLESS NO UNITS ON TTY
	RETBAD			;NO UNITS. FAIL
	RETSKP			;SUCCESS



;NVTDSC - DECREMENT INS/SYNC COUNT AND RE-ALLOCATE IF NECESSARY

;ACCEPTS:
;	T2/ ADDRESS OF DYNAMIC DATA

;RETURN +1: ALWAYS


NVTDSC::LOAD Q1,PTITC,(T2)
	SOJ Q1,			;INS COUNTS -1, SYNC CHAR COUNTS 1
	STOR Q1,PTITC,(T2)
	LOAD Q1,PTNTI,(T2)	;GET INPUT UNIT
	SETSEC Q1,ANBSEC
	SKIPN NETBAL(Q1)	;ANY ALLOCATION
	 CALL NVTRAL		;NO. SEND MORE ALLOCATION
	RET

;NVTDWN - CLEAR UP ALL NVTS

;RETURN +1: ALWAYS

NVTDWN::MOVE T1,NVTPTR		;CLEAN UP ALL NVTS
NVTDW1:	HRR T2,T1		;GET TTY NUMBER
	PUSH P,T1		;SAVE LINE COUNTER
	CALL NVTDTT		;GO TRY TO DETACH IT
	 JFCL			;IGNORE ERRORS
	POP P,T1		;GET LINE COUNTER BACK
	AOBJN T1,NVTDW1		;CHECK ALL NET NVT LINES
	RET


;TTC7SN - LINE IS A NVT. SEE IF NVT LOGINS ARE ALLOWED

TTC7SN:	TXNE T1,SF%NVT		;SEE IF NVT LOGINS ALLOWED
	JRST RTRUE		;YES, GO LOGIN IN
	HRROI T1,[ASCIZ/
?LOGGING IN OVER NETWORK TERMINALS IS CURRENTLY DISALLOWED.
/]
	CALL TTEMES
	JRST RFALSE		;FAIL


;ASNNVT - ASSIGN A NETWORK VIRTUAL TERMINAL

;ACCEPTS:
;	T1/ RECEIVE UNIT
;	T2/ SEND UNIT

;	CALL ASNNVT

;RETURNS +1: FAILURE
;	 +2: SUCESS
;		T1/ LINE NUMBER
;		T2/ ADDRESS OF DYNAMIC DATA AND DATA BASE LOCKED

SWAPCD

ASNNVT::STKVAR<NVREC,NVSEND,NVLIN>
	MOVEM T2,NVSEND		;SAVE SEND AND RECEIVE UNITS
	MOVEM T1,NVREC
	HRRZ T1,NVTPTR		;GET FIRST NVT LINE NUMBER
	SETZ T3,		;START WITH FIRST NVT
	NOSKED
ASNNV1:	MOVE T2,T1		;GET FIRST NVT OFFSET
	ADD T2,T3		;ADD CURRENT NVT
	MOVEM T2,NVLIN		;SAVE LINE NUMBER
	CALL STADYN		;IS IT INITIALIZED
	 JUMPE T2,ASNNV4	;NO. NO DYNAMIC DATA
	SKIPG TTNETW(T2)	;FREE?
	JRST ASNNV3		;YES.
ASNNV2:	CAIGE T3,NTTNVT-1	;LOOKED AT ALL NVT'S?
	AOJA T3,ASNNV1		;NO
	OKSKED			;YES,
	RETBAD			;RETURN BAD

ASNNV3:	LOAD T2,TCJOB,(T2)	;GET JOB FOR WHICH THIS IS A CNTRL TTY.
	CAIE T2,-1		;IS THERE ONE
	JRST ASNNV2		;YES. TTY ALREADY ATTACHED?
ASNNV4:	MOVE T2,NVLIN		;GET LINE NUMBER BACK
	CALL TTYASC		;ASSIGN NVT
	 JRST ASNNV6		;COULD NOT ASSIGN IT
	MOVE T2,NVLIN		;GET LINE NUMBER
	CALL LCKTTY		;AND LOCK DATA BASE
	 JRST ASNNV5		;CANNOT LOCK DATA BASE. SHOULD'NT HAPPEN
	SETONE TCJOB,(T2)	;INDICATE NO CONTROLLING JOB FOR TERM.
	SETONE TTPRM,(T2)	;MAKE DATA PERMANENT UNTIL NVT CLOSED
	MOVE T1,NVREC		;GET RECEIVE UNIT BACK

repeat 0,<	;99 begin deletion
	TXNN T1,AN%NTP		;NEW NVT PROTOCOL REQUEST?
	 TLZA T3,-1		;NO, MAKE ZEROES
	  MOVX T3,NVNNV		;YES, MAKE NEW NVB BIT
>;99 end deletion

;99 Begin modification
	MOVEI T3,.TYONV		; Default is old NVT
	TXNE T1,AN%NTP		;NEW NVT PROTOCOL REQUEST?
	  MOVEI T3,.TYNNV	;YES, MAKE NEW NVB BIT
	TXNE T1,AN%SUP		; SUPDUP?
	 MOVEI T3,.TYSUP
	SETZM TTNETW(T2)	;CLEAR TTNETW EXCEPT FOR NVNNV
	STOR T3,NVTYP,(T2)
;99 End modification

	SETZM NVTOPF(T2)	;CLEAR OPTION STATUS
	OKSKED
	MOVE T3,NVSEND		;GET BACK SEND UNIT
	STOR T1,PTNTI,(T2)	;REMEMBER UNITS
	STOR T3,PTNTO,(T2)
	SETONE TT%DUM,TTFLGS(T2) ;SET DUPLEX MODE
	MOVEI T1,.TTNVT		;21 SET TO BE AN "IDEAL" TERMINAL
	STOR T1,TTTYP,(T2)
	MOVE T1,NVLIN		;RETURN LINE NUMBER
	RETSKP


ASNNV5:	CALL ULKTTY		;UNLOCK DATA BASE
ASNNV6:	HRRZ T1,NVTPTR		;GET FIRST NVT
	MOVE T3,NVLIN		;SET UP TO TRY NEXT LINE
	SUB T3,T1		;GET NVT NUMBER IN 3
	JRST ASNNV2		;AND TRY NEXT NVT

	ENDSV.

;NVTDTS - CLOSE A FULL DUPLEX NET TTY CONNECTION ON CARRIER OFF

;ACCEPTS:
;	T2/ LINE NUMBER

;	TDJRST OFF VHNGUP	;HANGUP, REACTIVATE REMOTE LINE


;RETURNS +1: ALWAYS

RESCD

NVTDTS: CALL NVTDTT		;DETACH NVT
	 RET			;IGNORE ERRORS
	RET			;SUCESS


;NVTDET - CLOSE A FULL DUPLEX NET TTY CONNECTION
;NVTDTT - SAME BUT DONT DESTROY RETURN ADDRESS

;ACCEPTS:
;	T2/ LINE NUMBER

;	CALL NVTDET

;RETURNS +1: FAILURE
;		T1/  1B0 + ADDRESS OF ROUTINE IF NEED TO DISMISS
;		T1/  ERROR CODE IF FAILED
;	 +2: SUCCESS

	RESCD

NVTDET::
	POP P,CX		;THROW AWAY LOCAL RETURN *** HACK! ***
NVTDTT::			;DONT DESTROY THE RETURN ADDRESS
	SE1CAL			;ENTER SECTION 1
	SAVEQ			;SAVE Q1,Q2,Q3
	CALL NVTCHK		;IS IT AN NVT
	 RETSKP			;NOT ASSIGNED RETURN
	SKIPG TTNETW(T2)	;REASONABLE UNITS?
	JRST NVTDT1		;NO GO CLEAN IT UP
	LOAD Q1,PTNTI,(T2)	;INPUT UNIT
	SETSEC Q1,ANBSEC
	PUSH P,T2		; save line data
	CALL NVTCLZ		;CLOSE IT
	MOVE T2,0(P)		; restore
	LOAD Q1,PTNTO,(T2)	;OUTPUT UNIT
	SETSEC Q1,ANBSEC
	CALL NVTCLZ		;CLOSE IT
	POP P,T2		; restore data
NVTDT1:	SETZM TTNETW(T2)	;ZERO OUT UNITS
;;; 100 code for other networks joins here
VTDET:	STKVAR <NVTDLN,NVTDAD>
	MOVEM T2,NVTDAD
	DYNST T1		; Get static data
	MOVEM T1,NVTDLN	
	CALL CLRPRM		;CLEAR PERMANENT BIT SO WILL BE DEASSIGNED
;;; 100: end of modification
	LOAD T3,TCJOB,(T2)	;GET OWNING JOB
	CAIN T3,-1		;ANY JOB?
	JRST NVTDT2		;NO. GO DEALLOCATE DATA
	MOVE T2,NVTDLN		;GET TTY LINE NUMBER
	MOVEI T1,.TTDES(T2)	;MAKE DEVICE DESIGNATOR
	CALL CHKDES		;GET INDEX TO DEVICE TABLES
	 JRST [	MOVE T2,NVTDAD	;GET ADDRESS OF DYNAMIC DATA BACK
		CALL ULKTTY	;NO.  SUCESSFUL RETURN
		RETBAD]		;INVAILD DEVICE SHOULD NOT HAPPWN
	SETZRO DV%OPN,DEVCHR(T2) ;CLEAR OPEN BIT SO RELD AT LOGOUT WILL
				; DEASIGN IT
	MOVE T2,NVTDAD		;GET ADDRESS OF DYNAMIC DATA
	MOVE T1,NVTDLN		;GET TTY LINE NUMBER
	CAMN T1,CTRLTT		;IS THIS THE CONTROLLING TTY
	JRST NVTDT2		;YES.  GO DEASIGN DATABASE.
	LOAD T3,TCJOB,(T2)	;GET OWNING JOB
	HLRZ T3,JOBPT(T3)	;GET CONTROLLING TERMINAL OF JOB
	CAME T1,T3		;IS THIS A CONTROLLING TTY
	JRST NVTDT2		;NO.  GO DETACH IT.

;A JOB EXISTS ON THIS LINE, AND THE NET CONNECTION HAS BEEN BROKEN.
;GENERATE A CARRIER OFF PSI FOR THE TOP FORK. THIS WILL CAUSE THE
;TERMINAL DATA BLOCK TO BE DEASSIGNED.

	MOVE T2,NVTDLN		;GET TTY LINE NUMBER
	NOSKD1
	CALL NTYCOF		;CAUSE CARRIER OFF ACTION
	OKSKD1
	MOVE T2,NVTDAD		;GET ADDRESS OF DYNAMIC DATA BACK
	CALL ULKTTY		;NO.  SUCESSFUL RETURN
	RETSKP

;DEASSIGN THE TERMINAL'S DATA BLOCK

NVTDT2:	JE TTSAL,(T2),NVTDT3	;IF DOING SENDALL CLEAR IT
	SETZRO TTSAL,(T2)	;ZERO SENDALL BIT
	SOS SALCNT		;DECREMENT COUNT OF LINES DOING SENDALL
	SETZM TTSAL2(T2)	;ZERO SENDALL POINTER
NVTDT3:	CALL ULKTTY		;UNLOCK DATA BASE
	MOVE T2,NVTDLN		;GET TTY LINE NUMBER
	MOVEI T1,.TTDES(T2)	;MAKE DEVICE DESIGNATOR
	CALL CHKDES		;GET INDEX TO DEVICE TABLES
	 RETBAD			;INVAILD DEVICE SHOULD NOT HAPPWN
	MOVEM T2,NVTDAD		;SAVE INDEX TO DEVICE TABLES
	MOVE T2,NVTDLN		;GET TTY LINE NUMBER
	CALL TTYDE0		;DEALOCATE LINE
	 RETBAD			;RETURN ERROR OR TEST ROUTINE
	MOVE T2,NVTDAD		;GET INDEX TO DEVICE TABLES
	HRROS DEVUNT(T2)	;SET OWNING JOB TO -1
	SETZRO DV%ASN!DV%OPN,DEVCHR(T2) ;MARK NOT ASSIGNED OR OPEN
	MOVE T2,NVTDLN		;GET LINE NUMBER
	CAME T2,CTRLTT		;CONTROLLING TERMINAL
	RETSKP			;NO.  SUCESSFUL RETURN
	SETOM CTRLTT		;YES.  INDICATE NO TERMINAL
	MOVE T2,JOBNO		;GET JOB NUMBER
	HRROS JOBPT(T2)		;THIS JOB NO LONGER HAS A TTY
	RETSKP			;SUCESSFUL RETURN

	ENDSV.

;NETCAP - CALLED FROM TCI ON INPUT WAIT

;ACCEPTS:
;	T2/ DYNAMIC DATA ADDRESS

;	TDCALL OFF VHNGRY	;INPUT GA


;RETURNS: +1: ALWAYS
;	T2/ DYNAMIC DATA ADDRESS


NETCAP:	SKIPG TTNETW(T2)	;STILL CONNECTED?
	RET			;NO
	PUSH P,Q1		;SAVE Q1
	PUSH P,T2		;AND T2.  MUST BE RETURNED
	NOINT			;PROTECT ANY POSSIBLE ILOCKS
	CALL CKNNVT		;NEW NVT PROTOCOL?
	 JRST NETCA1		;99 SUPDUP, don't send GA
	 JRST NETCA1		;NO.  SKIP SENDING GA
	CALL NVTXGA		;SEND GA IF NEEDED
NETCA1:	LOAD Q1,PTNTI,(T2)	;INPUT UNIT
	SETSEC Q1,ANBSEC
	SKIPN NETBAL(Q1)	;IS THERE ANY ALLOCATION
	 CALL NVTRAL		;NO PROBABLY ONLY 1ST TIME, OR AFTER CFIBF
	OKINT
	POP P,T2		;RESTORE T2
	POP P,Q1		;AND Q1
	RET


;CKNNVT - CHECK IF THIS NVT IS USING NEW PROTOCOL


;ACCEPTS:
;	T2/ ADDRESS OF DYNAMIC DATA

;	CALL CKNNVT

;RETURNS +1: OLD NVT PROTOCOL
;	 +2: NEW NVT PROTOCOL

repeat 0,<	;99 begin modification
CKNNVT:	JE NVNNV,TTNETW(T2),R	;OLD NVT PROTOCOL?  RETURN
	RETSKP			;NEW PROTOCOL. SKIP RETURN
>;99 end repeat 0

;RETURNS +1: SUPDUP PROTOCOL
;	 +2: OLD NVT PROTOCOL
;	 +3: NEW NVT PROTOCOL
CKNNVT:	LOAD CX,NVTYP,(T2)
	CAIN CX,.TYSUP
	 JRST R
	CAIN CX,.TYNNV
	 AOS (P)
	AOS (P)
	RET
;99 End mod



REPEAT 0,<
;NVTCHO - CHECK FOR SPECIAL NVT OUTPUT PROCESSING
; CALLED FROM TCOUTX FOR NVT'S

NVTCHO:	STKVAR<NVTCH>
	CALL CKNNVT		;CHECK IF NEW NVT
	 RET			;NOT. NO SPECIAL PROCESSING
	MOVEM T1,NVTCH		;SAVE CHARACTER
	MOVX T3,NVCRP		;PREVIOUS CHARACTER CARRIAGE RETURN
	TXNE T3,TTNETW(T2)	;WAS IT?
		ANDCAM T3,TTNETW(T2) ;YES, CLEAR IT
		CAIE T1,.CHLFD	;MUST BE FOLLOWED BY LF
		CAIN T1,0	;OR NULL
		 JRST .+1
		SETZ T1,	;IF NOT FOLLOW IT WITH NULL
		CALL TCOBQ	;GO PUT IT OUT
		MOVE T1,NVTCH	;GET CHARACTER BACK
		JRST .+1]
	CAIN T1,IACCH		;IAC?
	CALL TCOBQ		;YES. DOUBLE THE SPECIAL CHARACTER
	MOVE T1,NVTCH		;GET CHARACTER BACK
	RET
	ENDSV.

>;END OF REPEAT 0

REPEAT 0,<
;NVTXCR - SET NVCRP CALLED FROM TTYSRV

;ACCEPTS:
;	T2/ ADDRESS OF DYNAMIC DATA

;RETURN +1: ALWAYS

NVTXCR:	CALL CKNNVT
	 RET
	SETONE NVCRP,TTNETW(T2)
	RET
>;END OF REPEAT 0

;NTTCSO - START OUTPUT TO A LINE CALLED FROM STRTOU

;	TDJRST OF VSTOUT	;START OUTPUT TO LINE


;RETURNS +2: ALWAYS

NTTCSO:	AOS TTNOF		;REQUEST TTY SCAN
	AOS IMPFLG
	RETSKP			;SAY NOTHING ELSE TO DO

REPEAT 0,<
;NVTRCC -  CHECK FOR ECHOS DONE BY RCTE
;ACCEPTS:
;	T1/ CHARACTER
;	T2/ LINE NUMBER

;RETURNS:
;	+1	;NO RCTE ACTION
;	+2	;CHARACTER NOT A BREAK CHARACTER
;	+3	;CHARACTER IS A RCTE BREAK
;THE 400 BIT IS SET IN THE CHARACTER IN AC1 IF RCTE DID THE ECHO.

NVTRCC:	CALL NVTCHK		;IS IT AN NVT?
	 RETSKP			;RETURN AS NOT A BREAK CHARACTER
	PUSH P,T3		; STASH AC3
	MOVEI T3,(1B<RCTOPT+WILOPT>) ;RCTE OPTION REQUEST
	TDNN T3,NVTOPF(T2)
	 JRST NVTRC1		;NO
	MOVEI T3,0(T1)		;THE CHARACTER
	ANDI T3,177		;RETAIN LOW BITS
	LSH T3,-2		;DIVIDE BY 4 BYTES PER WORD
	TRNE T1,2		;IF SECOND TWO BYTES WANTED
	 SKIPA T3,CHWTB(T3)	;GET THEM
	  MOVS T3,CHWTB(T3)	;ELSE GET FIRST TWO BYTES
	TRNN T1,1		;IF BYTE 0 OR 2
	LSH T3,-9		;SHIFT OVER
	HRROS T3
	AND T3,TTBRKC(T2)	;RETAIN BITS SPECIFIED AS BREAKS
	TRNN T3,777		;IS THIS CHAR ONE OF THEM?
	 LSH T3,-1		;YES, SHIFT BIT 15 INTO BIT 16
	TLNE T3,2		;WAS ECHO SUPPRESSED?
NVTRC1:	 AOSA -1(P)		;YES, INDICATE RCTE HAS DONE NOUGHT
	  IORI T1,400		;ELSE INDICATE ECHO GENERATED
	CALL ULKTTY		;UNLOCK DATA BASE
	POP P,T3		;RESTORE AC3
	RET
>;END OF REPEAT 0

;NVTXGA - SEND GA

;ACCEPTS:
;	T2/ ADDRESS OF DYNAMIC DATA

;RETURNS +1:  ALWAYS

NVTXGA:	MOVE T1,TTNETW(T2)	;GET STATUS WORD
	TXNN T1,NVGAB		;GA SUPPRESSED
	CALL CKNNVT		;OR NOT NEW PROTOCOL?
	 RET			;99 NO
	 JRST NVTXG1		;NO.  SKIP GA
	MOVEI T1,GACH		;GET GA CHARACTER
	CALL NVTSSP		;SEND IT
NVTXG1:	MOVEI T3,(1B<RCTOPT+WILOPT>) ;RCTE OPTION REQUEST
	TDNN T3,NVTOPF(T2)
	 RET			;NO
	LOAD T1,PBRCT,(T2)	;GET BREAK COUNT
	ADDI T1,1		;ADD ONE
	CAILE T1,MAXBRC		;OVER MAXIMUN
	 BUG(IMPTMB)
	STOR T1,PBRCT,(T2)	;STORE COUNT OF BREAKS BACK
	SETZRO NVWKS,TTNETW(T2)	;CANCEL WAKEUP SEEN
NVTRRR:	STKVAR<NVTCH>
NVTRR0:	SETZM NVTCH		;ASSUME ZERO COMMAND
	JE NVRCS,TTNETW(T2),NVTRR1 ;ANY CHANGE IN STATE?
				; NO, BYPASS THIS NONSENSE.
	CALL GTBRKC		;GET BREAK CLASSES
	MOVEM T1,NVTCH		;SAVE THAT
	CALL GTSPCC		;GET BREAK CLASS FOR SPECIAL ECHO CHAR.
	IORM T1,NVTCH		;MUST BREAK ON ALL OF THEM
	SKIPE T1		;ANY SPECIAL BREAKS?
	 MOVEI T1,2		;YES, SUPPRESS ECHO OF BREAKS
	MOVE T3,TTFLGS(T2)	;GET FLAGS
	TXNN T3,<TT%ECO!TT%ECM>	;NO ECHO WANTED?
	 IORI T1,6		;SUPPRESS ALL ECHOES
	TXC T3,<TT%ECO!TT%ECM>
	TXCN T3,<TT%ECO!TT%ECM>	;SUPPRESS ECHOES OF BREAKS?
	 IORI T1,2		;YES, ...
	IORI T1,11		;CAUSE BREAK CLASS TO CHANGE
	HRLM T1,NVTCH		;SAVE THE COMMAND
	SKIPA T1,[^D10]		;NEED 4 CHARS FOR BREAK CLASSES
NVTRR1:	MOVEI T1,6		;NEED 6 FOR SB ETC
	CALL NVTRSV		;RESERVE SPACE
	 RET			;RETURN
	MOVEI T1,SBCH		;BEGINNING OF SUBNEGOTIATIONS
	CALL NVTSSP		;SEND IAC-SB
	MOVEI T1,RCTOPT
	CALL TCOBQ		;SAY WHICH OPTION WE ARE CHANGING
	HLRZ T1,NVTCH		;GET COMMAND
	CALL TCOBN		;SEND THE COMMAND
	 JUMPE T1,NVTRR3	;NO CHANGE, SKIP THE FOLLOWING
	HRRZ T1,NVTCH		;GET NEW BREAK CLASSES
	LSH T1,-8		;GET HIGH ORDER BYTE
	CALL TCOBN		;SEND IT
	HRRZ T1,NVTCH		;AND LOW ORDER TOO.
	CALL TCOBN		;SEND LOW ORDER BYTE
NVTRR3:	MOVEI T1,SECH		;END OF SUBNEGOTIATIONS
	CALL NVTSSP		;SEND SE
	LOAD T1,PBRCT,(T2)	;GET OUTSTANDING BREAKS
	MOVE T3,NVTCH		;GET BREAK INFO BACK
	SKIPE T3		;SKIP IF NONE
	MOVEM T3,TTBRKC(T2)	;SET NEW CURRENT BREAK CLASSES
	SOS T1			;DECREMENT OUTSTANDING BRKS
	STOR T1,PBRCT,(T2)	;STORE BACK
	SETZRO NVRCS,TTNETW(T2)	;CANCEL STATE CHANGE
	OKSKD1
	JUMPN T1,NVTRR0		;REPEAT IF BREAKS STILL OUTSTANDING
	RET
	ENDSV.


; TABLE OF BREAK CLASS FOR EACH CHARACTER

U==1
L==2
N==4
FC==10
CC==20
K6==40
K7==100
K8==200
K9==400

CHWTB:	BYTE(9)CC,CC,CC,CC,CC,CC,CC,CC	; ^@ - ^G
	BYTE(9)FC,FC,FC,FC,FC,FC,CC,CC	; ^H - ^O
	BYTE(9)CC,CC,CC,CC,CC,CC,CC,CC	; ^P - ^W
	BYTE(9)CC,CC,CC,CC,CC,CC,CC,FC	; ^X - EOL
	BYTE(9)K9,K6,K8,K8,K8,K8,K8,K8	; SPACE - '
	BYTE(9)K7,K7,K8,K8,K6,K8,K6,K8	; ( - /
	BYTE(9)N,N,N,N,N,N,N,N		; DIGITS
	BYTE(9)N,N,K6,K6,K7,K8,K7,K6	; 8, 9 - ?
	BYTE(9)K8,U,U,U,U,U,U,U		; @ - G
	BYTE(9)U,U,U,U,U,U,U,U		; H - O
	BYTE(9)U,U,U,U,U,U,U,U		; P - W
	BYTE(9)U,U,U,K7,K8,K7,K8,K8	; X - _
        BYTE(9)K8,L,L,L,L,L,L,L		; ' - g
	BYTE(9)L,L,L,L,L,L,L,L		; h - o
	BYTE(9)L,L,L,L,L,L,L,L		; p - w
	BYTE(9)L,L,L,K7,K7,K7,K8,CC	; x - RUBOUT

;GTBRKC - GET TERMINAL BREAK CLASSES

;ACCEPTS:
;	T2/ DYNAMIC DATA ADDRESS

;RETURNS +1: ALWAYS
;	T1/ BREAK CLASSES


GTBRKC:	SETZ T1,
	MOVE T3,TTFLGS(T2)
	TXNE T3,TT%WKA		;BREAK ON ALPHANUMERICS
	 TRO T1,7		;UPPER AND LOWER CASE AND NUMBERS
	TXNE T3,TT%WKP		;PUNCTUATION
	 TRO T1,740
	TXNE T3,TT%WKN		;NON-FORMATTING CONTROLS
	 TRO T1,20
	TXNE T3,TT%WKF		;FORMATTERS
	 TRO T1,10
	RET

;GTSPCC - GET BREAK CLASS FOR CHARACTERS NEEDING SPECIAL ECHOES

;ACCEPTS:
;	T2/ ADDRESS OF DYNAMIC DATA

;RETURNS +1: ALWAYS
;	T1/ BREAK CLASS FOR CHARACTERS NEEDING SPECIAL OUTPUT

GTSPCC:	STKVAR<NVCOC1,NVCOC2,NVFMCC>
	CALL TTYGPI		;GET PI CHARACTERS AS COCFORMAT
	MOVE T1,NVCOC1		;SAVE COC WORDS FROM TTYGPI
	MOVE T3,NVCOC2
	CALL TTRCOC		;GET CONTROL CHAR OUTPUT MODES
	ANDCMI T3,377		;ONLY CONTROL CHARACTERS
	IORI T3,2B<40*2-^D36+1>	;FAKE A NORMAL ECHO FOR SPACE
	ANDCM T3,NVCOC2		;FORCE ZEROES FOR INT CHARS
	ANDCM T1,NVCOC1
	XOR T1,NVTNMD		;COMPARE TO ASSUMED ECHO MODE
	XOR T3,NVTNMD+1
	MOVE T1,NVFMCC		;SAVE T1
	MOVEI T1,FC		;ASSUME NEEDS FORMATTERS
	EXCH T1,NVFMCC		;SAY SO AND GET T1 BACK
	TDZN T1,[BYTE (2)0,0,0,0,0,0,0,0,3,3,3,3,3,3]
	TDNE T3,[BYTE (2)0,0,0,0,0,0,0,0,0,0,0,0,0,3]
	 SKIPA
	 SETZM NVFMCC		;NOT NEEDED AFTER ALL
	TDZN T1,[BYTE (2)3,3,3,3,3,3,3,3,0,0,0,0,0,0,3,3,3,3]
	TDNE T3,[BYTE (2)3,3,3,3,3,3,3,3,3,3,3,3,3,0,0,3]
	 MOVEI T1,CC		;NEED SPECIAL ECHO FOR NON-FORMATTERS
	IOR T1,NVFMCC
	TRNE T3,<BYTE (2)0,0,0,0,0,0,0,0,0,0,0,0,0,0,3>	; SPACE?
	 IORI T1,K9		;NEED SPECIAL ECHO FOR SPACE
	RET
	ENDSV.


;TTYGPI - GET NORMAL MODES FOR ECHO (MUST AGREE WITH THAT IN USER TELNET)

;ACCEPTS:
;	T2/ ADDRESS OF DYNAMIC DATA

;RETURNS +1: ALWAYS
;	T1/ COC1 WORD BASED ON INTERRUPT CHARACTERS
;	T3/ COC2 WORD BASED ON INTERRUPT CHARACTERS


TTYGPI:	STKVAR<NVTCC1,NVTCC2,NVDYND>
	SETZM NVTCC1		;ZERO COC TYPE WORDS HERE
	SETZM NVTCC2
	MOVEM T2,NVDYND		;NEED THIS ACCUMULATOR
	MOVE T1,TTPSI(T2)	;GET PSI BITS
	ANDCMI T1,77		;MASK OUT EXTRANEOUS BITS
	TRZE T1,100		;IS SPACE AN INTERRUPT?
	 TRO T1,10		;YES, SET BIT 40(8)
	TRZE T1,20		;RUBOUT?
	 TRO T1,4		;SET BIT 41(8)
	LSH T1,-1		;AVOID SIGN BIT
TTGPI1:	MOVN T2,T1		;COMPLEMENT ALL BUT RIGHTMOST 1
	AND T2,T1		;GET JUST THAT BIT
	ANDCAM T2,T1		;CLEAR IT
	MUL T2,T2		;SQUARE IT
	LSH T3,1		;FILL THE GAP
	IORB T3,NVTCC2		;OR IN BITS
	IORB T2,NVTCC1
	JUMPN T1,TTGPI1		;LOOP TILL ALL ARE DONE
	LSHC T2,1
	IOR T2,NVTCC1		;OR IN BITS
	IOR T3,NVTCC2
	LSHC T2,1
	MOVE T1,T2		;MOVE FIRST WORD TO T1
	MOVE T2,NVDYND		;RESTORE ADDRESS OF DYNAMIC DATA
	RET
	ENDSV.

NVTNMD:	BYTE (2)0,0,0,0,0,0,0,2,2,2,2,2,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2

REPEAT 0,<
;NVTXWW - RCTE SET NVWKS

;ACCEPTS:
;	T2/ ADDRESS OF DYNAMIC DATA

;RETURNS +1: ALWAYS


NVTXWW:	SETONE NVWKS,TTNETW(T2)	;SET WAKEUP SEEN
	RET
>;END OF REPEAT 0


REPEAT 0,<
;NVTXWK - RCTE CHECK FOR READING BREAK CHARACTERS AND SEND RCTRST IF NEEDED

;ACCEPTS:
;	T1/ CHARACTER
;	T2/ ADDRESS OF DYNAMIC DATA

;RETURNS +1: ALWAYS

NVTXWK:	SKIPL TTNETW(T2)		;THAT IS STILL CONNECTED
	CALL CKNNVT		;AND USING NEW PROTOCOL
	 RET			;NO, RETURN
	PUSH P,T3		;PRESERVE T3
	MOVEI T3,(1B<RCTOPT+WILOPT>) ;RCTE OPTION REQUEST
	TDNN T3,NVTOPF(T2)
	 JRST NVTXWX		;NO
	JE NVWKS,TTNETW(T2),NVTXW1 ;JUST SAW WAKEUP? SEND A RCTE RESET
	PUSH P,T1
	CALL NVTXGA		;NOW SEND THIS ONE
	POP P,T1		;RESTORE AC1
NVTXW1:	PUSH P,T1		;SAVE ALL 8 BITS
	ANDI T1,177		;TABLE IS 128 LONG
	LDB T1,PCLASS		;GET THE WAKEUP CLASS OF THIS CHAR
	LOAD T3,TT%WAK,TTFLGS(T2) ;AND OF THIS LINE
	TDNN T3,T1		;IS THIS A WAKEUP?
	 JRST [POP P,T1		;NO. RESTORE THE CHARACTER
		JRST NVTXWX]	;DON'T WAKE IT.
	POP P,T1		;YES. RESTORE THE CHARACTER
	SETONE NVWKS,TTNETW(T2)	;REMEMBER WE SAW IT
NVTXWX:	POP P,T3		;RETORE T3
	RET
>;END OF REPEAT 0

REPEAT 0,<
;NVTCIB - NVT CLEAR INPUT BUFFER
;NEEDS NEW PROTOCOL FEATURE TO WORK PROPERLY

;ACCEPTS:
;	T2/ ADDRESS OF DYNAMIC DATA

;	TDCALL OFF VCLIBF	;CLEAR INPUT BUFFER


;RETURN +1: ALWAYS

NVTCIB:	SKIPL TTNETW(T2)	;STILL CONNECTED TO NETWORK?
	CALL CKNNVT		;AND NEW STYLE NVT?
	 RET			;NO. DONE
	MOVEI T1,RCTOPT		;USE RCTE OPTION IN REVERSE
	SKIPN INSKED		;ARE WE IN THE SCHEDULER?
	SKIPE NSKED		;OR NO SKED
	SKIPA			;YES SKIP CALL
	CALL NVTNGT		;TO CLEAR INPUT BUFFER
	SETZRO PBRCT,(T2)	;CLEAR BREAK COUNT
	RET
>;END OF REPEAT 0

REPEAT 0,<
;NVTXPI - NOTE CHANGE IN PSI SET

;ACCEPTS:
;	T2/ ADDRESS OF DYNAMIC DATA

;RETURNS +1: ALWAYS


NVTXPI:	CALL CKNNVT
	 RET
	MOVEI T3,NVTOPF(T2)	;GET CURRENTLY ON OPTIONS
	TDNN T3,(1B<RCTOPT+WILOPT>) ;RCTE OPTION REQUEST
	 JRST NVTXP1		;NO
	SETONE NVRCS,TTNETW(T2)	;NOTE STATE CHANGE
	RET
>;END OF REPEAT 0

;NVTCOB - NVT CLEAR OUTPUT BUFFER CALLED FROM TTCBF2

;ACCEPTS:
;	T2/ ADDRESS OF DYNAMIC DATA

;	TDJRST OFF VCLOBF	;CLEAR OUTPUT BUFFER


;RETURNS +1: ALWAYS


NVTCOB:	SKIPE INSKED		;IN SCHEDULER
	RET			;YES RETURN IMMEDIATELY
	SKIPG TTNETW(T2)	;STILL CONNECTED TO NETWORK?
	 JRST NVTCO3		;NO.  RETURN
	NOINT			;PROTECT POSSIBLE ILOCKS
	LOAD T1,TLTYP,(T2)	;100 Get line type
	CAIE T1,TT.NVT		;100 ARPA NVT?
	 JRST NVTCO0		;100 No, skip this
	PUSH P,T2
	PUSH P,Q1
	LOAD Q1,PTNTO,(T2)	;OUTPUT UNIT
	SETSEC Q1,ANBSEC
	CALL NETHLK		;GET HOST AND LINK
	CALL IMPINS		;SEND CONTROL MESSAGE
	POP P,Q1
	POP P,T2		;RESTORE REGISTERS
NVTCO0:	CALL CKNNVT		;NEW STYLE NVT?
	 JRST NVTCOS		;99 SUPDUP
	 JRST NVTCO1		;OLD STYLE
	MOVEI T1,DMCH		;DATA MARK CHARACTER
	CALL NVTSSP		;SEND NEW DM
	JRST NVTCO2

NVTCO1:	MOVEI T1,1		;RESERVE ONE CHARACTER
	CALL NVTRSV		;GO REESERVE IT
	 JRST NVTCO2		;NONE AVAILABLE CANNOT WAIT
	MOVEI T1,200
	CALL TCOBN		;SEND CHARACTER
	OKSKD1
NVTCO2:	OKINT
NVTCO3:
;;;	CALL TTXONA		;REACTIVATE OUTPUT IF NECESSARY
	RET
;99 Begin addition
NVTCOS:	MOVEI T1,1		;RESERVE ONE CHARACTER
	CALL NVTRSV		;GO REESERVE IT
	 JRST NVTCO2		;NONE AVAILABLE CANNOT WAIT
	MOVEI T1,%TDORS		; Output reset (+++ should be in DPY table)
	CALL TCOBN		;SEND CHARACTER
	OKSKD1
	JRST NVTCO2
;99 End addition

;TTCOBN - NVT CLEAR OUTPUT BUFFERS
;ENTERS CLEAR BUFFER ROUTINE AFTER DEVICE DEPENDENT CODE TO PREVENT 
; LOOPING

;ACCEPTS:
;	T2/ ADDRESS OF DYNAMIC DATA


;RETURNS +1: ALWAYS


TTCOBN:	NOSKD1
	CHNOFF DLSCHN
	CALLRET TTCOB5

;NVTDOB - PERFORM DOBE SEQUENCE CALLED FROM TTDOBE

;ACCEPTS:
;	T2/ ADDRESS OF DYNAMIC DATA

;	TDJRST OFF VDOBE	;DOBE


;RETURNS +1: ALWAYS


NVTDOB:	CALL CKNNVT		;NEW NVT?
	 RET			;99 NO, SUPDUP
	 RET			;NO. JUST RETURN
	MOVEI T1,TMKOPT		;TIMING MARK OPTION
	CALL NVTNGT		;GO NEGOTIATE OPTION
	 JFCL			;IGNORE FAILURE
	RET

;NVTPAR - CHECK STPAR ARGUMENT AND NEGOTIATE ANY NEEDED OPTIONS


;ACCEPTS:
;	T1/ NEW JFN MODE WORD
;	T2/ ADDRESS OF DYNAMIC DATA

;	TDCALL OFF VSTPAR	;STPAR JSYS


;RETURNS +1: ALWAYS

NVTPAR:	STKVAR<NVJFMW>
	MOVEM T1,NVJFMW		;SAVE NEW JFN MODE WORD
	CALL CKNNVT		;NEW NVT?
	 RET			;99 NO, SUPDUP
	 JRST NVTPA1		;NO OLD STYLE
	MOVE T3,T1		;COPY NEW STATE
	XOR T1,TTFLGS(T2)	;GET DIFFERENCE
	TXNN T1,TT%DUM		;CHANGE IN ECHO?
	 JRST NVTPA2		;NO, TRY NEXT
	MOVX T1,ECHOPT+WILOPT	;ECHO OPTION REQUEST
	TXNN T3,TT%DUM		;NEGOTIATE ON?
	SKIPA T3,[IFIW!NVTNGT]	;YES NEGOTIATE ECHO
	MOVE T3,[IFIW!NVTNGF]	;NO
	CALL @T3		;CALL THE ROUTINE
	 SKIPA			;SET TO LINE HALF DUPLEX
	JRST NVTPA2		;CHECK FOR OTHER NEGOTIATIONS
	SETONE TT%DUM,NVJFMW	;SET IT	TO LINE HALF DUPLEX


NVTPA2:				;OTHER CHECKS GO HERE IF ANY
NVTPAX:	MOVE T1,NVJFMW		;RESTORE NEW JFN MODE WORD
	RET


NVTPA1:	XOR T1,TTFLGS(T2)	;GET ANY CHANGES
	TXNN T1,TT%DUM		;DUPLEX MODE
	 JRST NVTPAX		;NONE EXIT
	MOVE T1,NVJFMW
	TXNE T1,TT%DUM		;IS NEW FULL?
	 SKIPA T1,[204]		;NO. SEND "YOU ECHO"
	  MOVEI T1,203		;YES. SEND "I ECHO"
	CALL TCOBN
	JRST NVTPAX		;RETURN
	ENDSV.


REPEAT 0,<
;NVTMOD - CHECK SFMOD ARGUMENT AND NEGOTIATE ANY OPTIONS NEEDED

;ACCEPTS:
;	T1/ NEW JFN MODE WORD
;	T2/ ADDRESS OF DYNAMIC DATA

;RETURN +1: ALWAYS

NVTMOD:	STKVAR<MDJFMW,MDDIFW,MDRADD>
	CALL CKNNVT		;NEW NVT?
	 RET			;99 NO, SUPDUP
	 RET			;NO. DO NOTHING
	MOVEM T1,MDJFMW		;SAVE NEW JFN MODE WORD
	MOVE T3,T1		;COPY OF ARGUMENT
	XOR T1,TTFLGS(T2)	;GET BIT DIFFERENCE
	MOVEM T1,MDDIFW		;SAVE DIFFERENCE
	TRNN T1,1B29		;CHANGE IN BINARY?
	 JRST NVTMO1		;NO.  TRY OTHER OPTIONS
	TRNN T3,1B29		;BINARY REQUESTED
	SKIPA T3,[IFIW!NVTNGT]	;YES NEGOTIATE BINARY
	MOVE T3,[IFIW!NVTNGF]	;NO
	MOVEM T3,MDRADD		;SAVE ROUTINE ADDRESS
	MOVEI T1,BINOPT		;REQUEST FOR BINARY
	CALL @T3		;CALL THE ROUTINE
	 IFNSK.
		MOVEI T1,1B29	;SET TO ASCII
		IORM T1,MDJFMW	; IN NEW JFN MODE WORD
		JRST NVTMO1	;GO TO NEXT OPTION
	 ENDIF.
	MOVEI T1,BINOPT+WILOPT	;BINARY REQUEST
	MOVE T3,MDRADD		;GET ROUTINE ADDRESS
	CALL @3			;REQUEST OPTION
	 IFNSK.
		MOVEI T1,BINOPT	;BINARY
		CALL NVTNGF	;TELL HIM NO
		 JFCL
		MOVEI T1,1B29	;SET TO ASCII
		IORM T1,MDJFMW	; IN JFN MODE WORD
		JRST NVTMO1	;TRY NEXT OPTION
	 ENDIF.
NVTMO1:	MOVE T3,MDDIFW		;GET BIT DIFFERENCE
	MOVEI T1,(1B<RCTOPT+WILOPT>)
	TDNE T1,NVTOPF(T2)	;NO RCTE ON?
	TRNN T3,TT%WAK+TT%ECO+TT%ECM ;OR NO CHANGE IN WAKEUP SET
	 JRST NVTMO2		;NO,, SKIP FOLLOWING
	SETONE NVRCS,TTNETW(T2)	;NOTE CHANGE IN RCTE SETTINGS
NVTMO2:	MOVE T1,MDJFMW		;GET BACK JFN MODE WORD
	RET
>;END OF REPEAT 0

;NVTNGT - NEGOTIATE AN OPTION

;ACCEPTS:
;	T1/ OPTION REQUEST
;	T2/ ADDRESS OF DYNAMIC DATA

;RETURN +1: FAILURE COULD NOT GET OPTION
;	+2: SUCCESS GOT OPTION

NVTNGT:	MOVEI T3,[IFIW!NVTXWL	;GET ADDRESS OF WILL
		IFIW!NVTXDO]	; AND DO ROUTINES
	CALL NVTNGC		;GO NEGOTIATE THEM
	 AOS 0(P)		;SUCCESS
	RET			;FAILURE

;NVTNGF - REFUSE OPTION

;ACCEPTS:
;	T1/ OPTION REQUEST
;	T2/ ADDRESS OF DYNAMIC DATA

;RETURN +1: SUCCESS REFUSED OPTION
;	+2: FAILURE COULD NOT REFUSE OPTION


NVTNGF:	MOVEI T3,[IFIW!NVTXWN	;GET ADDRESS OF WON'T
		IFIW!NVTXDN]	; AND DON'T ROUTINES
NVTNGC:	CAIL T1,MAXOPT		;LEGAL OPTION
	 RET			;NO
	STKVAR<NNGOPT,NNGADD,NNGDAD>
	MOVEM T1,NNGOPT		;SAVE OPTION
	MOVEM T2,NNGDAD		;AND ADDRESS OF DYNAMIC DATA
	MOVEM T3,NNGADD		;AND ADDRESS OF ROUTINES
	MOVE T3,BITS(T1)	;CONVERT OPTION TO FLAG BITS
	IORM T3,NVTOPF(T2)	;SET OPTION NEGOTIATION IN PROGRESS BIT
	TRZN T1,WILOPT		;ARE WE ASKING FOR THIS OPTION
	AOS NNGADD		;NO.  BUMP TO DO OR DON'T
	MOVE T3,NNGADD		;GET ADDRESS OF ROUTINE
	CALL @0(T3)		;SAY "DO, WIL, DONT, WONT"
	MOVE T1,NNGOPT		;GET OPTION BACK
	ROT T1,-9		;INTO TOP 9 BITS
	MOVE T2,NNGDAD		;GET DYNAMIC DATA ADDRESS
	CALL TTYDIS		;SET UP FOR DISMISS
	MOVE T2,NNGDAD		;GET DYNAMIC DATA ADDRESS
	DYNST			;GET STATIC LINE NUMBER
	MOVSS T2		;MOVE IT TO THE LEFT HALF
	IOR T1,T2		;LINE NUMBER IN 9-17
	HRRI T1,NVTNTT		;ACTIVATION TEST
	MDISMS
	MOVE T2,NNGDAD		;GET ADDRESS OF DYNAMIC DATA
	CALL TTYAWK		;GO NOINT AGAIN
	SETZRO NVTMO,TTNETW(T2) ;CANCEL ANY TIME-OUT IN PROGRESS
	MOVE T1,NNGOPT		;GET OPTION AGAIN
	MOVS T3,BITS(T1)	;CONVERT TO FLAG
	TDNN T3,NVTOPF(T2)	;IS IT OFF
	 AOS 0(P)		;SKIP IF SUCCESSFUL
	RET
	ENDSV.


;NVTNTT - WAIT ROUTINE FOR NVT NEGOTIATIONS

;ACCEPTS T1/  BITS 18-26  OPTION NUMBER
;	      BITS 27-35  TTY NUMBER

NVTNTT:	LDB T3,[POINT 9,1,26]	;GET OPTION NUMBER
	MOVE T3,BITS(T3)
	ANDI T1,777		;LINE NUMBER
	MOVE T2,T1		;GET LINE NUMBER IN T2
	CALL STADYN		;GET ADDRESS OF DYNAMIC DATA
	 JRST T1(T4)		;NOT ACTIVE. THIS SHOULD NOT HAPPEN
	SKIPE TTNETW(T2)	;SATISFIED IF DISCONNECTED
	TDNN T3,NVTOPF(T2)
	 JRST 1(T4)		;NEGOTIATION COMPLETE
	JRST 0(T4)



;CHECK OVERDUE NEGOTIATIONS

NEGCHK::MOVE T2,NVTPTR		;POINTER TO NVTS
NEGCH1:	STKVAR<NVTCTR>		; 100: Other nets join here
NEGCKL:	MOVEM T2,NVTCTR		;SAVE NVT COUNTER
	HRRZ T2,T2		;GET JUST RIGHT HALF
	CALL LCKTTY		;GET ADDRESS OF DYAMIC DATA AND LOCK
	 JRST NEGCKE		;NOT ACTIVE
	SKIPGE TTNETW(T2)	;ATTACHED?
	 JRST NEGCKE		;NO, SKIP IT
	MOVX T3,NVTMO		;TIME OUT
	HLLZ T1,NVTOPF(T2)	;GET OUTSTANDING OPTIONS
	 JUMPE T1,[ANDCAM T3,TTNETW(T2) ;NONE, CANCEL TIME-OUT IF ANY
		JRST NEGCKE]
	XORB T3,TTNETW(T2)	;YES, COUNT COUNTER
	TXNN T3,NVTMO		;COUNT FROM 1 TO 0?
	 HRRZS NVTOPF(T2)	;YES, CANCEL OUTSTANDING OPTION
NEGCKE:	CALL ULKTTY		;UNLOCK DATA BASE
	MOVE T2,NVTCTR		;GET AOBJ COUNTER
	AOBJN T2,NEGCKL		;ANY MORE NVT'S
;;;100: deletion
	RET
	ENDSV.

;NETTCS - MOVE TTY OUTPUT TO NET BUFFERS

;ACCEPTS:
;	T2/ ADDRESS OF DYNAMIC DATA

;RETURN +1: ALWAYS


NETTCS::MOVEI T3,(1B<RCTOPT+WILOPT>)
	TDNE T3,NVTOPF(T2)
	CALL CKNNVT
	 JRST NETTC8		;99 No RCTE
	 JRST NETTC8		;NO RCTE
	LOAD T3,PBRCT,(T2)	;LOAD BREAK COUNT
	SKIPE T3		;NEED TO SEND RESET?
	 CALL NVTRRR		;YES, TRY TO SEND
NETTC8:	SKIPG TTNETW(T2)	;STILL CONNECTED?
	 JRST NETTCF		;NO, JUST CLEAR BUFFER
	LOAD Q1,PTNTO,(T2)	;GET UNIT INDEX
	SETSEC Q1,ANBSEC
	CALL NETDED		;END OF TRANSMISSION OR DEAD HOST
	 JRST NETTCF		;YES, DON'T SEND ANY MORE
	PUSH P,T2		;PRESERVE DYNAMIC DATA ADDRESS
	LOAD T1,LTIDX,(Q1)	;GET LINK TABLE INDEX
	SETSEC T1,ANBSEC
	CALL PKCHK		;CHECK HOW MANY BYTES CAN BE SENT NOW
	MOVE FX,T2		;SAVE NUMBER OF BYTES
	POP P,T2		;GET BACK DYNAMIC DATA ADDRESS
	JUMPLE FX,PKULCK	;IF NONE, GIVE UP
	CAILE FX,140		;BUT LIMIT TO 140 CHARS
	 MOVEI FX,140
	MOVEI Q2,1(P)		;USE STACK AS LOCAL BUFFER
	HRLI Q2,(<POINT 8,0,31>);CONSTRUCT 8-BIT BYTE PTR
	ADJSP P,40		;RESERVE SPACE ON STACK
	PUSH P,Q2		;SAVE BYTE PTR
	SETZ T4,		;INIT CHAR COUNT
	SETONE TTOTP,(T2)	;INDICATE OUTPUT ACTIVE
NETTC2:	SOJL FX,NETTC4		;COUNT DOWN LIMIT
	PUSH P,T2		;SAVE ADDRESS OF DYNAMIC DATA
	PUSH P,T4		;SAVE T4
	NOSKD1
	CALL TTSND		;GET A CHARACTER FROM OUTPUT BUFFER
	 NOP			;BFR EMPTY, TTOTP CLEARED
	OKSKD1
	POP P,T4		;RETORE T4
	POP P,T2		;GET BACK DYNAMIC DATA ADDRESS
	JE TTOTP,(T2),NETTC5	;DID WE GET A CHARACTER?
	IDPB T1,Q2		;YES. PUT CHAR ON STACK BUFFER
	AOJA T4,NETTC2

NETTC4:	SETZRO TTOTP,(T2)	;CLEAR OUTPUT ACTIVE BIT
NETTC5:	POP P,T3		;GET BACK BYTE POINTER
	JUMPE T4,[ADJSP P,-40	;NO CHARS TO SEND, CLEAR STACK
		LOAD T1,LTIDX,(Q1) ;GET LINK TABLE INDEX
		SETSEC T1,ANBSEC
		CALLRET PKULCK]
	MOVEI T1,^D8		;EIGHT BIT BYTES
	IMUL T1,T4		;GET NUMBER OF BITS
	ADDM T1,NETBTC(Q1)	;ADD TO CONNECTION BIT TRANS. COUNT
	MOVNS T1		;NOW GET NEGATIVE NUMBER OF BITS
	ADDM T1,NETBAL(Q1)	;ADJUST BIT ALLOCATION
	LOAD T1,LTIDX,(Q1)	;GET LINK TABLE INDEX
	SETSEC T1,ANBSEC
	PUSH P,T2		;SAVE DYNAMIC DATA ADDRESS
	CALL PKMSG1		;PACK THE MESSAGE
	POP P,T2		;RESTORE DYNAMIC DATA ADDRESS
	ADJSP P,-40		;CLEAR STACK
	JRST NETTC8		;SEE IF ANY MORE

NETTCF:	CALL TTCOBN		;FLUSH OUTPUT BUFFER
	LOAD Q1,PTNTO,(T2)	;1012 Be sure that Q1 is valid
	SETSEC Q1,ANBSEC	;1012 and in right section
	LOAD T1,LTIDX,(Q1)	;GET LINK TABLE INDEX
	SETSEC T1,ANBSEC
	RET

;NVTUPI - UNPACK MESSAGE INTO TTY BUFFERS

;ACCEPTS
;	T1/ LT INDEX
;	T2/ ADDRESS OF DYNAMIC DATA
;	Q1/ IMPUN/SOCKET TABLE INDEX 

NVTUPI::STKVAR<NVUPLT,NVUPCT,NVUPDD>
	MOVEM T1,NVUPLT		;PRESERVE LINK TABLE INDEX
	SETZM NVUPCT		;COUNT BYTES UNPACKED
	MOVEM T2,NVUPDD		;SAVE DYNAMIC DATA ADDRESS
NVTUPL:	MOVE T1,NVUPLT		;GET LINK TABLE INDEX
	CALL UPBYT		;GET  BYTE
	 JRST NVTUPD		;NOTHING TO UNPACK
	AOS NVUPCT		;COUNT BYTES
	MOVE T1,T3		;SAVE CHARACTER
	MOVE T2,NVUPDD		;GET ADDRESS OF DYNAMIC DATA
	LOAD T3,NVSTP,(T2)	;GET THE CURRENT COMMAND STATE OF THIS
	SETZRO NVSTP,(T2)	;ZERO CURRENT STATE
	CALL @NVTSTD(T3)	;DISPATCH ON IT
	JRST NVTUPL		;DO NEXT CHARACTER


NVTUPD:
	MOVE T4,NVUPCT		;BYTES UNPACKED
	IMULI T4,^D8		;EIGHT BITS/BYTE
	ADDM T4,NETBTC(Q1)	;INCREMENT ARPANET CONN. BIT COUNT
	MOVE T4,NVUPCT		;BYTES UNPACKED
	MOVE T2,NVUPDD		;GET ADDRESS OF DYNAMIC DATA
	MOVE T1,NVUPLT		;RESTORE LT INDEX
	IMUL T4,[-8]		;CALCULATE NEGATIVE BITS
	HLRE Q1,IMPLT1(T1)	;GET CONNECTION NUMBER
	SETSEC Q1,ANBSEC
	ADDB T4,NETBAL(Q1)	;UPDATE BIT ALLOCATION
	JUMPGE T4,NVTUP1	;REALLOCATE
	BUG(IMPNEA)
	SETZM NETBAL(Q1)	;ZERO ALLOCATION
NVTUP1:	CALL NVTRAL		;REALLOCATE
	MOVE T2,NVUPDD		;GET ADDRESS OF DYNAMIC DATA
	RET
	ENDSV.

NVTSTD:	IFIW!NVTNRM		;NOTHING DEFERRED
	IFIW!NVTWIL		;DEFERRED WILL
	IFIW!NVTWNT		;DEFERRED WONT
	IFIW!NVTDO		;DEFERRED DO
	IFIW!NVTDNT		;DEFERRED DONT
	IFIW!NVTIAC		;DEFERRED IAC
	IFIW!NVT300		;99 SUPDUP - deferred 300
	IFIW!NVTCLC		;99 SUPDUP - reading console loc


;NVTNRM - NORMAL NVT CHARACTER PROCESSING

;ACCEPTS:
;	T1/ CHARACTER
;	T2/ ADDRESS OF DYNAMIC DATA

;RETURN +1: ALWAYS

;99 Begin modification
NVTNRM:	CALL CKNNVT		; What type terminal?
	 JRST [	CAIN T1,300	; SUPDUP
		 JRST NVTSU0	; Control char (+++ ITP?)
		JRST .+2]	; Vanilla char
	 JRST [	CAIL T1,200	; Old NVT
	 	 JRST NVTCT0	; Control char
		JRST .+1]	; Vanilla char
	CAIN T1,IACCH		; New NVT.  Is it IAC?
	 JRST NVTCTL		; No, PROCESS POSSIBLE NVT CONTROL CHARACTER
;99 End modification
NVTDCH:	MOVE T3,NVTOPF(T2)
	TXNE T3,<1B<BINOPT+^D18>>
	 JRST NVTUPB		; Binary, skip special checks
	JE NVCRI,TTNETW(T2),[	;WAS LAST CH CR?
		CAIE T1,.CHCRT	;NO. IS THIS ONE?
		 JRST NVTUPB	;NO, PROCEED NORMALLY
		SETONE NVCRI,(T2) ;YES, REMEMBER IT
		JRST NVTUPB]	;AND SEND IT ON
	SETZRO NVCRI,(T2)	;YES, FORGET THAT
	JUMPE T1,R		;NULL?
	CAIN T1,.CHLFD		;WAS THIS ONE A LINE FEED
	RET			;YES, FORGET IT
NVTUPB:	SETZ Q2,		;NO SPECIAL FLAGS
	PUSH P,Q1		;SAVE Q1
	DYNST			;GET LINE NUMBER FOR TTCHI
	NOSKD1			;TTCHI EXPECTS TO BE CALLED NOSKED
	CALL TTCHI		;STUFF IT IN TTY BUFFER
	 NOP			;IGNORE ERROR RETURN
	OKSKD1
	POP P,Q1
	RET

;NVTCTL - TELNET CONTROL CODES RECEIVED

;ACCEPTS:
;	T1/ CHARACTER
;	T2/ ADDRESS OF DYNAMIC DATA

;RETURN +1: ALWAYS

NVTCTL:	SKIPGE TTNETW(T2)	;IF NO SOCKETS ATTACHED,
	 JRST NVTDCH		;IGNORE CHAR
;99	CALL CKNNVT		;NEW STYLE NVT?
;99	 JRST NVTCT0		;NO, LOOK FOR OLD STYLE COMMANDS
;99	CAIE T1,IACCH		;YES, IS IAC
;99	 JRST NVTDCH		;NO, CONTINUE PROCESSING
	JRST NVTCL4		;YES. TAKE CARE OF IT

NVTCT0:	CAIN T1,202		;NOP
	 RET
	CAIN T1,200		;SYNC CHAR?
	 JRST NVTCL1
	CAIN T1,203		;ECHO OFF?
	 JRST NVTCL2
	CAIN T1,204		;ECHO ON?
	 JRST NVTCL3
	JRST NVTDCH

NVTCL1:	PUSH P,T1		;SAVE A TEMP AC
	LOAD T1,PTITC,(T2)	;SYNC COUNTS 1, INS COUNTS -1
	AOJ T1,
	STOR T1,PTITC,(T2)
	POP P,T1		;RESTORE THE AC
	RET

NVTCL3:	TDZA T1,T1		;FULLDUPLEX ZERO AC AND SKIP
NVTCL2:	MOVEI T1,.TTLDX		;LINE HALF DUPLEX
	STOR T1,TT%DUM,TTFLGS(T2) ;SET DUPLEX MODE FULL/HALF
	RET

;PROCESS IAC

NVTCL4:	MOVEI T3,.DFIAC		;SET TO DEFFERED IAC
	STOR T3,NVSTP,(T2)
	RET

;NVTIAC - PROCESS BYTE AFTER IAC

;ACCEPTS:
;	T1/ CHARACTER
;	T2/ ADDRESS OF DYNAMIC DATA

;RETURN +1: ALWAYS


NVTIAC:	CAIGE T1,SECH		;END OF SUBNEGOTIATIONS
	 RET			;NOT A VALID COMMAND
;99	SETONE NVNNV,TTNETW(T2)	;MARK THIS NEW PROTOCOL
	MOVX T3,.TYNNV		;99 MARK THIS NEW PROTOCOL
	STOR T3,NVTYP,(T2)	;99
	SETZ T3,		;NEXT STATE IF ANY
	XCT NVTDTB-SECH(T1)	;DISPATCH ON THE CHARACTER
	 JRST NVTDCH		;SPECIAL FUNCTION CHARACTER
	STOR T3,NVSTP,(T2)	;NEXT STATE
	RET

NVTDTB:	RET			;(360) END OF SUBNEGOTIATION
	RET			;(361) NOP -- IGNORE
	JRST NVTCL1		;(362) NEW DATA MARK
	RET			;(363) BREAK -- IGNORE
	MOVEI T1,3		;(364) IP -- CONVERT TO ^C
	MOVEI T1,"O"-100	;(365) AO -- CONVERT TO ^O
	MOVEI T1,"T"-100	;(366) AYT -- CONVERT TO ^T
	MOVEI T1,177		;(367) EC -- CONVERT TO DEL
	MOVEI T1,"U"-100	;(370) EL -- CONVERT TO ^U
	RET			;(371) GA -- IGNORE
	RET			;(372) SB -- SHOULDN'T GET THIS
	TROA T3,.DFWIL		;(373) DEFER WILL
	TROA T3,.DFWNT		;(374) DEFER WONT
	TROA T3,.DFDO		;(375) DEFER DO
	TROA T3,.DFDNT		;(376) DEFER DONT
	JFCL			;(377) IAC IAC -- IAC


;99 Begin addition
; 300 received
NVTSU0:	MOVEI T3,.DF300
	STOR T3,NVSTP,(T2)
	RET

; Char after 300
NVT300:	CAIN T1,301		; Logout char?
	 RET			; +++ Yes
	CAIE T1,302		; Console loc
	 RET			; No, punt char
	MOVEI T3,.DFCLC
	STOR T3,NVSTP,(T2)
	RET

NVTCLC:	JUMPE T1,R		; Null, back to normal
	MOVEI T1,.DFCLC		; +++ put string somewhere
	STOR T1,NVSTP,(T2)
	RET

;99 End addition


;NVTSSP - SEND SPECIAL CHARACTER

;ACCEPTS:
;	T1/ CHARACTER
;	T2/ ADDRESS OF DYNAMIC DATA

;RETURN +1: ALWAYS

NVTSSP:	PUSH P,T1		;SAVE CHARACTER
	MOVEI T1,2		;NEED 2 CHARACTERS
	CALL NVTRSV		;RESERVE SPACE IN BUFFER (NOSKED)
	 JRST [	POP P,T1	;COULDN'T GET DON'T WAIT
		RET]		;RETURN
	HRROI T1,IACCH		;SAME AS 377, BUT PREVENT ITS DOUBLING
	CALL TCOBN		;CALL TCOBN TO GET CR-NULL IF NEEDED
	POP P,T1		;GET BACK SPECIAL CHARACTER
	CALL TCOBQ		;SEND IT
	OKSKD1
	RET

;NVTRSV - RESERVE SPACE IN BUFFER FOR CHARACTERS SPECIFIED IN 1

;ACCEPTS:
;	T1/ NUMBER OF CHARACTERS
;	T2/ ADDRESS OF DYNAMIC DATA

;RETURN +1: FAILURE NO ROOM
;	+2 SUCCESS

NVTRSV:	NOSKD1			;MAKE SURE SPACE DOESN'T DISAPPEAR
	LOAD T3,TOMAX,(T2)	;MAXIMUM BYTES IN OUTPUT BUFFER
	SUB T3,TTOCT(T2)	;SPACE IN OUTPUT BUFFERS
	CAML T3,T1		;WILL THEY FIT
	 RETSKP			;YES. ENOUGH ROOM, RETURN SKIP
	OKSKD1
	MOVE T3,FORKX		;GET FORK NUMBER
	CAMN T3,NCPFRK		;IS THIS THE NCP FORK?
	 JRST NVTRV1		;YES, ATTEMPT TO SEND THE BUFFER
	SKIPN INSKED		;IN THE SCHEDULER
	SKIPE NSKED		;OR NO SKED
	RETBAD			;YES TELL HIM THERE WAS NO ROOM
	PUSH P,T1		;NO. WAIT FOR SPACE
	PUSH P,T2		;SAVE ARGUMENTS
	MOVEI T1,TCOTST		;GET ADDRESS OF WAIT ROUTINE
	CALL TTYDIS		;SET UP FOR DISMISS
	DYNST			;GET LINE NUMBER
	HRL T1,T2		;MOVE IT TO THE LEFT HALF
	MDISMS			;WAIT FOR SPACE
	POP P,T2		;RESTORE ARGUMENTS
	CALL TTYAWK		;GO NOINT AGAIN
	POP P,T1
	JRST NVTRSV		;TRY AGAIN

NVTRV1:	JN <TTRXF,TTSFG>,(T2),R		;IF STOPED RETURN
	PUSH P,T1		;SAVE NUMBER OF CHARACTERS
	PUSH P,Q1		;SAVE UNIT CALLED WITH
	LOAD Q1,PTNTO,(T2)	;GET UNIT NUMBER
	SETSEC Q1,ANBSEC
	LOAD T1,LTIDX,(Q1)	;GET LINK TABLE INDEX
	SETSEC T1,ANBSEC
	HRRZ T3,IMPLT4(T1)	;GET MSG ALLOC
	SKIPE T3		;IS THER ANY?
	 MOVE T3,NETBAL(Q1)	;YES. GET BIT ALLOC IF NON-ZERO MSG ALLOC
	POP P,Q1		;RESTORE UNIT CALLED WITH
	LSH T3,-3		;CONVERT TO BYTES
	CAMGE T3,0(P)		;AT LEAST WHAT WE NEED?
	 JRST [	POP P,T1	;NO. GIVE UP
		RET]
	PUSH P,T2		;PRESERVE LINE NUMBER
	CALL NETTC8		;SEND AS MUCH AS POSSIBLE
	POP P,T2		;RESTORE ADDRESS OF DYNAMIC DATA
	POP P,T1		;AND NUMBER OF CHARACTERS WANTED
	JRST NVTRSV		;AND TRY AGAIN

;NVTRFU - SEND WONT (REFUSE)

;ACCEPTS:
;	T2/ ADDRESS OF DYNAMIC DATA
;	OPTION ON TOP OF STACK

;RETURN +1: ALWAYS


NVTRFU:	MOVEI T1,WNTCH

;NVTSRP - SEND REPLY IN 1 FOR OPTION ON STACK

;ACCEPTS:
;	T1/ REPLY
;	T2/ ADDRESS OF DYNAMIC DATA
;	OPTION ON TOP OF STACK

;RETURN +1: ALWAYS


NVTSRP:	PUSH P,T1		;SAVE REPLY
	MOVEI T1,3
	CALL NVTRSV		;RESERVE SPACE FOR THREE CHARACTERS
	 JRST [	ADJSP P,-2	;NO ROOM CLEAN UP STACK
		RET]
	HRROI T1,IACCH		;SAME AS 377 BUT PREVENT DOUBLING
	CALL TCOBN		;USE TCOBN TO GET CR-NULL IF NEEDED
	POP P,T1		;GET REPLY
	CALL TCOBQ		;SEND IT
	POP P,T1		;GET OPTION
	CALL TCOBQ		;SEND IT
	OKSKD1
	RET

;NVTSWL - SEND WILL

;ACCEPTS:
;	T2/ ADDRESS OF DYNAMIC DATA
;	OPTION ON TOP OF STACK

;RETURN +1: ALWAYS

;NVTXWL - ENTRY FOR OPTION IN T1


NVTXWL:	PUSH P,T1		;SAVE OPTION
NVTSWL:	MOVEI T1,WILCH		;ENTER HERE WHEN OPTION IS ON STACK
	JRST NVTSRP		;SEND REPLY



;NVTSNR - SEND NO REPLY

;ACCEPTS:
;	T2/ ADDRESS OF DYNAMIC DATA
;	OPTION ON TOP OF STACK

;RETURN +1: ALWAYS


NVTSNR:	ADJSP P,-1		;NO REPLY NECESSARY OR POSSIBLE
	RET

;NVTSWN - SEND WONT

;ACCEPTS:
;	T2/ ADDRESS OF DYNAMIC DATA
;	OPTION ON TOP OF STACK

;RETURN +1: ALWAYS

;NVTXWN - ENTRY FOR OPTION IN T1


NVTXWN:	PUSH P,T1		;SAVE OPTION
NVTSWN:	MOVEI T1,WNTCH		;ENTER HERE WHEN OPTION ALREADY PUSHED
	JRST NVTSRP



;NVTSDO - SEND "DO"

;ACCEPTS:
;	T2/ ADDRESS OF DYNAMIC DATA
;	OPTION ON TOP OF STACK

;RETURN +1: ALWAYS

;NVTXDO - ENTRY FOR OPTION IN T1


NVTXDO:	PUSH P,T1		;SAVE OPTION
NVTSDO:	MOVEI T1,DOCH		;ENTER HERE WHEN OPTION ALREADY PUSHED
	JRST NVTSRP

;NVTSDN - SEND "DONT"

;ACCEPTS:
;	T2/ ADDRESS OF DYNAMIC DATA
;	OPTION ON TOP OF STACK

;RETURN +1: ALWAYS

;NVTXDN - ENTRY FOR OPTION IN T1


NVTXDN:	PUSH P,T1		;SAVE OPTION
NVTSDN:	MOVEI T1,DNTCH		;ENTER HERE WHEN OPTION ALREADY PUSHED
	JRST NVTSRP

;NVTDO - PROCESS "DO"

;ACCEPTS:
;	T1/ OPTION
;	T2/ ADDRESS OF DYNAMIC DATA

;RETURN +1: ALWAYS


NVTDO:	CAIL T1,WILOPT		;ARE WE WILLING?
	 JRST NVTDO1		;NO
	MOVE T3,BITS+WILOPT(T1)	;YES GET FLAG BITS
	TDNE T3,NVTOPF(T2)	;OUTSTANDING REQUEST
	 JRST NVTWI2		;YES GO PROCESS IT
NVTDO1:	PUSH P,T1		;REMEMBER THE OPTION
	MOVSS T3			;PUT BIT IN "OPTIONS ON" HALF
	TDNE T3,NVTOPF(T2)	;IS THE OPTION ON?
	 JRST NVTSNR		;YES, SEND NO REPLY
	CAIGE T1,NVTLOP		;DO WE KNOW ABOUT THIS OPTION
	 CALL @NVTDOD(T1)	;YES. ATTEMPT EXECUTION
	  JRST NVTRFU		;CAN'T DO IT -- REFUSE
	IORM T3,NVTOPF(T2)	;SET OPTION ON
	JRST NVTSWL		;AND SEND "WILL"

NVTDOD:	IFIW!R			;BINARY XMIT -- REFUSE FOR NOW
	IFIW!NVTECN		;TURN ECHOS ON
	IFIW!R			;RECONNECT -- REFUSE FOR NOW
	IFIW!NVTSGA		;SUPPRESS GA -- WONDERFUL NEWS
	IFIW!R			;MESSAGE SIZE -- REFUSE
	IFIW!R			;STATUS -- REFUSE
	IFIW!NVTDTM		;TIMING MARK -- TRY TO DO IT
;	IFIW!NVTDRC		;REMOTE CONTROLLED TRANS & ECHO
	IFIW!R			;DO NOT DO IT FOR NOW
NVTLOP=.-NVTDOD

;ACTION ROUTINES FOR "DO"
;TURN ECHOES ON

NVTECN:	MOVX T1,TT%DUM
	ANDCAM T1,TTFLGS(T2)	;SET TO FULL DUPLEX
	RETSKP

;SET SUPPRESS GA BIT

NVTSGA:	SETONE NVGAB,TTNETW(T2)
	RETSKP

;DO TIMING MARK PROTOCOL

NVTDTM:	RETSKP


REPEAT 0,<
;TURN ON RCTE

NVTDRC:	SETONE NVRCS,TTNETW(T2)	;END CURRENT STATE INFO WITH FIRST CMD
	SETZM TTBRKC(T2)		;CLEAR BREAK STATUS INFO
	MOVEI T1,1
	STOR T1,PBRCT,(T2)	;SEND ONE RCTE COMMAND TO START
	RETSKP		;WE ARE HAPPY TO DO RCTE
>;END OF REPEAT 0


;NVTDNT - PROCESS "DONT"

;ACCEPTS:
;	T1/ OPTION
;	T2/ ADDRESS OF DYNAMIC DATA

;RETURN +1: ALWAYS

NVTDNT:	CAIL T1,WILOPT		;ARE WE WILLING FOR THIS OPTION
	 JRST NVTDN1		;NO
	MOVE T3,BITS+WILOPT(T1)	;GET FLAG BITS
	TDNE T3,NVTOPF(T2)	;OUTSTANDING REQUEST
	 JRST NVTWN2		;YES
NVTDN1:	PUSH P,T1		;SAVE OPTION
	MOVSS T3		;PUT BIT IN "OPTION ON" HALF
	TDNN T3,NVTOPF(T2)	;OPTION ALREADY OFF?
	 JRST NVTSNR		;YES. SEND NO REPLY
	CAIGE T1,NVTLOP		;DO WE KNOW ABOUT THIS OPTION?
	 CALL @NVTDND(T1)	;YES. PERFORM ACTION
	ANDCAM T3,NVTOPF(T2)	;CLEAR THE OPTION
	JRST NVTSWN		;AND SEND "WON'T"

NVTDND:	IFIW!R			;DILEMMA -- HE WANTS OFF, BUT WE CAN'T
	IFIW!NVTECF		;ECHO OFF
	IFIW!R			;OPTION NOT ON, NO REPLY
	IFIW!NVTAGA		;HE WONT SUPPRESS GA -- NUTS
	IFIW!R			;MESSAGE SIZE OPTION
	IFIW!R			;STATUS OPTION
	IFIW!R			;TIMING MARK -- HUH?
	IFIW!R			;TURN OFF RCTE

;"DONT" ACTION ROUTINES
;TURN ECHOS OFF

NVTECF:	MOVX T1,TT%DUM		;DUPLEX MODE
	IORM T1,TTFLGS(T2)	;SET TO LINE HALF DUPLEX
	RET

;TURN OFF SUPPRESS GA BIT

NVTAGA:	SETZRO NVGAB,TTNETW(T2)
	RET

NVTWIL - ;PROCESS "WILL"

;ACCEPTS:
;	T1/ OPTION
;	T2/ ADDRESS OF DYNAMIC DATA

;RETURN +1: ALWAYS


NVTWIL:	CAIL T1,WILOPT		;ONLY WILOPT OPTIONS
	 JRST NVTWI1		;OTHERS CANNOT BE OUTSTANDING
	MOVE T3,BITS(T1)	;GET THE BIT FOR THE OPTION
	TDNN T3,NVTOPF(T2)	;IS THIS OPTION OUTSTANDING?
	 JRST NVTWI1		;NO.
NVTWI2:	MOVS T1,T3		;PUT BITS IN OPTION ON HALF
	IORM T1,NVTOPF(T2)	;SET WILL BIT
	ANDCAM T3,NVTOPF(T2)	;AND CLEAR OUTSTANDING BIT
	RET

NVTWI1:	PUSH P,T1		;SAVE THE OPTION
	MOVSS T3		;PUT BIT IN "OPTONS ON" HALF
	TDNE T3,NVTOPF(T2)	;IS OPTION ALREADY ON?
	 JRST NVTSNR		;YES. SEND NO REPLY
	CAIGE T1,NVTLOP		;LEGAL OPTION?
	 CALL @NVTWID(T1)	;YES.  CALL ACTION ROUTINE
	  JRST NVTSDN		;UNIMPLEMENTED OPTION OR CAN'T COMPLY
	IORM T3,NVTOPF(T2)	;DONE. SET OPTION "ON"
	JRST NVTSDO		;AND SEND "DO"

NVTWID:	IFIW!RSKP		;WILL BINARY -- DO
	IFIW!R			;WILL ECHO -- DONT
	IFIW!R			;RECONNECT -- DONT
	IFIW!RSKP		;SUPPRESS GA -- DO, DO, DO , DO!
	IFIW!R			;MESSAGE SIZE -- DONT
	IFIW!R			;STATUS -- DONT
	IFIW!R			;TIMING MARK -- HUH?
	IFIW!R			;WHAT'S HE TRYING TO DO?

;NVTWNT - PROCESS "WONT"

;ACCEPTS:
;	T1/ OPTION
;	T2/ ADDRESS OF DYNAMIC DATA

;RETURN +1: ALWAYS


NVTWNT:	CAIL T1,MAXOPT		;LEGAL OPTION
	 JRST NVTWN1		;NO.  OPTION NOT HANDLED
	MOVE T3,BITS(T1)	;GET BIT FOR OPTION
	TDNN T3,NVTOPF(T2)	;IS THIS OPTION OUTSTANDING
	 JRST NVTWN1		;NO. REQUEST
NVTWN2:	HLR T3,T3		;YES. NEG ACKNOWLEDGE
	ANDCAM T3,NVTOPF(T2)	;CLEAR BOTH OUTSTAND AND WILL FLAGS
	RET

NVTWN1:	PUSH P,T1		;SAVE OPTION
	MOVSS T3		;PUT BIT IN "OPTIONS ON" HALF
	TDNN T3,NVTOPF(T2)	;OPTION ALREADY OFF?
	 JRST NVTSNR		;YES. SEND NO RPLY
	ANDCAM T3,NVTOPF(T2)	;STRANGELY ENOUGH, THE USER END
	JRST NVTSDN		;NEVER HAS ANY OPTIONS TO TURN OFF

;NVTRAL - RE-ALLOCATE IF NEEDED TO BRING ALLOCATION UP TO OPERATING LEVEL

;ACCEPTS:
;	T2/ ADDRESS OF DYNAMIC DATA
;	Q1/ SOCKET TABLE INDEX (IMPUN)

;RETURN +1: ALWAYS


NVTRAL::CALL LCKNCP		;PREVENT NCP CHANGES
	CALL NETDED		;END OF TRANSMISSION OR DEAD HOST
	 JRST ULKNCP		;CONNECTION DEAD OR DONE
	LOAD T3,TIMAX,(T2)	;CAPACITY OF LINE
	SUB T3,TTICT(T2)	;GIVES SPACE NOW IN LINE BUFFER
	JUMPE T3,[LOAD T1,PTITC,(T2) ;IF FULL, CHECK FOR INS RECEIVED
		TRNE T1,4	;COUNT IS SYNC-INS, 3 BIT FIELD
		MOVEI T3,1	;INS REQUESTED, ALLOCATE 1 BYTE
		JRST .+1]
	LSH T3,3		;IMULI 3,8 (BYTE SIZE)
	SUB T3,NETBAL(Q1)	;DESIRED ALL LESS ALL NOW OUT
	MOVE T4,T3		;SAVE DIFFERENCE
	LOAD T1,LTIDX,(Q1)	;GET LINK TABLE INDEX
	SETSEC T1,ANBSEC
	HRRZ T3,IMPLT4(T1)	;CURRENT MSG ALLOC
	MOVN T3,T3		;MAKE POSITIVE
	ADDI T3,^D6		;RAISE IT TO 6
	LOAD T1,TIMAX,(T2)	;MAX SPACE IN BUFFER
	ASH T1,-1		;ONE-HALF
	CAMGE T4,T1		;RE-ALLOCATE IF MORE THAN HALF A BUFFER
	CAIL T3,4		;OR IF MORE THAN 3 MSGS
	SKIPA			;YES.  RE-ALLOCATE
	 JRST ULKNCP		;NO LEAVE
	CALL NETHLK		;GET HOST AND LINK
	CALL IMPALL		;GO ALLOCATE IT
	CALLRET ULKNCP		;UNLOCK ON THE WAY OUT

;3005 Begin addition
;Called off TDCALL from HSTTY

NTHST:	PUSH P,Q1
	NOSKED
	CALL STADYN		;Get dynamic data
	LOAD Q1,PTNTI,(T2)	;Get output unit
	OKSKED			;Done with dynamic data
	SETSEC Q1,ANBSEC	;Set to arpanet section for table lookup
	CALL NETHLK		;Find host
	MOVE T2,T1		;Move host to T2
	TXO T2,1B0		;Flag host, not TTY
	POP P,Q1		;Restore temp
	RET			;Back to caller

;3005 End addition

  >				;** END IFN .NTFLG ON FIRST PAGE

