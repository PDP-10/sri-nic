; UPD ID= 226, SNARK:<5.MONITOR>DIAG.MAC.6,  29-Sep-81 09:37:10 by DONAHUE
;TCO 5.1523 - SET THE CDB BACK ONLINE AT DGPDL2
; UPD ID= 1943, SNARK:<5.MONITOR>DIAG.MAC.5,   6-May-81 04:03:08 by WACHS
;TCO 5.1312 - CLOSE RACE WINDOW TO PREVENT RH2PIL BUGCHKS
; UPD ID= 1732, SNARK:<5.MONITOR>DIAG.MAC.4,  19-Mar-81 08:39:34 by WACHS
;TCO 5.1273 - RETURN CCW LIST AS WELL AS CHAN LOGOUT AREA
;TCO 5.1272 - ALLOW 2 DIAG JOBS TO COEXIST BETTER
; UPD ID= 509, SNARK:<4.1.MONITOR>DIAG.MAC.32,   6-May-80 16:13:56 by DBELL
;TCO 4.1.1155 - ALLOW SKIP STYLE CCW WORDS TO BE USED
; UPD ID= 356, SNARK:<4.1.MONITOR>DIAG.MAC.31,  26-Mar-80 11:06:18 by DBELL
;TCO 4.1.1119 - MAKE CHANGES NECESSARY FOR RP20 DISKS
;TCO 4.1.1115 - ALLOW MULTIPLE CCWS TO BE USED IN .DGSCP FUNCTION
;<4.MONITOR>DIAG.MAC.30, 25-Sep-79 11:22:05, EDIT BY DBELL
;FIX TYPO IN 4.2476
;<4.MONITOR>DIAG.MAC.29, 21-Sep-79 16:29:33, EDIT BY DBELL
;TCO 4.2476 - MAKE .DGPDL FUNCTION WORK IN GENERAL, EVEN ON TXO3'S
;<OSMAN.MON>DIAG.MAC.1, 10-Sep-79 15:21:53, EDIT BY OSMAN
;TCO 4.2412 - Move definition of BUGHLTs, BUGCHKs, and BUGINFs to BUGS.MAC
;<4.MONITOR>DIAG.MAC.27,  4-Mar-79 15:03:17, EDIT BY KONEN
;UPDATE COPYRIGHT FOR RELEASE 4
;<4.MONITOR>DIAG.MAC.26, 26-Feb-79 11:48:14, Edit by MCLEAN
;MAKE BLOCK TYPE CHECK FOR KDB IN DGPDL
;<4.MONITOR>DIAG.MAC.25, 22-Feb-79 12:06:29, Edit by MCLEAN
;CHANGE SE1CAL IN DGPDL TO SE1ENT
;<4.MONITOR>DIAG.MAC.24, 19-Feb-79 22:29:12, Edit by MCLEAN
;INCREMENT JB0FLG AFTER MTAJB0
;<4.MONITOR>DIAG.MAC.23, 18-Feb-79 01:21:49, Edit by MCLEAN
;FIX DGPDL TO CORRECTLY RECOGNIZE NON-EX DEVICE
;<4.MONITOR>DIAG.MAC.22, 18-Feb-79 01:08:27, Edit by MCLEAN
;FIX DGPDL TO DO CORRECT VERSION OF RESET TO CHANNEL
;<4.MONITOR>DIAG.MAC.21,  7-Feb-79 23:39:36, Edit by MCLEAN
;<4.MONITOR>DIAG.MAC.20,  7-Feb-79 18:16:20, Edit by MCLEAN
;<4.MONITOR>DIAG.MAC.19,  1-Feb-79 23:23:00, Edit by MCLEAN
;<4.MONITOR>DIAG.MAC.18,  1-Feb-79 15:39:48, Edit by MCLEAN
;CHANGE FUNCTION OF .DGPDL
;<4.MONITOR>DIAG.MAC.17, 31-Jan-79 01:07:42, Edit by MCLEAN
;MORE... DGPDL FIXES
;<4.MONITOR>DIAG.MAC.16, 28-Jan-79 21:07:56, Edit by MCLEAN
;FIX DEXIST SUBROUTINE TO DO CORRECT CHECK FOR UDB
;<4.MONITOR>DIAG.MAC.15, 28-Jan-79 16:56:10, Edit by MCLEAN
;<4.MONITOR>DIAG.MAC.14, 28-Jan-79 16:25:34, Edit by MCLEAN
;MORE .DGPDL FIXES
;<4.MONITOR>DIAG.MAC.13, 28-Jan-79 14:11:01, Edit by MCLEAN
;CHANGE DIAG11 LABEL TO DIAGZ1 SO MONSYM DOESN'T MESS THINGS UP
;<4.MONITOR>DIAG.MAC.12, 28-Jan-79 14:00:24, Edit by MCLEAN
;MORE .DGPDL CHANGES
;<4.MONITOR>DIAG.MAC.11, 28-Jan-79 13:54:59, Edit by MCLEAN
;<4.MONITOR>DIAG.MAC.10, 21-Jan-79 21:37:41, Edit by MCLEAN
;<4.MONITOR>DIAG.MAC.9, 21-Jan-79 17:56:07, Edit by MCLEAN
;ADD .DGPDL JSYS

;THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY ONLY BE USED
;  OR COPIED IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
;COPYRIGHT (C) 1976,1977,1978,1979 BY DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.

	SEARCH PROLOG,PHYPAR,SERCOD,PROKL
	TTITLE DIAG

; CODE TO SUPPORT THE DIAG JSYS FOR THE KL10

	SUBTTL DIAG JSYS

	EXTERN TODCLK
	EXTERN MAPPV,SETCST,MTRON,MTROFF,WATEPT,UNWEPT,MONCOR


;DIAG-THIS ROUTINE IS CALLED TO PERFORM SEVERAL DIAGNOSTIC FUNCTIONS
;THE CURRENTLY IMPLEMENTED ONES DO THE FOLLOWING:
;
;	1.RESERVE A CHANNEL FOR USE BY A DIAGNOSTIC
;	2.RELEASE THE CHANNEL FROM USE
;	3.SETUP A CHANNEL PROGRAM
;	4.GET CHANNEL STATUS
;
;CALL FORMAT:
;	1/-# OF WORDS IN ARGLIST,,ARGLIST ADDRESS
;
;	DIAG
;RETURN
;	+1	;ERROR RETURN,WRONG STATE,ILLEGAL ADDRESS,BAD FORMAT
;	+2	;NORMAL RETURN
;
; ACCUMULATOR DEFINITIONS
;
;	P4= ARGUMENT LIST POINTER
;	Q1= FUNCTION CODE + FLAGS
;	Q2= DEVICE ADDRESS

.DIAG::	MCENT
	MOVX T1,SC%WHL!SC%OPR!SC%MNT ;CHECK FOR SUFFICIENT PRIVLEDGE
	TDNN T1,CAPENB		;AGAINST ENABLED CAPABILITIES
	RETERR(WHELX1)		;NOT GOOD ENOUGH
	UMOVE P4,1		;GET THE ARGUMENT LIST(#ARGUMENTS,,LIST ADDRESS)
	UMOVE Q1,(P4)		;GET FUNCTION CODE
	HRRZ T1,Q1		;GET JUST FUNCTION CODE
	CAIL T1,.DGACU		;RANGE CHECK FUNCTION CODE
	CAILE T1,.DGGCS		; ...
	JRST [	CAIL T1,.DGGEM	;no. is it a mem control function
		CAILE T1,.DGPDL	;""
		RETERR (DIAGX1)	;no. error
		SUBI Q1,.DGGEM-.DGGCS-1 ;GET INDEX INTO DISPATCH
		JRST DIAGZ1]	;GO DO IT
	AOBJN P4,DIAG1		;UPDATE COUNT FIELD AND CHECK IF LEGAL
DIGER:	RETERR (DIAGX3)		;ARGUMENT COUNT FIELD WAS TOO SMALL
DIAG1:	UMOVE Q2,(P4)		;GET DEVICE ADDRESS
	LOAD T1,DG%ADT,Q2	;GET ADDRESS TYPE
	SKIPE T1		;LEGAL?
	RETERR (DIAGX4)		;ILLEGAL TYPE CODE SPECIFIED
	LOAD P1,DG%DVC,Q2	;GET DEVICE CODE
	CAIL P1,.DGRH0		;CHECK RANGE
	CAILE P1,.DGRH7		; ...
	RETERR(DIAGX8)		;ILLEGAL
	SUBI P1,.DGRH0		;CONVERT TO INDEX
	SKIPN P1,CHNTAB(P1)	; ...
	RETERR(DIAGX8)		;NO SUCH CHANNEL
DIAGZ1:	HRRZ T4,Q1		;GET ADDRESS ONLY
	CALL @DIAGFT-1(T4)	;GO PERFORM SPECIFIC FUNCTION
	SMRETN			;SKIP RETURN TO USER

;DISPATCH TABLE FOR FUNCTIONS-FUNCTION CODE INDEX #

DIAGFT:	IFIW!DGASDV		;ASSIGN CHANNEL-DEVICE MODE(TIMED)
	IFIW!DGASCU		;ASSIGN CHANNEL-CONTROLLER MODE(UNTIMED)
	IFIW!DGRLCH		;RELEASE THE CHANNEL
	IFIW!DGSTPG		;SETUP CHANNEL PROGRAM
	IFIW!DGRLPG		;RELEASE THE CHANNEL PROGRAM
	IFIW!DGGTST		;GET THE CHANNEL LOGGED OUT STATUS
;WARNING! ADD FUNCTIONS HERE CAREFULLY!

;END OF CHANNEL-SPECIFIC FUNCTIONS. DEFINE NEW FORMAT FUNCTIONS

	IFIW!DGMEM		;GET MEMORY
	IFIW!DGMEM0		;RELEASE MEMORY
	IFIW!DGPDL		;DYNAMIC RECONFIGURATION OF CHANNEL

;ASSIGN THE CHANNEL FOR USE BY THE CALLER
;

DGASDV:	AOBJN P4,DGAS1		;UPDATE POINTER
	RETERR (DIAGX3)		;COUNT FIELD BAD
DGAS1:	CALL DGUGET		;GET UDB FOR THIS REQUEST
	CALL DGUVAL		;VALIDATE ACCESS
	CALL DGLOCK		;SIEZE DIAG INTERLOCK, GO NOINT
	CALL DGEXAC		;LOCK PROGRAM AND GO NOSKED IF REQUESTED
	MOVE T1,JOBNO		;GET JOB NUMBER OF REQUESTOR
	SETONE DIAFL,(T1)	;REMEMBER HE HAS A RESOURCE
	CALL DGUASN		;SET MAINTENANCE MODE, BLOCK IF NEEDED
	CALL DGCASN		;ASSIGN CHANNEL
	UMOVE T1,(P4)		;GET TIME FIELD
	ADD T1,TODCLK		;AS OFFSET FROM CURRENT TIME
	MOVEM T1,UDBODT(P3)	;SET AS OVERDUE TIMER
DGUIOX:	MOVX T1,UIOF		;SET USER IOT IN PC
	IORM T1,-1(P)		;OF JSYS CALLER
	OKINT			;NOINT DONE IN DGLOCK
	RET

;ASSIGN CHANNEL IN CONTROLLER MODE-UNTIMED REQUEST

DGASCU:	CALL DGUMAP		;MAP NEXT INSTRUCTION ONTO ALL UDB
	 CALL DGUVAL		;VALIDATE ACCESS
	CALL DGLOCK		;SIEZE DIAG LOCK, GO NOINT
	CALL DGEXAC		;DO EXCLUSIVE ACCESS IF REQUESTED
	MOVE T1,JOBNO		;GET JOB NUMBER OF REQUESTOR
	SETONE DIAFL,(T1)	;REMEMBER HE HAS A RESOURCE
	CALL DGUMAP		;NOW ASSIGN
	 CALL DGUASN		;...
	CALL DGCASN		;ASSIGN CHANNEL
	JRST DGUIOX		;RETURN SETTING IOT USER


;HERE TO RELEASE A CHANNEL AND ALL DEVICES

DGRLCH::SAVEQ
	CALL DGCCHK		;VERIFY CHANNEL IN MAINTENANCE MODE
	CALL DGUMAP		;MAP ONTO ALL UDBS
	 CALL [	MOVSI T1,(US.MAI!US.MRQ) ;CHECK FOR MAINTENANCE MODE
		TDNN T1,UDBSTS(P3) ; ...
		RET		;NOT IN MAINTENANCE
		CALLRET DGUREL]	;RELEASE
	CALL DGRLPG		;RELEASE CHANNEL PROGRAM
	MOVSI T3,(CS.MAI!CS.MRQ) ;SET TO RELEASE CHANNEL
	MOVEI T1,0		;DO CHANNEL ONLY RESET
	HRRZ T2,CDBDSP(P1)	;GET CHANNEL DISPATCH
	SE0ENT			;LOWER LEVEL RUNS IN SEC0
	NOSKED
	IOPIOF
	ANDCAM T3,CDBSTS(P1)	;RELEASE CHANNEL
	HLLOS CDBONR(P1)	; ...
	SETZM CDBODT(P1)	; ...
	CALL CDSRST(T2)		;RESET CHANNEL PIA, ETC.
	CALL RSTSEK		;RESTART SEEKS
	CALL SCHXFR		;AND ANY TRANSFER
	IOPION
	OKSKED
	SE1CAL			;BACK TO SEC1
	CALL DGEXRL		;RELEASE EXCLUSIVE ACCESS IF ACQUIRED
	MOVX T1,UIOF		;CLEAR IOT USER
	ANDCAM T1,-5(P)		;IN JSYS CALLERS PC
	CALL DGUNLK		;CLEAR DIAG LOCK
	RET

;UNLOCK ANY LOCKED PAGES.  LOCATION DIAGCW POINTS TO THE BLOCK OF RESIDENT
;STORAGE CONTAINING THE CCW WORDS.  THE FIRST WORD OF THE BLOCK IS AN
;AOBJN POINTER TO THE ACTUAL CCW WORDS.


DGRLPG:	SAVEQ			;SAVE ACCUMULATORS
	CALL DGCCHK		;CHECK CHANNEL IN MAINTENANCE MODE
	NOINT			;NO INTERRUPTIONS
	HRRZ T1,CDBICP(P1)	;GET ICCW ADDRESS FOR THIS RH20
	SETZB Q1,(T1)		;CLEAR ANY JUMP WORD AND AN AC
	EXCH Q1,DIAGCW		;ZERO STORAGE POINTER AND GET OLD ONE IF ANY
	JUMPE Q1,DGRLFN		;DONE IF NO STORAGE WAS ASSIGNED
	SKIPN Q2,0(Q1)		;GET AOBJN POINTER TO THE CCW LIST
	JRST DGRLRL		;IF NONE, JUST RELEASE STORAGE

DGRLLP:	LDB T1,[POINT 13,(Q2),26]	;GET PHYSICAL CORE PAGE FROM CCW
	SKIPE T1		;WAS THERE ONE?
	CALL MULKCR		;YES, UNLOCK THE PAGE
	AOBJN Q2,DGRLLP		;DO FOR ALL CCW WORDS

DGRLRL:	MOVE T1,Q1		;GET ADDRESS OF BLOCK WE ARE DONE WITH
	CALL RELRES		;FREE UP THE BLOCK
DGRLFN:	OKINT			;INTERRUPTS ALLOWED NOW
	RET			;DONE

;SETUP CHANNEL PROGRAM

;RH20 SPECIFIC BITS
CHJMP==1B1			;JUMP
CHXFR==1B0			;TRANSFER DATA
CHLST==1B1			;LAST TRANSFER
CHREV==1B2			;REVERSE
CCWMAX==^D50			;MAXIMUM NUMBER OF CCW'S ALLOWABLE


DGSTPG:	CALL DGCCHK		;CHECK CHANNEL IN MAINTENANCE MODE
	CALL DGRLPG		;FIRST RELEASE OLD CCW LIST
	AOBJN P4,.+2		;MAKE SURE HAVE AT LEAST ONE CCW WORD
	 RETERR (DIAGX3)	;ARGUMENT LIST WAS TOO SHORT
	HLRE T1,P4		;GET NUMBER OF CCWS TO BUILD
	MOVNS P5,T1		;CREATE POSITIVE COUNT AND SAVE IN P5
	CAILE T1,CCWMAX		;SPECIFYING TOO MANY WORDS?
	 RETERR(DIAGX6)		;YES, ILLEGAL CCW LIST
	LSH T1,1		;DOUBLE IT SO WE CAN GUARANTEE CCWS ON ONE PAGE
	HRLI T1,.RESP3		;INSERT LOWEST PRIORITY REQUEST
	MOVEI T2,.RESGP		;ALLOCATE FROM GENERAL POOL
	NOINT			;MUST BE NOINT NOW
	CALL ASGRES		;GRAB SOME FREE CORE
	 RETERR(,<OKINT>)	;FAILED, ERROR
	MOVEM T1,DIAGCW		;REMEMBER ADDRESS OF FREE CORE BLOCK
	MOVEI T2,1(T1)		;GET POSSIBLE STORAGE ADDRESS FOR CCWS
	ANDI T2,PGSIZ-1		;KEEP ONLY OFFSET WITHIN PAGE
	ADDI T2,-1(P5)		;CREATE LAST OFFSET USED FOR CCWS
	CAIGE T2,PGSIZ		;WOULD ALL OF THE CCWS FIT ON ONE PAGE?
	TDZA T2,T2		;YES, SET UP TO USE THAT AREA
	MOVEI T2,-1(P5)		;NO, THEN USE OTHER HALF WHICH IS ON ONE PAGE
	ADDI T2,1(T1)		;CREATE ACTUAL STORAGE ADDRESS
	MOVNS P5		;NEGATE THE CCW COUNTER
	HRLZ P5,P5		;BUILD PART OF AOBJN POINTER
	HRR P5,T2		;INSERT ADDRESS WHERE CCWS ARE TO GO
	MOVEM P5,0(T1)		;SAVE POINTER TO CCWS IN FIRST WORD OF BLOCK

;NOW LOOP OVER ALL OF THE CCW WORDS SPECIFIED:


DGSTLP:	UMOVE P6,(P4)		;PICKUP NEXT CCW WORD
	 ERJMP DGSTIL		;FAILED
	JUMPGE P6,DGSTIL	;BAD CCW WORD IF NOT A TRANSFER CCW
	LDB T2,[POINT 11,P6,13]	;GET BYTE COUNT
	SOJL T2,DGST2		;ALLOW EITHER 0 OR EXACTLY ONE PAGE
	MOVE T3,P6		;COPY CCW
	ANDI T3,PGSIZ-1		;GET ADDRESS WITHIN PAGE
	TXNE P6,CHREV		;BACKWARDS?
	MOVNS T2		;YES, NEGATE COUNT
	ADD T3,T2		;DETERMINE TERMINATING WORD
	SKIPL T3		;WITHIN PAGE?
	CAIL T3,PGSIZ		; ???
	 RETERR(DIAGX7,<CALL DGRLPG
			OKINT>)	;CCW OVERFLOWS PAGE, GIVE ERROR
DGST2:	LDB T1,[POINT 18,P6,35]	;GET THE VIRTUAL ADDRESS IN AC1
	JUMPE T1,DGST3		;IF A SKIP WORD, JUST KEEP IT AS IS
	TXO T1,1B0		;INDICATE FROM USER MODE
	UMOVE T2,(T1)		;REFERENCE THE VIRTUAL PAGE TO CREATE IT
	 ERJMP DGSTIL		;FAILED
	CALL MLKMA		;LOCK THE PAGE INTO CORE
	DPB T1,[POINT 13,P6,26]	;STORE PHYSICAL PAGE INTO THE CCW
DGST3:	TXO P6,CHXFR		;FORCE TRANSFER FLAG ON
	MOVEM P6,0(P5)		;STORE FIXED UP CCW IN STORAGE BLOCK
	AOBJN P4,.+1		;ADVANCE USER'S POINTER
	AOBJN P5,DGSTLP		;LOOP FOR ALL CCW WORDS USER WANTS

	MOVX T1,CHLST		;GET FLAG READY
	IORM T1,-1(P5)		;FORCE LAST TRANSFER FLAG ON IN LAST CCW WORD
	MOVE T1,DIAGCW		;GET ADDRESS OF STORAGE BLOCK
	HRRZ T1,0(T1)		;THEN GET ADDRESS OF FIRST CCW WORD
	MAP T1,0(T1)		;FIND THE PHYSICAL ADDRESS OF THAT WORD
	TLZ T1,777760		;ZAP JUNK BITS
	TXO T1,CHJMP		;BUILD A JUMP WORD TO THE CCW LIST
	HRRZ T2,CDBICP(P1)	;GET ICCW ADDRESS
	MOVEM T1,0(T2)		;STORE THE JUMP WORD IN THE LOGOUT AREA
	SETZM 1(T2)		;CLEAR OTHER WORDS OF LOGOUT AREA
	SETZM 2(T2)		; ...
	OKINT			;INTERRUPTS OK AGAIN
	RET			;DONE


DGSTIL:	CALL DGRLPG		;RELEASE THE BLOCK
	OKINT			;ALLOW INTERRUPTS
	RETBAD(DIAGX6)		;SAY BAD CCW LIST FORMAT

;GET THE CURRENT CHANNEL STATUS FOR THE USER

DGGTST:	MOVEI T3,1(P4)		;GET USER DESTINATION
	ADD P4,BHC+3		;INCREMENT POINTER TO TEST LENGTH
	AOBJN P4,DGGT1		;UPDATE STORE POINTER
	RETERR (DIAGX3)		;POINTER WASN'T LONG ENOUGH
DGGT1:	HRRZ T2,CDBICP(P1)	;GET ICCW ADDRESS
	MOVEI T1,3		;3 WORD XFER
	CALL BLTMU		;TRANSFER WD0-WD2 TO USER SPACE
	JUMPG P4,R		;RETURN IF THATS ALL HE WANTS
	HRRZ T2,DIAGCW		;HE WANTS CCW LIST TOO - GET ITS ADDRESS
DGGT2:	MOVE T1,1(T2)		;GET A CCW
	UMOVEM T1,1(P4)		;TELL USER
	ERJMP R			;QUIT IF FAULT
	JUMPE T1,R		;RETURN AFTER STORING TERMINATING ZERO
	ADDI T2,1		;MORE - POINT AT NEXT
	AOBJN P4,DGGT2		;GIVE IT TO USER IF HE HAS THE ROOM
	RET			;FILLES ARGUMENT BLOCK - RETURN

;HERE TO DO UNIT/CONTROLLER ADDITION


DGPDL:	ADD P4,BHC+2		;CHECK SIZE TO SEE IF LEGAL
	AOBJP P4,DIGER		;NO -- TOO SMALL
	SUB P4,BHC+3		;RESTORE
	XCTU [SKIPL T1,1(P4)]	;GET CHANNEL AND CHECK VALIDITY
	CAILE T1,7		;LEGAL?
	RETERR (DIAGX8)		;NO
	SKIPE P1,CHNTAB(T1)	;MAKE SURE CHANNEL EXISTS
	XCTU [SKIPGE Q2,2(P4)]	;GET UNIT AND SEE IF NEGATIVE
	RETERR (DIAGX8)		;NO CHANNEL OR BAD UNIT
	XCTU [SKIPGE P5,3(P4)]	;CHECK FOR -1 CONTROLLER
	SETO P5,		;FORCE -1
	JUMPL P5,DGPDL2		;PROCEED IF NO CONTROLLER SPECIFIED
	HLRE T1,CDBIUN(P1)	;GET NEGATIVE NUMBER OF ENTRIES
	MOVN T1,T1		;MAKE POSITIVE
	CAML P5,T1		;VERIFY CONTROLLER NUMBER
	RETERR (DIAGX8)		;INVALID
	MOVE P3,CDBIUN(P1)	;GET ADDRESS OF UDB TABLE
	ADD P3,P5		;ADD TO GET PROPER ENTRY
	SKIPN P3,(P3)		;POINTER EXIST?
	JRST DGPDL2		;NO, GO CREATE ONE
	LDB T1,USYBKT		;GET BLOCK TYPE
	CAIE T1,.BTKDB		;CHECK FOR KDB
	RETERR (DIAG12)		;ERROR DEVICE NOT ON LINE
DGPDL2:	HRRZ T1,CDBDSP(P1)	;GET DISPATCH TABLE
	CALL CDSEXT(T1)		;SEE IF UNIT ALREADY EXISTS
	SKIPA			;DOESN'T ALL OK
	JRST [	SKIPL CDBSTS(P1);DOES - IS THE CDB OFFLINE?
		RETERR (DIAG11)	;NO ILLEGAL REQUEST
		MOVSI T1,(CS.OFL) ;YES
		ANDCAM T1,CDBSTS(P1);SET IT BACK ONLINE
		RET ]		;AND DONE
	SKIPN T1		;ILLEGAL UNIT NUMBER?
	RETERR (DIAGX8)		;YES, GIVE ERROR
	PUSH P,Q2		;SAVE Q2 AND P5
	PUSH P,P5
	SKIPL P5		;CHECK FOR NO CONTROLLER
	EXCH Q2,P5		;SET Q2 TO CONTROLLER, P5 TO UNIT
	NOINT
	SE0ENT
	CALL DGUMAP		;CHECK FOR VALIDITY
	 CALL DGUVAL
	CALL DGLOCK		;LOCK
	CALL DGUMAP		;PUT IN MAI MODE
	 CALL DGUASN
	CALL DGCASN		;ASSIGN CHANNEL
	NOSKED			;NOSKED
	IOPIOF			;TURN OFF CHANNEL
	MOVE Q3,CDBIUN(P1)	;GET CORRECT UNIT ADDRESS
	ADD Q3,Q2
	CALL RH2UNS		;GO GET UNIT SETUP
	SKIPN 0(Q3)		;ALREADY EXISTS?
	MOVEM P3,0(Q3)		;NO STORE THE NEW FOUND ENTRY
	CALL DGUMAP		;RELEASE ALL THE UNITS
	 CALL [	MOVSI T1,(US.MAI!US.MRQ)
		TDNN T1,UDBSTS(P3)
		RET		;NOT IN USE FORGET IT
		CALLRET DGUREL]	;RELEASE
	MOVSI T1,(CS.MAI!CS.MRQ) ;RELEASE CHANNEL
	ANDCAM T1,CDBSTS(P1)
	HLLOS CDBONR(P1)
	HRRZ T2,CDBDSP(P1)
	MOVEI T1,0		;RESET CHANNEL
	HRRZ T2,CDBDSP(P1)	;GET CHANNEL DISPATCH
	CALL CDSRST(T2)		;RESET CHANNEL PIA,ETC.
	CALL RSTSEK		;RESTART SEEKS
	CALL SCHXFR		;AND ANY TRANSFERS
	IOPION
	SE1ENT
	OKSKED
	AOS MTAJB0		;FORCE SETSPD TO RUN INCASE MAGTAPES
	AOS JB0FLG		;START JOB 0
	CALL DGUNLK		;UNLOCK  AND RETURN
	OKINT			;ALLOW INTERRUPTS
	POP P,P5
	POP P,Q2		;RESTORE Q2
	HRRZ T1,CDBDSP(P1)	;GET DISPATCH TABLE
	CALL CDSEXT(T1)		;SEE IF UNIT NOW EXISTS
	RETERR (DIAG12)		;NO, COMPLAIN
	RET			;ALL OK

;UTILITIES

;HERE TO CHECK THAT A CHANNEL IS IN MAINTENANCE MODE

DGCCHK:	MOVSI T1,(CS.MAI)	;MAINTENANCE FLAG
	TDNN T1,CDBSTS(P1)	; ...
	RETERR(DIAGX2)		;NO - RETURN ERROR
	RET			;ALL OK

;HERE TO VALIDATE ACCESS TO A UNIT

DGUVAL:	RET			;**TEMP**
;	MOVSI T1,(US.MAL)	;MAINTENANCE MODE ALLOWED?
;	TDNN T1,UDBSTS(P3)	; ??
;	RETERR(DIAGX5)		; NO
;	RET			;YES

;HERE TO ASSIGN A CHANNEL
;ASSUMES ALL UNITS ALREADY IN MAINTENANCE MODE, THEREFORE NEVER NEEDS TO BLOCK

DGCASN:	MOVSI T1,(CS.MRQ)	;SET MAINTENANCE REQUEST BIT
	IORM T1,CDBSTS(P1)	; ...
	CALL DGUMAP		;MAP OVER ALL UNITS
	 CALL DGCAS1
	MOVSI T1,(CS.MAI)	;ALL UNITS IDLE, SET MAINT
	IORM T1,CDBSTS(P1)	; ...
	MOVSI T1,(CS.MRQ)	;CLEAR REQUEST
	ANDCAM T1,CDBSTS(P1)	; ...
	SETZM CDBODT(P1)	;CLEAR OVERDUE TIME
	HRRZ T1,FORKX		;SETUP OWNING FORK
	HRRM T1,CDBONR(P1)	; ...
	HRRZ T1,CDBICP(P1)	;AND CLEAR ICCW
	SETZM (T1)		; ...
	RET

DGCAS1:	MOVSI T1,(US.ACT!US.REW) ;UNIT IDLE?
	TDNN T1,UDBSTS(P3)	;?
	RET			;YES
	MOVS T1,P3		;NO - MUST BLOCK
	HRRI T1,DGUIDL		;WAIT FOR IDLE
	PDISMS
	JRST DGCAS1		;CHECK AGAIN
;SCHEDULER TEST ROUTINE TO WAIT FOR UNIT IDLE

DGUIDL:	MOVSI T2,(US.ACT!US.REW) ;UNIT IDLE?
	TDNE T2,UDBSTS(T1)	; ...
	JRST 0(T4)
	JRST 1(T4)		;NO - UNBLOCK



;HERE TO ASSIGN A UNIT

DGUASN:	MOVSI T1,(US.MRQ)	;SET REQUEST BIT
	IORM T1,UDBSTS(P3)	; ...
DGUAS1:	MOVSI T2,(US.ACT)	;SETUP BITS FOR PIOFF TESTS
	MOVSI T3,(US.MAI)	; ...
	NOSKED
	IOPIOF
	TDNE T2,UDBSTS(P3)	;ACTIVE?
	JRST DGUAS2		;YES - MUST BLOCK
	IORM T3,UDBSTS(P3)	;NO - SET MAINTENANCE IMMEDIATELY
	IOPION
	OKSKED
	ANDCAM T1,UDBSTS(P3)	;CLEAR MAINTENANCE REQUEST
	SETZM UDBODT(P3)	;AND OVERDUE TIMER
	HRRZ T1,FORKX		;SETUP OWNING FORK
	HRRM T2,UDBONR(P3)	; ...
	RET

DGUAS2:	IOPION			;RE-ENABLE INTERRUPTS
	OKSKED
	MOVEI T1,DGUTST		;SCHEDULER TEST ROUTINE FOR UDB BLOCK
	HRL T1,P3		;SETUP UDB
	PDISMS			;WAIT FOR BIT TO SET
	MOVSI T1,(US.MRQ)	;BIT TO CLEAR
	JRST DGUAS1		;JOIN ABOVE

;SCHEDULER TEST FOR UDB IN MAINTENANCE MODE

DGUTST:	MOVSI T2,(US.MAI)	;TEST MAINTENANCE BIT
	TDNN T2,UDBSTS(T1)	;IN UDB
	JRST 0(T4)		;NOT ON YET
	JRST 1(T4)		;ON, UNBLOCK


;HERE TO RELEASE A UNIT

DGUREL:	MOVSI T1,(US.MAI!US.MRQ)	;CLEAR MAINTENANCE BIT
	ANDCAM T1,UDBSTS(P3)	; ...
	SETZM UDBODT(P3)	;CLEAR OVERDUE TIME
	HLLOS UDBONR(P3)	;RESET OWNING FORK
	RET

;HERE TO GET THE UDB POINTED TO BY THE ADDRESS IN Q2

DGUGET:	LDB P3,[POINT 6,Q2,29]	;GET UNIT ADDRESS
	HLRE T1,CDBIUN(P1)	;WITHIN BOUNDS?
	MOVNS T1
	CAIL P3,(T1)		; ??
	RETERR(DIAGX9)		;NO
	ADDI P3,CDBUDB(P1)	;INDEX INTO UDB TABLE
	SKIPN P3,(P3)		;ANYTHING THERE?
	RETERR(DIAGX9)		;NO
	LDB T1,USYTYP		;YES - GET UNIT TYPE
	CAIE T1,.UTTM2		;KDB?
	RET			;NO - DONE
	MOVE P2,P3		;COPY
	LDB P3,[POINT 6,Q2,35]	;GET SUBUNIT NUMBER
	HLRE T1,KDBIUN(P2)	;BOUNDS CHECK
	MOVNS T1
	CAIL P3,(T1)
	RETERR(DIAGX9)		;NOT LEGAL
	ADDI P3,KDBUDB(P2)	;INDEX INTO KDB UDB TABLE
	SKIPN P3,(P3)		;UDB PRESENT?
	RETERR(DIAG10)		;NO
	RET			;YES - ALL OK

;HERE TO CHECK IF EXCLUSIVE ACCESS (LOCK AND NOSKED) IS REQUIRED
;FOR THIS DIAG REQUEST

DGEXCK:	CALL DGUMAP		;CHECK ALL UNITS ON THIS CHAN
	 CALL DGEXC1
	RET

DGEXC1:	SKIPL UDBSTR(P3)	;IS UNIT IN A STR?
	TLO Q1,(1B0)		;SET SIGN BIT - NEED EXCLUSIVE ACCESS
	RET

;HERE TO ACQUIRE EXCLUSIVE ACCESS IF REQUESTED

DGEXAC:	CALL DGEXCK		;CHECK IF EXCLUSIVE ACCESS NEEDED
	JUMPGE Q1,R		;NOT NEEDED, RETURN
DGEXCA:	SAVEP			;YES - SAVE REGISTERS
	CALL ASGPAG		;GET FREE PAGE
	RETERR(MONX02)		;INSUFFICIENT RESOURCES
	MOVE P2,T1		;COPY SCRATCH PAGE ADDRESS
	SETOM (T1)		;SET PAGE TO ALL ONES
	HRLZ T2,T1		;BUILD BLT POINTER
	HRRI T2,1(T1)		; ...
	BLT T2,PGSIZ-1(T1)	;CLEAR PAGE TO ONES
	CALL MLKMA		;LOCK IN MEMORY
	CALL DGEXNS		;DO NOSKED, SPECIAL TRAP ACTIONS
	MOVSI P1,-PGSIZ		;LOOP OVER USER ADDRESS SPACE
DGEXA1:	SKIPN UPTPGA(P1)	;USER PAGE EXIST?
	JRST DGEXA2		;NO - KEEP LOOKING
	HRRZ T1,P1		;YES - LOCK IT DOWN
	LSH T1,PGSFT		;BUILD ADDRESS
	TLO T1,(1B0)		;MARK USER ADDRESS
	CALL MLKMA		;LOCK
	MOVE T2,P2		;BUILD INDEX INTO LOCKED PAGE LIST
	ADDI T2,(P1)		; ...
	MOVEM T1,(T2)		;SAVE ADDRESS
DGEXA2:	AOBJN P1,DGEXA1		;LOOP
	HRLM P2,DIAGFK		;STORE TEMP PAGE ADDRESS TO RELEASE
	RET

;HERE TO GO NOSKED

DGEXNS:	NOSKED			;LOCK UP THE PROCESSOR
	AOS PNSKDC		;SAY HAVE A NOSKED BECAUSE OF DIAG
;******SHOULD CONSIDER TRAPPING JSYS AND TRAPS HERE
	RET			;DONE

;HERE TO RELEASE EXCLUSIVE ACCESS

DGEXRL:	HLRZ T1,DIAGFK		;ANYTHING TO UNLOCK?
	JUMPE T1,R		;NO - EXIT
	SAVEP			;SAVE REGISTERS
	MOVSI P1,-PGSIZ		;SETUP TO UNLOCK ALL LOCKED PAGES
	HLRZ P2,DIAGFK		;GET TEMP PAGE ADDRESS
	SKIPN P2		;CHECK THERE WAS ONE
	BUG(DGZTPA)
DGEXR1:	HRRZ T1,P1		;WAS THIS PAGE LOCKED BY DIAG?
	ADD T1,P2		; ...
	SKIPGE T1,(T1)		; ?
	JRST DGEXR2		;NO - DO NOTHING
	CAML T1,MONCOR		;A REASONABLE PAGE?
	CALL MULKCR		;YES - UNLOCK IT
DGEXR2:	AOBJN P1,DGEXR1		;LOOP FOR WHOLE ADDRESS SPACE
	MOVE T1,P2		;NOW UNLOCK LOCK PAGE LIST PAGE
	CALL FPTA		;LACK OF MULKMA
	CALL MULKPG		;UNLOCK IT
	HRRZS DIAGFK		;CLEAR MEMORY OF PAGE
;****** RESTORE JSYS AND PAGE TRAP HERE
	NOINT
	SOS PNSKDC		;ONE LESS NOSKED BECAUSE OF RESOURCES
	OKSKED			;RELESE CPU
	MOVE T1,P2		;GET VIRTUAL ADDR BACK
	CALL RELPAG		;RELEASE IT
	HRRZ T1,FORKX		;CHECK IF ANY TTY ACTIVITY
	HLRZ T1,FKJOB(T1)	;GET JOB NUMBER
	HLRE T2,JOBPT(T1)	;GET CONTROLLING TERMINAL
	JUMPL T2,R		;IF DETACHED, QUIT
	CALL CKINP		;SEE IF ANY TERMINAL INPUT
	 RET			;NOTHING
	CHKINT			;USER IS TYPING. POKE SCHED
	RET

;HERE TO REQUEST THE DIAG LOCK

DGLOCK:	NOINT			;PREVENT INTS WHILE SETTING UP
	SKIPL DIAGWT		;WAIT A WHILE IF ANOTHER JOB IS BLOCKED FOR DIAG
	AOSE DIAGLK		;TEST/SET LOCK
	JRST DGLK1		;BUSY - MUST WAIT
	MOVE T1,FORKX		;HAVE LOCK - IDENTIFY OWNER
	MOVEM T1,DIAGFK		; ...
	RET

DGLK1:	OKINT			;BE OKINT WHEN BLOCKED
	SETOM DIAGWT		;INDICATE WE'RE WAITING
	MOVEI T1,DGLTST		;BLOCK
	MDISMS			; ...
	JRST DGLOCK		;TRY AGAIN

DGLTST:	SKIPL DIAGLK		;LOCK FREE?
	JRST 0(T4)		;NO
	AOSN DIAGWT		;YES, SOME OTHER FORK WAITING?
	JRST 0(T4)		;YES, LET HIM HAVE A CHANCE AT IT
	JRST 1(T4)		;MAYBE, TRY TO GET IT TOO

;HERE TO RELEASE THE DIAG LOCK

DGUNLK:	HLRZS T1,DIAGFK		;CHECK FOR UNRELEASED TEMP PAGE
	SKIPE T1		; ...
	BUG(DGUTPG)
	SETOM DIAGFK		;INDICATE NO OWNER
	SETOM DIAGLK		;FREE LOCK
	RET

;HERE TO RELEASE ALL DIAG. RESOURCES ALLOCATED TO THIS PROCESS
;CALLED FROM KSELF IF THE FORK HAS ANY ASSIGNED

DGFKIL::HRRZ T1,DIAGFK		;THIS FORK HAVE DIAG RESOURCE NOW?
	CAME T1,FORKX		;??
	RET			;NO - NOTHING TO DO NOW
	SAVEPQ			;SAVE ALL ACS
	MOVSI Q1,-CHNN		;BUILD AOBJN POINTER
FKIL1:	SKIPN P1,CHNTAB(Q1)	;ANYTHING PRESENT?
	JRST FKIL2		;NO - ON TO NEXT
	MOVSI T1,(CS.MRQ)	;MAINT REQUEST UP?
	TDNE T1,CDBSTS(P1)	;?
	ANDCAM T1,CDBSTS(P1)	;YES - CLEAR IT
	MOVSI T1,(CS.MAI)	;YES - IS IT IN ASSIGNED?
	TDNN T1,CDBSTS(P1)	; ??
	JRST FKIL2		;NO
	CALL DGRLCH		;YES - RELEASE IT
FKIL2:	AOBJN Q1,FKIL1		;LOOP FOR ALL CHANNELS
	RET			;ALL DONE

;DIAG ROUTINES FOR TGHA MEMORY CONTROL.

;MAP MEMORY. ALSO TURNS OFF PI AND ENTERS SECONDARY PROTOCOL.
;MAY ALSO TURN OFF METER

;ARGS ARE:

;	FIRST USER PAGE IN MAP REGION
;	FIRST REAL MEMORY ADDRESS TO MAP
;	COUNT OF PAGES TO MAP
;	AR/ARX TRAP ADDRESS. -1 => NO INTERVENTION

DGMEM:	STKVAR <USRPAG,MEMPAG,CNTPAG,PAGE1,PAGE2>
	AOBJN P4,DGMEM1		;GET USER ADDRESS
	RETERR (DIAGX3)		;NOT ENOUGH ARGS
DGMEM1:	UMOVE T1,0(P4)		;GET USER PAGE ADDRESS
	SKIPLE T1		;MUST BE A VALID PAGE NUMBER
	CAILE T1,777		;AND MUST BE IN ONE SECTION
	RETERR (ARGX06)		;INVALID PAGE NUMBER GIVEN
	MOVEM T1,USRPAG		;SAVE USER PAGE
	AOBJN P4,DGMEM2		;GET NEXT ARG
	RETERR (DIAGX3)		;NOT ENOUGH
DGMEM2:	UMOVE T1,0(P4)		;GET PHYSICAL ADDRESS
	CAMLE T1,NHIPG		;IS THIS PAGE EXTANT?
	RETERR(PMCLX2)		;NO. GIVE ERROR THEN
	MOVEM T1,MEMPAG		;SAVE IT
	AOBJN P4,DGMEM3		;GET LAST ARG
	RETERR (DIAGX3)		;TOO BAD. NOT THERE
DGMEM3:	UMOVE T1,0(P4)		;GET PAGE COUNT
	CAILE T1,1000		;MUST NOT BE GREATER THAN ONE SECTION
	RETERR (ARGX06)		;CAN;T HAVE IT THEN
	MOVEM T1,CNTPAG		;SAVE IT

;NOW SEE IF UPPER LIMITS MATCH

	ADD T1,MEMPAG		;GET LAST MEMORY PAGE
	SOS T1			;ONE LESS
	CAMLE T1,NHIPG		;WITHIN BOUNDS?
	RETERR (PMCLX2)		;NO. CAN;T DO IT THEN
	MOVE T1,CNTPAG		;GET COUNT AGAIN
	ADD T1,USRPAG		;GET END OF USER SPACE
	CAILE T1,1000		;WITHIN SECTION 0
	RETERR (ARGX06)		;NO. BOMB THEN
	SETOM P3		;ASSUME NO AR/ARX INTERVENTION
	AOBJP P4,DGMEM6		;IS ONE SPECIFIED?
	UMOVE P3,0(P4)		;YES. GET IT
	; ..

;HERE WITH ALL ARGS VALIDATED. NOW SET UP USER MAP

DGMEM6:	CALL DGLOCK		;GET DIAG LOCK. NOW NOINT
	MOVE T1,USRPAG		;GET USER PAGE
	MOVE T2,CNTPAG		;GET COUNT
DGMEM4:	SKIPE UPTPGA(T1)	;IS THIS MAP SLOT EMPTY?
	RETERR (ARGX06,<CALL DGUNLK>) ;NO. CAN'T DO FUNCTION THEN
	SOJLE T2,DGMEM5		;MORE TO DO?
	AOJA T1,DGMEM4		;YES
DGMEM5:	CALL ASGPAG		;GET A PAGE
	RETERR (MONX02,<CALL DGUNLK>) ;NONE THERE
	SKIP 0(T1)		;CREATE THE PAGE
	MOVEM T1,PAGE1		;SAVE THE PAGE
	CALL ASGPAG		;GET ANOTHER PAGE
	RETERR (MONX02,<CALL DGUNLK
			MOVE T1,PAGE1
			CALL RELPAG>) ;FREE THE PAGE
	MOVE T2,PAGE1		;GET ADDRESS OF PAGE 1
	MOVEM T2,0(T1)		;SAVE IT
	MOVE T2,MEMPAG		;GET FIRST MEM PAGE
	MOVEM T2,2(T1)		;SAVE IT
	MOVE T2,USRPAG		;GET FIRST USER PAGE
	MOVEM T2,3(T1)		;SAVE IT
	MOVE T2,CNTPAG		;GET COUNT OF PAGES
	MOVEM T2,4(T1)		;SAVE IT
	MOVEM T1,PAGE2
	MOVE T2,CASHF		;CURRENT CACHE STATE
	MOVEM T2,5(T1)		;SAVE IT

;USER MAP IS AVAILABLE FOR OPERATION. FIRST LOCK THE DIAGNOSTIC
;IN MEMORY

	CALL DGEXCA		;LOCK THE DIAGNOSTIC. WILL BE NOSKED ON RETURN
	MOVE T1,PAGE1		;GET PAGE I.D.
	CALL MLKMA		;LOCK IT IN
	MOVE T1,PAGE2
	HLRZ T2,DIAGFK		;SAVE LOCK PAGE
	HRLM T1,DIAGFK		;REMEMBER THIS ADDRESS
	MOVEM T2,1(T1)		;SAVE LOCK PAGE ADDRESS
	CALL MLKMA		;LOCK THIS ONE ALSO
	MOVE T1,FORKX		;GET FORK NUMBER OF THIS PROCESS
	HLL T1,FKPGS(T1)	;GET SPTN OF UPTA
	HRR T1,USRPAG		;GET STARTING PAGE NUMBER
	MOVE T2,MEMPAG		;GET MEMORY PAGE
	MOVE T3,CNTPAG		;GET COUNT
	CALL MAPPV		;SET UP THE MAP

;USER MAP NOW SET UP. NEED TO FIX UP CST0 AREA

	PIOFF			;TURN OFF INTERRUPTS
	CALL CASHOF		;TURN OFF THE CACHE
   REPEAT 0,<			;SKIP THIS FOR NOW
	JSR BUGMON		;AND ENTER SECONDARY PROTOCOL
	MOVEI T1,[SIXBIT '$MOS MEMORY DIAGNOSTIC RUNNING...$/']
	JSR BUGMSG		;TELL OPERATOR
   >				;END OF REPEAT 0
	; ..

;HERE WITH MACHINE COMPLETELY UNDER THIS PROCESS'S CONTROL.
;MUST NOW TURN OFF METER, SAVE CST0 FOR TARGET PAGES
;AND MAKE TARGET PAGES ACCESSIBLE.

	CALL MTROFF		;TURN OFF CLOCK. (DISABLES
				;METER AND TIMER).

;NOW SAVE RELEVANT CST0 LOCATIONS

	MOVE T1,MEMPAG		;FIRST MEM PAGE
	HRLI T1,CST0(T1)	;GET START OF TRANSFER
	HRR T1,PAGE1		;WHERE IT IS GOING
	MOVE T2,PAGE1		;GET DEST ADDRESS AGAIN
	ADD T2,CNTPAG		;# OF PAGES
	BLT T1,-1(T2)		;SAVE ALL OF CST0

;CST0 LOCATIONS NOW SAVED. SET UP CURRENT CST0 SO IS ACCESSIBLE

	MOVE T1,MEMPAG		;FIRST MEM PAGE
	MOVE T2,CNTPAG		;# OF PAGES
	CALL SETCST		;SET CST0 FOR THE PAGES
				;SETS AGE TO CURRENT AGE. SETS
				;USE FIELD TO ALL 1'S

;NOW ALL IS READY FOR THE DIAGNOSTIC. LET IT HAVE IT
;FIRST, WAIT FOR EPT USERS TO FINISH

	CALL WATEPT		;LET APRSRV DO THE WAITING

	MOVEM P3,DIAGAR		;SET AR/ARX INTERCEPT
	RET			;GO!

;MEMORY FUNCTION TO RELEASE ALL RESOURCES.
;NO ARS

DGMEM0:	STKVAR <USRPAG,MEMPAG,CNTPAG,PAGE1,PAGE2>
	SETZM DIAGAR		;CLEAR AR/ARX INTERCEPT
	CALL UNWEPT		;TURN ON EPT DEVICES
	HLRZ T1,DIAGFK		;GET PAGE WITH CONTROL INFO
	MOVEM T1,PAGE2		;SAVE IT
	MOVE T2,2(T1)		;FIRST MEMORY PAGE
	MOVEM T2,MEMPAG
	MOVE T3,3(T1)		;GET USER PAGE AFFECTED
	MOVEM T3,USRPAG
	MOVE T3,4(T1)		;GET COUNT OF PAGES USED
	MOVEM T3,CNTPAG
	MOVE T4,0(T1)		;GET PAGE WHERE CST0'S ARE SAVED
	MOVEM T4,PAGE1
	ADDI T2,CST0		;GET FIRST CST0 SLOT TO RESTORE
	ADD T3,T2		;THE END
	HRL T2,T4		;FORM BLT ARG
	BLT T2,-1(T3)		;RESTORE CST0 ENTRIES
	CALL MONCLA		;CLEAR MAP
	MOVE T4,1(T1)		;GET USER LOCK PAGE PAGE
	HRLM T4,DIAGFK		;RESTORE IT
	SKIPE 5(T1)		;WANT CACHE ON?
	CALL CASHON		;YES. SO TURN IT ON
   REPEAT 0,<			;NOT NEEDED PRESENTLY
	MOVEI T1,[SIXBIT '$MOS MEMORY DIAGNOSITIC COMPLETED$/']
	JSR BUGMSG		;TELL OPERATOR
	JSR BUGPRI		;TURN ON PRIMARY PROTOCOL
   >				;END OF REPEAT 0
	PION			;AND TURN ON INTS

;SYSTEM NOW ON

	NOINT			;PREVENT INTS
	CALL DGEXRL		;UNLOCK USER. NOW OKSKED
	MOVE T1,PAGE1		;GET JSB PAGE
	CALL FPTA		;GET I.D.
	CALL MULKPG		;UNLOCK IT
	MOVE T1,PAGE1		;GET IT AGAIN
	CALL RELPAG		;RELEASE IT
	MOVE T1,PAGE2		;GET OTHER JSB PAGE
	CALL FPTA		;GET I.D.
	CALL MULKPG		;UNLOCK IT
	MOVE T1,PAGE2		;GET IT AGAIN
	CALL RELPAG		;RELEASE IT
	; ..

;NOW CLEAN UP USER MAP

	MOVE T3,CNTPAG		;# OF PAGES
	SETOM T2		;SAY CLEAR MAP
	MOVE T1,FORKX		;THIS FORK
	HLL T1,FKPGS(T1)	;GET USER MAP
	HRR T1,USRPAG		;THE STARTING PAGE NUMBER
	CALL MAPPV		;CLEAR MAP
	CALL DGUNLK		;RELEASE DIAG LOCK
	OKINT			;ALLOW INTS NOW
	RET			;AND DONE, AT LAST

	TNXEND
	END
