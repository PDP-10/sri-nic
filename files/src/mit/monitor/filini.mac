; UPD ID= 69, SNARK:<5.MONITOR>FILINI.MAC.8,  23-Jul-81 14:08:18 by GRANT
;TCO 5.1431 - give PS:<OPERATOR> IPCF when creating the directory
; UPD ID= 2055, SNARK:<5.MONITOR>FILINI.MAC.7,  21-May-81 08:50:42 by LEACHE
;TCO 5.1338 - Add <SYSTEM-ERROR> to CRDTAB
; UPD ID= 1526, SNARK:<5.MONITOR>FILINI.MAC.6,   6-Feb-81 12:47:11 by ZIMA
;TCO 5.1258 - remove call to DMPINI in FILINI.
; UPD ID= 1004, SNARK:<5.MONITOR>FILINI.MAC.5,  11-Sep-80 18:03:27 by GRANT
;Change MONX01 to MONX02 in MAKIDX routine
; UPD ID= 659, SNARK:<5.MONITOR>FILINI.MAC.2,  16-Jun-80 17:23:07 by KONEN
;TCO 5.1063 -
;When mounting public structure, use structure name, rather than PS for alias
;<OSMAN.MON>FILINI.MAC.1, 10-Sep-79 15:29:13, EDIT BY OSMAN
;TCO 4.2412 - Move definition of BUGHLTs, BUGCHKs, and BUGINFs to BUGS.MAC
;<4.MONITOR>FILINI.MAC.15,  1-Sep-79 22:26:28, EDIT BY R.ACE
;RESTORE EFILIN
;<4.MONITOR>FILINI.MAC.14, 24-Aug-79 05:58:01, EDIT BY R.ACE
;TCO 4.2398 - NO MORE EFILIN
;<4.MONITOR>FILINI.MAC.13,  2-May-79 08:08:38, Edit by KONEN
;CHANGE JOB TO FORK IN SDBSTS IN INITING STRUCTURE
;<4.MONITOR>FILINI.MAC.12,  1-May-79 23:33:12, Edit by MCLEAN
;FIX SECTION GREATER THAN 37 BUGHLT FOR REBUILD OF ROOT-DIRECTORY
;<4.MONITOR>FILINI.MAC.11, 30-Apr-79 08:10:23, EDIT BY KIRSCHEN
;DO NOT PERMIT INTERRUPTS WITH SPACE ASSIGNED IN FILCRD
;<4.MONITOR>FILINI.MAC.10, 19-Mar-79 14:02:54, EDIT BY HALL
;MAKIDX/FNDIDX - GO NOINT WHILE WE HAVE JSB FREE SPACE
;<4.MONITOR>FILINI.MAC.9,  4-Mar-79 16:45:55, EDIT BY KONEN
;UPDATE COPYRIGHT FOR RELEASE 4
;<4.MONITOR>FILINI.MAC.8,  7-Feb-79 21:16:33, EDIT BY KIRSCHEN
;add ck2060 routine
;<4.MONITOR>FILINI.MAC.7, 18-Oct-78 16:28:52, EDIT BY MILLER
;FIX MAKIDX TO LOOK FOR DELETED COPY. ALWAYS UNDELETE FILE
;<4.MONITOR>FILINI.MAC.6, 19-Jul-78 23:21:29, Edit by MCLEAN
;INT DIRRDU
;<2MCLEAN>FILINI.MAC.5,  7-Jul-78 13:12:43, Edit by MCLEAN
;DIRECTORY CACHE LOCK INITILIZATION
;<4.MONITOR>FILINI.MAC.4, 20-Jun-78 01:33:00, EDIT BY BOSACK
;<4.MONITOR>FILINI.MAC.3, 19-Jun-78 21:52:44, EDIT BY BOSACK
;<1BOSACK>FILINI.MAC.1004, 19-Jun-78 17:18:04, EDIT BY BOSACK
;<1BOSACK>FILINI.MAC.1003, 15-Jun-78 22:10:59, EDIT BY BOSACK
;<1BOSACK>FILINI.MAC.1002,  5-Jun-78 21:35:38, EDIT BY BOSACK
;<1BOSACK>FILINI.MAC.1001,  5-Jun-78 20:45:44, EDIT BY BOSACK
;<1BOSACK>FILINI.ORG.4,  5-Jun-78 18:33:18, EDIT BY BOSACK
;<4.MONITOR>FILINI.MAC.1,  7-Mar-78 09:36:50, Edit by HURLEY
;CHANGE EXADRF TO EXADF


;THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY ONLY BE USED
;  OR COPIED IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
;COPYRIGHT (C) 1976,1977,1978,1979 BY DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.

	SEARCH PROLOG
   IFNDEF EXADF,<	TTITLE FILINI>
   IFDEF EXADF,< TTITLE FILINI,EFILIN>
	SWAPCD

;LOCAL ITEMS IN STG.MAC

PSNUM==:0			;STRUCTURE NUMBER (OFFSET IN STRTAB) FOR
				;THE PUBLIC STRUCTURE

EXTN <INIDEV>

ROOTDN==:1			;ROOT-DIRECTORY DIRECTORY NUMBER
SYSTDN==:2			;SYSTEM DIRECTORY NUMBER
SUBSDN==:3			;SUBSYS DIRECTORY NUMBER
ACNTDN==:4			;ACCOUNTS DIRECTORY NUMBER
OPERDN==:5			;OPERATOR DIRECTORY NUMBER
SPOLDN==:6			;SPOOL DIRECTORY NUMBER
NSYSDN==:7			;<NEW-SYSTEM>
NSUBDN==:10			;<NEW-SUBSYS>

NRESDN==:17			;NUMBER OF RESERVED DIR NUMBERS FOR DEC

;SPECIAL AC DEFINITIONS USED HEREIN

DEFAC (STS,P1)
DEFAC (JFN,P2)			;SEE GTJFN FOR FUNCTIONS
DEFAC (DEV,P4)
DEFAC (F1,P5)

RS BKOFN,1			;OFN OF BACKUP FILE DURING RECONSTRUCTION

; Initialize file stuff
;CALLED BY MEXEC WHEN A JOB IS STARTED.  INITIALIZES THE JSB

JBFINI::MOVEI A,JSFREE		; Origin of free area in jsb
	HRLOM A,JSBFRE		; To header
	MOVEI A,IJSFRE
	HRRZM A,JSFREE		; One big block free
	MOVEM A,JSBFRE+2
	SETOM JSBFRE+1
	MOVE A,[XWD JSFREE+IJSFRE,JSFREE]
	MOVEM A,JSBFRE+4
	MOVEI A,MAXLW+1
	MOVEM A,JSBFRE+3
	MOVE A,[XWD JBCOR,JBCOR+1]
	SETZM JBCOR
	BLT A,JBCOR+3
	UNLOCK JBCLCK
	UNLOCK JSFLCK		; INIT DEALL STACK LOCK
	UNLOCK JSSTLK		;INITIALIZE JSB STRUCTURE LOCK
	MOVEI C,FREJP		; Start with frejp page
IJFRLP:	MOVE A,C
	LSH A,9
	PUSH P,C
	CALL RELPAG
	POP P,C
	CAIGE C,JSLST-1
	AOJA C,IJFRLP
	SETOM PRIMRY		; Primary io to controlling tty
	SETOM JFNLCK		; Unlock jfnlck
	SETOM LNMLCK		; UNLOCK LOGICAL NAME LOCK
	MOVEI A,1
	MOVEM A,MAXJFN
	MOVE A,STRTAB+PSNUM	;GET SDB ADDRESS OF STRUCTURE 0 (PUBLIC)
	LOAD A,STRUC,(A)	;GET ITS UNIQUE STRUCTURE CODE
	STOR A,JSUC		;SAVE AS CONNECTED STRUCTURE CODE
	MOVEI A,SYSTDN		;GET DIRECTORY NUMBER FOR <SYSTEM>
	STOR A,JSDIR		;MAKE THIS THE CONNECTED DIRECTORY
	MOVE A,[[3
		 ASCIZ "OPERATOR"],,USRNAM]
	BLT A,USRNAM+2		;INIT USER NAME STRING
	MOVE A,[[3
		 ASCIZ "OPERATOR"],,ACCTSL]
	BLT A,ACCTSR+1		;INIT ACCT STRING
	SETZRO JSCDF		;MARK THAT THERE IS NO DIR STRING
	MOVE B,JOBNO
	SETZM JOBDIR(B)		;INDICATE NOT YET LOGGED IN
	MOVE A,[XWD 777000,-1]
	MOVEM A,CAPMSK
	MOVEM A,CAPENB

;INITIALIZE THE 3-WORD BLOCKS IN THE JSB FOR STRUCTURES.  THIS CODE MERELY
;SETS THE STRUCTURE NUMBER TO -1 TO INDICATE THE SLOT IS FREE.  GTSTOF
;INITIALIZES THE REST OF THE BLOCK WHEN IT IS ASSIGNED.

	MOVSI T1,-STRN
	HRRI T1,JSSTRT		;T1/(-COUNT,,ADDRESS OF WORD 0 OF BLOCK)
JBFIN1:	MOVX T2,JSFRST
	STOR T2,JSSTN,(T1)	;INITIALIZE STRUCTURE NUMBER TO -1
	ADDI T1,JSSTMX-1	;GO TO NEXT BLOCK OF WORDS
	AOBJN T1,JBFIN1		;..
	RET
;INITBT - BITTABLE INITILIZATION

;	CALL BTINIT

;RETURNS +1 ALWAYS
;R4 - INDEX INTO MMAP FOR BITTABLE ENTRIES FOR NON/EXTENDED BITTABLES
;
;THIS ROUTINE INITALIZES THE ADDRESSES FOR THE BITTABLE
;
	RESCD
INITBT::
   IFDEF EXADF,<
	SETOM EXADDR		;SET LARGE DIRECTORY
   >
   IFNDEF EXADF,<
	MOVEI T1,1		;SET NON/ZERO SECTION
	MOVEM T1,EXADDR>
	SKIPN EXADFL		;CHECK TO SEE IF EXAD MACHINE
	SETZM EXADDR		;NO PROTECT FROM ATTEMPT TO USE NONZERO SECTIONS
	MOVNI T4,<BTBMAX+777>/1000 ;NON EXTENDED
	HRLZS T4
	MOVEI T1,BTB		;FIND BASE OF BITTABLE FOR NON EX
	SKIPE EXADDR		;WHICH
	MOVE T1,[BTSEC,,0]	;EXTENDED
	MOVEM T1,BTBORA		;SET ORIGIN
	LSH T1,-PGSFT		;MAKE PAGE ADDRESS
	MOVEM T1,BTSTRT		;SAVE START
	HRR T4,T1		;SET PAGE NUMBER FOR RETURN
	ADDI T1,<BTBMAX-1>/1000	;SET END PAGE NUMBER
	MOVEM T1,BTEND		;SET END OF BITMAP
	MOVEI T1,BTBMAX		;BITTABLE MAX FOR NON/EXTENDED
   IFDEF EXADF,<
	SKIPGE EXADDR
	MOVEI T1,BTMXSZ		;EXTENDED
   >
	MOVEM T1,BTBSIZ		;SET SIZE
	RET
	SWAPCD
;FILINI - File system initialization

;	CALL FILINI

;RETURNS +1: ALWAYS

;THIS CODE IS CALLED BY JBI0 IN MEXEC AS PART OF SYSTEM STARTUP
;IF THE MONITOR WAS STARTED AT SYSGO1, STARTF IS 0
;IF IT WAS STARTED AT SYSLOD, STARTF HAS SOME COMBINATION OF THE FOLLOWING BITS SET:
;	MI%RFS IF THE USER REQUESTED REFRESHING THE FILE SYSTEM
;	MI%RCN IF THE USER DID NOT REQUEST REFRESH
;	MI%HMB IF THE HOME BLOCKS WERE REWRITTEN
;IF THE SYSTEM WAS STARTED AT SYSGO1, OR IF IT WAS STARTED AT SYSLOD,
;BUT ALL QUESTIONS WERE ANSWERED 'NO', STARTF IS 0

FILINI::STKVAR <FILINZ>
	UNLOCK DIRCLK		;INIT DIRECTORY CACHE LOCK
	CALL DEVINI		;INIT DEVICE TABLES
	MOVE T1,[DIRRDM]	;GET MASK
	MOVEM T1,DIRRDU		;SET DIRECTORY READ TIME UPDATE MASK
	MOVEI T1,<NIDXPG*PGSIZ>/.IDXLN	;MAXIMUM DIRECTORY NUMBER
   IFDEF EXADF,<
	SKIPGE EXADDR		;IF EXADDR -1 THEN LARGE DIRECTORY NUMBER LEGAL
	MOVEI T1,<MXDRNM*PGSIZ>/.IDXLN	;MAX LARGE DIRECTORY NUMBER
   >
	MOVEM T1,MXDIRN		;SET UP MAX DIRECTORY NUMBER
	MOVE A,[XWD MSEC1,DIRPGA] ;GET ADDRESS OF DIRECTORY MAPPING AREA
	SKIPE EXADDR		;IF EXADDR 0  THEN ALL SEC 0
	MOVE A,[DRSECN,,0]	;DIRECT SECTION (SEC DRSECN)
	MOVEM A,DIRORA		;INITIALIZE THE BASE ADDRESS WORD
	MOVEI A,DRMASZ		; MAGIC NUMBER OF DIRECTORY PAGES
   IFDEF EXADF,<
	SKIPGE EXADDR		;SET DIRECTORY SIZE 0=SEC 0 30PGS
				;1=SEC 1 SIZE 30 PGS -1=SEC1 777PGS
	MOVEI A,DRMXSZ
   >
	MOVEM A,NDIRPG
	MOVE A,[<30+^D35>/^D36+1] ;SET SIZE OF FREE BIT TABLE
   IFDEF EXADF,<
	SKIPGE EXADDR
	MOVE A,[<DRMXSZ+^D35>/^D36+1]
   >
	MOVEM A,FBTSIZ
	MOVE A,[EXP IDXPGA]		;GET ADDRESS OF INDEX TABLE
	SKIPE EXADDR		;CHECK FOR EXADDR HERE
	MOVE A,[IDXSEC,,0]	;SET IDX SECTION
	MOVEM A,IDXORA		;SET UP BASE OF INDEX TABLE
	UNLOCK LDTLCK		;INITIALIZE THE DIRECTORY LOCK TABLE
	SETZM FILINZ		;ASSUME NO NEED TO FIX FRONT END FILE SYSTEM
	SKIPN B,STARTF		;ZERO IF STARTED AT SYSGO1
	JRST FILIN1		;DIDN'T START AT SYSLOD. DO USUAL STARTUP

;STARTED THE MONITOR AT SYSLOD.  SEE WHAT THEY WANT TO DO

	TXNE B,MI%RFS		;DO WE WANT A FULL REFRESH?
	JRST FILRFS		;YES. GO DO IT
	TXNE B,MI%HMB		;NO. WERE THE HOME BLOCKS REWRITTEN?
	SETOM FILINZ		;YES. INDICATE POINTER TO FRONT END FILE SYSTEM
				; HAS BEEN CLOBBERED

;NOT REFRESHING. SEE IF RECONSTRUCTING ROOT-DIRECTORY

	HRROI A,[ASCIZ /RECONSTRUCT ROOT-DIRECTORY? /]
	PSOUT
	CALL YESNO		;SEE IF RECONSTRUCTING
	JUMPN A, [	MOVEI A,PSNUM	;YES. A/STRUCTURE NUMBER FOR PS
			CALL FILREC	;GO DO RECONSTRUCTION
			 BUG(BADREC)
			HRROI A,RCDMSG	;GET POINTER TO ADVISORY MESSAGE
			PSOUT		;INFORM USER EVERYTHING OK SO FAR
			MOVX B,MI%BTB	;INDICATE REBUILD BIT TABLE
			IORM B,STARTF	; FOR MEXEC TO SEE LATER
			JRST FILIN1]	;THEN PROCEED NORMALLY

;IF EXPANDING A STRUCTURE WITHOUT REFRESHING, ANSWER TO NEXT QUESTION
;SHOULD BE YES

	MOVX A,MI%RCN		;NOT RECONSTRUCTING. CLEAR THE BIT
	ANDCAM A,STARTF		; IN STARTF (SET BY FSSINI)
	HRROI A,[ASCIZ/REBUILD BIT TABLE? /]
	PSOUT			;ASK ABOUT BIT TABLE
	CALL YESNO		;GET THE ANSWER
	JUMPN A,[MOVX B,MI%BTB	;INDICATE REBUILD BIT TABLE
		IORM B,STARTF	; FOR MEXEC TO SEE LATER
		JRST FILIN1]	;THEN PROCEED NORMALLY

;USER DIDN'T WANT TO REFRESH, RECONSTRUCT, OR REBUILD. ASSUME NORMAL STARTUP

	SETZM STARTF		;ACT AS IF NOTHING HAD HAPPENED
	HRROI A,[ASCIZ /NORMAL STARTUP ASSUMED.
/]
	PSOUT

; Make directory and index known to system

FILIN1:
	MOVEI A,PSNUM		;A/STRUCTURE NUMBER FOR PS
	CALL SETRDO		;SET UP ROOT-DIRECTORY OFN
	 BUG(IBOFNF)
	MOVEI A,PSNUM		;A/STRUCTURE NUMBER FOR PS
	SKIPN B,STRTAB(A)	;GET SDB ADDRESS FOR THIS STRUCTURE
	JRST FILERR		;PS MUST BE DEFINED
	CALL INISTR		;GO SET UP DEVNAM, ETC.
	MOVEI T1,PSNUM		;T1/STRUCTURE NUMBER FOR PS
	CALL MNTBTB		;GET AN OFN ON THE BIT TABLE FILE
	 JRST [	BUG(NOBTB)
		MOVX T4,SF%BTE!SF%CDE ;FAILED. INDICATE BIT TABLE ERRORS
		IORM T4,FACTSW	;SO THAT SYSJOB WON'T START
		MOVEI T1,PSNUM	;T1/STRUCTURE NUMBER FOR PS
		CALL CRTBTB	;INITIALIZE A PRIVATE COPY OF THE BIT
				; TABLE SO WE CAN RUN
		 BUG(BTBCR1)
		MOVEI T1,PSNUM	;GET STRUCTURE NUMBER FOR PS
		HRRZ T2,STRTAB(T1) ;POINT TO ITS SDB
		MOVX T4,MI%ASG	;FORBID ASSIGNING PAGES UNTIL CHECKD CAN
		IORM T4,SDBSTS(T2) ; RUN AND REBUILD THE BIT TABLE
		ADDI T1,DVXST0	;POINT TO THIS STRUCTURE IN DEVICE TABLES
		MOVX T4,D1%INI	;CLEAR THE 'INI' BIT ON THE ASSUMPTION
		ANDCAM T4,DEVCH1(T1) ; THAT CHECKD WILL REBUILD THE BIT TABLE
		JRST .+1]
	MOVEI T1,PSNUM		;T1/STRUCTURE NUMBER FOR PS
	CALL FNDIDX		;GET OFN FOR INDEX TABLE
	 JRST [	MOVEI T1,PSNUM	;FAILED.T1/ STRUCTURE NUMBER FOR PS
		CALL MAKIDX	;NOT THERE, MAKE A NEW ONE
		 BUG(BADXT1)
		BUG(BADXT2)
		MOVX A,MI%XTB	;INDICATE NEEDS TO BE INITIALIZED LATER
		IORM A,STARTF
		MOVX A,SF%BTE	;FORCE CHECKD TO BE RUN BEFORE
		IORM A,FACTSW	; SYSTEM COMES UP FOR TIME-SHARING
		JRST .+1]
	JRST FILIN2		;PROCEED TO COMMON CODE
;FILRFS - HERE WHEN REFRESHING FILE SYSTEM

FILRFS:	SE1ENT
	MOVEI A,PSNUM		;A/STRUCTURE NUMBER
	SKIPN B,STRTAB(A)	;B/ADDRESS OF SDB
	JRST FILERR		;PS MUST BE DEFINED
	CALL INISTR		;SET UP DEVNAM, INDICATE BEING INITED
	MOVEI A,PSNUM		;A/STRUCTURE NUMBER
	CALL CRTBTB		;INITIALIZE A BIT TABLE IN CORE
	 BUG(BTBCRT)

;CREATE INDEX BLOCK FOR PRIMARY COPY OF ROOT-DIRECTORY

	MOVE A,DIDSCI		;GET INITIAL INDEX BLOCK ADR FOR ROOT
	MOVEI B,PSNUM		;B/STRUCTURE NUMBER
	CALL NEWIB		;GET THE INDEX BLOCK FOR THE ROOT DIR
	 BUG(NEWROT)
	MOVE C,STRTAB+PSNUM	;GET ADDRESS OF SDB
	STOR A,STRRDO,(C)	;REMEMBER THE OFN OF THE ROOT-DIR INDEX BLOCK

;CREATE INDEX BLOCK FOR BACKUP COPY OF ROOT-DIRECTORY

	MOVE A,DIDSCJ		;GET AN OFN FOR BACKUP FILE ALSO
	MOVEI B,PSNUM		;B/STRUCTURE NUMBER
	CALL NEWIB		;SO BACKUP FILE STARTS IN A KNOWN SPOT
	 BUG(NEWBAK)
	MOVEM A,BKOFN		;SAVE ITS OFN

;SET UP THE INDEX TABLE FOR ROOT-DIRECTORY. THIS CODE MAKES A TEMPORARY
;COPY OF IDXTAB IN JSB FREE SPACE IN ORDER TO CREATE THE FIRST FEW
;DIRECTORIES ON THE SYSTEM.  IDXORA POINTS TO THAT FREE SPACE TEMPORARILY.

	PUSH P,IDXORA		;SAVE THE OLD IDXTAB ORIGIN
	CALL ASGPAG		;GET PAGE TO PUT TEMPORARY IDXTAB INTO
	 BUG(IDXNOS)
	MOVEM A,IDXORA		;SAVE THE ADDRESS FOUND

;PUT AN ENTRY FOR ROOT-DIRECTORY IN THE TEMPORARY IDXTAB, AND INITIALIZE
;THE DIRECTORY

	MOVEI A,ROOTDN		;NOW SET UP THE INDEX TABLE 
	MOVEI B,0		;DONT HAVE AN FDB ADDRESS YET
	MOVE C,DIDSCI		;GET DISK ADR OF INDEX BLOCK
	MOVEI D,ROOTDN		;SETUP SUPERIOR AS ROOT DIRECTORY
	CALL SETIDX		;SETUP THE INDEX TABLE FOR THE ROOT DIR
	 BUG(FILRID)
	MOVEI A,ROOTDN		;NOW INITIALIZE THE DIRECTORY FILE
	MOVEI B,PSNUM		;ASSUME THE PUBLIC STRUCTURE
	CALL DIRINI		; TO LOOK LIKE A DIRECTORY (SETS UP HEADER)
INIROT:	 BUG(FILIRD)

;CREATE A FEW SPECIAL DIRECTORIES

	MOVEI A,PSNUM		;A/STRUCTURE NUMBER FOR PS
	CALL FILCRD		;GO CREATE ALL THE DIRECTORIES
	MOVE A,BKOFN		;A/OFN OF BACKUP FILE
	CALL RELOFN		;RELEASE OFN OF BACKUP FILE
	SETZM BKOFN
	MOVEI A,PSNUM		;A/STRUCTURE NUMBER FOR PS

;CREATE A BIT TABLE FILE AND COPY THE TEMPORARY ONE INTO IT.  

	CALL WRTBTB		;GO CREATE BIT TABLE FILE
	 JRST [	CAIE T1,MSTRX6	;DID HOME BLOCK WRITE FAIL?
		 BUG(FILBTB)
		BUG(FILHOM)
		JRST .+1]	;THIS ISN'T FATAL UNLESS OLD STYLE HOME BLOCKS

;CREATE A PERMANENT IDXTAB FILE AND MAKE IDXORA POINT TO THE STANDARD
;PLACE IN THE MONITOR MAP.  RELEASE THE JSB FREE SPACE

	MOVEI A,PSNUM		;GET NUMBER OF THE PUBLIC STRUCTURE
	CALL MAKIDX		;GO CREATE INDEX FILE
	 JRST IDXBAD		;COULD NOT SET UP INDEX TABLE FILE
	MOVX T1,MI%XTB		;INDICATE INDEX TABLE MUST BE INITIALIZED
	IORM T1,STARTF		; FOR COMMON CODE TO SEE LATER
	MOVEI A,JSBFRE		;RELEASE THE IDXTAB PAGE
	MOVE A,IDXORA		;GET THE ADDRESS
	CALL RELPAG		;RELEASE FREE PAGE
	POP P,IDXORA		;RESTORE THE IDXTABLE ADDRESS

;CREATE THE FRONT END FILE SYSTEM

	SE0ENT
	MOVEI A,PSNUM		;GET NUMBER OF PUBLIC STRUCTURE
	SKIPGE T2,FEFSIZ	;SEE IF FE FILE SYSTEM SIZE WAS GIVEN
	JRST [	MOVEI T1,PSNUM	;NO. T1/STRUCTURE NUMBER FOR PS
		CALL GTFESZ	;GET THE SIZE FROM THE HOME BLOCKS
		 BUG(NOFEFS)
		MOVE T2,T1	;T2/NUMBER PAGES IN FE FILE SYSTEM
		JRST .+1]
	MOVEI T1,PSNUM		;T1/STRUCTURE NUMBER
	CALL FEFSYS		;CREATE A FRONT END FILE SYSTEM
	 BUG(FILFEF)

;CREATE BOOTSTRAP.BIN

	MOVEI T1,PSNUM		;GET NUMBER OF PUBLIC STRUCTURE
	SKIPGE T2,BOTSIZ	;SEE IF BOOTSTRAP.BIN WAS GIVEN
	JRST [	MOVEI T1,PSNUM	;NO. T1/STRUCTURE NUMBER FOR PS
		CALL GTBTSZ	;GET THE SIZE FROM THE HOME BLOCKS
		BUG(NOBTBN)
		MOVE T2,T1	;T2/NUMBER OF PAGES IN BOOTSTRAP.BIN
		JRST .+1]
	CALL BOTSYS		;CREATE A BOOTSTRAP.BIN FILE
	BUG(FILBOT)

;UPDATE THE DISK FOR ROOT-DIRECTORY

	MOVE T1,STRTAB+PSNUM	;GET SDB FOR PS
	LOAD T1,STRRDO,(T1)	;GET OFN ON <ROOT-DIRECTORY>
	HRLZS T1		;OFN,,0
	MOVEI T2,1000		;ALL PAGES
	CALL UPDPGS		;UPDATE ON DISK
	MOVE T1,STRTAB+PSNUM	;GET SDB AGAIN
	LOAD T1,STRRDO,(T1)	; OFN
	CALL UPDOFN		;UPDATE OFN ALSO
	;..
;HERE FOR NORMAL STARTUP OR WHEN INITIALIZATION IS COMPLETE

	;..
FILIN2:	SKIPN B,STRTAB+PSNUM	;GET SDB ADDRESS FOR PS
	JRST FILERR		;PS MUST BE DEFINED
	MOVEI A,ROOTDN		;NOW CHECK ROOT-DIR
	LOAD C,STRUC,(B)	;GET UNIQUE CODE
	HRL A,C			;A/UNIQUE CODE,,DIRECTORY
	CALL SETDIR		;MAP IN ROOT-DIR AND LOCK IT
	 BUG(FILMAP)
	CALL BLKSCN		;MAKE SURE IT IS VALID
	 BUG(BADROT)
	CALL USTDIR		;UPDATE AND UNLOCK THE DIR
	MOVE B,STARTF		;GET STARTUP FLAGS
	TXZE B,MI%XTB		;DO WE NEED TO INIT INDEX TABLE?
	JRST [	MOVEI A,PSNUM	;YES. A/ NUMBER OF PS
		CALL IDXINI	;INITIALIZE IT
		 JRST IDXBAD
		JRST .+1]

	CALL ISDIRT		;INIT SPECIAL DIR TABLE
	CALL INIDEV		;INITIALIZE DEVICE DRIVERS
	CALL ENQINI		;INITIALIZE THE ENQ/DEQ DATA BASE
	CALL SNPINI		;INITIALIZE THE SNOOP DATA BASE
	CALL NETINI		;INITIALIZE THE ARPANET STORAGE


	MOVX T3,MI%BTB		;DON'T CHECK BIT TABLE IF REBUILDING
	TDNE T3,STARTF
	JRST FILIN3
	MOVE T1,STRTAB+PSNUM	;GET POINTER TO SDB FOR PS
	MOVX T3,MI%ASG		;IF ASSIGNMENTS ARE PROHIBITED, BIT TABLE
	TDNE T3,SDBSTS(T1)	; DOESN'T EXIST. DON'T TRY TO CHECK IT
	JRST FILIN3		;OR CHECK THE ROOT-DIRECT ORY BACKUP
	MOVEI T1,PSNUM		;T1/STRUCTURE NUMBER
	MOVX T2,MI%MSG		;T2/REQUEST MESSAGES ON CONSOLE
	CALL CHKBT		;CHECK CONSISTENCY OF BIT TABLE AND FIX IT
	 JRST [	MOVX T3,SF%BTE	;FAILED. INDICATE BIT TABLE ERRORS ON PS
		IORM T3,FACTSW	; FOR MEXEC TO SEE LATER
		JRST .+1] 	; AND THEN PROCEED NORMALLY
	MOVX T3,MI%RCN		;DON'T CHECK THE BACKUP IF RECONSTRUCTING
	TDNN T3,STARTF		; (FILREC DELETED IT)
	JRST [	MOVEI T1,PSNUM	;T1/STRUCTURE NUMBER FOR PS
		CALL CHKBAK	;CHECK BACKUP OF ROOT-DIRECTORY
		 BUG(BADBAK)
		JRST .+1]
FILIN3:
	SKIPE FILINZ		;DID WE REWRITE HOME BLOCKS?
	JRST [	MOVEI A,PSNUM	;A/STRUCTURE NUMBER FOR PS
		CALL FIXFES	;YES. PUT POINTER TO FE FILE SYSTEM BACK IN
		 BUG(FIXBAD)
		JRST .+1]	; HOME BLOCKS
	SKIPE FILINZ		;DID WE REWRITE HOME BLOCKS?
	JRST [	MOVEI A,PSNUM	;A/STRUCTURE NUMBER FOR PS
		CALL FIXBOT	;YES -- PUT POINTER TO BOOT FILE BACK
		BUG(FIXBDB)
		JRST .+1]
	MOVEI A,PSNUM		;A/STRUCTURE NUMBER FOR PS
	SKIPN STRTAB(A)		;IS THERE AN ENTRY FOR PS?
	JRST FILERR		;PS MUST BE DEFINED
	CALL FRESTR		;GO CLEAR SLOT IN DEVNAM, ETC.
	RET

FILERR:	BUG(STZERO)
	RET

IDXBAD:	 BUG(BADXTB)


;ROUTINE TO CREATE ALL THE STANDARD DIRECTORIES

;ACCEPTS:
;	T1/STRUCTURE NUMBER

;	CALL FILCRD

;RETURNS +1:	ALWAYS

;CALLED DURING REFRESH ONLY

BLKSIZ==<.CDDGP+1>+<MAXLW+2>	;SPACE FOR CRDIR BLOCK+DEV:<DIR> STRING

FILCRD::SAVEQ			;PRESERVE SOME ACCUMULATORS
	MOVEM A,Q3		;SAVE STRUCTURE NUMBER
	NOINT			;NO INTERRUPTIONS WITH SPACE ASSIGNED
	MOVEI B,BLKSIZ		;ASSIGN SPACE FOR CRDIR BLOCK AND DIR STRING
	CALL ASGJFR		;USE JSB FREE SPACE
	 JRST [	BUG(FILJB1)
		OKINT		;PERMIT INTERRUPTS AGAIN
		RET ]		;RETURN
	MOVEI Q2,1(A)		;SAVE ADDRESS OF CRDIR BLOCK
	MOVSI Q1,-CRDTBL	;SET UP AOBJN COUNTER
FILCR1:	HRROI A,[ASCIZ/DEC-20/]	;GET DEFAULT PASSWORD
	MOVEM A,.CDPSW(Q2)	;SET UP PARAMETER BLOCK FOR CRDIR
	MOVX A,SC%OPR!SC%IPC	;MAKE THE DIR BE OPERATOR AND IPCF
	MOVEM A,.CDPRV(Q2)	;ONLY FOR DIR'S THAT ARE NOT FILES-ONLY
	MOVX A,MD%FO		;SET UP FOR FILES-ONLY DIRECTORIES
	MOVEM A,.CDMOD(Q2)	;ONLY SET ID CD%MOD IS SET
	HRLZI A,377777		;SET INFINITY FOR THOSE DIRS
	MOVEM A,.CDLIQ(Q2)	; WITH QUOTAS
	MOVEM A,.CDLOQ(Q2)	; ...
	HRROI A,.CDDGP+1(Q2)	;GET DESTINATION FOR COMPLETE STRING
	MOVE B,Q3		;GET STRUCTURE NUMBER
	HRRO C,CRDTAB(Q1)	;GET POINTER TO DIRECTORY NAME
	CALL STRST		;FORM COMPLETE DIRECTORY STRING (INCLUDING STR)
	 JRST [	BUG(FILCCD)
		JRST FILCR3 ]	;GO ON TO NEXT DIRECTORY
	MOVEI A,1(Q1)		;GET DIRECTORY NUMBER BEING SET
	MOVEM A,.CDNUM(Q2)
	MOVE B,STRTAB(Q3)	;GET ADDRESS OF SDB FOR THIS STRUCTURE
	CAIE A,ROOTDN		;CREATING ROOT-DIRECTORY ?
	JRST FILCR2		;NO, GO ON
	SETONE STCRD,(B)	;YES, NOTE ROOT-DIRECTORY BEING CREATED
FILCR2:	MOVEI A,SYSDPT		;GET PROTECTION OF SYSTEM AND SUBSYS
	MOVEM A,.CDDPT(Q2)	;SET UP PROTECTION WORD
	MOVEI A,SYSFPT		;GET FILE PROTECTION OF SYSTEM AND SUBSYS
	MOVEM A,.CDFPT(Q2)
	SETZM .CDRET(Q2)	;SET RETENTION COUNT TO 0
	HRROI A,.CDDGP+1(Q2)	;GET POINTER TO DIRECTORY NAME
	HLLZ B,CRDTAB(Q1)	;GET FLAGS FOR THIS DIR
	HRR B,Q2		;GET ADDRESS OF PARAMETER BLOCK
	CRDIR			;CREATE THE DIR
	HRRZ A,A		;GET THE DIRECTORY NUMBER
	CAIN A,ROOTDN		;WAS ROOT-DIR JUST CREATED?
	JRST [	MOVE B,STRTAB(Q3) ;GET ADDRESS OF SDB
		SETZRO STCRD,(B) ;ROOT-DIRECTORY NO LONGER BEING CREATED
		MOVE A,Q3	;GET STRUCTURE NUMBER
		CALL CREBAK	;GO CREAtE BACKUP FILE
		 BUG(FILBAK)
		JRST .+1]
FILCR3:	AOBJN Q1,FILCR1		;LOOP BACK UNTIL ALL DIR'S ARE CREATED
	MOVEI A,JSBFRE		;NOW RETURN THE SPACE TO THE JSB
	MOVEI B,-1(Q2)		;GET ADDRESS OF FREE BLOCK
	CALL RELFRE		;RELEASE THE SPACE AND RETURN
	OKINT			;PERMIT INTERRUPTS AGAIN
	RET			;RETURN

CRDTAB:	CD%MOD!CD%NUM!CD%LIQ!CD%LOQ+[ASCIZ/<ROOT-DIRECTORY>/]
	CD%RET!CD%FPT!CD%DPT!CD%MOD!CD%NUM!CD%LIQ!CD%LOQ+[ASCIZ/<SYSTEM>/]
	CD%FPT!CD%DPT!CD%MOD!CD%NUM!CD%LIQ!CD%LOQ+[ASCIZ/<SUBSYS>/]
	CD%RET!CD%MOD!CD%NUM!CD%LIQ!CD%LOQ+[ASCIZ/<ACCOUNTS>/]
	CD%PSW!CD%PRV!CD%NUM+[ASCIZ/<OPERATOR>/]
	CD%RET!CD%MOD!CD%NUM!CD%LIQ!CD%LOQ+[ASCIZ/<SPOOL>/]
	CD%RET!CD%FPT!CD%DPT!CD%MOD!CD%NUM!CD%LIQ!CD%LOQ+[ASCIZ/<NEW-SYSTEM>/]
	CD%FPT!CD%DPT!CD%MOD!CD%NUM!CD%LIQ!CD%LOQ+[ASCIZ/<NEW-SUBSYS>/]
	CD%FPT!CD%DPT!CD%MOD!CD%NUM!CD%LIQ!CD%LOQ!CD%RET+[ASCIZ/<SYSTEM-ERROR>/]
CRDTBL==.-CRDTAB

;ROUTINE TO CREATE THE BACKUP FILE TO HOLD A COPY OF THE ROOT-DIR
;ACCEPTS IN A/	STRUCTURE NUMBER
;	CALL CREBAK
;RETURNS +1:	FAILED
;	 +2:	OK

;CALLED DURING REFRESH ONLY

CREBAK:	ASUBR <CREBKS,CREBKJ,CREBLK>
	MOVEI B,^D15		;GET ENOUGH SPACE FOR NAME OF BACKUP FILE
	CALL ASGJFR		;GO ASSIGN JSB FREE SPACE
	 RETBAD			;FAILED
	MOVEM A,CREBLK		;SAVE ADDRESS OF BLOCK
	HRROI A,1(A)		;FORM POINTER TO WHERE NAME WILL GO
	MOVE B,CREBKS		;GET STRUCTURE NUMBER
	HRROI C,[ASCIZ/<ROOT-DIRECTORY>BACKUP-COPY-OF-ROOT-DIRECTORY.IMAGE;P770000/]
	CALL STRST		;FORM COMPLETE FILE NAME
	 JRST CREBK1		;FAILED, GO RELEASE SPACE AND RETURN
	MOVX A,GJ%NEW+GJ%PHY+GJ%SHT
	HRRZ B,CREBLK		;GET ADDRESS OF FREE BLOCK
	HRROI B,1(B)		;FORM POINTER TO FILE NAME
	GTJFN			;CREATE BACKUP FILE
	 JRST CREBK1		;FAILED, RELEASE SPACE AND RETURN
	MOVEM A,CREBKJ		;SAVE JFN
	HRRZ JFN,A		;NOW MAP IN FDB
	IMULI JFN,MLJFN
	MOVE STS,FILSTS(JFN)
	HRRI DEV,DSKDTB
	HRL DEV,CREBKS		;GET STRUCTURE NUMBER
	SE1CAL
	CALL GETFDB
	 JRST [	MOVE A,CREBKJ	;COULD NOT GET FDB
		RLJFN		;RELEASE JFN
		 JFCL
		JRST CREBK1 ]	;GO RELEASE SPACE AND RETURN
	MOVE B,CREBKS		;GET STRUCTURE NUMBER
	MOVE B,STRTAB(B)	;GET ADDRESS OF SDB
	LOAD B,STRBXB,(B)	;GET ADDRESS OF INDEX BLOCK
	STOR B,FBADR,(A)	;PLUNK IN THE DISK ADR (MAGIC)
	SETZRO FBNXF,(A)	;FILE NOW EXISTS
	SETONE <FBNOD,FBDIR>,(A) ;THIS FILE IS NOT TO BE DUMPED
				;MAKE IT SO THE FILE CANNOT BE DELETED
				;BY SETTING THE FBDIR BIT
	CALL USTDIR		;UNLOCK DIR
	MOVE A,CREBKJ		;GET BACK JFN
	RLJFN			;RELEASE THE JFN
	 JFCL
	MOVEI A,JSBFRE		;GET FREE HEADER
	MOVE B,CREBLK		;GET ADDRESS OF FREE BLOCK
	CALL RELFRE		;RELEASE FREE BLOCK
	RETSKP			;GIVE OK RETURN

; HERE ON ERRORS TO RELEASE SPACE AND GIVE FAIL RETURN

CREBK1:	MOVEI A,JSBFRE		;GET FREE HEADER
	MOVE B,CREBLK		;GET ADDRESS OF FREE BLOCK
	CALLRET RELFRE		;RELEASE SPACE AND GIVE FAIL RETURN
;INISTR - INITIALIZE STRUCTURE

;ACCEPTS:
;	A/STRUCTURE NUMBER
;	B/START OF SDB

;RETURNS +1: ALWAYS

;CALLED WHEN A STRUCTURE IS MOUNTED BUT IS NOT YET GENERALLY AVAILABLE.
;THE CALLING FORK IS GIVEN CONTROL OF THE STRUCTURE UNTIL FRESTR
;IS CALLED. THE RIGHT HALF OF SDBSTS HOLDS THE FORK NUMBER
;ALSO, CLEARS D1%NIU IN DVCH1 TO INDICATE SLOT HAS A REAL STRUCTURE

INISTR:
	SAVET
	HRRZ A,A		;GET STRUCTURE NUMBER
	MOVEI C,DVXST0		;GET START OF STRUCTURES IN DEVXXX
	ADD C,A			;GET DEVXXX INDEX FOR THIS UNIT
	MOVE D,SDBNAM(B)	;GET STRUCTURE NAME FROM SDB
	MOVEM D,DEVNAM(C)	; AND STORE IN DEVNAM
	MOVX D,D1%INI		;INDICATE STRUCTURE BEING INITED
	IORM D,DEVCH1(C)
	MOVX D,D1%NIU		;CLEAR INDICATOR THAT SLOT IS NOT IN
	ANDCAM D,DEVCH1(C)	; USE
	MOVE D,FORKX		;GET CURRENT FORK
	STOR D,STRJB,(B)	;INDICATE IT IS THE INITING FORK
				; AND THUS THE ONLY LEGAL USER WHILE
				; D1%INI IS SET
	RET


;FRESTR - FREE A STRUCTURE

;ACCEPTS:
;	T1/STRUCTURE NUMBER

;	CALL FRESTR

;RETURNS +1: ALWAYS

;MAKES A STRUCTURE AVAILABLE FOR GENERAL USE

FRESTR::
	SAVET
	HRRZ A,A
	MOVEI C,DVXST0
	ADD C,A
	MOVX D,D1%INI		;INDICATE NOT BEING INITIALIZED
	ANDCAM D,DEVCH1(C)
	HRROS DEVUNT(C)		;INDICATE AVAILABLE TO ALL JOBS
	RET
;SET UP OFN OF ROOT-DIRECTORY FOR A STRUCTURE
;
; CALL:
;	ACCEPTS IN T1/	STRUCTURE #
;		CALL SETRDO
; RETURNS: +1	 ERROR
;	   +2	SUCCESS

;CALLED DURING NORMAL STARTUP ONLY

SETRDO::STKVAR <STRDOS>		;ALLOCATE SPACE FOR SDB ADDRESS
	MOVE T2,T1		;COPY STRUCTURE NUMBER
	SKIPN T1,STRTAB(T2)	;IS THERE AN SDB FOR THIS STRUCTURE ?
	RET			;NO, ERROR
	MOVEM T1,STRDOS		;YES, SAVE ADDRESS OF SDB
	LOAD T1,STRRXB,(T1)	;GET DISK ADDRESS OF XB FOR ROOT-DIRECTORY
	TXO T1,FILWB+THAWB	;GET ACCESS BITS
	CALL ASROFN		;GET AN OFN FOR THE ROOT-DIRECTORY
	 RET			;ERROR, RETURN
	MOVE T2,STRDOS		;GET BACK ADDRESS OF SDB
	STOR T1,STRRDO,(T2)	;STORE OFN FOR ROOT-DIRECTORY IN SDB
	RETSKP			;RETURN SUCCESS
;INIT SPECIAL DIRECTORY TABLE WITH ACTUAL DIRNUMS.
;	CALL ISDIRT
; RETURNS +1 ALWAYS

;CALLED FROM COMMON CODE

ISDIRT:	SAVEQ
	MOVNI Q1,NSDIR0		;GET NEG OF LENGTH OF INITIAL TABLE
	MOVSI Q1,0(Q1)		;SETUP AS AOBJN PTR
	SETZM NSDIRT		;INIT COUNT OF ENTRIES IN RUNTIME TABLE
ISDIR1:	HRRZ B,SDIRT0(Q1)	;GET LOC OF DIR NAME STRING
	HRLI B,(POINT 7,0)
	ILDB A,B		;COUNT CHARS IN NAME
	JUMPN A,.-1		;SCANNING UNTIL NULL
	HRRZ A,SDIRT0(Q1)	;CONSTRUCT LOOKUP PTR FOR CALL
	MOVEI A,-1(A)		;RH OF LOOKUP PTR IS ADR-1
	SUBM A,B		;COMPUTE NEG # OF WORDS IN NAME STRING
	HRLI A,1(B)		;LH OF LOOKUP PTR IS -(NWORDS-1)
	MOVE Q2,A		;SAVE A
	MOVEI A,PSNUM		;THIS FEATURE IS FOR PS ONLY
	CALL STRCNV		;GET UNIQUE CODE
	 JRST ISDIR2		;FAILED, SKIP THIS ONE
	HRRZ B,A		;GET UNIQUE CODE
	MOVE A,Q2		;GET BACK ADDRESS OF STRING BLOCK
	CALL DIRLKX		;LOOKUP THIS DIRECTORY THE USUAL WAY
	 JRST ISDIR2		;FAILED, IGNORE IT
	MOVM B,NSDIRT		;GET INDEX TO NEXT FREE ENTRY IN SDIRTB
	HRLM A,SDIRTB(B)	;SUCCESS, SAVE DIRNUM IN TABLE
	HRRZ A,SDIRT0(Q1)
	HRRM A,SDIRTB(B)	;SAVE STRING ADR IN TABLE
	SOS NSDIRT		;UPDATE NEG COUNT OF ENTRIES IN TABLE
ISDIR2:	AOBJN Q1,ISDIR1		;DO ALL DIRS
	RET
;FILREC - RECONSTRUCT ROOT-DIRECTORY

;ACCEPTS:
;	A/STRUCTURE NUMBER

;	CALL FILREC

;RETURNS +1:ALWAYS

;ROUTINE TO RECONSTRUCT THE ROOT-DIRECTORY
;THIS IS DONE BY COPYING THE INDEX BLOCK OF THE BACKUP ROOT-DIR
;INTO THE INDEX BLOCK FOR THE ROOT-DIRECTORY
;AFTER COPYING THE BACKUP INDEX BLOCK, THE ROOT-DIR SHOULD BE INTACT
;THE BACKUP INDEX BLOCK IS ZEROED

;NOTE: A NEW BACKUP FILE IS NOT MADE HERE; THE NEXT CALL TO CPYBAK 
;WILL CREATE IT. THIS EXITS WITHOUT AN OFN FOR ROOT-DIRECTORY. THE CALLER MUST
;ASSIGN THE OFN

FILREC::STKVAR <STRN02,FILRER,FILREB,FILREO>
	MOVEM A,STRN02		;SAVE STRUCTURE NUMBER
	MOVE A,STRTAB(A)	;GET ADDRESS OF SDB
	LOAD A,STRBXB,(A)	;GET ADDRESS OF XB FOR BACKUP FILE
	TLO A,(FILWB+THAWB)	;OPEN FOR WRITE AND THAWED
	MOVE B,STRN02		;B/STRUCTURE NUMBER
	CALL ASROFN		;GET AN OFN FOR BACKUP FILE
	 RETBAD ()		;FAILED, RETURN
	MOVEM A,BKOFN		;SAVE THE OFN FOR THE BACKUP FILE
	MOVE A,DIDSCI		;GET ADR OF ROOT-DIR
	TLO A,(FILWB+FILNB+THAWB)
	MOVE B,STRN02		;B/STRUCTURE NUMBER
	CALL ASROFN		;GET AN OFN FOR ROOT-DIR
	 JRST FLRER1		;FAILED, GO RELEASE BACKUP FILE OFN AND RETURN
	MOVEM A,FILREO		;SAVE THE OFN
	MOVE B,STRN02		;GET STRUCTURE NUMBER
	MOVE B,STRTAB(B)	;GET ADDRESS OF SDB
	STOR A,STRRDO,(B)	;SAVE OFN OF ROOT-DIRECTORY
	CALL ASGPAG		;GET A PAGE TO MAP ROOT-DIR INTO
	 JRST FLRER2		;FAILED, RELEASE OFN'S AND RETURN ERROR
	MOVEM A,FILRER		;SAVE ADDRESS
	MOVE B,A		;NOW MAP IN THE IB OF THE ROOT
	TLO B,(PTRW)		;READ WRITE
	MOVE A,FILREO		;GET THE OFN
	CALL SETMPG
	CALL ASGPAG		;NOW GET A PAGE FOR THE BACKUP IB
	 JRST FLRER3		;FAILED, CLEAN UP AND RETURN ERROR
	MOVEM A,FILREB		;SAVE ADDRESS OF PAGE
	MOVE B,A		;MAP IN IB OF BACKUP FILE
	TLO B,(PTRW)
	MOVE A,BKOFN		;GET OFN
	CALL SETMPG		;MAP IN IB
	MOVE A,FILREB		;SEE IF THERE IS A BACKUP FILE
	SKIPN 0(A)		;PAGE 0 MUST BE THERE
	JRST FLRER4		;NO PAGE 0, CLEAN UP AND RETURN ERROR
	HRL A,FILREB		;GET SOURCE ADR
	HRR A,FILRER		;GET DESTINATION ADR
	MOVEI B,777(A)		;GET FINAL ADR
	BLT A,0(B)		;COPY BACKUP IB TO ROOT-DIR IB
	HRRZ A,FILREB
	SETZM 0(A)		;ZERO FIRST WORD
	HRL A,FILREB		;NOW ZERO BACKUP IB
	MOVEI B,777(A)		;GET FINAL ADR
	HRRI A,1(A)		;GET DESTINATION ADR
	BLT A,0(B)		;ZERO THE IB
	MOVE A,FILREO		;NOW CAUSE THE OFN TO BE WRITTEN OUT
	MOVX B,OFNWRB		;GUARANTEE IT WILL BE WRITTEN
	IORM B,SPTH(A)		;...
	CALL UPDOFN		;WRITE OFN TO DISK
	MOVE A,BKOFN		;DO THE SAME FOR BACKUP OFN
	MOVX B,OFNWRB
	IORM B,SPTH(A)
	CALL UPDOFN
	MOVEI A,0		;NOW UNMAP THE TEMP PAGES
	MOVE B,FILRER
	CALL SETMPG
	MOVEI A,0
	MOVE B,FILREB
	CALL SETMPG
	MOVE A,FILRER		;AND RELEASE THE TEMP PAGES
	CALL RELPAG
	MOVE A,FILREB
	CALL RELPAG
	MOVE A,BKOFN		;RELEASE THE OFN OF BACKUP FILE
	CALL RELOFN
	MOVE A,FILREO		;1/OFN FOR ROOT-DIRECTORY
	CALL RELOFN		;RELEASE THE OFN FOR ROOT-DIRECTORY
				; (CALLER WILL DO ASOFN LATER)
	MOVE A,STRN02		;GET STRUCTURE NUMBER
	MOVE A,STRTAB(A)	;POINT TO ITS SDB
	SETZRO STRRDO,(A)	;CLEAR THE OFN FOR ROOT-DIRECTORY
	RETSKP

RCDMSG:	ASCIZ/
[RECONSTRUCTION PHASE 1 COMPLETED]
/

; ERROR RETURN ROUTINES FOR FILREC

FLRER4:	MOVE A,FILREB		;GET PAGE FOR BACKUP XB
	CALL RELPAG		;RELEASE THE PAGE

FLRER3:	MOVE A,FILRER		;GET ADDRESS OF PAGE
	CALL RELPAG		;RELEASE THE PAGE

FLRER2:	MOVE A,FILREO		;GET OFN OF ROOT-DIRECTORY
	CALL RELOFN		;RELEASE THE OFN

FLRER1:	MOVE A,BKOFN		;GET OFN OF BACKUP FILE
	CALLRET RELOFN		;RELEASE THE OFN AND RETURN ERROR
;CPYBAK - COPY THE ROOT-DIRECTORY FILE TO THE BACKUP FILE
;ACCEPTS: A/ STRUCTURE NUMBER
;	CALL CPYBAK
;RETURNS +1:	ERROR DURING COPYING
;	 +2:	OK

;NOT CALLED FROM WITHIN FILINI

CPYBAK::SAVEQ
	SE1CAL
	STKVAR <STRN03,CPYBKA,CPYBKJ,CPYBKO>
	MOVEM A,STRN03		;SAVE STRUCTURE NUMBER
	NOINT			;DONT ALLOW INTERRUPTS OUT OF THIS
	SETZM Q2		;ASSUME SUCCESS
	MOVEI B,^D14		;GET ENOUGH SPACE FOR NAME OF BACKUP FILE
	CALL ASGJFR		;ASSIGN SPACE FOR COMPLETE NAME
	 RETBAD (,OKINT)	;FAILED, GIVE UP
	MOVE Q1,A		;SAVE ADDRESS OF BLOCK
	HRROI A,1(A)		;FORM POINTER TO WHERE NAME WILL GO
	MOVE B,STRN03		;GET STRUCTURE NUMBER
	HRROI C,[ASCIZ/<ROOT-DIRECTORY>BACKUP-COPY-OF-ROOT-DIRECTORY.IMAGE/]
	CALL STRST		;FORM COMPLETE FILE NAME
	 JRST [	SETOM Q2	;MARK THAT FAIL RETURN IS NEEDED
		JRST CPYBK6 ]	;GO RELEASE SPACE AND GIVE FAIL RETURN
	MOVX A,GJ%OLD!GJ%PHY!GJ%SHT
	HRROI B,1(Q1)		;GET POINTER TO NAME
	GTJFN			;GET JFN FOR BACKUP FILE
	 SETOM Q2		;MARK THAT FAIL RETURN IS NEEDED
	MOVEM A,CPYBKJ		;SAVE JFN
CPYBK6:	MOVEI A,JSBFRE		;GET ADDRESS OF FREE HEADER
	MOVE B,Q1		;GET ADDRESS OF BLOCK
	CALL RELFRE		;RELEASE FREE SPACE
	JUMPN Q2,R		;GIVE FAIL RETURN IF NEEDED

;CLEAR THE 'DIR' BIT IN THE FDB FOR BACKUP-COPY-OF-ROOT-DIRECTORY.
;THIS IS TO INSURE THAT THE BACKUP NO LONGER HAS THE BIT SET SO THAT
;WE CAN OPEN THE FILE FOR WRITE

	HRRZ A,CPYBKJ		;GET JFN
	IMULI A,MLJFN		;INDEX INTO JFN TABLES
	CALL GETFDT		;GET THE FDB FOR THIS FILE
	 JRST CPYBK4		;FAILED. GO REPORT ERROR
	SETZRO <FBDIR>,(A)	;CLEAR THE 'DIR' BIT
	CALL USTDIR		;UNLOCK THE DIRECTORY
	HRRZ A,CPYBKJ		;GET JFN AGAIN
	MOVE B,[440000,,OF%RD+OF%WR+OF%THW]
	OPENF			;OPEN THE FILE FOR READ AND WRITE
	 RETBAD (,<MOVE A,CPYBKJ
		   RLJFN
		    JFCL
		   OKINT>)
	CALL ASGPAG		;GET A TEMPORARY PAGE FOR PMAPING
	 JRST CPYBK4		;FAILED TO GET A PAGE
	MOVEM A,CPYBKA		;SAVE ADR OF PAGE
	MOVEI A,ROOTDN		;NOW MAP IN ROOT-DIR
	MOVE B,STRN03		;GET STRUCTURE NUMBER
	CALL MAPDIR		;...
	 JRST CPYBK5		;FAILED
	CALL BLKSCN		;MAKE SURE THIS IS A STILL VALID
	 JRST CPYBK5		;ROOT-DIR IS SICK, DONT KILL BACKUP
	CALL SYMCHK		;CHECK VALIDITY OF SYMBOL TABLE ALSO
	 JRST CPYBK5		;NO, DONT DESTROY OLD GOOD COPY
	HRLZ A,CPYBKJ		;GET OFN OF THIS FILE
	CALL JFNOFN		;FOR USE BY SETMPG
	 JRST CPYBK5		;FAILED
	HLRZM A,CPYBKO		;SAVE OFN
	MOVN Q1,NDIRPG		;SET UP AOBJN COUNTER
	HRLZS Q1
	;..
	;..

CPYBK1:	MOVE B,STRN03		;GET STRUCTURE NUMBER
	MOVE B,STRTAB(B)	;GET ADDRESS OF SDB
	LOAD A,STRRDO,(B)	;GET OFN OF ROOT-DIRECTORY
	HRLZ A,A		;CHECK IF ROOT-DIR PAGE EXISTS
	HRR A,Q1		;GET PAGE NUMBER
	CALL MRPACS		;GET ACCESSIBILITY
	TXNN A,PA%PEX		;PAGE EXIST?
	JRST CPYBK2		;NO, SKIP THIS PAGE
	HRR A,Q1		;GET PAGE #
	HRL A,CPYBKO		;GET OFN OF FILE
	MOVX B,PTRW		;READ AND WRITE ACCESS
	HRR B,CPYBKA		;GET ADR OF WHERE TO MAP FILE PAGE
	CALL SETMPG		;GET PAGE OF BACKUP FILE MAPPED IN
	MOVEI B,0(Q1)		;NOW SET UP TO BLT ROOT-DIR TO FILE
	LSH B,PGSFT		;GET ADDRESS OF ROOT-DIR PAGE
	ADD B,DIRORA		;ADD IN BASE ADR
	MOVE C,CPYBKA		;GET DEST ADDRESS
	MOVEI A,1000
	CALL XBLTA		;COPY ROOT-DIR TO BACKUP FILE
	MOVEI A,0		;UNMAP THE PAGE
	MOVE B,CPYBKA
	CALL SETMPG
CPYBK2:	AOBJN Q1,CPYBK1		;LOOP BACK FOR ALL PAGES IN DIR
CPYBK3:	MOVE A,CPYBKA		;NOW RELEASE TEMP PAGE
	CALL RELPAG		;...
	MOVE A,CPYBKJ		;AND RELEASE JFN
	CLOSF
	 JFCL
	OKINT
	RETSKP			;COPY HAS BEEN MADE SUCCESSFULLY

CPYBK5:	MOVE A,CPYBKA		;RELEASE TEMP PAGE
	CALL RELPAG
CPYBK4:	MOVE A,CPYBKJ		;AND RELEASE JFN
	RLJFN
	 JFCL
	OKINT
	RET			;GIVE ERROR RETURN

;ROUTINE TO GET AN OFN FOR THE INDEX TABLE FILE
;
; ACCEPTS:
;	T1/ STRUCTURE NUMBER
;		CALL FNDIDX IF FILE EXISTS
;			OR
;		CALL MAKIDX TO CREATE FILE

; RETURNS: +1	 ERROR
;	   +2	SUCCESS, HANDLE FOR INDEX TABLE FILE STORED IN SDB

;CALLED FROM REFRESH AND NORMAL STARTUP CODE AND WELL AS MSTR

FNDIDX::TDZA T3,T3		;INDICATE MUST FIND OLD FILE
MAKIDX::SETOM T3		;INDICATE CREATING NEW FILE
	STKVAR <CRIDXS,CRIDXB,CRIDXE,CRIDXJ,CRIDXF>
	SE1CAL
	MOVEM T3,CRIDXF		;SAVE INDICATOR OF ENTRY POINT
	MOVEM T1,CRIDXS		;SAVE STRUCTURE NUMBER
	SETZM CRIDXE		;INITIALIZE ERROR FLAG
	MOVEI T2,12		;GET # OF WORDS NEEDED FOR FILE NAME
	NOINT			;NOINT WHILE HAVE JSB FREE SPACE
	CALL ASGJFR		;ASSIGN SOME FREE SPACE
	 RETBAD (MONX02,<OKINT>) ;RETURN "INSUFFICIENT RESOURCES" - JSB FULL
	MOVEM T1,CRIDXB		;SAVE ADDRESS OF BLOCK ASSIGNED

; GET A JFN FOR THE INDEX TABLE FILE

	HRROI T1,1(T1)		;FORM POINTER TO WHERE NAME WILL GO
	MOVE T2,CRIDXS		;GET STRUCTURE NUMBER
	HRROI T3,[ASCIZ/<ROOT-DIRECTORY>INDEX-TABLE.BIN.1/]
	CALL STRST		;FORM COMPLETE FILE NAME
	 JRST [	SETOM CRIDXE	;FAILED, NOTE THAT AN ERROR OCCURRED
		JRST CRIDX2 ]	;FAILED, NOTE ERROR AND GO RELEASE SPACE
	MOVE T2,CRIDXB		;GET ADDRESS OF BLOCK CONTAINING NAME
	HRROI T2,1(T2)		;FORM POINTER TO FILE NAME
	SKIPE CRIDXF		;WANT TO CREATE IDXTAB?
	JRST MAKID1		;YES. GO DO IT
	MOVX T1,GJ%SHT!GJ%PHY!GJ%OLD!GJ%DEL ;SHORT CALL, PHYSICAL ONLY, OLD FILE
	GTJFN			;GET A JFN FOR THE INDEX TABLE FILE
MAKID2:	 JRST [	SETOM CRIDXE
		JRST CRIDX2]
	MOVEM T1,CRIDXJ		;SAVE JFN OF INDEX TABLE FILE
	HRLI T1,.FBCTL		;SET UP TO CHANGE CONTROL WORD
	MOVX T2,FB%DEL		;CHANGE DELETED BIT
	SETZM T3		;CLEAR IT
	CHFDB			;DO IT
	 ERJMP [SETOM CRIDXE	;INDICATE ERROR
		JRST CRIDX2]
	JRST CRIDX2		;GO TO COMMON CODE

;HERE WHEN CREATING NEW IDXTAB

MAKID1:	MOVX T1,GJ%SHT!GJ%PHY 	;TRY TO CREATE FILE
	GTJFN			;GET A JFN FOR THE NEW FILE
	 JRST [	SETOM CRIDXE	;FAILED, NOTE ERROR
		JRST CRIDX2 ]	;GO RELEASE SPACE AND RETURN ERROR TO USER
	MOVEM T1,CRIDXJ		;SAVE JFN OF NEW FILE
	HRLI T1,.FBCTL		;GET OFFSET TO WORD TO BE CHANGED
	MOVX T2,FB%NOD		;CHANGE THE FB%NOD BIT
	MOVX T3,FB%NOD		;INDEX TABLE FILE IS NOT DUMP-ABLE
	CHFDB			;CHANGE THE FDB OF THE NEW FILE
	 ERJMP .+1		;IGNORE FAILURE
	HRRZ T1,CRIDXJ		;GET JFN OF NEW INDEX TABLE FILE
	MOVX T2,<FLD(^D36,OF%BSZ)+OF%WR>
	OPENF			;OPEN THE FILE TO CREATE THE INDEX BLOCK
	 JRST [	SETOM CRIDXE	;NOTE OCCURRANCE OF ERROR
		MOVE T1,CRIDXJ	;GET JFN
		RLJFN		;RELEASE THE JFN
		 JFCL		;IGNORE ERRORS HERE
		JRST CRIDX2]	;GO RELEASE SPACE AND RETURN ERROR
	TXO T1,CO%NRJ		;DON'T RELEASE THE JFN
	CLOSF			;CLOSE THE FILE
	 JFCL			;IGNORE ERROR HERE
	MOVE T1,CRIDXS		;GET STRUCTURE NUMBER
	CALL CPYBAK		;UPDATE BACKUP COPY OF ROOT-DIRECTORY
	 JFCL			;IGNORE FAILURE TO UPDATE BACKUP ROOT-DIR

; RELEASE SPACE USED TO HOLD FILE NAME - RETURN ERROR IF ANYTHING HAS FAILED

CRIDX2:	MOVEI T1,JSBFRE		;GET FREE HEADER
	MOVE T2,CRIDXB		;GET ADDRESS OF FREE BLOCK
	CALL RELFRE		;RELEASE THE SPACE
	OKINT			;OKINT NOW THAT JSB FREE SPACE RETURNED
	SKIPE CRIDXE		;ANY ERRORS SO FAR ?
	RETBAD (MSTX11)		;YES, RETURN ERROR

; ASSIGN AN OFN FOR THE INDEX TABLE FILE AND SAVE IN THE SDB FOR THIS STRUCTURE

	MOVE T1,CRIDXJ		;GET THE JFN OF THE INDEX TABLE FILE
	IMULI T1,MLJFN		;COMPUTE OFFSET TO JFN BLOCK
	CALL GETFDT		;GET THE ADDRESS OF THE FDB FOR THIS FILE
	 JRST [	SETOM CRIDXE	;FAILED, NOTE THAT AN ERROR OCCURRED
		JRST CRIDX4 ]	;GO RELEASE THE JFN AND RETURN ERROR TO USER
	LOAD T1,FBADR,(A)	;GET ADDRESS OF INDEX BLOCK
	TXO T1,FILWB+THAWB	;OPEN FOR WRITE, THAWED
	MOVE T2,CRIDXS		;GET STRUCTURE NUMBER
	CALL ASROFN		;ASSIGN AN OFN IN THE ROOT-DIRECTORY
	 JRST [	SETOM CRIDXE	;FAILED, NOTE THAT AN ERROR OCCURRED
		JRST CRIDX3 ]	;GO UNLOCK DIRECTORY AND RETURN ERROR
	MOVE T2,CRIDXS		;GET STRUCTURE NUMBER
	MOVE T2,STRTAB(T2)	;GET ADDRESS OF SDB FOR THIS STRUCTURE
	STOR T1,STRIDX,(T2)	;STORE OFN OF INDEX TABLE IN SDB
	SETONE STIDX,(T2)	;NOTE THAT INDEX TABLE OFN HAS BEEN SET UP
CRIDX3:	CALL USTDIR		;UNLOCK THE DIRECTORY
CRIDX4:	MOVE T1,CRIDXJ		;GET JFN OF INDEX TABLE FILE
	RLJFN			;RELEASE THE JFN
	 JFCL			;FAILED, IGNORE FAILURE
	SETZRO <CURSTR,CURUC,IDXFLG>
	SKIPE CRIDXE		;ANY ERRORS OCCUR ?
	RETBAD (MSTX11)		;YES, RETURN ERROR CODE
	RETSKP			;NO, RETURN SUCCESS

;ROUTINE TO INITIALIZE THE INDEX TABLE
; CALL:	ACCEPTS IN T1/ STRUCTURE NUMBER
;		CALL IDXINI
;RETURNS +1:	 ERROR
;	 +2:	SUCCESS

;CALLED FROM COMMON CODE

IDXINI::STKVAR <IDXINS,IDXINR> ;VARIABLES FOR STRUCTURE NUMBER AND FWDN FOR ROOT
	SE1CAL
	SAVEP			;SAVE PERMANENT ACS
	MOVEM A,IDXINS		;SAVE STRUCTURE NUMBER

;CHECK ROOT-DIRECTORY AND REBUILD IT IF NECESSARY

	MOVE A,STRTAB(A)	;GET SDB
	LOAD B,STRUC,(A)	;GET UNIQUE CODE FOR THIS STRUCTURE
	HRLZS B			;B/ UNIQUE CODE,,DIRECTORY NUMBER
	HRRI B,ROOTDN		; FOR ROOT-DIRECTORY ON THIS STRUCTURE
	MOVEM B,IDXINR		;SAVE 36-BIT DIRECTORY NUMBER
	MOVX A,DD%CHK		;CHECK SYMBOL TABLE
	DELDF			;CHECK ROOT-DIRECTORY
	 ERJMP [MOVX A,DD%RST	;ERRORS - REBUILD
		MOVE B,IDXINR	;GET DIR NUMBER BACK
		DELDF		;REBUILD SYMBOL TABLE
		 ERJMP R	;IF FAILED, TELL CALLER
		JRST .+1]	;REBUILD SUCCEEDED

;MAP IN ROOT-DIRECTORY AND INITIALIZE ITS MAXIMUM ALLOWABLE SUBDIRECTORIES

	MOVE A,IDXINS		;GET STRUCTURE NUMBER
	MOVE A,IDXINR		;A/ (UNIQUE CODE,,DIRECTORY NUMBER) FOR ROOT-DIRECTORY
	CALL SETDIR		;MAP ROOT-DIRECTORY
	 RETBAD			;FAILED
	MOVE A,DIRORA		;CHECK SUBDIR COUNT
	LOAD B,DRSDC,(A)	; ...
	SKIPN B			;ZERO?
	MOVE B,MXDIRN		;YES - ROOT DIR ALWAYS HAS AT LEAST
	STOR B,DRSDC,(A)	;ITSELF
	CALL CLRIDX		;START BY ZEROING IDXTAB
	CALL USTDIR		;AND UNLOCK THE ROOT-DIR

;STEP THROUGH ALL DIRECTORIES AND CREATE THEIR ENTRIES IN IDXTAB

	HLLZ A,IDXINR		;GET STRUCTURE UNIQUE CODE
	MOVX F1,DIRSF!STEPF	;INDICATE STEPPING
IDXIN1:	SETZ C,			;NO WILD MASK
	CALL MDDDIR		;STEP THROUGH DIRS AND SETUP INDEX
	 JRST IDXIN2		;ANALYZE ERROR
	 JRST IDXIN2		; ...
	CALL USTDIR		;UNLOCK
	JRST IDXIN1		;LOOP

;HERE WHEN MDDDIR RETURNS FAILURE.  ALWAYS GET HERE WHEN IT REACHES
;LAST DIRECTORY

IDXIN2:	CAIE A,GJFX32		;NO MORE DIRECTORIES?
	BUG(BADIDX)
	MOVE B,IDXINS		;GET STRUCTURE NUMBER
	MOVE B,STRTAB(B)	;GET ADDRESS OF SDB
	LOAD A,STRIDX,(B)	;GET OFN OF IDXTAB
	HRLZS A
	MOVEI T2,1000
	CALL UPDPGS
	MOVE A,IDXINS
	MOVE A,STRTAB(A)
	LOAD A,STRIDX,(A)
	CALL UPDOFN		;UPDATE ON DISK
	RETSKP			;RETURN SUCCESS

;SETUP NEW INDEX BLOCK FOR ROOT-DIRECTORY
;ACCEPTS:
;	A/DESIRED ADR OF INDEX BLOCK
;	B/STRUCTURE NUMBER

;	CALL NEWIB
; RETURN +1:  FAILURE
;	 +2: SUCCESS, WITH
;	1/ OFN
;	2/ DISK ADR

;CALLED FROM REFRESH CODE

NEWIB::	STKVAR<STRN04,DSKADR,IBOFN>
	MOVEM B,STRN04		;SAVE STRUCTURE NUMBER
	MOVSI C,(FILWB+FILNB+THAWB) ;CONSTRUCT BITS FOR CALL TO ASOFN
	MOVEM C,DSKADR		;SAVE TO MERGE WITH ADDRESS LATER
	CALL DSKASA		; Get a blank disc address
	 RET			;FAILED, RETURN ERROR
	EXCH A,DSKADR		;SAVE DSK ADR, RECOVER BITS
	IOR A,DSKADR		;MERGE ADR WITH BITS
	MOVE B,STRN04		;B/STRUCTURE NUMBER
	CALL ASROFN
	 RET			;FAILED, RETURN ERROR
	MOVEM A,IBOFN		;SAVE THE OFN
	CALL UPDOFN		;WRITE THE INDEX BLOCK TO THE DISK
	MOVE A,IBOFN		;RESTORE THE OFN
	MOVE B,DSKADR		;RESTORE THE DISK ADDRESS
	RETSKP

	TNXEND
	END
