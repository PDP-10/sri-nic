;<BERLIN.MONITOR>FILMSC.MAC.2, 28-Jun-82 15:27:33, Edit by BERLIN
;1000 V5 merge
;SRC:<SYS.MONITOR>FILMSC.MAC.3 23-Mar-81 01:02:58, Edit by MMCM
;221 Full 12-bit character input via .MOFCI MTOPR
; UPD ID= 449, SNARK:<5.MONITOR>FILMSC.MAC.11,  29-Jan-82 14:03:18 by WALLACE
;TCO 5.1709 - Make check at TTYOUT for universal form of terminal designator
;  (i.e. 600000+.DVTTY,,terminal number) and continue at TTYOUX
; UPD ID= 448, SNARK:<5.MONITOR>FILMSC.MAC.10,  29-Jan-82 13:44:11 by MILLER
;TCO 5.1678. TTYASN now checks that caller has access to the TTY
; UPD ID= 142, SNARK:<5.MONITOR>FILMSC.MAC.9,   3-Sep-81 11:10:00 by DONAHUE
;TCO 5.1486 - Prevent TTYBLO from looping with a large byte count
; UPD ID= 2152, SNARK:<5.MONITOR>FILMSC.MAC.8,   8-Jun-81 17:36:15 by MURPHY
;PREVENT CLEAR OF TTY OUTBUF WHEN CLOSING IF TTY ASSIGNED
; UPD ID= 1863, SNARK:<5.MONITOR>FILMSC.MAC.7,  21-Apr-81 18:28:18 by MURPHY
;ADD .MOPCS, .MOPCR FUNCTIONS
;TCO 5.1242 - Fix TTYCLZ to not block NOINT with DEVLKK locked.
; UPD ID= 961, SNARK:<5.MONITOR>FILMSC.MAC.5,  25-Aug-80 16:25:50 by ENGEL
;TCO 5.1136 - ADD DEVLKK
; UPD ID= 686, SNARK:<5.MONITOR>FILMSC.MAC.4,  23-Jun-80 14:58:17 by SANICHARA
;TCO 5.1074 - The fork enabling a PTY for INTs must be the owner of the JFN
; UPD ID= 654, SNARK:<5.MONITOR>FILMSC.MAC.3,  16-Jun-80 17:00:10 by OSMAN
;tco 5.1050 - Make jfn on TTY: use fork's controlling terminal
; UPD ID= 434, SNARK:<5.MONITOR>FILMSC.MAC.2,  13-Apr-80 15:13:20 by OSMAN
; UPD ID= 426, SNARK:<4.1.MONITOR>FILMSC.MAC.2,  13-Apr-80 14:34:48 by OSMAN
;tco 4.1.1142 - Use RSCAN data if input from fork's controlling terminal
; UPD ID= 426, SNARK:<4.1.MONITOR>FILMSC.MAC.46,   9-Apr-80 16:22:31 by OSMAN
;Clean up TTYIN code.  Get rid of moby literal
;<4.MONITOR>FILMSC.MAC.45, 26-Oct-79 14:51:15, EDIT BY ZIMA
;TCO 4.2557 - Change for new calling sequence to TTSSPD for ACJ rejection
; handling; returns nonskip on error, skip on "success".  At TTMSSP+3.
;<4.MONITOR>FILMSC.MAC.44, 24-Oct-79 12:38:55, EDIT BY MURPHY
;HANDLE FAILURE FROM TTSTI
;<OSMAN.MON>FILMSC.MAC.1, 10-Sep-79 15:29:37, EDIT BY OSMAN
;TCO 4.2412 - Move definition of BUGHLTs, BUGCHKs, and BUGINFs to BUGS.MAC
;<4.MONITOR>FILMSC.MAC.41, 13-Aug-79 17:07:13, EDIT BY DBELL
;TCO 4.2393 - MAKE GNJFN OF NUL:<*>FOO.BAR TERMINATE
;<4.MONITOR>FILMSC.MAC.40,  9-Aug-79 13:43:05, EDIT BY TOMCZAK
;TTYCLZ - wait for output buffers to empty before closing a TTY
;<4.MONITOR>FILMSC.MAC.39, 12-May-79 13:04:22, EDIT BY MILLER
;<4.MONITOR>FILMSC.MAC.38, 12-May-79 12:49:24, EDIT BY MILLER
;ADD CODE FOR GDSTS
;<4.MONITOR>FILMSC.MAC.37, 20-Mar-79 17:18:34, EDIT BY HALL
;TTYIN - BE NOINT UNTIL FREE SPACE IS RETURNED WHEN USING THE
;RESCAN BUFFER
;<4.MONITOR>FILMSC.MAC.36,  4-Mar-79 17:11:09, EDIT BY KONEN
;UPDATE COPYRIGHT FOR RELEASE 4
;<4.MONITOR>FILMSC.MAC.35, 30-Jan-79 12:11:49, Edit by MCLEAN
;FIX TTMTOP TO RETSKP IF NO CONTROLLING TERMINAL
;<4.MONITOR>FILMSC.MAC.34, 13-Dec-78 15:45:09, Edit by MCLEAN
;REMOVE AN INSTRUCTION IN TTYOUB
;<4.MONITOR>FILMSC.MAC.33, 11-Dec-78 22:58:59, Edit by MCLEAN
;ADD .MOTPS
;<4.MONITOR>FILMSC.MAC.31, 11-Dec-78 13:34:50, Edit by MCLEAN
;CHANGE REGISTER FROM B TO D AT TTYOUY+A FEW
;<4.MONITOR>FILMSC.MAC.30,  6-Nov-78 12:46:58, Edit by MCLEAN
;<4.MONITOR>FILMSC.MAC.29,  5-Nov-78 16:22:34, Edit by MCLEAN
;FIX TTYOUB FOR LAST CHARACTER CHECK
;<2MCLEAN>FILMSC.MAC.28, 11-Oct-78 00:11:32, Edit by MCLEAN
;<2MCLEAN>FILMSC.MAC.27, 10-Oct-78 23:57:47, Edit by MCLEAN
;<2MCLEAN>FILMSC.MAC.26,  9-Oct-78 23:42:00, Edit by MCLEAN
;<2MCLEAN>FILMSC.MAC.25,  8-Oct-78 21:42:37, Edit by MCLEAN
;<2MCLEAN>FILMSC.MAC.24,  8-Oct-78 15:06:51, Edit by MCLEAN
;<2MCLEAN>FILMSC.MAC.23,  5-Oct-78 11:57:21, Edit by MCLEAN
;<2MCLEAN>FILMSC.MAC.22,  3-Oct-78 23:40:35, Edit by MCLEAN
;<2MCLEAN>FILMSC.MAC.21,  3-Oct-78 23:20:19, Edit by MCLEAN
;<2MCLEAN>FILMSC.MAC.20,  3-Oct-78 00:59:16, Edit by MCLEAN
;<2MCLEAN>FILMSC.MAC.19,  3-Oct-78 00:57:45, Edit by MCLEAN
;<4.MONITOR>FILMSC.MAC.17, 27-Aug-78 10:02:16, EDIT BY MILLER
;<4.MONITOR>FILMSC.MAC.16, 27-Aug-78 09:58:00, EDIT BY MILLER
;ADD CHKBCH
;<4.MONITOR>FILMSC.MAC.15, 15-Aug-78 09:29:09, Edit by ENGEL
;MAKE TTMVER UNLOCK IF BLOCK WRONG SIZE
;<4.MONITOR>FILMSC.MAC.14, 14-Aug-78 08:34:36, EDIT BY OSMAN
;MAKE TLOCK SKIP IF SUCCESS
;<4.MONITOR>FILMSC.MAC.13, 10-Aug-78 16:35:53, EDIT BY OSMAN
;ADD READ/SET LINE COUNTER, LINE COUNTER MAXIMUM FUNCTIONS
;<4.MONITOR>FILMSC.MAC.12, 26-Jul-78 18:43:01, EDIT BY MILLER
;ADD READ XOFF BIT FUNCTION
;<4.MONITOR>FILMSC.MAC.11, 23-Jul-78 15:05:24, EDIT BY MILLER
;FIX TYPEO
;<4.MONITOR>FILMSC.MAC.10, 23-Jul-78 14:49:39, EDIT BY MILLER
;TCO 1951. ADD MTOPR CODE FOR XON/XOFF
;<4.MONITOR>FILMSC.MAC.9, 14-Jul-78 12:53:03, Edit by MCLEAN
;<4.MONITOR>FILMSC.MAC.8, 14-Jul-78 12:48:27, Edit by MCLEAN
;<4.MONITOR>FILMSC.MAC.7, 14-Jul-78 12:48:01, Edit by MCLEAN
;<4.MONITOR>FILMSC.MAC.6, 14-Jul-78 01:52:08, Edit by MCLEAN
;<4.MONITOR>FILMSC.MAC.5, 14-Jul-78 01:30:27, Edit by MCLEAN
;<4.MONITOR>FILMSC.MAC.4, 14-Jul-78 01:12:47, Edit by MCLEAN
;ADD CHECK FOR OPENED TO MTOPR
;<3A.MONITOR>FILMSC.MAC.4, 17-May-78 11:10:53, EDIT BY MILLER
;FIX UP HANDLING OF RSCNBP TO AVOID SYSTEM CRASHES. CURRENT RSCAN
; CODE IS STILL WRONG AND FULL OF RACES
;<4.MONITOR>FILMSC.MAC.2,  9-Mar-78 09:37:53, Edit by ENGEL
;ADD MTOPR FUNCTIONS FOR 128-CHARACTER MASK


;THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY ONLY BE USED
;  OR COPIED IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
;COPYRIGHT (C) 1976,1977,1978,1979 BY DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.

	SEARCH PROLOG
	TTITLE FILMSC		;MISC - TTY, PTY, STRING AND NIL
	SWAPCD

;SPECIAL EXTERNALS IN TTYSRV USED BY THIS CODE

	EXTN <TTXSET,TTRXOB,TTGSTS,TTIFCI> ;221 Add TTIFCI

;SPECIAL AC DEFINITIONS USED HEREIN

DEFAC (U,Q1)			;UNIT NUMBER
DEFAC (IOS,Q2)			;DEVICE STATUS FLAGS
DEFAC (STS,P1)			;SEE GTJFN FOR FUNCTIONS
DEFAC (JFN,P2)
DEFAC (DEV,P4)
DEFAC (F1,P5)

	SUBTTL NUL DEVICE FUNCTIONS

NILDTB::DTBDSP (NILSET)
	DTBDSP (NILLKP)		;NAME LOOKUP
	DTBDSP (NILLKP)		;EXT LOOKUP
	DTBDSP (NILVLK)		;VER LOOKUP
	DTBBAD			;PROTECTION INSERTION
	DTBSKP			;ACCOUNT INSERTION
	DTBBAD			;STATUS INSERTION
	DTBDSP (NILOPN)		;OPEN
	DTBDSP (NILSQI)		;INPUT
	DTBDSP (NILSQO)		;OUTPUT
	DTBSKP			;CLOSF
	DTBSKP			;RENAME
	DTBSKP			;DELETE
	DTBBAD (DUMPX6)		;DUMPI
	DTBBAD (DUMPX6)		;DUMPO
	DTBSKP			;MOUNT
	DTBSKP			;DISMOUNT
	DTBSKP			;INIT DIRECTORY
	DTBSKP			;MTOPR
	DTBBAD			;DEVICE STATUS READ
	DTBBAD			;DEVICE STATUS SET
	DTBSKP			; RECORD OUT
	DTBDSP (RFTADN)		; READ TAD
	DTBDSP (SFTADN)		; SET TAD
	DTBDSP (BIOINP)		;SET JFN FOR INPUT
	DTBDSP (BIOOUT)		;SET JFN FOR OUTPUT
	DTBBAD (GJFX49)		;CHECK ATTRIBUTE

	DTBLEN==:.-NILDTB	;GLOBAL LENGTH OF DISPATCH TABLE

NILOPN:	TQCE <RNDF>		;WANT APPEND?
	TQO <WRTF>		;YES. LIGHT WRITE BIT THEN
	SETZB A,B
	CAIN JFN,377777
	RET			;ALL DONE FOR THIS GUY
	TQNN <READF>		;IS IT READ?
	HRLOI A,377777		;NO. DO OUTPUT
	MOVEM A,FILCNT(JFN)	;STORE COUNT
	SETZB A,FILBYT(JFN)	;RETURN ZEROS
	RETSKP			;AND RETURN SUCCESSFULLY

NILSQO:	SETZB A,B
	CAIN JFN,377777
	 RET
	TQNN <READF>		;IS IT READ?
	HRLOI A,377777		;NO, SET UP LARGE COUNT
	MOVEM A,FILCNT(JFN)
	SETZB A,FILBYT(JFN)
	RET

NILSQI:	TQO <EOFF>		;GENERATE EOF ON INPUT
	RET

NILSET:	TQO <NNAMF,NVERF>	;SET FLAGS
	HRRZ A,FILDDN(JFN)	;USE DIRECTORY NUMBER AS COUNTER
	TQNN <STEPF>		;STEPPING?
	JRST SK2RET		;NO, GIVE OK RETURN
	SOSL A			;FIRST TIME?
	RETBAD (GNJFX1)		;NO, SAY NO MORE DIRECTORIES
	HRRM A,FILDDN(JFN)	;YES, STORE FLAG BACK
	JRST SK2RET		;AND GIVE OK RETURN


NILLKP:	JUMPE A,SK2RET		;IF FIRST TIME, ALLOW IT
	TQNN <STEPF>		;STEPPING
	JRST SK2RET		;NO, GIVE OK RETURN
	RETBAD (GNJFX1)		;NO MORE NAMES

NILVLK:	CAME A,[-2]		;FIRST TIME?
	TQNN <STEPF>		;OR NOT STEPPING
	RETSKP			;THEN SAY OK
	RETBAD (GNJFX1)		;NO MORE VERSIONS
	SUBTTL STRING DEVICE FUNCTIONS

STRDTB::DTBBAD (GJFX32)	;DIR SET
	REPEAT BIND-1,<
	DTBBAD (DESX9)>
	STRIN
	DTBDSP (STROUT)
	REPEAT DELD-BOUTD,<
	DTBBAD (DESX9)>
	DTBBAD (DUMPX6)		;DUMPI
	DTBBAD (DUMPX6)		;DUMPO
	DTBBAD (DESX9)		;MOUNT
	DTBBAD (DESX9)		;DISMOUNT
	DTBBAD (DESX9)		;INITIALIZE DIR
	DTBBAD (MTOX1)		; MTOPR
	DTBBAD (DESX9)		;GET DEV STATUS
	DTBBAD (DESX9)		;SET DEV STATUS
	DTBSKP			;RECORD OUT
	DTBDSP (RFTADN)		; READ TAD
	DTBDSP (SFTADN)		; SET TAD
	DTBDSP (BIOINP)		;SET JFN FOR INPUT
	DTBDSP (BIOOUT)		;SET JFN FOR OUTPUT
	DTBBAD (GJFX49)		;CHECK ATTRIBUTE

	DTBLEN==:.-STRDTB	;GLOBAL LENGTH OF DISPATCH TABLE

STRIN:	XCTBU [ILDB A,JFN]
	RET

STROUT:	XCTBU [IDPB A,JFN]
	RET

;DECREMENT BYTE POINTER
; A/ BYTE PTR
;	CALL DBP
; RETURNS +1, CLOBBERS B AND C

DBP::
	MOVNI T2,1		;ADJUST BY -1
	ADJBP T2,T1
	MOVEM T2,T1		;RETURN RESULT
	RET			;AND DONE
	SUBTTL PTY DEVICE FUNCTIONS

;DEVICE DEPENDENT ROUTINES. TO DO CERTAIN FUNCTIONS, THE RH OF DEV
;CONTAINS THE NAME OF A TABLE SUCH AS PTYDTB, AND A ROUTINE IS CALLED
;VIA 'CALL @FOO(DEV)', WHERE FOO IS A SYMBOL FOR AN OFFSET INTO THE 
;TABLE. THE SYMBOLS ARE DEFINED IN PROLOG. IN THE COMMENTS BELOW,
;THE OFFSET IS INDICATED ALONG WITH THE PURPOSE OF THE ROUTINE

PTYDTB::DTBDSP (PTYSET)		;DLUKD - DIRECTORY SETUP
	DTBBAD (DESX9)		;INLUKD - NAME LOOKUP
	DTBBAD (DESX9)		;ELUKD - EXTENSION LOOKUP
	DTBBAD (DESX9)		;VLUKD - VERSION LOOKUP
	DTBBAD (DESX9)		;PULKD - PROTECTION INSERTION
	DTBBAD (DESX9)		;ALUKD - ACCOUNT INSERTION
	DTBBAD (DESX9)		;SLUKD - STATUS INSERTION
	DTBDSP (PTYOPN)		;OPEND - OPEN FILE
	DTBDSP (PTYIN)		;BIND - BYTE INPUT
	DTBDSP (PTYOUT)		;BOUTD - BYTE OUTPUT
	DTBDSP (PTYCLZ)		;CLOSD - CLOSE FILE
	DTBBAD (DESX9)		;REND - RENAME
	DTBBAD (DESX9)		;DELD - DELETE FILE
	DTBBAD (DUMPX6)		;DMPID - DUMP MODE INPUT
	DTBBAD (DUMPX6)		;DMPOD - DUMP MODE OUTPUT
	DTBBAD (DESX9)		;MNTD - MOUNT DEVICE
	DTBBAD (DESX9)		;DSMD - DISMOUNT DEVICE
	DTBBAD (DESX9)		;INDD - INITIALIZE DIRECTORY OF DEVICE
	DTBDSP (PTMTOP)		;MTPD - DO MTAPE OPERATION
	DTBBAD (DESX9)		;GDSTD - GET DEVICE STATUS
	DTBBAD (DESX9)		;SDSTD - SET DEVICE STATUS
	DTBSKP			;RECOUT - FORCE RECORD OUT (SOUTR)
	DTBDSP (RFTADN)		;RFTADD - READ FILE TIME AND DATE
	DTBDSP (SFTADN)		;SFTADD - SET FILE TIME AND DATE
	DTBDSP (BIOINP)		;SET JFN FOR INPUT
	DTBDSP (BIOOUT)		;SET JFN FOR OUTPUT
	DTBBAD (GJFX49)		;CHECK ATTRIBUTE

	DTBLEN==:.-PTYDTB	;GLOBAL LENGTH OF DISPATCH TABLE

	DEFSTR (PTYFRK,PTYSTS(U),35,18) ;FORK INDEX OF OWNER
	DEFSTR (PTYCHN,PTYSTS(U),17,6) ;PSI CHANNEL NUMBER

;BITS IN AC 'IOS' - SEE DEFAC AT BEGINNING OF MODULE

FLG(POPEN,L,IOS,400000)		;PTY IS OPEN
FLG(PIIEN,L,IOS,200000)		;INPUT INTERRUPT ENABLED
FLG(POIEN,L,IOS,100000)		;OUTPUT INTERRUPT ENABLED
FLG(PIIEV,L,IOS,040000)		;INPUT EVENT OCCURRED
FLG(POIEV,L,IOS,020000)		;OUTPUT EVENT OCCURRED
FLG(PTBAT,L,IOS,010000)		;PTY IS BEING CONTROLED BY BATCH
;FUNCTION DLUKD FOR PTY - DIRECTORY SETUP

PTYSET:	TQO <NNAMF,NVERF>	;SAY NO NAME, VERSION, ETC
	RETBAD (GJFX32)

;OPEND FUNCTION FOR PTY - OPEN FILE

;ACCEPTS:
;	JFN/ JOB FILE NUMBER
;	DEV/ (UNIT NUMBER,,DISPATCH ADDRESS)

;CALL PTYOPN

;RETURNS +1: FAILURE
; 	 +2: SUCCESS

PTYOPN:	STKVAR <PTYOLN>
	CALL CHKAPD		;FIX APPEND BIT
	HLRZ U,DEV		;GET UNIT NUMBER
	MOVE IOS,PTYSTS(U)
	TQOE <POPEN>		;ALREADY OPEN?
	RETBAD OPNX9		;YES
	HLRZ T2,DEV		;T2/ PTY NUMBER
	CALL PTYTTY		;GET CORRESPONDING TELETYPE NUMBER
	MOVEM T2,PTYOLN		;SAVE LINE NUMBER
	CALL STADYN		;IS LINE ALREADY ACTIVE?
	 SKIPA			;NO
	RETBAD (OPNX7)		;YES. INDICATE ASSIGNED TO ANOTHER JOB
	MOVE T2,PTYOLN		;T2/ LINE NUMBER
	CALL TTYASC		;ASSIGN DYNAMIC DATA FOR LINE
	 RETBAD			;FAILED
	MOVE T2,PTYOLN		;T2/ LINE NUMBER
	MOVEI T1,-1		;T1/ JOB NUMBER
	CALL STCJOB		;INDICATE NO CONTROLLING JOB FOR TERMINAL
	MOVE T2,PTYOLN		;T2/ LINE NUMBER
	CALL STADYN		;POINT TO DYNAMIC DATA
	 JRST PTYOP1		;SHOULDN'T HAPPEN
	CALL STPRM		;MAKE THE DATA PERMANENT UNTIL PTY IS CLOSED
	MOVX IOS,POPEN		;SET THAT PTY IS NOW OPEN
	HRR IOS,FORKX		;REMEMBER FORK DOING OPEN
PTYRET:	MOVEM IOS,PTYSTS(U)
	RETSKP

PTYOP1:	BUG(TTNAC1)
	RETBAD (TTYX01)

;FUNCTION BIND FOR PTY - BYTE INPUT

;ACCEPTS:
;	DEV/ (UNIT,,DISPATCH ADDRESS)

;	CALL PTYIN

;RETURNS +1: ALWAYS,
;		T1/ A CHARACTER

;GETS A CHARACTER FROM THE ASSOCIATED TERMINAL'S OUTPUT BUFFER TO
;SERVE AS INPUT ON THE PTY.  BLOCKS IF NECESSARY. ALWAYS RETURNS WITH
;CHARACTER

PTYIN:	HLRZ 2,DEV
	CALL PTYTTY		;GET INTERNAL LINE NUMBER
	CALL LCKTTY		;GET ADDRESS OF DYNAMIC DATA AND PREVENT
				; DEALLOCATION
	 JRST [	CALL ULKTTY	;NOT FULLY ACTIVE. ALLOW DEALLOCATION
		TQO <ERRF>	;INDICATE ERROR
		RET]
	CALL TTSTO		;GET CHAR FROM LINE, BLOCK IF NONE
	 JRST PTYIN		;TRY AGAIN
	CALL ULKTTY		;ALLOW DEALLOCATION
	RET

;FUNCTION BOUTD FOR PTY - BOUT OUTPUT

;ACCEPTS:
;	T1/ A CHARACTER
;	DEV/ (UNIT,,DISPATCH ADDRESS)

;	CALL PTYOUT

;RETURNS +1: ALWAYS

;FOR THE ASSOCIATED TERMINAL, SIMULATES REMOVING THE SPECIFIED
;CHARACTER FROM TTBBUF AND PLACING IT IN THE LINE'S INPUT BUFFER
;(ISSUING AN INTERRUPT IF NECESSARY, ECHOING, ETC.)

PTYOUT:	HLRZ 2,DEV		;GET PTY NUMBER
	CALL PTYTTY		;CONVERT TO INTERNAL LINE NUMBER
	CALL TTSTI		;PUT CHAR INTO LINE
	 JRST [	TQO <BLKF>	;FAILED
		HRLZ T1,T1	;LEAVE ERR CODE IN LH
		RET]
	RET

;FUNCTION CLOSD FOR PTY - CLOSE FILE

;ACCEPTS:
;	DEV/ (UNIT,,DISPATCH ADDRESS)

;	CALL PTYCLZ

;RETURNS +1: FAILURE
;	 +2: SUCCESS

;ON FAILURE, IF BLOCKING IS NECESSARY, BLKF IS SET AND T1 CONTAINS
;(LINE NUMBER,,ADDRESS OF TEST ROUTINE)

PTYCLZ:	STKVAR <PTYCLN>
	HLRZ 2,DEV
	CALL PTYTTY		;GET LINE NUMBER
	MOVEM T2,PTYCLN		;SAVE LINE NUMBER
	CALL LCKTTY		;POINT TO DYNAMIC DATA
	 JRST [	CALL ULKTTY	;NOT ACTIVE
		JRST PTYCL1]	;SKIP DEALLOCATION AND DETACH
	CALL CLRPRM		;CLEAR PERMANENT BIT SO DEASSIGN WILL HAPPEN
	CALL ULKTTY		;ALLOW DEALLOCATION
	MOVE T2,PTYCLN		;T2/ LINE NUMBER
	CALL GTCJOB		;GET OWNING JOB
	 JRST PTYCL1		;LINE NOT ACTIVE. DON'T DETACH OR DEALLOCATE
	CAIN T3,-1		;ANY JOB?
	JRST PTYCL2		;NO. GO DEALLOCATE DATA

;A JOB EXISTS ON THIS LINE. GO DETACH IT. THIS WILL CAUSE THE TERMINAL
;DATA BLOCK TO BE DEASSIGNED

	NOSKED
	CALL NTYCOF		;CAUSE CARRIER OFF ACTION
	OKSKED
	JRST PTYCL1

;NO JOB EXISTS ON THIS LINE.  DEASSIGN TERMINAL'S DATA BASE
;AND INDICATE THAT THE PTY IS CLOSED

PTYCL2:	NOSKED			;NO INTERFERENCE UNTIL TTY AND PTY AGREE
	MOVE T2,PTYCLN		;T2/ LINE NUMBER
	CALL TTYDEA		;DEALLOCATE THE DYNAMIC DATA
	 JRST [	OKSKED
		JRST PTYCL4]	;FAILED. 
	HLRZ U,DEV		;GET PTY NUMBER
	SETZM PTYSTS(U)		;INDICATE PTY CLOSED
	OKSKED
	RETSKP

;TERMINAL SIDE IS NOT ACTIVE. INDICATE PTY IS CLOSED

PTYCL1:	HLRZ U,DEV		;GET PTY NUMBER
	SETZ IOS,		;CLEAR OPEN BIT AND ALL OTHERS
	JRST PTYRET

;UNABLE TO DEASSIGN. RETURN TO CALLER, WHICH WILL WAIT

PTYCL4:	TXZN T1,1B0		;FAILURE OR WAIT?
	RETBAD			;FAILURE. RETURN ERROR CODE
	HRL T1,T2		;WAIT. T1/(LINE NUMBER,,ROUTINE ADDRESS)
	TQO BLKF		;INDICATE WAIT NECESSARY
	RETBAD			;TAKE FAILURE RETURN
;FUNCTION MTPD FOR PTY - MTOPR

;ACCEPTS:
;	USER T2/ FUNCTION CODE
;	USER T3/ ARGUMENT OR ADDRESS OF ARGUMENT BLOCK
;	DEV/ (PTY NUMBER,,PTYDTB)

;	CALL PTMTOP

;RETURNS +1: FAILURE
;	 +2: SUCCESS

PTMTOP:	TQNN <OPNF>		;CHECK FOR OPENED
	RETBAD (CLSX1)		;NOT OPENED ERROR
	HLRZ U,DEV		;GET PTY NUMBER
	UMOVE 2,2		;GET FUNCTION CODE FROM USER
	MOVEI 3,0(2)		;MTOPR OP CODE
	CAIN 3,.MOAPI		;ASSIGN PTY INTERRUPT CHANNEL?
	JRST PTENAI		;ENABLE INTERRUPTS
	CAIN 3,.MOPIH		;PTY HUNGRY?
	JRST PTSTIH		;TEST INPUT HUNGRY
	CAIE 3,.MOBAT		;SET BATCH BIT?
	RETBAD (MTOX1)		;ILLEGAL FUNCTION
	MOVX T1,PTBAT		;INITIALIZE BATCH BIT TO 0
	ANDCAM T1,PTYSTS(U)
	XCTU [SKIPE 3]		;SETTING THE BATCH BIT?
	IORM T1,PTYSTS(U)	;YES, PTY IS A BATCH PTY
	RETSKP

;MTOPR FUNCTION .MOPIH - SEE IF PTY IS HUNGRY

;RETURNS +2: ALWAYS
;	USER T2/ 0 FOR NOT HUNGRY
;		 -1 FOR HUNGRY

PTSTIH:	MOVE T2,U		;T2/ PTY NUMBER
	CALL PTYTTY		;CONVERT TO INTERNAL LINE NUMBER
	CALL LCKTTY		;GET ADDRESS OF DYNAMIC DATA, PREVENT DEALLOCATION
	 JRST [	CALL ULKTTY	;NOT ACTIVE. ALLOW DEALLOCATION
		SETZ T1,	;ASSUME NOT HUNGRY
		SKIPN T2	;UNLESS LINE IS NOT ACTIVE AT ALL
		SETO T1,	;THEN MAKE IT HUNGRY
		JRST PTSTI1]
	CALL TTSTIH		;TEST INPUT HUNGRY ON TTY
	CALL ULKTTY		;ALLOW DEALLOCATION
PTSTI1:	UMOVEM 1,2		;RETURN ANSWER TO USER
	RETSKP

;MTOPR FUNCTION .MOAPI - ASSIGN INTERRUPT CHANNELS

PTENAI:	NOINT			
	LOCK JFNLCK		;LOCK THE JFN
	CALL REAJFN		;CHECK AND REASSIGN THE JFN IF NECESSARY
	 JFCL
	UNLOCK JFNLCK		;RELEASE THE LOCK
	OKINT
	MOVE 3,FORKX		;GET THIS FORK'S INDEX
	HRRM 3,PTYSTS(U)	;REASSIGN FORK
	LDB 3,[POINT 6,2,17]	;GET CHANNEL ASSIGNMENT
	SKIPL 3			;IS THE CHANNEL NON-NEGATIVE?
	CAIL 3,<^D36-1>		;IS IT < 35?
	RETBAD (MTOX18)		;BAD VALUE. INPUT HAS TO BE <=34
				;SO OUTPUT CAN BE <=35
	STOR 3,PTYCHN		;REMEMBER IT
	MOVX 3,PIIEN		;INPUT INTERRUPT ENABLED FLAG
	ANDCAM 3,PTYSTS(U)
	TLNE 2,(MO%WFI)		;SET IT ACCORDING TO B0 OF ARG
	IORM 3,PTYSTS(U)
	MOVX 3,POIEN		;OUTPUT INTERRUPT ENABLED FLAG
	ANDCAM 3,PTYSTS(U)
	TLNE 2,(MO%OIR)		;SET IT ACCORDING TO B1 OF ARG
	IORM 3,PTYSTS(U)
	CALL PTTINT		;SEE IF INTERRUPT NOW POSSIBLE
	RETSKP

;ROUTINE CALLED FROM SCHEDULER TO SEE IF JOB IS A BATCH JOB
;	T1/ CONTROLLING TERMINAL NUMBER

CHKBCH::CALL CHKPTY		;SEE IF A PTY
	 RET			;NO. ERGO NOT BATCH
	MOVX T2,PTBAT		;GET BATCH BIT
	TDNN T2,PTYSTS(T1)	;IS THIS A BATCH PTY?
	RET			;NO
	RETSKP			;IS BATCH

;PTYINI - ROUTINE CALLED FROM OPENF TO INITIALIZE THE PTY PARAMETERS

;ACCEPTS:
;	DEV/ UNIT,,CODE

;	CALL PTYINI

;RETURNS +1: ALWAYS

;INITIALIZES VALUES FOR THE TERMINAL ASSOCIATED WITH THE GIVEN PTY
;THIS IS DONE BEFORE THE JOB IS CREATED ON THE LINE SO THAT THE OWNER
;OF THE PTY CAN CONTROL THE LINE.  OPENING THE PTY HAS CAUSED THE
;ASSOCIATED TERMINAL TO HAVE PERMANENT DYNAMIC DATA, WHICH WILL
;BE DEALLOCATED WHEN THE PTY IS CLOSED

PTYINI::HLRZ B,DEV		;GET PTY UNIT
	CALL PTYTTY		;CONVERT TO LINE NUMBER
	MOVEI A,.TTDES(B)	;GET DESIGNATOR (400000+N)
	MOVE B,NORMTF		;GET NORMAL SETTING
	SFMOD			;SET MODES
	STPAR			;AND THESE AS WELL
	MOVEI B,.TTIDL		;SET IT TO BE "IDEAL" TERMINAL
	STTYP			;SET THE TYPE
	DMOVE B,TTICB1		;DEFAULT CONTROL ACTIONS
	SFCOC
	HRLI A,(TL%CRO+TL%COR+TL%SAB+TL%STA) ;BREAK ALL LINKS AND SET REFUSE
	MOVEI B,-1		;ALL REMOTES
	TLINK			;GO DO IT
	 JFCL
	RET			;AND DONE

;GET FORK OF OWNER OF PTY
; 1/ TTY NUMBER
;	CALL PTYGFK
; RETURN +1: NO PTY FOR THAT TTY
; RETURN +2: SUCCESS,
;		T1/ FORKX OF OWNER

PTYGFK::CALL CHKPTY		;GET PTY NUMBER
	 RETBAD			;NO
	PUSH P,U		;YES. SAVE AC
	MOVE U,T1		;PUT PTY NUMBER IN NECESSARY AC
	LOAD 1,PTYFRK		;GET FORK (USES AC U)
	POP P,U			;RESTORE U
	RETSKP

;ROUTINE TO SEE IF A PTY IS A BATCH PTY
;ACCEPTS IN T1/	TTY NUMBER
;	CALL PTYGBB
;RETURNS +1:	NOT A PTY
;	 +2:	0 = NOT BATCH
;		-1 = BATCH PTY

PTYGBB::CALL CHKPTY		;GET PTY NUMBER
	 RETBAD			;NO. RETURN FAILURE
	MOVE T2,PTYSTS(T1)	;YES, GET STATUS WORD
	TXNN T2,PTBAT		;BATCH BIT ON?
	TDZA T1,T1		;NO
	SETO T1,		;YES
	RETSKP			;RETURN

;CHECK IF ACCESS TO TTY IS OK BECAUSE IT IS CONTROLLED BY PTY OF
; THIS JOB.
; 1/ TTY #
; RETURNS +1, 1/ 0= FALSE
;	-1 = TRUE (ACCESS OK)

PTCHKA::CALL CHKPTY		;GET PTY NUMBER
	 JRST PTCHK1		;NOT A PTY
	SAVEAC <T2>		;1000 Preserve T2 (paranoia)
	MOVX T2,POPEN
	TDNN T2,PTYSTS(T1)	;PTY IS OPEN?
	JRST PTCHK1		;NO
	HRRZ T2,PTYSTS(T1)	;OWNING FORK
	HLRZ T2,FKJOB(T2)	;OWNING JOB
	CAME T2,JOBNO		;IS OWNING JOB SAME AS THIS JOB?
PTCHK1:	TDZA 1,1		;NO, RETURN FALSE
	SETO 1,			;RETURN TRUE
	RET

;FIND JOB NUMBER OF JOB CONTROLLING PTY
; 1/ TTY NUMBER
; RETURN +1: 1/ JOB NUMBER, OR -1 IF NOT PTY OR PTY NOT OPENED

PTGETJ::CALL CHKPTY		;GET PTY NUMBER
	 JRST PTGJ1		;NOT A PTY
	MOVX T2,POPEN
	TDNN T2,PTYSTS(T1)	;PTY OPEN?
	JRST PTGJ1		;NO
	HRRZ T2,PTYSTS(T1)	;GET CONTROLLING FORK
	HLRZ T1,FKJOB(T2)	;GET JOB NUMBER
	RET

PTGJ1:	SETO T1,		;INDICATE NOT A PTY OR NOT OPEN
	RET

	RESCD

;FOLLOWING CODE RESIDENT BECAUSE CALLED FROM TTYSRV AT PI LEVEL

;ACCEPTS:
;	T1/ PTY NUMBER

;CALLED WHEN LINE IS GOING INTO INPUT WAIT

PTYFIN::PUSH P,IOS
	PUSH P,U
	MOVE U,T1		;GET PTY NUMBER IN CORRECT AC
	MOVX IOS,PIIEV		;INPUT EVENT FLAG
	JRST PTYF1

;ACCEPTS:
;	T1/ PTY NUMBER

;CALLED WHEN STARTING OUTPUT TO A LINE

PTYFOU::PUSH P,IOS
	PUSH P,U
	MOVE U,T1
	MOVX IOS,POIEV		;OUTPUT EVENT FLAG
PTYF1:	IORB IOS,PTYSTS(U)	;SET APPROPRIATE FLAG
	CALL PTTINT		;SEE IF INTERRUPT NOW POSSIBLE
	POP P,U
	POP P,IOS
	RET

;INITIATE INTERRUPT IF POSSIBLE

;ACCEPTS:
;	U/ PTY NUMBER

PTTINT:	PUSH P,1
	PUSH P,2
	SETCM 3,PTYSTS(U)	;GET COMPLEMENTED FLAGS
	TXNN 3,PIIEV+PIIEN	;SEE IF INPUT ENABLE AND EVENT BOTH SET
	JRST [	MOVX IOS,PIIEV	;YES, CLEAR EVENT
		ANDCAB IOS,PTYSTS(U)
		LOAD 1,PTYCHN	;DESIGNATED CHANNEL
		MOVEI 2,0(IOS)	;DESIGNATED FORK
		CALL PSIRQ	;REQUEST INTERRUPT
		JRST .+1]
	SETCM 3,PTYSTS(U)	;GET COMPLEMENTED FLAGS
	TXNN 3,POIEV+POIEN	;SEE IF OUTPUT ENABLE AND EVENT BOTH SET
	JRST [	MOVX IOS,POIEV	;YES, CLEAR EVENT
		ANDCAB IOS,PTYSTS(U)
		LOAD 1,PTYCHN	;ON DESIGNATED CHANNEL +1
		ADDI 1,1
		MOVEI 2,0(IOS)	;TO DESIGNATED FORK
		CALL PSIRQ	;REQUEST INTERRUPT
		JRST .+1]
	POP P,2
	POP P,1
	RET

;SKIP IF PTY OPEN
;GIVEN TTY LINE NUMBER IN 2

PTYSKO::PUSH P,IOS
	PUSH P,T1
	MOVE T1,T2
	CALL TTYPTY
	MOVE IOS,PTYSTS(T1)
	TQNE <POPEN>		;OPEN?
	JRST [	POP P,T1	;YES. TAKE SUCCESS RETURN
		POP P,IOS
		RETSKP]
	POP P,T1		;NO. TAKE FAILURE RETURN
	POP P,IOS
	RET
	SUBTTL RESCAN JSYS

	SWAPCD
.RSCAN::MCENT
	TLNE 1,-1		;BITS IN L.H.?
	JRST RSC0		;YES, ASSUME BYTE POINTER
	CAIL A,RFNLEN		;LEGAL FUNCTION?
	RETERR RSCNX2		;NO, "RSCAN FUNCTION CODE OUT OF RANGE"
	JRST @RFNTAB(1)		;IN RANGE, DO IT.

;DISPATCH TABLE FOR RSCAN FUNCTIONS

RFNTAB:	IFIW!REINIT		;0 MEANS MAKE BUFFER AVAILABLE FOR INPUT
	IFIW!RECNT		;1 MEANS COUNT CHARACTERS LEFT TO READ
RFNLEN==.-RFNTAB

RECNT:	MOVEI 1,0		;START WITH COUNT OF 0
	SKIPN 2,RSCNPT		;READING FROM RESCAN BUFFER?
	JRST RSC5		;NO, RETURN COUNT OF 0
	JRST RSC4		;YES, GO COUNT REMAINING CHARS

REINIT:	SKIPN 2,RSCNBP		;REINITIALIZE THE POINTER
	JRST RSC5		;NO BYTE POINTER, RETURN 0
	HRLI 2,(POINT 7,0,34)	;SET UP BYTE POINTER
	MOVEM 2,RSCNPT
	SKIPA			;SKIP ADDI FIRST TIME
RSC6:	ADDI 1,1		;COUNT A CHAR
RSC4:	ILDB 3,2		;GET NEXT CHAR
	JUMPN 3,RSC6		;END YET?
RSC5:	UMOVEM 1,1		;YES, RETURN COUNT TO USER
	SMRETN

RSC0:	NOSKED			;SETTING UP A NEW BUFFER
	NOINT			;THIS TOO
	SETZM RSCNPT		;ZERO PREVIOUS POINTER
	MOVE T2,RSCNBP		;GET PREVIOUS BUFFER
	SETZM RSCNBP		;NONE HERE NOW
	OKSKED
	JUMPE T2,RSC1		;IF NO BUFFER, GO ON
	MOVEI T1,JSBFRE		;YES, RELEASE ITS SPACE
	CALL RELFRE
RSC1:	OKINT
	UMOVE Q3,1		;GET STRING POINTER
	TLC Q3,-1		;LH = -1?
	TLCN Q3,-1
	HRLI Q3,(POINT 7,0)	;YES, MAKE IT A VALID STRING POINTER
	MOVEI T4,RSCMXC		;SET UP MAX COUNT
	MOVEI T2,^D11		;START WITH ENOUGH CHARACTERS FR HEADER
	MOVE T3,Q3		;GET STARTING POINTER
RSC2:	XCTBU [ILDB T1,T3]	;GET A CHARACTER
	SOJLE T4,[RETERR (RSCNX1)]
	SKIPE T1		;FOUND THE NULL YET?
	AOJA T2,RSC2		;NO, COUNT UP THIS CHARACTER
	MOVEI P3,-^D10(T2)	;GET COUNT OF CHARACTERS IN STRING
	IDIVI T2,5		;GET WORDS FOR BUFFER SPACE
	NOINT			;GUARD AGAINST DATA BASE LOSSAGE
	CALL ASGJFR		;GET SPACE FOR BUFFER
	 RETERR ()		;NOT ENOUGH ROOM
	HRRZM T1,RSCNBP		;SAVE THE POINTER TO THE BUFFER
	HRLI T1,(POINT 7,0,34)	;SET UP A POINTER TO IT
RSC3:	XCTBU [ILDB T2,Q3]	;GET NEXT CHARACTER
	IDPB T2,T1		;STORE IT IN THE BUFFER
	SKIPE T2		;FOUND THE NULL YET?
	SOJG P3,RSC3		;NO, LOOP BACK FOR REST
	MOVEI T2,0		;END WITH A NULL
	DPB T2,T1
	UMOVEM Q3,1		;STORE THE UPDATED STRING POINTER
	SMRETN			;DONE
;	TTY DEVICE FUNCTIONS

;DEVICE DEPENDENT ROUTINES. TO DO CERTAIN FUNCTIONS, THE RH OF DEV
;CONTAINS THE NAME OF A TABLE SUCH AS TTYDTB, AND A ROUTINE IS CALLED
;VIA 'CALL @FOO(DEV)', WHERE FOO IS A SYMBOL FOR AN OFFSET INTO THE 
;TABLE. THE SYMBOLS ARE DEFINED IN PROLOG. IN THE COMMENTS BELOW,
;THE OFFSET IS INDICATED ALONG WITH THE PURPOSE OF THE ROUTINE

TTYDTB::DTBDSP (TTYSET)		;DLUKD - DIRECTORY SETUP
REPEAT OPEND-1,<DTBBAD (DESX9)>
	DTBDSP (TTYOPN)		;OPEND - OPEN FILE
	DTBDSP (TTYIN)		;BIND - BYTE INPUT
	DTBDSP (TTYOUT)		;BOUTD - BYTE OUTPUT
	DTBDSP (TTYCLZ)		;CLOSD - CLOSE FILE
	DTBBAD (DESX9)		;REND - RENAME
	DTBBAD (DESX9)		;DELD - DELETE FILE
	DTBBAD (DUMPX6)		;DMPID - DUMP MODE INPUT
	DTBBAD (DUMPX6)		;DMPOD - DUMP MODE OUTPUT
	DTBBAD (DESX9)		;MNTD - MOUNT DEVICE
	DTBBAD (DESX9)		;DSMD - DISMOUNT DEVICE
	DTBBAD (DESX9)		;INDD - INITIALIZE DIRECTORY OF DEVICE
	DTBDSP (TTMTOP)		;MTPD - DO MTAPE OPERATION
	DTBDSP (TTGDST)		;GDSTD - GET DEVICE STATUS
	DTBBAD (DESX9)		;SDSTD - SET DEVICE STATUS
	DTBSKP			;RECOUT - FORCE RECORD OUT (SOUTR)
	DTBDSP (RFTADN)		;RFTADD - READ FILE TIME AND DATE
	DTBDSP (SFTADN)		;SFTADD - SET FILE TIME AND DATE
	DTBDSP (BIOINP)		;SET JFN FOR INPUT
	DTBDSP (BIOOUT)		;SET JFN FOR OUTPUT
	DTBBAD (GJFX49)		;CHECK ATTRIBUTE

	DTBLEN==:.-TTYDTB	;GLOBAL LENGTH OF DISPATCH TABLE

;DLUKD FUNCTION FOR TTY - DIRECTORY SETUP

TTYSET:	TQO <NVERF,NNAMF>
	RETBAD (GJFX32)

;OPEND FUNCTION FOR TTY - OPEN FILE

;ACCEPTS:
;	JFN/ JOB FILE NUMBER
;	DEV/ (UNIT NUMBER,,DISPATCH ADDRESS)

;	CALL TTYOPN

;RETURNS +1: FAILURE
;	 +2: SUCCESS

TTYOPN:	STKVAR <TTYOPX>
	CALL CHKAPD		;FIX APPEND BIT
TTYOP1:	CALL CKJFTT		;SEE IF JFN IS FOR 'TTY:'
	 RETSKP			;YES. THIS ALWAYS SUCCEEDS
	CALL LCKDVL		;LOCK THE DEVICE TABLES
	CALL FNDUNT		;GET INDEX INTO DEVICE TABLE FOR THIS UNIT
	MOVEM A,TTYOPX		;SAVE INDEX INTO DEVICE TABLES
	HRRZ B,A		;GET INTO CORRECT AC
	CALL DEVAV		;IS THIS DEVICE AVAILABLE TO US?
	 RETBAD (OPNX7,<UNLOKK DEVLKK
			OKINT>) ;NO. RETURN NOT AVAILABLE
	HLRZ B,DEV		; Get tty line number
	CALL TTYASO		;ASSIGN TERMINAL IF POSSIBLE
	 JRST TTYOP2		;ERROR. GO SEE WHAT TO DO
	HRRZ A,TTYOPX		;GET INDEX INTO DEVICE TABLES
	MOVE B,JOBNO		;NO. STORE JOB NUMBER IN DEVUNT
	HRLM B,DEVUNT(A)
	MOVX B,DV%OPN		;AND INDICATE OPEN IN DEVCHR
	IORM B,DEVCHR(A)
TTYOP3:	UNLOKK DEVLKK		;UNLOCK DEVICE TABLES
	OKINT
	TQO <SIZF>
	RETSKP

;FAILED. SEE IF GIVING UP OR WAITING

TTYOP2:
	UNLOKK DEVLKK		;UNLOCK DEVICE TABLES
	OKINT
	TXZN T1,1B0		;WAITING?
	RETBAD			;NO. FAIL
	HRL T1,T2		;GET LINE NUMBER
	MDISMS			;WAIT
	JRST TTYOP1		; AND GO TRY AGAIN
;BIND FUNCTION FOR TTY - BYTE INPUT

;ACCEPTS:
;	DEV/ (UNIT,,DISPATCH ADDRESS)
;	JFN/ JFN OR -1 OR 400000+LINE NUMBER

;	CALL TTYIN

;RETURNS +1: ALWAYS,
;		T1/ THE CHARACTER

;GETS ONE INPUT CHARACTER FOR THE LINE. IF NONE IS AVAILABLE, BLOCKS.

;THERE'S A BUG IN THE FOLLOWING CODE.  IF JFN CONTAINS -1, CODE
;KNOWS TO CHECK RSCAN BUFFER.  HOWEVER, NOTICE HOW WHEN JFN CONTAINS
;REAL JFN FOR "TTY", RSCAN BUFFER ISN'T CHECKED!

TTYIN:	CAIE JFN,-1		;CONTROLLING TTY?
	JRST [	CAIGE JFN,400000;NO, REAL JFN?
		JRST TTYIN2	;YES
		JRST TTYIN0]	;NO, TERMINAL DESIGNATOR
	MOVE A,JOBNO		;SET UP LINE NUMBER
	HLL DEV,JOBPT(A)
	HLRZ B,JOBPT(A)		;GET LINE NUMBER
	CAIE B,-1		;NOW ATTACHED?
TTYIN1:	CALL CKBJFN		;HAS A BKJFN BEEN DONE?
	 SKIPA			;NO.
	JRST TTYINX		;YES. GO USE THAT CHARACTER INSTEAD OF RSCAN
	SKIPN RSCNPT		;RESCAN PTR SET?
	JRST TTYINX		;NO
	ILDB A,RSCNPT		;YES, GET CHAR FROM RESCAN BUFFER
	JUMPN A,R		;USE IT UNLESS IT'S NULL
	NOINT			;NO INTERRUPTS WHILE RELEASING FREE SPACE
	NOSKED			;OWN SYSTEM
	SETZM RSCNPT		;FLUSH POINTER
	MOVE B,RSCNBP		;GET CURRENT RSCAN BUFFER POINTER
	SETZM RSCNBP		;NO POINTER NOW
	OKSKED
	MOVEI A,JSBFRE		;RELEASE THE OLD BUFFER
	SKIPE B			;IF NO BUFFER, ALL DONE
	CALL RELFRE		;RELEASE IT
	OKINT			;OK NOW THAT FREE SPACE RETURNED
	JRST TTYINX		;REPARSE DONE, GO GET REAL CHARACTER

;Here when we know JFN contains a real JFN.

TTYIN2:	LDB B,[POINT 4,STS,35]	;GET MODE OF OPEN
	JUMPE B,[LDB B,PBYTSZ	;IF ZERO, USE NORMAL FOR THE TERMINAL
		CAIE B,8	;WAS OPENED WITH BYTE SIZE OF 8?
		JRST TTYINX	;NO. ALLOW TRANSLATION
		JRST TTYINB]	;YES. ASSUME BINARY
	CAIE B,10		;OPENED IN BINARY MODE
TTYINX:	SKIPA D,[TCI]		;CALL INPUT ROUTINE THAT ALLOWS TRANSLATION
TTYINB:	MOVEI D,TCIB		;CALL INPUT ROUTINE FOR BINARY INPUT
	HLRZ 2,DEV		;GET INTERNAL LINE NUMBER
	CAIN 2,-1		;LINE NUMBER AVAILABLE?
	CALL TTYATW		;NO, WAIT FOR ATTACH
	CALL LCKTTY		;GET ADDRESS OF DYNAMIC DATA, PREVENT DEALLOCATION
	JRST [	CALL ULKTTY	;NOT ACTIVE. ERROR
		TQO ERRF	;INDICATE FAILURE TO CALLER
		RET]
	CALL 0(D)
	 JRST TTYIN		;BLOCKED. GO TRY AGAIN (TTYSRV UNLOCKED DATA)
	CALL ULKTTY		;ALLOW DEALLOCATION
	CAIL JFN,400000		;JFN OR 400000+LINE NUMBER?
	 RET			;TERMINAL DESIGNATOR
	HLLZ B,FILBYT(JFN)	;JFN. GET BYTE SIZE FROM OPENF
	TLZ B,770000		;POINT TO END OF AC
	HRRI B,A		;FORM BYTE POINTER TO GET CHARACTER
	LDB A,B			;GET THE NUMBER OF BITS ASKED FOR
	RET			;RETURN CHARACTER OF CORRECT SIZE

;Come here when 400000+n is given

TTYIN0:	HRRZ A,FORKN
	LOAD A,FRKTTY,(A)	;GET OUR CONTROLLING TERMINAL
	CAIE A,-1		;DO WE NOT HAVE ONE?
	CAME A,JFN		;OR WE HAVE ONE BUT JFN DOESN'T MATCH?
	JRST TTYINX		;NO RESCAN, SINCE RANDOM TERMINAL DESIGNATOR
	MOVEI B,-.TTDES(JFN)	;READING FROM OUR PROCESS CTTY, SO
	JRST TTYIN1		;GO CHECK RESCAN DATA

;BOUTD FUNCTION FOR TTY - BOUT OUTPUT

;ACCEPTS:
;	T1/ CHARACTER
;	DEV/ (UNIT,,DISPATCH ADDRESS)

;	CALL TTYOUT

;RETURNS +1: ALWAYS

;OUTPUTS ONE CHARACTER TO THE SPECIFIED TERMINAL. 

TTYOUT:	HLRZ B,JFN		;Get left half of designator
	CAIN B,600000+.DVTTY	;If universal device designator specifies
	 JRST TTYOUX		;  terminal, then terminal number in LH(DEV)
	CAIL JFN,400000		;JFN OR 400000 + LINE NUMBER?
	 JRST TTYOUX		;400000 + LINE NUMBER
	HLLZ B,FILBYT(JFN)	;GET BYTE SIZE FROM OPENF
	TLZ B,770000		;POINT TO END OF AC
	HRRI B,A		;CREATE BYTE POINTER TO CHARACTER IN AC
	LDB A,B			;GET AS MANY BITS AS OPENED FOR
	LDB B,[POINT 4,STS,35]	;GET MODE IN WHICH OPENED
	JUMPE B,[LDB B,PBYTSZ	;IF NORMAL MODE, GET BTYE SIZE OPENED FOR
		CAIE B,8	;OPENED FOR 8-BIT BYTES?
		JRST TTYOUX	;NO. ALLOW TRANSLATION
		JRST TTYOUB]	;YES. BINARY OUTPUT
	CAIE B,10		;NOT NORMAL MODE. BINARY?
TTYOUX:	SKIPA D,[TCO]		;CALL ROUTINE THAT ALLOWS TRANSLATION
TTYOUB:	MOVEI D,TCOB		;CALL ROUTINE FOR BINARY OUTPUT
	HLRZ B,DEV		;GET LINE NUMBER
	CAIN 2,-1		;LINE NUMBER AVAILABLE?
	CALL TTYATW		;NO, WAIT FOR ATTACH
	CALL LCKTTY		;GET ADDRESS OF DYNAMIC DATA, PREVENT DEALLOCATION
	JRST [	CALL ULKTTY	;NOT ACTIVE. ERROR
		TQO ERRF	;INDICATE ERROR TO CALLER
		RET]
	CALL 0(D)		;CALL OUTPUT ROUTINE IN TTYSRV
	CALLRET ULKTTY		;ALLOW DEALLOCATION

;SOUT FUNCTION FOR TTY - SOUT OUTPUT

;ACCEPTS:
;	DEV/ (UNIT,,DISPATCH ADDRESS)

;	CALL TTYBLO

;RETURNS +1 BLOCK OR ERROR
;RETURNS +2 FINISHED

;OUTPUTS STRING TO THE SPECIFIED TERMINAL. 

TTYBLO::HLRZ B,DEV		;GET LINE NUMBER
	CAIN 2,-1		;LINE NUMBER AVAILABLE?
	CALL TTYATW		;NO, WAIT FOR ATTACH
	CALL LCKTTY		;GET ADDRESS OF DYNAMIC DATA, PREVENT DEALLOCATION
	JRST [	CALL ULKTTY	;NOT ACTIVE. ERROR
		TQO ERRF	;INDICATE ERROR TO CALLER
		RET]
	MOVSI Q3,-1000		;SET UP A COUNTER
TTYOLP:	XCTBUU [ILDB A,2]	;GET A BYTE
	XCTU [SKIPN 3]		;CHECK FOR NO CHARACTERS
	JUMPE A,TTYOLX		;FINISHED
	
	CAIL JFN,400000		;JFN OR 400000 + LINE NUMBER?
	 JRST TTYOUY		;400000 + LINE NUMBER
	HLLZ D,FILBYT(JFN)	;GET BYTE SIZE FROM OPENF
	TLZ D,770000		;POINT TO END OF AC
	HRRI D,A		;CREATE BYTE POINTER TO CHARACTER IN AC
	LDB A,D			;GET AS MANY BITS AS OPENED FOR
	LDB D,[POINT 4,STS,35]	;GET MODE IN WHICH OPENED
	JUMPE D,[LDB D,PBYTSZ	;IF NORMAL MODE, GET BTYE SIZE OPENED FOR
		CAIE D,8	;OPENED FOR 8-BIT BYTES?
		JRST TTYOUY	;NO. ALLOW TRANSLATION
		JRST TTYOUZ]	;YES. BINARY OUTPUT
	CAIE D,10		;NOT NORMAL MODE. BINARY?
TTYOUY:	SKIPA D,[TCO]		;CALL ROUTINE THAT ALLOWS TRANSLATION
TTYOUZ:	MOVEI D,TCOB		;CALL ROUTINE FOR BINARY OUTPUT
	PUSH P,A		;SAVE CHARACTER FOR DONE CHECK
	CALL 0(D)		;CALL OUTPUT ROUTINE IN TTYSRV
	TQZN <BLKF>		;CHECK FOR BLOCKED AND CLEAR
	TQNE <ERRF>		;ERROR?
	JRST [	POP P,A		;UNLOCK AND RETURN ERROR/BLOCKED
		JRST ULKTTY]
	EXCH B,0(P)		;SET CHARACTER FOR DONE CHECK
	CALL SIONXT		;CHECK FOR END OF STRING
	JRST [	POP P,B		;RESTORE DYNAMIC ADDRESS
		AOBJN Q3,TTYOLP	;HAVE WE DONE THIS 1000 TIMES?
		CALL ULKTTY	;YES, TAKE A BREAK
		JRST TTYBLO]	;AND CONTINUE
	POP P,B			;RESTORE DYNAMIC ADDRESS
TTYOLX:	AOS 0(P)		;GIVE SKIP RETURN
	CALLRET ULKTTY		;ALLOW DEALLOCATION

;TTYATW - WAIT UNTIL JOB HAS A CONTROLLING TERMINAL

;	CALL TTYATW

;RETURNS +1: ALWAYS
;		DEV/ (CONTROLLING TERMINAL,,UNCHANGED)
;		T2/ CONTROLLING TERMINAL

;PRESERVES T1

TTYATW:	PUSH P,A
	MOVE A,JOBNO
	MOVEI A,JOBPT(A)	;CONSTRUCT PTR TO JOBPT
	CALL DISGE		;DISMISS UNTIL IT'S POSITIVE
	HLL DEV,0(A)		;GET NEW CONTROLLING TTY NUMBER
	POP P,A
	HLRZ 2,DEV		;GET LINE NUMBER
	CAIN 2,-1		;BE SURE WE HAVE ONE
	JRST TTYATW		;STILL DETACHED
	RET

;GDSTD - GET DEVICE DEPNEDENT STATUS

TTGDST:	HLRE T2,DEV		;GET TTY NUMBER
	JUMPL T2,RFALSE		;IF DETACHED, GIVE UP NOW
	CALL LCKTTY		;LOCK THE TTY
	 JRST [	CALL ULKTTY	;ERROR
		CALLRET RFALSE]	;AND DONE FOR NOW
	CALL TTGSTS		;GET STATUS IN T1
	CALL ULKTTY		;UNLOCK THE TTY
	RET			;AND DONE
;CLOSD FUNCTION FOR TTY - CLOSE FILE

;ACCEPTS:
;	DEV/ (UNIT NUMBER,,DISPATCH ADDRESS)

;	CALL TTYCLZ

;RETURNS +1: FAILURE
;	 +2: SUCCESS

TTYCLZ:	STKVAR <TTYCLX,TTFLX>
TTYCL3:	MOVEM T1,TTFLX		;Save flags for later
	CALL CKJFTT		;SEE IF JFN FOR 'TTY:'
	 RETSKP			;YES. THIS ALWAYS SUCCEEDS
	CALL LCKDVL		;LOCK THE DEVICE LOCK, GO NOINT
	CALL FNDUNT		;GET POINTER TO DEVICE TABLES
	MOVEM T1,TTYCLX		;SAVE IT
	HRRZ T2,T1		;T2/ POINTER TO DEVICE TABLES
	CALL DEVAV		;SEE IF DEVICE AVAILABLE TO THIS JOB
	 JRST TTYCL4		;NO. RETURN FAILURE
	HLRZ T2,DEV		;YES. T2/ LINE NUMBER
	CALL GTCJOB		;GET CONTROLLING JOB FOR THIS TERMINAL
	 JRST TTYCL4		;NONE. SHOULDN'T HAPPEN
	CAME T3,JOBNO		;IS IT THIS JOB?
	JRST TTYCL4		;NO. SHOULDN'T HAPPEN
	MOVE T1,TTYCLX		;GET INDEX TO DEVICE TABLES
	JN DV%ASN,DEVCHR(T1),TTYCL1 ;IF ALSO ASSIGNED, DON'T DEALLOCATE DATA
	HLRZ T1,DEV		;Create a terminal designator
	ADDI T1,.TTDES
	MOVE T2,TTFLX		;Get the flags
	TXNN T2,CZ%ABT		;See if this is an abort close
	IFSKP.
	  TQNE <WRTF>		;Yes - opened for write?
	  CFOBF			;Yes - clear output
	  TQNE <READF>	;Opened for read?
	  CFIBF			;Yes - clear input
	ELSE.
	  TQNN <WRTF>		;If not opened for output
	  IFSKP.
	    SOBE		;See if output buffer is empty
	    IFNSK.
	      UNLOKK DEVLKK	;Output to wait for, release our lock
	      OKINT		;and undo DEVLKK NOINT
	      HLL T1,DEV	;Load TTOBET argument
	      HRRI T1,TTOBET	;and scheduler test to do DOBE stuff
	      TQO <BLKF>	;Inform caller we should block
	      RET		;and return to caller
	    ENDIF.
	  ENDIF.
	ENDIF.
	HLRZ T2,DEV		;T2/ LINE NUMBER
	CALL TTYDEA		;DEALLOCATE DYNAMIC DATA FOR THIS LINE
	 JRST TTYCL2		;FAILED. GO WAIT IF NECESSARY
	MOVE T1,TTYCLX		;POINT TO DEVICE TABLES
	HRROS DEVUNT(T1)	;INDICATE NO JOB OWNS THE DEVICE
TTYCL1:	SETZRO DV%OPN,DEVCHR(T1) ;INDICATE NO LONGER OPEN
	UNLOKK DEVLKK		;UNLOCK THE DEVICE LOCK
	OKINT			;LCKDVL DID A NOINT
	RETSKP			;SUCCESS

;TTYDEA FAILED. IF BIT 0 IS SET, AC 1 HAS ADDRESS OF SCHEDULER TEST

TTYCL2:	UNLOKK DEVLKK		;UNLOCK THE DEVICE LOCK
	OKINT			;LCKDVL DID A NOINT
	TXZN T1,1B0		;IS THIS A TEST ROUTINE?
	RETBAD			;NO. RETURN FAILURE
	HRL T1,T2		;T1/ (LINE NUMBER,,ROUTINE ADDRESS)
	TQO BLKF		;INDICATE BLOCK
	RETBAD

;DEVICE IS NOT AVAILABLE TO THIS JOB

TTYCL4:	UNLOKK DEVLKK		;UNLOCK THE DEVICE LOCK
	OKINT			;LCKDVL DID A NOINT
	RETBAD (DEVX2)

;MTPD FUNCTION FOR TTY - MTOPR

TTMTOP:	TQNN <OPNF>		;CHECK TO SEE IF OPENED
	RETBAD (CLSX1)		;NO ERROR
	HLRE 2,DEV		;GET LINE NUMBER
	JUMPL T2,RSKP		;RETURN IF NOT CONTROLLING TERMINAL
	XCTU [HRRZ 3,2]		;GET MTOPR OP CODE
	MOVSI T1,-TTMTTB	;FORM AOBJN POINTER
TTMTO1:	HLRZ T4,TTMTFC(T1)	;GET CODE
	CAIN T4,0(T3)		;IS THIS THE ONE?
	JRST [	HRRZ T3,TTMTFC(T1) ;GET DISPATCH ADDRESS
		JRST 0(T3)]	;GO DO IT
	AOBJN T1,TTMTO1		;DO ALL OF THEM
	RETBAD (MTOX1)		;ERROR

;MTOPR DISPATCH TABLE

TTMTFC:	.MOPIH,,TTMHNG		;TEST INPUT HUNGRY
	.MOSPD,,TTMSSP		;SET LINE SPEED
	.MORSP,,TTMRSP		;READ LINE SPEED
	.MOSLW,,TTMSWD		;SET LINE WIDTH
	.MORLW,,TTMRWD		;READ LINE WIDTH
	.MOSLL,,TTMSLN		;SET LINE LENGTH
	.MORLL,,TTMRLN		;READ LINE LENGTH
	.MOSNT,,TTMSNT		;SET TTY MSG STATUS
	.MORNT,,TTMRNT		;READ TTY MSG STATUS
	.MOSIG,,TTMSIG		;SET "IGNORE INPUT" BIT
	.MORBM,,TTMRBM		;READ THE WAKE UP MASK
	.MOSBM,,TTMSBM		;SET THE WAKE UP MASK
	.MORFW,,TTMRFW		;READ THE FIELD WIDTH
	.MOSFW,,TTMSFW		;SET THE FIELD WIDTH
	.MOXOF,,TTXXX		;SET/CLEAR XON/XOFF PROCESSING
	.MORXO,,TTXXXR		;READ BIT SETTING
	.MORLC,,TTMRLC		;READ LINE COUNTER
	.MOSLC,,TTMSLC		;SET LINE COUNTER
	.MORLM,,TTMRLM		;READ LINE MAXIMUM
	.MOSLM,,TTMSLM		;SET LINE MAXIMUM
	.MOTPS,,TTLIPS		;SET PSI FOR SPECIFIC LINE 
	.MOPCS,,TTPCS		;SET PAGE PAUSE CHARACTER
	.MOPCR,,TTPCR		;READ PAGE PAUSE CHARACTER
	.MOFCI,,TTMFCI		;221 READ FULL INPUT CHARACTER

TTMTTB==.-TTMTFC		;LENGTH OF TABLE

;FUNCTION .MOPIH OF MTOPR - SEE IF LINE IS HUNGRY

;RETURNS +2: ALWAYS
;		T1/ 0 IF NOT HUNGY
;		   -1 IF HUNGRY

TTMHNG:	CALL LCKTTY		;GET ADDRESS OF DYNAMIC DATA, PREVENT ALLOCATION
	 JRST [	CALL ULKTTY	;NOT ACTIVE. ALLOW DEALLOCATION
		SETZ T1,	;ASSUME NOT HUNGRY
		SKIPN T2	;UNLESS LINE IS NOT ACTIVE AT ALL
		SETO T1,	;THEN MAKE IT HUNGRY
		JRST TTMHN1]
	CALL TTSTIH		;SEE IF HUNGRY
	CALL ULKTTY		;ALLOW DEALLOCATION
TTMHN1:	UMOVEM T1,2		;STORE RESULT
	RETSKP			;AND DONE

;FUNCTION .MOSPD OF MTOPR - SET TERMINAL SPEED

;ACCEPTS:
;	T2/ LINE NUMBER
;	T3/ (INPUT SPEED,,OUTPUT SPEED)

TTMSSP:	CALL TTMLOK		;CHECK FOR ACCESS TO THIS TTY
	 RETBAD (MTOX7)		;CAN'T DO IT
	CALL TTSSPD		;GO SET SPEED
	 RETBAD()		;FAILED (ACJ rejection)
	RETSKP			;AND DONE

;FUNCTION .MORSP OF MTOPR - GET LINE SPEED

TTMRSP:	CALL TTRSPD		;GO READ SPEED
	RETSKP			;DONE


;TTSIG - SET "IGNORE INPUT" BIT FOR A LINE
;MUST BE WHEEL OR OPERATOR TO DO THIS

TTMSIG:	MOVX T1,SC%OPR!SC%WHL	;MUST BE WHEEL OR OPERATOR TO DO THIS
	TDNN T1,CAPENB		;IS IT?
	RETBAD (MTOX7)		;CAN'T DO IT
	UMOVE T1,T3		;GET NEW SETTING
	CALL TTSSIG		;GO SET BIT IN LINE'S STATIC DATABASE
	RETSKP			;DONE, RETURN SUCCESS

;LOCAL ROUTINE TO VERIFY ACCESS TO TTY
;CHECKS IF TTY IS "ACTIVE" OR IF CALLER IS WHEEL OR OPERATOR.
;IF TTY IS ACTIVE, THEN THIS PROCESS MUST HAVE IT ASSIGNED OR
;OPENED.

TTMLOK:	SAVET			;SAVE ALL REGS
	MOVX T1,SC%WHL!SC%OPR	;SEE IF WHEEL OR OPERATOR
	TDNE T1,CAPENB		;IS IT?
	RETSKP			;YES. ALLOW ACCESS THEN
	CALL LCKTTY		;NO. SEE IF ACTIVE
	 CALLRET ULKTTY		;NO. UNLOCK IT AND GIVE ERROR RETURN
	CALL ULKTTY		;YES. UNLOCK IT
	RETSKP			;AND ALLOW ACCESS
;ROUTINE TO LOCK DYNAMIC DATA
;SKIPS IFF SUCCESS.

TLOCK:	CALL LCKTTY		;GET ADDRESS OF DYNAMIC DATA, PREVENT DEALLOCATION
	 JRST [	CALL ULKTTY	;NOT ACTIVE. ALLOW DEALLOCATION
		RETBAD (TTYX01)] ;INDICATE NOT ACTIVE
	RETSKP

;FUNCTION .MOSLW OF MTOPR - SET LINE WIDTH

TTMSWD:	CALL TLOCK
	 RETBAD
	UMOVE T1,3		;GET WIDTH TO SET
	CALL TTSWID		;GO SET IT
	JRST [	CALL ULKTTY	;ALLOW DEALLOCATION
		RETBAD (MTOX19)] ;RETURN INVALID WIDTH
	CALL ULKTTY		;ALLOW DEALLOCATION
	RETSKP			;AND DONE

;FUNCTION .MORLW - READ LINE WIDTH

TTMRWD:	CALL TLOCK
	 RETBAD
	CALL TTRWID		;GO READ WIDTH
	JRST TTMTST		;GO RETURN TO USER

;FUNCTION .MOSLL OF MTOPR - SET LINE LENGTH

TTMSLN:	UMOVE T1,3		;GET LENGTH
	CALL TLOCK
	 RETBAD
	CALL TTSLEN		;GO SET IT
	 JRST [	CALL ULKTTY	;ALLOW DEALLOCATION
		RETBAD (MTOX20)] ;RETURN INVALID LENGTH
	CALL ULKTTY		;SUCCESS. ALLOW DEALLOCATION
	RETSKP			;AND DONE

;FUNCTION .MORLL OF MTOPR - READ LINE LENGTH

TTMRLN:	CALL TLOCK
	 RETBAD
	CALL TTRLEN		;GO GET IT
TTMTST:	UMOVEM T1,3		;STORE RESULT
	CALL ULKTTY		;ALLOW DEALLOCATION
	RETSKP			;AND DONE

;SET LINE COUNTER - .MOSLC

TTMSLC:	CALL TLOCK		;LOCK THE DATA
	 RETBAD
	UMOVE A,C		;GET NEW VALUE
	CALL TTSLC		;SET IT
	CALLRET TTMTST		;DONE

;READ LINE COUNTER - .MORLC

TTMRLC:	CALL TLOCK		;LOCK TTY DATA
	 RETBAD
	CALL TTRLC		;GET THE COUNTER
	UMOVEM A,C		;STORE IN USER'S AC
	CALLRET TTMTST

;SET LINE COUNTER MAXIMUM - .MOSLM

TTMSLM:	CALL TLOCK
	 RETBAD
	UMOVE A,C		;GET VALUE BEING SET
	CALL TTSLM		;SET IT
	CALLRET TTMTST

;READ MAXIMUM - .MORLM

TTMRLM:	CALL TLOCK
	 RETBAD
	CALL TTRLM		;READ MAXIMUM
	UMOVEM A,C		;GIVE TO USER
	CALLRET TTMTST

;FUNCTION .MOSNT OF MTOPR

TTMSNT:	CALL TTMLOK		;VERIFY ACCESS TO TTY
	 RETBAD (MTOX7)		;CAN'T DO IT
	UMOVE C,C		;GET USER'S ARG
	CALL TTSNTS		;GO SET TTY NO MSG
	RETSKP			;DONE

;FUNCTION .MORNT OF MTOPR

TTMRNT: CALL TTRNTS		;GO READ TTY MSG STATUS
	UMOVEM C,C		;AND GIVE TO USER
	RETSKP			;DONE

;SET/CLEAR XON/XOFF PROCESSING

TTXXX:	CALL TLOCK
	 RETBAD
	UMOVE T3,3		;GET NEW SETTING
	CALL TTXSET		;SET IT
	CALL ULKTTY		;UNLOCK TTY
	RETSKP			;AND DONE

;READ SETTING OF XOFF BIT

TTXXXR:	CALL TLOCK
	 RETBAD
	CALL TTRXOB		;READ XOFF BIT
	UMOVEM T1,3		;RETURN VALUE
	CALL ULKTTY
	RETSKP			;AND DONE

;SET PAGE PAUSE CHARACTER

TTPCS::	CALL TLOCK
	 RETBAD
	UMOVE T1,3
	CALL TTPPCS
	CALL ULKTTY		;UNLOCK TTY
	RETSKP			;AND DONE

;READ PAGE PAUSE CHARACTER

TTPCR::	CALL TLOCK
	 RETBAD
	CALL TTPPCR
	UMOVEM T1,3
	CALL ULKTTY		;UNLOCK TTY
	RETSKP			;AND DONE

; SET PSI FOR NON-CONTROLLING TERMINAL I/O

TTLIPS:	CALLRET TTYNPS		;DO NON CONTROLLING TERMINAL PSI ENABLE

;221 Begin addition
TTMFCI:	CALL TLOCK		;Lock down tty
	 RETBAD
	CALL TTIFCI		;Get a character
	 JRST [	TQO <BLKF>	;Need to go blocked
		RET]
	CALLRET TTMTST		;Return to user
;221 End addition

;ROUTINE CALLED BY NILOPN,PTYOPN ,AND TTYOPN TO SET WRTF
;IF APPEND REQUESTED

CHKAPD:	TQZE <RNDF>		;WANT APPEND?
	TQO <WRTF>		;YES. BUT ALWAYS FAKE APPEND
	RET			;AND DONE

 SUBTTL TERMINAL WAKE-UP AND FIELD WIDTH SUPPORT

;TTMRBM - READ BREAK MASK

TTMRBM:	CALL TTMVER		;GO VERIFY BLOCK AND LINE
	RET			;ERROR - RETURN
	STKVAR <<TTMSK1,4>>
	XMOVEI T1,TTMSK1	;POINT TO WHERE WE WANT MASK TO GO
	CALL TTRBM		;GET MASK INTO TTMSK
	UMOVE T1,T3		;GET USER AREA POINTER
	DMOVE T3,TTMSK1		;GET FIRST TWO WORDS
	XCTU [	DMOVEM T3,1(T1)]	;PUT IN USER AREA
	DMOVE T3,2+TTMSK1	;GET LAST TWO WORDS
	XCTU [	DMOVEM T3,3(T1)]	;PUT IN USER AREA
	CALL ULKTTY		;UNLOCK THE DYNAMIC DATA
	RETSKP
;  TTMSBM - SET THE BREAK MASK

TTMSBM:	CALL TTMVER		;GO VERIFY BLOCK AND LINE
	RET			;ERROR - RETURN
	STKVAR <<TTMSK2,4>>
	XCTU [	DMOVE T3,1(T1)]	;GET FROM USER AREA
	DMOVEM T3,TTMSK2	;SET FIRST TWO WORDS
	XCTU [	DMOVE T3,3(T1)]	;GET FROM USER AREA
	DMOVEM T3,2+TTMSK2	;SET LAST TWO WORDS
	XMOVEI T1,TTMSK2	;POINT TO WHERE IS
	CALL TTSBM		;SET MASK INTO TTMSK
	CALL ULKTTY		;UNLOCK THE DYNAMIC DATA
	RETSKP


; TTMVER - VERIFY LINE NUMBER IS CORRECT AND BLOCK IS DEFINED PROPERLY

;ACCEPTS:	T2/LINE NUMBER

;RETURNS:	+1,ERROR
;		+2,WITH	T1/USER CONTEXT ADDRESS OF 4 WORD BLOCK
;			T2/DYNAMIC DATA ADDRESS
;			T3/CLOBBERED

TTMVER:	CALL TLOCK
	 RETBAD
	UMOVE T1,T3		;GET ADDRESS OF USER BLOCK
	UMOVE T3,(T1)		;GET ARGUMENT LENGTH
	CAIN T3,T4		;MUST BE LENGTH OF FOUR
	RETSKP			;YES, RIGHT LENGTH - RETURN
	CALL ULKTTY		;UNLOCK THE DYNAMIC DATA
	CAIG T3,T4		;IS IT LESS THAN FOUR
	RETBAD (MTOX13)		;YES - THEN TELL USER
	RETBAD (MTOX8)		;NO - MUST BE TO LONG

;TTMRFW - READ THE FIELD WIDTH

TTMRFW:	CALL TLOCK
	 RETBAD
	CALL TTRFW		;GO GET THE FIELD WIDTH
	UMOVEM T1,T3		;GIVE TO USER
	CALL ULKTTY		;UNLOCK DYNAMIC DATA
	RETSKP

;TTMSFW - SET THE FIELD WIDTH

TTMSFW:	CALL TLOCK
	 RETBAD
	UMOVE T1,T3		;GET FIELD WIDTH FROM USER
	CALL TTSFW		;GO SET THE FIELD WIDTH
	CALL ULKTTY		;UNLOCK DYNAMIC DATA
	RETSKP

 SUBTTL  TTYASN
;TTYASN - ASSIGN TERMINAL AS CONTROLLING TERMINAL FOR A JOB

;ACCEPTS:
;	T1/ JOB NUMBER
;	T2/ INTERNAL LINE NUMBER

;	CALL TTYASN

;RETURNS +1: FAILURE
;	 +2: SUCCESS

TTYASN::
	SE1CAL
	STKVAR <TTYALN,TTYASX>
	MOVEM T2,TTYALN		;SAVE LINE NUMBER
	CALL LCKDVL		;LOCK THE DEVICE TABLES
	MOVEI T1,.TTDES(T2)	;T1/ DEVICE DESIGNATOR
	CALL CHKDES		;GET INDEX INTO DEVICE TABLES
	 RETBAD(,<UNLOKK DEVLKK ;INVALID DESIGNATOR. SHOULDN'T HAPPEN
		OKINT>)
	MOVEM B,TTYASX		;SAVE INDEX INTO DEVICE TABLES
	HLRZ T2,DEVUNT(B)	;GET OWNING JOB
	CAME T2,JOBNO		;US?
	CAIN T2,-1		;OR NO ONE
	SKIPA B,TTYALN		;YES. GO ON
	RETBAD(DESX2,<UNLOKK DEVLKK
		OKINT>)
	CALL TTYASC		;GO ASSIGN TERMINAL IF POSSIBLE
	 RETBAD(,<UNLOKK DEVLKK ;FAILED
		OKINT>)
	HRRZ A,TTYASX		;GET INDEX INTO DEVICE TABLES
	MOVE B,JOBNO		;GET THIS JOB NUMBER
	HRLM B,DEVUNT(A)	;MARK THIS IT OWNS THE TERMINAL
	MOVX B,DV%ASN		;INDICATE ASSIGNED
	IORM B,DEVCHR(A)
	UNLOKK DEVLKK
	OKINT
	RETSKP

;TTYDAS - DEASSIGN TERMINAL

;ACCEPTS:
;	T2/ INTERNAL LINE NUMBER

;	CALL TTYDAS

;RETURNS +1: FAILED,
;		T1/ ERROR CODE
;			OR
;		    1B0 + ADDRESS OF SCHEDULER TEST ROUTINE FOR MDISMS
;	 +2: SUCCEEDED

;CALLER MUST HAVE LOCKED THE DEVICE LOCK

TTYDAS::STKVAR <TTYDLN,TTYDAX>
	MOVEM T2,TTYDLN		;SAVE LINE NUMBER
TTYDA3:	MOVEI T1,.TTDES(T2)	;T1/ DEVICE DESIGNATOR FOR TERMINAL
	CALL CHKDES		;GET INDEX TO DEVICE TABLES
	 RETBAD			;INVALID DESIGNATOR. SHOULDN'T HAPPEN
	MOVEM T2,TTYDAX		;SAVE INDEX TO DEVICE TABLES
	JN DV%OPN,DEVCHR(T2),TTYDA1 ;DON'T DEALLOCATE IF ALSO OPEN
	HLRZ T2,DEV		;T2/ LINE NUMBER
	CALL TTYDEA		;DEALLOCATE DYNAMIC DATA
	 RETBAD			;FAILED. GO WAIT IF NECESSARY
TTYDA5:	MOVE T2,TTYDAX		;GET INDEX TO DEVICE TABLES
	HRROS DEVUNT(T2)	;INDICATE NO JOB OWNS THIS DEVICE
TTYDA1:	SETZRO DV%ASN,DEVCHR(T2) ;INDICATE NO LONGER ASSIGNED
	RETSKP

;FAILED TO DEASSIGN DYNAMIC DATA. RETURN FAILURE TO CALLER WITHOUT
;CHANGING DEVICE TABLES

	TNXEND
	END
