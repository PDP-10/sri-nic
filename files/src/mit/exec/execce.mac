;132 small tweaks
;130 New implementation of Emacs mode under VTS.
;717 use VTS where possible
;716 add command edit features
;713 add literals label
;712 UTEXAS release version


;S:<5-ESOURCE.R20>EXECCE.MAC,	9-OCT-82 12:39:00,   Edit by Billy
; ADD UTAH-20 EXPANSIONS AND HISTORY COMMAND


;TOPS20 'EXECUTIVE' COMMAND LANGUAGE

	SEARCH EXECDE
	TTITLE EXECCE

;UTEXAS-20 COMMAND EDITOR - BILLY BROWN, JULY, 1982

;THIS FILE CONTAINS: COMMAND EDITOR, AGAIN COMMAND, COMMAND SAVE ROUTINE

CEF,<				;716

;ROUTINE TO SAVE CONTENTS OF COMMAND BUFFER FOR LATER CEDIT COMMAND
CSAVE::	SKIPN PASCMD		;7 command has password in it
	 SKIPE CEBPTR		;THIS ONE NOT TO BE SAVED?
	  RET
	SAVEAC <A,B,C,D>	;SAVE THE REGISTERS
	MOVE A,SBLOCK+.CMIOJ	;GET PRIMARY JFNS
	CAME A,[.PRIIN,,.PRIOU]	;A REAL, TYPED COMMAND?
	 JRST CSAVE5		;NOPE, DON'T SAVE IT
	SKIPE PCCIPF		;IF NOT PCL COMMAND, SAVE IT
	 JRST  [SKIPE PCLMID
		 JRST CSAVE5	;IF NOT THE CALLING COMMAND, DON'T SAVE
		SETOM PCLMID	;DON'T SAVE ANY MORE PCL COMMANDS
		JRST .+2 ]	;BUT DO SAVE THIS ONE
	SETZM PCLMID
	LDB A,[FIRCHR CBUF]	;CHECK IT OUT FIRST
	JUMPE A,CSAVE5		;DON'T SAVE EMPTY COMMANDS
	CAIN A,CR		;CR?
	 JRST CSAVE5		;YES, DON'T SAVE
	CAIN A,LF		;LF?
	 JRST CSAVE5		;YES, EMPTY COMMAND, DON'T SAVE
	MOVE A,[ASCPTR CBUF]	;POINT TO THE SOURCE
	MOVE B,CEFFL		;GET ADDRESS OF FIRST FREE LOCATION
	CAME B,CE1ST		;ABOUT TO STOMP SOMEONE?
	 JRST CSAVE0		;NO
	HRRZ D,(B)		;GET ADDRESS OF NEXT ONE
	HRRZS (D)		;TIE IT OFF
	MOVEM D,CE1ST		;SAVE NEW ADDRESS
	SOS CECNT		;DECREMENT THE COUNT
CSAVE0:	HLL B,[ASCPTR]		;POINT TO FIRST FREE SPOT
	ADDI B,1		;LEAVE ROOM FOR THE HEADER
CSAVE1:	ILDB C,A		;GET NEXT BYTE
	CAIN C,CR		;END ON CR
	 SETZ C,
	CAIN C,LF		;END ON LINE FEED
	 SETZ C,
CSAVE2:	IDPB C,B		;STORE THE BYTE
	HRRZ D,B		;GET ADDRESS WE JUST STORED IN
	CAME D,CE1ST		;GOING OVER THE FIRST COMMAND?
	 JRST CSAVE3
	HRRZ D,(D)		;GET ADDRESS OF NEXT ONE
	HRRZS (D)		;TIE IT OFF
	MOVEM D,CE1ST		;SAVE NEW ADDRESS
	SOS CECNT		;DECREMENT THE COUNT
CSAVE3:	HRRZ D,B		;GET ADDRESS AGAIN
	CAIE D,CEBFEN		;PAST THE BUFFER?
	 JRST CSAVE4		;NO
	MOVE B,[ASCPTR CESAVE]	;YES, RESET TO THE TOP
	JRST CSAVE2		;AND TRY AGAIN

CSAVE4:	JUMPN C,CSAVE1		;GET NEXT CHARACTER IF NOT THE END
	HRRZ A,B		;GET ADDRESS OF LAST BYTE
	ADDI A,1		;BECOMES FIRST FREE LOCATION
	CAIL A,CEBFEN		;STILL IN THE BUFFER?
	 MOVEI A,CESAVE		;NO, WRAP AROUND
	EXCH A,CEFFL		;SAVE IT, A POINTS TO THE NEW BLOCK
	HRRM A,@CELAST		;LINK THIS ONE IN
	MOVE B,CELAST		;GET ADDRESS OF LAST ONE
	HRLZM B,(A)		;LINK FROM NEW ONE TO OLD ONE
	MOVEM A,CELAST		;UPDATE LAST COMMAND POINTER
	AOS CECNT		;INCREMENT COUNT
CSAVE5: RET


; HISTORY COMMAND
.HISTO::SETOM CEBPTR		;7 don't save this
	NOISE <about recent exec commands>
	MOVEI B,[FLDDB. .CMCFM,CM%SDH,,<confirm to print entire history>,,[
		FLDDB. .CMNUM,CM%SDH,^D10,<integer "n" for last "n" commands>]]
	CALL FLDSKP		;CONFIRMATION OR NEW COMMAND
	 CMERRX			;SOME TYPE OF ERROR
	STKVAR <HSTNUM,CELPOS,CELPTR>
	GTFLDT D		;SEE WHAT WE GOT
	CAIN D,.CMCFM		;CONFIRM?
	 JRST  [SETOM HSTNUM	;EFFECTIVELY INFINITY
		JRST HIST1]	       
	MOVEM B,HSTNUM		;SAVE AMOUNT OF HISTORY
	CONFIRM
HIST1:	SETZM CELPOS		;ENTRY ZERO
	SKIPN C,CELAST		;CURRENT MOST RECENT ENTRY
	 RET			;NOTHING THERE
	MOVEM C,CELPTR
HIST2:	MOVE D,CELPOS		;GET LINE COUNT
	MOVEI B,1(C)		;GET PAST HEADER
	HLL B,[ASCPTR]		;MAKE INTO BYTE POINTER
	ETYPE < -%4Q: %2M %_>
	SOSN HSTNUM		;DECREMENT COUNTER
	 RET			;NO MORE WANTED
				;GO TO PREVIOUS LINE
	HLRZ C,@CELPTR		;TAKE THE LEFT HAND LINK
	CAIN C,0		;CHECK FOR END OF LIST
	 RET
	MOVEM C,CELPTR		;UPDATE POINTER
	AOS CELPOS		;INCREMENT THE LINE NUMBER
	JRST HIST2		;PROCESS THIS LINE


; AGAIN COMMAND

.AGAIN::MOVEI B,[FLDDB. .CMCFM,CM%SDH,,<confirm to redo last command>,,[
		FLDDB. .CMTXT,CM%SDH,,<command to be executed first>]]
	CALL FLDSKP		;CONFIRMATION OR NEW COMMAND
	 CMERRX			;SOME TYPE OF ERROR
	GTFLDT D		;SEE WHAT WE GOT
	CAIN D,.CMCFM		;CONFIRM?
	 JRST AGINOK		;YES, SKIP NEW STUFF
	MOVE C,[ASCPTR ATMBUF]	;POINT TO THE NEW COMMAND
	MOVX A,.CTTRM		;AND TO THE TERMINAL
OAGAIN:	ILDB B,C		;GET NEXT CHAR
	JUMPE B,OAGIN1		;CHECK FOR END
	CAIN B,.CHCNN		;^N?
	 MOVX B,CR		;YES, MULTI LINE STUFF
	STI			;STUFF IT
	JRST OAGAIN		;DO THE REST

OAGIN1:	MOVX B,CR		;END WITH CR
	STI
	MOVEI B,[FLDDB. .CMCFM]	;PARSE THE CR TO SYNC WITH AGAIN<CR>
	CALL FIELD
AGINOK:	MOVE C,CELAST		;GET ADDRESS OF LAST COMMAND STRING
	HLRZ C,(C)		;SKIP ONE MORE
	ADDI C,1		;SKIP PAST THE HEADER
	HLL C,[ASCPTR]		;MAKE IT A POINTER
	MOVX A,.CTTRM
AGAIN1:	IBP C			;POINT TO NEXT BYTE
	HRRZ D,C		;CHECK FOR WRAP AROUND
	CAIL D,CEBFEN		;STILL IN THE BUFFER?
	 MOVE C,[FIRCHR CESAVE] ;NO, RESET
	LDB B,C			;GET NEXT CHAR
	JUMPE B,AGAIN2		;CHECK FOR END
	STI			;STUFF IT
	JRST AGAIN1		;DO THE REST

AGAIN2:	MOVX B,CR		;ADD CR TO THE END
	STI
	SETOM CEBPTR		;DON'T SAVE THIS IN THE EDIT BUFFER
	MOVE A,CELAST		;GET POINTER TO "REDO" COMMAND
	HLRZ A,(A)		;NOW POINTER TO PREVIOUS COMMAND
	MOVEM A,CELAST		;FORGET THE "REDO" FROM HISTORY
	RET			;ALL DONE


;UTEXAS-20 COMMAND LINE EDITOR

.CEDIT::SETOM CEBPTR		;7 don't save this
	MOVEI B,[FLDDB. .CMCFM,CM%SDH,,<confirm to enter command EDITOR>,,[
		FLDDB. .CMNUM,CM%SDH,^D10,<number of previous command>,,[
		FLDDB. .CMTXT,CM%SDH,,<prefix of previous command>]]]
	CALL FLDSKP		;CONFIRM OR NEW COMMAND
	 CMERRX			;SOME TYPE OF ERROR
;130	TRVAR <CADLFG,CEDUMB,CABKFG,CELPOS,CECPOS,CELPTR,CEDSEA,CENUMR>
	TRVAR <CADLFG,CEDUMB,CABKFG,CELPOS,CECPOS,CELPTR,CEDSEA,CENUMR,CETWID,CETLEN,CEFMOD,CETCHR,CEWINL>	;130
	SETZM CEDSEA		;ASSUME NORMAL MODE
	GTFLDT D		;SEE WHAT WE GOT
	CAIN D,.CMCFM		;CONFIRM?
	 JRST CEDITU		;YES, EDIT LAST COMMAND
	AOS CEDSEA		;NO, ASSUME SEARCH MODE; ATMBUF CONTAINS STRING
	CAIN D,.CMTXT		;TEXT?
	 SETOM CEDSEA		;YES
	SUBI B,1		;7 seems to always be one off
	MOVEM B,CENUMR		;SAVE IN CASE OF NUMBER
	CONFIRM
VTS,<	JRST CEDITU>		;130 New implementation

NOVTS,<				;130 Old implementation/non-VTS
CEDITU:	MOVX A,.CTTRM		;GET OLD MODE WORD
	RFMOD
	PUSH P,B		;SAVE THIS FOR LATER
	TXZ B,TT%IGN		;MAKE SURE IT SEES TT%WAK BITS
	TXO B,TT%WAK		;WAKE ON EVERYTHING
	TXZ B,TT%ECO		;TURN OFF ECHOING
	TXZ B,TT%PGM		;TURN OFF PAGING (^S, ^Q)
	TXZ B,TT%TAB		;SPACES INSTEAD OF TAB
	SFMOD
	STPAR
	MOVE B,[052525,,553125]	;PASS CR, ^I, FORMAT LF, NO NULLS
	MOVE C,[252525,,652400]	;FORMAT ESCAPE
	SFCOC
	MOVX A,.FHSLF		;7 make sure ctrl/c capability is on
	RPCAP			;7
	TXON C,SC%CTC		;7
	 JRST  [TXNN B,SC%CTC	;7
		 ERROR <Control-c capability required>	;7
		EPCAP		;7
		JRST .+1]	;7
	MOVX A,.FHJOB
	SETZ B,			;NO TERMINAL INTERRUPTS
	STIW
	SETZM CELPOS		;INITIALIZE LINE NUMBER
	MOVE A,CELAST		;GET THE FIRST COMMAND POINTER
	MOVEM A,CELPTR		;INITIALIZE FOR CETOP
	SKIPE CEDSEA		;SEARCH MODE?
	 CALL CESRCH		;YES, SO BEGIN DEFFERENTLY
	SETZM CEDUMB		;ASSUME SMART TERMINAL
	SKIPN CEFLAG		;EMACS MODE?
	 JRST CETOP		;YES, SIMULATE UP CURSOR
	MOVE A,COJFN		;ALTER MODE, GET TERMINAL TYPE
VTS,<	 RTCHR			;717
	TXNN B,TC%OVR		;717 overstrike or
	 TXNN B,TC%SCL		;717 no clear selected portions?
       >			;717
NOVTS,<	GTTYP
	SKIPN EEOLTB(B)		;IS IT SMART?
       >			;717
	 SETOM CEDUMB		;NO
	SETZM CADLFG		;INITIALIZE STUFF
	SETZM CABKFG
	JRST CETOP		;SIMULATE INITIAL UP CURSOR
>;130 old implementation

;SEARCH FOR INITIAL STRING
;
;   ACCEPTS:	A/	POINTER TO FIRST COMMAND
;		CELPTR/	SAME AS A	
;   RETURNS:	CELPTR/	UPDATED VALUE
;		CELPOS/	UPDATED VALUE
CESRCH:	SKIPL CEDSEA		;SEARCH MODE OR NUMBER MODE
	 JRST CENUMM		;NUMBER MODE
	MOVE C,A		;BASE STRING HEADER
	MOVE B,[ASCPTR 1(C)]	;BASE STRING BYTE POINTER
	MOVE A,[ASCPTR ATMBUF]	;POINT TO THE PREFIX STRING
	STCMP
	CAIN A,0		;STRING ARE EQUAL?
	 RET			;YES, SO RETURN
	TXNE A,SC%SUB		;SUBSTRING?
	 RET			;YES, SO RETURN
				;GO TO PREVIOUS LINE
	HLRZ A,@CELPTR		;TAKE THE LEFT HAND LINK
	CAIN A,0		;CHECK FOR END OF LIST
	 JRST CESRCL		;END OF LIST
	AOS CELPOS		;INCREMENT THE LINE NUMBER
	MOVEM A,CELPTR		;UPDATE POINTER
	JRST CESRCH		;PROCESS THIS LINE

CESRCL:	MOVE A,CELAST		;END OF LIST, GO BACK TO THE FIRST LINE
	MOVEM A,CELPTR		;RESET THE POINTER
	SETZM CELPOS		;RESET LINE NUMBER
	TYPE <%Prefix not found - editing last command>
	RET

;NUMBER MODE
CENUMM:	SKIPGE C,CENUMR		;ONLY ALLOW POSITIVE NUMBERS
	 RET			;RETURN OTHERWISE POINTING AT CURRENT	
CENUMA:	HLRZ A,@CELPTR		;TAKE THE LEFT HAND LINK
	CAIN A,0		;CHECK FOR END OF LIST
	 JRST CENUML		;END OF LIST
	AOS CELPOS		;INCREMENT THE LINE NUMBER
	MOVEM A,CELPTR		;UPDATE POINTER
	SOJGE C,CENUMA		;CONTINUE IF MORE TO GO
	RET			;RETURN POINTING TO CURRENT LINE

CENUML:	TYPE <%Requested command line lost - positioning at first command>
	RET


NOVTS,<				;130 Old implementation/non-VTS
CETOP:	ETYPE <%_>		;CR
	CALL EEOLN		;ERRASE TO END OF LINE
	MOVE A,CELPTR		;POINT TO THE CURRENT LINE
	ADDI A,1		;SKIP PAST THE HEADER
	HLL A,[ASCPTR]		;MAKE IT A POINTER
	MOVE B,[ASCPTR CETSAV]	;POINT TO THE TEMP BUFFER
CETOP0:	ILDB C,A		;GET NEXT BYTE
	HRRZ D,A		;CHECK FOR WRAP AROUND
	CAIE D,CEBFEN		;TOO FAR?
	 JRST CETOP1		;NO
	MOVE A,[ASCPTR CESAVE]	;YES, RESET THE POINTER
	JRST CETOP0		;AND START OVER

CETOP1:	IDPB C,B		;MOVE IT
	CAIE C,0		;END ON NULL BYTE
	 JRST CETOP0		;DO THE REST
	SETZM CECPOS		;INITIALIZE POSITION
	MOVE A,[ASCPTR CETSAV]	;GET A POINTER TO IT
	MOVEM A,CEBPTR		;SAVE IT
	SKIPN CEDUMB		;WRITE LINE FOR DUMB TERMINALS
	 JRST CETOP2
	CALL CENUMB
	MOVE A,CEBPTR
	PSOUT
	ETYPE <%_>
CETOP2:	TYPE <    >		;MAKE ROOM FOR THE LINE NUMBER
	MOVE A,CEBPTR
	SKIPN CEDUMB		;EMACS OR SMART ALTER MODE?
	 PSOUT			;YES, WRITE IT OUT
	TYPE <>		;BACK TO THE BEGINNING
	CALL CENUMB		;WRITE THE NUMBER
	JRST CEINC		;GET COMMAND INPUT CHARACTER
>;130 old implementation

CENUMB: MOVX A,.CTTRM		;OUTPUT LINE# AS "DD:"
	MOVN B,CELPOS		;GET (NEGATIVE) LINE NUMBER
	JUMPE B,CENUM1		;DO CURRENT LINE DIFFERENT
	MOVX C,NO%LFL!NO%OOV!NO%AST!FLD(3,NO%COL)!FLD(12,NO%RDX)
        NOUT
	 NOP
        TYPE <:>
	RET			;ALL DONE

CENUM1:	TYPE < **:>		;FOR CURRENT LINE
	RET


;130 Start addition for new implementation
VTS,<
CEDITU:	MOVX A,.FHSLF		;7 make sure ctrl/c capability is on
	RPCAP%			;7
	TXOE C,SC%CTC		;7
	IFSKP.
	  TXNN B,SC%CTC		;7
	    ERROR <Control-c capability required>	;7
	  EPCAP%		;7
	ENDIF.
	MOVX A,.FHJOB
	SETZ B,			;NO TERMINAL INTERRUPTS
	STIW%
	MOVX A,.CTTRM		;Get terminal characteristics
	RTCHR%
	MOVEM B,CETCHR		;Save them
	TXO B,TC%WRP		;Turn this on, makes the monitor behave more
	STCHR%			;predictably wrt continuation lines
	MOVE Q1,CETCHR		;Characteristics in Q1 for easy lookup
	SETZM CEDUMB
	TXNE Q1,TC%OVR		;If overstrike
	 TXNE Q1,TC%SCL		;and can't clean up after ourselves
	IFSKP.
	  TXZ Q1,TC%MOV		;Then don't try moving up
	  SETOM CEDUMB		;Flag for Alter mode
	ENDIF.
	IFXN. Q1,TC%MOV		;Try to unconfuse the monitor
	  RFPOS%		;This probably doesn't do much due to
	  MOVE C,B		;optimizations, but it's the best I can
	  MOVX B,.VTHOM		;132 try to defeat optimizations
	  VTSOP%		;132
	  MOVX B,DP%AG1+.VTMOV	;come up with... 
	  VTSOP%
	ENDIF.
	RTMOD%			;Get terminal modes
	MOVE Q2,B		;In Q2
	MOVEI B,.MORLW		;Get terminal width
	MTOPR%
	SOJ C,			;Lose a column for continuation marker
	SKIPG C
	  MOVEI C,-1
	MOVEM C,CETWID
	MOVEI B,.MORLL		;Get terminal length
	MTOPR%
	TXNE Q2,TM%MVR		;Lose a line for verbose more processing
	 TXNE Q2,TM%SCR		;in wrap mode
	IFSKP. <SOJ C,>		;(Maybe should just turn it off)
	SKIPG C
	  MOVEI C,-1
	MOVEM C,CETLEN
	RFMOD%			;Get old mode word
	MOVEM B,CEFMOD		;Save for later
	TXZ B,TT%IGN!TT%ECO!TT%PGM!TT%TAB	;No echo, tabs, ^S/^Q
	TXO B,TT%WAK		;WAKE ON EVERYTHING
	SFMOD%
	STPAR%
;	MOVE B,[052525,,553125]	;PASS CR, ^I, FORMAT LF, NO NULLS
	MOVE B,[052525,,753525] ;Format CR, Tab, LF, ignore nulls
	MOVE C,[252525,,652400]	;FORMAT ESCAPE
	SFCOC%
	SETZM CELPOS		;INITIALIZE LINE NUMBER
	MOVE A,CELAST		;GET THE FIRST COMMAND POINTER
	MOVEM A,CELPTR		;INITIALIZE FOR CETOP
	SKIPE CEDSEA		;SEARCH MODE?
	 CALL CESRCH		;YES, SO BEGIN DEFFERENTLY
	SETZM CADLFG		;Initialize stuff for Alter mode
	SETZM CABKFG
	;JRST CETOP


CETOP:	MOVE A,CELPTR		;Point to current line
	ADDI A,1
	HRLI A,(ASCPTR)
	MOVE B,[ASCPTR CETSAV]	;Move it to edit buffer
	MOVEM B,CEBPTR
	MOVEI D,CETSVL*5
	DO.
	  CAMN A,[010700,,CEBFEN-1]	;Check for wraparound
	    MOVE A,[ASCPTR CESAVE]
	  ILDB C,A
	  SOSL D		;Truncate if too long for edit buffer
	   IDPB C,B		;MOVE IT
	  JUMPN C,TOP.
	ENDDO.
	DPB C,B			;Make sure asciz
	SETZM CECPOS		;INITIALIZE POSITION
	MOVX A,.CTTRM		;Get a fresh line if need to
	MOVEI B,.VTADV
	VTSOP%
	 ERCAL CNEWLN
	JRST CEDIS0		;Make like ^R
>;130 End addition for new implementation


;GET THE NEXT INPUT CHARACTER
CEINC:	SKIPN CEFLAG		;EMACS MODE?
	 JRST ECEINC		;YES, DIFFERENT COMMANDS
	SETZ P3,		;ASSUME NO NUMERIC ARGUMENT
ACEINC:	PBIN			;GET ALTER MODE COMMAND
	CAIL A,"0"		;BIGGER THAN 0?
	 CAILE A,"9"		;SMALLER THAT 9?
	  JRST ACEIN1		;NOT A NUMBER, KEEP LOOKING
	IMULI P3,^D10		;NUMBER, UPDATE THE COUNT
	ADD P3,A		;ADD THIS ONE IN
	SUBI P3,"0"		;CONVERT TO BINARY
	JRST ACEINC		;GET THE REST OF THE COMMAND

ACEIN1:	CAIN A,CR		;^M - EXIT AND DO COMMAND
	 JRST CEEXIT
	CAIE A,"E"		;E - EXIT AND DO COMMAND
	 CAIN A,"e"
	  JRST CEEXIT
	CAIN A,.CHCNU		;^U - START OVER
	 JRST CETOP
	CAIN A,.CHLFD		;LINEFEED - NEXT LINE
	 JRST CEDOWN
	CAIN A,.CHESC		;ESC - PREVIOUS LINE
	 JRST CEUP
	CAIN A,.CHCNR		;^R - RETYPE LINE
	 JRST CATYPE
	CAIE A,"L"		;^L - TYPE LINE AND START OVER
	 CAIN A,"l"
	  JRST CARTYP
	CAIE A,"P"		;P - RETYPE LINE
	 CAIN A,"p"
	  JRST CATYPE
	CAIE A,"Q"		;Q - ABORT
	 CAIN A,"q"
	  JRST CEQUIT
	CAIN A,.CHCNC		;^C - ABORT
	 JRST CEQUIT
	CAIE A,"D"		;D - DELETE CHARACTERS
	 CAIN A,"d"
	  JRST CADEL
	CAIE A,"H"		;"H" - DELETE TO END, THEN INSERT
	 CAIN A,"h"
	  JRST CAHACK
	CAIE A,"I"		;"I" - ENTER INSERT MODE
	 CAIN A,"i"
	  JRST CAINST
	CAIE A,"R"		;"R" - DELETE THEN INSERT
	 CAIN A,"r"
	  JRST CADEIN
	CAIE A,"W"		;"W" - MOVE OVER WORDS
	 CAIN A,"w"
	  JRST CAFORW
	CAIE A,"X"		;"X" - EXTEND LINE
	 CAIN A,"x"
	  JRST CAEXTN
	CAIE A,"Z"		;"Z" - DELETE WORDS
	 CAIN A,"z"
	  JRST CADELZ
	CAIN A,":"		;":" - DELETE REST OF LINE
	 JRST CACOLN
	CAIN A,"\"		;"\" - TRANSPOSE PREVIOUS TWO CHARS
	 JRST CETRAN
	CAIN A,.CHDEL		;RUB - MOVE CURSOR LEFT
	 JRST CALEFT
	CAIN A," "		;SPACE - MOVE CURSOR RIGHT
	 JRST CARIGH
	CAIN A,.CHTAB		;TAB - MOVE TO END OF LINE
	 JRST CAEOLN
	CAIN A,"?"		;? - GIVE HELP MESSAGE
	 JRST CAHELP
	CALL CEBELL		;ERROR, RING THE BELL
	JRST CEINC		;TRY AGAIN


;HERE TO ENTER INSERT MODE
CAINST:	CALL CAFLSH		;FLUSH ANYTHING WE HAD GOING
CANST0:	PBIN			;GET NEXT CHARACTER
	CAIN A,.CHESC		;ESCAPE?
	 JRST CEINC		;YES, EXIT
	CAIN A,.CHTAB		;A TAB?
	 JRST CAINOK		;YES, LET IT PASS
	CAIL A," "		;SOME CONTROL CODE?
	 CAIN A,.CHDEL		;OR RUBOUT?
	  SKIPA			;YES, ERROR
	   JRST CAINOK		;ITS OK
	CALL CEBELL		;ERROR, RING BELL
	JRST CANST0		;AND TRY AGAIN

CAINOK:	MOVE C,CEBPTR		;GET THE POINTER
	SKIPE CEDUMB		;DUMP TERMINAL?
	 PBOUT			;YES, DISPLAY THE CHARACTER
CAINS1:	ILDB B,C		;GET ONE THAT WAS THERE
	SKIPN CEDUMB		;SMART TERMINAL?
	 PBOUT			;YES, OUTPUT IT
	DPB A,C			;REPLACE IT
	JUMPE A,CAINS2		;EXIT AFTER A NULL BYTE
	MOVE A,B		;SET UP TO REINSERT THE ONE
	JRST CAINS1

CAINS2:	AOS CECPOS		;UPDATE OUR POSITION
	IBP CEBPTR		;AND OUR POINTER
	SKIPE CEDUMB		;SMART TERMINAL
	 JRST CAINST		;NO, GET SOME MORE
	TYPE <>		;POSITION THE CURSOR
	CALL CENUMB		;MOVE PAST THE LINE NUMBER
	MOVE A,COJFN		;POINT TO THE TERMINAL
	HRROI B,CETSAV		;POINT TO THE STRING
	MOVN C,CECPOS		;GET COUNT
	CAIE C,0		;DON'T GO FOREVER HERE
	 SOUT			;MOVE PAST THE OLD CHARACTERS
	JRST CAINST		;DONE, GET SOME MORE


;HERE TO DELETE N CHARACTERS
CADEL:	CALL ALTDEL		;DO ALTER MODE DELETE
	JRST CEINC		;DONE

;HERE TO DELETE N CHARACTERS THEN INSERT TEXT
CADEIN:	CALL ALTDEL		;DO ALTER MODE DELETE
	CALL CAFLDE		;SIGNAL END OF DELETE
	JRST CAINST		;SO THE INSERT

;ALTER MODE DELETE ROUTINE
ALTDEL:	MOVE A,CEBPTR
	ILDB B,A
	CAIN B,0
	 RET
	CALL CAFLBK		;FLUSH BACKSPACE MARKER
	CAIG P3,0		;ZERO OR BAD ARGUMENT?
	 MOVX P3,1		;YES, MAKE IT THE DEFAULT
	SETZ C,			;NEW COUNTER
	SKIPE CEDUMB		;SMART TERMINAL
	 CALL CADELF		;NO, SIGNAL DELETE
	MOVE B,CEBPTR		;GET THE POINTER
ALTDL1:	ILDB A,B		;GET NEXT CHARACTER
	JUMPE A,ALTD1A		;END?
	ADDI C,1		;NO, INCREMENT COUNT
	SKIPE CEDUMB		;SMART TERMINAL?
	 PBOUT			;NO, ECHO CHARACTER
	SOJG P3,ALTDL1
	JRST ALTDL2

ALTD1A:	SETO A,			;WENT TOO FAR, BACKUP POINTER
	ADJBP A,B
	MOVEM A,B
ALTDL2:	CAIN C,0
	 RET
	MOVE A,CEBPTR
ALTDL3:	ILDB C,B		;GET FIRST CHARACTER
	IDPB C,A		;SAVE IN NEW POSITION
	JUMPN C,ALTDL3
	SKIPE CEDUMB		;SMART TERMINAL?
	 RET			;NO, DONE
ALTDL4:	MOVE A,CEBPTR		;REWRITE THE SCREEN
	PSOUT
	CALL EEOLN
CACTYP:				;130 added label
	TYPE <>		;POSITION THE CURSOR
	CALL CENUMB		;MOVE PAST THE LINE NUMBER
	MOVE A,COJFN		;POINT TO THE TERMINAL
	HRROI B,CETSAV		;POINT TO THE STRING
	MOVN C,CECPOS		;GET COUNT
	CAIE C,0		;DON'T GO FOREVER HERE
	 SOUT			;MOVE PAST THE OLD CHARACTERS
	RET


;HERE TO RETYPE THE LINE
CATYPE:	CALL CAFLSH		;FLUSH EVERYTHING
	SKIPN CEDUMB		;SMART TERMINAL?
	 JRST CEDISP		;YES, THIS IS A JOB FOR EMACS
	MOVE A,CEBPTR		;FINISH THE LINE
	PSOUT
	ETYPE <%_>		;GO TO NEW LINE
;130	JRST CINST1		;WRITE IT OUT
	CALL CACTYP		;130 CINST1 no longer exists in the new VTS
	JRST CEINC		;130 implementation, but this is equivalent

;HERE TO FINISH TYPING THE LINE AND START OVER
CARTYP:	CALL CAFLSH
	SETZM CECPOS		;RESET CHARACTER PSOITION
	SKIPN CEDUMB		;SMART TERMINAL?
	 JRST CARTP1		;YES
	MOVE A,CEBPTR		;FINISH THE LINE
	PSOUT
CARTP1:	MOVE A,[ASCPTR CETSAV]	;RESET POINTER
	MOVEM A,CEBPTR
	ETYPE <%_>		;NEW LINE
;130	JRST CETOP2		;AND START OVER
	TYPE <    >		;130 MAKE ROOM FOR THE LINE NUMBER
	MOVE A,CEBPTR		;130
	SKIPN CEDUMB		;130
	 PSOUT%			;130
	CALL CACTYP		;130
	JRST CEINC		;130

;HERE TO HACK AND INSERT
CAHACK:	CALL CAFLBK
	SKIPN CEDUMB		;SMART TERMINAL?
	 JRST CAHAK1		;YES, DO IT THE EASY WAY
	CALL CADELF		;SIGNAL DELETE
	MOVE A,CEBPTR		;GET THE REST OF THE STRING
	PSOUT			;OUTPUT IT
	TYPE <\\>		;END OF DELETE
	SETZM CADLFG
CAHAK1:	SETZ A,			;CHOP OFF THE REST OF THE STRING
	MOVE B,CEBPTR		;GET COPY OF POINTER
	IDPB A,B		;CURSOR IS ONE POSITION PAST POINTER
	CALL EEOLN		;JUST IN CASE
	JRST CAINST		;START INSERTING

;HERE TO MOVE OVER WORDS
CAFORW:	CALL CAFLSH
	CAIG P3,0
	 MOVX P3,1
CAFRW1:	CALL F.WORD		;GET COUNT TO NEXT WORD
	ADDM B,CECPOS		;UPDATE POSITION
	MOVN C,B		;GET NEGATIVE COUNT
	MOVE A,COJFN		;MOVE OVER
	MOVE B,CEBPTR
	CAIE C,0
	 SOUT			;WRITE IT OUT
	MOVEM B,CEBPTR
	SOJG P3,CAFRW1
	JRST CEINC		;DONE

;HERE TO DELETE N WORDS
CADELZ:	CALL CAFLBK
	PUSH P,CEBPTR		;SAVE THE POINTER
	CAIG P3,0		;ZERO OR NO ARGUMENT?
	 MOVX P3,1		;YES, MAKE IT THE DEFAULT
	SETZ D,			;KEEP COUNT HERE
CADLZ1:	CALL F.WORD		;GET COUNT TO NEXT WORD
	SUB D,B			;KEEP NEGATIVE COUNT
	ADJBP B,CEBPTR		;UPDATE POINTER
	MOVEM B,CEBPTR
	SOJG P3,CADLZ1
	SKIPE A,CEDUMB		;SMART TERMINAL?
	 JRST CADLZ2		;NO.
	MOVE A,CEBPTR		;DESTINATION POINTER
	POP P,CEBPTR		;SOURCE POINTER
	JRST M.FIX		;FIX IT UP

CADLZ2:	CALL CADELF		;SIGNAL DELETE
	MOVE A,COJFN		;WRITE OUT DELETED STUFF
	MOVE B,(P)		;POINT TO DELETED STUFF
	MOVE C,D		;NUMBER OF CHARACTERS
	CAIE C,0		;SKIP IF NONE
	 SOUT
	POP P,CEBPTR		;FIX THE POINTER
	MOVE A,CEBPTR
CADLZ3:	ILDB C,B		;GET FIRST CHARACTER
	IDPB C,A		;SAVE IN NEW POSITION
	JUMPN C,CADLZ3
	JRST CEINC		;DONE

;HERE TO EXTEND THE LINE
CAEXTN:	CALL CAFLSH
	MOVE A,CEBPTR		;GET THE POINTER
	PSOUT			;WRITE IT OUT
	SETO B,			;BACKUP THE POINTER
	ADJBP B,A
	SETZ A,			;GET COUNT TOO
CAXTN1:	ILDB A,CEBPTR		;GET NEXT CHARACTER
	JUMPE A,CAXTN2
	AOS CECPOS		;UPDATE POSITION
	JRST CAXTN1

CAXTN2:	MOVEM B,CEBPTR		;SAVE NEW POINTER
	JRST CAINST		;GO TO INSERT MODE

;HERE TO JUMP TO THE END OF A LINE
CAEOLN:	CALL CAFLSH
	MOVE A,CEBPTR		;GET POINTER
	PSOUT			;WRITE IT OUT
	SETO B,			;BACK IT UP
	ADJBP B,A
	SETZ A,			;GET COUNT TOO
CAEOL1:	ILDB A,CEBPTR		;GET NEXT CHARACTER
	JUMPE A,CAEOL2
	AOS CECPOS		;UPDATE POSITION
	JRST CAEOL1

CAEOL2:	MOVEM B,CEBPTR		;SAVE NEW POINTER
	JRST CEINC		;DONE

;HERE TO DELETE THE REST OF THE LINE
CACOLN:	CALL CAFLBK
	SKIPN CEDUMB		;SMART TERMINAL?
	 JRST CACLN1		;YES, SKIP THIS
	CALL CADELF		;SIGNAL DELETE
	MOVE A,CEBPTR		;GET POINTER
	PSOUT			;WRITE THE RESTO OF THE STRING
	TYPE <\\>		;SIGNAL NO MORE DELETE
	SETZM CADLFG
CACLN1:	SETZ A,			;CHOP OFF THE REST OF THE STRING
	MOVE B,CEBPTR		;GET COPY OF POINTER
	IDPB A,B		;CURSOR IS ONE POSITION PAST POINTER
	CALL EEOLN		;JUST IN CASE
	JRST CEINC		;ALL DONE

;HERE TO MOVE TO RIGHT
CARIGH:	CALL CAFLSH
	CAIG P3,0		;ARGUMENT OK?
	 MOVX P3,1		;FIX IT UP
CARIG1:	ILDB A,CEBPTR		;GET NEXT CHARACTER
	JUMPE A,CARIG2		;END OF LINE
	AOS CECPOS		;UPDATE POSITION
	PBOUT			;MOVE OVER
	SOJG P3,CARIG1		;DO THE REST
	JRST CEINC		;DONE

CARIG2:	SETO A,			;WENT TOO FAR
	ADJBP A,CEBPTR		;BACK UP
	MOVEM A,CEBPTR
	JRST CEINC		;DONE

;HERE TO MOVE TO THE LEFT
CALEFT:	CALL CAFLDE
	SKIPN CECPOS		;BEGINNING OF LINE?
	 JRST CEINC		;YES, SKIP
	CAIN P3,0		;NO ARGUMENT?
	 MOVX P3,1		;MAKE IT A 1
	CAML P3,CECPOS		;ARGUMENT TOO BIG?
	 MOVE P3,CECPOS		;YES, TRIM IT DOWN
	SKIPE CEDUMB		;SMART TERMINAL
	 JRST CALFT1		;NO
	MOVN C,P3		;FIX THE POINTER
	ADJBP C,CEBPTR
	MOVEM C,CEBPTR
	MOVN A,P3		;FIX POSITION
	ADDM A,CECPOS
;130	JRST CINST1		;POSITION CURSOR
	CALL CACTYP		;130 No CINST1 in new VMS implementation,
	JRST CEINC		;130 but this is equivalent

CALFT1:	CALL CABAKF		;SIGNAL BACK MOVEMENT
CALFT2:	LDB A,CEBPTR		;GET THIS CHARACTER
	PBOUT			;OUTPUT IT
	SETO B,			;MOVE THE POINTER BACK
	ADJBP B,CEBPTR		;BACK UP THE POINTER
	MOVEM B,CEBPTR
	SOS CECPOS
	SOJG P3,CALFT2		;DO THE REST
	JRST CEINC		;GET NEXT COMMAND


;ROUTINES TO PRINT \ AND \\ FOR DUMB TERMINAL ALTER MODE
CAFLSH:	CALL CAFLBK		;FLUSH OUT BACKSPACE CHARACTER
	CALL CAFLDE		;FLUSH OUT DELETE CHARACTER
	RET

CAFLBK:	SKIPN CEDUMB
	 RET
	SKIPN CABKFG		;WERE WE BACKSPACING?
	 RET			;NO, NOTHING TO DO
	SETZM CABKFG		;RESET THE FLAG
	TYPE <\>		;SIGNAL END OF BACKSPACE
	RET

CAFLDE:	SKIPN CEDUMB		;DUMB TERMINAL?
	 RET			;YES, RETURN
	SKIPN CADLFG		;WERE WE IN A DELETE?
	 RET			;NO
	SETZM CADLFG		;RESET FLAG
	TYPE <\\>		;SIGNAL END OF DELETE
	RET

CABAKF:	SKIPN CEDUMB
	 RET
	SKIPN CABKFG		;SET?
	TYPE <\>		;NO, SIGNAL
	SETOM CABKFG		;SET BACKSPACE FLAG
	RET

CADELF:	SKIPN CEDUMB
	 RET
	SKIPN CADLFG		;SET?
	TYPE <\\>		;NO, SIGNAL
	SETOM CADLFG		;SET DELETE FLAG
	RET


NOVTS,<				;130 old implementation/non-VTS
;EMACS MODE BEGINS HERE

ECEINC:	MOVX A,.CTTRM		;ALLOW 8 BIT INPUT
	RFMOD			;GET THE MODE WORD
	PUSH P,B		;SAVE IT
	TXZ B,TT%DAM		;BINARY MODE
	SFMOD
	PBIN			;GET EDIT CHARACTER
	POP P,B			;RESTORE MODE WORD
	PUSH P,A		;SAVE CHARACTER
	MOVX A,.CTTRM
	SFMOD
	POP P,A			;RESTORE CHARACTER
	SKIPN CEMETA		;META KEY IN USE?
	 TRZ A,200		;NO, TRIM PARITY BIT
	TRZE A,200		;META KEY USED?
	 JRST METAN1		;YES, PROCESS IT
				;7 some changes here
	CAIN A,.CHCNA		;^A - MOVE TO BEGINNING OF LINE
	 JRST CEBEGN
	CAIE A,.CHCNB		;^B - CURSOR LEFT
	 CAIN A,.CHBSP		;BACKSPACE - CURSOR LEFT
	  JRST CELEFT
	CAIE A,.CHCNC		;^C - ABORT
	 CAIN A,.CHBEL		;^G - ABORT
	  JRST CEQUIT
	CAIN A,.CHCND		;^D - DELETE CHARACTER AT CURSOR
	 JRST CERMSP
	CAIN A,.CHCNE		;^E - MOVE TO END OF LINE
	 JRST CEMEND
	CAIN A,.CHCNF		;^F - CURSOR RIGHT
	 JRST CERIGH
	CAIN A,.CHTAB		;TAB - INSERT WITHOUT V
	 JRST CINSRT
	CAIE A,.CHLFD		;LINEFEED - EXIT AND DO EDITED COMMAND
	 CAIN A,CR		;RETURN - EXIT AND DO EDITED COMMAND
	  JRST CEEXIT
	CAIN A,.CHVTB		;^K (VERTICAL TAB) - KILL TO END OF LINE
	 JRST CEKILL
	CAIN A,.CHFFD		;^L (FORM FEED) - CLEAR SCREEN AND REDISPLAY
	 JRST CECLDS
	CAIN A,.CHCNN		;^N - CURSOR DOWN
	 JRST CEDOWN
	CAIN A,.CHCNP		;^P - EDIT PREVIOUS COMMAND
	 JRST CEUP
	CAIN A,.CHCNR		;^R - REDISPLAY LINE
	 JRST CEDISP
	CAIN A,.CHCNQ		;^Q - QUOTE NEXT CHARACTER
	 JRST CEQUOT
	CAIN A,.CHCNT		;^T - TRANSPOSE CHARACTERS
	 JRST CETRAN
	CAIN A,.CHESC		;<ESC> - META PREFIX
	 JRST METAIN
	CAIN A,.CHCUN		;^_ - HELP MESSAGE
	 JRST CEHELP
	CAIN A,.CHDEL		;RUBOUT - DELETE CHAR AT LEFT OF CURSOR
	  JRST CELEFT
	CAIGE A," "		;SOME OTHER CONTROL CHARACTER?
	 JRST CEINC		;YES, IGNORE IT
	JRST CINSRT		;INSERT THIS CHARACTER

CEQUOT:	PBIN			;GET THE CHARACTER
	CAIE A,.CHLFD		;7 any chars except CR or LF
	 CAIN A,CR		;7
	  JRST CEQUOT		;7
	JRST CINSRT		;PROCESS IT

;AN ESCAPE HAS BEEN ENTERED, GET THE NEXT COMMAND CHARACTER
METAIN:	PBIN			;GET THE NEXT WORD
METAN1:	CAIN A,.CHESC		;M-ESC - STUFF COMMAND WITH <ESC>
	 JRST METAES
	CAIN A,"?"		;M-? - STUFF COMMAND WITH ?
	 JRST METAQU
	CAIE A,"B"		;M-B - BACK TO BEGINNING OF WORD
	 CAIN A,"b"
	  JRST METAB
	CAIE A,"D"		;M-D - DELETE TO END OF WORD
	 CAIN A,"d"
	  JRST METAD
	CAIE A,"F"		;M-F - FORWARD TO END OF WORD
	 CAIN A,"f"
	  JRST METAF
	CAIE A,"N"		;M-n - insert ^N 
	 CAIN A,"n"
	  JRST METAN
	CAIN A,.CHDEL		;M-RUB - DELETE BACK TO START OF WORD
	 JRST METARB
	CALL CEBELL		;ERROR, RING BELL
	JRST CEINC		;TRY AGAIN


;HERE TO INSERT A CHARACTER INTO THE COMMAND LINE
;717 VTS doesn't look good here
METAN:	MOVX A,.CHCNN		;7 a ^N fall through
CINSRT:	MOVE C,CEBPTR		;GET THE POINTER
CINST:	ILDB B,C		;GET ONE THAT WAS THERE
	DPB A,C			;REPLACE IT
	JUMPE A,CINST0		;EXIT AFTER A NULL BYTE
	PBOUT			;OUTPUT IT
	MOVE A,B		;SET UP TO REINSERT THE ONE
	JRST CINST
CINST0:	AOS A,CECPOS		;UPDATE EVERYTHING
	IBP CEBPTR

CINST1:	TYPE <>		;POSITION THE CURSOR
	CALL CENUMB		;MOVE PAST THE LINE NUMBER
	MOVE A,COJFN		;POINT TO THE TERMINAL
	HRROI B,CETSAV		;POINT TO THE STRING
	MOVN C,CECPOS		;GET COUNT
	CAIE C,0		;DON'T GO FOREVER HERE
	 SOUT			;MOVE PAST THE OLD CHARACTERS
	JRST CEINC		;DONE

;MOVE THE CURSOR TO THE LEFT (OR RUBOUT)
CELEFT:	SKIPN CECPOS		;AT BEGINNING OF BUFFER?
	 JRST CEINC		;YES, DO NOTHING
	LDB C,CEBPTR		;GET CHARACTER WE ARE GOING TO
	SETO B,
	ADJBP B,CEBPTR		;DECR BYTE PTR
	MOVEM B,CEBPTR
	SOS CECPOS		;DECR CHARACTER POSITION
	CAIN A,.CHDEL		;RUBOUT?
	 JRST CERMSP		;YES, ERRASE LAST CHARACTER
	CAIGE C," "		;SOME CONTROL CHARACTER?
	 JRST CINST1		;YES, DON'T MESS UP
	CALL CEBACK		;BACK UP
	JRST CEINC

;MOVE THE CURSOR TO THE END OF THE LINE
CEMEND:	MOVE B,CEBPTR		;SEE IF WE'RE POINTING AT ZERO BYTE
	ILDB A,B
	JUMPE A,CEMND1		;AT END OF LINE, QUIT
	AOS CECPOS
	PBOUT			;MOVE OVER
	JRST CEMEND+1

CEMND1:	SETO C,
	ADJBP C,B
	MOVEM C,CEBPTR		;MAKE BYTE POINTER AGREE WITH CURSOR
	JRST CEINC

;MOVE THE CURSOR TO THE RIGHT
;717 VTS doesn't look good here
CERIGH:	MOVE B,CEBPTR		;SEE IF WE'RE POINTING AT ZERO BYTE
	ILDB A,B
	JUMPE A,CEINC		;AT END OF BUFFER, DO NOTHING
	PBOUT			;MOVE OVER
	AOS CECPOS		;INCR CHARACTER POSITION
	IBP CEBPTR		;INCREMENT POINTER
	JRST CEINC

;MOVE TO THE NEXT COMMAND LINE
CEDOWN:	HRRZ A,@CELPTR		;TAKE THE RIGHT HAND LINK
	CAIN A,0		;CHECK FOR END OF LIST
	 JRST CEDWN1		;NOT AT END, SKIP THIS
	SOS CELPOS		;DECREMENT THE LINE NUMBER
	MOVEM A,CELPTR		;UPDATE POINTER
	JRST CETOP		;PROCESS THIS LINE

CEDWN1:	MOVE A,CE1ST		;END OF LIST, GO BACK TO THE FIRST LINE
	MOVEM A,CELPTR		;RESET THE POINTER
	MOVE A,CECNT		;GET RIGHT LINE NUMBER
	SUBI A,1
	MOVEM A,CELPOS		;SET IT
	JRST CETOP		;PROCESS THIS LINE

;MOVE TO THE PREVIOUS COMMAND LINE
CEUP:	HLRZ A,@CELPTR		;TAKE THE LEFT HAND LINK
	CAIN A,0		;CHECK FOR END OF LIST
	 JRST CEUP1		;NOT AT END
	AOS CELPOS		;INCREMENT THE LINE NUMBER
	MOVEM A,CELPTR		;UPDATE POINTER
	JRST CETOP		;PROCESS THIS LINE

CEUP1:	MOVE A,CELAST		;END OF LIST, GO BACK TO THE FIRST LINE
	MOVEM A,CELPTR		;RESET THE POINTER
	SETZM CELPOS		;RESET LINE NUMBER
	JRST CETOP		;PROCESS THIS LINE

;HERE TO DELETE THE CHARACTER AT THE CURSOR
CERMSP: MOVE B,CEBPTR		;GET DESTINATION POINTER
	MOVX A,1
	ADJBP A,CEBPTR		;POINTER TO SOURCE
	LDB C,A			;ZERO BYTE?
	JUMPE A,CEINC		;YES, QUIT
	SETZ C,			;NO, MOVE THE TEXT
	SIN
	TYPE <>		;START OVER
	CALL CENUMB		;WRITE THE LINE NUMBER
	HRROI A,CETSAV		;AND THE LINE
	PSOUT
	CALL EEOLN
	JRST CINST1		;POSITION THE CURSOR

;HERE TO MOVE THE CURSOR TO THE BEGINNING OF THE LINE
CEBEGN:	MOVEI A,CETSAV		;FIX POINTER
	HLL A,[ASCPTR]
	MOVEM A,CEBPTR
	SETZM CECPOS		;RESET POINTER TO BEGINNING OF LINE
	TYPE <>		;MOVE CURSOR TO BEGINNING
	CALL CENUMB		;WRITE THE LINE NUMBER
	JRST CEINC		;GET NEXT COMMAND

;HERE TO KILL EVERYTHING TO THE RIGHT OF THE CURSOR
CEKILL:	SETZ A,			;CHOP OFF THE REST OF THE STRING
	MOVE B,CEBPTR		;GET COPY OF POINTER
	IDPB A,B		;CURSOR IS ONE POSITION PAST POINTER
	CALL EEOLN		;ERRASE IT FROM THE SCREEN
	JRST CEINC		;GET NEXT COMMAND

;HERE TO SWAP THE CHARACTER AT THE CURSOR AND THE ONE BEFORE IT
CETRAN:	SKIPN CECPOS		;BEGINNING OF LINE?
	 JRST CEINC		;YES, SKIP
	MOVE B,CEBPTR
	ILDB A,B		;END OF LINE?
	JUMPE A,CEINC
	MOVE B,CEBPTR		;GET LOCAL POINTER
	MOVX A,1		;SCOOT OVER ONE
	ADJBP A,B
	LDB C,A			;CHANGE THE CHARACTERS IN THE BUFFER
	LDB D,B
	DPB D,A
	DPB C,B
	TYPE <>		;REWRITE THE LINE
	CALL CENUMB
	HRROI A,CETSAV
	PSOUT
	JRST CINST1		;POSITION CURSOR

;HERE TO MOVE TO THE BEGINNING OF THE NEXT WORD
METAF:	CALL F.WORD		;GET DESTINATION
	ADDM B,CECPOS		;UPDATE POSITION
	JUMPE B,CEINC		;NO MOVEMENT, STOP
	ADJBP B,CEBPTR		;UPDATE POINTER
	MOVEM B,CEBPTR		;SAVE IT
	JRST CINST1		;MOVE CURSOR OVER

;HERE TO MOVE TO THE BEGINNING OF THE PREVIOUS WORD
METAB:	CALL B.WORD		;GET DESTINATION
	JUMPE B,CEINC		;SKIP IF NO MOVEMENT
	MOVN B,B		;MAKE IT NEGATIVE
	MOVE C,B		;GET A COPY OF IT
	ADJBP C,CEBPTR		;UPDATE THE POINTER
	MOVEM C,CEBPTR
	ADDM B,CECPOS		;UPDATE POSITION
	JRST CINST1		;UPDATE CURSOR

;HERE TO DELETE UP TO THE BEGINNING OF THE NEXT WORD
METAD:	CALL F.WORD		;GET DESTINATION
	MOVE A,B		;GET COPY OF OFFSET
	ADJBP A,CEBPTR		;POINTER TO DESTINATION
	JRST M.FIX		;MOVE EVERYTHING

;HERE TO DELETE BACK TO THE BEGINNING OF THE PREVIOUS (OR THIS) WORD
METARB:	CALL B.WORD		;GET DESTINATION
	MOVN D,B		;MAKE IT NEGATIVE
	MOVE A,D
	ADDM A,CECPOS		;FIX UP POSITION
	ADJBP A,CEBPTR		;GET DESTINATION POINTER
	EXCH A,CEBPTR		;FOOL M.FIX - WE ARE NOW A M-D
METAR1:	JUMPE D,M.FIX		;NEED TO MOVE THE CURSOR OVER
	PUSH P,A		;SAVE THE POINTER
	CALL CEBACK		;BACK UP
	POP P,A			;RESTORE THE POINTER
	AOJA D,METAR1
>;130 old implementation

;130 The following three routines are used by Alter mode, so leave them around
;HERE TO FIX THINGS UP AFTER METAD, METARB, OR ALTER MODE DELETE
M.FIX:	MOVE B,A		;GET COPY OF DESTINATION POINTER
	SKIPN CEDUMB		;EMACS OR SMART ALTER?
	 PSOUT			;YES, OVERWRITE THE SCREEN
	CALL EEOLN		;CLEAN THINGS UP
	MOVE A,CEBPTR		;GET CURRENT POINTER
M.FIX1:	ILDB C,B		;GET FIRST CHARACTER
	IDPB C,A		;SAVE IN NEW POSITION
	JUMPN C,M.FIX1		;DONE?
;130	JRST CINST1		;POSITION THE CURSOR
	CALL CACTYP		;130
	JRST CEINC		;130

;SUBROUTINE TO RETURN NUMBER OF SPACES UNTIL START OF NEXT WORD
F.WORD:	SETZ B,			;INITIALIZE COUNT
	MOVE C,CEBPTR		;GET LOCAL COPY OF POINTER
	ILDB A,C		;GET THIS CHARACTER
	JUMPE A,[RET]		;END OF LINE, QUIT
	CAILE A," "		;WHITE SPACE?
	 JRST F.WRD2		;YES, ALMOST THERE
F.WRD1:	ILDB A,C		;GET NEXT CHARACTER
	ADDI B,1		;UPDATE COUNT
	JUMPE A,[RET]		;END OF LINE
	CAIG A," "		;STILL WHITE SPACE?
	 JRST F.WRD1		;YES, KEEP LOOKING
F.WRD2:	ILDB A,C		;GET NEXT CHARACTER
	ADDI B,1		;INCREMENT COUNT
	JUMPE A,[RET]		;END OF LINE
	CAILE A," "		;WHITE SPACE?
	 JRST F.WRD2		;NO, KEEP LOOKING
	RET			;YES, DONE.

;SUBROUTINE TO RETURN NUMBER OF SPACES UNTIL START OF PREVIOUS WORD
B.WORD:	SETZ B,			;INITIALIZE COUNT
	MOVE C,CEBPTR		;GET LOCAL COPY OF POINTER
	MOVE D,CECPOS		;LOCAL COPY OF POSITION
	JUMPE D,[RET]		;BEGINNING OF LINE, EXIT
	ILDB A,C		;GET THIS CHARACTER
	CAIG A," "		;WHITE SPACE?
	 JRST B.WRD1		;YES, SKIP THIS PART
	LDB A,CEBPTR		;GET CHARACTER BEFORE THIS ONE
	CAILE A," "		;WHITE SPACE
	 JRST B.WRD2		;NO, IN THE MIDDLE OF A WORD
B.WRD1:	SETO A,			;BACKUP THE POINTER
	ADJBP A,C
	MOVE C,A
	LDB A,C			;GET NEXT ONE
	SUBI D,1		;UPDATE COUNT
	ADDI B,1		;UPDATE THIS TOO
	JUMPE D,[RET]		;CHECK FOR BEGINNING OF LINE
	CAIG A," "		;STILL WHITE SPACE?
	 JRST B.WRD1		;YES, KEEP LOOKING
B.WRD2:	SETO A,			;BACKUP THE POINTER
	ADJBP A,C
	MOVE C,A
	LDB A,C			;GET NEXT CHARACTER
	SUBI D,1		;UPDATE EVERYTHING
	ADDI B,1
	JUMPE D,[RET]		;CHECK FOR BEGINNING OF LINE
	CAILE A," "		;STILL IN A WORD?
	 JRST B.WRD2		;YES, LOOP BACK
	SUBI B,1		;ADJUST IF NOT BEGINNING OF LINE
	RET			;ALL DONE


NOVTS,<				;130 more old implementation/non-VTS
;HERE TO STICK AN ESCAPE OR QUESTION MARK ON THE END OF THE COMMAND
METAES:	SKIPA B,[.CHESC]	;STUFF ESCAPE WITH THE COMMAND
METAQU:	 MOVEI B,"?"		;STUFF ? WITH THE COMMAND
METAEQ:	ILDB A,CEBPTR		;LOOK FOR THE END OF THE LINE
	JUMPE A,METEQ1
	JRST METAEQ		;TRY AGAIN

METEQ1:	DPB B,CEBPTR		;STUFF THE NEW CHARACTER
	IDPB A,CEBPTR		;ADD A ZERO BYTE
	MOVEI C,CETSAV		;STUFF LINE HERE WITH NO CR AT END
	HRLI C,(ASCPTR)		;MAKE A POINTER
	MOVX A,.CTTRM
	CFIBF			;CLEAR THE TYPE AHEAD
METEQ2:	ILDB B,C		;GET NEXT CHAR
	JUMPE B,CEQUIT
	STI			;STUFF IT
	JRST METEQ2

;HERE WHEN DONE. STUFF THE EDITED COMMAND INTO THE TERMINALS INPUT BUFFER
CEEXIT:	MOVEI C,CETSAV		;POINT TO CURRENT LINE
	HRLI C,(ASCPTR)
	MOVEI A,.CTTRM		;GET THE TERMINAL DESIGNATOR
	CFIBF
CEEX2:	ILDB B,C		;GET NEXT CHAR
	JUMPE B,CEEX3		;END ON A ZERO BYTE
	CAIN B,.CHCNN		;7 multi-line stuffs
	 MOVX B,CR		;7
	STI			;STUFF IT
	JRST CEEX2		;DO THE REST

CEEX3:	MOVEI B,CR
	STI

CEQUIT: MOVEI Q1,ETTYMD		;LOAD EXEC TTY MODES
	CALL LTTYMD
	MOVX A,.CTTRM		;RESTORE PAGE MODE IF WE NEED TO
	POP P,B
	STPAR
	SETOM CEBPTR		;DON'T SAVE THIS
	ETYPE <%_>
	RET

;ROUTINE TO REDISPLAY THE LINE
CECLDS: CALL BLANK1
CEDISP:	ETYPE <%_>		;GO TO A NEW LINE
	CALL EEOLN		;JUST TO BE SURE
CEDIS0:	CALL CENUMB		;DO THE LINE NUMBER
	HRROI A,CETSAV		;POINT TO COMMAND LINE
	PSOUT			;WRITE IT OUT
	JRST CINST1		;POSITION THE CURSOR
>;130 old implementation


;130 Start addition for new implementation
VTS,<

CEBIN:	MOVX A,.CTTRM		;Go into binary mode so can read meta key
	MOVE B,CEFMOD
	TXZ B,TT%IGN!TT%ECO!TT%PGM!TT%TAB!TT%DAM
	TXO B,TT%WAK
	SFMOD%
	BIN%			;Read it
	PUSH P,B
	MOVE B,CEFMOD		;Restore mode
	TXZ B,TT%IGN!TT%ECO!TT%PGM!TT%TAB
	TXO B,TT%WAK
	SFMOD%
	POP P,A
	SKIPN CEMETA
	  TRZ A,200
	JUMPE A,CEBIN		;Ignore nulls
	RET

CETAB:	.CHCNA,,CEBEGN		;^A - beginning of line
	.CHCNB,,CEBSP		;^B - backward character
	.CHCNC,,CEQUIT		;^C - quit
	.CHCND,,CEDEL		;^D - delete char
	.CHCNE,,CEEND		;^E - end of line
	.CHCNF,,CEFWD		;^F - forward character
	.CHBEL,,CEABOR		;^G - clear numarg or abort
	.CHBSP,,CEBSP		;^H - same as ^B
	.CHTAB,,CEINS		;^I - insert tab
	.CHLFD,,CEEXIT		;^J - same as ^M
	.CHVTB,,CEKILL		;^K - kill line
	.CHFFD,,CECLR		;^L - clear screen
	.CHCRT,,CEEXIT		;^M - add ^M and exit
	.CHCNN,,CEDOWN		;^N - next line
	.CHCNP,,CEUP		;^P - previous line
	.CHCNQ,,CEQUOT		;^Q - quote character
	.CHCNR,,CEDISP		;^R - retype line
	.CHCNT,,CETRAN		;^T - transpose characters
	.CHCNU,,CEUARG		;^U - universal argument
	.CHCNV,,CEINS		;^V - self-inserting
	.CHCNW,,CERUBW		;^W - rubout word
	.CHCNZ,,CEXIT		;^Z - exit without adding CR
	.CHDEL,,CERUB		;^? - rubout character
	.CHCUN,,CEHELP		;^_ - help message
	200!.CHESC,,CEMEXI	;M-Esc - Add ESC and exit
	200!"?",,CEQEXI		;M-? - add ? and exit
	200!"B",,CEBSPW		;M-B - backward word
	200!"D",,CEDELW		;M-D - delete word
	200!"F",,CEFWDW		;M-F - forward word
	200!"N",,CEINSN		;M-N - insert ^N
	200!.CHCNN,,CEINSN	;C-M-N - insert ^N
	200!.CHDEL,,CERUBW	;M-Rubout - rubout word
NCETAB==:.-CETAB


;In Emacs mode:
; P3 is the arg
; Q1 has the terminal characteristics
; CENUMR is the arg flag: 1 if no arg, -1 if ^U last, 0 if arg digits last
; CEDSEA is the partial display flag: -1 if full display, else number of
;	 characters past cursor visible on last line.  It's always -1 if
;	 TC%MOV is set in Q1.
; CEWINL is the screen line of first line of buffer, if TC%MOV is on.

ECEINC:	MOVEI P3,1		;Initialize arg
	MOVEM P3,CENUMR		;No real arg yet
ECEIN0:	CALL CEBIN		;Get character
	CAIE A,.CHESC		;Escape is meta prefix
	IFSKP.
	  CALL CEBIN
	  TRO A,200
	ENDIF.
	CAIL A,200+"a"		;Meta letters are case-insensitive
	 CAILE A,200+"z"
	  IFSKP. <SUBI A,"a"-"A">
	MOVSI B,-NCETAB		;Look for a function for this letter
	DO.
	  HLRZ C,CETAB(B)
	  CAME C,A
	  IFSKP.
	    HRRZ C,CETAB(B)
	    JRST (C)
	  ENDIF.
	  AOBJN B,TOP.
	ENDDO.
	CAIL A,"0"		;Not found in table
	 CAILE A,"9"
	  IFSKP. <JRST CEDIG>	;If a digit, go do that
	CAIL A,"0"+200
	 CAILE A,"9"+200
	  IFSKP. <JRST CEMDIG>	;If meta-digit, go do it
	CAIL A," "
	 CAIL A,177
	  JRST CERR		;Random control and meta chars err out
	JRST CEINS		;Everything else self-inserts

CERR:	CALL CEBELL
	JRST CEINC


CEQEXI:	MOVEI A,"?"		;Exit with a question mark
	JRST CEXIT0
CEMEXI:	MOVEI A,.CHESC		;Exit with escape
	JRST CEXIT0
CEEXIT:	MOVEI A,.CHCRT		;Exit with a CR
	JRST CEXIT0
CEXIT:	SETZ A,			;Exit as-is
	;JRST CEXIT0
CEXIT0:	PUSH P,A		;Save the final character
	MOVX A,.CTTRM
	CFIBF%			;Clear typeahead
	MOVE C,[ASCPTR CETSAV]	;Stuff buffer
	DO.
	  ILDB B,C
	  JUMPE B,ENDLP.
	  CAIN B,.CHCNN		;^N becomes CR
	   MOVEI B,.CHCRT
	  STI%
	  LOOP.
	ENDDO.
	POP P,B			;Get back the final character
	SKIPE B			;And add it
	  STI%
CEQUIT:	IFXN. Q1,TC%MOV		;If can move cursor
	  CALL ENDCOL		;Move to the last line
	  MOVE C,A
	  CALL ABSMOV
	ENDIF.
	MOVEI Q1,ETTYMD		;Load EXEC TTY modes
	CALL LTTYMD
	MOVX A,.CTTRM		;Restore page mode
	MOVE B,CEFMOD
	STPAR%
	MOVE B,CETCHR		;Restore tc%wrp
	STCHR%
	SETOM CEBPTR		;Don't save this
	CALLRET CNEWLN		;Get a fresh line and return from CEDITU

CEABOR:	SKIPG CENUMR		;If have an arg
	 JRST CERR		;Just flush it and beep
	JRST CEQUIT		;else exit, for compatibility

CEUARG:	IMULI P3,4		;Increase arg
	SETOM CENUMR		;Mark that ^U last
	JRST ECEIN0		;Continue without resetting arg

CEDIG:	SKIPLE CENUMR		;If not in an arg
	 JRST CEINS		;digits just self-insert
CEMDIG:	SKIPE CENUMR		;If didn't just do a digit before
	 SETZ P3,		;then start arg over
	SETZM CENUMR		;Mark that digit last
	IMULI P3,^D10		;Accumulate arg
	ANDI A,17
	ADD P3,A
	JRST ECEIN0		;Continue without resetting arg

CEDOWN:	HRRZ A,@CELPTR		;TAKE THE RIGHT HAND LINK
	IFE. A			;End of list
	  MOVE A,CECNT
	  MOVEM A,CELPOS
	  MOVE A,CE1ST
	ENDIF.
	SOS CELPOS		;DECREMENT THE LINE NUMBER
	JRST CEUP1		;Join common code

CEUP:	HLRZ A,@CELPTR		;TAKE THE LEFT HAND LINK
	IFE. A
	  SETOM CELPOS
	  MOVE A,CELAST
	ENDIF.
	AOS CELPOS		;INCREMENT THE LINE NUMBER
CEUP1:	MOVEM A,CELPTR		;UPDATE POINTER
	IFXN. Q1,TC%MOV		;If can move
	  CALL ENDCOL		;Go to last line, looks better this way
	  MOVE C,A
	  CALL ABSMOV
	ENDIF.
	JRST CETOP		;PROCESS THIS LINE


CETRAN:	MOVEI P3,1
	MOVE B,CEBPTR
	ILDB A,B
	SKIPN A			;End of line?
	  MOVEI P3,2		;Yes, will want to move back 2
	CAMLE P3,CECPOS		;Must have at least 2 chars
	  JRST CERR
	CALL CEBSP0		;Move back to start of the two chars
	CALL DSPCOL		;Get end column for later
	MOVE D,A
	MOVE A,CEBPTR		;Do buffer
	ILDB B,A
	MOVE C,A
	ILDB C,C
	DPB C,A
	IDPB B,A
	SKIPN CEDSEA		;If have junk after cursor
	IFSKP.			;check for special cases
	  JXN Q1,TC%OVR,CETRA1	;Like overstriking
	  CAIE B,.CHTAB		;or tabs, since then the positions change
	   CAIN C,.CHTAB
	    JRST CETRA1
	ENDIF.
	MOVEI A,2		;Everything is ok, adjust position
	ADDM A,CECPOS
	ADJBP A,CEBPTR
	MOVEM A,CEBPTR
	MOVE A,C		;Output the two characters
	PBOUT%
	SKIPLE CEDSEA
	 SOS CEDSEA
	MOVE A,B
	PBOUT%
	SKIPLE CEDSEA
	 SOS CEDSEA
	CAIN P3,1		;If were in between the two chars
	  CALL CEBSP0		;go back there
	JRST CEINC		;and done

CETRA1:	;Here if can't just replace the chars for whatever reason
	MOVE B,D		;Get back old end column
	CALL CTYPEL		;Type the rest of the line over old cruft
	MOVE A,P2		;Set buffer to final position
	ADDM A,CECPOS
	ADJBP A,CEBPTR
	MOVEM A,CEBPTR
	CALL CEREPN		;Go there
	JRST CEINC

CECLR:	MOVEI A,.PRIOU
	MOVEI B,.VTCLR
	VTSOP%
	 ERCAL CNEWLN
	JRST CEDIS0

CEDISP:	CALL CNEWLN		;Go to a new line
CEDIS0:	CALL CENUMB		;Output the whole thing
	HRROI A,CETSAV
	PSOUT%
	CALL EEOLN		;Clear just in case
	CALL ENDCOL
	MOVE B,A
	CALL SETWIN		;Recompute window line
	CALL CEREPN		;And reposition back to cursor position
	JRST CEINC


CEBSPW:	JUMPLE P3,CEINC
	CALL BWORDS		;Convert word count to character count
	JUMPLE P3,CERR		;At start of line already...
	JRST CEBSP

CEBEGN:	MOVE P3,CECPOS
CEBSP:	JUMPLE P3,CEINC		;Check and adjust arg
	SKIPG CECPOS
	 JRST CERR
	CALL CEBSP0
	JRST CEINC

CEBSP0:	CAMLE P3,CECPOS
	 MOVE P3,CECPOS
	CALL CURCOL		;A/ current column in display
	MOVN B,P3		;Do the buffer
	ADDM B,CECPOS
	ADJBP B,CEBPTR
	MOVEM B,CEBPTR
	SKIPL CEDSEA
	 ADDM P3,CEDSEA
	SKIPA B,A
CEREPN:  SETOM CEDSEA
;;Reposition cursor by moving left:
;; Enter with B/current column, CECPOS/target position
;;If cannot get to the target position, and CEDSEA is not -1, then types
;;from CECPOS-P3 to end (before retyping to cursor).
MVLEFT:	CALL CURCOL		;Find target column in display
	CAMN B,A		;If no change
	 RET			;don't bother
	MOVE C,A
	JXN Q1,TC%MOV,ABSMOV	;If can move, do so!
	SUBM B,A		;A= distance
	CAILE A,(.MINFI)	;Must not change lines, since can't move up
	IFSKP.
	  CAILE A,10(C)		;If bsp is not much more expensive than CR+type
	   TXNE B,.LHALF	;or we're not on first line, so can't CR
	    TXNN Q1,TC%BS	;Then use backspace if we can
	  IFSKP.
	    MOVE C,A
	    MOVX B,DP%AG1+.VTBCK
	    MOVEI A,.PRIOU
	    VTSOP%
	     ERNOP
	    RET
	  ENDIF.
	  IFXE. B,.LHALF	;If we're on first line
	    MOVEI A,.CHCRT	;Go to start of the line
	    PBOUT%
	    JRST MVLEF1		;And retype to cursor to move forward
	  ENDIF.
	ENDIF.
	MOVE A,P3		;Else can't get there from here
	ADJBP A,CEBPTR		;Type to end so have full display
	SKIPL CEDSEA
	 PSOUT%
	CALL CNEWLN		;Get a fresh line
	SETZM CEDSEA		;Will only type to cursor
MVLEF1:	CALL CENUMB
	MOVEI A,.PRIOU
	HRROI B,CETSAV
	MOVN C,CECPOS
	SKIPGE C
	 SOUT%
	RET


CEKILL:	MOVX P3,.INFIN
	JRST CEDEL

CERUBW:	JUMPLE P3,CEINC
	CALL BWORDS		;Convert word count to character count
	JUMPLE P3,CERR
CERUB:	JUMPLE P3,CEINC
	SKIPG CECPOS
	 JRST CERR
	CALL CEBSP0
	JRST CEDEL

CEDELW:	JUMPLE P3,CEINC
	CALL FWORDS		;Convert word count to character count
	JUMPLE P3,CERR
CEDEL:	JUMPLE P3,CEINC		;Check arg
	MOVE B,CEBPTR
	ILDB A,B
	JUMPE A,CERR
	MOVE C,P3
	DO.
	  ILDB A,B
	  JUMPE A,[SUB P3,C	;Killing everything
		   AOJA P3,CEDEL0]
	  SOJG C,TOP.
	ENDDO.
	MOVE A,CECPOS		;Compute end of region, in case can do
	ADD A,P3		;a character delete.
	CALL POSCOL
	TXZA Z,F4
CEDEL0:	 TXO Z,F4		;F4=on if shouldn't try CID
	CALL CEDEL1		;subroutine so can do stkvar
	JRST CEINC

CEDEL1:	STKVAR <CCOL,DCOL,ECOL>
	MOVEM A,ECOL		;Save end col if have one
	CALL DSPCOL		;Compute end of display
	MOVEM A,DCOL
	CALL CURCOL		;And current column in display
	MOVEM A,CCOL
	MOVE B,CEBPTR		;Do the buffer now
	MOVE A,P3
	ADJBP A,B
	DO.
	  ILDB C,A
	  IDPB C,B
	  CAIN C,.CHTAB
	   TXO Z,F4		;Remember if have tabs
	  JUMPN C,TOP.
	ENDDO.
	TXNE Q1,TC%CID		;If can CID
	 SKIPL CEDSEA		;and have full display
	IFSKP.
	  MOVE A,DCOL
	  SUB A,CCOL
	  CAIGE A,(.MINFI)	;And we're on the last line
	   TXNE Z,F4		;And no tabs (and not doing a ^K)
	ANSKP.
	  MOVE C,CCOL		;Do it!
	  SUB C,ECOL
	  MOVX B,DP%AG1+.VTCID
	  MOVEI A,.PRIOU
	  VTSOP%
	   ERNOP
	  RET
	ENDIF.
	MOVE B,CCOL
	TRNN B,-1		;If we were in column 0
	 SKIPG B		;of a continuation line
	IFSKP.
	  MOVE A,CEBPTR
	  ILDB A,A		;And we're at end of buffer now
	ANDE. A			;Deleting whole continuation line which means
	  CALL CEREPN		;moving up before the ! of previous line
	ENDIF.
	MOVE B,DCOL		;Type rest of buffer, clearing old junk
	CALL CTYPEL
	CALLRET CEREPN		;And go back to cursor

	ENDSV.

;Retype from cursor over old stuff, clearing anything left over.
;Called with B/ end of old stuff, returns with B/final position
CTYPEL:	STKVAR <OCOL>
	MOVEM B,OCOL		;Save current column
	TXNN Q1,TC%SCL		;If can't clear
	 TXNN Q1,TC%OVR		;and overstriking tty
	IFSKP.
	  SKIPN CEDSEA		;And have some junk after cursor
	ANSKP.
	  CALL CNEWLN		;Can't win, give up and get a fresh line
	  CALL CENUMB
	  HRROI A,CETSAV	;Retype from the beginning
	  SETZM OCOL
	ELSE.
	  CALL EEOLN		;Else erase current line for overstrikers
	  MOVE A,CEBPTR		;(Assume overflow cleared by normal typeout)
	ENDIF.
	PSOUT%			;Type the new buffer to the end
	CALL EEOLN		;Play it safe
	CALL ENDCOL
	MOVE B,A		;B=current position
	MOVE C,OCOL		;See how much cruft left over from before
	SUB C,A
	JUMPL C,SETWIN		;Typed past old stuff, just recompute window
	IFXN. Q1,TC%SCL		;If can clear
	  CAIGE C,(.MINFI)	;More old lines below?
	    RET			;No, done
	  HLRZ C,OCOL		;Else clear those as well
	  HLRZ A,B
	  SUB C,A
	  DO.
	    CALL CNEWLN
	    SOJG C,TOP.
	  ENDDO.
	  HLLZ B,OCOL		;New position
	  CALLRET SETWIN
	ENDIF.
	JUMPLE C,R		;Nothing left over, done
	CAIGE C,(.MINFI)	;If more than a line's worth
	IFSKP.
	  MOVE C,CETWID		;Just pad to end of the line
	  SUBI C,(B)
	ENDIF.
	DO.			;Clear junk with spaces
	  SOJL C,R
	  MOVEI A,.CHSPC
	  PBOUT%
	  AOJA B,TOP.
	ENDDO.

	ENDSV.


CEFWDW:	JUMPLE P3,CEINC
	CALL FWORDS		;Convert word count to character count
	JUMPLE P3,CERR
	JRST CEFWD

CEEND:	MOVE B,CEBPTR
	ILDB A,B
	JUMPE A,CEINC
	MOVX P3,.INFIN
CEFWD:	JUMPLE P3,CEINC
	MOVE B,CEBPTR
	ILDB A,B
	JUMPE A,CERR
	MOVE C,P3
	DO.
	  SOJL C,ENDLP.
	  ILDB A,B
	  JUMPN A,TOP.
	  SUB P3,C		;Arg too large, fix it
	ENDDO.
	ADDM P3,CECPOS		;Do buffer
	MOVE B,P3
	ADJBP B,CEBPTR
	MOVEM B,CEBPTR
	MOVE A,CEDSEA
	SUB A,P3
	SKIPGE A
	  SETZ A,
	SKIPL CEDSEA
	  MOVEM A,CEDSEA
	IFXN. Q1,TC%MOV		;If can move
	  CALL CURCOL		;Find target column
	  MOVE C,A
	  MOVE A,CECPOS		;See how much moving over
	  SUB A,P3
	  CALL POSCOL
	  SUBM C,A
	  CAIG A,5		;If no more than 5 chars, probably not worth it
	ANSKP.
	  CALL ABSMOV		;Else reposition cursor
	  JRST CEINC
	ENDIF.
	MOVEI A,.PRIOU		;Ok "move" by typing over.
	MOVN B,P3
	ADJBP B,CEBPTR
	MOVN C,P3
	SOUT%
	JRST CEINC


CEQUOT:	CALL CEBIN
	TXZ A,200
	CAIE A,.CHLFD		;Linefeeds and CR's become ^N when inserted..
	 CAIN A,.CHCRT
CEINSN:	  MOVEI A,.CHCNN
;	JRST CEINS

CEINS:	JUMPLE P3,CEINC
	MOVX D,5*CETSVL		;Make sure have room
	SUB D,CECPOS
	MOVE B,CEBPTR
	DO.
	  ILDB C,B
	  SOJ D,
	  JUMPN C,TOP.
	ENDDO.
	JUMPLE D,CERR		;No room for anything, beep
	CAMLE P3,D
	  MOVE P3,D
	PUSH P,A		;Do the buffer
	MOVE D,P3
	DO.
	  TXZ Z,F4
	  MOVE B,CEBPTR
	  MOVE A,(P)
	  DO.
	    ILDB C,B
	    DPB A,B
	    JUMPE A,ENDLP.
	    CAIN C,.CHTAB	;Remember if get any tabs
	     TXO Z,F4
	    MOVE A,C
	    LOOP.
	  ENDDO.
	  IBP CEBPTR
	  SOJG D,TOP.
	ENDDO.
	ADJSP P,-1		;All done with character
	ADDM P3,CECPOS
	MOVE B,CEBPTR
	ILDB A,B
	IFN. A			;If not at end of buffer
	  TXNE Q1,TC%CID	;And can do CID
	   SKIPL CEDSEA		;Must have full display
	ANSKP.
	  TXNE Z,F4		;No tabs
	ANSKP.
	  CALL ENDCOL		;Must be all on one line
	  MOVE D,A
	  MOVE A,CECPOS
	  SUB A,P3
	  CALL POSCOL
	  SUB D,A
	  CAIL D,(.MINFI)
	ANSKP.
	  MOVE C,A		;Ok!  Do it by char ins.
	  CALL CURCOL
	  SUBM A,C
	  MOVX B,DP%AG1+.VTCID
	  MOVEI A,.PRIOU
	  VTSOP%
	   ERNOP
	  MOVN B,P3
	  ADJBP B,CEBPTR
	  MOVN C,P3
	  MOVEI A,.PRIOU
	  SOUT%
	  JRST CEINC
	ENDIF.
	TXNN Q1,TC%SCL		;If can't clear
	 TXNN Q1,TC%OVR		;and overstriking
	IFSKP.
	  SKIPN CEDSEA		;And have junk after cursor
	ANSKP.
	  CALL CNEWLN		;Get a fresh line, can't win
	  CALL CENUMB
	  HRROI A,CETSAV
	ELSE.
	  TXNE Q1,TC%OVR
	    CALL EEOLN		;Else clear for overstrikers
	  MOVN A,P3		;Type from old posn
	  ADJBP A,CEBPTR
	ENDIF.
	PSOUT%
	CALL ENDCOL
	MOVE B,A
	CALL SETWIN
	CALL CEREPN		;Go back to cursor
	JRST CEINC

FWORDS:	SKIPG D,P3
	  RET
	SETZ P3,
	MOVE B,CEBPTR
	DO.
	  SETZ C,		;C= in-word-p flag
	  DO.
	    ILDB A,B
	    JUMPE A,R
	    CAIL A,"1"
	     CAILE A,"9"
	      CAIN A,"*"
	        AOJA C,FWORD1
	    TRZ A,40
	    CAIL A,"A"
	     CAILE A,"Z"
	      CAIN A,.CHCNV	;Treat ^V as word constituent
	       AOJA C,FWORD1
	    JUMPG C,ENDLP.	;Break char, and we're in a word -- done
FWORD1:	    AOJA P3,TOP.
	  ENDDO.
	  SETO A,
	  ADJBP A,B
	  MOVE B,A
	  SOJG D,TOP.
	ENDDO.
	RET

BWORDS:	JUMPLE P3,R
	MOVE B,CEBPTR
	MOVE D,CECPOS
	DO.
	  JUMPLE D,ENDLP.
	  SETZ C,
	  DO.
	    LDB A,B
	    CAIL A,"1"
	     CAILE A,"9"
	      CAIN A,"*"
	        AOJA C,BWORD1
	    TRZ A,40
	    CAIL A,"A"
	     CAILE A,"Z"
	      CAIN A,.CHCNV	;Treat ^V as word constituent
	       AOJA C,BWORD1
	    JUMPG C,ENDLP.
BWORD1:	    SETO A,
	    ADJBP A,B
	    MOVE B,A
	    SOJG D,TOP.
	  ENDDO.
	  SOJG P3,TOP.
	ENDDO.
	MOVE P3,CECPOS
	SUB P3,D
	RET


;;Attempt to compute the cursor column for a position in buffer.  Not exactly
;;right due to inconsistencies in the monitor wrt handling of eol and tabs
;;and stuff, but we give it our best try.  Returns A/line#,,column#
ENDCOL: MOVX A,.INFIN
POSCOL:	SAVEAC <B,C,D>
	MOVE C,[ASCPTR CETSAV]
	MOVEI B,4		;Initialize to length of the " **:" header
	DO.			;Now count up the characters
	  ILDB D,C
	  JUMPE D,ENDLP.
	  SOJL A,ENDLP.
	  CAIN D,.CHDEL		;132 Rubout is not displayed, and no way to
	    LOOP.		;132 make it be as far as I can tell
	  CAIE D,.CHTAB
	  IFSKP.
	    ADDI B,10
	    TRZ B,7
	    LOOP.
	  ENDIF.
	  CAIL D,.CHSPC
	   CAIN D,.CHDEL
	    CAIN D,.CHESC
	     AOJA B,TOP.
	  ADDI B,2
	  LOOP.
	ENDDO.
	IDIV B,CETWID
	IFE. C			;If in column 0
	ANDG. B			;of a continuation line
	ANDE. D			;And at end of buffer
	  SOJ B,		;Then really at end of previous line
	  MOVE C,CETWID
	ENDIF.
	HRL A,B
	HRR A,C
	RET

CURCOL:	MOVE A,CECPOS
	CALL POSCOL
	SKIPE CEDSEA
	  RET
ADJCOL:	TRNN A,-1
	 SKIPG A
	  RET
	SOJ A,
	HRR A,CETWID
	RET

DSPCOL:	SKIPGE A,CEDSEA
	 JRST ENDCOL
	ADD A,CECPOS
	CALL POSCOL
	JRST ADJCOL

ABSMOV:	HLRZ A,C
	ADD A,CEWINL
	CAML A,CETLEN
	 SUB A,CETLEN
	HRL C,A
	MOVX B,DP%AG1+.VTMOV
	MOVEI A,.PRIOU
	VTSOP%
	 ERNOP
	RET

SETWIN:	TXNN Q1,TC%MOV		;Don't need to know window line if can't move
	  RET
	SAVEAC <A,B,C>
	HLRZ B,B
	PUSH P,B		;Save relative line position
	MOVEI A,.PRIOU
	RFPOS%
	HLRZ A,B
	POP P,B
	SUB A,B
	SKIPGE A
	 ADD A,CETLEN
	MOVEM A,CEWINL
	RET
>;130 End addition for new implementation


;ROUTINE TO SEND A BELL TO THE TERMINAL
CEBELL:	MOVE A,COJFN		;REDO THE CCOC
	RFCOC
	PUSH P,B		;SAVE MODE
	TLC B,1B32!1B33		;SEND ACTUAL CODE
	SFCOC
	MOVEI B,.CHBEL		;SEND THE BELL
	BOUT
	POP P,B			;RESTORE
	SFCOC
	RET

NOVTS,<				;130 old implementation/non-VTS
;ROUTINE TO BACK THE CURSOR UP ONE PLACE
CEBACK:	MOVE A,COJFN		;GET THE TERMINAL TYPE
VTS,<	MOVX B,.VTBCK		;717 use VTS
	VTSOP			;717
	 ERJMP CEBCK0		;717
	RET			;717
CEBCK0:				;717
       >			;717
	MOVE A,COJFN		;GET THE TERMINAL TYPE
	RFMOD			;GET MODE WORD
	PUSH P,B		;SAVE IT
	TXZ B,TT%DAM		;NO TRANSLATION
	SFMOD
NOVTS,<	GTTYP>			;717
	HRROI A,[ASCIZ//]	;ASSUME NORMAL TERMINAL
NOVTS,<	CAIE B,^D16		;717 GET THE VT100 TYPES OUT OF THE WAY
	 CAIN B,^D33
	  HRROI A,[ASCIZ/[D/]
	CAIE B,^D40
	 CAIN B,^D41
	  HRROI A,[ASCIZ/[D/]
	CAIN B,^D27		;BEEHIVES
	 HRROI A,[ASCIZ/D/]
	CAIN B,^D44		;DATAPOINTS
	 HRROI A,[ASCIZ//]
      >				;717
	PSOUT
	MOVE A,COJFN		;RESTORE MODE WORD
	POP P,B			;GET OLD MODE
	SFMOD			;DO IT
	RET
>;130 Old implementation

CNEWLN:	ETYPE <%_>		;130 Routine to go to a fresh line & clear
;ROUTINE TO ERRASE ALL CHARACTERS TO THE END OF LINE
EEOLN:	SAVEAC <A,B>		;SAVE THESE
	MOVE A,COJFN		;CURRENT OUTPUT JFN
VTS,<	MOVX B, .VTCEL		;717 use VTS
	VTSOP			;717
	 ERNOP			;717 
	RET			;717
       >			;717
NOVTS,<	MOVE A,COJFN		;717 CURRENT OUTPUT JFN
	RFMOD			;GET MODE WORD
	PUSH P,B		;SAVE IT
	TXZ B,TT%DAM		;NO TRANSLATION
	SFMOD
	GTTYP			;GET TERMINAL TYPE
	CAIG B,EOLNMX		;ALL WE KNOW ABOUT NOW
	SKIPN A,EEOLTB(B)	;GET STRING TO DUMP
	 JRST EEOLN2		;NONE - DO NOTHING
	TLNN A,-1		;STRING OR PNTR?
	 TLOA A,-1		;PNTR TO TEXT
	  HRROI A,EEOLTB(B)	;STRING - POINT TO IT INSTEAD
	PSOUT			;DUMP IT
EEOLN2:	MOVE A,COJFN		;RESTORE MODE WORD
	POP P,B			;GET OLD MODE
	SFMOD			;DO IT
	RET

;ERASE TO END OF LINE TABLE
EEOLTB:	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	BYTE (7)36,0
	BYTE (7).CHESC,"K",0
	0
	0
	0
	BYTE (7) .CHESC,"K",0
	BYTE(7).CHESC,"[","K",0
	0
	0
	BYTE (7) .CHCNW,0
	BYTE (7) .CHCRB,0
	0
	BYTE (7) ^D126,^D15,0
	BYTE (7) .CHESC,"K",0
	BYTE (7) .CHCNN,"U",0
	BYTE (7) .CHESC,"K",0
	BYTE (7) .CHESC,.CHCNU,0
	0
	BYTE (7) ^D30,0
	BYTE (7) .CHESC,"K",0
	0
	0
	BYTE (7) .CHESC,"K",0
	BYTE(7).CHESC,"[","K",0
	BYTE (7) .CHESC,"K",0
	[BYTE (7) .CHESC,"D","C","H","9","9",";",0]
	0
	0
	BYTE (7) .CHESC,"K",0
	0
	BYTE(7).CHESC,"[","K",0
	BYTE(7).CHESC,"[","K",0
	BYTE(7) ^D30,0
	BYTE(7) ^D30,0
	BYTE (7) 36,0
EOLNMX== .-EEOLTB-1
       >			;end NOVTS 


;ROUTINE TO TYPE A HELP MESSAGE FOR EMACS MODE
NOVTS,<				;130 Old implementation/non-VTS
CEHELP:	CALL BLANK1		;CLEAR THE SCREEN
	HRROI A,CEHMSG
	PSOUT
	JRST CEDISP			;REDISPLAY THE LINE
>;130

;130 Start addition for new implementation
VTS,<
CEHELP:	MOVX A,.CTTRM
	MOVEI B,.VTCLR
	VTSOP%
	 ERCAL CNEWLN
	MOVX A,.CTTRM
	RFMOD%
	PUSH P,B
	MOVE B,CEFMOD		;Restore user's preferred page mode setting
	STPAR%
	HRROI A,CEHMSG		;Output the message
	PSOUT
	MOVX A,.CTTRM
	POP P,B
	STPAR%
	JRST CEDISP		;REDISPLAY THE LINE
>;130 End addition for new implementation

NOVTS,<				;130 Old implementation/non-VTS
CEHMSG: ASCIZ/	Emacs Mode Command Editor
	To exit, type a Control-G

Control-A	  move to the beginning of the line
Control-B	  move BACK one character
Control-C	  abort
Control-D	  DELETE the character at the cursor
Control-E	  move to the END of the line
Control-F	  move FORWARD one character
Control-G	  exit
Backspace	  move BACK one character
Linefeed	  execute edited command
Control-K	  KILL everything to the right of the cursor
Control-L	  clear screen and redisplay the command line
Return		  execute edited command
Control-N	  edit the NEXT command line
Control-P	  edit the PREVIOUS command line
Control-Q	  QUOTE the next character for insert
Control-R	  REDISPLAY line
Control-T	  swap the character at the cursor with the one before it
Control-_	  typeout this help message
Delete		  DELETE the character to the left of the cursor
Meta-B	(Esc B)	  move to the beginning of the previous word
Meta-D	(Esc D)	  delete forward to the beginning of the next word
Meta-F	(Esc F)	  move to the beginning of the next word
Meta-N	(Esc N)	  insert a carriage return (appears as ^N)
Meta-Rub(Esc Del) delete back to the beginning of the previous word
Meta-Esc(Esc Esc) add an escape to the end of the command and execute
Meta-?	(Esc ?)	  add a question mark to the end of the command and execute
others		  insert this character at the cursor/
>;130 old implementation

;130 Start addition for new implementation
VTS,<
CEHMSG:	ASCIZ /	Emacs Mode Command Editor
	To exit, type Control-C

Control-A	   Move to start of the line
Control-E	   Move to End of line
Control-F	   Move Forward character
Control-B	   Move Back character
Meta-F   (Esc F)   Move Forward word
Meta-B   (Esc B)   Move Backward word
Control-D	   Delete character at cursor
Meta-D   (Esc D)   Delete word at cursor
DEL      (Rubout)  Rubout character before cursor
Meta-DEL (Esc DEL) Rubout word before cursor
Control-W	   Rubout word before cursor, same as Meta-Rubout
Control-K	   Kill to end of line
Control-N	   Next command line
Control-P	   Previous command line
Control-Q	   Quote next character for insert
Meta-N   (Esc N)   Insert a carriage return (appears as ^N)
Control-T	   Transpose characters
Control-R	   Redisplay line
Control-L	   Clear screen and redisplay line
Control-U	   Start numeric argument (repeat count for next command)
Meta-0..Meta-9	   Another way to enter a numeric argument
Control-Z	   Exit with current command line
Return		   Append a Return and exit with command line
Meta-Esc (Esc Esc) Append an Escape and exit with command line
Meta-?   (Esc ?)   Append a ? and exit with command line
Control-C	   Quit editor
Control-G	   Flush numeric argument if any, quit editor if none/
>;130 End addition for new implementation


;ROUTINE TO TYPE HELP MESSAGE FOR ALTER MODE
CAHELP:	CALL BLANK1		;TRY TO BLANK THE SCREEN
	HRROI A,CAHMSG
	PSOUT
	JRST CETOP			;RETYPE THE LINE

CAHMSG:	ASCIZ/	Alter mode command editor

Tab		Move to the end of the line
Line Feed	Edit the next command line
Control-L	Redisplay the command line, move cursor to beginning
Return		Execute edited command
Control-R	Redisplay the command line, stay at current cursor position
Control-U	Ignore editing up to now and start over
Escape		Edit the previous command line
n SPACE		Move forward n characters
n D		Delete n characters at the cursor
E		Execute edited command
H		Delete the rest of the line and enter insert mode
I		Enter insert mode (exit with an escape)
P		Redisplay the command line, stay at current cursor position
Q		Return to command level
n R		Delete n characters then enter insert mode
n W		Move forward n words
X		Move to the end of the line and enter insert mode
n RUB		Move back n characters
\		Swap the character at the cursor with the one before it
:		Delete everything to the right of the cursor
?		Typeout this help message/

;COMMAND EDIT INTERRUPT ROUTINE
.CEPSI::SKIPN CLF		;AT COMMAND LEVEL?
	 DEBRK			;NO, DON'T DO THIS
	SKIPE .P		;DO WE HAVE A SAVED STACK POINTER?
	 MOVE P,.P		;YES, RESTORE IT
	CALL RLJFNS		;RELEASE PARSED JFN'S
	MOVE A,[ASCPTR CBUF]	;LOOK AT THE COMMAND BUFFER
	ILDB B,A		;GET THE NEXT CHARACTER
	JUMPN B,.-1		;KEEP LOOKING FOR A NULL
	SETO C,			;FOUND IT
	ADJBP C,A		;BACK UP ONE CHARACTER
	MOVX A,.PRIIN		;LOOK AT THE TERMINAL
	SIBE			;ANYTHING THERE?
	 JRST  [MOVE A,C	;YES, ADD IT TO THE BUFFER
		MOVE B,[RD%RIE!^D80]
		SETZ C,		;NO PROMPT, QUIT WHEN TTY BUFFER IS EMPTY
		RDTTY		;GET IT
		 ETYPE <%_%%Can not find rest of command, Continuing>
		IDPB C,A	;ASCIZ THE STRING
		JRST .+1 ]	;READY TO GO NOW
	CALL CSAVE		;SAVE THE COMMAND IN PROGRESS
	PUSH P,P		;SAVE THE STACK POINTER
;130	TRVAR <CADLFG,CEDUMB,CABKFG,CELPOS,CECPOS,CELPTR,CEDSEA,CENUMR>	;SYNC
	TRVAR <CADLFG,CEDUMB,CABKFG,CELPOS,CECPOS,CELPTR,CEDSEA,CENUMR,CETWID,CETLEN,CEFMOD,CETCHR,CEWINL>	;130
	SETZM CEDSEA		;INITIALIZE STUFF
	CALL CEDITU		;GO TO THE EDITOR
	POP P,P			;FLUSH THE TRVARS
	MOVE A,LEV1PC		;GET THE RETURN ADDRESS
	HRRI A,CMDIN4		;CHANGE IT
	TXO A,PC%USR		;RETURN TO USER CODE
	MOVEM A,LEV1PC		;RESTORE FIXED PC
	DEBRK			;PARSE EDITED COMMAND


.FLUSH::NOISE <command editor buffer> ;7 
	CONFIRM			;7
	MOVE A,[CESAVE,,CESAVE+1] ;7 zero buffer 
	SETZM CESAVE		;7
	BLT A,CESAVE+CESAVL+CETSVL ;7
	SETZM PCLMID		;7 reset variables
.FLUS0::MOVEI A,CESAVE+2	;7 
	MOVEM A,CESAVE		;7
	MOVEM A,CEFFL		;7 initialize free space pointer
	MOVEI A,CESAVE		;7 initialize pointer into table
	MOVEM A,CE1ST		;7
	MOVEM A,CELAST		;7
	MOVX A,1		;7 initialize command count
	MOVEM A,CECNT		;7
	RET	

LITSCE:				;713 debugging aid: literals label
       >			;716 end CEF
	END


