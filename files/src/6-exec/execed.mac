;[SRI-NIC]SRC:<6-EXEC>EXECED.MAC.6,  7-May-85 17:48:26, Edit by HSS
; [NIC1031] Make sure EDIT passes file version number to the editor 
;<6-EXEC>EXECED.MAC.5, 25-Jan-85 21:42:59, Edit by HEGARTY
; Fix stray /].  Left over after edit 4.
;<6-EXEC>EXECED.MAC.4, 25-Jan-85 14:11:02, Edit by ALMQUIST
; Fix previous edit to work with release 6 (used to get internal illegal
;  instruction due to -1,,foo pointer in ASOUT)
;<6-EXEC>EXECED.MAC.3,  9-Aug-84 15:17:00, Edit by KRONJ
; Allow user to type EDIT with no filespec first time, merely scold him
;SCORE:<MERGED-6-EXEC>EXECED.MAC.2, 11-Jul-84 11:24:59, Edit by JPBION
;Stanford changes:
; Improved EMACS support
; Clear flags before EDIT command starts up SYS:EDIT to avoid EDIT with
;  switches becoming a kept fork
;
; UPD ID= 387, SNARK:<6.EXEC>EXECED.MAC.13,  22-Feb-84 09:38:20 by PAETZOLD
;More TCO 6.1977 - Fix up edit history from last change
; UPD ID= 386, SNARK:<6.EXEC>EXECED.MAC.12,  21-Feb-84 18:21:15 by PAETZOLD
;TCO 6.1977 - Add SEDX as another name for SED
; UPD ID= 241, SNARK:<6.EXEC>EXECED.MAC.11,  15-Jan-83 19:24:39 by CHALL
;TCO 6.1464 - UPDATE COPYRIGHT NOTICE
; UPD ID= 191, SNARK:<6.EXEC>EXECED.MAC.10,   8-Nov-82 15:39:40 by LOMARTIRE
;TCO 6.1347 - Make error routine at EDLOST: place EDITOR: name in ATMBUF
; UPD ID= 184, SNARK:<6.EXEC>EXECED.MAC.9,  21-Oct-82 00:17:15 by CHALL
;TCO 6.1323 - FIX NON-RECOG ON "ED FOO$$" (GIVES OUTPUT FILE AS NEXT GEN)
; UPD ID= 179, SNARK:<6.EXEC>EXECED.MAC.8,   8-Oct-82 18:12:58 by CHALL
;TCO 6.1305 ADD CODE FOR THE "PERUSE" (READ-ONLY) COMMAND
;MAKE GENERAL CODE AND FORMATTING IMPROVEMENTS
; UPD ID= 92, SNARK:<6.EXEC>EXECED.MAC.5,   8-Jan-82 15:51:26 by CHALL
;TCO 6.1052 - UPDATE COPYRIGHT NOTICE AND DELETE PRE-V4.1 EDIT HISTORY
; UPD ID= 79, SNARK:<6.EXEC>EXECED.MAC.4,   6-Nov-81 12:59:46 by CHALL
;TCO 5.1606 .EMCSA- ADD SETZM STAYF BEFORE JRST ..CONT
; UPD ID= 62, SNARK:<6.EXEC>EXECED.MAC.3,   2-Oct-81 10:44:49 by CHALL
;TCO 5.1540 - PUT EMACS CODE UNDER EMCSSW (NOT XTND)
; UPD ID= 33, SNARK:<6.EXEC>EXECED.MAC.2,  17-Aug-81 13:25:59 by CHALL
;TCO 5.1454 CHANGE NAMES FROM CANDE TO EXECED AND XDEF TO EXECDE
; UPD ID= 1073, SNARK:<5.EXEC>EXECED.MAC.6,  30-Sep-80 14:49:38 by OSMAN
;More 1068 - Change $NAME ($EMACS) to ENAME (EEMACS), GLXLIB conflict on $NAME
; UPD ID= 1068, SNARK:<5.EXEC>EXECED.MAC.5,  30-Sep-80 13:56:06 by HESS
; Check FDB (.FBUSW) for ITS-TECO based editor
; UPD ID= 983, SNARK:<5.EXEC>EXECED.MAC.4,   3-Sep-80 12:43:33 by HESS
; Don't call ERESET for new EMACS invocation
; UPD ID= 550, SNARK:<5.EXEC>EXECED.MAC.3,  23-May-80 13:35:58 by MURPHY
;MAKE CREATE/START USE SAME LOGIC AS IMPLICIT RUN
;<4.1.EXEC>EXECED.MAC.4, 27-Feb-80 08:34:45, EDIT BY OSMAN
;tco 4.1.1090 - Improve error messages
; UPD ID= 199, SNARK:<4.1.EXEC>EXECED.MAC.3,  10-Jan-80 14:01:54 by OSMAN
;tco 4.1.1063 - Make ;X in TV ask for filespec on "EDIT FOO.BAR$" command
;<4.1.EXEC>EXECED.MAC.2, 31-Oct-79 10:08:48, EDIT BY OSMAN
;tco 4.1.1002 - Fix "EDIT /ISAVE:5 FOO.BAR" followed by "EDIT"

;THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY ONLY BE USED
;  OR COPIED IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
;COPYRIGHT (C) 1980,1981,1982,1983 BY DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.

	SEARCH EXECDE
	TTITLE EXECED - CREATE READ AND EDIT COMMANDS

;PROCESSOR/COMMAND TABLES

;MACRO TO DEFINE THE EDITOR NAME, ITS SWITCHES, AND WHEN SWITCHES ARE LEGAL
;THE ARGUMENTS ARE (NAME,SWITCH-ADDR,SWITCH-FLAG,ROUTINE)
;NAME		ASCIZ EDITOR NAME
;SWITCH-ADDR	COMND BLOCK TO PARSE SWITCHES
;SWITCH-FLAG	 0==SWITCHES ARE LEGAL ONLY AFTER COMMAND NAME (EDIT, CREATE)
;		-1==SWITCHES ARE LEGAL ANYWHERE IN THE COMMAND
;ROUTINE	ADDRESS OF ROUTINE BLOCK DESCRIBED BELOW
;THE LABEL OF THE ARGUMENT LIST FOR EACH EDITOR IS E'NAME:

;THE ROUTINES AT ADDRESS "ROUTINE" ARE:
;ENTRY IS AT OFFSET:
; 0 := EDIT "INFILE"	(NON-SKIP TO IGNORE OUTPUT SPEC)
; 1 := EDIT "INFILE" "OUTFILE"
; 2 := JUST BEFORE FORK CREATE (EDITOR IN EDJFN), C(A) := RESCAN PNTR
; 3 := EDIT<CR> TYPED

DEFINE EDLIST <
ED (EDIT,SWEDIT,-1,.EDSOS)	;SWITCHES ARE ONLY LEGAL AFTER COMMAND NAME
IFE STANSW,<
ED (EMACS,    0, 0,.EMCS)	;NO SWITCHES
>;IFE STANSW
IFN STANSW,<
ED (EMACS,SWSEM, -1,.EMCS)	;STANFORD EMACS CODE - WITH "GOTO" SWITCH
>;IFN STANSW
ED (SED,  SWSED, 0,.EDSED)	;SWITCHES ARE LEGAL ANYWHERE
ED (SEDX, SWSED, 0,.EDSED)	;SAME AS SED
ED (TV,       0, 0,.EDTV)	;NO SWITCHES
>

SWEDIT:	FLDDB. .CMSWI,,$ETBL
SWSED:	FLDDB. .CMSWI,,$STBL
IFN STANSW,<
SWSEM:  FLDDB. .CMSWI,,$EMTBL
>;IFN STANSW

IFN STANSW,<
$EMTBL:	1,,1			;ONLY ONE SWITCH USED FOR EMACS
	[ASCIZ/GOTO:/],,EDSWGT	;GOTO SPECIFIC CHARACTER IN FILE

EDSWGT:	SKIPL EDCPOS		;ALREADY PARSED THIS SWITCH?
	 ERROR <GOTO switch already given>
	MOVEI B,[FLDDB. .CMNUM,CM%SDH,^D10,<Character position to go to>]
	CALL FLDSKP		;PARSE CHARACTER NUMBER
	 CMERRX
	SKIPGE B		;NON-NEGATIVE?
	 ERROR <GOTO argument must be non-negative>
	MOVEM B,EDCPOS		;REMEMBER FOR LATER
	MOVE A,CMPTR		;DON'T INCLUDE THIS SWITCH IN MEMORY:
	MOVEM A,EDPTR		;REMEMBER POINTER TO CURRENT POSITION
	MOVE A,CMCNT		;GET CURRENT COUNT
	MOVEM A,EDCNT		;AND REMEMBER IT
	TLZ Z,F2		;PRETEND WE DIDN'T SEE ANY SWITCHES
	JRST EDIT1		;GO REJOIN PARSE
>;IFN STANSW

;GENERAL ERROR MESSAGES

ERRIFS:	ASCIZ /Invalid switch or input filespec - %?/
ERROFS:	ASCIZ /Invalid switch or output filespec - %?/
ERRIFL:	ASCIZ /Invalid input filespec - %?/
ERROFL:	ASCIZ /Invalid output filespec - %?/

DEFINE ED (NAME,SWHADR,SWHFLG,ROUTIN),<
E'NAME:![ASCIZ "NAME"],,[ROUTIN,,[SWHFLG,,SWHADR]]
>
EDTAB:	TABLE
	EDLIST
	TEND

EDELS:	0,,[.EDTV,,[0,,0]]	;DEFAULT IF EDITOR: IS NOT DEFINED

EDLOST:	PUSH P,A
	MOVE A,.LNSJB
	HRROI B,[ASCIZ/EDITOR/]
	HRROI C,ATMBUF
	LNMST
	ERJMP .+1
	POP P,A
	CMERRX <Can't find editor>

;PERUSE COMMAND

.EDITP::HRLI P5,1		;LOOKS LIKE CREATE UNTIL THE END,
	JRST EDIT0		; WHEN THE COMMAND IS "PERUSE", NOT "EDIT"

;JPB - BEGIN HERE

;CREATE COMMAND

.EDITC::TLOA P5,-1		;SET THE CREATE FLAG. AND SKIP

;EDIT COMMAND

.EDIT::	SETZ P5,
EDIT0:	TLZ Z,F1!F2		;CLEAR TEMP FLAGS
IFE STANSW,<
	TRVAR <EDJFN,EINJFN,EOJFN,EDCNT,EDPTR>
>;IFE STANSW
IFN STANSW,<
	TRVAR <EDJFN,EINJFN,EOJFN,EDCNT,EDPTR,EDCPOS>
	SETOM EDCPOS		;HAVEN'T PARSED /GOTO: SWITCH YET
>;IFN STANSW
	SETZM EINJFN
	SETOM EOJFN
	UDEXT [GETSAVE()]	;SET UP CJFNBK FOR DEFAULT EXTENSION
	MOVX A,GJ%OLD		;OLD FILE ONLY
	MOVEM A,CJFNBK+.GJGEN	;SAVE FLAGS
	MOVE A,[.NULIO,,.NULIO]
	MOVEM A,CJFNBK+.GJSRC	;NO INPUT
	MOVEI A,CJFNBK		;LONG GTJFN BLOCK
	HRROI B,[ASCIZ /EDITOR:/]
	CALL GTJFS		;LOOK FOR IT
	  JRST EDLOST
	MOVEM A,EDJFN		;SAVE EDITOR JFN HERE
	MOVE A,JBUFP
	MOVEM A,.JBUFP		;SAVE THIS JFN FOR LATER
	MOVE A,CSBUFP
	MOVE B,EDJFN
	MOVX C,FLD(.JSAOF,JS%NAM)
	JFNS
	MOVEI A,EDTAB		;TABLE OF EDITORS
	MOVE B,CSBUFP		;FIND THE NAME OF THE EDITOR
	TBLUK
	TXNN B,TL%EXM		;MATCH?
	 CALL EDITNM		;NO - CHECK FDB(.FBUSW)
	HRRZ A,0(A)		;POINT TO MORE INFO
	HLR P5,0(A)		;SAVE ROUTINE ADDRS
	HRRZ Q2,0(A)		;GET ADDRESS OF SWITCH BLOCK
	NOISE (FILE)
	MOVE A,CMPTR		;GET POINTER TO REST OF COMMAND
	MOVEM A,EDPTR		;REMEMBER IT
	MOVE A,CMCNT		;GET CURRENT COUNT
	MOVEM A,EDCNT		;AND REMEMBER IT
EDIT1:	MOVEI B,EDTINF		;SET TO PARSE EDIT'S INPUT FILESPEC, ETC.
	CAIGE P5,0		;REALLY WANT CREATE?
	MOVEI B,EDTOUF		;YES - SET UP CREATE'S INSTEAD
	HRRZ A,(Q2)		;SET UP SWITCH ADDRESS OR ZERO
	MOVE C,(B)
	MOVE C,(B)
	HRRM A,(C)
	MOVE Q1,CMCNT		;SAVE COUNT JUST BEFORE FILE
	CALL FLDSKP		;GET SOMETHING
	 CAIA			;ON ERROR, CHECK FOR NEW FILE
	JRST EDIT1A
	JUMPL P5,EDIT2A		;NO OTHER CHOICES IF CREATE
	MOVEI B,EDTOUF		;OTHERWISE ALLOW CREATE OPTIONS AS SECOND CHOICE
	HRRZ A,(Q2)		;SET UP SWITCH ADDRESS OR ZERO
	MOVE C,(B)		;YES - PUT EDITOR'S SWITCH BLOCK AFTER THE REST
	MOVE C,(B)
	HRRM A,(C)
	CALL FLDSKP
	 JRST EDIT2A		;NO MORE CHANCES
EDIT1A:	LDB C,[POINTR <0(C)>,CM%FNC] ;GET CODE USED
	CAIN C,.CMCFM		;CR TYPED?
	JRST EDAGN		;YES - USE LAST
	CAIN C,.CMSWI		;SWITCH?
	JRST [CALL EDSWT	;YES - HANDLE IT
	       RET
	      JRST EDIT1]	;AND SEE WHAT'S NEXT
	CAIE C,.CMIFI		;INPUT FILESPEC?
	CAIN C,.CMOFI		;OR OUTPUT
	JRST EDIT3		;YES - PROCEED

;HERE IF THE COMMAND IS FLAKY - GIVE SOME KIND OF ERROR MESSAGE

EDIT2A:	JUMPGE P5,EDT2A2	;JUMP IF CREATING
	MOVEI A,ERRIFS		;PERUSE OR EDIT - ASSUME THERE ARE SWITCHES
	SKIPN (Q2)		;ARE THERE REALLY?
	MOVEI A,ERRIFL		;OF COURSE NOT - SET FOR NO SWITCHES
EDT2A1:	UERR (A)		;PRINT THE CORRECT ERROR

EDT2A2:	MOVEI A,ERROFS		;CREATE - ASSUME THERE ARE SWITCHES
	SKIPN (Q2)		;ARE THERE REALLY?
	MOVEI A,ERROFL		;OF COURSE NOT - SET FOR NO SWITCHES
	JRST EDT2A1		;GO PRINT THE CORRECT ERROR

EDIT3:	SUBM	Q1,EDCNT	;COMPUTE -# CHARS IN SWITCHES
	MOVEM	B,EINJFN	;REMEMBER INPUT JFN
	SKIPL	P5		;CREATE COMMAND?
	TXNE	A,CM%EOC	;NO - ALL DONE?
	JRST	EDXIT		;YES - EXIT
	CALL	@0(P5)		;INVOKE ROUTINE TO HANDLE INPUT FILESPEC
	 JRST	EDXIT		;EXIT IF NON-SKIP GIVEN
	TLNE	P5,1		;PERUSE COMMAND?
	JRST	EDXIT		;YES - EXIT
	NOISE	(OUTPUT AS)
	MOVE	B,EINJFN	;GET JFN BACK
	SETZM	CJFNBK+.GJDIR	;USE STANDARD DEFAULT FOR OUTPUT DIRECTORY
	MOVSI	C,(1B8)		;READ FILENAME
	CALL	EDJFNS
	MOVEM	A,CJFNBK+.GJNAM
	MOVSI	C,(1B11)	;READ EXTENSION
	CALL	EDJFNS
	MOVEM	A,CJFNBK+.GJEXT
	LDF	A,GJ%FOU!GJ%MSG
	MOVEM	A,CJFNBK

;NOW ASK FOR NAME OF OUTPUT FILE

EDXXX:	MOVEI B,EDTFIL		;(USE .CMFIL SO DEFAULTING WILL WORK)
	SKIPG A,(Q2)		;WANT TO ASK FOR SWITCHES TOO?
	SETZ A,			;NO - CLEAR SWITCH BLOCK ADDRESS
	MOVE C,(B)		;YES - PUT EDITOR'S SWITCH BLOCK AFTER THE REST
	MOVE C,(B)
	HRRM A,(C)
	CALL FLDSKP		;GET OUTPUT SPEC; DETECT CONFIRMATION
	 CMERRX
	LOAD D,CM%FNC,.CMFNP(C)	;SEE WHAT GOT TYPED
	CAIN D,.CMSWI		;SWITCH?
	JRST [CALL EDSWT	;YES - HANDLE IT
	       RET
	      JRST EDXXX]	;AND SEE WHAT'S NEXT
	CAIN D,.CMCFM		;CONFIRMATION?
	JRST EDXIT2		;YES, NO FILESPEC
	MOVEM B,EOJFN		;SAVE OUTPUT JFN
	CALL @1(P5)		;ROUTINE TO HANDLE OUTPUT FILESPEC
	 NOP			;NO ALTERNATE PATH

	;;; FALL INTO EDXIT

EDXIT:	MOVEI B,EDTCFM
	SKIPG A,(Q2)		;WANT TO ASK FOR SWITCHES TOO?
	SETZ A,			;NO - CLEAR SWITCH BLOCK ADDRESS
	HRRM A,(B)
	CALL FLDSKP		;GET CONFIRMATION OR MAYBE SWITCHES
	 CMERRX
	LOAD D,CM%FNC,.CMFNP(C)	;SEE WHAT GOT TYPED
	CAIE D,.CMSWI		;SWITCH?
	JRST EDXIT2		;NO - CONFIRMATION - FINISH THE COMMAND
	CALL EDSWT		;YES - HANDLE IT
	 RET
	JRST EDXIT		;AND SEE WHAT'S NEXT

EDXIT2:	MOVE B,EDPTR		;GET POINTER TO USER'S COMMAND
	CALL EDEDIT		;REMOVE THE NOISY PARTS
	MOVE A,CSBUFP		;BUILD DEFAULT STRING IN SCRATCH SPACE
	MOVE B,EDPTR		;GET POINTER TO USER'S COMMAND AGAIN
	SKIPE C,EDCNT		;ANY SWITCH PART?
	JRST [	CALL ASOUT	;YES, COPY THE STRING
		MOVEI B,.CHSPC	;SEPARATE SWITCHES FROM FILESPEC WITH SPACE
		IDPB B,A
		JRST .+1]
IFE NICSW,<			;[NIC1031]
	MOVE C,[FLD(1,JS%DEV)!FLD(1,JS%DIR)!FLD(1,JS%NAM)!FLD(1,JS%TYP)!JS%PAF]
>;IFE NICSW
IFN NICSW,<
	MOVE C,[JS%SPC]		;[NIC1031]
>;IFN NICSW
	MOVE B,EINJFN		;FIRST FILE
	JFNS			;TO STRING
	MOVE B,EOJFN		;OUTPUT SPEC?
	CAMN B,[-1]
	JRST EDXIT1		;NO
	MOVEI B," "
	IDPB B,A		;SEPARATE BY SPACE
	MOVE B,EOJFN		;GET OUTPUT JFN AGAIN
	JFNS			;YES, DO IT TOO
EDXIT1:	MOVE B,[POINT 7,[ASCIZ /
/]]
	MOVEI C,0
	CALL ASOUT		;FINISH SAVED LINE WITH CRLF
	CALL PIOFF		;DON'T ALLOW ^C WHILE CHANGING HORSES
	SKIPE A,EDSVB		;GET POINTER TO SAVED EDIT COMMAND
	CALL STREM		;RELEASE OLD STORAGE IF THERE WAS ANY
	SETZM EDSVB		;DO NOW SINCE XBUFFS MIGHT FAIL
	CALL PION		;ALLOW ^C AGAIN
	MOVE A,CSBUFP		;POINT TO CREATED DEFAULT STRING
	CALL XBUFFS		;GET SOME PERMANENT SPACE FOR IT
	MOVEM A,EDSVB		;REMEMBER POINTER TO NEW DEFAULT STRING
	MOVE D,EDPTR		;USE ACTUAL COMMAND STRING THIS TIME
EDXITB:	MOVE A,CSBUFP		;CREATE STRING FOR PROGRAM
	HLRE B,P5		;GET -1=CREATE, 0=EDIT, 1=PERUSE
	MOVE B,@[[POINT 7,[ASCIZ /CREATE /]]
		 [POINT 7,[ASCIZ /EDIT /]]
		 [POINT 7,[ASCIZ /PERUSE /]]]+1(B)
	MOVEI C,0
	CALL ASOUT		;START WITH CORRECT COMMAND NAME
	MOVE B,D		;USE REST OF COMMAND OR SAVED COMMAND
	CALL ASOUT
	MOVE A,CSBUFP		;GET COMMAND LINE
	CALL BUFFS		;SAVE THE STRING
	CALL @2(P5)		;ROUTINE TO HANDLE FORK CREATE/START
	 RET			;ALL DONE - RETURN
	MOVEM A,RSPTR		;STORE RESCAN POINTER
	CALL RLJFNS		;FLUSH EXTRA JFNS
	MOVE B,EDJFN		;GET JFN FOR EDITOR FILE
IFN STANSW,<
	SETZ Z,			;CLEAR FLAGS
>;IFN STANSW
	JRST CIN3		;JOIN IMPLICIT RUN CODE IN EXEC0

;SUBROUTINE FOR WHEN TBLUK FINDS NO MATCH ON EDITOR NAME

EDITNM:	MOVE A,EDJFN		;NO - CHECK FDB(.FBUSW)
	MOVE B,[1,,.FBUSW]
	MOVEI C,C
	GTFDB
	HLRZS C			;=> 'TEC',,VERS#
	MOVEI A,EDELS		;WHAT TO USE FOR DEFAULT
	CAIN C,'TEC'
	 MOVEI A,EEMACS		;USE EMACS INTERFACE
	RET

;SUBROUTINE TO REMOVE "()" AND "!!" NOISE FROM THE COMMAND LINE
;CALL WITH B/ POINTER TO COMMAND STRING; USES A, C

EDEDIT:	MOVE C,B		;GET THE POINTER TO THE LINE IN B AND C
EDEDT0:	ILDB A,B		;GET A CHARACTER
	CAIN A,"!"		;START OF NOISE?
	JRST EDEDT1		;YES - SKIP IT
	CAIN A,"("		;START OF NOISE?
	JRST EDEDT2		;YES - SKIP IT
	IDPB A,C		;NO - SAVE THE CHARACTER
	JUMPN A,EDEDT0		;AND LOOP UNTIL NULL,
	RET			;THEN RETURN

EDEDT1:	ILDB A,B		;SKIP NOISE - UNTIL "!"
	CAIE A,"!"
	JUMPN A,EDEDT1
	JRST EDEDT0

EDEDT2:	ILDB A,B		;SKIP NOISE - UNTIL ")"
	CAIE A,")"
	JUMPN A,EDEDT2
	JRST EDEDT0

;SUBROUTINE TO HANDLE SWITCHES
;RETURNS +2 IF SWITCH IS O.K., ELSE +1

EDSWT:	TLO	Z,F2		;NOTE THAT SWITCH WAS SEEN
	HRRZ	C,0(B)		;GET DISPATCH ADDRESS
	JUMPE	C,EDSWT1	;IF ZERO, THERE'S NO ARGUMENT
	TXNE	A,CM%SWT	;ARGUMENT - WAS A COLON TYPED?
	JRST	0(C)		;YES - GOT /SW: -  DISPATCH TO READ ARGUMENT
	CAIE	C,EDSWNX	;NO - IS THE ARGUMENT OPTIONAL?
	CAIN	C,EDSWSX
	RETSKP			;YES - THERE'S NO ARGUMENT, THEN - DONE
	TYPE	<?Switch must have a value - >
	JRST	EDSWT2		;FINISH OFF THE ERROR

EDSWT1:	TXNN	A,CM%SWT	;HERE IF NO ARGUMENT - WAS A COLON TYPED?
	RETSKP			;NO - O.K. - DONE
	TYPE	<?Switch does not allow argument - >
EDSWT2:	HLRO	B,0(B)		;OUTPUT THE SWITCH NAME WITH THE ERROR
	MOVEI	C,0
	MOVE	A,COJFN
	SOUT
	ETYPE	<%_>
	RET			;AND RETURN

;HERE TO PARSE AN OPTIONAL STRING OR NUMERIC ARGUMENT

EDSWSX:	SKIPA	B,[[FLDDB. .CMFLD,,,<STRING ARGUMENT>]]
EDSWNX:	MOVEI	B,[FLDDB. .CMNUM,,^D10]	;GET OPTIONAL DECIMAL NUMBER
	JRST	EDSW1

;HERE TO PARSE FILESPECS OR DECIMAL ARGUMENT

EDSWFL:	SKIPA	B,[[FLDDB. .CMIFI]]	;GET INPUT FILESPEC
EDSWFO:	MOVEI	B,[FLDDB. .CMOFI]	;GET OUTPUT FILESPEC
	JRST	EDSW1

EDSWNM:	MOVEI	B,[FLDDB. .CMNUM,,^D10]	;GET DECIMAL NUMBER
EDSW1:	CALL	FLDSKP
	 CMERRX
	RETSKP

;HERE TO PARSE A STRING OR OPTION ARGUMENT

EDSWST:	SKIPA	B,[[FLDDB. .CMFLD,,,<STRING ARGUMENT>]]
EDSWOP:	MOVEI	B,[FLDDB. .CMFLD,,,<OPTION NAME .LE. 6 CHARACTERS>]
	CALL	FLDSKP		;JUST GET ATOM
	 CMERRX <String required>
	RETSKP

;HERE IF THE USER JUST TYPED "EDIT<CR>"

EDAGN:
IFN STANSW,<
	SKIPE	D,EDSVB		;PREVIOUS STRING?
	IFSKP.
	  TYPE <%No saved filespec
>
	  MOVE D,[POINT 7,[BYTE(7) .CHCRT,.CHLFD,0]]
	  JRST	EDXITB		;YES, PROCEED
	ENDIF.
>
	CALL	@3(P5)		;CALL THIS EDITOR'S ROUTINE FOR "EDIT<CR>"
	 NOP			;DONE - RETURN
	JRST	EDXITB		;JOIN COMMON CODE

;SWITCH DEFINITIONS FOR EDIT

DEFINE NAMES <
X	(BAK,0)
X	(C128,0)
X	(C64,0)
X	(DECIDE,0)
X	(DPY,0)
X	(EXPERT,0)
X	(INCREMENT:,EDSWNM)
X	(ISAVE:,EDSWNM)
X	(LOWER,0)
X	(M33,0)
X	(M37,0)
X	(NOBAK,0)
X	(NODECIDE,0)
X	(NONSEPARATORS,0)
X	(NONUMBER,0)
X	(NOVICE,0)
X	(NUMBER,0)
X	(OLD,0)
X	(OPTION:,EDSWOP)
X	(PLINES:,EDSWNM)
X	(R,0)
X	(READONLY,0)
X	(RONLY,0)
X	(RUN:,EDSWFL)
X	(SAVE:,EDSWNM)
X	(SEPARATORS,0)
X	(SEQUENCE,0)
X	(START:,EDSWNM)
X	(STEP:,EDSWNM)
X	(UNSEQUENCE,0)
X	(UPPER,0)
X	(WINDOW:,EDSWNM)
>

DEFINE X(A,B) <[ASCIZ \A\],,B>

$ETBL:	0
	NAMES
..Z==.
RELOC $ETBL
	..Z-$ETBL-1,,..Z-$ETBL-1
RELOC ..Z

SED,<
;SWITCHES FOR SED

DEFINE NAMES <
X	(ALT,0)
X	(BACKUP,0)
X	(BEEP,0)
X	(CASE,0)
X	(CREATE,0)
X	(DTABS,0)
X	(GOTO:,EDSWNX)
X	(ICR,0)
X	(ID,0)
X	(IMODE,0)
X	(INVRT,0)
X	(ISAVE:,EDSWNM)
X	(ITABS,0)
X	(JOURN,0)
X	(LENG:,EDSWNM)
X	(LMAR:,EDSWNM)
X	(NOBACKUP,0)
X	(NOBEEP,0)
X	(NOCASE,0)
X	(NOFENCE,0)
X	(NOICR,0)
X	(NOID,0)
X	(NOIMODE,0)
X	(NOINVRT,0)
X	(NOITABS,0)
X	(NOJOURN,0)
X	(NOMESSA,0)
X	(NOPAGE,0)
X	(NORAISE,0)
X	(NORESET,0)
X	(NOROLL,0)
X	(NOSHOW,0)
X	(NOSTRIP,0)
X	(NOUPPER,0)
X	(OUT:,EDSWFO)
X	(PAGE,0)
X	(PROG:,EDSWFL)
X	(QUICK,0)
X	(RAISE,0)
X	(READ,0)
X	(RECOV,0)
X	(RESET,0)
X	(RMAR:,EDSWNM)
X	(ROLL,0)
X	(SAVE:,EDSWNM)
X	(SHOW,0)
X	(SLIDE:,EDSWNX)
X	(STRIP,0)
X	(TABS:,EDSWSX)
X	(TSET:,EDSWNM)
X	(UPPER,0)
X	(WIDTH:,EDSWNM)
X	(WRITE,0)
>
$STBL:	0
	NAMES
..Z==.
RELOC $STBL
	..Z-$STBL-1,,..Z-$STBL-1
RELOC ..Z

> ;END SED

;SUBROUTINES

;SUBROUTINE TO DO A JFNS. CALL WITH C/ FLAGS, B/ JFN
;THIS ROUTINE PRESERVES JFN IN B

EDJFNS:	STKVAR <SAVBBB>
	MOVE A,CSBUFP		;POINTER TO STRING SPACE
	JFNS
	MOVE A,CSBUFP		;GET POINTER TO STRING JUST CREATED
	MOVEM B,SAVBBB
	CALL BUFFS		;SAVE THE STRING
	MOVSI B,774000		;MASK FOR FIRST CHARACTER
	TDNN B,(A)		;SEE IF STRING IS NULL
	MOVEI A,0		;RETURN 0 INSTEAD OF POINTER IF FIELD IS NULL
	MOVE B,SAVBBB
	RET

;ARTIFICIAL SOUT ROUTINE FOR OUTPUTTING STRINGS TO MEMORY
;(SAVES HUNDREDS OF INSTRUCTIONS OVER THE JSYS)
;CALL (LIKE SOUT) WITH:
;	A/ POINTER TO TARGET STRING (NO HRROI'S ALLOWED)
;	B/ POINTER TO SOURCE STRING
;	C/ 0==STOP ON NULL; <0==DO -(C) CHARACTERS
;RETURNS UPDATED POINTERS AND C/ 0

ASOUT:	JUMPL C,ASOUTC		;JUMP TO DO A GIVEN NUMBER OF CHARACTERS
ASOUT1:	ILDB C,B		;ELSE GET A CHARACTER
	JUMPE C,ASOUTX		;DONE IF NULL
	IDPB C,A		;ELSE SAVE IT
	JRST ASOUT1		;AND LOOP

ASOUTC:	PUSH P,D		;SAVE A WORK AC
	ILDB D,B		;GET A CHARACTER
	IDPB D,A		;SAVE IT
	SOJG C,ASOUT1		;LOOP UNTIL COUNTED OUT
	CAIA			;THEN SKIP THE AV SAVE
ASOUTX:	PUSH P,D		;SAVE A WORK AC
	MOVE D,A		;GET A FRAGGABLE TARGET POINTER
	IDPB C,D		;END THE STRING WITH A NULL
	POP P,D			;RESTORE THE SCRATCH AC
	RET			;DONE

;AUXILIARY ROUTINES FOR VARIOUS EDITORS
;ENTRY IS AT OFFSET:
; 0 := EDIT "INFILE"	(NON-SKIP TO IGNORE OUTPUT SPEC)
; 1 := EDIT "INFILE" "OUTFILE"
; 2 := JUST BEFORE FORK CREATE (EDITOR IN EDJFN), A/ POINTER TO COMMAND STRING
; 3 := EDIT<CR> TYPED

NOEMCS,<
.EMCS:
>
NOSED,<
.EDSED:
>
.EDSOS:
.EDTV:	RSKP			;0 - INPUT FILE
	RSKP			;1 - OUTPUT FILE
	RSKP			;2 - FORK CREATE
	EDITCR			;3 - EDIT<CR>

;HERE FOR "NORMAL" EDITORS, ON "EDIT<CR>"
;DON'T ALLOW SWITCHES WITHOUT A FILESPEC

EDITCR:	SKIPN	D,EDSVB		;PREVIOUS STRING?
	JRST	EDICRX		;NO - OUTPUT ERROR MESSAGE
	TLNE	Z,F2		;EDIT/SW<CR> IS AN ERROR:
	ERROR	<Must have filespec>
	RETSKP			;OTHERWISE RETURN SUCCESS

EDICRX:	TYPE <%No saved filespec
>
	MOVE	D,[POINT 7,[ASCIZ /
/]]
	RET			;GIVE NORMAL RETURN

SED,<
;DISPATCH TABLE AND ROUTINES FOR SED

.EDSED:	RSKP			;0 - INPUT FILE
	RSKP			;1 - OUTPUT FILE
	RSKP			;2 - FORK CREATE
	EDISCR			;3 - EDIT<CR>

;HERE WHEN USER TYPED "EDIT<CR>"
;ALLOW SWITCHES; DON'T USE PREVIOUS FILESPEC LINE

EDISCR:	MOVE D,EDPTR		;JUST SET UP THE STRING AS THE USER TYPED IT
	RETSKP			;THAT'S ALL
>
EMCS,<
.EMCS:	.EMCSI			;0 - INPUT FILE (OR CREATE)
	RSKP			;1 - OUTPUT FILE (CAN'T HAPPEN)
	.EMCSF			;2 - FORK CREATE
	.EMCSA			;3 - EDIT AGAIN

;COME HERE WITH FILESPEC JFN IN EINJFN

.EMCSI:	JUMPGE P5,R		;DONE UNLESS COMMAND WAS CREATE
	MOVE A,EINJFN		;GET JFN
	MOVE B,[7B5+OF%WR]	;CREATE A FILE
	OPENF
	 JRST CERR
	TXO A,CO%NRJ		;KEEP JFN
	CLOSF			;FILE NOW EXISTS
	 NOP
	RET

;HERE TO RE-EDIT OLD FILE

.EMCSA: SKIPG A,EDFORK		;HAVE AN EDITOR FORK?
	 JRST EMCSA1		;NO - CHECK IF PREVIOUS FILE
	RFSTS			;SEE IF FORK IS AROUND
IFE STANSW,<
	 ERJMP [SETOM EDFORK	;NO FORK
		JRST EMCSA1]
>;IFE STANSW
IFN STANSW,<
	 ERJMP EMCSA3		;NO FORK
>;IFN STANSW
	TXZ A,RF%FRZ		;MUST BE FROZEN
	HLRZS A
	CAIN A,.RFFPT		;CHECK VALID TERMINATION
IFE STANSW,<
	 JRST [	MOVE A,EDFORK
		CALL KEFORK	;KILL IT OFF
		SETOM EDFORK
		JRST EMCSA1]	;HANDLE IF NO FORK
>;IFE STANSW
IFN STANSW,<
	 JRST EMCSA2		;ASK FOR CONFIRMATION BEFORE KILLING
>;IFN STANSW
	MOVE A,EDFORK
	MOVEM A,FORK		;MAKE EDITOR CURRENT FORK
	MOVEM A,RUNFK
	SETZM STAYF		;DON'T STAY AT COMMAND LEVEL
	JRST ..CONT		;AND RESUME IT

;NO FORK FOUND - TRY FOR KNOWN FILE

IFN STANSW,<
EMCSA2:	TYPE <% Editor fork in a strange state, flushing and starting over
>
	CALL FCONF		;LET USER DISALLOW FLUSH OF EMACS FIRST
	MOVE A,EDFORK		;GET EDITOR FORK AGAIN
	CALL KEFORK		;FLUSH IT
EMCSA3:	SETOM EDFORK		;FORGET WE HAVE AN EDITOR FORK
>;IFN STANSW

EMCSA1:	MOVE B,EDSVB		;POINT TO SAVED FILESPEC
	MOVX A,GJ%OLD!GJ%SHT
	GTJFN
	 JRST [	CALL PIOFF	;^C WITH STRING REMOVED BUT EDSVB NON-0 WOULD BE BAD
		SKIPE A,EDSVB	;FILE GONE
		CALL STREM	;SO FREE UP SPACE COMMAND STRING TOOK UP
		SETZM EDSVB
		CALL PION
		ERROR <Previous edit file gone>]
	CALL JFNSTK		;STACK IT
	MOVEM A,EINJFN		;SAVE INPUT JFN
	MOVE A,CSBUFP
	HRROI B,[ASCIZ "EDIT "]
	MOVEI C,0
	SOUT			;BUILD RESCAN LINE
	MOVE B,D		;SAVED FILESPEC
	SOUT
	MOVE A,CSBUFP		;SAVE STRING
	CALL BUFFS

	;;;FALL INTO EMCSF

;CREATE AN EDIT FORK AND START EDITOR

.EMCSF:
IFE STANSW,<
	MOVEM A,RSPTR		;SET UP FOR RESCAN
>;IFE STANSW

	SKIPG A,EDFORK		;ALREADY HAVE A FORK?
	 JRST EMCSF1		;NO - CREATE ONE
IFN STANSW,<
;; Rather than incurring the overhead of making a whole new EMACS,
;; use the FS SUPERIOR mechanism to tell EMACS to read the new file.
;; This will do a Visit File or Find File depending on the variable
;; Tags Find File (as does normal startup).  Here's how:
;;
;; When EMACS is stopped (c-X c-Z, ^C, etc) AC2 will contain a pointer
;; to the "buffer block".  Drop a negative number into offset 8 of
;; the block (a positive number means make space in current buffer
;; for fork to drop text in).  Then start at offset 7, and wait for it
;; to HALTF again.  This macros FS SUPERIOR in EMACS, which gets the
;; number in offset 8 as an argument, sees it's negative so reads the RSCAN
;; containing a filename optionally followed by a comma and the number
;; of the character to start at.  Since this format is different from
;; what we use in RSCAN on startup, we just use the filename.
;; When FS SUPERIOR does a FS EXIT we see the HALTF and start it back
;; again at the location it was originally halted at.


	;; First make sure we have an EMACS in a normal state
	MOVEM A,FORK		;SAVE AS CURRENT FORK
	RFSTS			;SEE IF FORK IS AROUND
	 ERJMP EMCSF3		;NO FORK
	TXZ A,RF%FRZ		;MUST BE FROZEN
	HLRZS A
	CAIE A,.RFHLT		;CHECK VALID TERMINATION
	 JRST EMCSF2		;ASK FOR CONFIRMATION BEFORE KILLING
	SKIPN EDSVB		;HAVE A FILESPEC THIS TIME AROUND?
	 JRST EMCSF4		;NO, JUST START IT

	;; Get the buffer block pointer
	MOVEI A,2		;WANT AC2
	CALL MAPPF		;MAP IN PROCESS ACS
	 JRST EMCSNM		;COULDN'T, GO COMPLAIN
	MOVE C,PAGEN+2		;GET THE POINTER IN C

	;; Set argument to -1 so FS SUPERIOR will read RSCAN buffer
	MOVEI A,8(C)		;POINT TO ARGUMENT LOCATION
	SETO B,			;GET A NEGATIVE NUMBER TO PUT THERE
	CALL STOREF		;DEPOSIT
	 JRST [	TYPE <% Couldn't set FS SUPERIOR argument
>
		JRST EMCSF2 ]	;LOST, GET A NEW ONE

	;; Run FS SUPERIOR to read in the file
	MOVEI D,","		;DIVIDING WITH A COMMA
	CALL EMCSRS		;START SETTING RSCAN BUFFER FOR EMACS
	CALL CRSCAN		;SET RSCAN BUFFER FOR EMACS TO SEE
	SETZM STAYF		;FOREGROUND NOT BACKGROUND
	SETZ Z,			;NO FUNNY FLAGS
	MOVEI B,7(C)		;GET ADDRESS TO START AT
	CALL GOTOR		;RUN IT AND WAIT FOR TERMINATION

	;; Now start back at the original location and finish command
EMCSF4:	CALL RLJFNS		;FLUSH XTRA JFNS
	SETZM .JBUFP		;NO LONGER SAVING PROGRAM JFN
	JRST ..STRT		;RESTART FORK IN CASE TYPED ^C OR NEW TTY TYPE


; Here to start making RSCAN buffer for either flavor of EMACS start
; Call with D/character to divide CPOS from filename (comma or escape)
; Returns +1/always, RSCAN buffer pointer set, no registers changed
EMCSRS:	SAVEAC <A,B,C,D>	;DON'T  MUNG CALLER REGISTERS
	PUSH P,D		;SAVE DIVIDER
	MOVE A,CSBUFP		;GET A PLACE TO MAKE A STRING
	MOVEM A,RSPTR		;USE THAT AS OUR RSCAN BUFFER
	HRROI B,[ASCIZ/EMACS /]	;START WITH PROGRAM NAME
	MOVEI C,0		;ENDING ON NULL
	SOUT			;ADD IT TO STRING
	SKIPN B,EDSVB		;GET POINTER TO REST OF COMMAND LINE
	 ERROR <Command line not saved at EMCSRS>
	SKIPL EDCPOS		;IS THAT ALL?
	IFSKP.
	  POP P,D		;YES, GET DIVIDER BACK
	  CAIE D,","		;COMMA?
	  IFSKP.
	    MOVX C,.INFIN	;YES, GO ONLY TO CHAR IN D
	    MOVEI D,.CHCRT	;WHICH IS A CARRIAGE RETURN
	    SOUT		;DO IT
	    SETZ C,		;NOW GET A NULL
	    DPB C,A		;AND DROP OVER CARRIAGE RETURN
	  ELSE.
	    SOUT		;NOT COMMA, ADD WHOLE OF STRING
	  ENDIF.
	  RET
	ENDIF.
	MOVX C,.INFIN		;UNTIL WE HIT CHAR IN D
	MOVX D,.CHCRT		;WHICH IS A CARRIAGE RETURN
	SOUT			;COPY STRING UP TO THAT
	POP P,D			;GET DIVIDER BACK
	DPB D,A			;DROP DIVIDER IN
	MOVE B,EDCPOS		;WITH CHARACTER POS
	MOVEI C,5+5		;DECIMAL
	NOUT			;ADD THE NUMBER
	 ERJMP CJERRE		;STRANGE ERROR
	MOVEI C,"J"		;GET TECO COMMAND TO MOVE TO LOCATION
	CAIE D,","		;UNLESS WE USED A COMMA
	 IDPB C,A		;ADD THE J TO THE LINE
	MOVEI C,.CHNUL		;GET NULL TO TERMINATE
	IDPB C,A		;FINISH STRING WITH IT
	RET			;ALL DONE


; Here when EMACS fork was not halted, so we couldn't use FS SUPERIOR
EMCSNM:	TYPE <% Couldn't map editor fork ACs
>
EMCSF2:	TYPE <% Editor fork in a strange state, flushing and starting over
>
	CALL FCONF		;LET USER DISALLOW FLUSH OF EMACS FIRST
	MOVE A,EDFORK		;GET EDITOR FORK ONCE MORE
>;IFN STANSW


	CALL KEFORK		;YES - FLUSH IT
IFN STANSW,<
EMCSF3:				;HERE WHEN RFSTS LOST
>;IFN STANSW
	SETOM EDFORK
EMCSF1:	CALL ECFORK		;MAKE A NEW FORK
	MOVX B,FK%KPT		;MARK IT KEPT
	IORM B,SLFTAB(A)
	MOVE B,EDJFN		;JFN ON EDITOR
	CALL SFKNAM		;SET ITS NAME
	MOVE A,EDJFN
	HRL A,FORK		;GET PROGRAM INTO FORK
	GET
	 ERJMP GETILI
	CALL RLJFNS		;FLUSH XTRA JFNS
	SETZM .JBUFP		;NO LONGER SAVING PROGRAM JFN
	SETZM STAYF		;DON'T STAY AT COMMAND LEVEL
IFN STANSW,<
	SKIPN EDSVB		;HAVE ANY FILE TO EDIT?
	IFSKP.
	  MOVEI D,.CHESC	;DIVIDE WITH ESCAPE
	  CALL EMCSRS		;START MAKING RSCAN BUFFER FOR EMACS
	ELSE.
	  SETZM RSPTR		;NO FILE, SO NO JCL
	ENDIF.
>;IFN STANSW
	MOVE A,FORK
	MOVEM A,EDFORK		;SET EDITOR FORK
	MOVEI B,0		;OFFSET 0 FOR START
	JRST ..STCR
> ;END FTEMCS

       END

