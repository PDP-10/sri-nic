;-*-Macro-*-

	TITLE	IDDT
	SUBTTL	Originally by W. W. PLUMMER, November 71 (ancient history!)
	SEARCH	CPUNUM,MONSYM

	IFNDEF KL20F, KL20F==1

;[SRI-NIC]SRC:<LOC.SUBSYS>IDDT.MAC.425, Edit by KLH
; Masked off all but 0177 bits for all PBOUTs, was causing ^? output in
; certain TTY modes.
;[SRI-NIC]SRC:<LOC.SUBSYS>IDDT.MAC.424,  4-Jan-88 17:15:02, Edit by IAN
; Fix extended ;I (XRIR%) bugs
;[SRI-NIC]SRC:<LOC.SUBSYS>IDDT.MAC.422,  1-Sep-87 14:40:56, Edit by IAN
; Fix bugs where single-stepping left old flags lying bogusly around
;[SRI-NIC]SRC:<LOC.SUBSYS>IDDT.MAC.417,  6-Aug-87 14:56:05, Edit by IAN
; Fix up $;Y to handle > 1-section files, fix bug in ;A typeout.
;[SRI-NIC]SRC:<LOC.SUBSYS>IDDT.MAC.412,  5-Aug-87 12:12:09, Edit by IAN
; Add $$;D to type out unix-style 32-bit dateword, to aid debugging of
; audit-trail binary data files.
;[SRI-NIC]SRC:<LOC.SUBSYS>IDDT.MAC.406, 24-Jul-87 10:26:01, Edit by IAN
; Make single-stepping a panic-causing instruction followed by erjmp
; or ercal work.  Make PIN show ERJMP and ERCAL as just that, not as
; JUMP 16, and JUMP 17,
;[SRI-NIC]SRC:<LOC.SUBSYS>IDDT.MAC.402, 23-Jul-87 13:00:55, Edit by IAN
; Fix ^N after interpretation of JSR/JSP/etc bug; Fix nnn$G bug.
;[SRI-NIC]SRC:<LOC.SUBSYS>IDDT.MAC.390, 29-May-87 12:01:54, Edit by IAN
; Show P (AC) when single-stepping a POPJ; Fix double-CR problem for
; $^M command; fix up ;A display in some losing cases; $: and $$: now
; show the block & program set if no symbol given.
;[SRI-NIC]SRC:<LOC.SUBSYS>IDDT.MAC.387, 13-Apr-87 16:23:07, Edit by IAN
; Changed ;D to $;D, made ;D print . & .+1 as a doubleword float.
;[SRI-NIC]SRC:<LOC.SUBSYS>IDDT.MAC.203, 17-Mar-87 14:44:03, Edit by IAN
; Version 3.0: Lots of extended fixes - almost actually works now!
; Removed that gross kludge; changed symbol-block&symbol character
; to "|" for readabilities sake; Added ;tab for fullword tab; Added n;X
; to set the current section, n default 0.
; When user is noticed to be in a non-0 section, start using the area
; 1,,20 - 1,,37 as the patch area (unless XRG already points to a non-0
; patch area).  New internal documentation, available via ^_<cmd> or
; $^_ apropos command, see DOCCMD.  Moved down HOME to 700000, needed
; more room.  Show the current instruction when re-entering IDDT, so
; user knows where he is.
;[SRI-NIC]SRC:<LOC.SUBSYS>IDDT.MAC.178,  3-Mar-87 16:59:05, Edit by IAN
; [NIC254] Allow full extended address to $$U and $G, plus a gross kludge.
;[SRI-NIC]SRC:<LOC.SUBSYS>IDDT.MAC.174, 20-Nov-86 12:30:51, Edit by IAN
; Add $;R to display current RSCAN buffer (then re-set it)
;SRC:<LOC.SUBSYS>IDDT.MAC.173,  4-Aug-86 10:30:54, Edit by KNIGHT
; Put an ERJMP after the UTFRK in BPTIN4+3
;[SRI-NIC]PS:<IAN>IDDT.MAC.38, 12-Oct-85 09:21:11, Edit by IAN
; [NIC252] $;E to enable inferior
;[SRI-NIC]PS:<IAN>IDDT.MAC.35, 12-Oct-85 09:02:34, Edit by IAN
; [NIC251] Give inferior same enabled caps as you have upon entering IDDT
;[SRI-NIC]SRC:<LOC.SUBSYS>IDDT.MAC.169, 22-Sep-85 07:57:43, Edit by IAN
; [NIC250] Extended addressing version
;[SRI-NIC]SRC:<LOC.SUBSYS>IDDT.MAC.168, 19-Jul-85 09:33:29, Edit by IAN
; Fix $N and $W so they actually work
;[SRI-NIC]SRC:<LOC.SUBSYS>IDDT.MAC.166, 17-Jul-85 13:36:02, Edit by IAN
; Keep only the RH of the address when setting breakpoint, so $Q$B and
; such will work.  Fix ;B typeout (not symbolically showing addresses)
;[SRI-NIC]SRC:<LOC.SUBSYS>IDDT.MAC.165, 22-Oct-84 20:35:01, Edit by IAN
; Flush the old junk for grabbing the symbols table from inferior.
; Just map it in with PM%CPY and make them private, no funny stuff.
;[SRI-NIC]SRC:<LOC.SUBSYS>IDDT.MAC.163, 19-Oct-84 12:12:53, Edit by IAN
; Add word-byte typeout mode on $36T, bugfixes having to do with radix
; typeout (used to always use halfword even on $10R;<space>, and so on)
;[SRI-NIC]SRC:<LOC.SUBSYS>IDDT.MAC.143,  1-Aug-84 12:28:12, Edit by IAN
; XTENDF flag for some extended-address stuff, better channel reporting
; (using channel names, ILI, QTA, etc, instead of just their numbers)
;[SRI-NIC]SRC:<LOC.SUBSYS>IDDT.MAC.137, 31-Jul-84 13:57:56, Edit by IAN
; Set SYSF non-0 if you want ;Y and friends to look in SYS: instead of DSK:
; Have TIW's printed meaningfully, with character names instead of an octal #
;[SRI-NIC]SRC:<LOC.SUBSYS>IDDT.MAC.133, 14-Mar-84 11:27:16, Edit by IAN
; ;D command to print $Q/arg as date&time, ;N to print $Q/arg as hostname
; via GTHST, fixed $;Y to handle files with holes.
;[SRI-NIC]PS:<IAN>IDDT.MAC.6,  1-Feb-84 13:02:33, Edit by IAN
; Make a PROG^K hack like ITS DDT (like ;Loadgo).  Have ^D stopping
; execution look a little differntly... didn't like "XXX:" etc,
; re-formatted ;A output.
;[SRI-NIC]SRC:<LOC.SUBSYS>IDDT.MAC.126, 31-Jan-84 22:52:19, Edit by IAN
; Fixed new junk to work for Tenex; if working on a $;Yanked file,
; treat locs 0-17 as real locs when opening, not as ACs, ala FILDDT.
;[SRI-NIC]SRC:<LOC.SUBSYS>IDDT.MAC.124, 13-Jan-84 09:01:31, Edit by IAN
; Have ;;H do MIT-style PRARG requested-death-by-hand-of-EXEC.
;[SRI-NIC]SRC:<LOC.SUBSYS>IDDT.MAC.121, 22-Dec-83 14:58:09, Edit by IAN
; Make sure to save page 0 with 116/symbol-table pointer intact, so
; we can debug this program!  Fix monitor-table lookup bug in EVAL.
;[SRI-NIC]SRC:<LOC.SUBSYS>IDDT.MAC.114, 13-Dec-83 09:26:56, Edit by IAN
; Changed ;YANK to have default SYS: device, and so had to zero .GJDEV
; for other output GTJFNs using same block (so they didn't write to
; obscure places)
;[SRI-NIC]SRC:<LOC.SUBSYS>IDDT.MAC.110,  8-Dec-83 08:02:35, Edit by IAN
; KL20F always set.  Fixed ;;J display.  Show address break info also in
; a ;B, or just address break in ;;B.  Have ^Z be the same as ;H.  Allow
; n;? to mean 600000+n;?.  Restructured the dispatch table.  ;T to list
; the symbol table, block;T lists only symbols in the specified block.
; ;;O to obtain symbols from Macro universal files.  A separate, permanent
; symbol table taken from MONSYM is built in during first run, so monitor
; symbols are always there (JSYTAB is built at the same time).  ;;E only
; shows entry vector.
;<SYS.UNSUPPORTED>NDDT.MAC.180, 1-Nov-80 18:32:00, Edit by TAA
; Update JSYS table
;<SYS.UNSUPPORTED>NDDT.MAC.179, 24-Sep-80 21:00:32, Edit by MT
; If error string not found for ;?, say so and show number
;<SYS.UNSUPPORTED>NDDT.MAC.178, 17-Aug-80 02:36:49, Edit by MT
; Put ERJMPs after STIWs so can be used under batch (with no ^C cap)
;<SOURCES.UNSUPPORTED>NDDT.MAC.175, 11-May-80 16:15:56, Edit by MT
; Make file commands require confirmation
; Change $B to delete current bpt, $$B deletes all
;<SOURCES.UNSUPPORTED>NDDT.MAC.173, 15-Apr-80 00:33:35, Edit by MT
; Fondle TIW
;<SOURCES.UNSUPPORTED>NDDT.MAC.172, 14-Apr-80 21:19:47, Edit by MT
; Made some typeouts prettier
; Fixes in fork handling for release 4
; Changed around reason table so it knows about quota exceeded
;<SOURCES.UNSUPPORTED>NDDT.MAC.170, 14-Apr-80 16:22:36, Edit by MT
; Made ;R work
;<SOURCES.UNSUPPORTED>NDDT.MAC.169,  9-Apr-80 14:08:45, Edit by MT
; Leave LH(1) 0 in RFSTS calls for Rel4
;<SOURCES.UNSUPPORTED>NDDT.MAC.168,  8-Apr-80 17:31:40, Edit by MT
; Don't SETNM to weird things
;<SOURCES.UNSUPPORTED>NDDT.MAC.167, 10-Mar-80 17:28:40, Edit by MT
; Updated JSYS table 
;<SOURCES.UNSUPPORTED>NDDT.MAC.166,  9-Mar-80 20:15:12, Edit by MT
; Don't lose when opening cells in nonexistant pages
;<SOURCES.UNSUPPORTED>NDDT.MAC.165,  7-Mar-80 03:14:36, Edit by MT
; Don't lose in ;J if JFN is unassigned
;<SOURCES.UNSUPPORTED>NDDT.MAC.164,  5-Mar-80 16:36:12, Edit by MT
; take care of <arg>^[ and altmoded equivalents
;<SOURCES.UNSUPPORTED>NDDT.MAC.163,  4-Mar-80 00:30:33, Edit by MT
; Try looking for PAT.. of PATCH not found
; Take care of $^[ and $$^[ properly
; DEP will always try to unprotect page if neccessary
; Bug fixes in 8 and 9 bit text typeout
;<HIC>IDDT.MAC	    9-June-78 		Edit by HIC
; Finish adding ^N single stepping mode to look like ITS DDT.
; Add $. which returns the current PC.
; Default escape character is now ^D
;<MMCM>IDDT.MAC.35, 19-Apr-78 22:57:40, Edit by MMCM
; Fix up CR after LF lossage for rel 3
;<MMCM>IDDT.MAC.34, 27-Dec-77 23:19:23, Edit by MMCM
; Added address break command ($$U) and related trap stuff
;<MMCM>IDDT.MAC.33, 14-Aug-77 22:11:13, Edit by MMCM
; Changes for Tops20 Jsys traps calling sequence
;<MMCM>IDDT.MAC.32, 19-Mar-77 06:51:30, Edit by MMCM
; Fixed multiple single stepping aobjn's
; Fixed ;;U and tag: incompatibility
;<MMCM>IDDT.MAC.30,  7-Mar-77 01:25:48, Edit by MMCM
; Changed to use Tops20 editting conventions
;<MMCM>IDDT.MAC.29, 26-Feb-77 01:15:03, Edit by MMCM
; Added KL opcodes
;<MMCM>IDDT.MAC.28, 15-Feb-77 15:39:35, Edit by MMCM
; Added tops20 jsys's and fixed up single stepping after breakpoint.
;<MMCM>IDDT.MAC;109   8-Jan-77 21:05:30    EDIT BY MMCM
; Added $Y single stepping
;<MMCM>IDDT.MAC;108	  7-Jan-77 02:47:02    EDIT BY MMCM
; Added $J single stepping, fancy editting (delch);
; Made levtab, etc. typeout symbolic
;<MMCM>IDDT.MAC;108	  6-Jan-77 00:53:23    EDIT BY MMCM
; Added various isi bug fixes and ;;jobstat and ;interrupt status
;<SOURCES>IDDT.MAC;46     1-Dec-76 13:59:29    EDIT BY PLUMMER
;<SOURCES>IDDT.MAC;45     1-Dec-76 12:11:24    EDIT BY PLUMMER
;<SOURCES>IDDT.MAC;44     1-Dec-76 11:35:30    EDIT BY PLUMMER
; FIX CHKA3A TO AVOID CHACING @ PTRS ALL THE WAY INTO FILE
; FIX 0$NB TO WORK.
;<SOURCES>IDDT.MAC;43     8-Nov-76 17:59:38    EDIT BY PLUMMER
; FIX UP / SO / AFER EXAMINE OF CELL WITH 1B5 ON WORKS
;<SOURCES>IDDT.MAC;42    13-Sep-76 17:01:18    EDIT BY PLUMMER
; $9T MODE FOR BCPL STRINGS AND $8T FOR NETBUFS ETC
; GIVE PROPER ERRORS IF BPTS CANNOT BE INSERTED OR REMOVED
; CONVERT TO KL20 PMAP AND TTY STUFF
; BIG CHANGES TO CHKADR
;<SOURCES>IDDT.MAC;41     6-Jul-76 11:57:23    EDIT BY PLUMMER
; FIX PRFRK TO SAVE W OVER CALLS TO FSTAT
;<SOURCES>IDDT.MAC;38    16-Jun-76 12:03:58    EDIT BY PLUMMER
; TURN ON FORKSTAT CODE
;<SOURCES>IDDT.MAC;35    11-Jun-76 16:00:12    EDIT BY PLUMMER
;<SOURCES>IDDT.MAC;34    11-Jun-76 15:52:22    EDIT BY PLUMMER
; REPAIRS TO FORK STAT, ^T, INOUT, BREAKPOINT SETTER
; MAKE N;;F BE FORK SELECTION.  ;F TOTAL FORKSTAT, N;F SPECIFIC FORKSTAT
;<SOURCES>IDDT.MAC;33    10-Jun-76 14:44:53    EDIT BY PLUMMER
; FIX UP FORKSTAT
;<SOURCES>IDDT.MAC;32     9-Jun-76 14:37:04    EDIT BY PLUMMER
;<PLUMMER>IDDT.MAC;23     9-Jun-76 14:01:44    EDIT BY PLUMMER
; REVISE THE HFK: CASE AGAIN
;<PLUMMER>IDDT.MAC;22     9-Jun-76 12:57:37    EDIT BY PLUMMER
; INIT MAIN STACK AT SPLICD ENTRY SO THAT CALL SETTRP WILL WORK
;<PLUMMER>IDDT.MAC;21     9-Jun-76 11:51:22    EDIT BY PLUMMER
;<PLUMMER>IDDT.MAC;20     8-Jun-76 17:48:59    EDIT BY PLUMMER
; ;;U COMMAND TO COPY IDDT SYMTAB TO USER SPACE AND THEN DO A ;U
; ;Y ETC SET $X LOCATION FROM DEFINITION OF PAT..
; ;;U DEFINES PAT.. FROM VALUE IN $X TO PRESERVE PATCHES
;<PLUMMER>IDDT.MAC;17     4-Jun-76 12:13:15    EDIT BY PLUMMER
; FIX UUO INTERPRETER, ADD INTERPRETER FOR USER JSYS'S
;<PLUMMER>IDDT.MAC;16     3-Jun-76 23:38:52    EDIT BY PLUMMER
; CHANGE SEQUENCE SAVING LOGIC IN SLASH
;<PLUMMER>IDDT.MAC;12     3-Jun-76 13:45:04    EDIT BY PLUMMER
; NEWFRK: MOVE FFORK AFTER CALL SETTRP TIL JSYS TRAP BUG FIXED
;<PLUMMER>IDDT.MAC;11     3-Jun-76 10:24:11    EDIT BY PLUMMER
; SOUP IN ALL OF TOMLINSON'S MULTI-FORK CODE
;<PLUMMER>IDDT.MAC;7     2-Jun-76 14:56:59    EDIT BY PLUMMER
; ;JFN STATUS COMMAND
;<PLUMMER>IDDT.MAC;3     2-Jun-76 12:01:34    EDIT BY PLUMMER
; UPDATE JSYS TABLE
; ^T TYPES GROUP LOAD INSTEAD OF LOAD AV.
; ^T AND ;V VIEW CELL LOGIC
; JSYS INSTRUCTION TYPER EVALUATES EFFECTIVE ADDRESS
; <PAGE>;A COMMAND
; FIX INTERPRETATION OF PUSHJ AND POV
; USE DEBRK .+1 RATHER THAN CIS AT ENTRIES
; FIX THE HANDLING OF INTERRUPTS FROM HALTED FORKS
;<SOURCES>IDDT.MAC;31     1-APR-74 16:06:45	EDIT BY PLUMMER
; FIX THE ^T "RUNNING AT ?" BUG
;<SOURCES>IDDT.MAC;30    21-MAR-74 12:36:28	EDIT BY PLUMMER
;<SOURCES>IDDT.MAC;29    20-MAR-74 13:12:54	EDIT BY PLUMMER
; ADD "LOCKED BY USER" TYPEOUT TO ;A
;<SOURCES>IDDT.MAC;28    20-MAR-74 12:37:50	EDIT BY PLUMMER
;<SOURCES>IDDT.MAC;27    19-MAR-74 00:19:33	EDIT BY PLUMMER
; FIX ;S (MISSING INSTR DUE TO NEW ;? CODE)
; TEXT INPUT INTERRUPTIBLE
; DONT FLUSH BPT'S AFTER ^C REENTER OUT OF USER PROG.
; JSYS DEFS FOR JSYS TRAP INSTRS
; ADD ^T ROUTINE
;<SOURCES>IDDT.MAC;22    12-MAR-74 00:30:11	EDIT BY PLUMMER
; $$Z FIXED (AGAIN)
; $P AFTER HALTF, HFORK CONTINUES PROGRAM (AGAIN)
;<SOURCES>IDDT.MAC;21    11-MAR-74 23:59:16	EDIT BY PLUMMER
; ;?  COMMAND
; FIX ;M
; ADD VERSION NUMBER STUFF
;<SOURCES>IDDT.MAC;17    23-AUG-73 10:58:55	EDIT BY PLUMMER
;<SOURCES>IDDT.MAC;16    23-AUG-73 01:23:56	EDIT BY PLUMMER
;<SOURCES>IDDT.MAC;15    23-AUG-73 00:34:42	EDIT BY PLUMMER
; $X ETC, PUSHES THE BREAK INSTRUCTION
; PDL OVF DURING PUSHJ INTERPRET DOES IIC ON USER'S POV CHN
; FLUSH SFORKS
; FLUSH SYMP POINTER TO LOCATION CONTAINING SYMPTR
; POLISH FLOATING FRACTION GATHERING
;<SOURCES>IDDT.MAC;13    14-AUG-73 12:03:15	EDIT BY PLUMMER
; RUBOUT DOES CIS
; CIS'S RATHER THAN DEBRK TO .+1
; FORK TERMINATION NO LONGER AN INTERRUPT
; FIX FLOATING INPUT BUG IN "POWER"
;<SOURCES>IDDT.MAC;12     3-JUN-73 20:39:35	EDIT BY PLUMMER
;<SOURCES>IDDT.MAC;11     1-JUN-73 00:04:40	EDIT BY PLUMMER
; FIX FLSSYM -- HRL'S SHOULD HAVE BEEN HRLI'S
;<SOURCES>IDDT.MAC;10    17-APR-73 10:46:42	EDIT BY PLUMMER
; GET SYMS IF NONE BEFORE AT INIT3
; JOBSYM INITIALLY 0 IN LEFT HALF NOW
;<SOURCES>IDDT.MAC;9    13-APR-73 11:11:08	EDIT BY PLUMMER
; REPAIR ESCAPE CHR DETECTION IN GETC
; ADD CIS AT INTERRUPT OUT OF USER
;<SOURCES>IDDT.MAC;8    11-APR-73 15:35:39	EDIT BY PLUMMER
; FIX $$B
; FIX AUTO PROCEED SO THAT IT SEES INTERRUPTS
;<SOURCES>IDDT.MAC;7    10-APR-73 22:30:19	EDIT BY PLUMMER
;<SOURCES>IDDT.MAC;6    10-APR-73 13:38:34	EDIT BY PLUMMER
;<SOURCES>IDDT.MAC;5     4-APR-73 01:09:59	EDIT BY PLUMMER
;<SOURCES>IDDT.MAC;4     4-APR-73 00:23:33	EDIT BY PLUMMER
;<SOURCES>IDDT.MAC;3     4-APR-73 00:10:12	EDIT BY PLUMMER
; CLEANUP START/REENTER/SPLICD ENTRIES
;<SOURCES>IDDT.MAC;2     3-APR-73 23:53:32	EDIT BY PLUMMER
; ^A FEATURE FOR ATOMS
; REPAIR SEARCHS
; REPAIR BPT INSERT/REMOVE
; FLUSH TEST AND COMPARE MACROS, FIX EA CALC ON $P
; DO ATI IN ;E ROUTINE
; ALLOW ;E TO TYPE IN ESCAPE CHR
; REMOVE EXTRA INSTRUCTIONS AT TBRK
; USE SIN FOR ;O
; USE SOUT FOR ;W
; FIX ;O AND ;W TYPEOUTS
;<2SOURCES>IDDT.MAC;290     8-MAR-73 10:29:42	EDIT BY PLUMMER
;<2SOURCES>IDDT.MAC;289     7-MAR-73 23:06:11	EDIT BY PLUMMER
; REARRANGE CALLS TO TEXT TYPERS IN FILE COMMANDS
; MORE PATCH MODE STUFF
;<2SOURCES>IDDT.MAC;288     7-MAR-73 21:31:08	EDIT BY PLUMMER
; RUBDVOUT'S TYPED IN WHILE IN IDDT BEHAVE LIKE THE ESCAPE CHR
;<2SOURCES>IDDT.MAC;287     7-MAR-73 15:23:34	EDIT BY PLUMMER
;<2SOURCES>IDDT.MAC;285     5-MAR-73 22:49:06	EDIT BY PLUMMER
; PATCH MODE STUFF STARTED
;<2SOURCES>IDDT.MAC;279     1-MAR-73 13:40:55	EDIT BY PLUMMER
; "GETJFN" ROUTINE THAT ALLOWS ESCAPE CHAR TO BE TYPED IN
; ALLOW ^C ETC FOR ESCAPE CHR
; REMOVED OLD FLAG "SBF" -- NOT USED
 ;<2SOURCES>IDDT.MAC;277    28-FEB-73 17:41:08	EDIT BY PLUMMER
 ; SWITCH BACK TO ONLY ONE INTERRUPT CHR (MOBY CHANGE)
 ;<2SOURCES>IDDT.MAC;274    27-FEB-73 22:32:11	EDIT BY PLUMMER
 ; FLUSH UNCOMMON DEF A AC'S B AND C
 ;<2SOURCES>IDDT.MAC;273    23-FEB-73 17:15:55	EDIT BY PLUMMER
 ; RE-DID THE CFIBF/CFOBF AT INTERRUPT SITUATION
 ;<2SOURCES>IDDT.MAC;272    21-FEB-73 17:16:46	EDIT BY PLUMMER
 ; ;R CLEARS SEMI FLAGS, FORKSTAT CALLS TYPE, MOVE PATCH SPACE
 ; CHANGE RELOC'S, SAY "IDDT" UPON HALTF ETC FROM USER
 ; RUBOUT FROM USER AND ERRORS CLEAR TYPE-AHEAD
 ;<2SOURCES>IDDT.MAC;271    20-FEB-73 22:19:47	EDIT BY PLUMMER
 ; "." HANDLED PROPERLY WHEN INSIDE IDDT
 ; /, [, ], !, AND \ DON'T SAVE OLD SEQUENCE
 ; $X MOVED TO LOCATION 20
 ;<2SOURCES>IDDT.MAC;267    19-FEB-73 14:36:58	EDIT BY PLUMMER
 ; GET SYMS AFTER ANY KIND A ENTRY
 ; READY FOR BPT'S TO REPORT AS STATUS 6
 ; BACK TO OLD "SETUP" FOR $$Z
 ; FLUSH "ZLOW" PARAMETER
 ; SWITCH TO CALL AND RET
 ;<2SOURCES>IDDT.MAC;266     6-FEB-73 00:00:19	EDIT BY PLUMMER
 ; FIX $$Z
 ;<2SOURCES>IDDT.MAC;265     1-FEB-73 23:38:39	EDIT BY PLUMMER
 ; ADDED SEMICOLON SPACE COMMAND -- LIKE OLD ;
 ;<2SOURCES>IDDT.MAC;264    17-JAN-73 18:09:46	EDIT BY PLUMMER
 ; CHANGE DEPOSIT TO REMEMBER RIGHT ACCESS
 ; ADRSPC UNMAPS USER PAGE
 ;<2SOURCES>IDDT.MAC;263    14-JAN-73 21:55:27	EDIT BY PLUMMER
 ; HALTF, HFORK ARE PROCEDABLE
 ; CHANGE COC WORDS
 ; FIXED SWITCHING BETWEEN USER AND IDDT
 ; IDDT CHANGES ACCESS OF USER'S PAGE SO BPT'S ETC. NEVER FAIL
 ;  TO GO IN OR COME OUT
 ;<2SOURCES>IDDT.MAC;259    14-JAN-73 17:37:35	EDIT BY PLUMMER
 ;<2SOURCES>IDDT.MAC;257    14-JAN-73 16:26:55	EDIT BY PLUMMER
 ; ADDR;S  COMMAND
 ; PROVISIONS MADE FOR "SPLICED" ENTRY FROM EXEC
 ;<2SOURCES>IDDT.MAC;251     9-JAN-73 14:41:50	EDIT BY PLUMMER
 ; UPDATE JSYS TABLE TO STENEX.MAC;42
 ;<2SOURCES>IDDT.MAC;250     9-JAN-73 12:44:51	EDIT BY PLUMMER
 ; SEMICOLON DISPATCH INSTALLED
 ; XCT CHASER FIXED
 ;<2SOURCES>IDDT.MAC;249    27-DEC-72 16:05:13	EDIT BY PLUMMER
 ; FIXED  /  WITHOUT ARG
 ;<2SOURCES>IDDT.MAC;248     4-DEC-72 11:52:05	EDIT BY PLUMMER
 ; FILE LOGIC DEFAULTING CLEANED UP
 ;<2SOURCES>IDDT.MAC;245    19-OCT-72 11:00:27	EDIT BY PLUMMER
 ;<PLUMMER>IDDT.MAC;17    26-SEP-72 11:10:06	EDIT BY PLUMMER
 ; W, E, N SEARCHES TAKE COUNT    105$3W stopes on the 3rd find
 ; $$nZ fills core with n (assumed 0 if not given)
 ;<PLUMMER>IDDT.MAC;13    13-SEP-72 13:39:40	EDIT BY PLUMMER
 ; OPCODE TABLE EXPLAINATION CLEANED UP
 ; OLD TABLE DISCARDED
 ;<PLUMMER>IDDT.MAC;12    13-SEP-72 11:58:43	EDIT BY PLUMMER
 ; JSYS TABLE UPDATED
 ; ^S COMMAND TO STORE SYMBOLS
 ; NEW $$Y TO READ NEW STYLE SYMBOL FILES
 ; DEFAULT EXTENTIONS FOR FILE COMMANDS
 ;<PLUMMER>IDDT.MAC;8    12-SEP-72 17:47:54	EDIT BY PLUMMER
 ; SYMBOL FILE COMMAND
 ;<PLUMMER>IDDT.MAC;3    11-SEP-72 23:26:13	EDIT BY PLUMMER
 ; ENTRY VECTOR STUFF CLEANED UP (USES 0-LENGTH FEATURE)
 ; HALT, HALTF ARE SILENT RETURNS TO IDDT
 ;<PLUMMER>IDDT.MAC;2    11-SEP-72 22:19:55	EDIT BY PLUMMER
 ; SAVE/RESTORE USER'S TTY  TAB SETTINGS
 ; SAVE BREAKS-IN-PROGRESS WORD IN $I+3
 ; LEFT AND RIGHT HALF SYMBOL FIXUPS
 ; AUTOMATIC  $: AT STARTUP
 ; ALLOW TAGS WITH OPCODE NAMES
 ; ? COMMAND IMPROVED
 ;<2SOURCES>IDDT.MAC;243    25-AUG-72 17:52:06	EDIT BY PLUMMER
 ; SMACRO ASSEMBLY
 ; MOVED FROM 667000 TO 740000
 ;<2SOURCES>IDDT.MAC;242    26-JUL-72 19:51:00	EDIT BY PLUMMER
 ; FIX JSYS EVAL

	 HOME==700000		;Where IDDT proper lives

PDLIST:	IOWD 10,.+1		;Temporary stack
	BLOCK 10

BLAST:	MOVE P,PDLIST		;Init stack, we'll be needing it.
	CALL MOVEME		;Blast ourself way up in memory
	CALL GETMSY		;Get monitor symbols (and make JSYTAB)
	CALL GTOFIL		;Get final outfile file

	MOVEI	1,.FHSLF	;Set our new entry vector
	MOVE	2,[3,,EVEC]
	SEVEC

	MOVE	0,[PROTO,,1]	;Blast save code into ACs
	BLT	0,16
	JRST	4		;and start it going.

PROTO:	-1			;1 - Delete pages
	.FHSLF,,0		;2 - in this process starting at page 1
	<HOME/1000>+PM%CNT	;3 - this many pages.
	PMAP			;4 - kill them.
	MOVE 0,OURSYM		;5 - put back pointer
	MOVEM 0,116		;6 to our symbols
	HRR 1,JFN		;7
	HRLI 1,.FHSLF		;10
	MOVEI 2,14		;11
	SSAVE			;12 - save ourself
	JRST INIT		;13 - and then start running.
	-1,,SS%CPY+SS%RD+SS%WR+SS%EXE+0		;14 page 0
	-777,,SS%CPY+SS%RD+SS%WR+SS%EXE+1	;15 and high-order ones.
	0			;16 end of table

MOVEME:	MOVE 0,[LOW,,HOME]
	BLT 0,DDTEND-1		;Blast in pure body
	HRLZ 0,116		;Start of our symbol table
	HRRI 0,DDTEND
	HLRE 1,116		;-#symbols
	MOVEI 2,DDTEND-1
	SUB 2,1
	BLT 0,0(2)		;move the symbols way up there too.
	MOVEI 0,DDTEND
	HLL 0,116
	MOVEM 0,OURSYM		;Save new symbol table pointer
	RET

GTOFIL:	HRROI 1,[ASCIZ \Output IDDT to file \]
	PSOUT
	HRLOI 1,(GJ%FOU!GJ%MSG!GJ%FNS!GJ%SHT!GJ%CFM)
	MOVE 2,[.PRIIN,,.PRIOU]
	GTJFN
	  JRST [CALL TERPRI	;Oops, some error...
		CALL BARF	;tell what it was
		JRST GTOFIL]	;then let them try again.
	MOVEM 1,JFN
	HRROI 1,[ASCIZ "Saving to "]
	PSOUT
	MOVEI 1,.PRIOU
	MOVE 2,JFN
	MOVE 3,[111110,,JS%PAF]
	JFNS
	HRROI 1,[ASCIZ " ...
"]
	PSOUT
	RET

LOST:	CALL BARF
LOST0:	HALTF
	JRST .-1

GETMSY:	MOVSI 1,(GJ%SHT!GJ%OLD)			;Get monitor symbols
	HRROI 2,[ASCIZ "UNV:MONSYM.UNV"]
	GTJFN
	  SKIPA
	    JRST GOTUNV
	MOVSI 1,(GJ%SHT!GJ%OLD)
IFN KL20F,<
	HRROI 2,[ASCIZ "SYS:MONSYM.UNV"]
>;KL20
IFE KL20F,<
	HRROI 2,[ASCIZ "<SUBSYS>MONSYM.UNV"]
>;Non-KL
	GTJFN
	  SKIPA
	    JRST GOTUNV
	HRROI 1,[ASCIZ "Can't find MONSYM.UNV anywhere.
Where is it? "]
	PSOUT
	MOVSI 1,(GJ%FNS!GJ%SHT!GJ%CFM)
	MOVE 2,[.PRIIN,,.PRIOU]
	GTJFN
	  JRST LOST
GOTUNV:	MOVEM 1,UNVJFN
	MOVE 2,[440000,,OF%RD]	;36-bit read.
	OPENF
	  JRST LOST
	HRROI 1,[ASCIZ "Loading monitor symbols from "]
	PSOUT
	MOVEI 1,.PRIOU
	MOVE 2,UNVJFN
	MOVE 3,[111110,,JS%PAF]
	JFNS
	HRROI 1,[ASCIZ " ... "]
	PSOUT
	CALL UNVHED		;Pass over the header
	SETZM NJSYSI		;No JSYSi yet
INMONS:	CALL GTUNVS		;Get a symbol and value
	  JRST GOTMSY		;  fatal error or no more
	HLRZ T,TT2		;Look at LH of symbols value
	CAIN T,(JSYS)		;This a JSYS maybe?
	  JRST [HRRZ T,TT2	;Look at RH
		CAILE T,777	;0 - 777?
		  JRST .+1	;  Naw, not a JSYS
		JRST GOTJSY]	;Yep!
	TLO TT1,GLOBAL+DELO	;set delete-output and global bits in symbol
	MOVE T,MONPTR
	CAIL T,RWX		;Make sure we keep in our region
	  JRST TOOSML
	MOVEM TT1,@MONPTR	;save symbol
	AOS T,MONPTR
	CAIL T,RWX
	  JRST TOOSML
	MOVEM TT2,@MONPTR	;and its value
	AOS MONPTR
	JRST INMONS

GOTJSY:	TLZ TT2,-1		;This JSYS#
	SKIPN JSYTAB(TT2)	;Already got a name?
	  MOVEM TT1,JSYTAB(TT2)	;  No, so fill it in.
	AOS nJSYSi
	JRST INMONS

TOOSML:	HRROI 1,[ASCIZ "
Not enough room!  Threatening to clobber RWX area..."]
	PSOUT
	JRST LOST0

GOTMSY:	MOVE 1,UNVJFN
	CLOSF
	  JFCL
	HRROI 1,[ASCIZ "done.
"]
	PSOUT
	MOVEI 1,.PRIOU
	MOVE 2,nJSYSi
	MOVEI 3,^D10
	NOUT
	  NOP
	HRROI 1,[ASCIZ " JSYSi defined, "]
	PSOUT
	MOVE T,MONPTR
	SUBI T,MONTAB
	MOVEI 1,.PRIOU
	MOVE 2,T
	LSH 2,-1		;/2
	MOVEI 3,^D10
	NOUT
	  JFCL
	HRROI 1,[ASCIZ " other symbols loaded.
"]
	PSOUT
	MOVNS T
	HRLI T,MONTAB
	MOVSM T,MONPTR
	RET

	LIT			;So we don't mix them up with the stuff
				;we want to be saving.

;Define accumulators

F=0		;FLAGS
R=<A==2>	;POINTERS TO TABLES, CORE, ETC.
S=3		;USED IN EVAL, FP1, FP4
W=4		;CONTAINS DISPATCH ADDRESS, USED IN FP1A, FP4
T=5		;TRANSFER DATA
W1=T+1
W2=7
SCH=10		;MODE CONTROL SWITCH FOR OUTPUT - CONTENT TYPER
AR=SCH+1	;MODE CONTROL SWITCH FOR OUTPUT - ADDRESS TYPER
ODF=AR+1	;MODE CONTROL SWITCH FOR OUTPUT - CURRENT RADIX
TT=13		;TEMPORARY
TT1=TT+1	;TEMPORARY
TT2=15		;TEMPORARY
TT3=16		;TEMPORATY
P=17		;PUSH DOWN

IFNDEF MIT,<MIT==0>

IFNDEF ISIGFF,<ISIGFF==<1-KL20F>>	; Isi's version of gfrks (no skip)
IFNDEF DELCHF,<DELCHF==<1-KL20F>>	; Delch jsys (for nifty editting)?
IFNDEF ADBRKF,<ADBRKF==KL20F>		; Address break stuff
IFNDEF XTENDF,<XTENDF==KL20F>		;Extended address stuff?

IFNDEF SYSF,<SYSF==0>			;Use SYS: for ;Y'anking, else DSK:

IFN DELCHF,<IFNDEF DELCH,<OPDEF DELCH [JSYS 625]>>

;Define bits for use in left half of accumulator F

  FEF==400000	;'E' exponent flag
 COMF==200000	;',' typed
  TIF==100000	;TRUNCATE TO 18 BITS -  SET BY SPACE OR COMMA
  DVF==40000	;DIVIDE FLAG
  FPF==20000	;'.' typed
  CCF==10000	;'$$' typed
  STF==4000	;Suppressed Typeout flag
  SAF==2000	;'>' typed
  FAF==1000	;'<' typed
QUESF==400	;'?' typed
  MLF==200	;'*' flag
  PTF==100	;'+', '-', or '*' typed
   CF==40	;'$' typed
  LTF==20	;LETTER TYPED IN TO CURRENT SYLLABLE
  ROF==10	;REGISTER OPEN FLAG
   SF==4	;SYLLABLE FLAG
   MF==2	;'-' typed
   QF==1	;QUANTITY TYPED IN TO WORD ASSEMBLER

;Define bits for use in right half of accumulator F

   Q2F==1	;NUMBER TYPED AFTER ALT MODE 
   ITF==2	;INSTRUCTION TYPED IF ITF=1
  OUTF==4	;OUTPUT IF OUTF=1
 TEM2F==10	;ANOTHER TEMPORARY, USED IN ;O STUFF and in merge not to clear
SSTEPF==20	; WE ARE SINGLE STEPPING
   XEQ==40	;WE'RE IN A $X
 SEMIF==100	;SEMICOLON TYPED
   NAF==200	;NEGATIVE ADDRESSES PERMISSABLE
   CF1==400	;OUTPUT 1 REGISTER AS CONSTANT
 CONDX==1000	;WE'RE EXECUTING THE CONDITIONAL BREAK INSTR.
   LF1==2000	;OUTPUT 1 REGISTER AS FORCED SYMBOLIC OR CONSTANT
  POWF==4000	;ARGUMENT FOR EXPONENT COMING
  TEMF==10000	;TEMPORARY FLAG
INTFLG==20000	;EXPR CONTAINS DDT INTERNAL REGISTER
YSTEPF==40000	; WE ARE IN $Y SINGLE STEP MODE VS $J MODE
SEMIF2==100000	;TWO SEMICOLI TYPED
SUPTEM==200000	;SUPER-TEMPORARY TYPEOUT MODE

;Random things

MAXJFN==155		;HIGHEST JFN NUMBER
JOBSYM==116		;Where standard symbol pointer is kept
STRBFL==40		;STRING (ATOM) BUFFER LENGTH
XPATCH==<1,,20>		;Where to do extended patching

XPCBP==<2700,,0>	;BP to Global address
XSECBP==<220500,,0>	;BP to section # in global address
XPC==<37,,777777>	;mask for extended PC portion of PC word
XSEC==<37,,0>		;mask for section part of PC
PCFL==<777740,,0>	;mask for flag portion of PC word

esc=="["-100		;the escape character
cr=="M"-100		;carriage return
lf=="J"-100		;linefeed
quote==""""		;doublequote
delete==177		;delete character

;Define push down length

LPDL==100	;MAX LENGTH PUSH DOWN LIST
PCSL==150	;OLD PC STACK LENGTH

;Define symbol table symbol types

GLOBAL==040000	;GLOBAL SYMBOL
LOCAL==100000	;Local symbol?
PNAME==740000	;PROGRAM NAME
DELI==200000	;DELETE INPUT
DELO==400000	;DELETE OUTPUT

;DEFINE UDEFINED SYMBOL TABLE TYPES

STADD==1B0	;IF 1, THEN ADDITIVE REQUEST
STLH==1B1	;IF 1, THEN REQUEST FOR LEFT HALF
STNEG==1B4	;IF 1, THEN NEGATIVE REQUEST

;FLAG SAYING ADDRESS IS IN NDDT'S ADDRESS SPACE
;MUST BE DIFFERENT THAN UNDEFINED SYMTAB TYPE BITS

DDTINT==1B5

NRBL==50	;NUMBER OF RING-BUGGER LOCATIONS (FOR SAVING OF EXAMINED LOCS)
NBP==10		;NUMBER OF BREAKPOINTS
NTBPTS==3	;NUMBER OF TEMPORARY BREAKPOINTS

OPDEF TYO	[PBOUT]
OPDEF TYI	[PBIN]
OPDEF CALL	[PUSHJ P,]
OPDEF RET	[POPJ P,]

DEFINE INTOFF <
	MOVEI	1,.FHSLF
	MOVSI	2,(1B0)
	DIC
>

DEFINE	INTON	<
	MOVEI	1,.FHSLF
	MOVSI	2,(1B0)		;THE RUBOUT CHANNEL
	AIC
>

define uppercase(ac) <
	cail ac,"a"
	  caile ac,"z"
	    skipa
	 subi ac,<"a"-"A">	;If lowercase convert to UPPERCASE
>

define lowercase(ac) <
	cail ac,"A"
	  caile ac,"Z"
	    skipa
	   addi ac,<"a"-"A">	;turn UPPERCASE to lowercase
>

LOW:	PHASE HOME		;Start of pure, the true body of the program.
IDDT:

V%MAJOR==3
V%MINOR==0
V%EDIT==12
V%WHO==2

;ENTRY VECTOR
EVEC:	JRST	INIT		;"START"
	JRST	INIT		;"REENETER"
	JRST	SPLICD		;INFERIOR HAS BEEN SPLICED BY EXEC

;FORK HANDLE SUPPLIED IN AC1 FROM EXEC
SPLICD:	MOVEM	1,TPFORK	;SAY WE HAVE AN INFERIOR
	MOVEM	1,FORK
	setom showpc		;show user forks current PC after initializing
	MOVE	P,PS		;GET A STACK
IFN KL20F,<	ffork>
	CALL	SETTRP		;SET JSYS TRAP FOR BPT

INIT:	INTOFF			;PREVENT SURPRISES DURING INIT
	MOVE	P,PCSTAK
	MOVEM	P,PCSPTR	;RESET STACK OF PC'S
	MOVE	P,PS		;MAIN STACK
	MOVE	T,[SCHM,,SCH]
	BLT	T,ODF		;LOAD MODE CONTROL SWITCHES
	SKIPLE	TPFORK		;DOES USER fork ALREADY EXIST?
	  JRST INIT3		;  yes
	MOVEI	1,.PRIIN
	SIBE			;ANY TYPE AHEAD?
	 JRST	INIT09		;  YES, so skip header
	HRROI	1,[ASCIZ /Extended IDDT /]
	PSOUT
	CALL PRTVER		;Let's see our version
	hrroi 1,[asciz ", type ^_^_ for help."]
	psout
	call crf		;then a blank line
INIT09:	CALL	NEWFRK		;GET A NEW FORK

INIT3:	MOVNI	1,5		;-5 means entire job
	RUNTM			;get runtime (in ms) into AC1
	MOVEM	1,TIMUSD	;save runtime @ reset
	MOVEM	3,TIMCON	;save console time @ reset
	MOVE	1,TPFORK
	FFORK			;FREEZE THE USER
	AOSE	USRFLG		;WERE WE IN THE USER BEFORE ^C, REE??
	 JRST	INIT4		;  NO, IDDT HAS USER INFO ALREADY
	CALL	USTATE		;GET COMPLETE STATE OF USER FORK
	SKIPL	SYMPTR		;DO WE ALREADY HAVE SYMBOLS?
	  CALL	SYMVEC		;GET SYMBOLS, ENT. VEC.
INIT4:	MOVEI	1,.FHSLF	;SETUP INTERRUPT SYSTEM ON IDDT FORK
	MOVE 2,[LEVTAB,,CHNTAB]
	SIR			;SETUP
	CIS			;Clear Interrupt System
	EIR			;Enable Interrupt System
IFE ADBRKF,<	MOVSI 2,(1B0!1B1!1B2)>	;RUBOUT, ^T, AND BPT CHANS
IFN ADBRKF,<	MOVE 2,[1B0!1B1!1B2!1B19]>	;INFERIOR TERMINATION TOO
	AIC			;Arm channels
	JRST	DDT

;ENTRIES FROM USER

;RUBOUT HIT, MAKE BELIEVE INSTR TRAP HAPPEND
RUBOUT:	AOSE	USRFLG		;WE'RE WE IN USER?
	  JRST	RENWRG		;  NO, REENTER IDDT AT WRONG
	MOVEI	1,.PRIIN	;yes.
	CFIBF			;FLUSH TYPE-AHEAD
	JRST	TRAP

;BPT INTERRUPT
BPTINT:	skipe debug
	  jrst [call terpri
		hrroi w1,[asciz "D> Breakpoint hit"]
		call type
		call crf
		jrst .+1]
	MOVE 1,TPFORK
	FFORK			; STOP THE WORLD.
	RTFRK			; READ WHICH FORK HIT BPT
IFE KL20F,<	 JRST BPTIN1>
IFN KL20F,<	erjmp	bptin1>

BPTIN4:
IFE KL20F,<	HLRZS 1>
	CAME	1,FORK
	 CALL	UNMAP
	MOVEM	1,FORK
	UTFRK
	 ERJMP .+1
	INTOFF
	MOVEI	1,BPTIN0
	MOVEM	1,IPC1
	DEBRK

BPTIN0:	SETZM	BPTFLG
	CALL	USTATE
	MOVSI	1,6
	JRST	TRAPD1

BPTIN1:	MOVSI	2,-14
BPTIN2:	MOVEI	1,BPTS
BPTI2A:	HRRZ	3,7(1)
	CAIN	3,400001(2)
	 JRST	BPTIN3		; FORK HANDLE IN USE -- SKIP IT
	ADDI	1,NBPTV
	CAIE	1,<BPTS+<NBP*NBPTV>>
	 JRST	BPTI2A
	MOVEI	1,400001(2)
	CAME	1,FORK
	 CAMN	1,TPFORK
	  JRST	BPTIN3
	RFRKH
BPTIN3:	AOBJN	2,BPTIN2
	RTFRK
IFE KL20F,<	 0	>	;what the hell is this???!?
	JRST	BPTIN4

;INSTR. TRAP. COULD BE ILL INSTR, ETC.

TRAP:	INTOFF
	MOVE	1,TPFORK
	CAME	1,FORK
	  CALL	UNMAP
	MOVEM	1,FORK
	MOVE	1,TPFORK
	FFORK
IFE KL20F,<
	MOVEI 1,TRAPD
	MOVEM	1,IPC2
	DEBRK
>;IFE KL20F
	CIS
TRAPD:	SETZM	BPTFLG		;ASSUME NOT FROM BPT
	CALL	USTATE		;GET USER STATE
	TLZ	1,400000	;INTERRUPT --> 0
TRAPD1:	MOVEM	1,WHY
	HLRZ	W,1		;W HAS TERMINATION REASON
	HRRZS	1		;1 HAS REASON WHY ILLEGAL IF W NOT = 2
	SETZM	TRAPWD
	SETZM	WDATA
	cain w,.rffpt		;ILL INST., ILL MEM REF, ETC
	  jrst trap3
	setzm ilitrp		;not a trapped ili, etc
IFN ADBRKF,<
	caie w,.rfabk		;ADDRESS BREAK HIT?
	 cain w,.rfsig		;OR JOB WANTS THE TTY
	  jrst trap7		;YES
>;IFN ADBRKF
	caie w,.rftrp		;NEW BPT CLASS
	 cain w,.rfhlt		;HALTF, HFORK, BPT
	  jrst trap2

;INTERRUPT, IO WAIT, FORK WAIT
TR014:	movei 1,.rfsig		;HANDLE AS INTERRUPT, WHY=10 FOR  XXX:
	hrrm 1,why
	jrst notmt		;GO TYPE BREAK MESSAGE

IFN ADBRKF,<
TRAP7:	movei 1,20(W)		;FAKE REASON (ABK:=7 OR TTY:=10)
	HRRM	1,WHY
	JRST	NOTMT
>

;FORCED TERMINATION CLASS
TRAP3:	cail 1,.icird		;illegal memory read
	 caile 1,.iciwr+1	; illegal memory write
	  jrst notmt		;  NOT A MEMORY TRAP

;MEMORY ACCESS VIOLATION
MEMTRP:	MOVE	1,FORK
	GTRPW
	MOVEM	1,TRAPWD
	MOVEM	2,WDATA
	TLNN 1,(tsw%rd!tsw%ex)	;READ AND EXECUTE TRAPS LEAVE GOOD PC
	  SOS	PC		;WRITE LEAVES IT STEPPED, AND BIT-5 ON(R/W/X)

NOTMT:	TRNN	F,CONDX		;ARE BPT'S IN?
	 CALL	REMOVB		;YES, PULL THEM OUT
	MOVEI	1,.PRIIN
	CFIBF			;CLEAR TYPE-AHEAD AT ERROR
	JRST	TBRK		;TYPE THE BREAK MESSAGE

;VOLUNTARY TERMINATION (HFORK, HALTF, BPT)
;GET ACTUAL INSTRUCTION THAT CAUSED TRAP

TRAP2:	ldb r,[XPCBP pc]	;actual PC where BP hit
TRAP21:	CALL	FETCH		;FETCH AN INSTR
	 SETZM	T		;PROTECTED, MAKE LIKE ILLEGAL INSTR.
TRAP22:	LDB W1,[POINT 9,T,8]	;get the opcode
	CAIE W1,<<XCT 0>/1B8>	;IS THIS AN XCT?
	  JRST	TRAP23		;  no.
TRAP29:	LDB R,[POINT 4,T,17]
	CAIE	R,0		;ANY XR SPECIFIED?
	  MOVE	R,AC0(R)	;YES, GET IT
	ADD	R,T		;DO INDEX ADDITION
	HRRZS	R
	TLNN	T,(@)		;ANY INDIRECTION?
	  JRST	TRAP21		;NO, CHECK FOR ANOTHER XCT
	CALL	FETCH		;FETCH INDIRECT ADDR
	 SETZM	T
	JRST	TRAP29

TRAP23:	PUSH	P,T		;save the contents
	PUSH	P,R
	TRNN	F,CONDX
	  CALL	REMOVB		;PULL OUT BPT'S IF THEY ARE IN
	POP	P,R
	POP	P,T
	CAMN	T,[BPT]
	 JRST	CHKBPT		;POSSIBLE BPT HIT
	CAME	T,[HFORK]
	 CAMN	T,[HALTF]
	  skipa
	   JRST	TRAP27
	trne f,sstepf		;are you single-stepping?
	  jrst [movei tt,1	;  yes.  fake that HALTF skipped once and
		jrst jstep2]	;  go back to ^N code
	AOS	PC		;SO A $P WILL CONTINUE
	MOVSI	W1,(1B5)	;User-mode bit
	IORM	W1,REALPC
	call reddt		;say "IDDT" so they know we're back
	jrst dd1.5		;then go for it.

;HERE IS AN OBSCURE CASE.  THE FORK HAS BEEN HALTED BY A SUPERIOR
;OF IDDT.  THE RIGHT THING TO DO IS JUST RFORK (IE JRST TOUSER).
;HOWEVER THE WFORK WILL IMMEDIATELY COMPLETE AGAIN AND WE WILL BE
;IN A GIANT LOOP, BURNING CYCLES.  TO AVOID THIS WE WILL HANDLE IT
;JUST LIKE A RUBOUT INTERRUPT, USING THE TIME IT TAKES THE
;USER TO TYPE $P AS A DELAY.

;THE GENERAL PROBLEM IS THAT THE USER FORK HAS TWO PROCESSES WRITING
;ON ITS STATUS -- IDDT AND THE SUPERIOR.  THIS REQUIRES SOME FORM OF
;COOPERATION BETWEEN THE WRITES AS NOT TO CONFUSE THINGS!

TRAP27:	MOVEI	W,31		;FAKE BREAK NUMBER
	MOVEM	W,WHY
	JRST	NOTMT		;GO TYPE THE HFK:... MSG

CHKBPT:	TRNE	F,CONDX		;HIT BPT, WERE THEY IN?
	  JRST	CHKBP2		;NO,  TRY FOR $X COMPLETION, ETC.
	PUSH	P,R		;SEE IF IT IS A BPT
	call chkadr		; GET OWNING FORK
	MOVEI	T,BPTS
CHKBP1:	skipe w,.baddr(t)	;WHERE THIS BPT IS PLANTED
	 came w,(p)		;right address?
	  jrst chkb1a		;  nope, try next
	hlrz w1,lastpg		;current process id
	came w1,.bfork(t)	;in the right process, too?
	  jrst chkb1a		;  nope, try next
	POP	P,R		;yes, so get back address
	JRST	BCOM		;and take care of it.

CHKB1A:	ADDI	T,NBPTV
	CAIE	T,BPTS+NBP*NBPTV
	 JRST	CHKBP1
	POP	P,R

;IS IT A PSEUDO BPT -- $X COMPLETION, ETC
CHKBP2:	MOVE TT,R
	SUB TT,XRG		;WHERE $X HAPPENS IN USER
	subi tt,1		;first word of XRG if global EA now
	JUMPLE TT,CHKBPZ	;WITHIN ALLOWED RANGE OF SKIPS?
	CAILE TT,3
	 JRST CHKBPZ		;NO, CALL IT ILLEGAL

;PSEUDO BPT HIT, SEE WHY
	TRNE	F,XEQ		;IN $X?
	 JRST	XCOM		; YES.
	TRNE	F,SSTEPF	;SINGLE STEPPING?
	 JRST	JSTEP2		; yes
	TRNE	F,CONDX		;IN A CONDITIONAL BREAK EVAL?
	 JRST	CONCOM		; YES.
	JRST	ILLINS		;HUH?

;NOT LEGAL AS $X, BUT MIGHT BE $^N COMPLETION

CHKBPZ:	move tt,r
	move w1,$ctrln+3	;LOCATION OF FIRST BPT
	SUB	TT,W1
	JUMPL	TT,ILLINS	;WITHIN ALLOWED RANGE OF SKIPS?
	CAIL	TT,3
	 JRST	ILLINS		;NO, CALL IT ILLEGAL
	TRNN	F,SSTEPF	;SINGLE STEPPING?
	 JRST	ILLINS		; NOPE, MUST BE ILL INS
	MOVE	TT,R
	SUB	TT,$CTRLN	;TT GETS AMOUNT TO OFFSET REALPC BY
	JRST	JSTCTN

;TYPE SOFTWARE GENERATED (IDDT) ILLEGAL INSTRUCTION
ILLINS:	movei w,.icili		;ILL:
	movem w,why

;TYPE BREAK MESSAGE,  WHY SAYS WHICH

TBRK:	CALL	CRF		;CARRIAGE RETURN
	HRRZ	W,WHY
TBRK1:	SKIPE W1,MSG(W)		;TEXT OF BREAK REASON
	  CALL TEXT2		;TYPE IT
tbrk2:	trne f,sstepf		;are we single-stepping?
	  call unset		;  yes, so get back original context
	ldb t,[XPCBP pc]	;get the user PC
	SETOM	PINFF		;PRINT APPROPRIATE AC AND EFF ADR
	SKIPN MSG(W)		;Normal output?
	  CALL LI1a		;  naw, probably ^D break (skip returns)
	    CALL LI1		;EXAMINE THE BREAK LOCATION, SETUP "."
	CALL	LCT
	HRRZ	W,WHY
	hrrz t,chntab(w)	;if this dispatch address is PANERR,
	caie t,panerr		;then it's a panic channel, so check
tbrk3:	  jrst tbrk4
	ldb r,[XPCBP pc]	;get the pc
	addi r,1		;next location
	and r,[xpc]		;in case we wrap
	call fetch		;get the instruction after the one that died
	  jrst tbrk4		;  failed to, oh well
	and t,[777740,,0]	;keep only the opcode and AC field
	came t,[erjmp]		;if the next instruction is
	  camn t,[ercal]	;  one of these,
	    skipa		;    (which it isn't)
	    jrst tbrk4		;    take the er{jmp,cal},
	dpb r,[XPCBP pc]	;so set the pc to it.
	call crf		;get to a new line
	move t,r		;in preparation for
	setom ilitrp		;this is a trapped ili or whatever
	jrst varrw1		;opening to next location to show we took it

tbrk4:	CAIE W,.rfsig		;INTERRUPT CODE
	 TRNN F,XEQ!CONDX
	  JRST	DD2
	CALL	UNSET		;POP PREVIOUS $X CONTEXT
	JRST	DD1.5

;READ THE USER'S STATE
;SWITCH TTY AND SUBSYS TO IDDT

USTATE:	MOVEI	1,.PRIIN
	RFMOD
	MOVEM	2,SAVTTY
	RFCOC
	MOVEM	2,SAVTT2
	MOVEM	3,SAVTT3
	MOVE	2,TTYCC2
	MOVE	3,TTYCC3
	SFCOC
	GTABS
	MOVEM	2,USRTB2
	MOVEM	3,USRTB3
	MOVEM	4,USRTB4
	MOVE	2,DDTTB2
	MOVE	3,DDTTB3
	MOVE	4,DDTTB4
	STABS
	GETNM
	MOVEM	1,SUBSYS
	MOVE	1,[sixbit /IDDT/]
	SETNM			;SET SUBSYSTEM NAME
	CALL	GETUSR		;fall into: GET STATE OF USER FORK
	skipn debug
	  ret
	push p,w1
	push p,t
	hrroi w1,[asciz "D> User PC is "]
	call type
	ldb t,[xpcbp realpc]
	call pad
	call crf
	pop p,t
	pop p,w1
	RET

;GET STATE OF USER FORK INTO IDDT SPACE

GETUSR:	MOVE	1,FORK
	RWM
	MOVEM	1,USRPSI+0	;USER CHANNELS WITH WAITING REQ.
	MOVE	1,FORK
	RCM
	MOVEM	1,USRPSI+1	;ACTIVE USER CHANNELS
	MOVEM	2,USRPSI+2	;BREAKS IN PROGRESS
	MOVE	1,FORK
	SETOM	USRPSI+3
	SKPIR			;SEE IF USR HAS INTERRUPTS ON
	 SETZM	USRPSI+3
	DIR
	TLO	1,(RT%DIM)
	RTIW			; Terminal interrupt word
	MOVEM	2,USRPSI+4
	MOVEM	3,USRPSI+5
	HRRI	1,.FHJOB
	RTIW
	MOVEM	2,USRPSI+6
	MOVEM	3,USRPSI+7
	SETZB	2,3
	STIW
	 ERJMP	.+1		; Can fail if no ^C capability
	MOVEI	1,.FHJOB
	MOVE	2,[060000,,100000]
	STIW
	 ERJMP	.+1
	MOVE	1,FORK
	MOVEI	2,AC0
	RFACS			;GET USER'S AC'S
	RFSTS
	MOVEM	2,REALPC
	TLNN	2,(1B5)		;MONITOR MODE PC?
	  SOS	2		;  YES, BACK IT UP SO . WILL APPEAR OK
	MOVEM	2,PC		;AND HIS PC
	ldb 3,[XSECBP 2]	;get the section#
	movem 3,cursec		;save it here
	jumpe 3,gtusr0		;sec 0, so don't need extended patch area
	move 3,xrg		;see where current pat location is
	tlne 3,37		;already extended?
	  jrst gtusr0		;  yes, so leave it be
	move 3,[xpatch]		;else use this extended patch location
	movem 3,xrg		;  yes, use extended patch area from now on
gtusr0:	SETZM	USRFLG		;WE'RE NOT IN THE USER.
	RET

; SET STATE OF USER FORK FROM IDDT SPACE

SETUSR:	MOVE	1,FORK
	MOVEI	2,AC0
	SFACS			;GIVE BACK HIS AC'S
	SETO 2,
	DIC			;DEASSIGN ALL CHANNELS
	MOVE	2,USRPSI+1	;TURN ON ONES WHICH SHOULD BE ACTIVE
	AIC
	SKIPE	USRPSI+3
	EIR			;INTERRUPTS ARE SUPPOSED TO BE ON
IFN KL20F,<
	TLO	1,(ST%DIM)	; TERMINAL INTERRUPT WORD
>;IFN KL20F
	MOVE	2,USRPSI+4
	MOVE	3,USRPSI+5
	STIW
	 ERJMP	.+1		; Can fail if no ^C capability
	HRRI	1,-5
	MOVE	2,USRPSI+6
	MOVE	3,USRPSI+7
	STIW
	 ERJMP	.+1
TOUSR6:	MOVE	1,FORK
	RFSTS			;GET PC
	MOVE	1,FORK
	CAMN	2,REALPC	;SAME AS IT WAS AT ENTRY?
	 RET			;YES, RFORK TO RESUME
	setz 2,			;flags (none) in AC2
	MOVE 3,realpc		;user PC in AC3
	XSFRK%			;[NIC254] set the PC
	  erjmp err		;[NIC254] oops
	move 2,realpc		;return the user's PC in AC2
	skipn debug
	  ret
	push p,w1
	push p,t
	hrroi w1,[asciz "D> Setting user PC to "]
	call type
	ldb t,[xpcbp realpc]
	call pad
	call crf
	pop p,t
	pop p,w1
	move 2,realpc
	ret

DDT:	SETZM	STRING		;GET COMMANDS FROM TTY, NOT STRING AT BPT
	CALL	CHKSYM		;INITIALIZE SYMBOL TABLE
	CALL	PGMST		;DO A $: IF POSSIBLE
	skipe showpc		;want to see where we are?
	  jrst [call reddt	;  yes, so show current pc.
		setzm showpc	;  only do this once
		jrst dd1.5]	;  then join common code
DD1:	CALL	CRF		;TYPE CAR.RET.  LINE FEED

;CARR. RET. ETC., COME BACK HERE
DD1.5:	TLZ	F,ROF		;CLOSE ANY OPEN REGISTER
DD1.6:	MOVE	T,[SCHM,,SCH]
	BLT	T,ODF		;LOAD MODE CONTROL SWITCHES
DD2:	TRZE	F,SUPTEM
	 MOVE	SCH,SCHSAV	;RESTORE IF SUPER-TEMPORARY MODE
	SETZM	PRNC		;PARENTHESES COUNT
	INTOFF			;SOME COMMANDS DO INTON
	MOVE	P,PS
	CALL	REMTBP		;REMOVE TEMPORARY BPTS (PUT IN FOR $^N)

;OPEN PAREN COMES BACK HERE
LIS:	MOVE	T,ESTU
	MOVEM	T,ESTUT		;INIT UNDEFINED SYM ASSEM
	MOVEI	1,.PRIIN
	RFMOD
	ANDCMI	2,17B23!3B25!3B29
	IORI	2,16B23!2B25!1B29	;DON'T AWAKEN ON ALPHA
	SFMOD
	TDZ	F,[777777-ROF-STF,,LF1+CF1+ITF+Q2F]

; < AND > COME BACK HERE
LIS0:	TDZ F,[-1-ROF-STF-FAF-SAF,,SEMIF!SEMIF2!NAF!CONDX!TEMF!TEM2F!INTFLG]
	SETZM	WRD

;SPACE AND , HERE
LIS1:	SETZM	FRASE

;+ - @ ETC. HERE
LIS2:	MOVEI	T,1
	MOVEM	T,FRASE1
	TLZ	F,MLF+DVF

;* / HERE
L1:	TLZ	F,CF+CCF+SF+FPF	;TURN OFF CONTROL, SYL, PERIOD FLAG
L1A:	SETZM	SYL		;NO SYL YET

;^ ETC. HERE
L1RPR:	SETZM	SYM
	MOVEI	T,6
	MOVEM	T,TEM		;INIT CHR PER SYMBOL COUNTER
	MOVE	T,[POINT 7,TXT]
	MOVEM	T,CHP		;SETUP FOR OPEVAL SYMBOL
	SETZM	TXT
	SETZM	TXT+1		;TO KEEP JSYS LOOKUP HAPPY
	SETZM	DEN		;DECIMAL NUMBER ACCUMULATOR
	SETZM	WRD2		;NUMBER TO RIGHT OF $ IN COMMAND
	MOVE	T,[POINT 7,STRBUF-1,34]
	MOVEM	T,STRIP
	MOVEM	T,STROP		;INIT ATOM BUFFER POINTERS

;NUMBERS, LETTERS COME BACK HERE FOR MORE OF SYMBOL
L2:	MOVE	1,[.TICCT,,1]	;^T TO CHANNEL 1
	ATI
	call escoff		;disable escape code
	CALL TIN		;PICK UP CHARACTER
LZ:	call escon		;enable escape code
	uppercase(t)		;CHANGE LOWER CASE TO UPPER CASE
	TRNN	F,SEMIF		;SEMICOLON CONTROL, OR...
	 TLNE	F,CF		;ALT. MODE CONTROL FLAG?
	  JRST	L21		;CONTROL
	CAIG	T,"Z"		;Z
	 CAIGE	T,"A"		;A
	  JRST	L21		;NOT A LETTER
	JRST	LET

;CONTROL OR NOT-LETTER
L21:	CAILE T,delete		;Reasonable character?  In range of dispatch
	  JRST ERR		;  Table?  Nope.
	caie t,";"		;semi and
	  cain t,esc		;  escape are special, they're
	    jrst l21a		;    always commands.
	tlne f,quesf		;want documentation on this command?
	  jrst doccmd		;  yes, do document that command
l21a:	HRRZ W,DISP(T)		;Assume char or $char (RH) dispatch
	TRNE F,SEMIF		;Semi-char?
	  HLRZ W,DISP(T)	;  Yes, so use LH dispatch.
	CAIGE W,MULT		;This routine evaluate its arg?
	  JRST (W)		;  Nope, no eval, just do it.
	MOVE T,SYL
	TLZN F,LTF
	  JRST POWER
	CAIN W,40		;IS TERMINATOR A SPACE?
	 SKIPE WRD		;AND WORD SO FAR ZERO?
	  SKIPA	T,[OPEVAL,,EVAL];NO, SEARCH EVAL 1ST
	   MOVS	T,[OPEVAL,,EVAL];YES, DO OP SEARCH
	MOVEM T,TEM1
	JRST L213

L212:	HLRZS	T,TEM1		;GET ADDRESS OF THE OTHER LOOKUP ROUTINE
	JUMPE	T,UND1		;IF ADR=0, THEN SYMBOL UNDEFINED
L213:	CALL	(T)		;CALL OPEVAL OR EVAL
	 JRST	L212		;SYMBOL NOT FOUND
	CAIN W,ASSEM		;DEFINED SYMBOL FOLLOWED BY #?
	 JRST	ERR

;EXPONENT ROUTINE COMES BACK HERE
L4:	TLZE	F,MF
	 MOVN	T,T
	TLNN	F,SF
	 CAIE	W,LPRN
	  SKIPA
	   JRST	LPRN
	EXCH	T,FRASE1
	TLNN	F,DVF
	 IMULB	T,FRASE1
	TLZE	F,DVF
	 IDIVB	T,FRASE1
	CAIGE	W,ASSEM
	  JRST	(W)		;MULTIPLY OR DIVIDE
	ADDB	T,FRASE
	CAIGE	W,SPACE
	 JRST	(W)		; + - @ ,
	ADD	T,WRD
	TLNE	F,TIF		;TRUNCATE INDICATOR FLAG
	 HLL	T,WRD		;TRUNCATE
	MOVEM	T,WRD
	TLNN	F,QF
	 MOVE	T,LWT
	SETZM	R
	MOVE	W1,ESTUT	;W1 IS USED IN DEPRA
	CAMN	W1,ESTU
	 JRST	L5
	CAILE	W,CARR
	 JRST	ERR
L5:	CAIG	W,RPRN
	 JRST	(W)
	PUSH	P,[JRST RETX]
	SKIPN	PRNC
	 JRST	(W)

;GIVE GENERALIZED ERROR COMMENT

PANERR:	JFCL			;So PANERR will be different than ERR - see
ERR:	SETZM	STRING		;the commands by CHNTAB.
	SETZM	BBC		;KILL THE BUFFERED CHARACTER IF AN ERROR
	MOVEI	W1,"?"
	JRST	WRONG1

;Fatal JSYS error (while getting file to ;Yank, etc)

JERR:	SETZM STRING
	SETZM BBC
	CALL TERPRI
	CALL BARF
	JRST WRONG2

;UNDEFINED SYMBOL TYPED.

UNDEF:	MOVE W1,[ascii " ?U?"]
	JRST WRONG1

;RUBOUT FROM INSIDE IDDT.  REENTER IDDT AT WRONG

RENWRG:	MOVEI	1,.PRIIN
	CFIBF
	MOVEI	1,.PRIOU
	CFOBF
IFE KL20F,<
	MOVEI 1,WRONG
	MOVEM	1,IPC2
	DEBRK
>;IFE KL20F
IFN KL20F,<
	cis
>;IFN KL20F

WRONG:	MOVE	W1,[ASCII / XXX/]
WRONG1:	MOVE	P,PS
	CALL	TEXT
WRONG2:	TLNN	F,ROF		;REG OPEN?
	  JRST	DD1		;NO, CR AND RESET

;COMMON RETURN
RETX:	MOVE	P,PS
	CALL	LCT		;COMMON RETURN FOR TAB;,JRST LIS
	JRST	DD2

UND1:	MOVE	R,ESTUT		;UNDEFINED SYM ASSEMBLER
	JUMPE	R,UNDEF		;UNDEFINED IF NO UNDEF TAB
	HLRE	S,ESTUT
	ASH	S,-1		;SETUP EVAL END TEST
	HRLOI	W1,37777+DELI+LOCAL
	CALL	EVAL2
	CAIN	W,ASSEM
	 TLNN	F,ROF
	  JRST	UNDEF
	SKIPE	PRNC
	 JRST	UNDEF
	MOVEI	T,"#"
	CAIE	W,ASSEM
	 CALL	TOUT
	MOVN	R,[2,,2]
	ADDB	R,ESTUT
	MOVE	T,SYM
	TLO	T,GLOBAL
	MOVEM	T,(R)
	move t,lloco		;[NIC250]
	TLNE	F,MF
	 TLO	T,(STNEG)	;SET FLAG TO SHOW SUBTRACTIVE REQUEST
	TLO	T,(STADD)	;SET FLAG TO SHOW UNCHAINED REQUEST
	MOVEM	T,1(R)
	MOVEI	T,0
	JRST	L4

; ? COMMAND

	block 5
	[asciz ";?	types the text for the last error the process got.
n;?	types the text for error number 600000+n"]
	block 2			;no $? or $$?
	[asciz "[sym]?	if no symbol is specified, lists all undefined symbols, else just
	the named one."]

QUESTN:	CALL	CRF		;LIST UNDEFINED SYMBOLS
	INTON
	TLNE	F,LTF		;HAS A SYMBOL BEEN TYPED?
	  JRST	QLIST		;NO
	MOVE	R,ESTU
QUEST1:	JUMPGE	R,DD1
	MOVE	T, (R)
	SKIPA	W1,ESTU
QUEST2:	  ADD	W1,[2,,2]
	CAME	T,(W1)
	  JRST	QUEST2
	CAME	R,W1
	  JRST	QUEST4
	CALL	SPT
	CALL	CRF
QUEST4:	ADD	R,[2,,2]
	JRST	QUEST1

QLIST:	HLRE	S,SYMPTR
	ASH	S,-1		;NUMBER OF ENTRIES
	SKIPL	R,SYMPTR
	  JRST	RETX		;NO SYM TAB
QLIST1:	SETZM	QLPNT		;SAY NO REFERENCE YET
QLIST2:	MOVE	T,(R)		;GET SYM
	TLZN	T,PNAME		;A PROG NAME?
	  JRST	QLIST6		;YES
	CAMN	T,SYM		;NO, IS AN OCCURANCE FOUND?
	  HRRZM	R,QLPNT		;YES, REMEMBER WHERE
QLIST3:	AOBJN	R,.+1		;MOVE TO NEXT TAB ENTRY
	AOBJN	R,QLIST4	;END OF TABLE?
	MOVE	R,SYMPTR	;YES RING PTR
QLIST4:	AOJLE	S,QLIST2	;DONE ALL SYMS?
	JRST	DD1		;YES

QLIST6:	SKIPN	QLPNT		;FOUND THE SYM?
	  JRST	QLIST3		;NO, KEEP LOOKING
	CALL	SPT1		;PRINT PROGRAM NAME
	MOVE	T,@QLPNT	;GET SYM BACK
	TLNN	T,GLOBAL
	  JRST	QLIST7		;NOT GLOBAL
	CALL	TSPC		;TYPE SPACE AND G
	MOVEI	T,"G"
	CALL	TOUT
QLIST7:	CALL	CRF
	SETZM	QLPNT	;RESET FIND FLG
	JRST	QLIST3	;RESUME SEARCH

;DIGITS, ADD IN TO OCTAL
;ACCUMULATOR (SYL), FLOATING NUM (FH,SYL)
;AND DECIMAL NUMBER (DEN), THEN HANDLE AS A LETTER

	block 9			;not real command characters, so no help

NUM:	ANDI	T,17		;T HOLDS CHARACTER
	TLNE	F,CF+FPF	;$ TYPED OR EXPONENT
	  JRST	NM1		;FORM WRD2
	MOVE	W,SYL
	LSH	W,3
	ADD	W,T
	MOVEM	W,SYL
	MOVE	W,DEN
	IMULI	W,^d10		;CONVERT TO DECIMAL
	ADD	W,T
	MOVEM	W,DEN
	AOJA	T,LE1A

; $ SIGN

	block 8
	[asciz "$	is a symbol component, not a command.  it is included in the symbol
	currently being typed in."]

DOLLAR:	movei T,46+"A"-13	;RADIX 50 $ TO BE
	jrst let

; % sign

	block 8
	[asciz "%	is a symbol component, not a command.  it is included in the symbol
	currently being typed in."]

PERC:	MOVEI T,47+"A"-13	;PERCENT SIGN
	jrst let

;LETTERS, ADD IN TO SYMBOL (SYM) BEING TYPED IN

	block 9			;not real command characters, so no help

LET:	TLC	F,SF+FPF	;EXPONENT IFF LTF'*FEF'*(T=105)*SF*FPF=1
let0:	TLZN	F,LTF+FEF+SF+FPF
	CAIE	T,"E"
	 TLOA	F,LTF
	  TLOA	F,FEF
	   JRST	LET1
	TLZN	F,MF
	 SKIPA	W1,SYL
	  MOVN	W1,SYL
	MOVEM	W1,FSV
	SETZM	DEN
LET1:	SUBI	T,"A"-13		;FORM RADIX 50 SYMBOL
LE1A:	TLO	F,SF+QF

;PACK CHARACTER INTO SYM
LE2:	MOVE	W,SYM
	MOVEI	R,"A"-13(T)
	IMULI	W,50		;CONVERT TO RADIX 50
	ADD	W,T
	SOSGE	TEM		;IGNORE CHARACS AFTER 6
	  JRST	L2
	MOVEM	W,SYM
	IDPB	R,CHP
	JRST	L2

;FORM NUMBER AFTER $
NUM1:	EXCH	T,WRD2
	IMULI	T,^d10
	ADDM	T,WRD2
	TRO	F,Q2F
	JRST	L2

NM1:	TLNE	F,CF
	  JRST	NUM1
	MOVEI	W1,6		;FORM FLOATING POINT NUMBER
	AOS	W2,NPWR10	;GET THE NEGATIVE POWER OF TEN
	MOVSI	R,(1.0)
NM1A:	TRZE	W2,1
	  FMPR	R,FT(W1)
	JUMPE	W2,NM1B
	LSH	W2,-1
	SOJG	W1,NM1A
NM1B:	MOVSI	W1,211000(T)	;UNNORMALIZED FP VALUE OF DIGIT
	FMPR	R,W1		;COMPUTE VALUE OF NEW DIGIT
	FADRB	R,FH		;ADD VALUE INTO FLOATING NO.
	MOVEM	R,SYL
	AOJA	T,LE1A

;THIS SEQUENCE INITIALIZES THE SYM TAB LOGIC

CHKSYM:	HLRZ	T,ESTU
	SUB	T,ESTU
	MOVE	W,SYMPTR
	ADD	T,W		;IF THE TOP OF THE UNDEFINED SYM TAB DOES
	TRNE	T,-1		; NOT POINT TO BOTTOM OF REGULAR SYM TAB,THEN
	  HRRZM	W,ESTU		; RE-INIT UNDEFINED SYM TABLE POINTER, ESTU.
	MOVE	T,PRGM
	SUB	T,W		;IF THE SYM TABLE PNTR AND THE PROGRAM
	TSC	T,T		; NAME (PRGM) PNTR DO NOT END UP IN THE
	MOVE	W1,PRGM		; SAME PLACE, OR THEY DO NOT BOTH START ON
	XOR	W1,W		; AN EVEN (OR BOTH ON ODD) LOCATION, OR
	TRNN	W1,1		; PRGM .GE. 0, THEN RE-INIT PRGM.
	  JUMPE	T,CHKSY0
	SETZM	PRGM
	SETZM	BLOCK		;RESET WORLD

;SETUP $X LOCATION FROM DEFINITION OF PAT..

CHKSY0:	MOVE	S,SYMPTR	;SEARCH LOW TO HIGH.  PAT.. IS 1ST!
CHKSY1:	MOVE	T,0(S)		;GET A SYMBOL
	AOBJN	S,.+1		;BUMP POINTER TO VALUE
	XOR T,[RADIX50 4,PAT..]	;WHAT WE ARE LOOKING FOR
	TDNE T,[177777,,777777]	;BITS WHICH MATTER
	  AOBJN	S,CHKSY1	;NO MATCH.  TRY NEXT SYM.
	SKIPGE	S		;DID WE FIND IT?
	 SKIPA	T,0(S)		;YES.  GET THE VALUE
	  MOVEI	T,20		;NO. DEFAULT $X LOCATION
	HRRZM	T,XRG		;WHERE $X WILL BE DONE. (PATCHES TOO)
	RET

;AUTOMATIC $: FOR PROGRAM CONTAINING THE START ADDRESS

PGMST:	MOVE	1,FORK
	GEVEC
	JUMPE	2,CPOPJ		;NO ENTRY VECTOR
	HRRZ	W,2		;SA
	SKIPL	PRGM		;DON'T IF ALREADY SET
	 SKIPL	R,SYMPTR	;OR IF NO SYMTAB
	  RET
	MOVSI	T,1		;BIG NUMBER
	JRST	PGMS19

PGMST0:	MOVE	T,0(R)		;GET ENTRY
	TLNE	T,(17B3)	;PROGRAM NAME?
	  JRST	PGMST2		;  NO, SKIP IT
PGMST1:	HRRZ	T,1(R)		;LOW BREAK
	SUB	T,W		;COMPARE WITH SA
	MOVN	T,T		;Make sign right.
	JUMPL	T,PGMST2	;THIS PRGM'S BRK IS BELOW THE SA
	CAML	T,TEM		;BREAK CLOSER THAN LAST ONE?
	  JRST	PGMST2		;NO
	MOVEM	R,PRGM		;CURRENT BEST PROGRAM
PGMS19:	MOVEM	T,TEM		;CUNNENT BEST DISTANCE
PGMST2:	AOBJN	R,.+1
	AOBJN	R,PGMST0	;TRY NEXT ENTRY
	SETZM	BLOCK
	SKIPL	R,PRGM		;DID IT GET SET?
	 RET			;  nope, sorry.
	MOVE	T,0(R)		;THE PROGRAM NAME
	MOVEM	T,SYM		;SETUP FOR SB1
	CALL	SB1		;LOOK FOR BLK NAME = PRGM NAME
	 RET			;  NONE (UGH! EVAL WILL LOOP AROUND EV2B)
	MOVEM	R,BLOCK		;DO  $&  TOO
	RET

POWER:	TLNN	F,FEF
	  JRST	L4		;NO EXPONENT
	CAIE	W,PLUS
	 CAIN	W,MINUS
	  TROE	F,POWF
	 TRZA	F,POWF
	  JRST	(W)		; E+-
	MOVE	W2,DEN
	SETZM	FRASE
	MOVEI	W1,FT-1
	TLZE	F,MF
	  MOVEI	W1,FT01
	SKIPA	T,FSV
POW2:	  LSH	W2,-1
	TRZE	W2,1
	  FMPR	T,(W1)
	JUMPE	W2,L4
	SOJA	W1,POW2

; . command

	block 7
	[asciz "$.	meta-dot is a copy of the process' PC which you are debugging."]
	[asciz ".	dot immediately following a numeric argument says that the number
	is decimal, not octal (10=10, but 10.=12).  Dot by itself is the
	address of the last location opened."]

PERIOD:	MOVE	T,DEN		;VALUE OF DECIMAL NUMBER
	TLNE	F,SF		;SYLLABLE STARTED?
	 JRST	PERIO2		;YES, TAKE AS DECIMAL NUMBER
	MOVE	T,LLOC		; VALUE OF "." IN CURRENT SEQUENCE
	TLZE	F,CF!CCF	;IF $ OR $$ THEN USE PC
	  ldb t,[XPCBP pc]
	TLNN	T,(DDTINT)	; "." INTERNAL TO IDDT?
	 JRST	PERIO2		;NO
	TROE	F,INTFLG	;SAY THIS EXPR IS INTERNAL
	 JRST	ERR		;INTERNAL ARITHMETIC
PERIO2:	MOVEM	T,SYL
	TLNE	F,FPF		;HAS A PERIOD BEEN SEEN BEFORE?
	  TLO	F,LTF		;YES, TWO PERIODS MAKES A SYMBOL
	TLON	F,FPF+SF+QF
	  MOVEI	T,0
	IDIVI	T,400
	SKIPE	T
	  TLC	T,243000
	TLC	W1,233000
	FAD	T,[0]		;NORMALIZE T AND W1
	FAD	W1,[0]
	FADR	T,W1
	MOVEM	T,FH
	SETZM	NPWR10		;NUM OF DIGITS PASSED THE DEC. PT.
	MOVEI	T,45		;RADIX 50 PERIOD
	JRST	LE2		;PROCESS AS SYMBOL CONSTITUENT

; $Q  VALUE OF LAST THING TYPED BY IDDT OR USER

	block 6
	[asciz "$$Q	is $Q with its halves swapped."]
	[asciz "$Q	is the value of the last thing typed by IDDT or you."]
	0			;there is no "Q" command

QUAN:	TLNN	F,CCF
	 SKIPA	T,LWT		;$Q, GET LAST WORD TYPED
	  MOVS	T,LWT		;$$Q, GET IT SWAPPED
	JRST	QUAN1

;$V  LEFT HALF --  $$V TO GET SIGN EXTENDED

	block 5
	[asciz "n;V	Has ^T display the contents of location n."]
	[asciz "$$V	is the left half of $Q, sign-extended."]
	[asciz "$V	is the left half of $Q."]
	0			;there is no "V" command

LEFT:	HLRE	T,LWT
	TLNN	F,CCF
	 HRRZS	T
	JRST	QUAN1

;HERE TO EXAMINE AN INTERNAL REGISTER -- READ SIXBIT NAME AND LOOKUP
INTSYM:	TRZ	F,SEMIF!SEMIF2	;CLEAR SEMICOLON TYPED FLAGS
	MOVEI	W1,6		;ALLOW SIX CHARACTERS
	PUSH	P,[0]		;BUILD SIXBIT ON TOP OF STACK
	MOVE	W2,[POINT 6,(P)]
INTSY2:	CALL	TIN
	MOVEM	T,BBC		;SAVE BUFFERED-BACK CHARACTER
	uppercase(t)
	CAIL	T,"A"		;MUST BE ALPHABETIC
	 CAILE	T,"Z"
	  JRST	INTSY1		;NOT, SO TRY NUMERIC
INTSY3:	SUBI	T," "		;MAKE SIXBIT
	SETZM	BBC		;NO LONGER BUFFERED, WE USED IT
	SOJL	W1,INTSY2	;ONLY PUT 6 CHARACTERS INTO T
	 IDPB	T,W2
	JRST	INTSY2	
INTSY1:	CAIL	T,"0"
	 CAILE	T,"9"		;NUMERIC?
	  SKIPA
	   JRST	INTSY3		;YES, SO BUILD UP MORE SIXBIT
	SETZI	W1,
	POP	P,T		;GET SIXBIT
	 JUMPE	T,INTXIT	;NULL, SO RETURN 0
	MOVEI	W2,INSYMB	;GET START OF INTERNAL SYMBOL TABLE
INTSY4:	HLRZ	TT,(W2)		;THE POINTER TO THE SIXBIT
	CAMN	T,(TT)		;MATCH THIS INTERNAL SYMBOL?
	 JRST	INTXI1		;YUP, READ VALUE AND MAKE INTERNAL
	CAIGE	W2,INSYME	;DONE WITH TABLE?
	 AOJA	W2,INTSY4	;NOPE, TRY NEXT ENTRY
	JRST	ERR		;ELSE SYMBOL NOT FOUND

INTXI1:	HRRZ	T,(W2)		;PICK UP SYMBOL'S VALUE
INTXIT:

;;; FALL INTO QUANIN

;;; FALL IN FROM INTSYM

;HERE TO EXAMINE INTERNAL REGISTER
;ADDRESS OF IT IN T
;USED BY $G  $X  ETC.
QUANIN:	TLO	T,(DDTINT)	;MARK FOR ADR INTERNAL TO DDT
	TROE	F,INTFLG	;DOES EXPR ALREADY CONTAIN INT SYM?
	 JRST	ERR		;YES.
	MOVEI	W,1
	MOVEM	W,FRASE1
QUAN1:	MOVEM	T,SYL
QUAN2:	TLO	F,SF+QF		;WRD,SYL STARTED
	TLZ	F,CF+CCF
	  JRST	L2

; ^_ - set the flag saying you want help on this command, not do the
; command itself

	block 7
	[asciz "$^_	does apropos lookup on the internal command documentation.  You are
	prompted for a string, and all commands which have that string in
	their documentation are displayed."]
	[asciz "
^_	followed by an IDDT command documents that command.  For a vanilla
	form (unmodified by ;'s or $'s) all variations of the command are
	also shown.  Note that '$' is the escape character, not a dollar sign.
^_sym	does apropos lookup on sym (a regular symbol).  This is just shorthand
	for $^_sym.  The long form reads real text, tho, so it can include
	funny characters that ^_sym can't."]

help:	tlne f,cf		;is this meta-help?
	  jrst apropos		;  yes, that's apropos
	tlo f,quesf		;flag to display help on command, not do it
	jrst contr1

; ; TYPED

	block 8
	[asciz ";	is a modifier for other IDDT commands, it has no meaning in and
	of itself."]

SEMIC:	TROE	F,SEMIF		;SEEN ONE ALREADY?
	 TRO	F,SEMIF2	;YES
	JRST	CONTR1

; $ TYPED

	block 8
	[asciz "^[	is a modifier for other IDDT commands; it has no meaning in and
	of itself."]

CONTROL:
	TLOE	F,CF		;HAVE ALREADY SEEN ONE?
	 TLO	F,CCF		;YES
CONTR1:	PUSH	P,2
	MOVEI	1,.PRIIN
	RFMOD
	IORI	2,17B23		;WAKEUP ON EVERYTHING
	SFMOD
	POP	P,2
	JRST	L2

;BIT 40 - DELETE OUTPUT
;    20 - DELETE INPUT
;    10 - LOCAL
;    04 - GLOBAL
;    00 - PROGRAM NAME (no bits set)
;    14 - LOCAL+GLOBAL - block name, value is block level
;S is -number of symbols left to be considered
;R is current sym tab pointer
;SYM has symbol being looked up
;W1 has code bits which will cause the current entry to be skipped over
;PRGM is 0 or pointer to current program's symbols
;BLOCK is 0 or pointer to current block's symbols
;TMPBLK is the temporary block pointer (set with blk|sym) if not 0
;BLVL is the highest level block already scanned

;LOOKUP LOCAL IN THIS PROGRAM, OR ELSE GLOBAL ANYWHERE
;FOR PURPOSE OF KILLING ($$K) A SYMBOL

EVAL0:	HRLOI	W1,37777+DELI	;IGNORE HALF-KILLED SYMBOLS
	HLRE	S,SYMPTR
	ASH	S,-1		;SETUP END TEST (- NUM OF ENTRIES IN TABLE)
	JRST	EVAL3

EVAL1:	ADD	R,[2,,2]
EVAL2:	SKIPL	R
	 MOVE	R,SYMPTR
	AOJG	S,CPOPJ		;TRANSFER IF NO SYMBOL FOUND
EVAL3:	MOVE	T,(R)
	XOR	T,SYM
	TLNN	T,PNAME		;WHEN PROGRAM NAME ENCOUNTERD,...
	 TLOA	W1,LOCAL	; STOP LOOKING AT LOCAL SYMS
	  TDNE	T,W1		;REJECT THIS ENTRY?
	   JRST	EVAL1		;YES, WRONG TYPE OR NAME DOESN'T MATCH
	TLNN	T,340000	;IS THIS ENTRY DELETED?
	 JRST	EVAL1		;YES. FORGET IT
	MOVE	T,1(R)		;GET DEFINITION
CPOPJ1:	AOS	(P)		;FOUND SYMBOL, SKIP
CPOPJ:	RET

;MAIN SYMBOL LOOKUP.

EVAL:	SETZM MONLUK
	MOVE T,SYMPTR
	MOVEM T,EVPTR
	CALL EVALA		;SEARCH UP THE SYMBOL TREE
	  SKIPA			; Not found, try monitor symbols.
	    JRST CPOPJ1		;  FOUND, SKIP.
	CALL EV9	  	;NOT FOUND. SEARCH WHOLE TREE
	  SKIPA			; Not found
	    JRST CPOPJ1		;  Found
	SETOM MONLUK
	MOVE T,MONPTR		;Search up Monitor symbols now
	MOVEM T,EVPTR
	CALL EVALA
	  RET
	JRST CPOPJ1

;SCAN UP THE SYMBOL TREE.
;DON'T CONSIDER SYMBOLS IN BLOCKS ON SAME OR DEEPER LEVELS.

EVALA:	MOVSI	W1,DELI		;IGNORE HALF-KILLED SYMS
	HLRE	S,EVPTR
	ASH	S,-1		;END CHK.  - # OF TAB ENTRIES
	SKIPE MONLUK		;monitor mode lookup?
	  JRST EV5		;  yes.
	SKIPL	R,tmpblk	;temporary block?
	  JRST [skipl r,block	;  no.  is there a permanent block?
		  jrst ev5	;    nope, not either.
		jrst ev3]	;  yes, use it.
	SETZM	tmpblk		;yes, have the pointer in r, reset tmp block.
	MOVE	T,1(R)		;GET LEVEL FROM DEF OF CURRENT BLOCK
	MOVEM	T,BLVL		;BLKS DEEPER THAN BLVL WON'T BE CONSIDERED
	JRST	EV1		;START SCAN WITH THIS BLOCK'S SYMS

EV3:	CAMN	R,EVPTR		;JUST CHECKED LOWEST ENTRY?
	  JRST	EV4		;YES, RING R TO TOP AND CONTINUE
	AOJGE	S,CPOPJ		;NOTHING FOUND IF ALL ENTRIES SCANNED

;MAIN LOOP
EV1:	SUB	R,[2,,2]	;MOVE TO NEXT ENTRY
	MOVE	T,(R)		;GET NAME AND TYPE
	TDNE	T,W1		;TEST TYPE BITS
	  JRST	EV3		;THIS TYPE BEING REJECTED
	LDB T,[POINT 4,(R),3]	;GET TYPE BITS
	CAIN	T,3
	  JRST	EV2		;BLOCK NAME
	SKIPN	T		;PROGRAM NAME?
	 TLOA	W1,LOCAL	;YES. START REJECTING LOCALS
	  SKIPA	T,(R)		;RESTORE T IF NOT PRGM NAME
	   JRST	EV3		;RESUME SCAN AFTER PROGRAM NAME
	XOR	T,SYM		;SEE IF ENTRY MATCHES KEY
	TLZ	T,740000	;FLUSH TYPE BITS FROM CONSIDERATION
	JUMPN	T,EV3		;NO MATCH. KEEP LOOKING
	MOVE	T,1(R)		;GET DEFINITION
	JRST	CPOPJ1		;SKIP.

;SCAN HIT BOTTOM OF TABLE, RING TO TOP
EV4:	HLRE	R,EVPTR
	MOVNS	R		;GET POSITIVE LENGTH
	ADD	R,EVPTR		;ONE ENTRY PASSED TOP
	AOJL	S,EV1		;KEEP SCANNING IF ALL NOT CHECKED
	RET			;NOT FOUND

;BLOCK NAME ENCOUNTERED
EV2:	MOVE	T,1(R)		;DEF. IS LEVEL OF NEW BLOCK'S SYMBOLS
	CAMGE	T,BLVL		;LEVEL < LEVELS ALREADY CONSIDERED?
	  JRST [movem t,blvl	;YES. SCAN THEM.  save level of enclosing
		jrst ev3]	;block so no deeper blocks will be scanned.
EV2B:	SUB	R,[2,,2]	;NO. SKIP OVER THIS BLOCK
	ADDI	S,1		;LOOK FOR ANOTHER BLK WHICH ENCLOSES THIS ONE
	LDB T,[POINT 4,(R),3]
	CAIE	T,3
	  JRST	EV2B		;NOT A BLOCK NAME. KEEP LOOKING
	JRST	EV2		;BLOCK NAME. CHECK ITS LEVEL

;Here when EVALA called and no current TMPBLK or BLOCK

EV5:	MOVEI	T,1
	MOVEM	T,BLVL		;SET LEVEL TO 1 (MAIN)
	SKIPN MONLUK
	 SKIPL R,PRGM		;IS THERE A PRGM SET?
	  SKIPA
	   JRST EV1		;YES, SEARCH ITS SYMBOLS,ALL LEVELS
	HLRE	R,EVPTR		;RESET R TO TOP OF TAB
	MOVNS	R
	ADD	R,EVPTR
	JRST	EV1

;SCAN WHOLE SYMBOL TREE LOOKING FOR PROGRAM AND BLOCK WHICH CONTAIN SYMBOL.
;TYPE PROGRAM AND BLOCK IF APPROPRIATE.

EV9:	SETZM	SVTB
	SETZM	SVFB
	SETOM	SVF		;INDICATE NO MATCH FOUND YET
	HLRE	T,SYMPTR
	JUMPGE	T,CPOPJ		; EMPTY SYMBOL TABLE
	MOVNS	T
	ADD	T,SYMPTR
	HRRZ	R,T		;R POINTS AT END OF TABLE + 2
EV9A:	SUB	R,[2,,2]	;MOVE DOWN ONE ENTRY
	CAMN	R,SYMPTR	;LOOKING AT BOTTOM ENTRY?
	 JRST	EV9B		;  YES
	LDB T,[POINT 4,(R),3]	;GET TYPE BITS
	CAIN	T,3
	 JRST	EV9C		;BLOCK NAME
	CAIN	T,0
	 JRST	EV9D		;PROGRAM NAME
	TRNE	T,4
	 JRST	EV9A		;DELETED, IGNORE
	MOVE	T,(R)
	XOR	T,SYM
	TLZ	T,740000	;FLUSH TYPE BITS FROM CONSIDERATION
	JUMPN	T,EV9A		;DOESNT MATCH KEY, TRY NEXT
	AOSE	SVF		;IS THIS THE FIRST FIND?
	 JRST	EV9E		;NO
	MOVEM	R,BLVL		;YES. REMEMBER BLOCK LEVEL
	MOVE	T,1(R)
	MOVEM	T,SVBTS
	JRST	EV9A		;RESUME SCAN

;NOT FIRST MATCH
EV9E:	MOVE	T,1(R)
	CAME	T,SVBTS		;DEFINITION SAME AS FIRST MATCH?
	 RET			;NO, REPORT FAILURE
	SETZM	SVF		;MUST BE -1 OR 0 (0 FOR ON)
	JRST	EV9A		;RESUME SCAN

;BLOCK NAME ENCOUNTERED

EV9C:	SKIPN	SVF		;HAS A MATCH BEEN SEEN ALREADY?
	 JRST	EV9A		;YES, KEEP LOOKING
	MOVEM	R,SVFB		;NO, REMEMBER WHICH BLOCK WE'RE AT
	JRST	EV9A		;IN CASE WE GET A FIND IN THIS ONE

;PROGRAM NAME ENCOUNTERED

EV9D:	SKIPN	SVF		;HAS A MATCH BEENSEEN ALREADY?
	 JRST	EV9A		;YES. KEEP SCANNING
	MOVEM	R,SVTB		;NO. REMEMBER IN CASE MATCH IS FOUND
	SETZM	SVFB		;NEW PRGM. DON'T KNOW BLK YET
	JRST	EV9A		;KEEP SCANNING

;SCAN HIT BOTTOM ENTRY IN TABLE

EV9B:	SKIPE	SVF		;MATCH FOUND?
	 RET			;  NO. REPORT FAILURE
	AOS	(P)		;SET FOR SKIP RETURN
	call tspc		;space over one for readabilities sake
	SKIPE	R,SVTB		;DO WE HAVE A PRGM NAME,
	 CAMN	R,PRGM		;AND IS IT SAME AS CURRENT ONE?
	  JRST [MOVE W1,BLVL
		CALL SPT0	;YES. DON'T BOTHER PRINTING PRGM NAME
		jrst ev9b2]
	MOVE	T,(R)		;FROM NOW ON WHEN WE TYPE FOO$:, WE DO IT TOO!
	PUSH	P,R
	CALL	SPT1		;type the new program-name
	MOVSI T+1,(ASCIZ /$:/)
	CALL	TEXT2
	POP	P,R
	CALL	SSBLK		;set program symbol block now
EV9B2:	call tspc		;more readability
	MOVE	R,BLVL		;RETURN WHERE IN TABLE
	MOVE	T,1(R)		;AND VALUE
	RET

;COME HERE TO DO A $: WHEN A SYMBOL IS NOT IN THE CURRENT BLOCK

SSBLK:	MOVE	T,(R)
	MOVEM	T,SYM
	MOVE	R,SYMPTR	;SET PROGRAM NAME - DOLLAR COLON
SSET1:	JUMPGE	R,UNDEF
	MOVE	T,(R)
	CAMN	T,SYM
	 JRST	SSET2
	ADD	R,[2,,2]
	JRST	SSET1

SSET2:	MOVEM	R,PRGM
	SETZM	BLOCK
	CALL	SB1
	 CAIA
	MOVEM	R,BLOCK
	POPJ	P,

; document a command.  get here with T containing the command character
; to be documented.  F has whatever modifier flags, CF, CCF, etc.
;
; documentation for a command is a series of 9 locations before the first
; word of a commands code, as pointed to by the DISP table.  the order of
; the command-string pointers (bare address only) is:
;
;     offset   semis   escs	e.g.
;	-9	;;	$$	$$;;a
;	-8	;;	$	$;;a
;	-7	;;	-	;;a
;	-6	;	$$	$$;a
;	-5	;	$	$;a
;	-4	;	-	;a
;	-3	-	$$	$$a
;	-2	-	$	$a
;	-1	-	-	a
;	DISP ->	first word of code for command
;

doccmd:	hrrz tt1,disp(t)	;address of start of command's code
	cain tt1,err		;unknown commands jump to ERR
	  jrst [call terpri
		hrroi w1,[asciz "No such command."]
		call type
		jrst dd1]
	call crf		;get to a new line
	subi tt1,1		;word before has doc for root command
	trne f,semif2		; ;; version?
	  jrst [subi tt1,6	;   yes, find right position
		jrst doccm0]
	trne f,semif		; ; version?
	  subi tt1,3		;   likewise
doccm0:	tlne f,ccf		; $$ version?
	  jrst [subi tt1,2	;   uh huh
		jrst doccm1]
	tlne f,cf		; $ version?
	  subi tt1,1		;  think this will work?
doccm1:	cain tt1,carr-1		;if not vanilla ^M
	  tlnn f,qf		;  or no symbol typed
	    skipa		;    then just do regular command help
	   jrst assapr		; else do apropos on the symbol
	skipn w1,(tt1)		;see if there's help for that.
	  jrst [call terpri
		hrroi w1,[asciz "No help for that."]
		call type
		jrst dd1]
	inton			;let this be interruptable
	call type		;type it
	call crf		;then get to a new line
	tdne f,[cf+ccf,,semif+semif2]	;if no modifiers at all,
	  jrst dd1		;were, so showed what they asked for.
	movei tt2,^d8		;8 variants forms of command
help1:	subi tt1,1		;back up to previous form
	skipe w1,(tt1)		;anything?
	  jrst [call type	;  yes, so display this variant
		call crf	;  of the command, too.
		jrst .+1]
	sojg tt2,help1
help2:	jrst dd1		;and done

;;
;;	here when they did ^_sym<cr>
;;	we'll turn the symbol into text and do apropos on it
;;

assapr:	movei t,asapr0		;use this routine to for RADIX output
	movem t,sptsub		;this has the addr of output routine
	move tt,[440700,,jcl]	;turn it into text here
	move t,sym		;symbol user typed
	call spt1a		;output it to buffer
	setz t,			;make sure it's
	idpb t,tt		;asciz.
	jrst apro00		;go look it up now.

asapr0:	idpb t,tt		;given char in t, put it in buf pointed to
	ret			;by tt, then return into SPT

; $^_ command, apropos help

aprmpt:	asciz "apropos: "

apropos:call crf		;get to a new line
	hrroi w1,aprmpt
	call type		;type the prompt
	hrroi 1,jcl		;re-use the JCL buffer to hold target string
	MOVE 2,[RD%BEL!RD%CRF!RD%RND+jcllen*5-1]
	HRROI 3,aprmpt
	RDTTY			;get some text from the user
	  JRST JERR		;  oops
	TLNE 2,(RD%BFE)		;DELETED PAST START?
	  JRST WRONG		;  yes, so cancel command
	setz 2,			;let's clobber the trailing LF
	dpb 2,1			;to null, giving ASCIZ string.
apro00:	inton			;let this be interruptable
	move tt1,[-200,,disp]	;aobjn to DISPatch table for all commands
apro0:	hrrz tt2,(tt1)		;see if this command exists
	cain tt2,err		;commands jump to ERR if undefined
	  jrst apro3		;  no such command
	movei tt3,9		;this many total variations on command
apro1:	subi tt2,1		;back up to help word
	skipn w1,(tt2)		;there a help string here?
	  jrst apro2		;  nope, try next
	hrli w1,440700		;turn into BP to source string
	move w2,[440700,,jcl]	;BP to target string
	call substr		;see if W2 is a substring of W1
	  jrst apro2		;  no.
	hrro w1,(tt2)		;yes, it is.
	call type		;so display this match
	call crf		;and try the next
apro2:	sojg tt3,apro1		;try next command variant
apro3:	aobjn tt1,apro0		;then try next command
	jrst dd1		;then done

;; given a BP to a source string in W1 and a BP to a test string in W2, see
;; if the test string occurs in the target string, case insensitively.

substr:	movem w1,sorcbp
	movem w2,testbp

subst0:	ildb t,w2		;convert test string to all
	jumpe t,subst1		;hit end of string
	lowercase(t)		;lowercase, since most help text is
	dpb t,w2		;lowercase.   store char back...
	jrst subst0

subst1:	move w1,sorcbp
	move w2,testbp
subst2:	ildb t,w2		;get a test char
	ildb tt,w1		;get a source char
	jumpe t,cpopj1		;hit end of test string, so match
	jumpe tt,cpopj		;hit end of source string, so no match
	lowercase(tt)		;test string is already lower
	cain t,(tt)		;match?
	  jrst subst2		;  yes, keep at it.
subst3:	ibp sorcbp		;no match, try starting at next source pos
	jrst subst1		;go for it.

;;
;;	$nT output routines
;;

text36:	hrroi w1,[asciz /$36"/]
	CALL TYPE
	MOVE R,LLOC
TEXT37:	CALL FETCH
	  JRST TEXTL4
	JUMPE T,TEXTL4
	CALL UTOUT
	AOJA R,TEXT37

; ;" command

TEXTYP:	inton			;this could be long, make it interruptable
	hrroi w1,[asciz /$0"/]
	CALL	TYPE
	MOVE	R,LLOC
	PUSH	P,R
TEXTL1:	CALL	FETCH
	 JRST	TEXTL3
	MOVE	TT2,T
	MOVNI	W1,5
	MOVE TT1,[440700,,TT2]
TEXTL2:	ILDB	T,TT1
	JUMPE	T,TEXTL3
	CALL	TOUT
	AOJN	W1,TEXTL2
	AOS	R,(P)
	JRST	TEXTL1

TEXTL3:	POP	P,R
TEXTL4:	MOVEI	T,"$"
	CALL	TOUT
	JRST	RETX

TEXCHR:	MOVEI	R,CHRO
	JRST	TEXHER

TEXSQZ:	MOVEI	R,R50PNT
	JRST	TEXHER

TEXSIX:	SKIPA	R,[SIXBP]	;OUTPUT . IN SIXBIT
TEXASC:	 MOVEI	R,TEXTT		;OUTPUT . IN ASCII
TEXHER:	TRNE	F,SUPTEM
	 MOVEM	SCH,SCHSAV	;SUPER TEMPORARY. SO SAVE
	MOVEM	R,SCH
	MOVS	S,[SCHM,,SCH]	;MODE SWITCHES TO MEMORY
	TLNE	F,CCF
	 BLT	S,ODFM		;WITH $$, MAKE MODES PERMANENT
	TLO	F,QF
	MOVE	T,LLOC
	PUSH	P,[RETX]
	JRST	LI2A

CHRO:	hrroi w1,[asciz /$0#/]
	CALL	TYPE
	MOVE	R,LLOC
	CALL	FETCH
	 JRST	ERR
	CALL	UTOUT
	JRST	RETX

; # command

	block 6
	[asciz "$$#	sets the permanent typeout mode to low-byte ASCII typeout, then
	types out $Q (in that mode)."]
	[asciz "$#	sets the temporary typeout mode to low-byte ASCII typeout, then
	types out $Q (in that mode)."]
	[asciz "#	types out low order 7 bits of $Q as an ASCII character in the
	form $0#char."]

CHRI:	TRO	F,SUPTEM
	TLNN	F,CF
	 JRST	TEXCHR
	TRZ	F,SUPTEM
	TLNN	F,CCF
	 TRNN	F,Q2F
	  JRST	TEXCHR
	PUSH	P,[QUAN1]
	JRST	TEXI1

; & command

	block 6
	[asciz "$$&	sets the permanent typeout mode to RADIX 50, then retypes $Q."]
	[asciz "$&	sets the temporary typeout mode to RADIX 50, then retypes $Q."]
	[asciz "&	retypes $Q as RADIX 50."]

SQZI:	TRO	F,SUPTEM
	TLNN	F,CF		;NO $S TYPED. THIS IS SUPER TEMPORARY
	 JRST	TEXSQZ		;SO PRINT IT AND SET SUPTEM FLAG
	TRZ	F,SUPTEM	;NOT SUPER-TEMPORARY
	TLNN	F,CCF		;WAS IT $$&?
	 TRNN	F,Q2F		;WAS THERE A $& WITHOUT A NUMBER TYPED
	  JRST	TEXSQZ		;IF EITHER, GO AND TYPE IT
	PUSH	P,[SQZIN]
	JRST	TEXI1

; ' command

	block 6
	[asciz "$$'	sets the permanent typeout mode to sixbit, then retypes $Q."]
	[asciz "$'	sets the temporary typeout mode to sixbit, then retypes $Q."]
	[asciz "'	types out $Q as a sixbit word in the format $1'aaaaaa$ where aaaaaa
	are the sixbit characters."]

SIXI:	TRO	F,SUPTEM
	TLNN	F,CF		;NO $S TYPED. THIS IS SUPER TEMPORARY
	 JRST	TEXSIX		;SO PRINT IT AND SET SUPTEM FLAG
	TRZ	F,SUPTEM	;NOT SUPER-TEMPORARY
	TLNN	F,CCF		;WAS IT $$'?
	 TRNN	F,Q2F		;WAS THERE A $' WITHOUT A NUMBER TYPED
	  JRST	TEXSIX		;IF EITHER, GO AND TYPE IT
	PUSH	P,[SIXBIN]
	JRST	TEXI1

; " command

	block 6
	[asciz |$$"	sets the permanent typeout mode to 7-bit text, then retypes $Q.|]
	[asciz |$"	sets the temporary typeout mode to 7-bit text, then retypes $Q.|]
	[asciz |"	types out $Q as a 7-bit text word in the format $0"aaaaa$ where
	aaaaa is the actual text.|]

TEXI:	TRO	F,SUPTEM
	TLNN	F,CF		;NO $'S TYPED. THIS IS SUPER TEMPORARY
	 JRST	TEXASC		;SO PRINT IT AND SET SUPTEM FLAG
	TRZ	F,SUPTEM	;NOT SUPER-TEMPORARY
	TLNN	F,CCF		;WAS IT $$"?
	 TRNN	F,Q2F		;WAS THERE A $" WITHOUT A NUMBER TYPED
	  JRST	TEXASC		;IF EITHER, GO AND TYPE IT
	PUSH	P,[TEXI2+1]	;THIS MUST BE $0", SO GET INPUT
	SETZM	TXUPRW
	SETZM	TXQUOT
TEXI1:	PUSH	P,2
	INTON
	MOVEI	1,.PRIIN
	RFMOD
	IORI	2,17B23		;WAKEUP ON EVERYTHING
	SFMOD
	POP	P,2
	MOVEI	T,33
	MOVEM	T,SYL		;TERMINATE ON ALTMODE ALWAYS
	MOVEI	W1,5
	MOVEI	T-1,0
	CALL	TIN
	CAIN T,esc		;NEW ALT MODE, ESCAPE
	  JRST [MOVE W1,WRD2
		IORM W1,T
		SETZM WRD2
		JRST QUAN2]
	POP	P,A
	JRST	(A)

TEXI2:	CALL	TIN
	SKIPE	TXQUOT
	 JRST	TXQT
	CAMN	T,SYL
	 JRST	TEXI3
	SKIPE	TXUPRW
 	 JRST TXUPR  
	CAIN T,"Q"-100
	  JRST [SETOM TXQUOT
		JRST TEXI2]
	CAIN T,"^"
	  JRST [SETOM TXUPRW
		JRST TEXI2]
TEXI2A:	ROT T,-7
	LSHC T-1,7
	SOJG W1,TEXI2
	MOVE T,WRD2
	IORM T,W		; SET BIT
	CALL TEXDEP		; DEPOSIT THIS WORD OF TEXT
	JRST TEXI2+1		; AND CONTINUE

TEXI3:	LSHC T-1,-43
	JUMPLE W1,[MOVE W1,WRD2
		   IORM W1,T
		   SETZM WRD2
		   JRST QUAN1]
	LSH	T,7
	SOJA	W1,.-2

TXQT:	SETZM	TXQUOT
	JRST	TEXI2A

TXUPR:	SETZM	TXUPRW
	CAIN	T,"?"
	  JRST	TXDEL
	SUBI	T,100
	JUMPL	T,ERR
	JRST	TEXI2A

TXDEL:	MOVEI	T,delete
	JRST	TEXI2A

TEXDEP:	TLNN	F,ROF		; IS A REGISTER OPEN?
	  JRST	TEXDE2
	CALL	TIN
	CAMN	T,SYL
	tlnn f,ccf
	  ret
	PUSH	P,T
	MOVE	T,-1(P)
	XCT	1(T)
	MOVE	R,LLOCO
	CALL	DEP
	 JRST	ERR
	POP	P,T
	AOS	LLOCO
	MOVEI	W1,5
	MOVEI	T-1,0
	RET

TEXDE2:	AOS	(P)		; Skip return
	CALL	TTPEEK		; Look ahead
	CAME	T, SYL		; Terminator?
	 SKIPA	T, SYL		; Type for him
	  JRST	TIN
	JRST	TOUT

SIXBIN:	SKIPA	W1,[6]
SIXBI1:	CALL	TIN		; INPUT TEXT (SIXBIT)
	CAMN	T,SYL
	 JRST	SIXBI2
	uppercase(t)
	CAIL	T," "		;IS CHAR IN SIXBIT SET?
	 CAILE	T,"_"
	  JRST	ERR		;NO
	ANDI	T,77		;YES, MASK TO 6 BITS
	TRC	T,40		;CONVERT TO SIXBIT FORM
	ROT	T,-6
	LSHC	T-1,6
	SOJG	W1,SIXBI1
	CALL	TEXDEP		; DEPOSIT THIS WORD OF TEXT
	JRST	SIXBI1+1
SIXBI2:	MOVE	T,T-1
	JUMPLE	W1,[SETZM WRD2
		    JRST QUAN1]
	LSH	T,6
	SOJA	W1,.-2

SQZIN:	PUSH P,[0]
	SKIPA W1,[6]
SQZIN1:	  CALL TIN
	CAMN T,SYL
	 JRST SQZIN2
	CALL SQUEEZ		;Accmulate onto stack
	  JRST [POP P,T
		JRST ERR]
	SOJG	W1,SQZIN1
	CALL	TEXDEP
	 JRST	SQZIN1+1

SQZIN2:	CALL	SQZFIX
	JUMPLE W1,[PUSHJ P,SQZFIX
		   POP P,1
		   SETZM WRD2
		   JRST QUAN1]
	IMULI	T,50
	SOJA	W1,.-2

SQUEEZ:	uppercase(t)
SQZIN3:	CAIL T,"A"
	 CAILE T,"Z"
	  JRST .+3
	   SUBI	T,66
	   JRST	SQZIN4
	CAIL T,"0"
	 CAILE T,"9"
	  JRST .+3
	   SUBI	T,57
	   JRST	SQZIN4
	CAIN T,"."
	  JRST [MOVEI T,45
		JRST SQZIN4]
	CAIN T,"$"
	  JRST [MOVEI T,46
		JRST SQZIN4]
	CAIN T,"%"
	  JRST [MOVEI T,47
		JRST SQZIN4]
	CAIE T,"#"
	  RET
SQZIN4:	MOVEI 2,50
	IMULM 2,-1(P)
	ADDM T,-1(P)
	JRST CPOPJ1

SQZFIX:	MOVE	1,WRD2
	IDIVI	1,^d10
	IMULI	1,^d8
	ADD	1,2
	LSH	1,36
	TLZ	1,37777
	MOVE	T,-1(P)
	IORM	1,T
	POPJ	P,

; ;R --  TAKE PRECEEDING SYMBOL AS RADIX 50

RDX50:	MOVE	T,SYM
	MOVEM	T,SYL
	TLZ	F,FPF!FEF!LTF!SF
	TRZ	F,SEMIF!SEMIF2	;ALLOW $ MODIFIERS
	JRST	L1RPR

; $K command - <sym>$K is KILL SYMBOL FOR OUTPUT
;<SYM>$$K -- KILL FOR INPUT AND OUTPUT
;SYM HAS THE SYMBOL

	block 6
	[asciz "$$K	clobbers the entire symbol table.
sym$$K	kills the named symbol for input and output both."]
	[asciz "sym$K	kill the given symbol for output, so it won't be seen."]
	0			;there is no "K" command

KILL:	TLNN	F,LTF		;DOES SYM CONTAIN A LETTER?
	 JRST	KILTAB		;NO
	CALL	EVAL
	  JRST	KILL1		;CANT FIND A DEFINED SYM BY THAT NAME
;FOUND.  R POINTS AT NAME-VALUE PAIR IN SYM TAB
	MOVEI	T,DELO/200000	;DELETE OUTPUT
	TLNE	F,CCF
	  MOVEI	T,DELI/200000	;NO INPUT OR OUTPUT
	DPB T,[POINT 2,(R),1]	;LEFT 2 BITS IN SYMBOL
	JRST	RETX

KILL1:	MOVE	R,ESTU		;REMOVE UNDEFINED SYMS
	JUMPGE	R,UNDEF		;EMPTY
KILL2:	CALL	EVAL0
	  JRST	RETX
	CALL	REMUN
	JRST	KILL2

;REMOVE ONE SYMBOL FROM THE UNDEFINED TABLE
REMUN:	MOVE	S,[2,,2]
	ADDB	S,ESTU		;SHORTEN UNDEF TABLE AND MOVE ORG UP
	MOVE	W,-2(S)		;PUT SYM WHICH FELL OFF BOTTOM
	MOVEM	W,(R)		;IN PLACE OF SYM BEING DELETED
	MOVE	W,-1(S)
	MOVEM	W,1(R)
	RET

;$$K -- KILL ENTIRE SYMBOL TABLE

KILTAB:	TLNN	F,CCF		;HOW MANY $'S
	  JRST	ERR		;NOT ENOUGH
	CALL	FLSSYM
	JRST	RETX

;SYMBOL TABLE FLUSHER
FLSSYM:	SKIPL	T,SYMPTR	;OLD SYMBOL POINTER
	  MOVE	T,[-2,,HOME-2]
	MOVEM	T,SYMPTR
	CAMN	T,[-2,,HOME-2]
	  JRST	FLSUNS		;NO OLD SYMS PAGES TO WORRY ABOUT
	HRLZI	R,0(T)
	TLZ	R,777000
	SUB	T,R
	ASH	T,-11
	TRZ	T,777000
	SETZ	3,		;WATCH OUT FOR KL20
FLSSP:	HRR	2,T		;PAGE
	HRLI	2,.FHSLF	;IDDT FORK
	SETOM	1		;DISMISS IT
	PMAP
	AOBJN	T,FLSSP
	MOVE	T,[-2,,HOME-2]	;"NULL" SYM PTR
	MOVEM	T,SYMPTR
	SETZM	PRGM
	SETZM	BLOCK
	SETZM	tmpblk

;FLUSH UNDEFINED SYMBOL TABLE

FLSUNS:	SKIPL	T,ESTU
	 RET			;NONE
	HRLZI	R,0(T)
	TLZ	R,777000
	SUB	T,R
	ASH	T,-11
	TRZ	T,777000
	SETZ	3,		;WATCH OUT FOR KL20
FLSUN1:	HRR	2,T		;PAGE
	HRLI	2,.FHSLF	;IDDT FORK
	SETOM	1		;DISMISS IT
	PMAP
	AOBJN	T,FLSUN1
	SETZM	ESTU
	SETZM	ESTUT
	RET

; : - SYM HAS SYMBOL TO LEFT OF :
;DEFV HAS VALUE OF A IN A<B:

	block 6
	[asciz "sym$$:	sets the symbol block name to be sym.
$$:	shows the current block name."]
	[asciz "sym$:	sets the program name to be sym.
$:	shows the current program name."]
	[asciz "sym:	defines sym as a symbol having the value of dot.
n<sym:	defines sym to have the value n."]

TAG:	TLNN	F,LTF   	;NO LETTERS means show what's set
	  JRST tag1		;  do it.
	TLNE	F,FAF   	; DEFINE SYMBOLS
	  JRST	tag0		;A<B:
	TLNE	F,CF		;$ TYPED?
	  JRST	SETNAM		;<PROGRAM>$:
	MOVE	W,LLOCO		;<TAG>: COMMAND,  LLOCO=VALUE OF .
	TLNE	F,(DDTINT)
	  JRST	ERR		; . WAS INSIDE OF IDDT
	HRRZM	W,DEFV
tag0:	call	defin
	jrst	retx

tag1:	tlne f,ccf		;$$: block?
	  jrst tag2		;  yes
	skipl w,prgm		;no, program.  one set?
	  jrst err		;  nope.
	call tspc		;space over one.
	LDB T,[POINT 32,(W),35]	;GET SYMBOL
	call spt1		;and show it.
	jrst retx		;done.

tag2:	skipl w,block		;block set?
	  jrst err		;  nope
	call tspc
	LDB T,[POINT 32,(W),35]	;GET SYMBOL
	call spt1		;and show it.
	move w1,[ascii " ("]
	call text2
	movei 1,.priou		;now show the block level.
	move 2,1(w)		;get the block level
	movei 3,^d10
	NOUT
	  nop
	movei t,")"
	call tout
	jrst retx

;Define a symbol
;SYM and DEFV have the name and value

DEFIN:	CALL	EVALA		;DEFINED SYMBOL?
	 JRST	DEF1		;NO - DEFINE
	 JRST	DEF2		;YES, REDEFINE
DEF1:	MOVN	R,[2,,2]
	ADDB	R,SYMPTR	;MOVE UNDEFINED TABLE 2 REGISTERS
	HRRZ	T,ESTU
	SUBI	T,2
	HRL	T,ESTU
	HRRM	T,ESTU
	SKIPGE	ESTU
	  BLT	T,-1(R)
DEF2:	MOVE	T,DEFV
	MOVEM	T,1(R)		;PUT IN NEW VALUE
	MOVSI	T,GLOBAL
	IORB	T,SYM
	MOVEM	T,(R)		;PUT IN NEW SYM AS GLOBAL
	MOVE	R,ESTU

DEF3:	JUMPGE	R,CPOPJ		;PATCH IN VALUE FOR UNDEF SYM ENTRY
	MOVE	T,SYM
	TLO	T,GLOBAL	;UNDEFINED TAB HAS GLOBAL ENTRIES
	CAME	T,(R)
	  JRST	DEF4
	PUSH	P,R		;SAVE PTR
	SKIPL	R,1(R)		;IS ENTRY AN ADDITIVE REQUEST?
	  JRST	DEF7		;NO, CHAINED IN RIGHT HALF
	CALL	FETCH
	 JRST	ERR
	TLNN	R,(STNEG)	;ADDITIVE OR SUBTRACTIVE?
	 SKIPA	S,DEFV		;ADDITIVE
	  MOVN	S,DEFV		;SUBTRACTIVE
	TLNE	R,(STLH)	;RIGHT OR LEFT HALF?
	  JRST	DEF8		;LEFT
	ADD	S,T		;RIGHT
	HRRM	S,T
DEF5:	CALL	DEP
	 JFCL
DEF6:	POP	P,R
	CALL	REMUN
DEF4:	ADD	R,[2,,2]	;REMOVE THE NOW DEFINED SYMBOL
	JRST	DEF3

DEF7:	JUMPE	R,DEF6		;JUMP IF ALL DONE
	CALL	FETCH
	 JRST	ERR
	HRRZ	S,T		;SAVE CHAIN PTR
	HRR	T,DEFV		;REPLACE WITH NEW VALUE
	CALL	DEP
	 JRST	ERR		;LEAVES DANGLING CHAIN!!!
	HRRZ	R,S
	JRST	DEF7

DEF8:	HRLZS	S		;LEFT HALF FIXUP
	ADD	T,S
	JRST	DEF5

;<PROGRAM>$: COMMAND

SETNAM:	MOVE	R,SYMPTR	;SET PROGRAM NAME - DOLLAR COLON
SET1:	JUMPGE	R,UNDEF
	MOVE	T,(R)
	CAMN	T,SYM		;this full match will only work if the flag
	  JRST	SET2		;bits for the syms are 0, which they are for
	ADD	R,[2,,2]	;program-names only.
	JRST	SET1

SET2:	MOVEM	R,PRGM		;save the program name.
	SETZM	BLOCK		;start out with no selected block.
	CALL	SB1		;see if there's a block with the same name
	  JRST	RETX		;  as this program.  huh?  no?  oh well...
SBPRM:	MOVEM	R,BLOCK		;yes there is, so select that block too.
	JRST	RETX

;SEARCH SYMBOLS IN PROGRAM BEGINNING AT R FOR BLOCK NAMED SYM

SB1:	CAMN	R,SYMPTR
	 RET			;HIT BOTTOM OF TAB.
	SUB	R,[2,,2]
	LDB	T,[POINT 4,(R),3]
	JUMPE	T,CPOPJ		;BEGINNING OF NEXT PROGRAM
	CAIE	T,3
	 JRST	SB1		;NOT A BLOCK NAME
	MOVE	T,(R)
	XOR	T,SYM
	TLZ	T,740000
	JUMPN	T,SB1		;NAME DOESN'T MATCH
	JRST	CPOPJ1

; | command

	block 8
	[asciz \BLK|SYM	is the symbol SYM in the given symbol block BLK.\]

SETBLK:	TLNE	F,LTF		;if no symbol typed, it's an error
	 SKIPL	R,PRGM
	  JRST	ERR		;NO PROGRAM NAMED
	CALL	SB1		;defined?
	 JRST	UNDEF		;  nope
	MOVEM	R,tmpblk
	JRST	L1RPR		;SET BLOCK NAME

;FILE LOGIC

;THE FLAG TEMF IS USED TO CONTROL WHETHER OR NOT THE FORK IS
; TO BE STARTED AFTER THE GET ASSOCIATED WITH THE COMMAND (;Y, ;M
; ;L, OR $L). ON SUPPRESS RUNNING IT.

; ;Y -- YANK, BUT DON'T START A FILE

YANK:	hrroi w1,[asciz /ank file: /]
	TLNE	F,CF		; ALT-SEMI-Y
	  hrroi w1,[asciz /ank data file: /]
	TRO	F,TEMF		;SUPPRESS RUNNING IT
	JRST LODFIL

; ;M -- MERGE FILE INTO CURRENT USER FORK

MERGE:	hrroi w1,[asciz /erge file: /]
	TRO	F,TEMF		;SUPPRESS RUNNING IT
	JRST	LODFIL		;BYPASS NEWFORK GETTER

; ;L -- RUN THE NAMED FILE

LOADGO:	hrroi w1,[asciz /oadgo:   /]
	TRZ	F,TEMF		;ALLOW IT TO RUN
LODFIL:	CALL LODFI2
	MOVSI 3,(GJ%OLD!GJ%CFM)
	MOVEM 3,DEFALT+.GJGEN
	MOVE 3,[.PRIIN,,.PRIOU]
	MOVEM 3,DEFALT+.GJSRC
	JRST ASJFN

; $L -- RUN THE LOADER

	block 5
	[asciz ";L	load & go.  Prompts for a filespec, then loads and starts the named
	image."]
	0			;no $$L
	[asciz "$L	runs the loader."]
	0			;there is no "L" command

LOADER:
IFE	KL20F,<	hrroi w1,[asciz /oader [Confirm]/]>
IFN	KL20F,<	hrroi w1,[asciz /ink [Confirm]/]>
	CALL	TYPE
 	MOVEI	1,.PRIIN
	CFIBF		; RESET BUFFER AND ASK
	PBIN
	cain 1,cr	;a CR
	  pbin		;  is always followed by a LF
	caie 1,lf
	  jrst [hrroi w1,[asciz / Aborted?/]
		CALL TYPE
		JRST DD1.5]
	TLZ	F,CF
	CALL	KILFRK
	CALL	NEWFRK
	TRZ	F,TEMF		;ALLOW IT TO RUN, not a file-image.
	movsi 1,(gj%sht!gj%old)
IFE	KL20F,<	HRROI 2,[ASCIZ /<SUBSYS>LOADER.SAV/]>
IFN	KL20F,<	hrroi	2, [asciz /SYS:LINK.EXE/]>

; 1,2 ARE SET FOR GTJFN

ASJFN:	CALL ASJFN0
	TRNE	F,TEMF		;ARE WE SUPPOSED TO RUN IT?
	  JRST	DDT		;  NO
	CALL	CRF
	JRST	TOUSER

ASJFN0:	PUSH	P,2
	PUSH	P,1
	MOVE	1,FORK
	GEVEC			;MAYBE NULL
	 erjmp jerr
	POP	P,1
	EXCH	2,0(P)		;SAVE OLD EV
	CALL	GETFIL		;LOAD FILE
	CALL	SYMVEC		;GET SYMS, ENT. VEC TO R
	MOVEM	R,0(P)
	MOVEI	2,0(R)
	TLO	2,(1B5)		;USERMODE
	MOVEM	2,PC
	MOVEM	2,REALPC
	POP	P,2
	MOVE	1,FORK
	SEVEC
	 erjmp jerr
	SETZM FILIMG
	setzm cursec		;start out in section 0
	SETZM AC0
	MOVE 1,[AC0,,AC0+1]
	BLT 1,AC0+17		;Clear the ACs
	MOVE 1,FORK
	MOVEI 2,AC0
	SFACS			;and then set them.
	 erjmp jerr
	RET

LODFI2:	CALL	TYPE
lodfi3:
IFN KL20F,<
IFE SYSF,<SETZM DEFALT+.GJDEV>
IFN SYSF,<
	HRROI 1,[ASCIZ "SYS"]
	MOVEM 1,DEFALT+.GJDEV
>;SYSF
	SETZM DEFALT+.GJDIR
>;IFN KL20
IFE KL20F,<
	SETZM DEFALT+.GJDEV
	HRROI 1,[ASCIZ "SUBSYS"]
	MOVEM 1,DEFALT+.GJDIR
>;IFE KL20
IFN KL20F,<	HRROI 1,[ASCIZ /EXE/]>
IFE KL20F,<	HRROI 1,[ASCIZ /SAV/]>
	TLNE F,CF			;This a $;Y type?
	  SETZ 1,			;  Yes, so no default extension.
	MOVEM	1,DEFALT+.GJEXT
	SETZM DEFALT+.GJNAM
	MOVEI	1,DEFALT
	MOVEI	2,0
	RET

; ;O -- OBTAIN SYMBOL FILE

OBTAIN:	TRNE F,SEMIF2		;Was this ;;O ?
	  JRST OBTUNV		;  Yes, so want universal file.
YNKSYM:	hrroi w1,[asciz /btain symbol file: /]
	CALL	TYPE
	HRROI	1,[ASCIZ /SYMBOLS/]
	MOVEM	1,DEFALT+.GJEXT
	MOVSI	1,(gj%old!gj%cfm)
	MOVEM	1,DEFALT+.GJGEN
	SETZM DEFALT+.GJDEV
	SETZM DEFALT+.GJDIR
	MOVEI	1,DEFALT
	MOVEI	2,0
	CALL	GETJFN
	 JRST	SYMSO4		;NO SYMBOLS??
	MOVEM	1,TEM1
	MOVE	2,[44B5!1B19]
	OPENF
	 JRST	SYMSO3
	CALL	FLSSYM		;FLUSH PAGES CONTAINING PREVIOUS SYMS
	MOVE 1,TEM1

YNKSY1:	BIN
	JUMPGE	2,YNKSY9	;NO DEFINED TAB
	HLRE	3,2		;THE NEGATIVE LENGTH

YNKSY2:	MOVEI	T,HOME
	ADD	T,3		;LOWEST ADDR OF DEF SYMTAB
	HRL	T,3		;MAKE AOBJN PTR
	MOVEM	T,SYMPTR	;THAT'S THE SYMTAB PTR
	MOVSI	2,(POINT 36,0)
	HRR	2,T		;36-BIT POINTER
	SIN

YNKSY3:	BIN			;UNDEF TAB IOWD
	JUMPGE	2,YNKSY8	;NO UNDEFINED TABLE
	HLRE	3,2		;GET NEG. LENGTH
	MOVE	T,SYMPTR	;PUT UNDER DEFINED TAB
	ADD	T,3		;BASE OF UNDEF TAB
	HRL	T,3		;MAKE AOBJN PTR
	MOVEM	T,ESTU		;THAT'S THE UNDEF. PTR
	MOVSI	2,(POINT 36,0)
	HRR	2,T
	SIN

YNKSY4:	MOVE	1,TEM1
	CLOSF
	 JRST	ERR
	JRST DD1

YNKSY8:	SETZM	ESTU		;SAY NO UNDEF SYMTAB
	JRST	YNKSY4		;GO CLOSE FILE

YNKSY9:	MOVE	T,[-2,,HOME-2]	;DUMMY UP A GOOD PTR
	MOVEM	T,SYMPTR
	JRST	YNKSY3		;LOOK FOR UNDEF. SYMTAB

;UNIVERSAL VERSION BIT DEFINITION

;THE FIRST WORD OF A UNV FILE MUST CONTAIN:
;	LEFT HALF	777
;	RIGHT HALF	UNIVERSAL VERSION NUMBER
;WHEN WRITING A UNV FILE, MACRO WRITES OUT:
;	777,,UWVER	FOR THE FIRST WORD
;	.JBVER		FOR THE SECOND WORD( MACRO VERSION NUMBER)
;WHEN READING A UNV FILE, MACRO READS THE FIRST WORD AND CHECKS FOR:
;	777 IN LEFT HALF, AND
;	CHECKS THE RIGHT HALF AGAINST MASK .URVER
;	WILL SKIP THE SECOND WORD IF A VERSION NUMBER IS EXPECTED THERE
;

UMACV==000020			;HAS MACRO VERSION IN 2ND WORD
USYN==000010			;NEW SYN HANDLING IN UNIVERSAL
UBAS==000004			;MUST HAVE THIS BASIC BIT ON
				;SAME AS THE FIRST VERSION #4
UPOL==000002			;POLISH INCLUDED
UMAD==000001			;MACRO ARG DEFAULT VALUE BUG FIXED

; Universal flag definitions

SYMF==400000			; symbol
TAGF==200000			; tag
NOOUTF==100000			; no DDT output
SYNF==040000			; synonym
MACF==020000			; macro
OPDF==010000			; opdef
PNTF==004000			; "value" in symbol table in
				;  pointer to 36-bit value
UNDF==002000			; undefined
EXTF==001000			; external
INTF==000400			; internal
ENTF==000200			; entry
ARF==000100			; variable
NCRF==000040			; don't CREF
MDFF==000020			; multiply defined
SPTR==000010			; special external pointer
SUPRBT==000004			; suppress output to REL and listing
LELF==000002			; LH relocatable
RELF==000001			; RH relocatable

OBTUNV:	MOVEI W1,[ASCIZ /btain universal file: /]
	CALL TYPE
	HRROI 1,[ASCIZ /UNV/]
	MOVEM 1,DEFALT+.GJDEV
	SETZM DEFALT+.GJDIR
	MOVEM 1,DEFALT+.GJEXT
	MOVSI 1,(GJ%OLD!GJ%CFM)
	MOVEM 1,DEFALT+.GJGEN
	MOVEI 1,DEFALT
	SETZ 2,
	CALL GETJFN
	  JRST SYMSO4		;NO SYMBOLS??
	MOVEM 1,UNVJFN
	MOVE 2,[44B5!1B19]	;Read, 26-bit bytes
	OPENF
	  JRST SYMSO3
	CALL FLSSYM		;FLUSH PAGES CONTAINING PREVIOUS SYMS
	MOVEI 1,HOME
	MOVEM 1,SYMPTR		;0,,HOME to start with.
	CALL UNVHED		;Read past header
SLRPUN:	CALL GTUNVS		;Get a symbol pair
	  JRST [MOVE 1,UNVJFN	;  Fatal error or no more.
		CLOSF
		  JRST ERR
		JRST DD1]
	MOVE 1,SYMPTR
	SUB 1,[1,,1]
	MOVEM TT2,(1)		;value
	SUB 1,[1,,1]
	TLO TT1,LOCAL+DELO	;set delete-output and local bits
	MOVEM TT1,(1)		;symbol
	MOVEM 1,SYMPTR
	JRST SLRPUN

GTUNVS:	SETZM IGNORE		; Assume we want this one.
	MOVE 1,UNVJFN
	BIN			; read a symbol
	JUMPE 2,CPOPJ		; spurious end of file?
GTUNV0:	CAMN 2,[373737,,373737]	; special symbol meaning end of universal file
	  RET			; at end, return to caller
	MOVE TT1,2		; save symbol for safekeeping
	BIN			; read flags word
	MOVE TT2,2		; save flags as well
	TLNE TT2,MACF		; macro?
	  JRST MACRO		; no, look at it further
	TLNN TT2,TAGF!UNDF!EXTF!ENTF!MDFF!SPTR!LELF!RELF	; any of these
	  CAMN TT1,[SIXBIT /.SYMTA/]	; or if .SYMTAB
	    SETOM IGNORE	; will cause it to be commented out
	TLNN TT2,PNTF!SPTR	; see if pointer block
	  JRST [TLZ TT2,-1	; No, so simple case - value is the
		JRST CVTSYM]	; RH halfword!
	BIN
	TLNE TT2,EXTF		; simple external?
	  JRST [BIN		; yes, get symbol it references
		JRST GTUNVS]	; and then ignore it.
	TLNN TT2,SPTR		; simple numeric value?
	  JRST [MOVE TT2,2	; yeah, so use it.
		JRST CVTSYM]
	SETOM IGNORE		;else something relocatable or polish, ignore!
	BIN
	JUMPL 2,POLAK		; if negative, Polish expression
	BIN			;I forget what this word was supposed to be...
	BIN			; finally the symbol added in
	JRST GTUNVS

CVTSYM:	SKIPE IGNORE		;Are we to ignore this symbol?
	  JRST GTUNVS		;  yeah, so just go try the next one.
	PUSH P,[0]		;else convert it into radix-50 on the stack
	MOVE TT,TT1
SIX50:	SETZ TT1,
	ROTC TT,6
	MOVEI T,40(TT1)		;7bit ascii
	CALL SQUEEZ		;make RADIX-50 and accumulate on stack
	   JRST [POP P,T	;Bad symbol
		JRST GTUNVS]	;lose, try another.
	JUMPN TT,SIX50
	POP P,TT1		;This is the RADIX-50 now
	JRST CPOPJ1		;and win-return

POLAK:	MOVE 1,UNVJFN
FLSPOL:	BIN			; link word
	JUMPN 2,FLSPOL		; can't be EOF
	BIN
	SKIPL 2
	 CAIL 2,14		; look like a Polish block?
	  JRST GTUNVS
REPEAT 4,<
	BIN			; remainder of block
>;REPEAT 4
REPEAT 2,<
	BIN			; consistency block
>;REPEAT 2
	JRST FLSPOL		; continue flushing Polish cruft

; Have to flush a macro...great pain involved.

MACRO:	BIN			; word 1 of leaf, LH 0 if last leaf
	MOVE TT2,2		; save it
REPEAT 3,<
	BIN			; rest of leaf
>;REPEAT 3
	TLNE TT2,-1		; last leaf?
	 JRST MACRO		; no, get next leaf
;;; I don't think this code is right, but it seems to work...
	BIN			; check for arguments
	TLNE 2,770000		; look like SIXBIT?
	  JRST GTUNV0		; yes, back to top level loop
	HLRZ TT2,2		; looks like a macro argument, get arg count-1
FLSARG:
REPEAT 5,<
	BIN			; default value plus leaf
>;REPEAT 5
	SOJGE TT2,FLSARG	; flush remaining arguments
	JRST GTUNVS

UNVHED:	MOVE 1,UNVJFN
REPEAT 5,<
	BIN			; slurp up header words
>;REPEAT 5
	RET

;GET FILE, SYMBOLS, AND ENTRY VECTOR (IF ANY)
;1,2 ARE SETUP FOR GTJFN

GETFIL:	CALL	GETJFN		;ONLY FLUSH STUFF IF GETJFN WINS
	 JRST JERR
	HRRZM	1,JFN
	HRROI	1,JFNDIR
	MOVEM	1,DEFALT+.GJDIR
	MOVE	2,JFN
	MOVSI	3,(JS%DIR)
	SETZ	4,
	JFNS
	HRROI	1,JFNNAM
	MOVEM	1,DEFALT+.GJNAM
	MOVSI	3,(JS%NAM)
	JFNS
	CALL	UNMAP		;FLUSH PAGE IN WINDOW
	CALL	KILFRK
	CALL	NEWFRK
	TLNE	F,CF
	 JRST	GETDFL
	HRL	1,FORK
	HRR	1,JFN
	GET
	  ERJMP JERR
	RET

;GET A FILE OF NON-RUNNABLE STUFF (LIKE $0L ON ITS)
GETDFL:	HRRZ	1,JFN
	MOVE	2,[444400,,OF%RD]
	OPENF
	  JRST [CALL BARF
		Move 1,JFN
		RLJFN
		  Nop
		JRST GETDF4]
	MOVEM	1,GDFROM
	MOVE	1,FORK
	MOVEM	1,GDTO
	Setom FFile			;From file -> memory

GDENTR:	SKIPN	1,DEFV			; GET LOWER LIMIT
	 MOVE	1,SYL
	MOVEM	1,DEFV			; SAVE AWAY
	MOVEM	1,SYL			; TEMP
	SKIPN	1,ULIMIT
	  MOVEI	1,37777
	MOVEM	1,ULIMIT		; SAVE UPPER LIMIT
	Setzm nPages			;# pages blasted
	Setom First

GETDLP:	HRLZ	1,GDFROM
	HRR	1,DEFV
	RPACS				; FIND THIS PAGE
	TLNN 2,(PA%PEX)
	  JRST [Call SRange		;Show the range mapped so far
		Setom First
		Skipn FFile
		  Jrst NXTPAG		; Doesn't exist, go on to the next one.
		Hrl 1,GDFROM
		Hrr 1,DEFV
		FFUFP			;Find next real page.
		  Movei 1,100000	;  No more, force end of search.
		Hrrzm 1,DEFV
		Jrst NXTPA0]
	Aos nPages			;Found a page.
	Skipge First
	  Jrst [Push P,1
		Movei 1,.PRIOU
		Move 2,DEFV
		Movem 2,First
		Movei 3,^D8
		NOUT
		  Nop
		Pop P,1
		Jrst .+1]
	Hrr 2,DEFV
	HRL	2,GDTO
	MOVSI	3,(PM%RD+PM%CPY)
	Skipn FFile
	  JRST [PUSH P,1
		Push P,2
		MOVE	R,DEFV
		LSH	R,9
		ADDI	R,100
		CALL	FETCH
	          JRST	ERR
		CALL	DEP
	          JRST	ERR
		Pop P,2
		POP P,1
		JRST	.+1]
	PMAP				; KEEP THOSE PAGES COMING
NXTPAG:	AOS DEFV			;Next page to blast out.
NXTPA0:	Move 1,DEFV
	CAMG 1,ULIMIT			;Beyond what we want?
	  Jrst GETDLP
	Call SRange

GETDF0:	Skipg T,nPages
	  Jrst [Hrroi W1,[ASCIZ /No pages./]
		CALL TYPE
		JRST GETDF1]
	Hrroi W1,[Asciz "= "]
	Call Type
	CALL TOC
	Hrroi W1,[ASCIZ / page /]
	Move T,nPages
	Caie T,1
	  Hrroi W1,[Asciz " pages "]
	Call Type
	Hrroi W1,[Asciz "loaded."]
	Skipn FFile
	  Hrroi W1,[Asciz "dumped."]
	Call Type
	call crf
GETDF1:	Skipe FFile
	 JRST	GETDF4
	MOVE	1,JFN
	MOVE	2,SYL
	LSH	2,9
	SFPTR
	 JRST	ERR
	MOVE	2,[444400,,AC0]
	MOVNI	3,20
	SIN
	MOVE	1,FORK
	MOVEI	2,AC0
	SFACS
	Move 1,GDTO
	CLOSF
	  JRST JERR
GETDF4:	SETZM	DEFV
	SETZM	ULIMIT
	SETOM FILIMG
	JRST	DDT

SRange:	Skipge First
	  Ret
	Move 2,DEFV
	Sub 2,First
	Caig 2,1
	  Jrst SRang0
	Movei 1,"-"
	PBOUT
	Movei 1,.PRIOU
	Move 2,DEFV
	Sos 2
	Movei 3,^D8
	NOUT
	  Nop
SRang0:	Movei 1," "
	PBOUT
	Ret

;DO AN ITS $0Y (UN-ALT-SEMI-Y)

UNASY:	hrroi w1,[asciz /nyank data to file: /]
	CALL	TYPE
	HRROI	1,[ASCIZ /EXE/]
	MOVEM	1,DEFALT+.GJEXT
	MOVSI	1,(gj%fou!gj%msg!gj%cfm)
	MOVEM	1,DEFALT+.GJGEN
	SETZM DEFALT+.GJDEV
	SETZM DEFALT+.GJDIR
	MOVEI	1,DEFALT
	MOVEI	2,0
	CALL	GETJFN
	 JRST JERR
	MOVEM	1,TT1
	MOVE	2,[440000,,OF%WR]
	OPENF
	 JRST JERR
	MOVEM	1,GDTO
	MOVE	1,FORK
	MOVEM	1,GDFROM
	MOVEI	2,AC0
	RFACS
	MOVE	1,GDTO
	MOVEI	2,AC0
	MOVNI	3,20
	SOUT
	Setzm FFile			;From memory -> file
	JRST	GDENTR

;DO A GTJFN, ALLOWING THE CURRENT ESCAPE CHARACTER TO BE TYPED IN.

GETJFN:	call escoff		;disable escape code
	GTJFN
	  JRST GETJF7		;SEE IF TERMINATOR WAS ESCAPE CHARACTER
GETJF5:	call escon		;enable escape code
	JRST CPOPJ1		;SAY OK TO CALLER

GETJF7:	CAIE 1,GJFX4		;ILLEGAL CHR IS REASON FOR LOSAGE?
	  JRST GETJF8		;NO
	HLRZ 1,2		;GET INPUT JFN
	SKIPN 1
	  HLRZ 1,DEFALT+1
	CAIN 1,.PRIIN
	 BKJFN
	  JRST GETJF8		;NOT TTY: OR BKJFN BAD
	BIN			;GET PREVIOUS CHR
	CAMN 2,ESCCHR		;IS IT THE ESCAPE CHR?
	  JRST WRONG		;YES (ATI WILL HAPPEN IN MAIN LOOP)
GETJF8:	call escon		;enable escape code
	RET			;NO SKIP

;GET A NEW FORK

NEWFRK:	MOVSI 1,(CR%CAP)
	CFORK
	 JRST	ERR
	MOVEM	1,FORK
	MOVEM	1,TPFORK
	FFORK			;IDDT DEALS ONLY WITH FROZEN FORKS
	CALL	SETTRP
	MOVEI	1,.FHSLF	;IDDT
	RPCAP
;	SETZ	3,		;[NIC251] PASS CAP'S BUT NOT ENABLED
	MOVE	1,FORK
	EPCAP
	MOVNI	1,5
	RUNTM
	MOVEM	1,TIMUSD
	MOVEM	3,TIMCON
	RET

KILFRK:	CALL	UNMAP		;FLUSH ANY MAPPED PAGE
	MOVE	1,TPFORK
	KFORK
	SETZM	FORK
	SETZM	USRPSI
	SETZM	USRPSI+1
	SETZM	USRPSI+2
	SETZM	USRPSI+3
	SETZM	BPTFLG
	SETZM	SYMPTR
	SETZM	ESTU
	SETZM	PRGM
	SETZM	BLOCK
	SETZM	tmpblk
	MOVE	TT,PCSTAK
	MOVEM	TT,PCSPTR
	RET

;SET JSYS TRAPS FOR BPT IN TPFORK

SETTRP:	MOVE	1,TPFORK
IFE KL20F,<	HRLI 1,(1B6)>
IFN KL20F,<	hrli 1, .tfres>
	TFORK			; RESET JSYS TRAPS
IFE KL20F,<	 HALTF>
IFE KL20F,<	HRLI 1,(1B3)>
IFN KL20F,<	hrli 1, .tfsps>
	MOVSI	2,2
	TFORK			; TURN ON TRAPS FOR BPT
IFE KL20F,<
	 HALTF
	HRLI	1,(1B0)
	MOVEI	2,JTAB
>
IFN KL20F,<
	hrli 1, .tfset
	movei	3, jtab
>
	TFORK
IFE KL20F,<
	HALTF
>
	RET

.R.==<BPT>&777
.Q.==.R./^D36
.R.==.R.-<.Q.*^D36>
JTAB:	REPEAT	.Q.,<0>
	1B<.R.>
	REPEAT	^D<<512+35>/36>-.Q.-1,<0>

;GET NEW SYMBOLS, ENTRY VECTOR
;FLUSH BREAKPOINTS, AND PAGES CONTAINING OLD SYMTAB FIRST.

SYMPAG==1			;Load symbols here in our address space
SYMADR=SYMPAG*1000

SYMVEC:	CALL	FLSBPT		;FLUSH BREAKPOINTS
	CALL	FLSSYM		;FLUSH OLD SYMBOLS

NEWSYM:	movei r,JOBSYM		;JOBSYM
GTSYMS:	CALL	FETCH0		;ENTRY FROM ;S
	  JRST NOSYMS
	Hlre TT,T		;-length
	JUMPE TT,NOSYMS
	Tlz T,-1		;Flush LH count
	IDivi T,1000		;T/ page#, W1/ offset within page
	ldb w2,[xsecbp r]	;get the section# of where the symptr is
	imuli w2,1000		;each section is 1000 pages
	addi t,(w2)		;account for it
	Addi W1,SYMADR		;And instead have it point within page#1
	Movem W1,SYMPTR
	Hrlm TT,SYMPTR
	Sub W1,TT		;ending address
	IDivi W1,1000		;W1/ ending page, W2 clobbered
	Subi W1,SYMPAG-1	;# pages in symbol table
	Hrrz 1,T		;Starting page in fork
	Hrl 1,FORK		;Process handle,,starting page
	Move 2,[.FHSLF,,SYMPAG]	;Where to put in our address space
	Move 3,W1		;# pages
	Tlo 3,(PM%CNT!PM%CPY)
	PMAP
	 Erjmp JErr
	Movei T,SYMADR		;Starting address in our space
GetSym:	Movms (T)		;Make the page private
	Addi T,1000		;step up to next page
	Sojg W1,GetSym		;and do it.
	Jrst EntVec

NOSYMS:	MOVE	T,[-2,,HOME-2]	;JOBSYM READ-PROTECTED??
	MOVEM	T,SYMPTR

;HANDLE ENTRY VECTOR

ENTVEC:	CALL	CHKSYM
	MOVE	1,FORK
	GEVEC
	RET

; ;U  UNLOAD THE CURRENT CORE IMAGE
; ;;U  UNLOAD CORE AFTER HAVING COPIED SYMBOL TABLE BACK
; OPPOSITE OF ;Y

SEMI.U:	TLNE	F,CF
	 JRST	UNASY
	TLNE	F,QF!CF		;REASONABLE COMMAND?
	 JRST	ERR
	TRNN	F,SEMIF2	;HOW MANY SEMICOLI?
	 JRST	UNGET		;ONLY ONE

UNLOAD:	MOVE	W1,[ASCIZ /nload/]
	CALL	TEXT
	MOVE	T,[RADIX50 4,PAT..]	;SETUP FOR DEFINE
	MOVEM	T,SYM
	MOVE	R,XRG		;CURRENT PATCH LOCATION ($X)
	MOVEM	R,DEFV
	CALL	DEFIN		;DO THE DEFINITION
	HRRZ	T,ESTU		;WHERE UNDEFINED TABLE IS
	SKIPL	ESTU		;BUT IS THERE ONE?
	  HRRZ	T,SYMPTR	;NO, USE DEFINED TABLE
	JUMPE	T,UNLOA9	;JUMP IF NO SYMBOLS AT ALL
	HRRZ	R,XRG		;$X LOCATION
	SUB	T,R		;GET AMOUNT OF FREE SPACE LEFT
	CAIL	T,10		;ENOUGH FOR NEXT TIME?
	 TDZA	T,T		;YES.  DON'T MOVE SYMTAB
	  SUBI	T,100		;NO. MAKE 100 FREE LOCATIONS FOR PATCHES
	MOVNS	T		;MAKE OFFSET POSITIVE
	CALL	STOSYM		;STORE SYMTAB BACK INTO USER SPACE
	JRST	UNLOA9		;NOW GO DO A ;U

;MAKE A COPY OF IDDT'S VERSION OF THE USER'S TABLE IN THE USER SPACE
; T/  OFFSET TO MOVE SYMTABLE UP BY

STOSYM:	PUSH	P,T		;SAVE OFFSET FOR BELOW
	HLLZ	S,SYMPTR	;NEG. LENGTH OF DEFINED TABLE
	ADD	S,ESTU		;ACCOUNT FOR UNDEFINED TABLE
	HLRES	S
	MOVNS	S		;TOTAL LENGTH OF BOTH TABLES
	HLRE	R,SYMPTR
	MOVNS	R
	ADD	R,SYMPTR
	HRRZS	R		;TOP+1 (SOURCE IN IDDT)
	ADD	T,R
	HRRZS	T		;TOP+1 (DEST. IN USER)
	TRO	F,TEMF		;SAY IT IS FIRST TIME THROUGH

STOSY0:	PUSH	P,T		;SAVE TARGET ADDRESS
	SUBI	R,1		;MOVE TO NEXT DATA ADDRESS
	MOVE	T,0(R)		;PICK UP A DATA WORD
	EXCH	R,0(P)		;GET TARGET ADDR, SAVE SOURCE
	TRZN	F,TEMF		;1ST TIME, OR
	TRNN	R,777		;GOING INTO NEW PAGE?
	  SOJA	R,STOSY1	;  YES.  MUST MAP THE PAGE
	SOJA	R,STOSY2	;NO.  IT IS MAPPED FROM LAST TIME

STOSY1:	PUSH	P,R		;SAVE TARGET ADDR
	CALL	DEP		;MAP AND STORE
	 JRST	ERR		;FAILED.  JUST GET OUT
	JRST	STOSY3

STOSY2:	PUSH	P,R		;SAVE TARGET ADDR
	ANDI	R,777		;SAVE OFFSET INTO PAGE
	MOVEM	T,UCORE(R)	;STORE THE WORD

STOSY3:	POP	P,T		;RESTORE TARGET ADDRESS
	POP	P,R		;AND SOURCE
	SOJG	S,STOSY0	;AND DO MORE IF NEEDED.
	MOVE	T,SYMPTR
	ADD	T,0(P)		;COMPUTE NEW SYMPTR
	movei r,JOBSYM
	SKIPGE	T
	CALL	DEP
	 JFCL
	POP	P,T
	ADD	ESTU		;OFFSET UNDEFINED POINTER TOO
	MOVEI	R,117
	SKIPGE	T
	CALL	DEP
	 JFCL
	RET

; ;U COMMAND

UNLOA9:	SKIPA	W1,[POINT 7,[ASCIZ / to file: /]]
UNGET:	  hrroi w1,[asciz /nget to file: /]
	CALL	TYPE
	MOVSI	1,(gj%fou!gj%msg!gj%cfm)
	MOVEM	1,DEFALT+.GJGEN	;FLAGS
	SETZM DEFALT+.GJDEV	;No default device
	SETZM DEFALT+.GJDIR	;or directory
IFN ka10f!ki10f,<	HRROI 1,[ASCIZ /SAV/]>
IFN KL20F,<		hrroi	1, [asciz /EXE/]>
	MOVEM	1,DEFALT+.GJEXT
	MOVEI	1,DEFALT
	MOVEI	2,0
	CALL	GETJFN
	 JRST	JERR
	MOVEM	1,TT1

UNGET0:	MOVE	1,FORK
	GEVEC
	JUMPN	2,UNGET2

UNGET1:	call crf
	hrroi w1,[asciz /Start address is /]
	CALL	TYPE
	move t,lloco
	MOVE	1,FORK
	HRLI	2,1		;LEN 1
	HRR	2,T		;AT "."
	SEVEC
	CALL	PAD

UNGET2:	HRR	1,TT1
	HRL	1,FORK
	MOVE	2,[-1000,,520000]
	SETZM	3
	SSAVE
	JRST	DD1

; ;W -- WRITE OUT SYMBOL FILE

SYMSOT:	hrroi w1,[asciz /rite symbols on file: /]
	CALL	TYPE
	TRO	F,TEMF!TEM2F	;SAY BOTH TABS EXIST
	SKIPGE	R,SYMPTR
	CAMN	R,[-2,,HOME-2]
	 TRZ	F,TEMF		;NO MAIN SYMTAB
	SKIPL	R,ESTU
	 TRZ	F,TEM2F		;NO UNDEF TAB
	TRNN	F,TEMF!TEM2F
	 JRST	SYMSO4		;NOTHING TO WRITE

SYMSO1:	HRROI	1,[ASCIZ /SYMBOLS/]
	MOVEM	1,DEFALT+.GJEXT
	MOVSI	1,(GJ%FOU!GJ%CFM)
	MOVEM	1,DEFALT+.GJGEN
	SETZM DEFALT+.GJDEV
	SETZM DEFALT+.GJDIR
	MOVEI	1,DEFALT
	MOVEI	2,0
	CALL	GETJFN
	 JRST	ERR
	MOVEM	1,TEM1
	MOVE	2,[44B5!1B20]
	OPENF
	 JRST	SYMSO3

SYMSO2:	TRNE	F,TEMF
	SKIPL	T,SYMPTR
	 SETZM	T
	CALL	WRTSYM
	TRNE	F,TEM2F
	 SKIPL	T,ESTU
	  SETZM	T
	CALL	WRTSYM
	MOVE	1,TEM1
	CLOSF
	 JFCL
	JRST	DD1

SYMSO3:	MOVE 1,TEM1
	RLJFN
	  JFCL
SYMSO4:	CALL TERPRI
	CALL BARF
	JRST ERR

WRTSYM:	PUSH	P,3
	HLL	2,T		;GET NEG. LENGTH
	HRRI	2,-1(T)		;MAKE IOWD
	BOUT
	HRLI	2,004400	;POINT 36,.-.,-1
	HLRE	3,T		;NEG. LENGTH
	SKIPGE	3
	SOUT
	POP	P,3
	RET

; ;E COMMAND -- CHANGE ESCAPE CHARACTER

ESCAP:	TRNE F,SEMIF2		;Was this ;;E?
	  JRST SHOENT		;  Yes
	tlne f,cf		;[NIC252] was this alt-semi-e?
	  jrst [move 1,fork	;[NIC252]
		setob 2,3	;[NIC252]
		EPCAP		;[NIC252]
		hrroi w1,[asciz "nabled"]	;[NIC252]
		call type	;[NIC252]
		jrst dd1]	;[NIC252]
	hrroi w1,[asciz /scape character is: /]
	CALL	TYPE
	call escoff		;disable the old escape code
	MOVEI	1,.FHSLF
	RPCAP
	MOVE	TT,3
	MOVNI	1,5		;SAY WHOLE JOB
	RTIW			;GET CURRENT TIW
	push p,2
	TLNE	TT,(1B0)	;SEE IF ^C CAP IS ENABLED
	  SETZB	2,3
	STIW			;ALLOW EVERYTHING TO BE TYPED IN
ESCAP0:	TYI
	MOVE	T,1
	MOVNI	1,5
	SETZ 3,
	pop p,2
	STIW			;RESTORE THINGS AS THEY WERE
	PUSH	P,T
	CAIN	T,delete	;RUBOUT?
	  MOVEI	T,^D28		;YES
	CAIN	T,40		;SPACE
	  MOVEI	T,^D29
	CAILE	T,^D29		;REST ARE ILLEGAL
	  JRST	ERR

ESCAP1:	PUSH	P,T		;SAVE FOR LATER
	MOVNS	T
	MOVSI	W,(1B0)		;A SINGLE BIT
	ROT	W,0(T)		;CONVERT TO MASK
	TDNN	W,[1B0!17B10!1B13!3B29]	;DID TENEX ECHO PROPERLY?
	  JRST	ESCAP3		;YES
	MOVEI	T,"^"
	CALL	TOUT
	MOVE	T,-1(P)		;THE CHARACTER
	TRC	T,100		;MAKE INTO NON-CONTROL EQUIVALENT
	CALL	TOUT

ESCAP3:	POP	P,ESCCOD		;NEW ESCAPE CODE
	POP	P,ESCCHR		;NEW ESCAPE CHARACTER

ESCAP4:	MOVE	R,SAVCOC
	DPB	R,COCPTR		;POINTER INTO CCOC WORD

ESCAP5:	MOVE	TT,ESCCHR		;NEW ESCAPE CHARACTER
	IDIVI	TT,^D18
	ASH	TT1,1
	MOVNS	TT1
	ADDI	TT1,^D34		;NUMBER OF BITS LEFT IN WHICHEVER WORD
	ADD	TT,[2B11+TTYCC2]	;TWO BIT BYTE POINTER
	DPB	TT1,[POINT 6,TT,5]	;INSERT POSITION
	MOVEM	TT,COCPTR
	LDB	R,TT		;GET CURRENT SETTING
	MOVEM	R,SAVCOC
	MOVEI	R,0
	DPB	R,TT		;TURNOFF ECHOING FOR THAT CHAR

ESCAP6:	MOVEI	1,.PRIOU
	MOVE	2,TTYCC2
	MOVE	3,TTYCC3
	SFCOC
	call escon		;enable escape code
	jrst dd1

; ;T - Show symbol Table

LISTS:	MOVEI W1,[ASCIZ " - symbol table"]
	CALL TYPE
	SETZM LSTKEY		;Show all blocks
	SETOM LSTSYM		;Print symbols
	tlne f,cf		;unless $;t
	  setzm lstsym
	MOVE T,SYM
	TLNE F,QF		;There an arg?
	  MOVEM T,LSTKEY	;  Yeah, so put symbol here.
	setom seeblk		;assume showing all blocks now

LISTS0:	CALL CRF
	SKIPGE TT2,SYMPTR	;Any symbols?
	  CAMN TT2,[-2,,HOME-2]
	    JRST DD1		;  Nope.
	INTON			;make this abortable
	MOVEI TT1,3
	HLRE TT2,SYMPTR
	MOVE TT3,TT2
	MOVNS TT2
	ADD TT2,SYMPTR
	ASH TT3,-1
	JRST LISTS2

LISTS1:	SUB TT2,[2,,2]
	LDB T,[POINT 4,(TT2),3]
	CAIN T,3
	  JRST BLKNAM		;A block name.
	JUMPE T,PRGNAM		;Program-name.
	skipe seeblk		;can we see syms in this block?
	 SKIPN LSTSYM		; or are we not Listing symbols?
	  JRST LISTS2		;  Nope...
	CAILE TT1,^D70		;Fit on line?
	  JRST [CALL CRF
		MOVEI TT1,3
		JRST .+1]
	MOVE T,TT1
	CALL TALIGN
	ADDI TT1,^D8
	LDB T,[POINT 32,(TT2),35]
	CALL SPT1		;RADIX-50 output
LISTS2:	AOJLE TT3,LISTS1
	CALL CRF
	JRST DD1

PRGNAM:	SKIPA TT,[0]		;Program-names are like block level 0
BLKNAM:	  MOVE TT,1(TT2)	;  Get block-level
	SKIPE LSTKEY		;Looking for a specific block?
	  JRST [LDB T,[POINT 32,(TT2),35]	;Yes, check if this is it.
		CAMN T,LSTKEY	;A match?
		  JRST .+1	;  Yes, so onward...
		SETZM seeblk	;No match, wrong block.
		JRST LISTS2]
	setom seeblk		;this block is ok to see
SHOBLK:	CALL TERPRI
	skipg w1,tt		;if below program lebvel
	  jrst [hrroi w1,[asciz "Program "]
		call type
		jrst shobl0]
	movei t,">"		;indent using this
	call tout
	sojg w1,.-1		;indent according to the level
shobl0:	LDB T,[POINT 32,(TT2),35]
	CALL SPT1		;Print block name
	jumpe tt,[movei t,":"
		  call tout
		  jrst shobl1]	;no level# for programs
	MOVEI W1,[ASCIZ " ("]
	CALL TYPE
	MOVEI 1,.PRIOU
	MOVE 2,TT
	MOVEI 3,^D10
	NOUT
	  NOP
	MOVEI T,")"
	CALL TOUT
shobl1:	CALL CRF
	MOVEI TT1,3
	JRST LISTS2

; ;B - Print some breakpoint information (like :LISTB on ITS).  Also
; shows the address break, if set.  ;;B shows only the address break.

PRBRK:	MOVEI W1,[ASCIZ /reakpoints/]
	CALL TYPE
	CALL CRF
	SETO TT2,
	TRNE F,SEMIF2		;Was this ;;B ?
	  JRST SHOABK		;  Yes, so just want address break
	MOVEI	W1,BPTS
PRBRKL:	SKIPN .baddr(W1)	;ONE HERE?
	  JRST PRNXTB		;  no
	HRROI 1,[ASCIZ /Name   Location           Break Skip   Proceed Count/]
	AOSG TT2
	  PSOUT
	CALL CRF
	PUSH	P,W1
	MOVEI	W1,.bname(W1)
	CALL	TYPE0		; NAME
	MOVEI	T,13
	CALL	TALIGN
	move w1,(p)
	MOVE	T,.baddr(W1)
	CALL	PADSO		; print out the address
	MOVEI	T,40
	CALL	TALIGN
	MOVE	W1,(P)
	MOVE	T,.bskip(W1)
	CALL	CONSYM		; 0 OR CONDITIONAL BREAK SKIP
	MOVEI	T,60
	CALL	TALIGN
	MOVE	W1,(P)
	MOVE	T,.bpcnt(W1)
	CALL	TOC4		; PROCEED COUNT, signed decimal w/dot.
	POP	P,W1
PRNXTB:	ADDI	W1,NBPTV
	AOS	(P)
	CAIE	W1,<BPTS+<NBP*NBPTV>>
	 JRST	PRBRKL
SHOABK:
IFN ADBRKF,<
	HRRZ 1,FORK
	HRLI 1,.ABRED
	ADBRK			;Read address break
	  ERJMP SADRBD
	JUMPE 2,SADRBD		;None set
	MOVEI W1,[ASCIZ /Name   Location/]
	AOSG TT2
	  CALL TYPE
	CALL CRF
	MOVEI W1,[Asciz "ADR$"]
	CALL TYPE0
	MOVEI T,"R"
	TLNE 3,(AB%RED)
	  CALL TOUT
	MOVEI T,"W"
	TLNE 3,(AB%WRT)
	  CALL TOUT
	MOVEI T,"E"
	TLNE 3,(AB%XCT)
	  CALL TOUT
	MOVEI T,13
	CALL TALIGN
	MOVE T,2
	CALL CONSYM		; PRINT OUT VALUE,,LOCN
>;Address break
SADRBD:	MOVEI W1,[ASCIZ "None set."]
	SKIPGE TT2
	  CALL TYPE
	CALL CRF
	JRST DD1

; ;H -- HALTF BACK TO EXEC, ;;H tries to tell EXEC to kill this fork

FrkCCL==:0	;Re-do last CCL command function
FrkKep==:1	;Keep fork
FrkKil==:2	;Kill fork
FrkBak==:3	;Continue/Background

	block 2
	[asciz ";;H	halts IDDT and requests to superior that its own fork be reset."]
	block 5
	[asciz "^Z or ;H
	halts IDDT"]

HHALT:	call escoff		;disable escape code
	TRNE F,SEMIF2		; ;;H?
	  JRST [Move 1,[.PRAST,,.FHSLF]
		Movei 2,4	;Address of arg block
		Movei 3,1	;Length of arg block
		Movsi 4,FrkKil	;Kill this fork, please (the arg)
		PRARG
		Jrst .+1]
	HALTF			;LIKE @QUIT
	call reddt		;let user know he's back in
	jrst dd1.5		;then go back to debugging.

escoff:	push p,1		;turn off ^D interrupt
	move 1,esccod
	DTI
	pop p,1
	ret

escon:	push p,1		;turn on ^D interrupt
	hrlz 1,esccod		;code,,channel 0
	ATI
	pop p,1
	ret

REDDT:	CALL TERPRI		;make sure on a new line
	MOVE	W1,[ASCIZ "IDDT"]
	CALL	TEXT
	call crf
	call crf
	ldb t,[xpcbp pc]	;get the current PC
	jumpe t,cpopj		;0 if no real PC, so don't show it
	setom pinff		;print AC and E fields
	call li1		;show where they were
	call lct		;space over a bit
	ret

;***ROUTINES BEYOND HERE EVALUATE THEIR ARGUMENT***

; * command

	block 8
	[asciz "*	does integer multiplication, 3*4=14"]

MULT:	TLO	F,PTF+MLF		;*
	jrst l1

; ! command, division

	block 8
	[asciz "!	performs integer division, 3!2=1"]

DIVD:	TLO	F,DVF+PTF		;SINGLE QUOTE
	JRST	L1

ASSEM:	JRST	PLUS		;#

; - command

	block 8
	[asciz "-	does fullword integer subtraction, or is used for unary negation.
	1-2=-1, and -1=-1."]

MINUS:	TLO	F,MF
	jrst plus

; + command

	block 8
	[asciz "+	does fullword integer addition (space does 18-bit truncated addition):
	2+2=4, 400000+400000=1,,0"]

PLUS:	TLO	F,PTF
	JRST	LIS2

; ( character

	block 8
	[asciz "(	starts a parenthetical expression, which will have its halves swapped
	when finished: (1,,2) = 2,,1.  Note that (x) will conveniently put x
	in the index register field of an instruction."]

LPRN:	CAML	P,[LPDL-4,,0]	;LEFT PARENTHESIS
	JRST	ERR
	PUSH	P,F		;RECURSE FOR OPEN PAREN
	PUSH	P,WRD
	PUSH	P,FRASE
	PUSH	P,FRASE1
	AOS	PRNC
	JRST	LIS

; @ character

	block 8
	[asciz "@	is not a command, but an assembler notation that sets the indirect bit
	of the instruction being assembled.  @ has a value equal to 20,,0"]

INDIRECT:
	movsi w,(@)		;get an @
	IORB	W,WRD		;or it in
	TLO	F,QF
	JRST	LIS2

	block 8
	[asciz |,	a single comma is normally used after the AC field of an instruction,
	like "MOVE 1,100".  It's exact action is to left-shift the pre-comma
	value 23. bits (into the AC field, for a user instruction), or 24.
	bits for an IO instruction.
,,	is used to separate halfwords.  val,, shifts val left 18 bits into
	the left half of the word.|]

ACCF:	MOVE	R,T		;COMMA PROCESSOR
ACCX:	XCT	ACCCF		;MOVEI T,"A" AS IN A,,B
	TLOE	F,COMF		;COMMA TYPED BEFORE?
	 JRST	ACCF1		;YES
	HRRM	R,ACCCF		;NO, SAVE LEFT HALF OF A,,B
	HLLZ	T,R
	LDB W1,[POINT 3,WRD,2]	;CHECK FOR IO INSTRUCTION
	IDIVI	W1,7
	LSH	R,27(W1)
	ADD	T,R
	ADDB	T,WRD
	JRST	SPAC1

ACCF1:	ADD	T,WRD		;SET LEFT HALF OF A,,B
	HRLZM	T,WRD
	JRST	SPAC1

;space command

	block 5
	[asciz ";space	retypes $Q in the current typeout mode."]
	block 2
	[asciz "space	space is used as a separator; it accumulates its value, truncated
	to 18 bits.  that is, 1 1 = 2, but 400000 400000 = 0"]

SPACE:	TLNE	F,QF
SPAC1:	 TLO	F,TIF
	TLZ	F,MF+PTF
	JRST	LIS1

; ) character

	block 8
	[asciz ")	finishes a parenthetical expression.  the value in parenthesis will
	have its halves swapped such that (1,,2) = 2,,1.  Note that (x) will
	conveniently put x in the index register field of an instruction."]

RPRN:	TLNN	F,QF
	  MOVEI	T,0
	MOVS	T,T
	SOSGE	PRNC
	  JRST	ERR
	POP	P,FRASE1
	POP	P,FRASE
	POP	P,WRD
	POP	P,F
	TLNE	F,PTF
	 TLNE	F,SF
	  JRST	RPRN1
	MOVEM	T,SYL
	TLO	F,QF+SF
	JRST	L1RPR

RPRN1:	ADDB	T,WRD
	TLO	F,QF
	JRST	L1A

; ;S --  SNARF SYMBOLS
;ARGUMENT IS ADDRESS CONTAINING POINTER TO TABLE
;ARG IS TAKEN AS JOBSYM IF NOT SUPPLIED

SNARF:	TLNN	F,QF		;ARG?
	  jrst [movei r,JOBSYM	;NO, DEFAULT
		push p,r	;save this
		call fetch0	;fetch absolute address
		  jrst err	;  failed
		jrst snarf0]
	call xtndpc		;turn into global address
	MOVE	R,T
	PUSH	P,R
	CALL	FETCH
	 JRST	ERR		;READ PROTECTED
snarf0:	JUMPGE	T,ERR		;BAD PTR
	TLNE	T,1		;MUST BE AN EVEN NUMBER LONG
	 JRST	ERR
	CALL	FLSSYM		;FLUSH OLD SYMBOL TABLE
	POP	P,R
	CALL	GTSYMS		;GET AND CHECK NEW TABLE
	JRST	DDT

; ;D - type out . and .+1 as a double-float
; $;D - print $Q as date&time
; $$;D - print $Q as unix-type 32-bit (left-justified) date&time

DATPRT:	tlnn f,cf		;$;D?
	  jrst dbltyp		;  no, just ;D
	PUSH P,T
	CALL LCT
	POP P,T
	MOVEI 1,.PRIOU
	TLNE F,QF
	  SKIPA 2,T		;Print argument if given
	    MOVE 2,LWT		;  else $Q
	tlne f,ccf		;$$;D?
	  jrst [lsh 2,-4	;  yes, unix-style, so right-justify
		call cvunxi	;  and to t20-internal
		jrst .+2]
	MOVSI 3,(OT%DAY)
	ODTIM
	JRST RETX

tmbdif==^D<365*<1970-1859>+72>  ; Time base difference (1858 vs 1970)

	; Given 32-bit unix time in AC2, converts to internal time in AC2
cvunxi:	push p,3
ifn 0,<
	idivi 2,^D<24*3600>	; 10X is very simple, it uses
	movsi 2,tmbdif(2)	; <# days>,,<# secs>
	hrri 2,(3)
	pop p,3
>;ifn tnx
ifn 1,<
	push p,4
	idivi 2,^D<24*60*60>	; Get # days in B, rem secs in C
	addi 2,tmbdif		; add time base difference
	mul 3,[1,,]		; This is how 20X converts # secs to internal.
	divi 3,^D<24*3600>
	cail 4,^D<24*3600>/2
	 addi 3,1
	movsi 2,(2)
	hrri 2,(3)		; now have internal format date in B.
	pop p,4
	pop p,3
>;ifn 20X
	ret

dbltyp:	call lct		;space over a bit
	move r,lloco		;.
	call fetch		;fetch value
	  jrst err		;  oops
	push p,t		;save it here
	move r,lloco		;.
	addi r,1		;.+1
	call fetch		;get second word of double
	  jrst err		;  oops
	movei 1,.priou		;output to terminal
	pop p,2			;first word of double
	move 3,t		;second word of double
	move 4,[fl%one+fl%pnt+fl%ovl+fld(^d17,fl%rnd)]
	DFOUT			;double float output
	  jrst err
	jrst retx

; ;N - Type arg or $Q as internet hostname

HSTPRT:	PUSH P,T
	CALL LCT
	POP P,T
	MOVEI 1,.GTHNS
	HRROI 2,STRBUF
	MOVE 3,T
	TLNN F,QF
	  MOVE 3,LWT
	GTHST
	 ERJMP hstpr0
	MOVEI W1,STRBUF
	CALL TYPE
	JRST RETX

hstpr0:	move w1,3		;assumed host# in w1 now
	movei 1,.priou
	movei 3,^d10		;decimal typeout
	ldb 2,[301000,,w1]	;get first octet
	NOUT			;type it
	  jfcl
	movei 2,"."
	BOUT
	ldb 2,[201000,,w1]	;get second octet
	NOUT			;type it
	  jfcl
	movei 2,"."
	BOUT
	ldb 2,[101000,,w1]	;get third octet
	NOUT			;type it
	  jfcl
	movei 2,"."
	BOUT
	ldb 2,[001000,,w1]	;get fourth octet
	NOUT			;type it
	  jfcl
	jrst retx

;  ;?  TYPE THE MOST RECENT ERROR STRING
; NUM;?  TYPE VALUE OF NUM AS ERSTR

SEM.QU:	PUSH	P,T
	CALL	CRF
	POP	P,T
	HRROI	1,STRBUF		;DUMP INTO STRING BUFFER FOR OUTPUT
	SETO	2,
	TLNE	F,QF
	  Jrst [Move 2,T
		Jumpl 2,.+1
		Caige 2,.ERBAS
		  Addi 2,.ERBAS
		Jrst .+1]
	HRL	2,FORK
	SETZ	3,
	ERSTR
	 JRST	SEMQU1		; No string for number
	 JRST	ERR
	SETZ	2,
	IDPB	2,1		;MAKE ASCIZ
	MOVE	W1,[POINT 7,STRBUF]
	CALL	TYPE		;COMMON OUTPUT ROUTINE
	JRST	DD1		;SO "OUTPUT TO FILE" WILL WORK

; No string for number
SEMQU1:	MOVE 1,FORK
	TLNN F,QF
	  GETER
	HRROI 1,[ASCIZ /No string for error /]
	PSOUT
	MOVEI 1,.PRIOU
	TLZ 2,-1
	MOVEI 3,10
	NOUT
	 JRST ERR
	JRST DD1

;REGISTER EXAMINATION LOGIC

;LLOCO  HAS CURRENTLY OPEN REGISTER. SET FROM C(LLOC) BY / ETC.
;LLOC   HAS CURRENT SEQUENCE. RESTORED FROM SAVLOC BY $LF ETC.
;SAVLOC HAS SAVED SEQUENCE. SET FROM LLOC BY TAB ETC.

;PRINT ADDRESS AND EXAMINE REGISTER
;ENTER HERE FROM TAB, ^, BS, LF, OR FROM $E, $N, OR $W

LI1b:	call xtndpc
	MOVEM T,LLOC
	MOVEM T,LLOCO
	INTON
	CALL PAD
	RET

LI1a:	CALL LI1b
	MOVEI T,")"
	CALL TOUT
	AOS (P)			;Skip return!
	JRST LI2

LI1:	CALL LI1b
	MOVEI	T,"/"
	CAME	SCH,SCHM		; TEMP MODE SAME AS PERM MODE?
	  JRST	LI3
LI4:	TLNE	F,STF
	 MOVEI	T,"!"
	CALL	TOUT

;ENTER HERE FROM /, [, ], !, \
;ADDRESS HAS BEEN PRINTED, EXAMINE CONTENTS

LI2:	TLZ	F,ROF		;CLOSE REGISTER(IN CASE OF SEARCHES ETC)
	call tdspc		;doublespace
LI2A:	MOVE	R,LLOCO
	CALL	FETCH		;fetch the contents
	 JRST	LINCR		;  failed, say "?"
	TLO	F,ROF		;REGISTER IS NOW OPEN
	TLNE	F,STF		;IN SUPPRESSED TYPE-OUT MODE?
	 JRST	DD2		;YES
	JRST	CONSYM		;GO PRINT IN PROPER MODE AND RET

LI3:	CAIN	SCH,FTOC	; NO, IF CONSTANT MODE
	 MOVEI	T,"["		; USE [
	CAIN	SCH,PIN		; IF SYMBOLIC MODE
	 MOVEI	T,"]"		; USE ]
	JRST	LI4

LINCR:	TLO	F,ROF		;PAGE NOT ASSIGNED, PRETEND WAS OPENED
	MOVEI	W1,"?"		;BUT TYPE OUT ?
	JRST	TEXT		;RETURN IS A POPJ

; ^J command

	block 7			;no $$, ;, or ;; variants
	[asciz "[n]$^J	deposit n in the open location, pop the ring buffer, and open the
	next location, ala .+1/"]
	[asciz "[n]^J	deposit n in the open location and open the next location, ala .+1/"]

LINEF:	CALL	DEPRA		;NEXT REGISTER
IFE KL20F,<			;LF WILL GENERATE CRLF (SEE SFCOC WORDS)
	CALL	CRN		;HE TYPE THE LINEFEED, JUST NEED CAR RET
>				;<LF><CR> CAUSES LOSSAGE ON SOME TERMINALS
	tlnn f,cf		;POP RING BUFFER?
	 skipa t,lloc		;  no, JUST CLOSE PATCH
	  call ptrb		;    yes, POP THE RING BUFFER
	aoja t,varrw1		;join common code

; ^ and
; ^H commands

	block 7
	[asciz "[n]$^H or [n]$^
	deposit n, pop the ring buffer, and open the previous location."]
	[asciz "[n]^H or [n]^
	deposit n and open previous location, ala .-1/"]

VARRW:	CALL	DEPRA
	CALL	CRF
	tlnn f,cf		;POP RING BUFFER?
	 skipa t,lloc		;  no, JUST CLOSE PATCH
	  call ptrb		;    yes, POP THE RING BUFFER
	SOS T			;PREVIOUS LOCATION
VARRW1:	and t,[ddtint!xpc]	;[NIC250] make sure it stays a real address
	INTON
	SETZM	PINFF		;DON'T PRINT AC AND/OR EFF ADR
	JRST	LI1		;DO THE EXAMINE

; ^M COMMAND

	block 7
	[asciz "[n]$^M	deposit n in the open location, close it, and pop the ring buffer."]
	[asciz "[n]^M	deposit n in the open location, then close it."]

CARR:	CALL	DEPRA		;CLOSE THE REGISTER
	TLNN	F,CF		;$CR  CHANGES SEQUENCE
	 JRST	DD1.5
	TLNE	F,CCF		;DOUBLE ALTMODE?
	 JRST	DD1.5		;YES, THAT IS ALL WE WANT TO DO
	CALL	PTRB		;ELSE POP THE RING BUFFER
	SETZM	PINFF		;NO LONG INSTRUCTION PRINT
	JRST	LI1		;PRINT THE LOCATION AND GO ON

; [ COMMAND -- OPEN AS A CONSTANT

	block 8
	[asciz "[	sets the temporary typeout mode to constant, then opens $Q ala /"]

OCON:	TLNE	F,QF		; QUANTITY TYPED?
	MOVEI	SCH,FTOC	; YES SET TEMPORARY MODE
	TRO	F,LF1+CF1	;OPEN AS CONSTANT
	JRST	SLASH

; ] COMMAND -- OPEN SYMBOLICALLY

	block 8
	[asciz "]	sets the temporary typeout mode to symbolic then opens $Q ala /"]

OSYM:	TLNE	F,QF
	MOVEI	SCH,PIN
	TRZ	F,CF1		;OPEN SYMBOLICALLY
	TROA	F,LF1

; !  COMMAND -- LIKE / BUT DOESN'T TYPE CONTENTS

SUPTYO:	TLO	F,STF		;SUPPRESS TYPEOUT
	jrst slash

; / COMMAND

	block 8
	[asciz "[n]/	slash is used to open a location.  if no location is specified,
	dot is opened."]

SLASH:	TLZ	F,STF		;TYPE OUT REGISTER
	call xtndpc		;extend the PC (user value in T)
	TLNN	F,QF		;WAS ANY QUANTITY TYPED?
	 JRST	SLAS1		;NO. DO NOT CHANGE MAIN SEQUENCE
	MOVE	R,LLOC
	MOVEM	R,SAVLOC	;ADDRESS TYPED; SAVE OLD SEQ.
	CALL	ATRB		;ADD THE LOCATION TO THE RING BUFFER
	TRNE	F,INTFLG	;ARG IS WITHIN IDDT?
	 TLO	T,(DDTINT)	;YES
	MOVEM	T,LLOC		;VALUE OF "."
SLAS1:	MOVEM	T,LLOCO		;TEMP VALUE OF "."
	SETZM	PINFF		;DON'T WANT LONG INSTRUCTION TYPEOUT
	JRST	LI2

; \ COMMAND -- LIKE / OR ! BUT DOESN'T CHANGE "."

	block 8
	[asciz "\	opens $Q like / does, but doesn't change the value of dot."]

ICON:	TLNN	F,ROF		;REGISTER OPENED?
	  JRST	SUPTYO		;NO. MAKE LIKE !
	CALL	DEPRS
	HRRZ	T,LWT
	JRST	SLAS1

; ^I -- SET LOC TO ADDRESS PART AND DO A / OPERATION

	block 5
	[asciz ";^I	open $Q as a fullword address, ala /"]
	0			;no $$^I
	[asciz "$^I	open the LH of $Q ala /"]
	[asciz "^I	open the RH of $Q ala /"]

TAB:	MOVE	R,LLOC		;CURRENT SEQUENCE
	movem	R,TEM		;IN CASE WE ARE IN PATCH MODE
	CALL	DEPRS		;OPEN REGISTER OF Q
	CALL	CRF
	MOVE	T,LLOC		;SET UP NEW SEQUENCE AND
	MOVEM	T,SAVLOC	;SAVE OLD SEQUENCE
	PUSH	P,R		;ADD THIS LOCATION TO RING BUFFER
	MOVE	R,T
	CALL	ATRB
	POP	P,R
	SETZM	PINFF		;DON'T PRINT AC OR EFF ADR
	MOVE	T,LWT
	trne f,semif		; ;tab?
	  jrst li1		;  yes, so do fullword tab.
	TLNE	F,CF		;$ BEFORE TAB?
	 MOVSS	T		;YES, USE LH THEN
	HRRZS	T		;NEW VALUE FOR .
	JRST	LI1

;HERE FOR PATCHING
;CONTROL-SHIFT-L FOR OPENING PATCH
;CONTROL-SHIFT-M FOR CLOSING PATCH
;LIKE ITS DDT, HUH?

	block 6
	[asciz "$$^\	remove the previously made patch."]
	0			;no $^\
	[asciz "[n]^\	deposit n in the open location, then open a patch area.  Use ^] to
	end the patch."]

NPTCH:	TRNE	F,SEMIF2
	 JRST	NPTCH2
	MOVSI	TT,(DDTINT)
	TDNE	TT,LLOC		;NOT NICE TO FOOL MOTHER IDDT!
	 JRST	ERR
	MOVE	W,[SQUOZE 0,PATCH]
	MOVEM	W,SYM
	CALL	EVAL		;FIND HIS PATCH SPACE
	  JRST [MOVE W,[SQUOZE 0,PAT..] ; Not there, try PAT..
		MOVEM W,SYM
		CALL EVAL
		  JRST [MOVEI T,50
			MOVEM T,DEFV
			CALL DEFIN	;GIVE HIM PATCH: AT 50
			MOVEI T,50	;ITS NOT SAVED, I GUESS
			JRST .+1]
		ADDI T,4	; Make it +4, so BPTs don't interfere
		JRST .+1]
	MOVE	R,LLOC
	MOVEM	R,PATLOC	;SAVE HIS CURRENT LOCATION
	MOVEM	T,PATPNT
	MOVEM	T,LLOC		;MAKE HIS CURRENT LOCATION BE PATCH
	MOVEM	T,LLOCO
	CALL	FETCH
	 JRST	ERR
	PUSH	P,T		;SAVE CONTENTS OF OLD LOCATION
	CALL	CRF
	MOVE	T,LLOC		;GET PATCH LOCATION IN T
	CALL	LI1		;PRINT THE LOCATION
	CALL	LCT
	MOVE	T,(P)
	CALL	CONSYM		;PRINT OLD VALUE
	POP	P,T
	MOVEM	T,WRD
	TLO	F,ROF+QF
	TRZ	F,SEMIF+SEMIF2
	JRST	QUAN1		;MAKE THIS CURRENT VALUE IF <CR> TYPED

; ^] - end patch

	block 6
	[asciz "[n]$$^]	is like $$^], but omits trailing JUMPAs after last instruction in
	the patch area."]
	[asciz "[n]$^]	deposits n in the open location, then closes the open patch,
	putting the patched instruction AFTER what was just deposited."]
	[asciz "[n]^]	deposits n in the open location then closes the open patch."]

NPTCH2:	PUSH 	P,T		; Save possible arg
	CALL	CRF
	TLNN	F,QF		; arg given?
	 JRST	NPTCH5
	MOVE	R,LLOC		; Yes, deposit it
	POP	P,T
	CALL	DEP
	 JRST	ERR
	AOSA	LLOC	
NPTCH5:	POP	P,T
	TLNN	F,CF+CCF	; $^[ or $$^[ ?
	 JRST	NPTCH3		; No
	MOVE	R,PATLOC	; Yes, retrieve patched-over instruction
	CALL	FETCH
	 JRST	ERR
	MOVE	R,LLOC
	CALL	PTPRT
	TLNE	F,CCF		; $$^[ ?
	 JRST	NPTCH4
	AOSA	R,LLOC
NPTCH3:	MOVE	R,LLOC
	MOVEI	W,2(R)
	PUSH	P,W		;SAVE NEW PATCH LOCATION
	MOVSI	T,(JUMPA 1,)
	HRR	T,PATLOC
	ADDI	T,1
	CALL	PTPRT
	ADDI	R,1
	ADDI	T,1
	CALL	PTPRT
NPTCH4:	MOVE	R,PATLOC	;GET OLD INSTRUCTION LOCATION
	MOVSI	T,(JUMPA 3,)
	HRR	T,PATPNT
	CALL	PTPRTN
	POP	P,DEFV		;GET NEW PATCH VALUE
	MOVE	W,[SQUOZE 0,PATCH]
	MOVEM	W,SYM
	CALL	DEFIN		;AND DEFINE IT SUCH
	MOVE	R,PATLOC
	MOVEM	R,LLOC
	MOVEM	R,LLOCO		;SET THE CURRENT LOCATION
	JRST	RETX

;IN R, THE LOCATION
;IN T, THE NEW VALUE

PTPRTN:	TDZA	W1,W1
PTPRT:	 SETO	W1,
	PUSH	P,W1
	PUSH	P,R
	PUSH	P,T
	MOVE	T,R
	CALL	LI1		;PRINT ADDRESS AND VALUE
	CALL	LCT		;THEN TAB
	MOVE	T,(P)
	MOVE	R,-1(P)
	CALL	DEP		;NEW DEPOSIT NEW VALUE
	 JRST	ERR
	CALL	CONSYM		;PRINT NEW VALUE
	SKIPE	-2(P)
	 CALL	CRF
	POP	P,T
	POP	P,R
	SUB	P,[1,,1]
	RET

;FLUSH ALL UnDEFINED SYMBOL REFERenCES TO THIS REGISTER.

DEPRA:	MOVE	R,SAVLOC
	TLNE	F,CF		;RESTORE OLD SEQUENCE IF $CR,$LF, OR
	 EXCH	R,LLOC		;IF $^ OR $BS WAS TYPED
	MOVEM	R,SAVLOC	;SETUP "NEW" OLD SEQUENCE
	TLNE	F,ROF		;IF REGISTER IS BEING CHANGED
	 TLNN	F,QF		;REMOVE ALL PREVIOUS UNDEFINED
	  JRST	DEPRS		;SYMBOL REFERENCES TO IT
	MOVE	R,ESTU
	MOVEM	W1,ESTU		;INCLUDE ALL #-D SYMS IN UNDEF TAB
DEPRA2:	JUMPGE	R,DEPRS
	HRRZ	W,1(R)
	CAMN	W,LLOCO
	 CALL	REMUN
	ADD	R,[2,,2]
	JRST	DEPRA2


;IF SOMETHING TYPED AND A REGISTER IS OPEN
;UPDATE THE OPEN REGISTER AND LWT
DEPRS:	MOVEM	T,LWT		;DEPOSIT REGISTER AND SAVE AS LWT
	MOVE	R,LLOCO		;QUAN TYPED IN REGIS EXAM
	TLZE	F,ROF		;TEST AND CLOSE REGISTER
	 TLNN	F,QF
	  RET
	CALL	DEP		;STORE AWAY
	 JRST	ERR		;CAN'T STORE
	RET

; = command

	block 8
	[asciz "=	equals retypes $Q as octal halfwords."]

EQUAL:	TRO	F,LF1+CF1	;=
	jrst psym0

; _ command

	block 8
	[asciz "_	retypes $Q in symbolic mode."]

PSYM:	TRZ	F,CF1		;@
psym0:	TRO	F,LF1
	SETZM	PINFF		;NEVER LONG INS PRINTOUT
	CALL	CONSYM
	JRST	RETX

;ROUTINE TO ADD ONE LOCATION TO THE RING-BUFFER - LOCATION IN R

ATRB:	PUSH	P,T
	AOS	T,RBPT		;GET NEW RING-BUFFER POINTER
	CAILE	T,LRB		;AT END OF BUFFER?
	 MOVEI	T,RB		;YES, LOOP TO BEGINNING
	MOVEM	T,RBPT		;UPDATE CURRENT POINTER
	MOVEM	R,(T)		;INSERT ADR IN RING-BUFFER
	POP	P,T
	RET

;ROUTINE TO "POP" THE RING-BUFFER, ADR RETURNED IN T
PTRB:	PUSH	P,R
	SOS	R,RBPT		;GET THE PREVIOUS LOCATION
	MOVE	T,1(R)		;THE WORD POINTED TO BY THE TOP OF THE STACK
	CAIGE	R,RB		;IF GONE TOO FAR,
	 MOVEI	R,LRB		; USE THE LAST LOCATION
	MOVEM	R,RBPT
	POP	P,R
	RET

;RADIX-50 SYMBOL PRINTER

R50PNT:	PUSH	P,T
	MOVEI	T,"$"
	CALL	TOUT
	POP	P,T
	LSH	T,-36		;RADIX 50 SYMBOL PRINTER
	TRZ	T,3
	CALL	TOC
	MOVEI	T,"&"
	CALL	TOUT
	SETZM	SVFB
	MOVEI	W1,LWT		;SETUP FOR SPT
	JRST	SPT

SIXBP:	hrroi w1,[asciz /$1'/]
	CALL	TYPE
	MOVNI	W2,6		;SIXBIT PRINTER
	MOVE	W1,LWT
	CALL PRTSIX
	MOVEI	T,"$"
	CALL	TOUT
	RET

PRTSIX:	MOVEI	T,0
	ROTC	T,6
	JUMPE	T,CPOPJ
	ADDI	T,40
	CALL	TOUT
	AOJL	W2,PRTSIX
	RET

;MODE CONTROL SWITCHES

; $T command

	block 4
	[asciz "$;T	only show the symbol table structure (program names and blocks),
	no symbols."]
	[asciz ";T	displays the entire symbol table.
blk;T	displays only the symbols in the block named blk."]
	[asciz "$$nT	permanently selects n-bit text typeout mode.  See $T for the choices
	of n."]
	[asciz "$nT	temporarily selects n-bit text typeout mode.  Pick one of:

	$5T	SQUOZE, same as $& mode
	$6	SIXBIT, same as $' mode
	$8T	Chaos 8-bit ASCII
	$9T	BCPL strings
	$36T	full-word character typeout mode."]
	0			;there is no "T" command

TEXO:	trnn f,q2f		;quantity given after escape?
	  jrst [movei r,textt	;  no, so assume 7-bit text
		jrst con0]	;  go do it.
	MOVE	T,WRD2
	SETZ R,
	CAIN T,^D36		;Word-characters
	  MOVEI R,TEXT36
	CAIN	T,9		;CHECK FOR $9T (BCPL STRINGS)
	  MOVEI	R,TEXT9
	CAIN	T,8		;CHECK FOR $8T (NETBUFS ETC)
	  MOVEI	R,TEXT8
	CAIN T,7		;Normal 7bit ASCIZ typeout
	  MOVEI R,TEXTT
	CAIN	T,6		;CHECK FOR $6T
	  MOVEI	R,SIXBP		;SET MODE SWITCH FOR SIXBIT
	CAIN	T,5		;CHECK FOR $5T
	  MOVEI	R,R50PNT	;SET MODE SWITCH FOR RADIX 50
	JUMPE R,ERR
	JRST CON0

; $H command

	block 2
	[asciz ";;H	halts IDDT and requests resetting by its superior."]
	block 2			;no ;$H or ;$$H
	[asciz ";H or ^Z
	halts IDDT."]
	[asciz "$$H	permanently selects halfword typeout mode, and retypes $Q."]
	[asciz "$H	temporarily selects halfword typeout mode, and retypes $Q."]
	0			;there is no "H" command

HWRDS:	movei R,HLFW
	jrst con0

; $F command

	block 4
	[asciz "n;;F	selects fork #n as the current fork."]
	[asciz ";F	displays the current Fork structure.
n;F	displays only fork #n."]
	[asciz "$$F	permanently selects floating-point output mode, and retypes $Q."]
	[asciz "$F	temporarily selects floating-point output mode, and retypes $Q."]
	0			;There is no "F" command

SFLOT:	MOVEI R,TFLOT		; $F
	JRST CON0

; $S command

	block 5
	[asciz "[n];S	Snarf symbols from inferior; n is the address of the symbol table
	pointer, which defaults to location 116"]
	[asciz "$$S	permanently selects symbolic typeout mode."]
	[asciz "$S	temporarily selects symbolic typeout mode."]
	0			;there is no "S" command

SYMBOL:	movei R,PIN
	jrst con0

; $C command

	block 6
	[asciz "$$C	sets the permanent typeout mode to octal halfwords, ala the [
	command.  In this mode, locations opened by IDDT are shown as
	loc[ instead of loc/."]
	[asciz "$C	sets the temporary typeout mode to octal halfwords, ala the [
	command.  In this mode, locations opened by IDDT are shown as
	loc[ instead of loc/."]
	0			;there is no "C" command

CON:	MOVEI R,FTOC
CON0:	HRRZM	R,SCH		;TEMPORARY MODE
	CALL TSPC
	JRST	BASE1

; $R - relative address mode

	block 4
	[asciz "$;R	displays the current RSCAN buffer contents."]
	[asciz ";R	prompts for a string, and sets the RSCAN buffer to it."]
	[asciz "$$R	permanently selects relative addressing typeout mode."]
	[asciz "$R	temporarily selects relative addressing typeout mode."]
	0			;there is no "R" command

RELA:	TRZE	F,Q2F
	  JRST	BASECH		;  Numeric arg...
	movei r,padso
	jrst absa0

; $A command

	block 5
	[asciz "[n];A	Shows the address space of the debugged process.  If page a is not
	specified, the entire address space is shown."]
	[asciz "$$A	sets the permanent typeout mode to numeric, in the current radix."]
	[asciz "$A	sets the temporary typeout mode to numeric, in the current radix."]
	0			;there's no plain "A" command

ABSA:	MOVEI R,TOC		; $A
absa0:	HRRZM	R,AR
BASE1:	MOVS	S,[SCHM,,SCH]	;MODE SWITCHES TO MEMORY
	TLNN	F,CCF
	 JRST	LIS1
	BLT	S,ODFM		;WITH $$, MAKE MODES PERMANENT
	JRST	RETX

;VARIOUS  R  COMMANDS
BASECH:	MOVE	T,WRD2		;$nR, CHANGE OUTPUT RADIX TO n
	CAIGE	T,2		;Minimum radix
	  JRST	ERR
	HRRZM T,ODF		;TEMPORARY RADIX CELL
	JRST CON		;Then act like $C

; SEMICOLON-SPACE COMMAND -- RETYPE ACCORDING TO CURRENT MODES

SEMSPA:	MOVEM	T,LWT
	JRST	@SCH

; $G command - go!

	block 6
	[asciz "$$mG	Starts the inferior at entry vector offset m, which defaults to 0."]
	[asciz "n$mG	Start the inferior at location n, and proceed m instructions before
	stopping.  n defaults to the programs starting address, and m to +inf."]
	0			;there is no "G" command

GO:	TLNN	F,CCF		;ONE <ESC> TYPED?
	 JRST	GOSET		;SETUP NEW START ADR OR START PROGRAM
	TRNE	F,Q2F		;TWO ESC'S TYPED
	 JRST	GO1		;USE ENTRY VECTOR
GOS1:	TLNE	F,QF
	 JRST	GO5		;ARG TYPED IN
GO0:	SETZM	WRD2
GO1:	TLNE	F,QF
	 JRST	ERR		;FOO$$3G  ??
	MOVE	1,FORK
	GEVEC
	HLRZ	1,2		;EV LENGTH
	JUMPE	1,ERR
	CAIL	1,10000		;SKIP IF TENEX EV (1 HAS LENGTH)
	 SKIPN	1,WRD2		;10/50, ALLOW ONLY $$0G
	  CAMGE	1,WRD2		;EV LENGTH > THAN REQUESTED INDEX?
	   JRST	ERR
	ADD	2,WRD2
	HRRZ	T,2		;ENTRY ADDR
	
GO3:	camle t,[xpc]		;[NIC254] range check address
	  jrst err		;[NIC254]   no good.
	move 2,pc		;[NIC254] get old pc
	and 2,[pcfl]		;just keep the flags
	ior t,2			;[NIC254] or in the old PC flags, giving the
	MOVEM	T,PC		;NEW PC
	MOVE	2,T
	TLNN	F,CCF
	 JRST	GO4

;ENTRY FROM $L ETC.
GO2:	MOVE	1,FORK
	CIS				;$$G COMMANDS CLEAR INTERRUPTS
	SETZM	USRPSI
	SETZM	USRPSI+1
	SETZM	USRPSI+2
	SETZM	USRPSI+3
GO4:	TLO	2,(1B5)			;INSIST ON USERMODE PC
	MOVEM	2,REALPC
	MOVE	TT,PCSTAK
	MOVEM	TT,PCSPTR		;NOT UNDER $X ETC ANY MORE
	TRZ	F,XEQ!CONDX
	CALL	CRF
	JRST	TOUSER

GO5:	TRNN	F,INTFLG		;DID ADDR CONTAIN AN INTERNAL SYMBOL?
	 JRST	GO3			;NO, DO THE $G
	JRST	ERR			;ATTEMPT TO GO INSIDE IDDT

;SETUP NEW START ADR, EXAMINE IT AS WITH ^N, BUT DO NOT START
GOSET:	TRNN	F,Q2F			;ARG TYPE AFTER <ESC>?
	 JRST	GOS1			;NOPE, IS NORMAL START THEN
	TRNE	F,INTFLG		;DID ADDR CONTAIN INTERNAL SYMBOL?
	 JRST	ERR
	TLNN	F,QF			;FOR ALT-0-G
	 JRST	GOSET1
GOSET2:	PUSH	P,T
	CALL	CRF
	POP	P,T
	movem	T,PC		;STORE NEW PC
	SETOM	PINFF		;LONG PRINTOUT
	JRST	LI1		;THEN EXAMINE AS IN ^N

GOSET1:	MOVE	1,FORK		;HERE FOR $<N>G
	GEVEC
	HLRZ	1,2		;EV LENGTH
	JUMPE	1,ERR
	CAIL	1,10000		;SKIP IF TENEX EV (1 HAS LENGTH)
	 SKIPN	1,WRD2		;10/50, ALLOW ONLY $$0G
	  CAMGE	1,WRD2		;EV LENGTH > THAN REQUESTED INDEX?
	   JRST	ERR
	ADD	2,WRD2
	HRRZ	T,2
	JRST	GOSET2


; ^L -- CLEAR THE SCREEN

	block 8
	[asciz "^L	clear the terminal's screen"]

CTRLL:	MOVEI	1,.PRIOU	;ENTER HERE FOR THINGS THAT BLANK INCIDENTALLY
	RFMOD			;CHANGE TO
	PUSH	P,2
	TRZ	2,TT%DAM	;BINARY MODE
	SFMOD
	GTTYP
	caig 2,mxttyp		;if beyond our table
	  skipn blnktb(2)	;  or no blanking possible
	    jrst dd1		;    then just emit a blank line
	HRROI	1,BLNKTB(2)	;GET RIGHT MAGIC
	PSOUT
	MOVEI	1,.PRIOU
	POP	P,2
	SFMOD
	JRST	DD1.5

BLNKTB:	REPEAT	4, <0>			; 0-3
IFE MIT,<
	BYTE	(7) "Z"-100,0		; 4 ADM3
>
IFN MIT,<
	BYTE	(7) 177,220-176,0	; 4 IMLACS
>
	BYTE	(7) 35,36,0		; 5 DM
	BYTE	(7) 33,"H",33,"J",0	; 6 HP2640
	REPEAT	4,<0>			; 7-10
	BYTE	(7) 33,"H",33,"J",0	; 11 VT50
	0				; 12
	BYTE	(7) 33,"(",177,0	; 13 LP
	0				; 14
	BYTE	(7) 33,"H",33,"J",0	; 15 VT52
mxttyp==.-blnktb

; $$^N -- FUNNY BUSINESS TO FIXUP BLOWING IT (^N INSTEAD OF $^N)
;IF AC GIVEN, USE (AC)
;IF ADDRESS GIVEN, USE CONTENTS OF THAT ADDRESS
;SO, IF IN UUO HANDLER, USE UUOH$$^N

CTRLNX:	MOVEI	W1,17		;USE AC 17 IF NOT SUPPLIED
	TLNE	F,QF		;ARGUMENT?
	 MOVE	W1,WRD		;ELSE USE HIS
	CAIG	W1,17
	 CAIGE	W1,0
	  JRST [ldb r,[xpcbp w1]	;GET the POINTER TO LOCATION IN CORE
		JRST CTLNX1]	;USE THIS ADDRESS
	move r,ac0(w1)		;GET VALUE OF AC
	skipg r			;global stack pointer?
	  tlz r,-1		;  no, so clobber count in LH
CTLNX1:	CALL	FETCH		;GET (P) OR EQUIVALENT
	 JRST	ERR
	jumpe t,err		;minor error checking
	TRZ	F,XEQ!CONDX
	tlz t,-1		;RH is return address
	call xtndpc		;turn into global addres
	SETZM	BPTFLG		;not a user breakpoint
	MOVE	R,PC
	MOVEM	R,REALPC	;SAVE PC
	and r,[xpc]		;keep only the PC part
	movem r,$ctrln		;save here
	PUSH	P,T		;SAVE ADDRESS FOR TEMP BP'S
	CALL	CRF		;REQUIRED CRLF
	call doset		;save the current world
	POP	P,R		;RESTORE THE ADDRESS,
	tro f,sstepf		;say we're single-stepping (of sorts)
	jrst jstan1		;insert temp breakpoints and go

; ^N -- ITS-LIKE SINGLE STEPPING

	block 6
	[asciz "$$^N	do the right thing after accidentally ^N'ing into a subroutine that
	you had intended to $$^N over."]
	[asciz "[n]$^N	single-step n times, n defaulting to 1, treating subroutine calls
	as a single instruction."]
	[asciz "[n]^N	single-step n times, n defaulting to 1"]

ctrln:	TLNE	F,CCF		;$$^N?
	 JRST	CTRLNX		;  yes
	setom	fctrln		; Fake a $y, and flag it as such
	tlnn	f, cf		; An <esc> turns $y fake to $j fake
	 troa	f, ystepf
	  trz	f, ystepf
	jrst	ctrlna

; $Y -- single step, just doing one instruction, special handling

	block 5
	[asciz "$;Y	yanks a data file.
n$;Y	yanks data file starting at page n.
n<m$;Y	yanks pages n through m of a data file."]
	[asciz ";Y	yank a file into memory, ala the EXEC's @GET command."]
	0			;no $$Y
	[asciz "[n]$Y	execute n instructions (n defaults to 1), with special simulation
	handling that i don't know anything about."]
	0			;there is no "Y" command

ystep:	tro f, ystepf
	jrst jstep0

; $J -- single step, interpretting subrs as single instrs
; num(foo)$J proceed until num instructions excecuted or value of
; foo changed foo$$J proceed until foo changed

	block 4
	[asciz ";;J	displays job status; username, job#, and TTY#, along with a ;F type
	fork display."]
	[asciz "[n];J	displays the status of JFN #n, or all JFNs if no n is given."]
	[asciz "m$$J	says to proceed until the value of m changes."]
	[asciz "$J	single step, intepreting subroutines as single instructions.
n(m)$J	says to proceed n instructions or until the value of m changes."]
	0			;there is no "J" command

jstep:	trz f,ystepf
jstep0:	setzm fctrln		;Losing output
ctrlna:	trz f,xeq!condx		;Not $x and for ddt
	setzm bptflg		;Any bpt will not be from user
	tlne f,ccf		;arg$$J
	  hrlos t		;  is like infinty(arg)$J
	tlnn f,qf!ccf		;No arg given?
	  movei t,1		;Just once
	jumpe t,jstep3		;0$j toggles verbose switch
	hrrzm t,stepct		;Number of times
	hlrz r,t		;Get location to write protect
	movem r,wrprot
	tlnn f,qf		;Quantity typed?
	  setzb	r,wrprot	;So $$J works after breakpoint
	move T,pc		;In case of breakpoint
	movem T,realpc
	PUSH P,R
	MOVE R,T
	SETZM CNXBPT
	PUSHJ P,BPCHK
	  SETOM CNXBPT
	POP P,R	
	jumpe r,jstep1		;None.
	call fetch		;Get contents
	  jrst err		;  oops
	movem t,wrcont		;Save it
jstep1:	call crf		;Always want a leading <CR><LF>
	tro f,sstepf		;Say we are single stepping
	ldb r,[XPCBP realpc]	;Get next instruction from user
 	call fetch		;Get it
	  jrst err		;  oops
	trne f,ystepf		;Need special handling?
	  jrst ystep2		;  no
	skipn fctrln		;$^N rather than $J?
	  jrst jstp1a		;  Nope, do it the wrong way
	call doset		;save current world
	movem r,$ctrln		;This is the PC
	addi r,1		;Initially, C(R) is C(REALPC)
jstan1:	call fetch
	  jrst jstp1b		;Failed, use normal, losing method
	tlce t,777000		;Find next reasonable instruction
	 tlnn t,774000		;0 < Opcode < 774
	  aoja r,jstan1		;No, keep looking
	tlc t,777000		;Return instruction to normal
	movei w1,3		;Put in three breakpoints
	movem w1,$ctins		;Also remember in memory in case of interrupts
jstan2:	movem r,$ctrln(w1)	;Location of breakpoint
	cain w1,3
	  jrst jstan3		;No need to do extra work if we have the ins
	call fetch
	  jrst jstanu		;Undo damage and use losing method
jstan3:	movem t,$ctins(w1)	;Save the instruction
	move t,[BPT]		; Then insert the breakpoint
	call dep
	  jrst jstanu		;Undo and use losing method
	sosle w1,$ctins		;Any locations left to do?
	  aoja r,jstan2		;Yup, so go to next one and proceed
	jrst touser		;Then start up user's program

jstanu:	call remtbp		;Remove any temp bpt's that are in
jstp1b:	call unset		;restore world
	ldb r,[XPCBP realpc]
	call fetch
	  jrst err
jstp1a:	call setesi		;Set up user's memory for xec
	jrst touser

;;
;;	Here when returning from a $^N or $$^N
;;

jstctn:	call remtbp		;remove temporary breakpoints
jstep2:	call unset		;pop back old situation
	addm tt,realpc		;Update user pc by delta (TT)
jstp2a:	move tt,realpc
	movem tt,pc
	skipe sstepv		; Verbose?
	  call jstep5		;   Yes, check things
	call jstep4		; In any case print the instruction
	sosg stepct		; More?
	  jrst jstpdd		; Back to ddt with no extra <CR>
	move r,wrprot		; Get new contents
	jumpe r,jstep1
	call fetch
	  jrst err
	camn t,wrcont		; Changed?
	  jrst jstep1		; No back for more
	move w1,[ascii /(WP)/]
	call text2
	ldb t,[XPCBP pc]
	call pad
	call lct
	move t,wrprot		; Type attempted new contents
	setzm pinff		;never print ac or eff adr
	call li1
	move r,wrprot
	move t,wrcont
	call dep		; Restore old contents (should we?)
	  jrst err
jstpdd:	call lct
	trz f,sstepf!ystepf	;not single-stepping anymore
	setzm cnxbpt
	jrst dd1.6

ystep2:	movem t,binstr		; Save instruction we are handling
	call proc12		; Do interpretation
	  jrst jstp1a		; Ok for regular handling
	jrst jstp2a		; Taken care of, see if more to do, etc.

jstep3:	setcmm	sstepv		; Toggle verbose switch
	ret			; And return

; Print out current instruction and save AC's and view reg for printing changes
jstep4:	push	p, t
	push	p, r
	ldb t,[XPCBP realpc]
	setzm	pinff		; Asumme quiet mode
	skipe	sstepv		; Is that the case?
	 setom	pinff		; No, print eff adr and/or ac
	call	li1		; Print out instruction
	move	t, [ac0,,ssacs]
	blt	t, ssacs+17	; Save user acs
	skipge	r, vaddr	; Anything in view cell?
	 jrst	jstp4a		; Nope
	hrrzs	r
	call	fetch
	 caia			; Forget it
	movem	t, ssacs+20	; Save it
jstp4a:	pop	p, r
	pop	p, t
	ret

; Print changes to AC's if fctrln is off, also print change to view reg
jstep5:	setz	t,
	skipe	fctrln		; Should we print changes?
	 jrst	jstp5z		; Nope, only do view register
jstp5a:	move	r, ac0(t)
	came	r, ssacs(t)	; Has it changed
	 call	jstep6		; Yes, say so
	caige	t, 17		; Done?
	 aoja	t, jstp5a
jstp5z:	skipge	r, vaddr	; Anything here?
	 ret
	hrrzs	r
	skipe	fctrln		; Next test only valid if not ^N
	 jrst	jstp5y
	caig	r, 17		; Is it an ac?
	 ret			; Yes, already done it
jstp5y:	call	fetch
	 ret
	camn	t, ssacs+20	; Changed?
	 ret
	move	r, vaddr
	setzm	pinff
	call	li1
	jrst	crf

; Print c(c(t)), a trailing <CR>, then return
jstep6:	push	p, t
	setzm	pinff
	call	li1		; Type out new contents
	call	crf
	pop	p, t
	ret

;Routine to remove temporary breakpoints -- for now, these are set up only
; by $^N and $$^N

remtbp:	skipge	$ctins		;Any temporary breakpoints?
	 ret			;Nope, return right away
	push p,tt
	movei w1,ntbpts		;Assume maximum number of breakpoints
	sub w1,$ctins		;Calculate actual number of things to undo
	setom $ctins		;reset this whether we succeed or not
	movei w2,$ctins+ntbpts
remtb1:	move r,$ctrln-$ctins(w2)	; Get address of instruction
	move t,(w2)		; And get the actual instruction
	call dep		; reinstate the original instruction
	  jrst err		;   oops!
	sosle w1		; any more to do?
	  soja w2,remtb1	;   yesssss.....
	pop p,tt
	ret

; $X COMMAND -- EXECUTE AN INSTRUCTION
; INSTRUCTION TO EXECUTE IS IN T

	block 5
	[asciz "[n];X	sets the current section to be n, which default to 0."]
	0			;no $$X
	[asciz "n$X	executes instruction n."]
	0			;there is no "X" command

XEC:	MOVE	R,T
	MOVEI	T,XRG		;IN CASE ITS A $X EXAMINE
	TLNN	F,QF		;WAS <INSTR> TYPED?
	 JRST	QUANIN		;NO, EXAMINE $X REGISTER
	MOVE	T,R
	CALL	SETESI		;SET UP USER'S MEMORY
	TRO	F,XEQ		;WE'RE IN A $X
	CALL	CRF
	JRST	TOUSER

;$X COMMAND COMPLETION
;PSEUDO BPT HIT
;TT HAS NUMBER OF SKIPS
XCOM:	MOVEI	W1,"$"
	CALL	TEXT
	SOJG	TT,.-2
	CALL	UNSET	;POP BACK TO PREVIOUS $X CONTEXT
	JRST	DD1

;GO TO USER.  PC SAYS WHERE.  XEQ, CONDX BITS SAY WHY.
;AND TELL WHERE TO RETURN IN IDDT

TOUSER:	CALL	UNMAP		;FLUSH THE USER'S PAGE.  user will run for
	TRNN	F,CONDX		;DDT'S PURPOSES, NOT HIS. THEREFORE, DON'T
	  CALL	INSRTB		;  PUT BPT'S BACK IN
	MOVEI	1,.PRIIN
	MOVE	2,SAVTTY
	SFMOD
	STPAR
	MOVE	2,SAVTT2
	MOVE	3,SAVTT3
	SFCOC
	MOVE	2,USRTB2
	MOVE	3,USRTB3
	MOVE	4,USRTB4
	STABS
	MOVE	1,SUBSYS
	TLNE	1,(77B5)	;Make sure name is meaningful
	 SETNM			;  RESTORE USER'S SUBSYSTEM NAME
	CALL	SETUSR		;SET STATE OF USER FORK FROM IDDT
TOUSR8:	MOVE	1,TPFORK
IFN KL20F,<
	TLO	1,(SF%CON)	;Continue the fork
	SFORK
	 erjmp err
>;IFN KL20F
	MOVE	1,TPFORK
	RFORK
	SETOM	USRFLG		;WE'RE NOW IN THE USER.
	skipe debug
	  jrst [hrroi w1,[asciz "D> User fork running"]
		call type
		call crf
		jrst .+1]
	INTON
	MOVE	1,TPFORK
WAITPC:	WFORK			;WAITPC HAD BETTER POINT TO THE WFORK (ADBRK)
	FFORK			;FREEZE IT IMMEDIATLY
	skipe debug
	  jrst [call terpri
		hrroi w1,[asciz "D> Returned from user"]
		call type
		call crf
		jrst .+1]
	JRST	TRAP		;FORK TERMINATED

IFN ADBRKF,<
;INFERIOR FORK TERMINATION INTERRUPT (OR FORCED FREEZE -- ADBRK)
FRKTRM:	PUSH	P,1
	PUSH	P,2
	MOVE	1,FORK
	RFSTS
	  ERJMP	FRKTR2		;IGNORE LOSSAGE HERE
	TLNN	1,(RF%FRZ)
	  JRST FRKTR2		;NOT FROZEN (IE NOT FORCED) WILL FALL THRU OK
	HRRZ	1,IPC1		;SEE WHAT WE WERE DOING
	CAIE	1,WAITPC
	 CAIN	1,WAITPC+1
	  JRST [movsi 1,(1b5)	;user-mode
		IORM 1,IPC1	;FORCE IT TO FALL THRU
		JRST FRKTR2]
FRKTR2:	POP	P,2
	POP	P,1
	DEBRK
>;ADBRKF

;BREAK POINT LOGIC

;HERE WHEN BPT HIT.  T POINTS AT PRIVATE BLOCK FOR THE BPT

;PRIVATE BLOCK FORMAT IS:
.BADDR==0		;ADDR. WHERE BPT SET
.BSKIP==1		;0 OR CONDITIONAL BREAK SKIP INSTR.
.BPCNT==2		;PROCEED COUNT
.BSPTR==3		;0 OR STRING POINTER, FED TO DDT WHEN BPT HIT
.BSAVI==4		;SAVED INSTRUCTION WHILE USER IS RUNNING
.BAUTO==5		;0 OR ELSE -1 IF AUTO-PROCEED
.BNAME==6		;ASCIZ NAME OF THIS BPT, LIKE $3B
.BFORK==7		;RH HAS FORK IN WHOSE ADR SPACE THE BPT IS SET
.BTRACE==10		;TRACE EXP.

BCOM:	MOVEM	T,BPTFLG	;INDICATE WHICH BPT WE'RE AT
	SKIPE	CNXBPT
	  JRST	BCOM3

;ARE WE GOING TO BREAK?

BCOM1:	SKIPE	W1,.BSKIP(T)	;DOES A CONDITIONAL INSTRuction EXIST?
	 CALL	DOCNDX		;yes, DO THE CONDITIONAL IN THE USER
	  SOSG	TT,.BPCNT(T)	;decrement THE PROCEED COUNT.
	   JRST	BREAK		;user conditional skipped or no proceed.
BCOM3:	SETZM	CNXBPT		;DON'T BREAK, PROCEED
	MOVE	T,.BSAVI(T)	;get back saved instruction
	JRST	PROCX

BCOM2:	MOVE	T,.BSAVI(T)	;THE BREAK INSTRUCTION
	JRST	PROC1

;DO THE CONDITIONAL BREAK INSTRUCTION FOR THE USER

DOCNDX:	MOVE	T,.BSKIP(T)	;GET THE INSTRUCTION
	CALL	SETESI		;setup to execute the instruction
	TRO	F,CONDX		;flag WHY WE'RE GOING TO USER
	JRST	TOUSER		;go do it, RETURNs FROM USER HERE:

;TT HAS THE NUMBER OF SKIPS
CONCOM:	TRNN	TT,1		;ONLY THE LOW BIT COUNTS
	  AOS	0(P)		;MAKE DOCNDX SKIP
	CALL	UNSET		;POP BACK TO PREVIOUS CONTEXT
	MOVE	T,BPTFLG	;GET BACK WHICH BPT WE'RE AT
	RET

;WE'RE REALLY BREAKING

BREAK:	PUSH	P,T		;POINTER TO BPT PRV BLK
	CALL	CRF		;NEED A LEADING CRLF WHEN BREAKING
	MOVE	T,(P)
	TDZ	F,[-1,,-1-XEQ]	;CLEAR ALL FLAGS EXECPT XEQ
	MOVE	2,FORK		;which fork broke
	CAMN	2,TPFORK	;same as the top fork?
	  JRST	BREAKT		;  yes.
	movei t,"("		;no, so let's type out
	call tout		;a process handle thing,
	MOVEI	1,.PRIOU	;to show which one broke.
	MOVEI	3,^d8
	ANDI	2,77		;display the last 6 bits of the PH
	NOUT
	  JFCL
	movei t,")"
	call tout

BREAKT:	move t,(p)		;restore break-block pointer
	move w1,.bname(t)	;ASCIZ NAME OF BREAK POINT -- "$3B" etc
	call text2		;PRINT IT
	movsi w1,(asciz ">")	;TYPE > FOR COND BREAK
	skipg .bpcnt(t)		;PROCEED COUNTER?
	  movsi w1,(asciz ">>")	;  TYPE >> FOR PROCEED COUNTER BREAK
	call text2		;type it
	MOVE	W1,LLOC		;SAVE CURRENT SEQUENCE
	MOVEM	W1,SAVLOC
	PUSH	P,R
	ldb r,[xpcbp pc]	;current PC
	call atrb		;save it on the ring
	MOVE	R,W1
	CALL	ATRB		;ADD PREVIOUS LOCATION TO RING BUFFER
	POP	P,R
	move T,PC
	movem T,LLOC		;SET CURRENT SEQ TO BREAK ADR
	SETOM	PINFF		;also open and display AC and EA
	CALL	LI1		;TYPE PC AT BREAK
	move w1,(p)		;get back pointer to break block
	skipn .btrace(w1)	;there a trace location?
	  jrst break1		;  nope.
BREA1A:	CALL	LCT		;PRINT TAB
	move t,.btrace(w1)	;get the location
	SETZM	PINFF		;DON'T PRINT EFF ADR AND/OR AC
	CALL	LI1		;EXAMINE REGISTER C($NB)LEFT
BREAK1:	POP	P,T		;GET BPT BLK PTR BACK
	skipn .bauto(t)		;SKIP IF AUTO
	  JRST	RETB		;  DONT PROCEED
BREAK2:	MOVEI	TT,2		;1 FOR SOS AT BCOM1, 1 FOR
	ADDB	TT,.bpcnt(t)	;PROCEEDING
	JUMPGE	TT,BREAK3	;NOT AUTOPROCEEDING ANYMORE
	CALL	CRF
	JRST	PROC0		;DO THE PROCEED

BREAK3:	SETZM	.bauto(t)	;CLEAR AUTO PROCEED
RETB:	SKIPE	T,.bsptr(T)	;START UP DDT, T POINTS AT BPT BLK
	HRLI	T,(<POINT 7,0>)	;IS THERE A COMMAND STRING?
	MOVEM	T,STRING
	JRST	RETX

;<NUM>$P -- PROCEED THROUGH THIS BPT NUM TIMES
;<NUM> IN T (IF ANY TYPED IN)

	 block 6
	[asciz "$$P	Like infinity$P, proceed through this breakpoint without stopping."]
	[asciz "$P	proceeds from a breakpoint.
 n$P	proceed from a breakpoint n times."]
	0			;there is no "P" command

PROCED:	MOVE	TT,T		;SO T CAN POINT TO BPT BLK
	CALL	CRF
	SKIPN	T,BPTFLG	;PROCEEDING FROM BPT?
	  JRST	TOUSER		;  NO. JUST RUN HIM AT HIS PC.
	TLNE	F,QF		;WAS AN ARG TYPED IN?
	  JRST	PROCD3		;  YES, USE IT.
	MOVEI	TT,1		;NO, ASSUME 1
	TLNE	F,CCF		;IF $$P
	  MOVSI	TT,200000	;  THEN VERY LARGE COUNT
PROCD3:	TLNE	F,CCF		;IF AUTOPROC
	  MOVNS	TT		;  NEGATE
	MOVEM	TT,.bpcnt(T)	;STORE COUNT FOR THIS BREAK IN $<N>B+1
	SETZM	.bauto(T)	;ASSUME NOT AUTOPROCEED
	TLNE	F,CCF		;$$P?
	  SETOM	.bauto(T)	;  IT IS AUTOPROCEED

;ENTER HERE FROM AUTOPROCEED

;USER MAY HAVE CHANGED THE CONTENTS OF THE BREAK
;LOCATION BETWEEN THE TIME THE BPT WAS HIT AND THIS $P
PROC0:	move r,bptflg		;address of break block which hit
	move r,.baddr(r)	;get the address of the breakpoint
	CALL	FETCH		;GET INSTRUCTION TO PROCEED FROM
	  JRST	ERR

;PROCX. ENTER HERE FROM FUNNY ALT-CONTROL-N HACK
PROCX:	MOVEM	T,BINSTR
	MOVEI	1,.FHSLF
	RWM
	JUMPGE	1,PROC12
	JRST	PROC1A

;ENTER HERE FROM NON-BREAKING BPT HIT
PROC1:	MOVEM	T,BINSTR	;INSTRUCTION TO LEAVE FROM
	MOVEI	1,.FHSLF
	RWM			;SEE IF RUBOUT INTERRUPT WAITING
	JUMPGE	1,PROC14	;NO, KEEP AUTOPROCEEDING
PROC1A:	INTON
	WAIT			;LET IT RIP

PROC14:	TRZ	F,SSTEPF!YSTEPF	;NOT SINGLE STEPPING
PROC12:	MOVEI	S,100		;MAX @ DEPTH ALLOWED FOR EA CALCULATION
	MOVEM	S,TEM1
	LDB W1,[POINT 9,T,8]	;OPCODE.
	LDB W2,[POINT 4,T,12]	;GET AC FIELD
	CAIE	W1,<XCT>/1B8
	 CAIN	W1,<PUSHJ>/1B8
	  JRST	IXCT1		;CALCULATE EA AND INTERPRET
	CAIE	W1,<JSR>/1B8
	 CAIN	W1,<JSA>/1B8
	  JRST	IXCT1
	CAIE	W1,<JSYS>/1B8
	 CAIN	W1,<JSP>/1B8
	  JRST	IXCT1
	TRNN	W1,700
	  JRST	IUUO
	TRNN	F,YSTEPF	;SINGLE STEPPING?
	  JRST	PROC2		; NO, ENUF INTERPRETATION
	CAIE	W1,<POPJ>/1B8
	 CAIN	W1,<JRA>/1B8
	  JRST	IXCT1
	CAIE	W1,<AOBJN>/1B8
	 CAIN	W1,<AOBJP>/1B8
	  JRST	IXCT1
	CAIE	W1,<JFFO>/1B8
	 CAIN	W1,<JRST>/1B8
	  JRST	IXCT1
	ANDI	W1,770		; REMOVE LOW 3 BITS OF OPCODE
	CAIE	W1,<AOJ>/1B8	; AOJ-SOMETHING
	 CAIN	W1,<SOJ>/1B8
	  JRST	IXCT1
	CAIN	W1,<JUMP>/1B8	; SOME FLAVOR JUMP
	 JRST	IXCT1

;USE THE HARDWARE TO INTERPRET ALL ELSE.  T HAS THE INSTRUCTION.  Deposits
;three double-PCs, then the instruction to proceed from, then three XJRSTFs
;to the double PC words, then starts the user at the proceed-from instr.

PROC2:	TRNE	F, YSTEPF	; ARE WE SINGLE STEPPING?
	 RET			; YES, GIVE SINGLE RETURN
proc3:	call effadr		;calculate EA of instruction
	  jfcl			;don't care if direct or indirect
	move r,xrg		;LOCATION OF $X REGISTER
	push p,t		;save the instruction
	move t,w1		;EA from effadr
	call dep		;deposit the global EA
	  jrst err		;  failed
	movei s,3		;how many XJRSTF blocks we need
	move t,pc		;get the pc word
proc4:	addi r,1		;step to next patch location
	addi t,1		;point to next loc after instruction
	push p,t		;save a copy of the pc
	and t,[pcfl]		;keep only the flags
	call dep		;deposit the first word of the double PC
	  jrst err		;  oops
	move t,(p)		;get back the pc
	and t,[xpc]		;this time keep only the global pc part
	addi r,1		;step to next patch location
	call dep		;deposit word 2 of the double PC
	  jrst err		;  ooops!
	pop p,t			;restore the pc
	sojg s,proc4		;put them all in.
	pop p,t			;get back the actual instruction
	and t,[777740,,0]	;keep only the opcode and AC field
	tlo t,(@)		;make it an indirect
	hrr t,xrg		;first patch location is where global EA is
	addi r,1		;get to the next patch location
	call dep		;deposit the hacked-up instruction
	  jrst err		;  oopsie
	MOVEI	S,3		;put this many jumps afterwards.
	move t,xrg		;the second word of the patch area is
	addi t,1		;where the first double-pc is
	hrli t,(XJRSTF)		;make an XJRSTF to point to it
proc5:	addi r,1		;step to next patch location
	call dep		;deposit the XJRSTF
	  jrst err		;  gosh
	addi t,2		;point to next double PC
	sojg s,proc5		;and put in the next XJRSTF
	move r,pc		;get the pc
	and r,[pcfl]		;keep only the flag bits.
	tlo r,(1b5)		;BE SURE IT'S USERMODE
	ldb t,[xpcbp xrg]	;patch area location (sec-relative part)
	add r,t			;add in the patch area location
	addi r,7		;skip past the 3 double PCs & instrs global EA
	MOVEM	R,REALPC	;WHAT FORK'S PC SHOULD BE
	JRST	TOUSER

;THESE ROUTINES INTERPRET PC SAVING INSTRUCTIONS.

;R POINTS TO THE INSTRUCTION
;T,BINSTR HAVE THE INSTRUCTION
;W1 HAS THE OP CODE
;W2 HAS AC FIELD

;INTERPRET UUO
IUUO:	JUMPE	T,PROC2		;ILLEGAL INSTRUCTION
	CAIL	W1,40
	  JRST	PROC2		;DEC 10/50 UUO, USE HARDWARE.
	MOVEI	R,40
	CALL	DEP
	  JRST	ERR
	MOVEI	R,41		;NOW EXECUTE LOCATION 41.

;INTERPRET XCT
IXCT:	SOSL	TEM1		;TOO MUCH @'ING?
	CALL	FETCH		;CODE PROTECTED?
	 JRST	ERR		;YES.
	MOVEM	T,BINSTR

;GET EFFECTIVE ADDRESS
IXCT1:	MOVE	T,BINSTR	;THE INSTRUCTION
	call	eff2		; Evaluate effective address
	 jrst	err

;CHECK XCT'D OR UUO'D INSTRUCTION TO SEE IF IT MUST BE INTERPRETED.

IXCT3:	HRRZS	W1
	DPB W1,[POINT 23,BINSTR,35]	;SMASH WITH EA
	LDB W2,[POINT 4,BINSTR,12]	;AC FIELD
	LDB W1,[POINT 9,BINSTR,8]	;GET OP. CODE
	MOVE	T,BINSTR		;GET INSTR WITH EA COMPUTED
	CAIN	W1,<PUSHJ>/1B8
	  JRST	IPUSHJ
	CAIN	W1,<JSR>/1B8
	  JRST	IJSR
	CAIN	W1,<JSA>/1B8
	  JRST	IJSA
	CAIN	W1,<JSP>/1B8
	  JRST	IJSP
	HRRZ	R,BINSTR
	CAIN	W1,<JSYS>/1B8
	  JRST	IJSYS
	CAIN	W1,<XCT>/1B8
	  JRST	IXCT
	TRNN	W1,700
	  JRST	IUUO		;ANOTHER ONE.  TEM1 WILL RUN OUT.
	trnn	f, ystepf	; More interpretation needed?
	  JRST	PROC2		;OK, USE HARDWARE
	cain	w1, <popj>/1b8
	 jrst	ipopj
	cain	w1, <jra>/1b8
	 jrst	ijra
	caie	w1, <aobjn>/1b8
	 cain	w1, <aobjp>/1b8
	  caia
	cain	w1, <jffo>/1b8
	 jrst	[push	p, w1
		 jrst	ijumps]
	cain	w1, <jrst>/1b8
	 jrst	ijrst
	push	p, w1
	andi	w1, 770
	caie	w1, <aoj>/1b8
	 cain	w1, <soj>/1b8
	  jrst	ijumps
	cain	w1, <jump>/1b8
	 jrst	ijump
	pop	p, w1
	jrst	proc2

;INTERPRET JSYS

IJSYS:	CAIGE	R,1000		;USER JSYS?
	 JRST	PROC2		;NO.  MONITOR-CALLING TYPE
	CALL	FETCH		;GET RETPTR,,JUMPADDR
	 JRST	ERR
	PUSH	P,T
	HRLZ	R,T		;WHERE TO STORE PC,,FLAGS
	AOS	T,PC		;RETURN ADDRESS FOR JSYS
	CALL	DEP
	 JRST	ERR
	POP	P,R		;WHERE TO JUMP TO
	JRST	IPJ2

; Compute effective address 
; Instruction in T, returns eff adr in W1 and contents of
; Effective address in T if 1st instruction used an indirect reference

effadr:	movei	w1, 100
	movem	w1, tem1	; Maximum indirection count
eff2:	setz w1,		;w1 is where we'll make the EA
	push p,w2		;use w2 as a temp
	ldb w2,[point 4,T,17]	;Get index register field
	skipe w2		;there an index register?
	  hrrz w1,ac0(w2)	;  yes, fetch the local part of (X)
	addi w1,(t)		;sum in the E field
	tlz w1,-1		;clobber carries
	skipe cursec		;section 0?
	  skipn w2		;  or no X register
	    jrst eff2a		;    don't do this
	ldb w2,[xsecbp ac0(w2)]	;get the section#
	dpb w2,[xsecbp w1]	;install it in the EA
eff2a:	pop p,w2		;done with w2 now
	tlnn t,(@)		;Indirection?
	  jrst [aos (p)		;  no, skip return later
		jrst eff3]	;  but still globalize.
	move r, w1		;yes, so r/ EA
	sosl	tem1		;Too  much indirection?
	 call	fetch		;Get contents
	  skipa			;Error of some sort
	jrst	effadr		;Back for more
eff3:	tlnn w1,37		; did we get a global address?
	  skipn cursec		;  or is this section 0?
	    ret			;   either or, so we're done
	hrl w1,cursec		; make this local addr into a global one
	ret

;turn the instruction given in T's I,X,Y into a Global Indirect Word in W1
;where Y is extended to point to the current section.

makgiw:	setzm tem1		;reset @-count so doesn't chase chain
	call eff2		;compute EA, but stop before indirection
	  jfcl			;  don't care if had indirection or not
	tlne t,(@)		;indirect bit set?
	  tlo w1,(1b1)		;  yes, so propagate to GIW in right place
	ret			;return GIW in w1

;INTERPRET PUSHJ

IPUSHJ:	MOVE	T,AC0(W2)	;USER'S PUSH POINTER
	skipl TT,T		;SAVE UN-GUNCHED POINTER
	  jrst [addi t,1	;  global, so bump RH
		xor tt,t	;  now let's see what happened to the LH
		tlne tt,-1	;  if any bits changed,
		  jrst ipj3	;    then sec-PDL overflowed
		jrst ipj1]	;  else it was OK
	AOBJN	T,.+1
	XOR	TT,T		;SEE IF SIGN CHANGED
	JUMPL	TT,IPJ3		;JUMP IF SO
IPJ1:	MOVEM	T,AC0(W2)	;update it
	skipg t			;global?
	  jrst [tlz t,-1	;  no, local, so clobber count
		call xtndpc	;  and then turn it into a global
		jrst .+1]
	move r,t		;where pdl points to
	AOS	T,PC		;data is return address, the next location
	CALL	DEP		;DO PUSH FOR HIM
	 JRST	ERR		;PROTECTED
	hrrz t,binstr		;EA OF PUSHJ
	call xtndpc		;globalify it
	move r,t		;put it in r
IPJ2:	move t,pc		;old pc
	and t,[pcfl]		;keep only the flags
	ior r,t			;or in the old flags
	TLO	R,(1B5)		;MUST BE USERMODE
	MOVEM	R,REALPC	;TOUSER WILL DO SFORK
	trne	f, ystepf	;Single stepping?
	 jrst	cpopj1		;  Yes, give double return (taken care of)
	JRST	TOUSER

IPJ3:	MOVE	1,FORK
	MOVSI	2,(1B9)
	IIC			;GOOSE USER'S CHN, LET HIM TRAP IT
	JRST	IPJ1		;DOES INT HAPPEN BEFORE PUSHJ????

ipj4:	ldb r,[xpcbp pc]	;get new pc
	jrst ipj2

;INTERPRET JSA
IJSA:	AOS	T,PC
	HRL	T,BINSTR		;FORM  EA.RET
	EXCH	T,AC0(W2)
	JRST	IJSR2

;INTERPRET JSR
IJSR:	AOS	T,PC
IJSR2:	HRRZ	R,BINSTR
	CALL	DEP
	 JRST	ERR
	AOSA	R,BINSTR
IJSR3:	hrrz t,binstr
	call xtndpc
	move r,t
IJSR4:	JRST	IPJ2

;INTERPRET JSP
IJSP:	AOS	W,PC
	MOVEM	W,AC0(W2)
	JRST	IJSR3
; Interpret popj
ipopj:	move	r, ac0(w2)	; Get pushdown pointer
	skipg r			; global?
	  tlz r,-1		;  no, local, so clobber LH
	call	fetch
	 jrst	err
	movem	t, pc
	move	t, ac0(w2)	;get the PDL ptr
	subi t,1		;back up address
	skipg t			;global?
	  sub t,[1,,0]		;  no, local, so adjust count also
	movem	t, ac0(w2)
	jrst	ipj4

; Interpret jra
ijra:	hrrz	t, binstr	;get the local address
	call xtndpc		;turn into full global address
	dpb t,[xpcbp pc]	; Pc_Ea
	hlrz	r, ac0(w2)	; Get ac
	call	fetch
	 jrst	err
	movem	t, ac0(w2)	; Restore ac
	jrst	ipj4

ijrst:	hrrz t, binstr		;get local address of where to JRST do
	call xtndpc		;turn into full global address
	dpb t,[xpcbp pc]	;make that the new pc
	jrst ipj4

; Interpret jumps, aobjn, aobjp, jffo, aojs, sojs, etc.

ijump:	move t,binstr		;get the instruction
	and t,[777740,,0]	;keep only the opcode and ac field
	camn t,[erjmp]		;is this an erjmp
	  jrst ierjmp		;  yesss...
	camn t,[ercal]		;ercal?
	  jrst iercal		;  yessss...
ijumps: movei	t, t
	move r, binstr			; Get instruction
	and r,[pcfl]			; just keep the flags.
	dpb	t, [point 4, r, 12]	; Substitute t for original ac
	hrri	r, ijump2		; Substitute for ea
	move	t, ac0(w2)		; Get real user ac
	xct	r			; Ha Ha!
	aos	pc			; Didnt jump, so increment pc
	jrst	ijump3

ijump2:	move	r, binstr		; Get ea
	and r,[xpc]			; just just the addr, not the flags
	movem	r, pc			; Fake jump
ijump3:	movem	t, ac0(w2)		; Update ac
	pop	p, t
	cain	t, <jffo>/1b8
	 movem	w1, ac0+1(w2)		; Update ac+1 for jffo
	jrst	ipj4

; interpret erjmp and ercal

ierjmp:	pop p,(p)		;flush saved opcode
	skipe ilitrp		;was last instruction ili or whatever?
	  jrst ijrst		;  yes.  treat it as a abs jump -- jrst
ierjm0:	aos pc			;no, so it's a no-op, so no jump
	jrst ipj4		;continue...

iercal:	pop p,(p)		;flush saved opcode
	skipn ilitrp		;was last instruction ili or whatever?
	  jrst ierjm0		;  nope...
	jrst ipushj		;yes.  treat it as a subr call -- pushj 17,

;INSERT BREAKPOINTS

INSRTB:	MOVEI	W1,BPTS
	PUSH	P,FORK		; SAVE CURRENT FORK
INSRT1:	skipn r,.baddr(w1)	;this one in use?
	  jrst insrt3		;  no
	move 1,.bfork(w1)	;no.  GET THE PERTINENT FORK
	call setfrk		;select that fork.
	  jrst [setzm .baddr(w1)	; FORK HAS GONE, CANCEL BPT
		jrst insrt3]
	CAIN	R,$CTRLN	;THIS WHERE THE TEMPORARY BREAKPOINT GOES?
	 JRST	INSRT3		;YES, DON'T INSERT THE BREAKPOINT
	CALL	FETCH		;GET THE USER'S INSTRUCTION
	 JRST	INSRT4		;PAGE IS READ PROTECTED.  ABORT.
	MOVEM	T,.bsavi(W1)	;save the user instruction here
	MOVE	T,[BPT]		;and replace it with a BPT
	CALL	DEP		;STUFF IT INTO THE USER
	 JRST	INSRT5		;PAGE IS WRITE PROTECTED
INSRT3:	ADDI	W1,NBPTV	;MOVE TO NEXT BPT
	CAIE	W1,<BPTS+<NBP*NBPTV>>
	 JRST	INSRT1
	POP	P,1
	CALL	SETFRK		; BACK TO ORIGINAL FORK
	 JFCL
	RET

INSRT4:	SKIPA	1,[POINT 7,[ASCIZ /?Can't read instruction under breakpoint /]]
INSRT5:	  MOVE	1,[POINT 7,[ASCIZ /?Can't insert breakpoint /]]
	PUSH	P,W1		;SAVE BPT BLOCK PTR
	MOVE	W1,1		;SETUP FOR TYPE
	CALL	TYPE
	MOVE	A,0(P)
	SUBI	A,BPTS		;GET BACK THE NUMBER
	IDIVI	A,NBPTV
	ADDI	A,1
	CALL	TOC5		;PRINT NUMBER AND PERIOD.
	POP	P,W1		;RESTORE THE BPT BLOCK POINTER
	POP	P,FORK		;GIVE REMOV0 SOMETHING TO PUSH
	CAIE	W1,BPTS		;ANY NEED REMOVING?
	 CALL	REMOV0		;YES
	JRST	ERR

;REMOVE BREAKPOINTS

REMOVB:	MOVEI	W1,<BPTS+<NBP*NBPTV>-NBPTV>	;ADDR OF LAST BPT
REMOV0:	PUSH	P,FORK		; SAVE CURRENT FORK
REMOV1:	skipn r,.baddr(w1)	;get address of breakpoint
	  jrst remov2		;  not is use
	move 1,.bfork(W1)	;fork for this breakpoint
	call setfrk		; SWITCH TO THIS FORK
	  JRST [setzm .baddr(W1)	; FORK GONE. CANCEL BPT
		JRST REMOV2]
	move t,.bsavi(w1)	;SAVED INSTRUCTION
	CALL	DEP		;put it back!
	 JRST	REMOV3		;WRITE PROTECTED PAGE
REMOV2:	SUBI	W1,NBPTV	;MOVE TO NEXT BPT
	CAIL	W1,BPTS		;DONE ALL?
	 JRST	REMOV1		;NO
	POP	P,1
	CALL	SETFRK
	 JFCL
	RET

REMOV3:	PUSH	P,W1
	hrroi w1,[asciz /?Can't remove breakpoint /]
	CALL	TYPE
	MOVE	A,0(P)
	SUBI	A,BPTS
	IDIVI	A,NBPTV
	ADDI	A,1
	CALL	TOC5
	CALL	CRF
	POP	P,W1
	JRST	REMOV2

; $B COMMANDS OF FORM <A>$<N>B

;A$NB  A$B  $NB  $B

	block 2
	[asciz ";;B	shows the current address break."]
	block 2			;no $;B or $$;B
	[asciz ";B	lists the current breakpoints (and address break)"]
	[asciz "$$B	removes all breakpoints."]
	[asciz "$B	deletes the current breakpoint.
n$mB	sets breakpoint #m at location n.  If m is not given, the first
	available breakpoint is used.
0$mB	removes breakpoint #m."]
	0			;there is no "B" command

BPS:	TLNE	F,QF
	  JRST	BPS1		;A$NB OR A$B
	TRNE	F,Q2F
	  JRST	BPS2		;$NB

;$B OR $$B -- DELETE BREAK POINTS

	TLNN	F,CCF		; $$B ?
	  JRST	BPS0		; No, remove current breakpoint
	CALL	FLSBPT
	JRST	RETX

;$B - DELETE CURRENT BREAKPOINT
BPS0:	SKIPN T,BPTFLG		; Get ptr to bpt block
	 JRST ERR		; Not at one
	SETZ R,
	JRST BPS5

;A$NB  OR  A$B
BPS1:	skipn r,t		;[NIC250]
	  jrst [TRNN F,Q2F	;DELETE MUST NAME A SPECIFIC BPT
		  JRST ERR	;0$B DOESN'T MEAN ANYTHING
		JRST BPS2]	;0$NB (CLEAR SPECIFIC BPT)
	call xtndpc		;extend this pc to absolute address
	PUSH	P,T		; SAVE ADDR
	CALL	FETCH		; CREATE IF NECESSARY
	  JRST	ERR
	CALL	DEP		; MAKE COPY IF NECESSARY
	  JRST	ERR
	POP	P,R		; GET BACK ADDRESS
;	HRRZ	T,LASTPG	; GET PAGE NUMBER IN OWNER
;	LSH	T,9
;	ANDCMI	R,777000	; FLUSH PAGE ADDRESS
;	IOR	R,T		; CONVERT TO ADDRESS IN OWNER
	TRNN	F,Q2F
	  JRST	BPS3		;A$B

;PROCESS THE $NB (A$NB TO SET, 0$NB TO CLEAR, $NB TO EXAMINE)
BPS2:	MOVE	T,WRD2
	CAIL	T,1
	CAILE	T,NBP
	  JRST	ERR		;NO SUCH BPT NUMBER
	IMULI	T,NBPTV
	ADDI	T,BPTS-NBPTV
	TLZN	F,QF
	  JRST	QUANIN		;$NB  EXAMINE
	JRST	BPS5		;A$NB (SET BPT) OR 0$NB (CLEAR BPT)

;A$B (NOT 0$B). SEARCH FOR A FREE BPT TO USE
BPS3:	MOVEI	T,BPTS		;PROCESS THE A$B
	HLRZ	W1,LASTPG	; GET OWNING FORK
BPS4:	camn w1,.bfork(t)	;same process?
	 came R,.baddr(t)	; AND SAME ADDRESS?
	  skipn	.baddr(T)	;  not same same.  IS THIS BPT NOT IN USE?
	   JRST	BPS5		;    USE THIS BPT
	ADDI	T,NBPTV		;TRY NEXT
	CAIE	T,<BPTS+<NBP*NBPTV>>
	  JRST	BPS4
	JRST	ERR		;NONE AVAILABLE

;USE THE BREAKPOINT POINTED TO BY T
;ADDR AT WHICH TO SET IT IN R
BPS5:	HLRZ	W1,LASTPG	; OWNING FORK FOR NEW BPT
	CAME	T,BPTFLG	;CHANGING BPT JUST HIT?
	 JRST	BPS6
	camn r,.baddr(t)	;TO A DIFFERENT PLACE?
	 came w1,.bfork(t)
	  CALL	GOODPC		;YES. DON'T PROCEED FROM OLD ONE.
BPS6:	MOVEM	R,.baddr(T)	;INSERT LOCATION
	SETZM	.bskip(T)
	SETZM	.bpcnt(T)
	SETZM	.bsptr(T)
	SETZM	.bauto(T)	;ASSUME NOT AUTOPROCEED
	HLRZ	R,LASTPG	;get process handle
	movem r,.bfork(T)	;store it here
	TLNN	F,CCF
	 JRST	RETX
	setom .bauto(t)		;IT IS AN AUTOPROCEED
	MOVSI	R,600000	;A MODERATLY NEGATIVE INFINITY/2
	MOVEM	R,.bpcnt(T)	;FOR PROCEED COUNT
	JRST	RETX

;FLUSH ALL BREAKPOINTS
FLSBPT:	MOVEI	T,BPTS		;ADDRESS OF 1ST BPT BLK
	SETZM	.baddr(T)	;DELETE THE BPT. 0-->ADDR
	ADDI	T,NBPTV		;MOVE TO NEXT
	CAIE	T,<BPTS+<NBP*NBPTV>>
	  JRST	.-3		;DO ANOTHER

;MAKE PC GOOD FOR $P
GOODPC:	SETZM	BPTFLG		;NO LONGER AT A BPT
SETPC:	PUSH	P,2
	MOVSI	2,(1B5)
	IORB	2,PC
	MOVEM	2,REALPC
	POP	P,2
	RET


;CHECK WHETHER THERE IS A BREAKPOINT AT THE ADDRESS POINTED
;AT IN R.  IF THERE IS, DON'T SKIP.  IF THERE ISN'T, SKIP.
;SORT OF BACKWARDS, HUH?  Should this check to see if the
;breakpoint is in the right fork, too?

BPCHK:	PUSH	P,W1
	PUSH	P,TT1
	PUSH	P,R
	HRRZS	R
	MOVEI	W1,BPTS
BPCHKL:	camn r,.baddr(w1)	;right address?
	  jrst bpchk1		;  yes, got it.
	ADDI	W1,NBPTV
	CAIE	W1,<BPTS+<NBP*NBPTV>>
	 JRST	BPCHKL
	AOS	-3(P)
BPCHK1:	POP	P,R
	POP	P,TT1
	POP	P,W1
	POPJ	P,

; $U - UNPROTECT PAGES IN USER'S FORK
;A<B$NU		;GIVES PROTECTION N TO PAGES A THRU B
;A$NU		;GIVES PROTECTION M TO PAGE A
;$NU		;GIVES PROTECTION N TO THE CURRENT PAGE
;4-BIT OF N MEANS READ ACCESS
;2-BIT OF N MEANS WRITE ACCESS
;1-BIT OF N MEANS EXECUTE ACCESS
;N ASSUMED TO BE 7 IF NOT SPECIFIED

	block 4
	[asciz "$;U	dumps core to file, the opposite of $;Y
n$;U	dumps core starting at page n
n<m$;U	dumps pages n through m."]
	[asciz ";U	ungets core image to file as an executable, the opposite of ;Y"]
	[asciz "$$U	removes any address break set.
a$$nU	sets address break at location a with mask n.  Mask bits are the
	same as for $U page protection: 1 = Execute, 2 = Write, 4 = Read,
	but defaults to 2 (write).  Note that you cannot set an address
	break on an AC!"]
	[asciz "$nU	gives protection n to the current page.
a$nU	gives protection n to page a.
a<b$nU	gives protection n to pages a through b.  Protection is composed of
	the sum of the desired access bits: 1 = Execute, 2 = Write, 4 = Read.
	The default protection is 7"]
	0			;there is no "U" command

UNPRO:	TLNE	F,CCF
IFE ADBRKF,<	JRST ERR>
IFN ADBRKF,<	JRST DADBRK>	;SET UP ADDRESS BREAK
	MOVE	TT,WRD2	;NUMBER TO RIGHT OF $
	TRNN	F,Q2F	;IF NOT GIVEN,
	MOVEI	TT,7	; ASSUME RWX
	JUMPL	TT,ERR
	CAILE	TT,7
	JRST	ERR
	ROT	TT,-5		;STANDARD POSTION
	TLNE	TT,(1B3)	;ASKING FOR WRITE ACCESS?
	TLO	TT,(1B9)	;YES, GIVE WRITE COPY IF CAN'T GET WRITE
UNPRO1:	TLNE	F,QF		;NUMBER TO LEFT OF $ ?
	JRST	UNPRO2		; YES.
	MOVE	T,LLOC		;.
	TLNE	T,(DDTINT)
	 JRST	ERR		;NICE TRY, RAY.
	LSH	T,-11		;MAKE INTO PAGE NUMBER
UNPRO2:	TLNN	F,FAF		; <  SEEN?
	MOVEM	T,DEFV		;NO, MAKE FIRST AND LAST PAGES THE SAME
	CAIG	T,777
	 CAMGE	T,DEFV
	  JRST	ERR		;TOO BIG, OR WRONG ORDER
	hrrz	w, lastpg	; Will we change the access of this page?
	lsh	w, -11
	caml	w, defv
	 camle	w, t
	 caia			; Ok, no problem
	call	unmap		; Map it out if we will
	SKIPA	1,DEFV
UNPRO3:	AOS	1,DEFV
	camle	1, t
	JRST	DD1	;DONE
	HRL	1,FORK
	RPACS
	TLNN	2,(1B5)	;EXISTS?
	JRST	UNPRO3
	MOVE	2,TT	;NEW ACCESS
	SPACS
	JRST	UNPRO3

IFN ADBRKF,<
;SET AND REMOVE ADDRESS BREAK
; $$U		REMOVE ADDRESS BREAK
;<LOC>$$<N>U	SET ADDRESS BREAK WITH MASK N FOR LOCATION <LOC>
;N ASSUMED TO BE 2 (BREAK ON WRITE) IF NOT SPECIFIED

DADBRK:	TLNN	F,QF		;ANY LOCATION GIVEN
	 JRST	DADBRR		;NO, GO REMOVE ALL ADDRESS BREAK
	MOVE	3,WRD2		;GET BREAK MASK
	TRNN	F,Q2F
	 MOVEI	3,2		;OR 2 IF NOT GIVEN
	JUMPL	3,ERR
	CAILE	3,7		;RANGE CHECK IT
	 JRST	ERR
	ROT	3,-3		;NORMALISE IT
	call xtndpc		;globalize the pc
	MOVE	2,T		;[NIC254] ADDRESS TO BREAK WITH
	HRRZ	1,FORK		;THE FORK TO DO IT IN
	hrli 1,.abset		;set address break
	ADBRK			;SET IT UP
	RET			;AND DONE

DADBRR:	HRRZ	1,FORK		;THE FORK TO DO IT IN
	hrli 1,.abclr		;clear address break
	ADBRK
	RET			;AND RETURN
>

; ;R -- GET JCL FOR RSCAN BUFFER
; $;R -- Display current RSCAN buffer

RJCL:	tlne f,cf			; $;R?
	  jrst pjcl			;   yes, print current JCL
	hrroi w1,[asciz /scan (JCL): /]
	CALL	TYPE
	setzm jcl			; CLEAR BUFFER
	move 1,[jcl,,jcl+1]
	blt 1,jcl+jcllen-1

	HRROI 1,JCL			; Set up TEXTI block
	MOVE 2,[RD%BEL!RD%CRF!RD%RND+jcllen*5-1]
	HRROI 3,[ASCIZ "JCL: "]
	RDTTY
	  JRST JERR
	TLNE 2,(RD%BFE)			; DELETED PAST START?
	  JRST WRONG
	HRROI 1,JCL
	RSCAN				; PUT JCL IN BUFFER
	  JRST JERR
	JRST DD1.5

pjcl:	hrroi w1,[asciz "scan"]
	call type
	movei 1,.rsini			;function code: make rscan available &
	RSCAN				;return # bytes in the rscan buffer.
	  jrst jerr
	jumpe 1,[hrroi w1,[asciz " buffer is empty"]
		 call type
		 jrst dd1]
	movei t,(1)			;keep count in T
	caile t,jcllen*5-1		;fit in buffer?
	  jrst [hrroi w1,[asciz " (truncated)"]
		call type
		movei t,jcllen*5-1	;nope, but can do this much
		jrst .+1]
	movei 1,.priin			;data available as primary input
	hrroi 2,jcl			;put it here.
	movni 3,(t)			;negative count in ac 3
	SIN				;suck it in
	  erjmp jerr
	hrroi w1,[asciz /: "/]
	call type
	hrroi w1,jcl
	call type
	movei t,""""
	call tout
	hrroi 1,jcl			;now re-set it!!
	RSCAN
	  jrst jerr
	jrst dd1

; ;X - set the extended section

SETSEC:	trne f,semif2		; ;;X?
	  jrst err		;   yeah, that's no good.
	tlnn f,qf		;no arg?
	  setz t,		;  assume sec 0 then
	cail t,0		;valid section #
	  caile t,37		; is 0 - 37 inclusive
	    jrst err		;   sorry, bozo
	movem t,cursec		;easy as pie!
	call lct		;show that we did something
	jrst dd2		;and continue

; ;J -- JFN STATUS
; <JFN>;J STATUS OF JUST THAT JFN

SEMI.J: TRNE	F,SEMIF2
	 JRST	jobst		; ;;J?
	TLNE	F,QF		;HAVE AN ARG?
	 JRST	SEMIJ1		;YES
	hrroi w1,[asciz /fn status:
/]
	CALL	TYPE
	INTON
	MOVEI	T,MAXJFN
	CALL	JSTAT
	SOJGE	T,.-1
	JRST	DD1

SEMIJ1:	JUMPL	T,ERR
	CAILE	T,MAXJFN
	 JRST	ERR
	INTON
	PUSH	P,T
	TLNN	F,QF
	 CALL	CRF
	TLNE	F,QF
	 CALL	LCT
	POP	P,T
	CALL	JSTAT
	JRST	DD1

;TYPE STATUS OF JFN IN T

JSTAT:	HRRZ	1,T		;THE JFN
	GTSTS
	TLNE	2,(1B10)	;NO GOOD? (+++ apparently this doesn't catch all cases)
	 JRST	JSTAT0		;NOT SO.
	hrroi w1,[asciz / not assigned/]
	TLNE	F,QF		;<JFN>;J ?
	 CALL	TYPE		;YES.
	RET

JSTAT0:	PUSH	P,T
	PUSH	P,2		;SAVE STATUS
	MOVEI	1,.PRIOU
	HRRZ	2,T
	MOVE	3,[4,,10]
	TLNN	F,QF		;DONT TYPE JFN AGAIN IF N;J
	NOUT
	 CALL	TSPC
	CALL	LCT		;TYPE A TAB
	MOVEI	1,.PRIOU
	HRRZ	2,-1(P)		;THE JFN
	SETZ	3,			;DEFAULT FORMAT
	JFNS
	 ERJMP [HRROI 1,[ASCIZ /Unassigned/]
		PSOUT
		POP P,TT
		JRST JSTA10]
	CALL	LCT
	TRZ	F,TEMF		;USED BY MEMS14
	POP	P,TT		;GET THE STATUS WORD
	hrroi w1,[asciz /not open/]
	TLNN	TT,(1B0)
	 CALL	TYPE
	MOVSI	W1,(ASCII / R/)
	TLNE	TT,(1B1)
	 CALL	MEMS14		;MAYBE TYPE A COMMA AND THE LETTER
	MOVSI	W1,(ASCII / W/)
	TLNN	TT,(1B4)
	MOVSI	W1,(ASCII / A/)
	TLNE	TT,(1B2)
	 CALL	MEMS14		;OK TO WRITE AND MAYBE CHANGE POINTER
	MOVSI	W1,(ASCII / X/)
	TLNE	TT,(1B3)
	 CALL	MEMS14
	MOVE	W1,[ASCII / PPT/]
	TLNE	TT,(1B5)
	 CALL	MEMS14
	MOVE	W1,[ASCII / PRC/]
	TLNE	TT,(1B6)
	 CALL	MEMS14
	MOVE	W1,[ASCII / ERR/]
	TLNE	TT,(1B9)
	 CALL	MEMS14
	MOVE	W1,[ASCII / EOF/]
	TLNE	TT,(1B8)
	 CALL	MEMS14
	TLNE	TT,(1B1!1B2)
	TLNN	TT,(1B0)
	 JRST	JSTA10
	TLNE	TT,(1B3!1B6)
	 JRST	JSTA10
	HRRZ	1,0(P)		;THE JFN
	RFPTR
	 JRST	JSTA10
	PUSH	P,2
	MOVEI	T,","
	CALL	TOUT
	CALL	TSPC
	MOVEI	1,.PRIOU
	POP	P,2
	MOVEI	3,^d10
	NOUT
	 JRST	JSTA10
	MOVEI	T,"."
	CALL	TOUT
JSTA10:	CALL	CRF
	POP	P,T
	RET

; ;;E - Show entry vector

SHOENT:	MOVEI W1,[ASCIZ "ntry vector "]
	CALL TYPE
	CALL SHOEN0
	JRST DD1

SHOEN0:	MOVE 1,FORK
	GEVEC
	JUMPE 2,[MOVEI W1,[ASCIZ "is undefined."]
		 JRST TYPE]
	PUSH P,2
	MOVEI W1,[ASCIZ /location /]
	CALL TYPE
	HRRZ T,0(P)
	push p, w
	CALL pad
	pop p, w
	POP P,T
	HLRZS T
	CAIN T,(JRST)
	  RET
	MOVEI W1,[ASCIZ /, length /]
	CALL TYPE
	JRST TOC

; ;A -- Type address space -- MEMSTAT

adrspc:	call unmap
	tlne f,qf		;do we have an arg?
	  jrst adrsp1		;  yes, so they want a specific page
	movei w1,[asciz /ddress space/]
	call type
	call crf
	inton
	hrroi w1,[asciz "Entry vector "]
	call type
	call shoen0
	call crf
	jumpe w,dd1
	call crf
;	jrst memsta		;fall into memstat (memory map)

;[NIC250] - Rewrite of memory-map (MEMSTAT) routine

memsta:	setom secnum		;start at -1 so first aos makes section 0

memst0:	aos 1,secnum		;bump section#
	caile 1,37		;within range?
	  jrst dd1		;  nope, so done
	hrl 1,fork		;ph,,section#
	RSMAP%			;read the section map
	  erjmp memst0		;  oops, try next one
	tlnn 2,(pa%pex)		;section exist?
	  jrst memst0		;  nope
	movei w1,[asciz " -- Section "]
	call type
	move t,secnum
	call toc		;type out the section#
	call lct		;a little whitespace
	hrroi w1,[asciz "R "]
	tlne 2,(sm%rd)		;read access?
	  call type
	hrroi w1,[asciz "W "]
	tlne 2,(sm%wr)		;write access?
	  call type
	hrroi w1,[asciz "X "]
	tlne 2,(sm%ex)		;execute access?
	  call type
	hrroi w1,[asciz "Indirect, "]
	tlne 2,(sm%ind)
	  call type
	jumpe 1,[hrroi w1,[asciz " Private"]
		 call type
		 jrst memst1]
	hrroi w1,[asciz " Mapped to fork "]
	call type
	hlrz t,2
	tlz t,(1b0)		;turn of PH bit
	call toc
	hrroi w1,[asciz ", section "]
	hrrz t,2
	call toc
memst1:	hrroi w1,[asciz " --"]
	call type
	call crf
	move w,secnum
	lsh w,3*3		;starting page# in section
	hrli w,-1000		;# of pages in section
	setzb tt,tt1		;clear last-page stuff

memst2:	hrl 1,fork
memst3:	hrrzm w,xrmarg+2	;first page in range
	hrlz 1,fork
	movei 2,xrmarg		;address of arg block
	XRMAP%			;check the page access
	  erjmp mmst3a		;  ummm...
	move 1,xrmdat+1		;check the return flags
	tlne 1,(rm%pex)		;exists?
	  jrst memst4		;  yes, so found first page in range
mmst3a:	aobjn w,memst3		;nope, try for next page in section
	jrst memst0		;no more pages, so try the next section

memst4:	call pagid		;GET FULL IDENTITY
	  jfcl
	  jfcl
	jumpge w,memst0		;if not still within section, do next
	move tt,tt2		;SAVE ID FOR LATER
	move tt1,tt3		;PRINTING, TESTING
	setz w2,		;HOW MANY IN THIS GROUP
	hrrz t,w		;starting page#
	call toc		;GROUP START, PAGE NUMBER

;HAVE THE FIRST PAGE, LOOK AT NEXT ONE TO SEE IF IT IS SAME GROUP

	call npagid		;NEXT PAGE ID, STEPS W
	  soja w2,memst9	;  DIFFERENT, TYPE OUT
	  jrst memst7		;  NEXT (CONSECUTIVE) PAGE IN SAME GROUP

;2ND PAGE IDENTICAL TO FIRST PAGE, SEE HOW MANY MORE ARE

memst5:	call npagid
	  jrst memst6
	  jrst memst6
	jrst memst5		;IDENTICAL, KEEP GOING

memst6:	setz w2,		;SAY IDENTICAL, NO CONSECUTIVE PAGES
	jrst memst8

;2ND PAGE IS NEXT HIGHER AFTER 1ST, IN SAME FORK/FILE. HOW MANY MORE

memst7:	call npagid
	  jrst memst8		;DIFFERENT
	  jrst memst7		;CONSECUTIVE, KEEP GOING

;PRINT LAST PAGE NUMBER OF GROUP

memst8:	movei t,"-"
	call tout
	movei t,-1(w)
	call toc		;FINAL PAGE NUMBER

;PRINT IDENTITY OF PAGES(S) IN GROUP

memst9:	movei t,^D12
	call talign
	hrroi w1,[asciz "@ "]
	tlne tt1,(pa%ind)
	  call type
	tlnn tt1,(pa%pex)
	  jrst [hrroi w1,[asciz /No page  /]
		call type
		jrst mems13]
	camn tt,[-1]
	  jrst [hrroi w1,[asciz /Forgotten file  /]
		call type
		jrst mems13]
	ldb 2,[point 9,tt,17]	;jfn or fork #
	tlne tt,(1b0)		;on if fork
	  jrst [hlrz w1,tt
		camn w1,fork
		  jrst [hrroi w1,[asciz /Private  /]
			call type
			jrst mems13]
		hrroi w1,[asciz /Fork /]
		call type
		move t,2		;fork number
		call toc
		call lct
		jrst mems13]
	movei 1,.priou		;tty output
	setz 3,			;no special options
	JFNS%			;print file name
	  ercal barf0		;  tsk!
mems10:	call tspc
	movei t,"("
	call tout
	hrrz t,tt
	call toc		;page # in fork/file
	skiple w2		;0 => only one page
	  jrst [movei t,"-"
		call tout
		hrrz t,tt
		addi t,-1(w2)
		call toc	;last page in group
		jrst .+1]
	hrroi w1,[asciz ")  "]
	call type
mems13:	hrroi w1,[asciz "R "]
	tlne tt1,(pa%rd)
	  call type
	hrroi w1,[asciz "W "]
	tlne tt1,(pa%wt)
	  call type
	hrroi w1,[asciz "X "]
	tlne tt1,(pa%ex)
	  call type
	hrroi w1,[asciz "C "]
	tlne tt1,(pa%cpy)
	  call type
	call crf
	tlnn f,qf		;<page>;a command?
	  jrst memst2		;  do next group
	call crf
	jrst dd1		;yes.  we're done

;type item in access capability list
mems14:	movei	1,","
	troe	f,temf
	  call	tout+1
	jrst	text2

;<PAGE>;A

adrsp1:	skipl w,t
	  cail w,37000
	    jrst err		;BAD ARG
	hrlz 1,fork
	hrrzm 2,xrmarg+2
	XRMAP%
	  erjmp adrsp2
	move 2,xrmdat+1
	tlnn 2,(rm%pex)		;does the specified page exist?
	  jrst adrsp2		;  nope
	call pagid
	  jfcl
	  jfcl
	move tt,tt2
	move tt1,tt3
	setz w2,
	call crf
	jrst memst9

ADRSP2:	MOVE	W1,[POINT 7,[ASCIZ /  No page/]]
	CALL	TYPE
	CALL	CRF
	JRST	DD1

;Next page id - returns flags for page in TT2, ID (JFN/PH,,page#)
;in TT3.  TT is expected to be the last TT2, TT1 the old TT3

npagid:	addi w2,1		;how many in current group
	aobjp w,cpopj		;bump page and return if no more
pagid:	setzb tt2,tt3		;initialize
	hrrz 1,w		;page#
	cail 1,37000		;valid page#
	  ret			;  nope, not any more
	movem 1,xrmarg+2	;store the wanted page#
	hrlz 1,fork		;ph,,0
	movei 2,xrmarg		;address of arg block
	XRMAP%			;read about that page
	  ercal barf0		;  ???
	hllz tt3,xrmdat+1	;get the returned flags
	tlnn tt3,(pa%pex)	;doesn't exist?
	  ret			;  nope
	move tt2,xrmdat		;return ID (JFN/PH,,page#)

;COMPARE PRINTING INFO AGAINS SAME FOR PREVIOUS PAGE

pagid8:	move 1,tt2
	xor 1,tt		;check to see if any bits are different
	tlne 1,-1		;any change?
	  ret			;  yep, a difference, so not in same group
	move 2,tt3
	xor 2,tt1
	tlne 2,(37B6!1B7!3B10)
	  ret			;DIFFERENT ACCESS
	trne 1,-1
	  jrst pagid6
popj2:	aos (P)			;take same-group return
	jrst cpopj1

pagid6:	move 1,w2
	add 1,tt
	sub 1,tt2
	trne 1,-1
	  ret
	jrst cpopj1

;SETUP TO EXECUTE A SINGLE INSTRUCTION
;T HAS THE INSTR.
;$X SAYS WHERE IN USER'S MEMORY TO DO IT

SETESI:	call makgiw		;turn instruction T's I,X,Y into a GIW in W1
	move r,xrg		;patch area
	ldb tt,[point 9,t,8]	;GET OPCODE
	move tt,pcpntb(tt)	;GET TABLE ENTRY
	trnn tt,4		;is E a real address?
	  jrst setes0		;  no, so don't need to do GIW stuff
	push p,t		;save the instruction
	move t,w1		;w1/ GIW from makgiw
	call dep		;deposit the GIW
	  jrst err		;  failed
	pop p,t			;restore the instruction
	and t,[777740,,0]	;keep only the opcode and AC field
	tlo t,(@)		;add an indirect bit
	hrr t,xrg		;first patch area is location of GIW
setes0:	addi r,1		;step to next patch location
	call dep		;deposit the hacked-up instruction
	  jrst err		;  oops
	MOVEI	W1,3
SETES1:	MOVE	T,[BPT]
	AOS	R
	CALL	DEP		;INSERT PSEUDO BREAKPOINTS
	 JRST	ERR
	SOJG	W1,SETES1
	CALL	DOSET
	move r,pc		;current pc
	and r,[pcfl]		;just keep the flags
	add r,xrg		;WHERE $X SHOULD BE DONE
	addi r,1		;first word is global EA!!   2nd is instr
	MOVEM	R,PC		;HIS TEMPORARY PC
	MOVEM	R,REALPC
	RET

;SETUP A SAVE FRAME ON THE AUXILIIARY STACK

DOSET:	push p,r
	EXCH	P,PCSPTR
	PUSH	P,F
	PUSH	P,LLOC
	PUSH	P,LLOCO
	PUSH	P,TRAPWD
	PUSH	P,WDATA
	PUSH	P,BPTFLG	;WHICH BREAKPOINT WERE AT
	PUSH	P,BINSTR	;CURRENT BREAK INSTRUCTION
.RPCNT==0
REPEAT <NTBPTS+1>*2,<PUSH P,$CTRLN+.RPCNT
.RPCNT==.RPCNT+1>
	MOVSI	R,(1B5)	;USERMODE FLAG
	IORM	R,PC
	PUSH	P,PC	;SAVE HIS OLD PC
	EXCH	P,PCSPTR
	pop p,r
	RET

;UNSET THE ABOVE
UNSET:	EXCH	P,PCSPTR
	hllz	TT1,REALPC	;FLAGS RETURNED FROM $X ETC.
	tlz tt1,37		;clobber section# of PC, leaving just flags
	POP	P,PC		;get back saved PC
	ldb tt2,[XPCBP pc]	;get the actual extended PC
	ior tt1,tt2		;combine the new flags with old PC
	MOVEM	TT1,PC		;WHAT TO TYPE FOR $G
	MOVEM	TT1,REALPC	;WHERE TO DO SFORK (IN TOUSER)
.RPCNT==0
REPEAT <NTBPTS+1>*2,<POP P,$CTRLN+<<NTBPTS+1>*2-1>-.RPCNT
.RPCNT==.RPCNT+1>
	POP	P,BINSTR
	POP	P,BPTFLG
	POP	P,WDATA
	POP	P,TRAPWD
	POP	P,LLOCO
	POP	P,LLOC
	POP	P,F
	EXCH	P,PCSPTR
	RET

; ;J COMMAND -- JOBSTAT

JOBST:	CALL	UNMAP	;WILL USE THAT AREA FOR BUFFER
	FRKTAB=UCORE
	MOVEI	W1,[ASCIZ /ob status:
/]
	CALL	TYPE
	INTON
	MOVEI	W1,[ASCIZ/ Job /]
	CALL	TYPE
	GJINF
	PUSH P,4		;Save TTY#
	PUSH P,1		;and user#
	MOVEI	1,.PRIOU
	MOVE	2,3		;JOB NUMBER
	HRRZI	3,^D10
	NOUT
	  JFCL
	MOVEI	W1,[ASCIZ/, User /]
	CALL	TYPE
	POP P,2			;User#
	DIRST
	  JFCL
	MOVEI W1,[ASCIZ ", TTY"]
	CALL TYPE
	POP P,2			;TTY#
	MOVEI 3,^D8
	NOUT
	  JFCL
	CALL	CRF		;FOLLOWED BY CARRIAGE RETURN

;TYPE FORK STRUCTURE
	MOVEI	1,.FHSLF	;SAY START AT SELF
IFN KL20F,<jrst frkst2>
JOBST1:	movsi	2,(1B0)		;SAY ASSIGN HANDLES
	MOVEI	2,FRKTAB	;USE BUFFER
	GFRKS			;GET FORK STRUCTURE
	HRRZ	W2,FRKTAB	;POINTER TO FORKS INFERIOR
	SETZ	W,		;INITIALIZE LEVEL COUNTER
	CALL	FSTRUC		;USE COMMON DISPLAY FORK
	JRST	DD1		;STRUCTURE ROUTINE


;FSTRUC
;RECURSIVE SUBR TO TYPE FORK STRUCTURE OF JOB.
;FOR EACH FORK, TYPES HANDLE AND STATUS.
;  FILE NAME OR "PROGRAM" WOULD ALSO BE DESIRABLE IF IT WERE AVAILABLE.
;STRUCTURE INDICATED BY PUTTING A FORK'S INFERIORS RIGHT AFTER IT,
;  INDENTING 3 COLUMNS PER LEVEL.
;THUS PARELLEL FORKS ARE THOSE WHICH APPEAR AT SAME INDENTATION WITH
;  NO LESS-INDENTED ENTRIES BETWEEN THEM.
;TAKES: S: POINTER TO GFRKS TABLE, SET UP BY CALLER.
;	W: LEVEL COUNTER, ZEROED BY TOP LEVEL CALLER.

;ENTRY POINT IS AT END BUT COMES RIGHT HERE.
;TYPE STUFF FOR THIS FORK.

FSTR1:	CALL	TSPC
	MOVE	1,W
	CALL	LCT		;INDENT 3 SPACES PER LEVEL BELOW FIRST.
	SOJGE	1,.-1
	MOVEI	W1,[ASCIZ/Fork /]
	CALL	TYPE

	HRRZ	2,1(W2)		;GET THIS FORK'S HANDLE FROM TABLE
	JUMPE	2,[MOVEI W1,[ASCIZ /**/]	;NO HANDLE ASSIGNED
		CALL TYPE
		JRST FSTR2]
	TRZ	2,(1B0)		;PRINT IN FORM ## NOT 4000##
	MOVEI	1,.PRIOU
	MOVEI	3,10
	NOUT			;FORK HANDLE, OCTAL
	 JRST	ERR		;JSYS ERROR ROUTINE FOR ERROR NUM IN C
FSTR2:	MOVEI	W1,[ASCIZ/: /];
	CALL	TYPE
	HRRZ	1,1(W2)		;HANDLE AGAIN
	CALL	FSTAT		;TYPE ITS STATUS
	CALL	CRF
;NOW DO ALL OF THE FORK'S INFERIORS, BY RECURSION.
	PUSH	P,W2
	HRRZ	W2,(W2)		;INFERIOR PTR FROM GFRKS TABLE.
	AOS	W		;DOWN LEVEL
	CALL	FSTRUC		;RECURSIVE CALL TO DO ENTIRE SUBTREE
	SOS	W		;UP LEVEL
	POP	P,W2
	HLRZ	W2,(W2)		;PARALLEL PTR FROM GFRKS TABLE

;ENTRY POINT.  NOP IF 0 PTR GIVEN.
FSTRUC:	JUMPN	W2,FSTR1
	RET

; ;I -- Interrupt  STATUS

;PSI IS OFF, LEVTAB=NNNNNN, CHNTAB=NNNNNN, CHN MASK=NNNNNNNNNNNN, BIP=N

PSIST:	MOVEI	W1,[ASCIZ/nterrupt status
/]
	CALL	TYPE
	INTON
	CALL	TSPC
	SKIPGE	1,FORK
	  JRST [MOVEI W1,[ASCIZ /No program/]
		CALL	TYPE
		JRST CRF]
	MOVEI	W1,[ASCIZ /PSI is /]
	CALL	TYPE
	MOVEI	W1,[ASCIZ /on/]
	SKIPN	USRPSI+3	;SKIP IF HIS PSI SYSTEM IS ON
	  MOVEI W1,[ASCIZ /off/]
	CALL	TYPE
	RIR
IFE XTENDF,<
	 ERJMP JERR
>;IFE ENTNDF
IFN XTENDF,<
	 ERJMP [MOVEI 1,.FHSLF
		GETER		;Get last error.
		TLZ 2,-1	;RH of 2 is the error code
		CAIE 2,RIRX1	;RIR incompatible with previous XSIR?
		  JRST JERR	;  Nope, so something else.
		move 1,fork
		MOVEI 2,RIRBLK
		XRIR%
		 ERJMP JERR
		MOVE 4,RIRBLK+1
		MOVE TT3,RIRBLK+2
		JRST psist0]
>;IFN EXTENDF
	jumpe 2,[hrroi w1,[asciz ", no Level or Channel table"]
		 call type
		 jrst psist1]
	HLRZ	4,2		;LEVTAB
	HRRZ	TT3,2		;CHNTAB
psist0:	MOVEI	W1,[ASCIZ/, Level table at /]
	CALL	TYPE
	MOVEI	t,(4)
	call	pad
	MOVEI	W1,[ASCIZ/, Channel table at /]
	CALL	TYPE
	MOVEI	t,(TT3)
	call	pad
psist1:	MOVEI	W1,[ASCIZ/

 Channels active:     /]
	CALL	TYPE
	SKIPN T,USRPSI+1
	  CALL NOTIW
	    CALL CHNTYP
	MOVEI	W1,[ASCIZ/
 Breaks waiting:      /]
	CALL	TYPE
	SKIPN T,USRPSI+0
	  CALL NOTIW
	    CALL CHNTYP
	MOVEI	W1,[ASCIZ/
 Levels in progress:  /]
	CALL	TYPE
	MOVSI	T,(17B3)
	AND	T,USRPSI+2
	SKIPN T
	  CALL NOTIW
	    CALL CHNTYP
	MOVEI	W1,[ASCIZ/

 Fork TIW:  /]
	CALL	TYPE
	SKIPN T,USRPSI+4
	  CALL NOTIW
	    CALL SHOTIW
	MOVEI	W1,[ASCIZ/
  Job TIW:  /]
	CALL	TYPE
	MOVNI	1,5
	RTIW
	SKIPN T,2
	  CALL NOTIW
	    CALL SHOTIW
	CALL	CRF
	JRST	DD1

NOTIW:	MOVEI W1,[ASCIZ "None"]
	CALL TYPE
	JRST CPOPJ1

SHOTIW:	PUSH P,T
	MOVSI TT,400000		;Start with highest bit.
	SETZB TT1,TT2

STIW0:	TDNN T,TT		;It set?
	  JRST STIW1		;  Naw, so try next bit.
	MOVEI W1,[ASCIZ ", "]
	SKIPE TT2
	  CALL TYPE
	HLRZ TT2,TIWs(TT1)	;LH of string...
	CAIN TT2,-1		;-1 in LH?
	  SKIPA W1,TIWs(TT1)	;  Yes, so string pointer,
	    MOVEI W1,TIWs(TT1)	;    No, so it's string itself.
	CALL TYPE
STIW1:	LSH TT,-1		;Right shift 1
	SKIPE TT		;Anything left to test?
	  AOJA TT1,STIW0	;  Yes, so do it.
	POP P,T
	JRST POTYPE

CHNTYP:	PUSH P,T
	MOVSI TT,400000		;Start with highest bit.
	SETZB TT1,TT2

CHNTY0:	TDNN T,TT		;It set?
	  JRST CHNTY2		;  Naw, so try next bit.
	MOVEI W1,[ASCIZ ", "]
	SKIPE TT2
	  CALL TYPE
	SKIPN IChans(TT1)
	  JRST [MOVEI 1,.PRIOU
		MOVE 2,TT1
		MOVEI 3,^D10
		NOUT
		  NOP
		JRST CHNTY1]
	MOVEI W1,IChans(TT1)
	CALL TYPE
CHNTY1:	SETO TT2,
CHNTY2:	LSH TT,-1		;Right shift 1
	SKIPE TT		;Anything left to test?
	  AOJA TT1,CHNTY0	;  Yes, so do it.
	POP P,T

POTYPE:	MOVEI W1,[ASCIZ " ("]
	CALL TYPE
	MOVEI 1,.PRIOU
	MOVE 2,T
	MOVE 3,[NO%MAG+^D8]
	NOUT
	  NOP
	MOVEI T,")"
	JRST TOUT

; ;V COMMAND -- SET ^T VIEW ADDRESS

SEMI.V:	TRNE	F,SEMIF2
	 JRST	ERR		;TOO MANY SEMICOLI
	TLNN	F,QF		;HAVE AN ARG?
	 JRST	SEMIV1		;NO
	TLNE	T,-1		;REASONABLE ADDRESS?
	 JRST	ERR		;NO
	CAIA
SEMIV1:	SETO	T,
	MOVEM	T,VADDR		;LEAVE FOR ^T TO SEE
	JRST	DD1

;F COMMAND -- FORKSTAT

SEMI.F:	TRNN	F,SEMIF2	; ;;F OR ;F?
	 JRST	FRKST		; ;F GO DO FORK STAT
	TLNN	F,QF		; N;;F?
	 JRST	ERR		;NO
	CAIL	T,0
	 CAIL	T,16
	  JRST	ERR		; BAD FORK NUMBER
	SKIPN	T
	 MOVE	T,TPFORK
	IORI	T,400000
	MOVE	1,T
	TLNN	F,FAF		; TWO ARGS?
	 JRST	SEM.F1		;NO
	MOVE	2,DEFV		; GET ARG
	IORI	2,400000	; INSURE ITS A FORK HANDLE
	GFRKH			; GET FORK HANDLE
	 JRST	ERR		; SOME KIND OF ERROR
	PUSH	P,1
	MOVEI	2,-400000(1)
	HRROI	1,[ASCIZ /(fork /]
	PSOUT
	MOVEI	1,.PRIOU
	MOVEI	3,10
	NOUT
	 JFCL
	HRROI	1,[ASCIZ /) /]
	PSOUT
	POP	P,1
SEM.F1:	CALL	SETFRK
	 JRST	ERR
	JRST	DD1

FRKST:	CALL	UNMAP	;WILL USE THAT AREA FOR BUFFER
	FRKTAB=UCORE
	TLNE	F,QF		; N;;F?
	 JRST	FRKST1		;YES
	MOVE	W1,[POINT 7,[ASCIZ /ork status
/]]
	CALL	TYPE
	INTON
FRKST2:
IFN KA10F,<	MOVE 2,[1B0+FRKTAB]>
IFN KL20F,<	MOVSI 2,(1B0)
		MOVE 3,[-1000,,FRKTAB]
	   >
	GFRKS
IFE isigff,<	JRST ERR>
IFN isigff,<	JFCL>
	HRRZI	W,FRKTAB	;WHAT TO PRINT
	MOVEI	TT,1	;LEVEL TO PRINT IT AT
	CALL	PRFRK	;PRINT FORKS
	JRST	DD1

PRFRK:	JUMPE	W,CPOPJ
	PUSH	P,W		;SAVE FOR BELOW
	PUSH	P,TT		;SAVE PRINTING LEVEL
	CALL	TSPC		;TYPE A SPACE
	SOJG	TT,.-1
	HRRZ	T,1(W)		;FORK HANDLE
	ANDI	T,77
	CALL	TOC		;PRINT IT
	CALL	LCT		;AND A TAB
	HRRZ	1,1(W)		;THE FORK HANDLE
	CALL	FSTAT		;PRINT THE STATUS
	CALL	CRF		;AND A CARRIAGE RETURN
	POP	P,TT		;RESTORE LEVEL
	HRRZ	W,@(P)		;POINTER TO INFERIORS
	AOS	TT		;LEVEL OF INFERIORS
	CALL	PRFRK		;PRINT THEM
	SOS	TT		;NOW BACK TO THIS LEVEL
	POP	P,W
	HLRZ	W,0(W)		;PARALLEL FORKS
	JRST	PRFRK

FRKST1:	JUMPL	T,ERR		;BAD ARG
	CAIL	T,20
	 JRST	ERR		;BAD ARG
	PUSH	P,T
	CALL	LCT
	POP	P,1
	TRO	1,400000	;MAKE INTO A GOOD FORK HANDLE
	CALL	FSTAT		;PRINT STATUS
	CALL	CRF
	JRST	DD1


;SUBROUTINE FOR FORMATTING A LIST OF ITEMS SEVERAL TO A LINE.
;USED FOR AVAILABLE TERMINALS, AVAILABLE DEVICES, AND FILSTAT.
;BEFORE EACH ITEM: COMMA EXCEPT CRLF IF TOO FAR TO RIGHT.

BEFORE:	PUSH	P,1
	PUSH	P,2
	MOVEI	1,.PRIOU
	RFPOS
	MOVEI	2,(2)		;MASK COLUMN POSITION
	CAIL	2,^D65
	  JRST [CALL	CRF
		JRST .+4]
	MOVEI	T,","
	TLOE	TT3,(1B0)		;SUPPRESS COMMA BEFORE FIRST ONE
	CALL	TOUT
	CALL	TSPC		;SPACE AFTER COMMA OR EOL
	  JRST [POP P,2
		POP P,1
		RET]

;SUBROUTINE TO LOOP OVER ALL DEVICES FOR "AVAIL DEVICES" AND "FILSTAT".
;FOR EACH DEVICE, EXECUTES LOCATION AFTER CALL WITH SIXBIT NAME IN A
;    DEVICE CHARACTERISTICS WORD (A LA "DVCHR" EXCEPT B5) IN	2,
;    -1 OR JOB # ASSIGNED TO IN C.
;RETURNS +2.
;DESTROYS 1, 2, 3, 4.
DEVNAM==6
DEVCHR==7
DEVUNT==10

DEVLUP:	SETO	4,
	HRL	1,TT2
	HRRI	1,DEVNAM	;GET # DEVICES FROM TABLE 6
	GETAB
	 JFCL
	HRLZ	4,1		;AOBJN COUNT,,ABLE INDEX
DEVL1:	HRL	1,4
	HRRI	1,DEVCHR	;GET DEVICE CHARACTERISTICS WORD FROM TABLE 7
	GETAB
	 JFCL
	MOVE	2,1
	HRL	1,4
	HRRI	1,DEVUNT	;GET JOB # ASS TO, OR -1, FROM LH TABLE 8
	GETAB
	 JFCL
	HLRE	3,1
	HRL	1,4
	HRRI	1,DEVNAM	;GET DEVICE NAME IN SIXBIT FROM TABLE 6
	GETAB
	 JFCL
	PUSH	P,4
	XCT	@-1(P)
	POP	P,4
	AOBJN	4,DEVL1
	JRST	[	AOS (P)
		RET]

;TYPE SIXBIT SYMBOL FROM A.

SIXPRT:	PUSH	P,2
	MOVE	2,1
SIXPR1:	SETZ	1,
	LSHC	1,6
	ADDI	1,40
	PBOUT
	JUMPN	2,SIXPR1
	POP P,2
	RET

; <  COMMAND

	block 8
	[asciz "<	angle-brackets are used in IDDT the way that parens are used in
	normal mathmatical symbology, to force precedence of expressions,
	e.g. 3*1+2=5, but 3*<1+2>=9"]

FIRARG:	MOVEM	T,DEFV		;VALUE OF ARG TO DEFINITION VALUE
	TLO	F,FAF		;INDICATE A < HAS BEEN SEEN
	JRST	ULIM1		;GIVE ERROR IF ARG NULL

; > COMMAND

	block 8
	[asciz ">	finishes an IDDT style precedence expression.  angle-brackets are
	used the way parens are in normal mathematics, to force precedence
	of an expression.  3*1+2=5, but 3*<1+2>=9"]

ULIM:	TLO	F,SAF		;INDICATE A > HAS BEEN SEEN
	HRRZM	T,ULIMIT	;UPPER LIMIT FOR $Z, $W ETC.

ULIM1:	TLNN	F,QF		;ON IF ARG WAS TYPED
	JRST	ERR
	JRST	LIS0		;GET REST OF COMMAND

;$I COMMAND -- NAME OF INTERRUPT STUFF FOR USER PSI SYSTEM

	block 5
	[asciz ";I	displays the status of the inferiors PSI system."]
	0			;no $$I
	[asciz "$I	is an internal IDDT block containing the following:

	$I	Interrupt channels with breaks waiting
	$I+1	Interrupt channels assigned for user
	$I+2	Breaks in progress
	$I+3	0 if interrupt system off, non-0 otherwise
	$I+4	Fork handle on user
	$I+5	Sixbit user subsystem name"]
	0			;there is no "I" command

INTRUP:	TLNN	F,QF		;MUST HAVE NO ARG
	 TLNE	F,CCF		;AND ONLY ONE $ SIGN
	  JRST	ERR		;ELSE, DIFFERENT COMMAND
	MOVEI	T,USRPSI
	JRST	QUANIN

;LOOK FOR BEST FIT FOR SYMBOL TYPE-OUT

LOOK:	TLNN	T,-1		;IF LEFT HALF NON-0, OR
	 CAIGE	T,140		;VALUE LESS THAN 140,
LOOKE:	  TLOA	F,(1B2)		;SKIP LOCALS OUTSIDE CURRENT PGM
	   TLZ	F,(1B2)		;OTHERWISE, ALLOW LCLS AND SAVE CONTEXT
	MOVEM	T,TEM		;save value for later
	move s,symptr		;get pointer to symbol table
	camn s,[-2,,home-2]	;any symbols?
	  jrst cpopj1		;  nope.
	SETZM	SVFB
	SETZM	SVTB
	SETOM	BLVL
	hlres s			;-2 * # of symbols
	ASH	S,-1		;# of symbols
	TLZ	F,600000
	HRLZI	W2,DELO+DELI
	SKIPL	R,PRGM		;if there's a current program block
	 JRST	TOPDWN		;  then use that.  else top-down...
LOOK1:	SUB	R,[2,,2]	;get to next symbol
	TDNE	W2,(R)		;deleted?
	  JRST	LOOK3		;  yes, ignore
	LDB T,[POINT 4,(R),3]	;get the bits
	CAIN	T,3		;3 is block-name
	 JRST	BLNME		;  handle it.
	JUMPE	T,PNAM		;0 is program-name, do it.
	TRNE T,LOCAL/40000	;This a local symbol?
	 TLZA	F,(1B1)		;  no, zero flag.
	  TLO	F,(1B1)		;    yes, flag as such.
	MOVE	T,TEM		;get back value
	MOVE	W,1(R)		;value of symbol in table
	XOR	W,T		;co-mingle bits
	JUMPL	W,LOOK3		;no good.
	SUB	T,1(R)		;compare values now...
	JUMPL	T,LOOK3		;symbol comes after what we want, so no good.
	JUMPGE	F,LOOK2		;not local symbol?
	MOVE	W,1(R)
	SUB	W,1(W1)
	JUMPL	W,LOOK3
	JUMPG	W,LOOK2
	SKIPN	SVTB		; THIS SYMBOL NO PREFIX
	 SKIPN	SVFB		; AND LAST SYMBOL WITH PREFIX?
	  JRST	LOOK3		; NO

LOOK2:	HRR	W1,R
	TLO	F,(1B0)		; REMEMBER WE HAVE FOUND SOME SYMBOL
	MOVE	W,SVTB
	TLNE	F,(1B1)		; IF THIS SYMBOL IS GLOBAL,
	 MOVEI	W,0		; THEN DON'T SAVE BLOCK
	MOVEM	W,SVFB
	SKIPN	W		; ANY PREFIX?
	 JUMPE	T,SPT0		; NO, THEN EXACT MATCH IS BEST
LOOK3:	CAMN	R,SYMPTR
	 JRST	TOPDWN
LOOK3A:	AOJLE	S,LOOK1
	MOVE	T,TEM
	TLNE	F,(1B0)
	 SUB	T,1(W1)
	JUMPE	T,SPT0		;If exact match, then got it.
	JRST	CPOPJ1

TOPDWN:	TLNE	F,(1B2)
	 TLO	W2,LOCAL
	HLRE	R,SYMPTR
	MOVNS	R
	ADD	R,SYMPTR
	JRST	LOOK3A

PNAM:	TLNE	F,(1B2)
	 TLO	W2,LOCAL
	SKIPA	T,[-1]		; PROGRAM NAMES LIKE BLOCKS OF LEVEL -1
BLNME:	 MOVE	T,1(R)		; GET BLOCK LEVEL
	MOVEM	R,SVTB		; SAVE THIS BLOCK LOCATION
	CAMN	R,BLOCK		; IS THIS THE CURRENT BLOCK?
	 JRST	BLNM1		; YES
	jrst look3		;always keep prefix
;	CAML	T,BLVL		; IS BLOCK BELOW CURRENT?
;	 JRST	LOOK3		; YES, RETAIN PREFIX
BLNM1:	SETZM	SVTB		; THIS IS CURRENT OR ABOVE
	MOVEM	T,BLVL
	JRST	LOOK3

CONSYM:	MOVEM	T,LWT
CONSY1:	TRNN	F,LF1
	 JRST	(SCH)		;PIN OR FTOC
	TRNE	F,CF1
	 JRST	FTOC
PIN:	LDB	T,[POINT 9,T,8]	;PRINT INSTRUCTION - GET OPCODE
	JUMPE	T,HLFW		;0, so type as halfwords
	CAIL	T,700		;CONO, CONI, ETC?
	 JRST	INOUT		;YES.  TYPE AS IN/OUT INSTRUCTION
	CAIN	T,<JSYS>/1B8
	 JRST	JSTYPE		;TYPE JSYS INSTRUCTION
PIN0:	setzm dontac		;don't show ac field?  start off showing it
	HLLZ	T,LWT		;get LH of instruction
	and t,[777740,,0]	;keep opcode and ac field
	camn t,[erjmp]		;special case, erjmp = jump 16,
	  jrst [movei w1,[asciz "ERJMP"]
		jrst pinerj]
	camn t,[ercal]		;another special case, ercal = jump 17,
	  jrst [movei w1,[asciz "ERCAL"]
		jrst pinerj]
	TLZ	T,777		;flush ac field now, leave just opcode
	CALL	OPTYPE
PIN1:	TRNE	F,ITF		;INSTRUCTION TYPED?
	 JRST	PFULI1		;YES
	MOVE	T,LWT		;TRY TO FIND FULL WORD MATCH
	TLNE	T,777		;BUT NOT IF AC, @, OR X FIELDS NON-0
	 JRST	PFULI1
	CALL	LOOK
	 JRST	PADS1		;FOUND
PFULI1:	MOVSI	T,777000
	AND	T,LWT
	TRNN	F,ITF		;HAS INSTRUCTION BEEN TYPED?
	 CALL	LOOK		;NO, LOOK IN SYMBOL TABLE
	TROA	F,NAF		;INSTRUCTION TYPED, ALLOW NEG ADDRESSES
	 JRST	HLFW		;NOT FOUND, OUTPUT AS HALFWORDS
	CALL	TSPC
	skipe dontac		;don't show ac field?
	  jrst pi4		;  correct, don't.
	LDB T,[POINT 4,LWT,12]	;GET AC FIELD
	JUMPE	T,PI4		;Don't print AC, if 0
	CALL	PAD
PI3A:	MOVEI	W1,","
	CALL	TEXT
PI4:	MOVE	W1,LWT
	MOVEI	T,"@"
	TLNE	W1,20		;CHECK FOR INDIRECT BIT
	  CALL	TOUT
	HRRZ	T,LWT
	LDB W,[POINT 9,LWT,8]	;INSTRUCTION BITS
	TLNE	W1,20
	  JRST	PI8
	CAIL	W,240
	 CAILE	W,247
	  JRST	PI8A		;ALL (EXCEPT ASH,ROT,LSH) HAVE SYMB. ADRS
	CAIN	W,<JFFO>_-33
	  JRST	PI8		;JFFO AND @ GET SYMBOLIC ADDRESSES
	CALL	PADS3A		;ONLY ABSOLUTE ADDRESSING FOR LSH, ASH, AND ROT
PI7:	TRZ	F,NAF	
	LDB R,[POINT 4,LWT,17]	;INDEX REGISTER CHECK
	JUMPE	R,PIZ		;EXIT
	MOVEI	T,"("
	CALL	TOUT
	MOVE	T,R
	CALL	PAD
	MOVEI	T,")"
	CALL	TOUT		;EXIT
PIZ:	SKIPN	PINFF		;PRINT INSTRUCTION AC/EFF ADR?
	 RET			;NOPE RETURN NOW
	SETZM	PINFF		;NEVER CHANCE RECURSION...
	LDB T,[POINT 9,LWT,8]	;GET OPCODE
	MOVE	T,PCPNTB(T)	;GET TABLE ENTRY
	LDB R,[POINT 4,LWT,12]	;GET AC FIELD
	PUSH	P,LWT		;SAVE LWT OVER PRINTING
	TRNE	T,1		;OPEN THE AC?
	 JRST	PIZAC		;YES... 
	TRNN	T,2		;OPEN AC UNLESS IT IS ZERO?
	 JRST	PIZNAC		;NOPE, SO NEVER PRINT AC
	JUMPE	R,PIZNAC
PIZAC:	CALL	LCT
	MOVE	T,R		;ADDRESS INTO T
	CALL	LI1		;PRINT THE CONTENTS
PIZNAC:	LDB T,[POINT 9,(P),8]	;GET OPCODE
	MOVE	T,PCPNTB(T)	;GET TABLE ENTRY
	TRNN	T,4		;PRINT EFF ADR?
	 JRST	PIZEA		;NOPE, WE ARE DONE
	CALL	LCT
	MOVE	T,(P)		;FOR EFFADR
	CALL	EFFADR
	 JRST	PIZFAI
	move t,w1		;ADR MUST BE IN T FOR LI1
	CALL	LI1		;PRINT
PIZRET:	POP	P,T
	RET

pinerj:	push p,t		;type clobbers this
	call type		;show the ERxxx call
	pop p,t
	setom dontac		;don't show the ac field
	tro f,itf		;an instruction was typed
	jrst pfuli1

PIZFAI:	MOVEI	T,"?"
	CALL	TOUT
	JRST	PIZRET

PIZEA:	MOVE	T,(P)		;EVEN THOUGH WE DON'T PRINT EA, MAYBE SHOW IT
	TLNN	T,37		;ANY AC OR INDIRECT BITS?
	 JRST	PIZRET		;NOPE, SO DONE
	CALL	LCT
	MOVEI	W1,[ASCIZ \E.A. _ \]
	CALL	TYPE
	MOVE	T,(P)		;FOR EFFADR
	CALL	EFFADR
	 JRST	PIZFAI
	move t,w1
	TRZ	F,CF1		;SWIPED FROM '_' CODE
	TRO	F,LF1
	PUSH	P,LWT
	CALL	CONSYM		;BUT DON'T DESTROY LWT
	POP	P,LWT
	JRST	PIZRET

PI8A:	CAIL	W,600		; IS THIS A TEST INSTRUCTION?
	 CAILE	W,677
	  JRST	PI9		; NO
	TRNE	W,10		; DIRECT OR SWAPPED?
	 JRST	PI8		; YES, PRINT SYMBOLIC ADDRESS
	CALL	PADFLG		; TLXX OR TRXX, PRINT ADDRESS AS FLAGS
	JRST	PI7

PI8:	CALL	PAD
	JRST	PI7

PI9:	LDB	W,[POINT 13,LWT,12]
	ANDI	W,16007
	CAIL	W,16003		; OP GREATER THAN DATAO?
	 CAIN	W,16005		; AND NOT CONI?
	  JRST	PI8		; NO
	CALL	PADFLG
	JRST	PI7		; YES CONO, CONSZ AND CONSO PRINT BITS

HLFW:	HLRZ	T,LWT		;PRINT AS HALF WORDS
	JUMPE	T,HLFW1		;TYPE ONLY RIGHT ADR IF LEFT ADR=0
	TRO	F,NAF		;ALLOW NEGATIVE ADDRESSES
	CALL	PAD
	MOVSI	W1,(ASCII /,,/)
	CALL	TEXT2		;TYPE ,,
HLFW1:	HRRZ	T,LWT
	jrst pad

;PRINT ADDRESSES (ARG USUALLY 18 BITS BUT CAN BE 36 BITS)

piad:	push p,symptr		;old symptr
	push p,prgm		;current program
	push p,block		;current block
	setzm prgm		;say none
	setzm block		;likewise
	move s,jobsym		;get our own symbol table pointer
	movem s,symptr		;make it the current one
	call pad		;show our internal address
	pop p,block		;restore current block ptr
	pop p,prgm		;restore program-block pointer
	pop p,symptr		;restore user forks symptr
	ret

PAD:	TLZE	T,(DDTINT)	;this a DDT internal symbol?
	 JRST	PADINT		;  yes.
	JRST	@AR		;PADSO OR PAD1

PADSO:	tlnn t,37		;extended address?
	  jrst padso1		;  nope.
	skipe filimg		;if a data file image,
	  jrst padso0		;  then show all locations
	tdnn t,[777776,,777760]	;else if sections 0 & 1 locs 0-17 are ACs
	  jrst padso1		;  then it's really an AC
padso0:	push p,t		;yes, extended.  save address
	hlrzs t			;get section# in rh
	call toc0		;type it out
	movsi w1,(ascii /,,/)	;then
	call text2		;",,"
	pop p,t			;get back address
padso1:	tlz t,-1		;clobber LH, keep only sec-relative part
	JUMPE	T,FP7B		;PRINT A ZERO
	CALL	LOOK		;look for a matching symbol
PADS1:	 RET			;  LOOK found & typed out exact match
	JUMPGE	F,PADS3		;PRINT NUMBER if NO SYMBOL FOUND
	MOVE	W2,1(W1)	;we need symbol+offset printout now.
	CAMG	T,SYMOFS	;offset too large
	 CAIGE	W2,60		;  or symbol too low in mem,
	  JRST	PADS3		;    just type as a number
	movem t,tem		;save the value here.
	CALL	SPT0		;else type the symbol
PADS0A:	MOVEI	T,"+"		;then +
PADS1A:	CALL	TOUT
	move t,tem
PAD1:	JRST	TOC		;the offset, then done.

PADS3:	MOVE	T,TEM		;here to type out the location as a number.
PADS3A:	TRNE	F,NAF		;if negative address not allowed,
	 CAIGE	T,776000	;  or not a negative address at all,
	  JRST	TOC		;    then don't do this.
PADS3B:	movns t			;negate the value
	hrrzm t,tem		;then save the RH only
	MOVEI	T,"-"		;now we'll type out a minus sign
	JRST	PADS1A		;then the value (restore from TEM)

;PRINT INTERNAL ADDRESS

PADINT:	MOVEI	TT,777777	;INITIAL DIFFERENCE = ./.
	MOVE	S,[INTTAB-INTEND,,INTTAB]
PADIN1:	HRRZ	R,0(S)
	SUBM	T,R
	JUMPL	R,PADIN0	;NEGATIVE IS NOT SMALLER THAN 0
	CAMLE	R,TT
	 JRST	PADIN0		;NOT A BETTER MATCH
	MOVEM	R,TT		;NEW DIFFERENCE
	HLRZ	W1,0(S)		;NAME POINTER
PADIN0:	AOBJN	S,PADIN1
PADIN2:	JUMPE	TT,PADIN3	;EXACT MATCH
	CAIL	T,FRSTIR	;LOWER THAN 1ST INTERNAL REGISTER
	 CAIL	T,LASTIR	;GREATER THAN LAST INTERNAL
	  JRST	ERR
	MOVEM	TT,TEM
	CALL	PADIN3
	JRST	PADS0A

PADIN3:	MOVEI	W1,0(W1)		;GET ASCIZ
	CALL	TYPE
	RET

; PRINT ADDRESS AS FLAGS

PADFLG:	PUSH	P,T		; SAVE ADDRESS
	MOVEI	W1,3		;COUNT BITS TO SEE IF MORE THAN 3
	MOVN	W2,T		;FIND RIGHTMOST ONE IN T
	TDZE	T,W2		;SKIP IF NO MORE
	SOJGE	W1,.-2		;STOP COUNTING IF MORE THAN 3
	JUMPL	W1,PADFL6	;GO TYPE NUMBER IF MORE THAN 3 BITS
	MOVEI	T,400000	; START WITH LEFT MOST BIT
PADFL1:	TDNN	T,(P)		; IS THIS BIT IN THE THING
	JRST	PADFL2		; NO, GO TO NEXT BIT
	CALL	LOOKE		; LOOK UP THIS BIT
	  JRST	PADFL3		; EXACT MATCH FOUND AND PRINTED
	JRST	PADFL4

PADFL3:	MOVE	T,TEM
	ANDCAM	T,(P)		; REMOVE BIT FROM ADDRESS
	SKIPN	(P)		; ANY MORE TO BE OUTPUT?
	JRST	PADFL5		; NO
	MOVEI	T,"+"
	CALL	TOUT		; YES, TYPE !
PADFL4:	MOVE	T,TEM
PADFL2:	ASH	T,-1		; SHIFT TO NEXT BIT
	CAILE	T,10		;DONE BITS 18-31?
	JRST	PADFL1		;NO, GO DO NEXT BIT
PADFL6:	POP	P,T			; ELSE TYPE OUT THE REST AS A NUMBER
	JRST	TOC

PADFL5:	POP	P,T
	RET

;;
;;	given a PC in T: if it's section-relative (no section#), then turn
;;	it into an absolute address in the current section (cursec).  if
;;	it's already absolute, set the current section from the section#
;;	of the PC.
;;

xtndpc:	push p,1
	and t,[ddtint!xpc]		;keep only the PC parts
	tlnn t,37			;any section#?
	  jrst [move 1,cursec		;get current section
		dpb 1,[xsecbp t]	;turn sec-rel address into global
		jrst .+1]
	pop p,1
	ret

INOUT:	MOVE	T,LWT
	TDC	T,[-1,,400000]	;IO INSTRUCTION OR NEG NUM
	TDCN	T,[-1,,400000]
	  JRST	PADS3B		;TYPE AS NEG NUM
	LDB	R,[POINT 7,T,9]	;PICK OUT IO DEVICE BITS
	CAIL	R,700_-2	;IF DEVICE .L. 700, THEN TYPE
	  JRST	HLFW		;TYPE AS HALF WORDS
	LDB	R,[POINT 3,T,12]
	DPB	R,[POINT 6,T,8]	;MOVE IO BITS OVER FOR OP DECODER
	CALL	OPTYPE
	CALL	TSPC
	MOVSI	T,077400
	AND	T,LWT
	JUMPE	T,PI4
	CALL	LOOK		;LOOK FOR DEVICE NUMBER
	JRST	PI3A
	MOVE	T,TEM
	LSH	T,-30
	CALL	TOC
	JRST	PI3A

;PRINT AS JSYS ONLY IF EXACT MATCH IS FOUND.  IF NOT PRINTED, RETURNS TO PIN
;TO CALL OPTYPE TO GET THE INSTRUCTION PRINTED LIKE "JSYS 501"

JSTYPE:	move t,lwt		;get the instruction
	tlne t,777		;if AC, @, or X field
	  jrst [call pin0	;  type as instruction first
		call lct	;  move over a bit
		move t,lwt	;  get back instruction
		jrst .+1]	;  carry on as normal
	call effadr		;EA is the JSYS#, returned in w1
	  jfcl			;  don't care if direct or indirect
	HRRZM W1,TEM1		;SAVE EFFECTIVE ADDRESS
	HRRZ T,W1		;RH is the JSYS#
	CAIG T,777		;If not a valid JSYS#
	  SKIPN T,JSYTAB(T)	; or no name for this one?
	    JRST PIN0		;  so just print as JSYS nnn
	CALL SPT1		;PRINT NAME, EXIT FROM PIN
	JRST LCT

; $M COMMAND -- SET SEARCH MASK

	block 5
	[asciz ";M	Merge - merges file into fork, ala the EXEC's @MERGE command.
	Actually, I have no idea what this really does."]
	0			;no $$M
	[asciz "$[m]M	is the internal IDDT location holding mask $M, or mask $mM.
n$mM	sets search mask #m to n.  The 8 masks are originally defined
	as:

	mask	what	value
	----	----	-----
	$M	Full	-1
	$1M	RH	777777
	$2M	LH	777777,,0
	$3M	AC	740,,0
	$4M	X	17,,0
	$5M	Opcode	777000,,0
	$6M	Full	-1
	$7M	Full	-1 ;.SYMOFS"]
	0			;there is no "M" command

MASK:	TLNE	F,CCF		;HOW MANY $'S ?
	 JRST	ERR		;2
	MOVE	R,T
	MOVEI	T,MSK
	TRNE	F,Q2F		;ARGUMENT AFTER THE ESC
	  jrst [move tt,wrd2	;  get the value
		cail tt,0	;if out of
		  caile tt,7	;  range
		    jrst err	;    then no good
		addi t,(tt)	;get to the right mask
		jrst .+1]
	TLNN	F,QF
	 JRST	QUANIN		;INTERNAL REGISTER EXAMINATION SETUP
	MOVEM	R,(T)		;SET THE MASK
	JRST	RETX

; $D DELETE LAST SYM & PRINT NEW

	block 4
	[asciz "$$;D	converts $Q from unix-style 32-bit dateword (assumed left-justified
	in $Q) to T20 internal format then types it out ala $;D"]
	[asciz "$;D	types $Q as a TOPS-20 date&time dateword, via ODTIM%."]
	[asciz ";D	outputs . & .+1 as a doubleword float."]
	0
	[asciz "$D	suppresses typeout of the last symbol typed by IDDT, then displays
	the next best symbol match."]
	0			;there is no "D" command

SYMD:	MOVEI	T,DELO/200000
	HRRZ	R,SPSAV		;PICK UP POINTER TO LAST SYM
	JUMPE	R,ERR
	DPB T,[POINT 2,(R),1]	;STORE SEMI-DELETE BITS IN SYMBOL
	MOVE	T,LWT
	SETZM	PINFF		;NEVER WANT LONG INS PRINTOUT
	call lct		;space over a bit, then
	JRST	CONSYM		;PRINT OUT NEXT BEST SYMBOL

; $W -- WORD EQUALITY SEARCH

	block 5
	[asciz ";W	writes out the current symbol table to the prompted-to
	file."]
	0			;no $$W
	[asciz "n$mW	Word equality search: shows all locations (masked by mask #m,
	which default to 0, the fullword mask) whose contents are n.
a<b>n$mW
	is the same, but only searches locations a through b."]
	0			;there is no "W" command

WORD:	TLNE	F,QF		;ARG TYPED?
	 JRST	EFWRD		;YES, DO WORD SEARCH
	MOVEI	T,TRAPWD	;NO, EXAMINE $W REGISTER
	JRST	QUANIN

; $E -- EFFECTIVE ADDRESS SEARCH

	block 4
	[asciz "$;E	enables the inferior fork with your current capabilities."]
	[asciz ";E	changes the IDDT escape character.  You will be prompted for the
	new escape character, which is used to bring you back to IDDT from
	execution in the inferior process."]
	0			;no $$E
	[asciz "n$E	Effective address search.  Shows locations whose EA is n.
a<b>n$E
	Is the same, but only search locations a through b."]
	0

EFFEC:	TLNE	F,CCF		;HOW MANY $'S ?
	 JRST	ERR		;2
	TLO	F,TEMF
	HRRZS	T

; $W - word equality search

EFWRD:	move R,[JUMPE T,SEAR3]
	jrst nword0

; $N - word inequality search

	block 5
	[asciz ";N	types out $Q as an internet hostname.  Actually, it just feeds it
	to GTHST%, typing it as a.b.c.d if that fails."]
	0			;no $$N
	[asciz "
n$mN	Word NON-equality search: shows all locations (masked by mask #m,
	which default to 0, the fullword mask) whose contents are NOT n.
a<b>n$mN
	is the same, but only searches locations a through b."]
	0			;there is no "N" command

NWORD:	MOVE R,[JUMPN T,SEAR3]
nword0:	MOVEM R,SEAR2
	TLZN	F,QF		;QUANTITY TYPED IN?
	 JRST	ERR		; NO ARGUMENT
	MOVEI	TT1,MSK		;LOOK AT MASK
	TRNE	F,Q2F
	 ADD	TT1,WRD2	; BUT IF $<N>N USE THAT MASK
	MOVE	TT1,(TT1)	;GET VALUE
	MOVEM	TT1,CURMSK	;AND SAVE IT
	INTON
	SETCAM	T,WRD
	MOVE	T,ULIMIT	;WHAT TO USE IF SECOND ARG TYPED
	TLNE	F,SAF		;IF 2ND ARG...
	 TLO	F,QF		;FOOL SETUP
	CALL	SETUP		;1ST ADDR TO DEFV, LAST TO ULIMIT
	CALL	CRF
SEAR1:	CALL	FETCH		;OF R
	 JRST	SEAR2B
	TLNE	F,TEMF		;CHECK FOR EFFECTIVE ADDRESS SEARCH
	  JRST	EFFEC0		; DO E.A. COMPARE, RETURN TO SEAR2X
	EQV	T,WRD
	AND	T,CURMSK

;GO TO SEAR3 IF A FIND HAS OCCURRED
SEAR2X:	XCT	SEAR2		;A JUMPE T,SEAR3 OR JUMPN T,SEAR3
SEAR2A:	AOS	R,DEFV		;GET NEXT LOCATION
	CAMG	R,ULIMIT	;END OF SEARCH?
	  JRST	SEAR1		;NO, LOOK SOME MORE

;AT END OF SEARCH
SEARFN:	SETCMM	LWT		;COMPLEMENT BITS BACK AND STOP SEARCH
	SETZM	DEFV
	SETZM	ULIMIT
	JRST	DD1

SEAR2B:	MOVEI	R,777
	IORB	R,DEFV		;SKIP TO NEXT PAGE
	JRST	SEAR2A

;FOUND A MATCH,  R IS WHERE
SEAR3:	MOVE	R,DEFV
	CALL	FETCH
	 JRST	ERR
	TLZ	F,STF		;GET RID OF SUPPRESS TYPEOUT MODE
	MOVE	T,DEFV
	SETZM	PINFF		;DON'T PRINT EFF ADR OR AC
	CALL	LI1		;EXAMINE REGISTER
	CALL	CRF
	SETCMM	LWT
	SETCMM	TEM
	JRST	SEAR2A

;CALCULATE EFFECTIVE ADDRESS AND DO
;COMPARE FOR INSTRUCTION AT  R
EFFEC0:	MOVEI	W,20		;@ CHAIN DEPTH, MAX.
	MOVEM	W,TEM
EFFEC1:	MOVE	W,T
	LDB	R,[POINT 4,T,17]	;GET XR FIELD
	JUMPE	R,EFFEC2	;NO XR SPECIFIED, TRY FOR @
	CALL	FETCH		;THE XR
	 JRST	ERR
	ADD	T,W		;ADD IN THE XR

;T HAS THE INDEXED ADDRESS, SEE IF @
EFFEC2:	HRR	R,T
	TLNN	W,(@)		;INDIRECT BIT CHECK
	  JRST	EFFEC3		;NONE, R HAS EFFECTIVE ADDR
	SOSE	TEM		;CHECK @ CHAIN LENGTH
	CALL	FETCH		;GET INDIRECT WORD
	 JRST	SEAR2A		;CAN'T GET IT => NO MATCH
	JRST	EFFEC1		;GO BACK AND TRY TO INDEX

;GOT IT. DO COMPARE ON ADDRESS
EFFEC3:	EQV	T,WRD
	ANDI	T,777777
	JRST	SEAR2X

;SETUP SEARCH LIMITS
;1ST ADDR (0) TO R AND DEFV, LAST TO ULIMIT
;USED BY SEARCHES (W,N,E) AND ZERO (Z)
SETUP:	TLNN	F,QF		;QUANTITY TYPED (2ND ARG)?
	  MOVEI	T,777777	;NO, DEFAULT LAST ADDRESS
	HRRZM	T,ULIMIT	;SAVE TOP OF SEARCH/ZERO
	HRRZS	R,DEFV		;GET 1ST ADDRESS
	TLNN	F,FAF		;WAS A 1ST ADR SPECIFIED?
	  SETZB	R,DEFV		;NO, MAKE IT ZERO
	CAMLE	R,ULIMIT	;LIMITS IN A REASONABLE ORDER?
	  JRST	ERR		;NO
	RET			;YES, RETURN

; $$Z  ZERO MEMORY FROM ZLOW TO ULIMIT AND AC'S

	block 6
	[asciz "$$Z	zero inferiors memory and ACs"]
	0			;no $Z
	0			;there is no "Z" command

ZERO:	TLNN	F,CCF
	  JRST	ERR
	CALL	UNMAP		;FORGET ABOUT ANY MAPPED PAGE
	CALL	SETUP
ZERO0:	CAIL	R,700000
	CAIL	R,740000
	 JRST	ZERO2		;NOT ZERO'ING COMPATIBILITY
	MOVE	1,FORK
	PUSH	P,R
	SETZB	2,3
	SCVEC			;FLUSH PAT
	POP	P,R
ZERO2:	MOVE	T,WRD2		;0 (OR WHATEVER) TO STORE IN MEMORY
ZERO3:	CAMLE	R,ULIMIT		;ABOVE LIMITS?
	 JRST	DD1		;YES, STOP
	TRNN	R,777		;START OF PAGE?
	JRST	ZERO4		;YES, CHECK FOR EXISTENCE
ZERO33:	CALL	DEP		;DEPOSIT T AT USER LOC IN R
	 JRST	ZERO5		;WOULDN'T DEPOSIT
	AOJA	R,ZERO0

ZERO4:	JUMPN	T,ZERO33		;NOT REALLY ZEROING
	MOVE	TT,ULIMIT
	SUB	TT,R		;NUMBER OF WORDS LEFT TO ZERO
	CAIGE	TT,777		;LESS THAN A PAGE?
	JRST	ZERO33		;YES, ZERO THEM
ZERO5:	MOVE	TT,R		;R=2
	HRRZS	2
	LSH	2,-11
	HRL	2,FORK
	SETZ	3,			;WATCH OUT FOR KL20
	SETOM	1
	PMAP
	MOVE	R,TT
	IORI	R,777		;TOP OF THIS PAGE
	AOJA	R,ZERO0		;DO NEXT PAGE

; $O command - select byte output

	block 5
	[asciz ";O	Obtains symbols from the prompted-for .UNV file."]
	[asciz "$$nO	permanently selects n-bit byte typeout mode, redisplaying $Q."]
	[asciz "$nO	temporarily selects n-bit byte typeout mode, redisplaying $Q."]
 	0			;there is no "O" command

BITO:	MOVEI	R,BITT		;BYTE OUTPUT SUBROUTINE
	HRRZI	AR,TOC
	TRZN	F,Q2F
	 JRST	ERR
	skipg t,wrd2		;gotta be
	  jrst err		;  greater than zero
	MOVEM	T,SVBTS
	MOVEI	T,^D36
	IDIV	T,WRD2
	SKIPE	T+1
	  ADDI	T,1
	MOVEM	T,SVBTS2
	HRRZ	SCH,R
	JRST	BASE1

BITT:	MOVE	T,SVBTS2
	MOVEM	T,SVBT2
	MOVE	T+1,LWT
	MOVEM	T+1,SVBT3
	PUSH	P,LWT
BITT2:	MOVEI	T,0
	MOVE	T+2,SVBTS
	LSHC	T,(T+2)
	MOVEM	T,LWT
	MOVEM	T+1,SVBT3
	CAIE	AR,PADSO
	CALL	TOCA
	CAIE	AR,TOC
	CALL	PIN
	SOSG	SVBT2
	JRST	BITT4
	MOVEI	T,","
	CALL	TOUT
	MOVE	T+1,SVBT3
	JRST	BITT2

BITT4:	POP	P,LWT
	RET

;NUMERIC OUTPUT SUBROUTINE

LWTTOC:	MOVE T,LWT		;Get the value to be typed.
FTOC:
TOC:	HRRZ	W1,ODF
	CAIN	W1,10		;IS OUPUT RADIX NOT OCTAL, OR
	 TLNN	T,-1		;ARE THERE  NO LEFT HALF BITS?
	  JRST	TOCA		;YES, DO NOTHING SPECIAL
	HRRM	T,TOCS		;NO, TYPE AS HALF WORD CONSTANT
	HLRZS	T		;GET LEFT HALF
	CALL	TOC0		;TYPE LEFT HALF
	MOVSI	W1,(ASCII /,,/)
	CALL	TEXT2		;TYPE ,,
TOCSX:	XCT	TOCS		;A MOVEI T,.-. TO GET RIGHT HALF BACK
TOCA:	HRRZ	W1,ODF		;IS OUTPUT RADIX DECIMAL?
	CAIN	W1,^d10
	 JRST	TOC4		;YES,TYPE SIGNED WITH PERIOD
TOC0:	LSHC	T,-43
	LSH	W1,-1		;W1=T+1
	DIVI	T,@ODF
	HRLM	W1,0(P)
	SKIPE	T
	 CALL	TOC0
	HLRZ	T,0(P)
	cail	t, ^d10
	 addi	t, "A"-"0"-^d10
	ADDI	T,"0"
	JRST	TOUT

TOC4:	MOVM	A,T		;TYPE AS SIGNED DECIMAL INTEGER
	JUMPGE	T,TOC5
	MOVEI	T,"-"
	CALL	TOUT
TOC5:	CALL	FP7		;DECIMAL PRINT ROUTINE
TOC6:	MOVEI	T,"."
	JRST	TOUT

;SYMBOL OUTPUT SUBROUTINE

SPT0:	HRRZM	W1,SPSAV	;SAVE POINTER TO TYPED SYM
SPT:	skipn t,svfb		;get symbol's block
	  jrst spt1w		;  doesn't have one?  then skip block typeout.
	CAMN	T,BLOCK		;same as last time?
	 JRST	SPT1W		;  yes, so don't repeat block.
	movem t,block		;different.  save new block.
	PUSH	P,W1
	LDB	T,[POINT 32,(T),35]
	CALL	SPT1		;type the block name
	MOVEI	T,"|"		;then
	CALL	TOUT		;| as separator
	POP	P,W1
SPT1W:	LDB T,[POINT 32,(W1),35]	;GET SYMBOL
;	jrst spt1		;fall into RADIX50 symbol typer

;RADIX 50 SYMBOL PRINTER

SPT1:	PUSH P,T
	MOVEI T,TOUT
	MOVEM T,SPTSUB
	POP P,T

SPT1a:	IDIVI	T,50
	HRLM	W1,0(P)
	JUMPE	T,SPT2
	CALL	SPT1a
SPT2:	HLRZ	T,0(P)
	JUMPE	T,CPOPJ		;FLUSH NULL CHARACTERS
	ADDI	T,260-1
	CAILE	T,271
	 ADDI	T,301-272
	CAILE	T,332
	 SUBI	T,334-244
	CAIN	T,243
SPT3:	 MOVEI	T,256
	JRST @SPTSUB

;FLOATING POINT OUTPUT

TFLOT:	MOVE	A,T
	JUMPG	A, TFLOT1
	JUMPE	A,FP1A
	MOVNS	A
	MOVEI	T,"-"
	CALL	TOUT
	TLZE	A,400000
	  JRST	FP1A
TFLOT1:	TLNN	A, 400
	  JRST	TOC5		;IF UNNORMALIZED, TYPE AS DECIMAL INTEGER

FP1:	MOVEI	S,0
	CAMGE	A,FT01
	  JRST	FP4
	CAML	A,FT8
	  AOJA	S,FP4
FP1A:	MOVEI	W,0

FP3:	MULI	A,400
	ASHC	S,-243(A)
	SETZM	TEM1		;INIT 8 DIGIT COUNTER
	SKIPE	A,S		;DON'T TYPE A LEADING 0
	CALL	FP7		;PRINT INTEGER PART OF 8 DIGITS
	CALL	TOC6		;PRINT DECIMAL POINT
	MOVNI	A,10
	ADD	A,TEM1
	MOVE	W1,W
FP3A:	MOVE	T,W1
	MULI	T,^d10
	CALL	FP7B
	SKIPE W1
	  AOJL	A,FP3A
	RET

FP4:	MOVNI	W,6
	MOVEI	W2,0
FP4A:	ASH	W2,1
	XCT FCP(S)
	  JRST	FP4B
	FMPR	A,@FCP+1(S)
	IORI	W2,1
FP4B:	AOJN	W,FP4A
	PUSH	P,W2		;SAVE EXPONENT
	PUSH	P,FSGN(S)	;SAVE "E+" OR "E-"
	CALL	FP3		;PRINT OUT FFF.FFF PART OF NUMBER
	POP	P,W1		;GET "E+" OR "E-" BACK
	CALL	TEXT
	POP	P,A		;GET EXPONENT BACK

FP7:	IDIVI	A,^d10		;DECIMAL OUTPUT SUBROUTINE
	AOS TEM1
	HRLM	S,(P)
	JUMPE	A,FP7A1
	CALL	FP7

FP7A1:	HLRZ	T,(P)
FP7B:	ADDI	T,260
	JRST	TOUT

FCP:	CAMLE	A, FT0(W)
	CAMGE	A, FT(W)
	Z	FT0(W)

;8,9-BIT TEXT TYPERS

TEXT8:	SKIPA	1,[8]		;8 AND 9 BIT TYPERS DONT GUESS ABOUT
TEXT9:	  MOVEI 1,9		;LEFT BYTE
	MOVE	W1,T
	PUSH	P,[-4]
	JRST	ALLTXT

TEXTT:	MOVE	W1,T		;MAKE IT <ALT><NUM><QUOTE>FOOBAR<ALT>
	MOVEI	T,"$"
	CALL	TOUT
	MOVEI	T,"0"
	TRZE	W1,1
	 MOVEI	T,"1"
	CALL	TOUT
	MOVEI	T,quote
	CALL	TOUT
	SETZ	2,
	PUSH	P,[-5]
	JRST	TEXTXX

TEXT:	SETO	2,
	PUSH	P,[-1000]
TEXTX:	TLNN	W1,774000	;LEFT JUSTIFIED UNLESS LEFT CHAR IS NULL
	LSH	W1,35
	JRST	TEXTXX

TEXT2:	SETO	2,
	PUSH	P,[-1000]
TEXTXX:	  MOVEI 1,7		;7-BIT BYTES IN W1
ALLTXT:	PUSH	P,1		;TEXT IN W1. BYTESIZE IN 1
ALLTX1:	MOVEI	T,0
	LSHC	T,@0(P)
	CALL UTOUT
	AOSE	-1(P)		;COUNTER
 	 JUMPN W1,ALLTX1
	MOVEI	T,"$"
	SKIPN	2
	 CALL	UTOUT
	POP	P,1
	POP	P,1
	RET

;STRING TYPER, ANY LENGTH.  W1 HAS BYTE POINTER

TYPE:	TLNN	W1, -1
	 HRLI	W1, <(POINT 7,)>
	EXCH	W1, 1
	PSOUT
	EXCH	W1, 1
	RET

TYPE0:	TLNN W1,-1		;Same as TYPE, but count the characters.
	  HRLI W1,<(POINT 7,)>
type1:	ILDB T,W1
	JUMPE T,CPOPJ
	CALL TOUT
	JRST type1

CRF:	MOVEI	T,cr		;TYPE CARRIAGE RETURN
	CALL	TOUT
	MOVEI	T,lf		;TYPE NEW LINE, then
crf0:	CALL	TOUT
	SETZM	HPOS
	RET

CRN:	movei t,cr
	jrst crf0

;TYPE LOWER CASE AND TAB, FROM PDP-1!!!
LCT:	CALL	TSPC		;3 spaces
tdspc:	CALL	TSPC		;2 spaces

;TYPE SPACE

TSPC:	push p,t
	MOVEI	T," "		;SPACE
	call tout
	pop p,t
	ret

;CHARACTER OUTPUT FROM AC1

TOUT:	EXCH	1,T
	ANDI	1,177
	TYO
	EXCH	1,T
	AOS	HPOS
	RET

UTOUT:	PUSH P,1
	ANDI T,177		;Only want low 7 bits of ASCII
	CAIN T,177		;Rubout is special
	  JRST [MOVEI 1,"^"
		TYO
		AOS HPOS
		MOVEI 1,"?"
		JRST UTOUT0]
	CAIGE T,40
	  JRST [PUSH P,T
		MOVEI 1,"^"
		TYO
		AOS HPOS
		POP P,1
		TRO 1,100	;Non-control this character
		JRST UTOUT0]
	MOVE 1,T
UTOUT0:	ANDI 1,177
	TYO
	AOS HPOS
	POP P,1
	RET

;ALIGNMENT (MAYBE) IN T, THE NUMBER YOU WANT

TALIGN:	CAMG	T,HPOS
	 POPJ	P,	 
	PUSH	P,T
	MOVEI	T," "
	CALL	TOUT
	POP	P,T
	JRST	TALIGN

TIN:	SKIPN	T,BBC		;ANY BUFFER-BACK CHARACTER?
	 JRST	TINZ		;NOPE, NORMAL PROCESSING
	SETZM	BBC		;CLEAR THE CHARACTER
	RET			;AND RETURN

TINZ:	SKIPE	STRING		;ARE WE INPUTTING FROM A STRING?
	 JRST	TINST		;  yes!
TIN0:	TDNE	F,[CF,,SEMIF]	;NEED TO SEE EACH CHR AS IT COMES IN?
	 JRST	TIN6		;  YES
	MOVE	T,STRIP		;IN PTR
	CAME	T,STROP		;OUT PTR
	 JRST	TIN4		; NON-EMPTY BUFFER
TIN1:	MOVE	T,[POINT 7,STRBUF-1,34]
	MOVEM	T,STRIP
	MOVEM	T,STROP
IFE	KL20F,<
TIN2:	CALL	GETC
	CAIN	T,"V"-100
	  JRST [CALL TINCV	;^V
		JRST TIN2A]
	CAIN	T,177
	  JRST	TINCA		;<rubout>
TIN2A:	IDPB	T,STRIP		;STORE IT IN BUF
	MOVE	T,STRIP
	CAMN	T,[POINT 7,STRBUF+STRBFL-1,34]
	 JRST	ERR		;BUFFER FULL
TIN3:	LDB	T,STRIP		;GET BACK THE CHR
	CAIL	T,"A"
	 CAILE	T,"Z"
	  CAIA
	   JRST	TIN2		;UPPERCASE LETTER, KEEP GOING
	CAIL	T,"a"
	 CAILE	T,"z"
	  CAIA
	   JRST	TIN2		;LOWERCASE LETTER
	CAIL	T,"0"
	 CAILE	T,"9"
	  CAIA
	   JRST	TIN2
TIN4:	ILDB	T,STROP		;RETURN NEXT CHR FROM BUFFER
TIN5:	CAIN	T,37		;TENEX EOL CHARACTER
	 MOVEI	T,cr		;EOL BECOMES CR ON WAY OUT
	RET

TIN6:	CALL	GETC
	JRST	TIN5

;CONTROL V (QUOTE NEXT CHARACTER)
TINCV:	TYI			;CHARACTER INTO 1
	MOVE	T,1
	CAIE	T,esc
	 RET
	MOVEI	T,"$"
	CALL	TOUT		;ECHO $ FOR ALTMODE
	MOVEI	T,esc
	RET

;DELETE PREVIOUS CHARACTER
TINCA:	MOVE	T,STRIP
	CAMN	T,STROP
	 JRST	WRONG		;BUFFER EMPTY

TINCA0:	
IFN DELCHF,<
	MOVEI	1, .PRIOU
	DELCH
	 JRST	.+4
	 JRST	.+3
	 JRST	TINCA2
	 JFCL
>
TINCA1:	MOVEI	T,"\"
	CALL	TOUT
	LDB	T,STRIP
	CALL	TOUT
TINCA2:	SOS	STRIP		;UNDEX BYTE PTR
	REPEAT	4,<IBP STRIP>
	JRST	TIN2
>	; Kl20f


IFN	KL20F,<
	movem	t, textib+.rddbp	; Set up byte pointer
	movei	t, strbfl*5		; Buffer length
	movem	t, textib+.rddbc	; Set up count

tin2:	movei	1, textib
	texti				; Get the poop
	 jrst	err			; Lossage
	move	t, textib+.rddbp	; Get updated pointer
	camn	t, [point 7, strbuf-1, 34]
	 jrst	wrong			; Nothing new
	ldb	1, t			; Get char that made it wake up
	camn	1, escchr		; User's escape?
	 jrst	wrong			; Yes
	movem	t, strip		; Update pointer
	caie	1, 33			; ESC?
	 jrst	tin4			; Nope
	movei	t, "$"
	call	tout			; Echo as $

tin4:	ildb	t, strop		; Get first char
	Ret

tin6:	jrst	getc			; Get char


textib:	7
	rd%rnd!rd%jfn!rd%sui
	.priin,,.priout
	point	7, strbuf
	strbfl*5
	0
	0
	textim

; Break character set for texti
textim:	777757,,777760		; All controls except <CR>
	747764,,001760		; Not on $,%,. or 0-9
	400000,,000760		; Nor letters
	400000,,000760		; Nor lowercase letters

>	; KL20F

ttpeek:	move	t, strop	; opt buffer pointer
	camn	t, strip	; Buffer empty?
	 tdza	t, t		; Return 0
	ildb	t, t		; Else get char
	ret

;INPUT FROM STRING AT BPT
TINST:	ILDB	T,STRING
	JUMPN	T,TINST1	;NOT END OF STRING
	SETZM	STRING		;SAY NO MORE
	JRST	TIN0		;GET FROM TTY

TINST1:	CAIE	T,33
	CALL	TOUT		;SAY WHAT WE READ
	JRST	GOTC

;GET CHARACTER AND CHECK FOR ESCAPE CHR

GETC:	TYI			;INPUT MAY BE FROM FILE (REDIRECT)
	MOVE	T,1
GOTC:	CAIE	T,esc
	 JRST	GETC2
	MOVEI	T,"$"
	CALL	TOUT
	MOVEI	T,esc
GETC2:	CAIE	T,"U"-100
	 CAMN	T,ESCCHR
	  JRST	WRONG
	cain t,cr		;a CR from the TTY
	  jrst [TYI		;  is always followed by LF
		movei t,cr	;  but just return the CR
		jrst .+1]
	RET

;[NIC250] - Rewritten DEP routine

;Deposit into memory subroutine, R has address, T has value.
;LH of R indicates if it is internal to DDT -- LIKE $3B, etc.

dep:	skipe debug		;debugging output?
	  call depbug		;  yassss...
	tlne r,(ddtint)		;internal?
	  jrst depint		;  yes, do it
	tdnn r,[777776,,777760]	;sections 0 & 1 locs 0-17 are ACs
	  jrst [movem t,ac0(r)	;  deposit in AC
		jrst cpopj1]	;  win-return
	push p,r		;save user's address
;	call unmap		;why is this necessary?  is it?
	call chkadr		;CHECK ADDRESS, MAP INTO UCORE
	jumpe tt,dep2		;IF NO PAGE, OK TO STORE
	tlne tt,(pa%wr!pa%cpy)	;STORE OK IF WRITE OR WRITE-COPY
	  jrst dep2
	hrrz 1,(p)		;neither, try to unprotect page
	lsh 1,-11
	hrl 1,fork
	movsi 2,(pa%rd!pa%wt!pa%ex!pa%cpy)
	SPACS%
	  erjmp dep3
	call dep4
	move r,(p)		;get back the user address
	call chkadr		;and try again
dep2:	movem t,ucore(r)	;store the value
	  erjmp dep3		;  just in case
	aos -1(p)		;skip-return for winnage
dep3:	pop p,r			;restore user's address
	ret

dep4:	PUSH 	P,T		;inform the user that a page was
	PUSH 	P,1		;make local (copied)
	CALL 	LCT
	POP	P,T
	HRRZI	T,(T)
	PUSH	P,W1
	CALL	TOC
	MOVE	W1,[POINT 7,[ASCIZ /$U/]]
	CALL	TYPE
	POP	P,W1
	POP	P,T
	ret
;[NIC250] - End of rewritten DEP routine

depbug:	push p,w1
	push p,w2
	push p,t		;value
	push p,r		;address
	call terpri
	hrroi w1,[asciz "D> DEP from "]
	call type
	hrrz t,-5(p)		;return address of caller of DEP
	subi t,1		;the actual call
	call piad		;print iddt address
	hrroi w1,[asciz ": "]
	call type
	move t,(p)		;the address
	call pad		;type the address
	hrroi w1,[asciz "/ "]
	call type
	setzm pinff		;only print the instruction
	move t,-1(p)		;the value
	call consym
	call crf
	pop p,r
	pop p,t
	pop p,w2
	pop p,w1
	ret

DEPINT:	MOVEI	TT,PC
	CAIE	TT,0(R)
	 JRST	DEPIN4		;NOT CHANGING PC
DEPIN1:	HRRZ	TT,PC		;GET ADDRESS PART
	CAIE	TT,0(T)		;CHANGING TO SOMETHING DIFFERENT?
	 SETZM	BPTFLG		;YES, DONT RESUME AT CURRENT BREAKPT.
	CAIE	TT,0(T)
	 JRST	DEPIN3		;TURN ON USERMODE, TO GET SFORK

DEPIN2:	MOVSI	TT,(1B5)
	TDNE	TT,PC		;COPY USERMODE BIT FROM OLD PC WORD
DEPIN3:	 TLO	T,(1B5)
	MOVEM	T,REALPC
	JRST	DEPIN5

DEPIN4:	MOVEI	TT,USRPSI	;SEE IF TRYING TO CHANGE REQUESTS.
	CAIN	TT,0(R)
	 RET			;CAN'T DO THAT.
DEPIN5:	MOVEM	T,0(R)		;STORE INTO INTERNAL REGISTER
	JRST	CPOPJ1		;SKIP RETURN

;[NIC250] - Rewritten FETCH routine

;Fetch from memory subroutine, R has address.  LH indicates internal or not
;Returns +2 on success with value in T

FETCH:	tlne r,(ddtint)		;internal read?
	  jrst [move t,0(r)	;  yes, so get it from internal register in DDT
		jrst cpopj1]	;  and win-return
	tdnn r,[777776,,777760]	;section 0 & 1 loc 0-17 are ACs?
	  jrst [skipe filimg	;Yes, but is this a file image?
		  jrst .+1	;  yes, so get the location
		move t,ac0(r)	;no, really an AC, so get the value
		jrst cpopj1]	;and win-return
	move t,r		;xtndpc wants pc in t
	call xtndpc		;extendify this address
	move r,t		;put it back in r now
fetch0:	push p,r		;save user's address
	call chkadr		;get the page mapped and check access
	tlnn tt,(pa%rd)		;read access?
	  jrst fetch1		;  nope
	move t,ucore(r)		;get the value into t
	  erjmp fetch1		;page may not exist
	aos -1(p)		;skip-return
fetch1:	pop p,r			;get user's addr back
	ret
;[NIC250] - End rewritten FETCH routine

SETFRK:	PUSH	P,2
	PUSH	P,1
	CALL	UNMAP
	RFSTS
	 erjmp fchk1
	TLC	1,-1
	TLNN	1,-1
	 JRST	FCHK1
	CALL	SETUSR
	POP	P,FORK
	CALL	GETUSR
	MOVE	1,FORK
	POP	P,2
	JRST	CPOPJ1

FCHK1:	POP	P,1
	POP	P,2
	RET

;[NIC250] - Rewritten CHKADR routine

;Check user's address in R=2; Bring it into UCORE if not already there
;Returns access to page in TT; TT/0 means no page

CHKADR:	PUSH	P,1
	PUSH	P,3
	PUSH	P,2		;R=2
	ldb 1,[XPCBP r]		;DESIRED ADDRESS
	LSH	1,-9		;DESIRED PAGE
	HRL	1,FORK		;FORM FORK,,PAGE
	MOVE	2,IDPACS	;ACCESS TO CURRENTLY MAPPED PAGE
	TLNE	2,(pa%pex)	;DOES NOT EXIST, OR
	 CAME	1,LASTPG	;DIFFERENT PAGE?
	  JRST	CHKA2		;YES

;Page is already mapped.  Make R have an offset into UCORE

CHKA1:	POP	P,R		;ORIGINAL ADDRESS REQUESTED
	ANDI	R,777		;CONVERT TO OFFSET INTO MAPPED PAGE
	move tt,idpacs		;TT IS WHERE ACCESS INFO IS RETURNED
	POP	P,3
	POP	P,1
	ret

;Map user's page into IDDT's UCORE

CHKA2:	movem 1,lastpg		;Save for next time
	move 2,[.fhslf,,ucore/1000]
	movsi 3,(pm%rd!pm%wr!pm%ex)
	PMAP%			;map the page in
	 erjmp [call geter	;get the last error in AC1
		caie 1,argx23	;Invalid section number?
		  jrst chka3	;  no, just just lossage
		call maksec	;yes, so try making the section
		  jrst chka3	;  oops...
		move 1,lastpg	;restore bashed AC1
		jrst chka2]	;succeeded, try again now
	move 1,2
	RPACS%			;now check the access
	  erjmp chka3		;  gack??
	tlnn 2,(pa%pex)		;does the page exist?
chka3:	  setz 2,		;  no, so return 0 access word
	move tt,2
	movem 2,idpacs
	jrst chka1

geter:	push p,2		;return last error code in AC1
	movei 1,.fhslf
	GETER%
	hrrz 1,2
	pop p,2
	ret

maksec:	push p,1
	push p,2
	push p,3
	setz 1,
	hrrz 2,lastpg		;page#
	lsh 2,-3*3		;get the section#
	hrl 2,fork		;ph,,section#
	move 3,[sm%rd!sm%wr+1]
	SMAP%			;create the section
	  erjmp .+2
	    aos -3(p)		;skip-return on win
	pop p,3
	pop p,2
	pop p,1
	ret

;[NIC250] - End rewritten CHKADR routine

;UNMAP THE PAGE CURRENTLY MAPPED INTO UCORE
UNMAP:	PUSH	P,1
	PUSH	P,2
	PUSH	P,3
	SETZB	3,IDPACS	;CLEAR BIT 5, AND 3 FOR KL20
	SETOB	1,LASTPG	;IMPOSSIBLE PAGE NUMBER
	MOVE	2,[.FHSLF,,UCORE/1000]
	PMAP			;AWAY!
	POP	P,3
	POP	P,2
	POP	P,1
	RET

;TABLE SAYING WHAT TO DO ABOUT EACH INSN VIS-A-VIS OPENING ITS AC
;AND MEMORY ADDRESS. EACH OP CODE HAS A 4-BIT BYTE.
;1 BIT => OPEN THE AC.
;2 BIT => OPEN THE AC UNLESS THE AC FIELD IS 0.
;4 BIT => OPEN THE MEMORY LOCATION.

;HANDLE AN INSTRUCTION LIKE "AND" WHICH HAS DIRECT, IMMED., MEMORY AND BOTH.

DEFINE AIMB (BITS) <
	EXP 5, 1+BITS, 5, 5
>

PCPNTB:
REPEAT 40,<EXP 0>	;0-47 - USER UUOS
REPEAT 40,<EXP 0>	;50-77 - UUO'S MEDIATED BY SYSTEM
REPEAT 4,<EXP 0>	;100-103 unused
	0		;104 JSYS
	0		;105 ADJSP
REPEAT 22,<EXP 5>	;106-127 UNUSED.
	5		;130 UFA
	5		;131 DFN
	1		;132 FSC
	6		;133 IBP
	5		;134 ILDB
	5		;135 LDB
	5		;136 IDPB
	5		;137 DPB
REPEAT 40,<EXP 5>	;140-177 - floating point
REPEAT 4,<		;200-217 - MOVE, MOVS, MOVN, MOVM
	5			;TO AC.
	1			;IMMEDIATE
	5			;TO MEMORY.
	6			;TO SELF.
>
REPEAT 4,<		;220-237 - IMUL, MUL, IDIV, DIV	220-237
	AIMB	0		;TO AC, IMMED, TO MEM, TO BOTH.
>
REPEAT 10,<EXP 1>	;240-247 - SHIFTS, AND JFFO
	5		;250 EXCH
	1		;251 BLT
	1		;252 AOBJP
	1		;253 AOBJN
	0		;254 JRST
	0		;255 JFCL
	4		;256 XCT
	5		;257 UNUSED
	0		;260 PUSHJ
	4		;261 PUSH
	4		;262 POP
	1		;263 POPJ
	0		;264 JSR
	1		;265 JSP
	1		;266 JSA
	1		;267 JRA
	AIMB	0	;270-273 ADDx
	AIMB	0	;274-277 SUBx
REPEAT 10,<EXP 1>	;300-307 CAIx
REPEAT 10,<EXP 5>	;310-317 CAMx
	0		;320 JUMP
repeat 7,<exp 1>	;321-327 JUMPL-JUMPG
repeat 10,<exp 6>	;330-337 SKIP-SKIPG
REPEAT 2,<		;340-377 AOJ,AOS; SOJ,SOS.
REPEAT 10,<EXP 1>		;AOJ, SOJ.
REPEAT 10,<EXP 6>		;AOS, SOS.
>
	1		;400 SETZ
	1		;401 SETZI
	4		;402 SETZM
	5		;403 SETZB
	AIMB	0	;404-407 ANDx
	AIMB	0	;410-413 ANDCAx
	AIMB	0	;414-417 SETMx
	AIMB	0	;420-423 ANDCMx
	1		;424 SETA
	1		;425 SETAI
	5		;426 SETAM
	5		;427 SETAB
	AIMB	0	;430-433 XORx
	AIMB	0	;434-437 ORx
	AIMB	0	;440-443 ANDCBx
	AIMB	0	;444-447 EQVx
	1		;450 SETCA
	1		;451 SETCAI
	5		;452 SETCAM
	5		;453 SETCAB
	AIMB		;454-457 ORCAx
	5		;460 SETCM
	11		;461 SETCMI
	4		;462 SETCMM
	5		;463 SETCMB
	AIMB	0	;464-467 ORCMx
	AIMB	0	;470-473 ORCBx
	1		;474 SETO
	1		;475 SETOI
	4		;476 SETOM
	5		;477 SETOB
REPEAT 10,<		;500-537 - HLL, HRL, HLLZ, ..., HRLE
	5			;TO AC.
	1			;IMMEDIATE.
	5			;TO MEM.
	6			;TO SELF.
>
REPEAT 10,<		;540-577 - HRR, HLR, HRRZ, ..., HLRE
	5			;TO AC.
	1			;IMMEDIATE.
	5			;TO MEM.
	6			;TO SELF.
>
REPEAT 4,<		;600-677 - TRNx, TRZx, TRCx, TROx
REPEAT 10,<EXP 1>		;THE TR AND TL VARIANTS.
REPEAT 10,<EXP 5>		;THE TD AND TS VARIANTS.
>
REPEAT 100,<EXP 4>	;700-777 - I/O instructions

;TYPE OP CODE OF INSTR IN LWT
;OP CODE EVALUATER.  TXT, TXT+1 HAVE 6 OR LESS ASCII
; CHARACTERS PACKED WITH A 7 BIT IDPB.

OPEVAL:	MOVSI W1,-1000		;JSYSi 0 - 777
	MOVE T,SYM
OPEVA0:	CAMN T,JSYTAB(W1)
	  JRST [HRRZ T,W1
		HRLI T,(JSYS)	;Make into a JSYS
		JRST CPOPJ1]	;and done.
	AOBJN W1,OPEVA0

	MOVEI	T,0		;NOT A JSYS SO DO USUAL OP EVAL
	IDPB	T,CHP		;INSERT NULL IN TEXT FOR SYMBOL
	MOVEM	P,SAVPDL
	TRZA	F,OUTF
OPTYPE:	TRO	F,OUTF		;TYPE AN OPCODE SYMBOLICALLY
	LSH	T,-33
	MOVEM	T,INST		;GET OPCODE INTO RIGHT 9 BITS
	MOVE	T,[POINT 7,TXT]
	MOVEM	T,CHP		;FOR OPEVAL,SETUP POINTER TO INPUT TEXT
	TRZ	F,ITF		;CLEAR INSTRUCTION TYPED FLAG
	CLEARB	R,W1
	MOVE	W2,BTAB
DC1:	ILDB	T,W2		;GET NEXT BYTE IN TBL
	CAILE	T,40
	 CAIL	T,74
	  SOJGE	R,DC1		;SKIP OVER # BYTES = C(R)
	JUMPG	R,DC1		;SKIP OVER ALPHA TEXT WITHOUT COUNTING
	SUBI	T,40
	JUMPE	T,DECX		;TRANSFER ON ASTOP CODE
	JUMPG	T,DC2
	DPB	T,[340500,,PNTR]	;SETUP R ON A DISPATCH BYTE
	TRZ	T,-4
	AOS	T
	DPB	T,[300600,,PNTR]
	TRNN	F,OUTF
	  JRST	DC6		;FOR OPEVAL ONLY
	LDB	R,PNTR		;GET # BYTES TO SKIP OVER
	JRST	DC1

DC2:	HRREI	T,-33(T)
	JUMPL	T,DECT		;TYPE OUT A LETTER
	jumpg	t, dc3		; Byte .ge. 74?
	ildb	t, w2
	movei t, 1000-74*2+1(t)	; Add in extension
dc3:	MOVEI	W1,FIR.-1(T)	;BYTE IS A TRANSFER
	IDIVI	W1,4
	MOVE	W2,BTAB(W2)	;CALCULATE POINTER TO NEXT BYTE
	ADDI	W2,(W1)
	JRST	DC1

DECT:	TRNE	F,OUTF
	JRST	DC8		;TYPE OUT A LETTER
	ILDB	W1,CHP		;GET NEXT INPUT LETTER
	CAIE	W1,133(T)	;COMPARE WITH ASSUMED NEXT LETTER
	JRST	NOMAT		;DOESNT MATCH
	JRST	DC1		;MATCHES, TRY NEXT

DECX:	TRNE	F,OUTF		;STOP (CODE 40) HAS BEEN SEEN
	  RET			;IF FOR OUTPUT, RETURN
	ILDB	W1,CHP		;GET NEXT INPUT CHAR IF ANY
	JUMPE	W1,DC7		;DOES # OF CHARS MATCH
NOMAT:	POP	P,R		;NO, BACK UP AND TRY SOME MORE
	POP	P,W2
	POP	P,PNTR
	POP	P,CHP
NOMAT1:	AOS	R			;ASSUME NEXT NUMBER FOR BIN VALUE
	DPB	R,PNTR		;STUFF INTO ANSWER
	LDB	R,PNTR
	JUMPN	R,DC6AA		;IF =0, BYTE WAS TOO BIG
	CAME	P,SAVPDL
	  JRST	NOMAT		;NOT AT TOP LEVEL
	RET			;UNDEFINED, FINALLY

DC6:	MOVEI	R,0		;ASSUME 0 FOR INITIAL BINARY VALUE
	DPB	R,PNTR
DC6AA:	CAMN	P,SAVPDL
	  JRST	DC6BB
	LDB	T,-2(P)		;OLD VALUE OF PNTR
	CAME	T,(P)
	  JRST	NOMAT1
DC6BB:	PUSH	P,CHP
	PUSH	P,PNTR
	PUSH	P,W2
	PUSH	P,R
	JRST	DC1

DC7:	MOVE	P,SAVPDL	;RESTORE PUSH DOWN POINTER
	MOVE	T,INST
	LSH	T,33		;PUSH BINARY INTO POSITION FOR OPEVAL
	LDB	R,[POINT 3,T,8]
	TLC	T,700000
	TLCN	T,700000
	  DPB R,[POINT 10,T,12]	;ONLY DONE FOR IO INSTRUCTIONS
	JRST	CPOPJ1		;SYMBOL FOUND, SKIP RETURN

DC8:	TRO	F,ITF		;SET INSTRUCTION TYPED FLAG
	MOVEI	T,133(T)
	CALL	TOUT		;OUTPUT A LETTER
	SETZM	SPSAV		;SO $D WONT TRY TO DELETE OP CODES
	JRST	DC1

	SUBTTL	CONTROL-T INTERRUPT HANDLER

CT.PSI:	PUSH	P,TEM
	PUSH	P,TEM1
	PUSH	P,SVFB
	PUSH	P,SVTB
	PUSH	P,SPSAV
	PUSH	P,BLVL
	ADD	P,[20,,20]
	JUMPGE	P,CT.PSY
	MOVEM	0,-17(P)
	HRLI	0,1
	HRRI	0,-16(P)
	BLT	0,0(P)

CT.PS1:	MOVEI	1,-1		;CTY:
	RFCOC
	PUSH	P,2
	PUSH	P,3
	MOVE	2,TTYCC2
	MOVE	3,TTYCC3
	SFCOC			;SETUP TTY FOR IDDT

CT.PS2:	call terpri
	movei 1,.priou		;terminal
	seto 2,			;now
	movsi 3,(ot%nda)	;no date, just now
	ODTIM			;output the current time
	call tspc		;then a space
	MOVE	1,FORK		;DO CURRENT FORK
	CALL	FSTAT		;show fork status
	CALL	USED		;RETURNS DELTA CPU AND CONSOLE IN 1,2
	hrroi w1,[asciz ", "]
	call type
	call load		;display the load
	CALL	VIEW		;then any user register
	CALL	CRF

CT.PS9:	POP	P,3
	POP	P,2
	MOVEI	1,-1
	SFCOC

CT.PSX:	HRLI	0,-16(P)
	HRRI	0,1
	BLT	0,17
	MOVE	0,-17(P)
CT.PSY:	SUB	P,[20,,20]
	POP	P,BLVL
	POP	P,SPSAV
	POP	P,SVTB
	POP	P,SVFB
	POP	P,TEM1
	POP	P,TEM
	DEBRK

;DO FORK STATUS FOR FORK HANDLE IN 1

FSTAT:	RFSTS
IFN KL20F,<erjmp fstatd>
	HLRZ	3,1		;get the flag bits into AC1
	CAIN	3,-1		;-1 means for went away,
	 JRST	FSTATD		;  i guess.
	PUSH	P,2		;SAVE THE PC FOR LATER

FSTAT1:	TRZ 3,(1B0)		;FROZEN BIT
	CAIN	3,.rftrp	;trap?
	 JRST	FSTAT2		;  yes
	CAIE	3,.rfhlt	;halted,
	 CAIN	3,.rffpt	;  or forced process termination?
FSTAT2:	  TLZ	1,(1B0)		;    yes
	movei w1,[ASCIZ /^D from /]
	skipe bptflg
	  move w1,[asciz "Broke from "]
	TLNE	1,(1B0)
	 CALL	TYPE

FSTAT3:	MOVSI	W1,(POINT 7,)
	HRR	W1,frksts(3)
	CALL	TYPE
	MOVE	1,WHY
	MOVE	W1,MSG(1)
	CAIN	3,.rffpt
	 CALL	TEXT2

FSTAT4:	MOVE	W1,[ASCIZ / at /]
	CALL	TEXT
	POP	P,T		;THE PC
	and t,[xpc]		;ONLY THE PC
	CALL	PAD
	RET

FSTATD:	MOVE	W1,[POINT 7,[ASCIZ /Fork disappeared/]]
	CALL	TYPE
	RET

;TYPE THE LOAD AVERAGE

load:	skipe systab		;know the table# for SYSTAT?
	  jrst load0		;  yes, have it already.
	move 1,[sixbit /SYSTAT/]
	SYSGT			;get it
	jumpe 2,cpopj		;failed!
	hrli 2,14		;magic index 14 is 1-minute average
	movem 2,systab		;save index,,table#
load0:	move 1,systab		;get index,,table#
	GETAB			;get the load
	  ret			;  lost!
	push p,1		;save for now
	hrroi w1,[asciz "Load "]
	call type
	movei 1,.priou		;to the tty
	pop p,2			;the #
	move 3,[fl%one+fl%pnt+fl%ovl+fld(2,fl%fst)+fld(2,fl%snd)]
	FLOUT			;output the load
	  jfcl
	ret

;TYPE TIME USED ETC SINCE LAST RESET
; RETURNS  DELTA CPU TIME IN 1 AND DELTA CONSOLE TIME IN 2

USED:	CALL	LCT
	MOVNI	1,5
	RUNTM
	SUB	1,TIMUSD
	PUSH	P,1		;delta-CPU
	PUSH	P,2		;TICK/SEC
	SUB	3,TIMCON	;get delta-console time
	PUSH	P,3		;dCONSOLE
	MOVE	W1,[ASCIZ /Used /]
	CALL	TEXT
	MOVE	T,-2(P)		;delta-CPU
	MOVE	TT,-1(P)	;ticks/sec
	CALL	TIMPRT
	MOVE	W1,[ASCIZ / in /]
	CALL	TEXT
	MOVE	T,0(P)		;delta-console
	MOVE	TT,-1(P)	;ticks/sec
	CALL	TIMPRT
	POP	P,2
	SUB	P,[1,,1]
	POP	P,1
	RET

;TIME PRINTER

;	T:	TIME TO BE PRINTED IN SECONDS
;	TT:	NUMBER OF TICKS PER SECOND

tquant:	^d<24*60*60>		;days
	^d<60*60>		;hours
	^d60			;minutes
	1			;seconds
ntquant==.-tquant

TIMPRT:	push p,tt1
	PUSH	P,T
	PUSH	P,TT
	IDIVI	T,0(TT)		;GET SECONDS
	PUSH	P,T+1
	trz f,temf		;use temp flag to say first non-0 quanta found
	movsi tt1,-ntquan	;aobjn to quant table
timpr0:	move 1,tquant(tt1)	;divisor
	idivi t,(1)		;see how many of this size quanta
	caig 1,1		;if 1 (seconds)
	  jrst timpr1		;  then always show, even if 0
	jumpn t,timpr1		;some...
	trnn f,temf		;need to see 0's now?
	  jrst timpr2		;  no, so ignore
timpr1:	movei 1,.priou
	movei 2,":"
	trne f,temf		;first one?
	  BOUT			;  no, so colon as separator
	move 2,t		;the units
	trne f,temf		;first one?
	 skipa 3,[no%lfl+no%zro+no%oov+fld(2,no%col)+^d10]
	  movei 3,^d10		;yes, floating width decimal
	NOUT			;output it
	  jfcl			;  shouldn't fail
	tro f,temf		;not the first one anymore
timpr2:	move t,t+1		;work on the remainer now
	aobjn tt1,timpr0	;go do the next quanta
	movei 2,"."		;decimal point
	BOUT			;now
	move 2,-1(p)		;get ticks/sec
	idivi 2,^d10		;TICKS PER 1/10 TH OF A SECOND
	pop p,t			;fractions of seconds (in ticks)
	idivi t,(2)		;FIND OUT HOW MANY TENTHS
	movei 2,"0"(t)		;turn into a char
	BOUT			;blast it out
	pop p,tt
	pop p,t
	pop p,tt1		;restore locals used by us
	RET
;PRINT THE CELL TO BE VIEWED (SET BY ;V)

VIEW:	SKIPGE	R,VADDR		;IS THERE ANYTHING?
	 RET			;NO. WE ARE DONE
	HRRZS	R
	CALL	FETCH		;MEM(R) TO T
	 RET			;CAN'T SO FORGET IT
	PUSH	P,T
	CALL	LCT		;TYPE A TAB
	HRRZ	T,VADDR
	CALL	PAD		;PRINT THE ADDRESS
	MOVEI	T,"/"
	CALL	TOUT
	CALL	LCT		;TYPE A TAB
	POP	P,T
	SETZM	PINFF		;NEVER WANT LONG INSTRUCTION PRINTOUT
	JRST	CONSYM		;TYPE AS CONSTANT OR SYMBOLIC

CRLF:	ASCIZ "
"

TERPRI:	MOVEI 1,.PRIOU
	RFPOS			;Get current position in line...
	TLZ 2,-1		;(which is in the RH)
	HRROI 1,CRLF
	SKIPE 2			;If not already at left margin
	  PSOUT			;  then put us there.
	SETZM HPOS
	RET

BARF:	CALL BARF0
	HRROI 1,CRLF
	PSOUT
	RET

BARF0:	MOVEI 1,.PRIOU
	MOVEI 2,"?"
	BOUT
	HRLOI 2,.FHSLF
	SETZ 3,
	ERSTR
	  JFCL
	  JFCL
	RET

PRTVER:	MOVEI 1,.PRIOU
	MOVEI 2,V%MAJOR
	MOVEI 3,^D10
	NOUT
	  JFCL
	MOVEI 2,"."
	BOUT
	MOVEI 2,V%MINOR
	NOUT
	  JFCL
	MOVEI 2,"("
	BOUT
	MOVEI 2,V%EDIT
	NOUT
	  JFCL
	MOVEI 2,")"
	BOUT
	MOVEI 2,"-"
	BOUT
	MOVEI 2,V%WHO
	NOUT
	  JFCL
	RET

;READ-ONLY AREA
RO:
;INTERNAL REGISTER MAP
;LH HAS POINTER TO TEXT FOR NAME
;RH HAS POINTER TO VALUE
DEFINE	INTDIS	(X) <
	$'X'B+6,,$'X'B>

	QZ==1
	RADIX	10
INTTAB:	REPEAT	NBP,<
	INTDIS	\QZ
	QZ==QZ+1>
	RADIX	8
	[ASCIZ /$X/],,XRG
	[ASCIZ /$G/],,PC
	[ASCIZ /$W/],,TRAPWD
	[ASCIZ /UUO/],,UUOL
	[ASCIZ /$M/],,MSK
	[ASCIZ /$1M/],,MSK+1
	[ASCIZ /$2M/],,MSK+2
	[ASCIZ /$3M/],,MSK+3
	[ASCIZ /$4M/],,MSK+4
	[ASCIZ /$5M/],,MSK+5
	[ASCIZ /$6M/],,MSK+6
	[ASCIZ /$7M/],,MSK+7
	[ASCIZ /$I/],,USRPSI
	[ASCIZ /;.SYMOFS/],,SYMOFS
	[ASCIZ /;.PC/],,PC
	[asciz ";.DEBUG"],,debug
INTEND:

INSYMB:
	[SIXBIT /SYMOFS/],,SYMOFS
	[SIXBIT /PC/],,PC
	[sixbit "DEBUG"],,debug
INSYME:

	353473426555	;1.0E32
	266434157116	;1.0E16
FT8:	233575360400	;1.0E8
	216470400000	;1.0E4
	207620000000	;1.0E2
	204500000000	;1.0E1
FT:	201400000000	;1.0E0
	026637304365	;1.0E-32
	113715126246	;1.0E-16
	146527461671	;1.0E-8
	163643334273	;1.0E-4
	172507534122	;1.0E-2
FT01:	175631463146	;1.0E-1
FT0=FT01+1

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;	Dispatch tables.  For each character (ASCII 0 - 137): LH,,RH
;;	where LH is for ;char, and RH is for char or $char
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

DISP:	REPEAT ^D8,<ERR,,ERR>	;^@ - ^G
	ERR,,VARRW		;BACKSPACE (^H)
	TAB,,TAB		;TAB (^I)
	ERR,,LINEF		;LINE-FEED (^J)
	err,,err		;^K
	ERR,,CTRLL		;^L
	ERR,,CARR		;CARRIAGE-RETURN (^M)
	ERR,,CTRLN		;^N
	REPEAT ^D11,<ERR,,ERR>	;^O - ^Y
	ERR,,HHALT		;^Z
	ERR,,CONTROL		;ESCAPE (^[) ] balance
	ERR,,NPTCH		;^\
	ERR,,NPTCH2		;^]
	ERR,,ERR		;^^
	err,,help		;^_
	SEMSPA,,SPACE		;SPACE
	ERR,,DIVD		;!
	TEXTYP,,TEXI		;"
	ERR,,CHRI		;#
	ERR,,DOLLAR		;$
	ERR,,PERC		;%
	ERR,,SQZI		;&
	ERR,,SIXI		;'
	ERR,,LPRN		;(
	ERR,,RPRN		;)
	ERR,,MULT		;*
	ERR,,PLUS		;+
	ERR,,ACCF		;,
	ERR,,MINUS		;-
	INTSYM,,PERIOD		;.
	ERR,,SLASH		;/
	REPEAT ^D10,<NUM,,NUM>	;0 - 9
	ERR,,TAG		;:
	SEMIC,,SEMIC		;";"
	ERR,,FIRARG		;<
	EQUAL,,EQUAL		;=
	ERR,,ULIM		;>
	SEM.QU,,QUESTN		;?
	INDIRECT,,INDIRECT	;@
	ADRSPC,,ABSA		;A
	PRBRK,,BPS		;B
	ERR,,CON		;C
	DATPRT,,SYMD		;D
	ESCAP,,EFFEC		;E
	SEMI.F,,SFLOT		;F
	ERR,,GO			;G
	HHALT,,HWRDS		;H
	PSIST,,INTRUP		;I
	SEMI.J,,JSTEP		;J
	ERR,,KILL		;K
	LOADGO,,LOADER		;L
	MERGE,,MASK		;M
	HSTPRT,,NWORD		;N
	OBTAIN,,BITO		;O
	ERR,,PROCED		;P
	ERR,,QUAN		;Q
	RJCL,,RELA		;R
	SNARF,,SYMBOL		;S
	LISTS,,TEXO		;T
	SEMI.U,,UNPRO		;U
	SEMI.V,,LEFT		;V
	SYMSOT,,WORD		;W
	SETSEC,,XEC		;X
	YANK,,YSTEP		;Y
	ERR,,ZERO		;Z
	ERR,,OCON		;[
	ERR,,ICON		;\
	ERR,,OSYM		;]
	ERR,,VARRW		;^
	ERR,,PSYM		;_
	err,,err		;`
	repeat ^d26,<err,,err>	;lowercase same as uppercase
	err,,err		;{
	err,,setblk		;|
	err,,err		;}
	err,,err		;~
	err,,err		;rubout

;DESCRIPTION OF OP DECODER FOR DDT:
;
;THE ENTIRE INSTRUCTION SET FOR THE PDP-10 CAN BE COMPACTED INTO
;A SPACE MUCH SMALLER THAN ONE REGISTER FOR EVERY SYMBOL.  THIS OCCURS
;BECAUSE OF THE MACHINE ORGANIZATION AND INSTRUCTION MNEMONICS CHOSEN
;FOR THE PDP-10.  FOR EXAMPLE, IF BITS (0-2) OF AN INSTRUCTION EQUAL
;101(2) THE INSTRUCTION IS A HALF WORD INSTRUCTION AND AN "H" MAY
;BE ASSUMED. "T" MAY BE ASSUMED FOR ALL TEST INSTRUCTIONS (WHICH
;BEGIN WITH 110(2).
;
;THE TABLE TBL IN DDT CONSISTS OF 9 BIT BYTES, 4 TO A WORD.
;THE NUMBERS IN THE BYTES HAVE THE FOLLOWING SIGNIFICANCE:
;
;0-37(8)
;       THIS IS A DISPATCH COMMAND FOR THE OP-DECODER INTERPRETER.
;	LET THE RIGHT MOST TWO BITS EQUAL N; LET THE NEXT 3 BITS
;	EQUAL P.
;
;	THE CONTENTS OF INST (INSTRUCTION) CONTAIN IN THE RIGHT
;	MOST NINE BITS THE BINARY FOR THE MACHINE INSTRUCTION.
;	P AND N REFER TO THE CONTENTS OF INST, AND THE OP DECODER
;	WILL PRODUCE AN ANSWER D GIVEN P, N, AND THE CONTENTS
;	OF INST.  N+1 IS THE NUMBER OF BITS IN INST WHICH ARE
;       TO BE CONSIDERED.  P GIVES THE
;	POSITION (NUMBER OF BITS FROM THE RIGHT EDGE) OF THE N+1 BITS.
;
;	EXAMPLE: P = 6
;	         N = 2
;
;	C(INST) = .010 101 100(2)
;
;	THE RESULT = D = 010(2) = 2(8)
;
;	D IS USED AS A DISPATCH ON THE NEXT BYTES IN THE TABLE.
;	IF D = 5, 5 BYTES IN THE TABLE (DON'T COUNT THE BYTES WHICH
;	PRINT TEXT, 41-72(8)) ARE SKIPPED OVER AND THE 6TH BYTE RESUMES
;	THE INTERPRETATION.
;
;40(8)	THIS IS A STOP CODE; WHEN THIS IS REACHED INTERPRETATION
;	IS FINISHED.

;41(8)-72(8)      THE ALPHABET IS ENCODED INTO THIS RANGE.
;	        41- A
;	        42- B
;	        72- Z
;	        WHEN A BYTE IN THIS RANGE IS REACHED, ITS CORRESPONDING
;	        LETTER IS TYPED.
;
;73(8)-777(8)     THIS IS A TRANSFER BYTE.  IF THE BYTE IN THIS RANGE IS
;	        CONSIDERED TO BE A, TRANSFER INTERPRETATION
;		TO THE A-73(8) BYTE IN THE TABLE.
;
;MACROS TO ASSEMBLE THE OPCODE TREE
;
;.TRA FOO	CAUSES INTERPRETER TO TRANSFER TO THE POINT IN THE
;		TREE TAGGED "FOO".
;
;.ADR FOO	CAUSES THIS POINT IN THE TREE TO BE TAGGED "FOO".
;
;.END 		MARKS A LEAF (A DEEPEST POINT) IN THE TREE. 
;		INTERPRETATION RESUMES AT THE NEXT HIGHEST
;		BRANCH.
;
;.TXT STUFF	CAUSES THE TEXT "STUFF" TO BE PACKED AS ONE ASCII
;		CHARACTER PER 9-BIT BYTE IN THE TREE.  THE
;		INTERPRETER TAKES NO ACTION IF IT ENCOUNTERS TEXT.
;
;.DIS MN	WHERE M AND N ARE TWO ONE-DIGIT INTEGERS.  M IS THE
;		NUMBER OF BITS TO THE RIGHT OF THE FIELD OF INTEREST.
;		N  IS THE NUMBER OF BITS TO CONSIDER.  FOR INSTANCE
;		.DIS 63  WILL CONSIDER THE LEFT THREE BITS OF A 9-BIT
;		OPCODE STORED IN  INST.  THE INTERPRETER DISPATCHES
;		0 TO 7 BYTES TO THE RIGHT DEPENDING ON THE VALUE
;		OF THE SELECTED FIELD.
;
;
;WHEN USED TO LOOKUP AN OPCODE (OPEVAL),  THE INTERPRETER
;OPERATES BY TYPING OUT ALL OPCODES A CHARACTER AT A TIME,
;CHECKING EACH CHARACTER FOR EQUALITY AGAINST THE KEY THAT IS
;BEING LOOKED UP.  THUS, TO LOOK UP "JRST", THE INTERPRETER
;TRIES ALL TOP LEVEL BRANCHES UNTIL IT FINDS ONE WHICH WILL TYPE OUT
;A "J",  AND THEN PROCEEDS TO SEE IF THE REST OF THAT BRANCH WILL
;TYPE OUT  "RST".  ETC.

SUBTTL	OP	DECODER

DEFINE BYT9 (A) <IRP A,<
A>>

IF1,<

DEFINE	.ADR	(A) <
%'A==	CLOC
FIR.==	CLOC
DEFINE	.ADR	(B) <
%'B==	CLOC
LASTB==CLOC+74-FIR.>>

DEFINE	.TRA(A)<CLOC==	CLOC+1 >
DEFINE	.TRAX(A)<CLOC==CLOC+2>

SYN	.TRA,	.DIS

DEFINE	.TXT	(A) <
IFNB	<A>,	<IRPC A,<CLOC==CLOC+1>>>

DEFINE	.END	(A) <
IFNB	<A>,	<IRPC A,<CLOC==CLOC+1>>
CLOC==	CLOC+1>

>		;END OF IF1
IF2,<

DEFINE .ADR (A)<IFN %'A-CLOC,<PRINTX PHASE ERR AT: %'A>>

DEFINE	.TRA	(A) <OUTP	%'A+74-FIR.>

DEFINE .TRAX (A),<OUTP 73
	OUTP	74+<Z1==%'A-FIR.-1000+74>
	IFL	Z1,<PRINTX "A" TOO SMALL FOR .TRAX>>

DEFINE	.DIS	(A) <OUTP	A&70/2+A&7-1>

DEFINE	.TXT	(A) <IFNB <A>,	<IRPC A,<OUTP "A"-40>>>

DEFINE	.END	(A) <
IFNB	<A>,	<IRPC A,<OUTP "A"-40>>
OUTP	40>

DEFINE OUTP (A)<
IFGE	<A>-1000,<PRINTX OPTABLE BYTE "A" TOO BIG>
IFE	<BINC==BINC-9>-^D27,<BINR1==A>
IFE	BINC-^D18,<BINR2==A>
IFE	BINC-9,<BINR3==A>
	IFE	BINC,<	BYTE (9) BINR1,BINR2,BINR3,<A>
	BINC==^D36>
CLOC==CLOC+1 >
>

TBL:  ;OPDECODER BYTE TABLE

CLOC== 0 ;SET BYTE LOCATION COUNTER TO 0
BINC== ^D36 ;INIT BYTES/WORD COUNTER


;**********THE ARGUMENT FOR THE FOLLOWING "BYT9" MACRO
;**************TERMINATES AT THE NEXT COMMENT WITH: **************
;;	TO INCLUDE UUOS IN THE DECODER TABLE, REPLACE THE FIRST
;;	.DIS 63,.END WITH .DIS 63,.TRA UUO

BYT9 <

.DIS 63,.END,.TRA FLO,.TRA HAK,.TRA ACCP,.TRA BOOLE
	.TXT H,.TRA HWT,.TXT T,.TRA ACBM


;IO INSTRUCTIONS

.DIS 21,.TRA BD,.TXT CON,.DIS 11,.TRA OI,.TXT S,.DIS 01,.TRA Z,.TRA O
.ADR BD,.DIS 01,.TXT BLK,.TRA IO,.TXT DATA,.ADR IO,.DIS 11,.TRA I,.TRA O
	.ADR OI,.DIS 01,.TRA O,.TRA I
;UUOS

.ADR UUO,.DIS 51,.END,.TXT,.DIS 32,.TRA U40,.TRAX U50,.TRA U60
	.DIS 21,.TRAX U703,.DIS 11,.TRA USET,.DIS 01
.TXT LOOKU,.TRA P,.TXT ENTE,.TRA R,.ADR USET,.TXT USET,.DIS 01,.TRA I,.TRA O
.ADR U40,.DIS 03,.TRAX CAL,.TXT INI,.TRA T,.END,.END,.END,.END,.END,.TXT CALL,.TRA I
.ADR U60,.DIS 21,.TRA U603,.DIS 01,.TXT IN,.TRA BPUT,.TXT OUT
	.ADR BPUT,.DIS 11,.TXT BU,.ADR F,.END F,.TXT,.TXT PU,.TRA T
.ADR U603,.DIS 01,.TRA U6062,.TXT STAT,.DIS 11,.ADR O,.END O,.TXT,.ADR Z,.END Z,.TXT
	.ADR U6062,.DIS 11,.TXT S,.TRA U62,.TXT G,.ADR U62,.TXT ETST,.TRA S

;BYTE AND FLOATING INSTRUCTIONS

.ADR FLO,.DIS 51,.TRA BYTE,.TXT F,.DIS 32,.TXT,.TXT AD,.TRA A,.TXT SB
	.TRA A,.TXT MP,.TRA A,.TXT DV,.ADR A
.DIS 21,.TRA LMB,.TXT R,.TRA IMB,.ADR LMB,.DIS 02,.END,.TXT
	.ADR	L,.END L,.TXT,.ADR M,.END M,.TXT
.ADR B,.END B,.TXT,.ADR BYTE,.DIS 32,.TRAX I100,.TRAX I110,.TRA I120,.TXT
	.DIS 03,.TXT UF,.TRA PA,.TXT DF,.TRA N
.TXT FS,.TRA C,.TXT IB,.ADR P,.END P,.TXT,.TXT I,.TRA LD
	.ADR LD,.TXT LD,.TRA B,.TXT I,.TRA DP,.ADR DP,.TXT DP,.TRA B

;FWT-FIXED POINT ARITH-MISC

.ADR HAK,.DIS 33,.TRA MV,.ADR MV,.TXT MOV,.TRA MO,.TRA ML,.TRA DV
	.TRA SH,.TRA H1,.TRA JP
.DIS 21,.TXT ADD,.TRA IMB,.TXT SU,.ADR BIMB,.TXT B,.ADR IMB,.DIS 02,.END,.TXT
	.ADR I,.END I,.TXT,.TRA M,.TRA B,.ADR MO,.DIS 22
.ADR EIMS,.TXT E,.TRA IMS,.TXT S,.TRA IMS,.TXT N,.TRA IMS,.TXT M
	.ADR IMS,.DIS 02,.END,.TXT,.TRA I,.TRA M,.ADR S,.END S,.TXT
.ADR ML,.DIS 21,.TXT I,.TRA ML1,.ADR ML1,.TXT MUL,.TRA IMB
	.ADR DV,.DIS 21,.TXT I,.TRA DV1
.ADR DV1,.TXT DI,.ADR DV2,.TXT V,.TRA IMB,.ADR H1,.DIS 03,.TXT EXC,.TRA S3,.TXT BL
	.ADR T,.END T,.TXT,.TRA AO,.ADR AO,.TXT AOBJ
.TRA AOB,.TXT JRS,.TRA T,.TXT JFC,.TRA L,.TXT XC,.TRA T,.TXT MA,.TRA P
	.ADR AOB,.DIS 01,.TRA P,.TRA N
.ADR JP,.DIS 03,.TRA PU,.ADR PU,.TXT PUSH,.TRA PUS,.TRA PO
	.ADR PO,.TXT POP,.TRA POP,.TXT JS,.ADR R,.END R,.TXT
.TXT JS,.TRA P,.TXT JS,.ADR PA,.END A,.TXT,.TXT JR,.TRA PA
	.ADR PUS,.DIS 01,.ADR J,.END J,.END,.TXT,.ADR POP
.DIS 01,.END,.TXT,.TRA J,.ADR SH,.DIS 02,.TXT A,.TRA S2,.TXT ROT,.TRA S1,.TXT L
	.ADR S2,.TXT S,.ADR S3,.TXT H,.TRA S1,.DIS 21,.TXT JFF,.TRA O,.END
	.ADR S1,.DIS 21,.END,.TXT,.ADR C,.END C,.TXT

;ARITH COMP-SKIP-JUMP

.ADR ACCP,.DIS 42,.TXT CA,.TRA CA1,.TRA SJ,.TXT A,.TRA JS,.TXT S
	.ADR JS,.TXT O,.DIS 31
.TXT J,.TRA COMP,.TXT S,.TRA COMP,.ADR CA1,.DIS 31,.TXT I,.TRA COMP,.TXT M,.TRA COMP
.ADR SJ,.DIS 31,.TXT JUM,.TRA PSJ,.TXT SKI,.ADR PSJ,.TXT P,.ADR COMP
.DIS 03,.END,.TXT,.TRA L,.ADR E,.END E,.TXT,.TXT L,.TRA E,.TRA PA,.TXT G,.TRA E
	.ADR N,.END N,.TXT,.END G,.TXT
;HALF WORDS

.ADR HWT,.DIS 51,.TRA HW1,.DIS 21,.TXT R,.TRA HW2,.TXT L,.ADR HW2,.TXT R,.TRA HW3
.ADR HW1,.DIS 21,.TXT L,.TRA HW4,.TXT R,.ADR HW4,.TXT L
	.ADR HW3,.DIS 32,.TRA IMS,.TXT Z,.TRA IMS,.TXT O,.TRA IMS,.TRA EIMS

;TEST INSTRUCTIONS

.ADR ACBM,.DIS 31,.TRA AC1,.DIS 01,.TXT D,.TRA AC2,.TXT S,.TRA AC2
	.ADR AC1,.DIS 01,.TXT R,.TRA AC2,.TXT L
.ADR AC2,.DIS 42,.TXT N,.TRA EAN,.TXT Z,.TRA EAN,.TXT C,.TRA EAN,.TXT O
	.ADR EAN,.DIS 12,.END,.TXT,.TRA E,.TRA PA,.TRA N

;BOOLEAN

.ADR BOOLE,.DIS 24,.TRA ST,.ADR AN,.TXT AND,.TRA B2,.TRA AN,.TRA ST,.TRA AN,.TRA ST
.TXT X,.ADR OR,.TXT OR,.TRA B2,.TXT I,.TRA OR,.TRA AN,.TXT EQ
	.TRA DV2,.TRA ST,.TRA OR,.TRA ST,.TRA OR,.TRA OR
.ADR ST,.TXT SET,.ADR B2,.DIS 24,.TXT Z,.TRA IMB,.TRA IMB
	.ADR CA,.TXT C,.TRA TA,.ADR TM,.TXT M,.TRA IMB
.ADR CM,.TXT C,.TRA TM,.ADR TA,.TXT A,.TRA IMB,.TRA IMB,.TRA IMB
	.ADR CB,.TXT C,.TRA BIMB,.TRA IMB,.TRA CA
.TRA CA,.TRA CM,.TRA CM,.TRA CB,.TXT O,.TRA IMB
;INSTRUCTION GROUP 120
.ADR I120,.DIS 11,.TRAX DMOV,.DIS 01,.TXT FIX,.TRAX FIX2,.DIS 21,.END EXTEND
	.TXT FLT,.ADR FIX2,.DIS 21,.END,.TRA R
.ADR DMOV,.TXT DMOV,.DIS 01,.TXT E,.TRAX EM,.TXT N
	.ADR EM,.DIS 21,.END,.TRA M

;MORE UUO'S

.ADR U50,.DIS 03,.TXT OPE,.TRA N,.TXT TT,.ADR CAL,.TXT CAL,.TRA L,.END,.END,.END
	.TXT,.TXT RENAM,.TRA E,.TXT I,.TRA N,.TXT OU,.TRA T
.ADR U703,.DIS 02,.TXT CLOS,.TRA E,.TXT RELEA,.TRA S
	.TXT MTAP,.TRA E,.TXT UGET,.TRA F

;INSTRUCTION GROUP 110 - DF ARITHMETIC
.ADR I110,.DIS 21,.TXT DF,.TRAX DF,.TXT D,.TRAX FXDP,.ADR DF,.DIS 02
	.END AD,.END SB,.TXT M,.TRA P,.END DV

;KL10 FIXED POINT DOUBLE PRECISION OPERATIONS
.ADR FXDP,.DIS 02,.END ADD,.END SUB,.END MUL,.END DIV

;OPCODES 100 TO 107 COME HERE
.ADR I100,.DIS 21,.END,.DIS 02,.TRAX JSYS,.TRAX ADJS,,.END,.END
	.ADR JSYS,.END JSYS,.ADR ADJS,.END ADJSP
;**********THIS TERMINATES THE "BYT9" MACRO ARGUMENT******
>

IF1,<	BLOCK	<CLOC+3>/4>
IF2,<	IFN BINC-^D36,<	BYTE (9) BINR1,BINR2,BINR3,0>>

IFNDEF CLOC.,<CLOC.==CLOC>
IFN CLOC.-CLOC,<PRINTX PHASE ERROR IN OPTABLE>

BTAB:	POINT	9,TBL	;TABLE USED TO GET NEXT BYTE POINTER
	POINT	9,TBL,8	;FOR TRANSFER BYTE
	POINT	9,TBL,17
	POINT	9,TBL,26
FSGN:	ASCII	.E-.
	ASCII	.E+.

;LEVEL TABLE FOR INTERRUPTS FROM USER

LEVTAB:	IPC1
	IPC2
	IPC3

;CHANNEL TABLE FOR USER INTERRUPTS.  A * means it's a panic channel.  We use
;this table also as a interrupt-channel-type table.  If the address you go
;to to PANERR, it's a panic channel.

CHNTAB:	2,,RUBOUT		;User 0 - RUBOUT
	2,,CT.PSI		;User 1 - ^T INTERRUPT
	1,,BPTINT		;User 2 - BREAKPOINT
	0,,ERR			;User 3
	0,,ERR			;User 4
	0,,ERR			;User 5
	0,,ERR			;.ICAOV INTEGER OVERFLOW
	0,,ERR			;.ICFOV FLOATING POINT OVERFLOW
	0,,ERR			;Reserved for DEC
	0,,PANERR		;* .ICPOV PUSHDOWN OVERFLOW
	0,,ERR			;ICEOF END OF FILE
	0,,PANERR		;* ICDAE DATA TRANSMISSION ERROR
	0,,PANERR		;* ICQTA QUOTA EXCEEDED OR DISK FULL (+++)
	0,,ERR			;Reseserved for DEC
	0,,ERR			; " " "
	0,,PANERR		;* .ICILI ILLEGAL INSTRUCTION
	0,,ERR			;* .ICIRD ILLEGAL MEMORY READ
	0,,ERR			;* .ICIMW ILLEGAL MEMORY WRITE
	0,,ERR			;[Reserved for DEC] ILLEGAL MEMORY EXECUTE
IFE ADBRKF,<	0,,ERR>		;.ICIFT SUBSIDIARY FORK TERMINATION
IFN ADBRKF,<	1,,FRKTRM>
	0,,PANERR		;* .ICMSE MACHINE SIZE EXCEEDED
	REPEAT	CHNTAB+36-.,<0,,ERR>

;TRAP MESSAGE TABLE -- OFFSET BY 6, SEE TBRK
MSG=.-6
	ASCII	/IOV:/		;6 INTEGER OVERFLOW
	ASCII	/FOV:/		;7 FLOATING POINT OVERFLOW
	0			;8.=10 RUBOUT (FAKE BREAK)
	ASCII	/POV:/		;9.=11 PUSHDOWN OVERFLOW
	ASCII	/EOF:/		;10.=12 END OF FILE
	ASCII	/DTE:/		;11.=13 DATA TRANSMISSION ERROR
	ASCII	/QOT:/		;12.=14 QUOTA EXCEEDED OR DISK FULL
	ASCII	/I13:/		;13.=15 RESERVED
	ASCII	/I14:/		;14.=16 RESERVED
	ASCII	/ILL:/		;15.=17 ILLEGAL INSTRUCTION
	ASCII	/IMR:/		;16.=20 ILLEGAL MEMORY READ
	ASCII	/IMW:/		;17.=21 ILLEGAL MEMORY WRITE
	ASCII	/IMX:/		;18.=22 ILLEGAL MEMORY EXECUTE (RESERVED ON KL)
	ASCII	/FKT:/		;19.=23 SUBSIDIARY FORK TERMINATION
	ASCII	/MSE:/		;20.=24 MACHINE SIZE EXCEEDED
	ASCII	/I21:/		;21.=25 RESERVED
	ASCII	/NXP:/		;22.=26 NON-EXISTANT PAGE
	ASCII	/ABK:/		;23.=27 ADDRESS BREAK (FAKE)
	ASCII	/TTY:/		;24.=30 JOB WANTS THE TTY (FAKE BREAK)
	ASCII	/HFK:/		;25.=31 FORK HALTED BY SUPERIOR OF IDDT
				; (FAKE BREAK)

frksts:	[ASCIZ /Running/]	;Fork status stuff
	[ASCIZ /IO wait/]
	[ASCIZ /Halt/]
	[ASCIZ /Halt: /]
	[ASCIZ /Fork wait/]
	[ASCIZ /Sleep/]
	[ASCIZ /JSYS trap/]
	[ASCIZ /Address break/]
	[ASCIZ /TTY wait/]

	LIT			;Dump literals.

;TIW strings

TIWs:	-1,,[ASCIZ "^@ or break"]
	ASCIZ "^A"
	ASCIZ "^B"
	ASCIZ "^C"
	ASCIZ "^D"
	ASCIZ "^E"
	ASCIZ "^F"
	ASCIZ "^G"
	ASCIZ "^H"
	ASCIZ "^I"
	ASCIZ "^J"
	ASCIZ "^K"
	ASCIZ "^L"
	ASCIZ "^M"
	ASCIZ "^N"
	ASCIZ "^O"
	ASCIZ "^P"
	ASCIZ "^Q"
	ASCIZ "^R"
	ASCIZ "^S"
	ASCIZ "^T"
	ASCIZ "^U"
	ASCIZ "^V"
	ASCIZ "^W"
	ASCIZ "^X"
	ASCIZ "^Y"
	ASCIZ "^Z"
	-1,,[ASCIZ "escape"]
	-1,,[ASCIZ "rubout"]
	-1,,[ASCIZ "space"]
	-1,,[ASCIZ "dataset carrier off"]
	-1,,[ASCIZ "typein"]
	-1,,[ASCIZ "typeout"]
	-1,,[ASCIZ "DEC reserved 33"]
	-1,,[ASCIZ "DEC reserved 34"]
	-1,,[ASCIZ "DEC reserved 35"]

IChans:	Block 6			;0-5 are user
	Asciz "AOV"		;Arithmetic overflow
	Asciz "FOV"		;Arithmetic floating-point overflow
	Asciz "DR8"		;Reserved for DEC
	Asciz "POV"		;PDL overflow
	Asciz "EOF"
	Asciz "DAE"		;Data error file condition
	Asciz "QTA"		;Disk full or quota exceeded
	Asciz "DR13"
	Asciz "DR14"
	Asciz "ILI"		;Illegal instruction
	Asciz "IMR"		;Illegal memory read
	Asciz "IMW"		;Illegal memory write
	Asciz "DR18"
	Asciz "IFT"		;Inferior process termination or forced freeze
	Asciz "MSE"		;System resources exhausted
	Asciz "DR21"
	Asciz "NXP"		;Non-existent page
	Block ^D13		;user

nJSYSi:	0			;Number of JSYSi defined
JSYTAB:	BLOCK 1000		;SIXBIT JSYS name or 0 if not used

;This is where monitor symbols will be stored.
MONTAB:
MONLEN==25			;# pages reserved

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;	End of pure - get to a page boundry (leaving space for
;;	monitor symbols) and start impure area
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	RWX=<.+MONLEN*1000-1>&777000
	DEPHASE
	RELOC RWX-IDDT+LOW
	PHASE RWX

FFile:	0			;Used by $;Y
nPages:	0
First:	0

tmpblk:	0			;temporary block pointer set by blk|sym
TEM:	0			;GENERAL TEMPORARY
GDTO:	0			;USED IN ALT-SEMI-Y
GDFROM:	0			;AND ALT-SEMI-U
TXUPRW:	0			;FOR ASCII INPUT MODE
TXQUOT:	0			;FOR ASCII INPUT MODE
HPOS:	0			;FOR ALIGNMENT
SCHSAV:	PIN			;TEMPORARY MODE SAVED HERE IN SUPER-TEMP MODE
JFNS1:				;FOR DEFAULT NAMES
JFNDIR:	BLOCK	10
JFNNAM:	BLOCK	7
JFNS2:	0
BLOCK:	0
SVF:	0
SW1:	0
SVFB:	0
SVTB:	0
BLVL:	0			;CURRENT BLOCK LEVEL IN SYM TAB
WRD:	0			;VALUE OF EXPRESSION TYPED
WRD2:	0			;VALUE OF EXPRESSION TO RIGHT OF $
PRNC:	0			;PAREN COUNT
NPWR10:	0			;NEG POWER OF 10 DURING FRAC PART OF FP NUM
IGNORE:	0			;In OBTUNV, ignore this symbol, don't save it.
systab:	0			;index,,table# for SYSTAT system table

FRASE:	0			;***DONT CHANGE ORDER, SEE  SEARC+3***
SYL:	0			;NUMBER TYPED, TAKEN AS OCTAL
LWT:	0			;LAST WORD TYPED IN OR OUT
TEM2:	0
FRASE1:
TEM3:	0
DEN:	0			;NUMBER TYPED, TAKEN AS DECIMAL

PRGM:	0			;0 OR POINTER TO THIS PROGRAM'S SYMBOLS
ESTU:	0			;BEGINNING OF UNDEFINED SYMBOL TABLE
ESTUT:	0
FSV:	0
FH:	0
SYM:	0			;RADIX 50 SYMBOL BEING GATHERED
SPSAV:	0			;POINTER TO LAST SYMBOL TYPED
DEFV:	0			;DEFINITION VALUE FOR SYMBOLS, FA FOR SEARCH
ULIMIT:	0			;LA FOR SEARCH, ETC.
LLOC:	0			;TEMPORARY VALUE OF .
LLOCO:	0			;VALUE OF .
SAVLOC:	0			;THE ADR OF OLD REGISTER EXAMINATION SEQUENCE
PATLOC:	0			;LOCATION ON INSTRUCTION BEING PATCHED UPON
PATPNT:	0			;"." DURING A PATCH
STRING:	0			;0 OR POINTER TO STORED COMMAND STRING
BBC:	0			;BUFFERED BACK CHARACTER

CNXBPT:	0
pinff:	0			; non-0 means print c(EA) and C(ac) of instr
wrprot:	0			; Location to be monitored in single stepping
wrcont:	0			; Contents thereof
stepct:	1			; Number of single steps
sstepv:	-1			; Verbose single stepping
fctrln:	0			; -1 means winning ^N, 0 means losing $y/$j
$ctrln:	0			; First word is pc of instruction
	block	ntbpts		; Saved PC's of temp BPT's
$ctins:	-1			; 1st word is 3-<# of saved locs>, rest
	block	ntbpts		; is displaced instr's
ssacs:	block	20		; User ac's before single step

jcllen==100			; space for jcl
JCL:	block jcllen

TXTNSZ:	0			;Byte size for variable-sized text output

STRIP:	0			;STRING BUFFER INPUT PTR
STROP:	0			;STRING BUFFER OUTPUT PTR
STRBUF:	BLOCK	STRBFL

RIRBLK:	3			;Length including this word.
	BLOCK 2

TIMUSD:	0			;CPU TIME USED AT LAST RESET
TIMCON:	0			;CONSOLE TIME USED AT LAST RESET
VADDR:	-1			;^T VIEW ADDRESS

JFN:	0			;JFN FOR PROGRAM UNDER $L,$Y
UNVJFN:	0			;For slurping up .UNV files

IPC1:	0			;INTERRUPT PC'S
IPC2:	0
IPC3:	0

EVPTR:	0
OURSYM:	0			;Our symbol table pointer
SYMPTR:	0,,HOME			;INITIAL (EMPTY) SYM. TAB. PTR.
MONPTR:	0,,MONTAB		;Pointer to monitor symbol table
MONLUK:	0			;For EVAL, non-0 if searching monitor symbols

;THE USER'S TTY STATE
SAVTTY:	0			;JFN mode word
SAVTT2:	0			;TTY CONTROL CHARACTER MODES (CCOC1)
SAVTT3:	0			;(CCOC2)
USRTB2:	0			;TTY TAB SETTINGS (1)
USRTB3:	0			;(2)
USRTB4:	0			;(3)

;DDT'S TTY STATE (CHANGE TTYCC2,3 MEAN CHANGE TO LITERAL AFTER ESCAP2)

DDTTB2:	401002,,4010		;IDDT'S TTY TAB SETTINGS
DDTTB3:	20040,,100200
DDTTB4:	401002,,4010
TTYCC2:				;and CCOC setting
IFE KL20F,<	BYTE	(2) 0,0,1,1,1,1,1,2,0,0,2,1,1,2,1,1,1,1
>;			    | | | | | | | | | | | | | | | | | |
IFN KL20F,<	BYTE	(2) 0,1,1,1,1,1,1,2,0,2,3,1,1,2,1,1,1,1
>;	  	    control @ A B C D E F G H I J K L M N O P Q
TTYCC3:
IFE KL20F,<	BYTE	(2) 1,1,0,0,1,1,1,1,1,0,1,1,1,2
>;			    | | | | | | | | | | | | | |
IFN KL20F,<	BYTE	(2) 1,1,0,1,1,1,1,1,1,0,1,1,1,1
>;		    control R S T U V W X Y Z [ \ ] ^ _

TOCS:	MOVEI	T,.-.		;GET RIGHT HALF BACK
SEAR2:	JUMPE	T,SEAR3		;OR JUMPN T,SEAR3
ACCCF:	MOVEI	T,.-.		;LEFT HALF OF A,,B

BPTFLG:	0			;ADDR OF BPT BLK IF A $P WILL BE FROM A BPT
QLPNT:	0			;USED IN ? COMMAND AS PTR
				;0 IF IT WILL BE FROM ILLINST OR RUBOUT
USRFLG:	-1			;-1 WHILE USER RUNNING, >=0 IF IN DDT
LASTPG:	0			;FORK,,PAGE  CURRENTLY MAPPED IN
IDPACS:	0			;ACCESS OF MAPPED PAGE
REALPC:	0			;WHAT FORK'S PC SHOULD BE WHEN NEXT RUN
cursec:	0			;extracted section# from PC
ilitrp:	0			;last instruction was ili &tc which had an
				;erjmp or ercal, so user is trapping it.
dontac:	0			;don't show AC field in PIN (for ercal/jmp)

;ESCAPE CHARACTER CONTROL
ESCCHR:	"D"-100			;THE ASCII CHARACTER
ESCCOD:	.TICCD			; AND TERM CODE
SAVCOC:	00			;SAVED CCOC (2-BIT) FIELD
COCPTR:	POINT	2,TTYCC3,9	;POINTER TO ABOVE FIELD

;DEFAULT VALUES FOR FILE GTJFN'S
DEFALT:	0		;OR 1B0
	.PRIIN,,.PRIOU
	0
	0
	0
	0		;SYMBOLS OR SAV
	0
	0
	0

;BLOCK FOR TEXTI
TXTBLK:	4
	RD%BEL!RD%RND!RD%JFN!RD%SUI
	.PRIIN,,.PRIOU
	-1,,JCL
	<20*5>

;INTERNAL REGISTERS

;BREAK POINTS

DEFINE BPTBLK(Z.)<
$'Z.'B:	BLOCK 6
	ASCIZ	/$'Z.'B/
	BLOCK 2
>
	RADIX	10

FRSTIR==.			;MARKS BEGINNING OF INTERNAL  REGISTER LIST
	QZ==1
BPTS:	REPEAT	NBP,<BPTBLK \QZ
	QZ==QZ+1>
NBPTV==<.-BPTS>/NBP		;NUMBER OF BPT VARIABLES
	RADIX	8
RB:	BLOCK	NRBL		;RING-BUFFER OF EXAMINED ADDRESSES
LRB==.-1
RBPT:	RB			;RING-BUFFER POINTER: START AT HEAD OF BUFFER
SYMOFS:	777			;MAXIMUM OFFSET FROM SYMBOL TO PRINT
TRAPWD:	0			;TRAP STATUS WORD
WDATA:	0			;WRITE DATA DURNING INSTR TRAP
XRG:	20			;LOCATION WHERE $X IS DONE
PC:	0			;INDICATED USER'S PC
CURMSK:	0			;THE MASK USED FOR A PARTICULAR SEARCH
UUOL:	0
MSK:	-1			;MASK FOR SEARCHES
	0,,-1			;AND OTHERS....
	-1,,0
	740,,0
	17,,0
	-1000,,0
	-1			;LAST TWO ARE USER DEFINED...
	-1
debug:	0			;want debugging output?
USRPSI:	block ^d8
FORK:	-1			;FORK HANDLE OF CURRENT USER FORK
SUBSYS:	'IDDT'			;SUBSYSTEM NAME FOR USER
TPFORK:	-1			; FORK HANDLE OF TOP FORK OF USER
LASTIR==.			;MARKS END OF INTERNAL REGISTERS

BINSTR:	0			;INSTR. TO INTERPRET WHEN PROCEEDING
WHY:	0			;WHY IDDT ENTERED, RH OF FORK STATUS

;USER'S ACCUMULATORS, WHILE IN DDT
AC0:	BLOCK	20

;PERMANENT CONTROL SWITCHES (AC'S 10,11,12 ARE TEMP EQUIV'S)
SCHM:	PIN			;DO NOT CHANGE ORDER
ARM:	PADSO
ODFM:	10

showpc:	0			;show the PC when first starting up?
SPTSUB:	0			;Subroutine that SPT calls with character
STRBBP:	0			;BP into STRBUF used by CTRL/K
FILIMG:	0			;Current image is of a $;Y'd file.
TEM1:	0

LSTKEY:	0			;0 if want all blocks else block-name
LSTSYM:	0			;non-0 if listing symbols
seeblk:	0			;non-0 if this sym block is ok to see

sorcbp:	0			;BPs to source and
testbp:	0			;test strings, saved by SUBSTR
secnum:	0			;current section (in memstat)

xrmarg:	4			;3 words in block (including this one)
	1			;# of pages to return info for
	0			;page# (inserted at runtime)
	xrmdat			;where to put the returned data

xrmdat:	block 2			;jfn,,page# ? access bits - return by XRMAP%

SVBTS:	0
SVBTS2:	0
SVBT3:	0
SVBT2:	0

PNTR:	EXP	INST		;POINTER TO BITS IN INST
INST:	0			;BINARY FOR INSTRUCTION
CHP:	0			;CHAR POINTER INTO TXT, TXT+1
TXT:	BLOCK	2		;STORE INPUT TEXT FOR OPEVAL
SAVPDL:	0			;PDL PTR SAVED DURING OPEVAL

LITS:	LIT			;Dump some more literals
	VAR			;and any variable we made.

PS:	IOWD	LPDL,.+1
	BLOCK	LPDL
PCSPTR:	0			;OLD PC STACK POINTER
PCSTAK:	IOWD	PCSL,.+1
	BLOCK	PCSL

;WINDOW INTO USER'S CORE
	.ORG <.+777>&777000	;Get to a page boundry
UCORE:	BLOCK 1000

DDTEND:	DEPHASE

	END	BLAST
