;[MIT-OZ]SS:<SYS.LIBRARY>MACSYM.MID.1, 11-Sep-83 20:12:07, Edit by GZ
;Converted to Midas to ease converting MACRO programs to Midas.
;Last few edits in MACRO file:
; ;<5-1-SOURCES>MACSYM.MAC.44,  7-Jul-83 05:16:58, Edit by MRC
; ;Stanford changes:
; ; Be sure to save ENDLP. context in nested DO.
; ; UPD ID= 82, SNARK:<5.UTILITIES>MACSYM.MAC.43,  22-Feb-82 17:57:38 by MURPHY
; ;IFJER., IFNJE. - new names for IFNES., IFESK.
;MACRO file copyright:
; ;THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY ONLY BE USED
; ;  OR COPIED IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
; ;
; ;COPYRIGHT (C) 1976,1977,1978,1979,1980,1981 BY DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
; ;VERSION 1

;Stuff supported:
; PGVER. VMAJ,VMIN,VEDIT,VWHO and related masks(VI%MAJ,VI%MIN,VI%EDN,VI%WHO)
; Random symbols (.INFIN,.MINFI,.LHALF,.RHALF,.FWORD, .CHxxx)
; MOVX AC,MASK
; TXxx AC,MASK
; DO./ENDDO. macros (and related stuff)
; IFxxx/ANxxx macros
; TMSG /text/, FMSG /text/
IFNDEF $$JSER,$$JSER==0
; Conditional on $$JSER:
;   PERSTR /optional msg/
;   ERMSG /text/
;   JSERR/EJSERR/JSHLT/EJSHLT
;   and support code for above.
IFNDEF $$STK,$$STK==0
; Conditional on $$STK:
;   CALL/RET/RETSKP/CALLRET
;   STKVAR [AA,[QQ,5],ZZ]/ENDSV.
;   SAVEACS [A,B,C,D]  (don't really need to be AC's)
;   labels RSKP and R
;   and support code for above.


.NSTGW			;No storage words in this part

DEFINE PGVER. (VMAJ,VMIN,VEDIT,VWHO)
	..PGV0==.
	LOC	137
.JBVER:	.BYTE 3.,9.,6.,18.
	VWHO
	VMAJ
	VMIN
	VEDIT
	.BYTE
	LOC ..PGV0
	.KILL ..PGV0
TERMIN

;MASKS FOR THE ABOVE

VI%WHO==:700000,,000000		;Customer edit code
VI%MAJ==:077700,,000000		;Major version number
VI%MIN==:000077,,000000		;Minor version/update
VI%EDN==:000000,,777777		;Edit number

;MISC CONSTANTS

.INFIN==:377777,,777777		;PLUS INFINITY
.MINFI==:400000,,000000		;MINUS INFINITY
.LHALF==:-1,,0			;LEFT HALF
.RHALF==:0,,-1			;RIGHT HALF
.FWORD==:-1			;FULL WORD

;SYMBOLS FOR THE CONTROL CHARACTERS

.CHNUL==:000			;NULL
.CHCNA==:001
.CHCNB==:002
.CHCNC==:003
.CHCND==:004
.CHCNE==:005
.CHCNF==:006
.CHBEL==:007			;BELL
.CHBSP==:010			;BACKSPACE
.CHTAB==:011			;TAB
.CHLFD==:012			;LINE-FEED
.CHVTB==:013			;VERTICAL TAB
.CHFFD==:014			;FORM FEED
.CHCRT==:015			;CARRIAGE RETURN
.CHCNN==:016
.CHCNO==:017
.CHCNP==:020
.CHCNQ==:021
.CHCNR==:022
.CHCNS==:023
.CHCNT==:024
.CHCNU==:025
.CHCNV==:026
.CHCNW==:027
.CHCNX==:030
.CHCNY==:031
.CHCNZ==:032
.CHESC==:033			;ESCAPE
.CHCBS==:034			;CONTROL BACK SLASH
.CHCRB==:035			;CONTROL RIGHT BRACKET
.CHCCF==:036			;CONTROL CIRCUMFLEX
.CHCUN==:037			;CONTROL UNDERLINE
.CHSPC==:040			;SPACE

.CHALT==:175			;OLD ALTMODE
.CHAL2==:176			;ALTERNATE OLD ALTMODE
.CHDEL==:177			;DELETE

	SUBTTL MOVX/TX

;MOVX - LOAD AC WITH CONSTANT

DEFINE MOVX AC,#MSK
   IFE <-1,,0>&MSK,[MOVEI AC,MSK]
   .ELSE [IFE <0,,-1>&MSK,[MOVSI AC,(MSK)]
	  .ELSE [IFE <<-1,,0>&MSK>-<-1,,0>,[HRROI AC,MSK]
		 .ELSE [IFE <<0,,-1>&MSK>-<0,,-1>,[HRLOI AC,(MSK)]
			.ELSE [MOVE AC,[MSK]]]]]
TERMIN

;TX - TEST MASK

IRP OP,,[N,NA,OE,ON,OA,ZE,ZN,ZA,CE,CN,CA]
  DEFINE TX!OP AC,#MSK
    IFE <-1,,0>&MSK,[TR!OP AC,MSK]
    .ELSE [IFE <0,,-1>&MSK,[TL!OP AC,(MSK)]
	   .ELSE [TD!OP AC,[MSK]]]
  TERMIN
TERMIN

IRP OP,,[N,E]
  DEFINE TXN!OP AC,#MSK
    IFE <-1,,0>&MSK,[TRN!OP AC,MSK]
    .ELSE [IFE <0,,-1>&MSK,[TLN!OP AC,(MSK)]
	   .ELSE [IFE MSK+1,[CAI!OP AC,0]
		  .ELSE [TDN!OP AC,[MSK]]]]
  TERMIN
TERMIN

..TXZ==ANDI
..TXO==ORCMI
..TXC==EQVI
.KILL ..TXZ,..TXO,..TXC
IRP OP,,[Z,O,C]
  DEFINE TX!OP AC,#MSK
    IFE <-1,,0>&MSK,[TR!OP AC,MSK]
    .ELSE [IFE <0,,-1>&MSK,[TL!OP AC,(MSK)]
	   .ELSE [IFE <<-1,,0>&MSK>-<-1,,0>,[..TX!OP AC,-1#MSK]
		  .ELSE [TD!OP AC,[MSK]]]]
  TERMIN
TERMIN



	SUBTTL BLOCK MACROS

;MACROS TO PROVIDE SOME BLOCK HANDLING OF CODE

;DO. - LOOP STRUCTURE, DECLARES TOP OF LOOP
; LOOP. - JUMPS TO TOP OF LOOP
; EXIT. - EXITS LOOP
; TOP. - TAG AT TOP OF LOOP FOR JUMPS, E.G. SOJG T4,TOP.
; ENDLP. - TAG AT END OF LOOP FOR JUMPS, E.G. SOJL T4,ENDLP.

DEFINE DO.
   ..DX
TERMIN

DEFINE ..DX \%TGE,%SV1,%SV2,%SV3
	EQUALS %SV1,TOP. ? EQUALS %SV2,ENDDO. ? EQUALS %SV3,ENDLP.
	.KILL %SV1
	TOP.==.
	DEFINE ENDDO.
	 %TGE::EQUALS TOP.,%SV1 ? EQUALS ENDDO.,%SV2 ? EQUALS ENDLP.,%SV3
	 .KILL %TGE
	TERMIN
	DEFINE ENDLP.
%TGE!!TERMIN
TERMIN

DEFINE ENDDO.
.ERR ENDDO. outside loop
TERMIN
DEFINE ENDLP.
.ERR ENDLP. outside loop
TERMIN
TOP.==-1
.KILL TOP.

DEFINE OD.
ENDDO.!TERMIN

DEFINE LOOP.
JRST TOP.!TERMIN

DEFINE EXIT.
JRST ENDLP.!TERMIN


;Conditionals

DEFINE IFSKP.
..IX [JRST ]
TERMIN

DEFINE IFNSK.
TRNA
 ..IX [JRST ]
TERMIN

DEFINE IFXN. AC,#MASK
 IFE <.MINFI-MASK>,..IX [JUMPGE AC,]
 .ELSE [IFE <.FWORD-MASK>,..IX [JUMPE AC,]
       .ELSE [TXNN AC,MASK
		..IX [JRST ]
	     ]]
TERMIN

DEFINE IFXE. AC,#MASK
 IFE <.MINFI-MASK>,..IX [JUMPL AC,]
 .ELSE [IFE <.FWORD-MASK>,..IX [JUMPN AC,]
       .ELSE [TXNE AC,MASK
		..IX [JRST ]
	     ]]
TERMIN

DEFINE IFJER.
ERJMP .+2
 ..IX [JRST ]
TERMIN

DEFINE IFNES.
	PRINTX /% IFNES. should be changed to IFJER.
/
	IFJER.
TERMIN

DEFINE IFNJE.
..IX [ERJMP ]
TERMIN

DEFINE IFESK.
	PRINTX /% IFESK. should be changed to IFNJE.
/
	IFNJE.
TERMIN

DEFINE IFE. AC
..IX [JUMPN AC,]
TERMIN

DEFINE IFN. AC
..IX [JUMPE AC,]
TERMIN

DEFINE IFG. AC
..IX [JUMPLE AC,]
TERMIN

DEFINE IFGE. AC
..IX [JUMPL AC,]
TERMIN

DEFINE IFLE. AC
..IX [JUMPG AC,]
TERMIN

DEFINE IFL. AC
..IX [JUMPGE AC,]
TERMIN

DEFINE ..IX OP,\%TAG,%SV1,%SV2
	OP!%TAG
	EQUALS %SV1,..TG ? EQUALS %SV2,ENDIF.
	DEFINE ..TG LBL
	%TAG!!LBL!TERMIN
	DEFINE ENDIF.
	..TG [::]
	 EQUALS ..TG,%SV1 ? EQUALS ENDIF.,%SV2
	TERMIN
TERMIN

DEFINE ELSE.
..EX
TERMIN

DEFINE ..EX \%TAG
	JRST %TAG
	..TG [::]
	DEFINE ..TG LBL
	  %TAG!!LBL!TERMIN
TERMIN

DEFINE ..TG LBL
 .ERR Conditional construct outside a conditional
TERMIN

DEFINE ENDIF.
 .ERR ENDIF. outside a conditional
TERMIN


;GENERAL CASES WITHIN CONDITIONALS

DEFINE ANSKP.
  JRST ..TG
TERMIN

DEFINE ANNSK.
	TRNA
	  JRST ..TG
TERMIN

DEFINE ANDXN. AC,#MASK
IFE <.MINFI-MASK>,JUMPGE AC,..TG
.ELSE [IFE <.FWORD-MASK>,JUMPE AC,..TG
       .ELSE [TXNN AC,MASK
		JRST ..TG
	     ]]
TERMIN

DEFINE ANDXE. AC,#MASK
IFE <.MINFI-MASK>,JUMPL AC,..TG
.ELSE [IFE <.FWORD-MASK>,JUMPN AC,..TG
       .ELSE [TXNE AC,MASK
		JRST ..TG
	     ]]
TERMIN

DEFINE ANDE. AC
	JUMPN AC,..TG
TERMIN

DEFINE ANDN. AC
	JUMPE AC,..TG
TERMIN

DEFINE ANDG. AC
	JUMPLE AC,..TG
TERMIN

DEFINE ANDGE. AC
	JUMPL AC,..TG
TERMIN

DEFINE ANDLE. AC
	JUMPG AC,..TG
TERMIN

DEFINE ANDL. AC
	JUMPGE AC,..TG
TERMIN


;MACRO TO PRINT MESSAGE ON TERMINAL

DEFINE TMSG &MSG
	HRROI 1,[ASCIZ MSG]
	PSOUT%
TERMIN

;MACRO TO OUTPUT MESSAGE TO FILE
; ASSUMES JFN ALREADY IN .AC1

DEFINE FMSG &MSG
	HRROI 2,[ASCIZ MSG]
	MOVEI 3,0
	SOUT%
TERMIN

.YSTGW				;Allow storage words again

IFN $$JSER,[			;Optional Jsys error support

IFNDEF P,P==:17

;MACRO TO PRINT MESSAGE FOR LAST ERROR, RETURNS +1

DEFINE PERSTR &MSG
	IFNB [MSG]TMSG MSG
	PUSHJ P,JSMSG0
TERMIN

;PRINT ERROR MESSAGE IF JSYS FAILS

DEFINE ERMSG *TEXT
	ERJMP	[TMSG ?!TEXT
		 JSHLT]
TERMIN

;JSYS ERROR HANDLER
;	CALL JSERR0
; RETURNS +1: ALWAYS, CAN BE USED IN +1 RETURN OF JSYS'S

JSERR0:	MOVEI 1,.PRIIN
	CFIBF%			;CLEAR TYPAHEAD
	MOVEI 1,.PRIOU
	DOBE%			;WAIT FOR PREVIOUS OUTPUT TO FINISH
	TMSG "
?JSYS error: "
JSMSG0:	MOVEI 1,.PRIOU
	HRLOI 2,.FHSLF		;SAY  THIS FORK ,, LAST ERROR
	SETZ 3,
	ERSTR%
	 NOP
	 NOP
	TMSG "
"
	POPJ P,

JSERR=:<PUSHJ P,JSERR0>		;Prints last jsys error, returns +1
EJSERR=:<ERCAL JSERR0>

;FATAL JSYS ERROR - PRINT MESSAGE AND HALT
;	CALL JSHLT0
; RETURNS: NEVER

JSHLT0:	JSERR			;PRINT THE MSG
JSHLT1:	HALTF%
	TMSG "?Program cannot continue
"
	JRST JSHLT1		;HALT AGAIN IF CONTINUED

.KILL JSHLT1

JSHLT=:<PUSHJ P,JSHLT0>		;Prints last jsys error, halts
EJSHLT=:<ERCAL JSHLT0>

];$$JSER


IFN $$STK,[			;Optional stack related support

	SUBTTL STKVAR - STACK VARIABLE FACILITY

IFNDEF P,P==:17

CALL=:<PUSHJ P,>
RET=:<POPJ P,>
CALLRET==:<JRST>

;; STKVAR [AA,BB,[QQ,5],ZZ]
;; ENDSV. (end of scope, flush names)
;; Supports return and skip return.
;; Unlike the macro version, AC16 is NOT clobbered.
DEFINE STKVAR ARGS
	..STKN==1
	IRP VAR,,[ARGS]
	  .STKV1 VAR
	TERMIN
	DEFINE ENDSV.
	  IRP ARG,,[ARGS]
	   .ENSV1(ARG)
	  TERMIN
	TERMIN
	ADJSP P,..STKN
	PUSHJ P,.STKST
TERMIN

DEFINE .STKV1 VAR,SIZE
	IFB [SIZE] ..STKN==..STKN+1
	.ELSE ..STKN==..STKN+SIZE
	$!VAR==<-..STKN>
	DEFINE VAR
$!VAR(P)TERMIN
TERMIN

DEFINE .ENSV1 VAR
	EXPUNGE VAR,$!VAR
TERMIN

.KILL ..STKN


.STKST:	EXCH 16,(P)		;Get return address, save AC16
	MOVEM 16,-1(P)		;Save ret address
	MOVN 16,-2(16)		;Fetch the word with ..stkn in it, negated
	MOVEI 16,(16)		;Clear lhs to allow indirecting in .STKRT
	EXCH 16,-1(P)		;Save it, get return address
	PUSH P,16		;Set up for popj
	HRRI 16,.STKRT		;Fake return address for caller
	EXCH 16,-1(P)		;set it up, restoring AC16
	POPJ P,

.STKRT:	JRST STKRT0		;Normal return
	ADJSP P,@(P)		;Skip return
RSKP:	AOS (P)
R:	POPJ P,

STKRT0:	ADJSP P,@(P)
	POPJ P,

.KILL STKRT0

RETSKP=:<JRST RSKP>

; SAVEAC [A,B,C]
; Supports +1/+2 returns.
; Unlike macro version, supports arbitrary locations (not just AC's)
; and doesn't clobber AC16.

DEFINE SAVEAC ACS
	IRP AC,,[ACS]
	  PUSH P,AC
	  ..NAC==.IRPCNT
	TERMIN
	.SAVX1 \..NAC+1,[ACS]
TERMIN

EQUALS SAVE.,SAVEAC		;Not in MACRO version...

.KILL ..NAC

DEFINE .SAVX1 N,ACS
	PUSH P,[[CAIA
		   AOS -N(P)
		 .SAVX2 [ACS]
		 POPJ P,
		]]
TERMIN

DEFINE .SAVX2 ACS
	IRP AC,REST,[ACS]
	  .SAVX2 [REST]
	  POP P,AC
	  .ISTOP
	TERMIN
TERMIN
];$$STK
