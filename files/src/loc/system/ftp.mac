;<SUBSYS.CMU>FTP.MAC.424, 14-Aug-86 14:05:18, Edit by VAF
; Comparison for UPDATE times was half wrong - fix it.
; Fix paged retrieve to non-disk file.
;<SUBSYS.CMU>FTP.MAC.423,  9-Jan-86 12:00:33, Edit by VAF
; BATFLG was backward. Fix it.
; Check for F%CRHK was backward. Fix it.
;<SUBSYS.CMU>FTP.MAC.422, 17-Dec-85 14:20:15, Edit by VAF
; Implement UPDATE and INSTALL commands.
;<SUBSYS.CMU>FTP.MAC.421,  2-Dec-85 14:37:03, Edit by VAF
; Clear F%XERR in DTRANS.
;<SUBSYS.CMU>FTP.MAC.420, 22-Nov-85 11:15:28, Edit by VAF
; Rewrite data transfer code to be much cleaner.
;<SUBSYS.CMU>FTP.MAC.417, 20-Nov-85 15:50:31, Edit by VAF
; Delete bogus RTXEFQ routine - it didn't work and things were calling it
; instead of RCVEFQ (and causing bad things to happen).
; Allow for null paged data after header (for PGT$LP record).
;<SUBSYS.CMU>FTP.MAC.416, 18-Nov-85 04:14:50, Edit by VAF
; In PREDAT, nuke old data connection if new params require close.
; Eliminate redundant F%DOPN flag. Do all data connection closing through
; common routine to insure that F%DATC is consistant.
; Remove redundant and gratuitous data connection closings.
; Remove gratuitous messages about "data conn never opened"
;<SUBSYS.CMU>FTP.MAC.415, 12-Nov-85 11:53:57, Edit by VAF
; Move RSCAN% past initialization code.
; Don't give ^G's on abort if running under Batch.
; Clear PARAM3 area whenever new TELNET connection opened.
; Don't touch PARAM2 during initializtion - it is useless and confusing.
;<SUBSYS.CMU>FTP.MAC.414,  6-Nov-85 15:57:44, Edit by VAF
; Clean up some of the data transfer code. Handle EOF/errors more consistantly.
;<SUBSYS.CS>FTP.MAC.413,  4-Oct-85 18:40:26, Edit by VAF
; Obey ^V quoting in GETSKP.
;<SUBSYS.CS>FTP.MAC.412, 19-Sep-85 17:19:53, Edit by VAF
; Remove stack from global area.
; Isolate TCP buffers on page boundary for monitor debugging.
;<SUBSYS.CS>FTP.MAC.411, 18-Sep-85 16:34:38, Edit by VAF
; Make ^Z terminate typein for send from TTY:
; Print transfer rates in just BPS. Also, inform user that times are in seconds
; Set file protection for paged files (under SETPFL conditional).
;<SUBSYS.CS>FTP.MAC.410, 14-Aug-85 16:16:18, Edit by VAF
; Clean up the type setting code some more.
; Set up F%CLSD in PREDAT so it knows not to reuse ports/data connections.
; Obey F%CLSD when in DTRABT.
; Miscellaneous cleanup.
;<SUBSYS.CS>FTP.MAC.407, 12-Aug-85 03:58:17, Edit by VAF
; Conditional code for supporting large data buffers (under IFDEF BIGBUF)
; Use TIMVAL when timing-out data transfer.
; Another fix to DOSTAT.
; Range check opsys type in GETLCN (oops!)
; Make GETLCN tables more general.
; Add VMS tables to GETLCN.
;<SUBSYS.CS>FTP.MAC.406,  2-Aug-85 15:51:04, Edit by VAF
; Allow "TYPE A" without subtype. Fix some minor bogosities in TYPE handling.
;<SUBSYS.CS>FTP.MAC.405, 20-Jun-85 14:57:22, Edit by VAF
; Make DOSTAT fake out FRNPRS better when same name used... (hack)
;<SUBSYS.CS>FTP.MAC.404, 12-May-85 15:05:21, Edit by VAF
; Always turn on SC%ANA if available.
;<SUBSYS.CS>FTP.MAC.403, 27-Mar-85 22:09:07, Edit by VAF
; Add debugging code for remote FTP servers...
;<SUBSYS.CS>FTP.MAC.402, 19-Mar-85 18:34:46, Edit by VAF
; Bugfix to take command.
; Make CMD know about CMERRX and use it.
; Give failure from DOSTAT on 212 (name is ambiguous)
; When DOSTAT gives 213, copy the foriegn path returned in case wildcarded
;<SUBSYS.CS>FTP.MAC.401, 14-Mar-85 19:02:51, Edit by VAF
; Clean up command tables, etc.
; Info version command
; Implement TAKE command (at last...)
; Flags for doing echo/allowing errors in TAKE files.
; Fix up echoing during command reparse if it is wrong...
; Wait & check ack for start of data transfer.
;<SUBSYS.CS>FTP.MAC.400, 14-Mar-85 02:22:09, Edit by VAF
; Don't request close of TELNET connection when data error occurs.
; Clear abort in TELCFX.
; Make some flags more consistant.
; Change summary format.
; Summarize totals during MGET/MSEND.
; Print correct file name in MSEND.
; Fix random small bugs.
; Add SET CRLF-Munging option.
; Print more info about type assumptions after ICP.
;<SUBSYS.CS>FTP.MAC.377, 10-Feb-85 23:42:50, Edit by VAF
; More flexible, layerd abort mechanism.
; Use F%OPEN consistantly.
;<SUBSYS.CS>FTP.MAC.376, 10-Feb-85 17:29:05, Edit by VAF
; Clear STRU P if setting TYPE to non-paged value.
; Add new TYPE command - ASCII get to TTY:
;<SUBSYS.CS>FTP.MAC.375,  5-Feb-85 18:36:58, Edit by VAF
;Major source reorganization:
;  Make a bunch of commands into "Set" and "Information" commands
;  Add "Set Statistics"
;  Logically reorganize code for all commands
;<SUBSYS.CS>FTP.MAC.374,  5-Feb-85 16:38:43, Edit by VAF
;Various minor bugfixes/changes:
;  Don't die on send of null file
;  Fix output to non-disk file during paged receive
;  Output number of pages sent/received in ^A
;  Don't print gratuitous message in .HASH.
;<SUBSYS.CS>FTP.MAC.373, 23-Nov-84 13:32:26, Edit by VAF
; Sigh... HPTIM% skip returns...
;<SUBSYS.CS>FTP.MAC.372, 23-Aug-84 12:03:53, Edit by VAF
; Fix Image type to be 36-bit bytes, just like L 36.
;<SUBSYS.CS>FTP.MAC.371,  7-Aug-84 17:19:51, Edit by VAF
; Only do STAT for TOPS-20, TENEX sites. Others can't handle it.
; Don't do multiple STAT's for the same file name.
;<SUBSYS.CS>FTP.MAC.370, 29-Jul-84 15:35:43, Edit by VAF
; Print TOPS-20 error code during ICP if available.
;<SUBSYS.CS>FTP.MAC.367, 23-Jul-84 13:14:11, Edit by VAF
; Don't do half-duplex password parsing for batch jobs.
; Redo half-duplex password parsing to work with in-line password.
;<SUBSYS.CS>FTP.MAC.366, 22-Jun-84 16:04:22, Edit by VAF
; Fix TOPS-20/Tenex local name defaulting to strip structure and/or directory
;<SUBSYS.CS>FTP.MAC.365,  6-Jun-84 13:58:36, Edit by VAF
; Change TXNN/IFSKP. in TRDATA to IFXE. - the test logic was reversed.
;<SUBSYS.CS>FTP.MAC.364, 10-May-84 14:04:47, Edit by VAF
;Changes to fix "Data connection refused" bug:
;  Reorganize DTRANS to start opening data connection before protocol cue
;  Clean up code in TRDATA & DTRANS - validate paged transfer earlier, etc.
;<SUBSYS.CS>FTP.MAC.363, 18-Apr-84 16:14:42, Edit by VAF
;Fixes to bugs introduced during merge:
;  Reload JFN before printing local file in MSEND
;  Change IDIVI to IDIV when computing bytes-words scaling factor.
;<SUBSYS.CS>FTP.MAC.362, 10-Apr-84 19:55:46, Edit by VAF
;A number of bug fixes, enhancements:
;  Don't do STAT during GET for Unix or ITS (they don't implement it)
;  Print byte size in ^A if type L
;  First shot at more flexible ^G handling.
;  Give TOPS-20's and TENEX's a ^C instead of an ABOR in ^G handler.
;  Put ^G interrupt at higher priority than ^A
;  Don't send params twice for first file in MGET (got unfixed somehow...)
;<SUBSYS.CS>FTP.MAC.361, 31-Mar-84 14:28:23, Edit by VAF
; Add NOPORT option - suppresses usage of PORT negotiation
; Rename/better document various port/socket variables.
;<SUBSYS.CS>FTP.MAC.360, 25-Mar-84 02:48:52, Edit by VAF
; Check remote file status in GET before attempting to procede.
;Merge Dale Chase's changes from ISI's version:
;  Complain if PREDAT can't init the connection
;  If Type set to Image, don't assume 2nd parameter or Paged Mode.
;  If system type unknown, assume Unix instead of aborting MGets.
;  Replace BLT of ATMBUF into LCLNAM, casualty of #232
;  Improve processing of remote error indications: Do an Esout so batch
;   jobs terminate; expunge empty local destination files
;  In GETLCN, make sure GETLCP(T3) is non-0.
;  In MGet., shift FRNOPS value before using as index.
;  When parsing foreign filename, use site-dependent break mask (ITS)
;  Allow 2 line get/send commands ala old ftp (#232)
;  Improve error handling/reporting in DOICP.
;  At SNDEOF, don't make $CLOSF abort T20/10Xs, let them close normally.
;  Fix bug in SNDDSK where extra bytes (nuls) were being sent unless the
;	byte-count modulo bytes-per-word was zero.
;  On Ascii transfers, insert/strip null when send/recv a <CR> not followed
;	by a <LF>
;  Add Getfrn check for null file type if Unix so we tell Unix to STOR
;	"FOO" instead of "FOO.", which are different.
;  Make password reparse code turn echoing back on.
;  Fix bug in arg to Openf% in .Direc
;  Make wait for normal telnet reply longer in Telcfm
;  Make telnet conn attempt timeout sooner and smarter (ala data conn)
;  Don't type out passwords when Verbose
;  Bug fixes:
;      Fix break mask in Acct parser at .Login+15.
;      Make Frnpth same size as Atmbuf so BLT at .Login+10 does right thing
;      Change logic in Predat, Trdata: was using wrong port for Ascii trx
;       following a paged trx.
;      Add Telbuf for building telnet cmds instead of Atmbuf, was displaying
;       passwords sometimes.
;      Fix Getskp to handle case where desired char isn't in string
;   Local changes (for compatability with previous Ftp):
;      Changed cmd sequence of Login, Get.
;      Lazy Connect- Allows connect by just typing hostname
;      Allow hostnumbers as Connect argument as well as hostnames
;      Do Sfust/Gfust on paged trx's for author, writer fields of fdb
;      Add Retain, Noretain commands; define Cwd as synonym for Cpath
;<SUBSYS.CS>FTP.MAC.227, 14-Mar-84 16:52:55, Edit by VAF
; Debugging code for data connection listener.
;<SUBSYS.CS>FTP.MAC.226, 13-Mar-84 19:21:52, Edit by VAF
; Fix longstanding problem with Type Image - it has no subtypes.
;<SUBSYS.CS>FTP.MAC.225,  8-Feb-84 14:20:09, Edit by VAF
; Add NETWORK command to allow selecting the local host number to use.
;<SUBSYS.CS>FTP.MAC.224, 27-Jan-84 14:25:55, Edit by VAF
; Set host for PORT value to be the "best" one, if the local host is on the
; same network as the foriegn host.
;<SUBSYS.CS>FTP.MAC.223, 14-Dec-83 18:05:50, Edit by VAF
; Kluge it so that 550 during multiple get is skipped.
; Don't send params twice for first file in multiple get.
;<SUBSYS.CS>FTP.MAC.222, 10-Nov-83 10:40:57, Edit by VAF
; Add 554 and 555 error handling, since ITS likes to send these.
;<SUBSYS.CS>FTP.MAC.221, 21-Sep-83 15:08:39, Edit by VAF
; Better selection of PORT value.
; Make get to/from TTY: to work better.
; Remove all mail support.
; Put back lazy host name parsing.
;<SUBSYS.CS>FTP.MAC.220, 18-Aug-83 16:26:00, Edit by VAF
; Add Mount command. Don't send extra space when sending "QUIT".
;<SUBSYS.CS>FTP.MAC.219, 13-Aug-83 17:57:18, Edit by VAF
;Several changes:
;  Rewrite filename conversion for Multiple Get & add Unix.
;  Do case fixing in multiple send.
;  Preserve JFN count in Multiple Send so it terminates correctly.
;<SUBSYS.CS>FTP.MAC.218, 12-Aug-83 19:58:56, Edit by VAF
;Add Exit command while connected. Put back ^G code.
;<SUBSYS.CS>FTP.MAC.217, 10-Aug-83 16:06:51, Edit by VAF
;Remove references to HSTNAM module. Do GTHST% directly.
;<SUBSYS.CS>FTP.MAC.216,  1-Aug-83 16:09:29, Edit by VAF
;Default remote file for unix to lowercase.
;<SUBSYS.CS>FTP.MAC.215, 25-Jul-83 11:40:37, Edit by VAF
;Use REMBRK break mask for all foriegn parameters (USER,ACCT,PASS)
;<SUBSYS.CS>FTP.MAC.212,  6-Jul-83 16:43:01, Edit by VAF
;In PREDAT, copy PARAM2 to PARAM3 after success. This should have been done all
;along...
;<5.1.CMU>FTP.MAC.211,  4-Jul-83 20:28:46, Edit by VAF
;Make abort cause wakeup when waiting for responses.
;<VAF.MAC.TCP>FTP.MAC.209, 29-Jun-83 17:05:13, Edit by VAF
;Add SWITCH.INI and rescan processing. Add history & plea at beginning.
;<VAF.MAC.TCP>FTP.MAC.207, 27-Jun-83 21:48:59, Edit by VAF
;Several improvements:
;  Clean up code a bit. Fix bug in multiple get.
;  Make default processing work again.
;  Make multiple responses work better.
;  Import a few changes from MRC@SU-SCORE
;<VAF.MAC.TCP>FTP.MAC.206, 17-Jun-83 02:13:06, Edit by VAF
;Do RET instead of JRST @CMDDSP in command routines. Seems that you'd tend
;to lose a lot of stack the other way... Make INFINT more careful about
;modifying interrupt PC. Make info interrupt be level 2.
;IIC% on INFCHN if a 221 comes in. The code for handling special replies 
;should really be flushed in favor of the INFINT processing.
;<VAF.MAC.TCP>FTP.MAC.205, 14-Jun-83 07:14:23, Edit by VAF
;A number of changes:
;  Do $CLOSF with CZ%ABT whenever an abort occurs during data xfer.
;  Try to close all local jfns at top of cmd loop.
;  Change GET to set GJ%FOU for local file, SEND to set GJ%OLD.
;  Don't send a PORT if sending mail, since PORT is only valid when logged-in
;  and MAIL is only valid when not logged-in.
;  Implement Control-G interrupt.
;<VAF.MAC.TCP>FTP.MAC.204,  5-Jun-83 18:41:51, Edit by VAF
;Changes for parsing host name/numbers:
;  Always use $GTHSN and $GTHNS. Do GTHST% for status after getting host #
;  Parse host names as "parse-only" userids, so that internet host numbers can
;  be given.
;<VAF.MAC.TCP>FTP.MAC.203,  4-Jun-83 14:18:22, Edit by VAF
;Only use CZ%ABT after STOR's if host is TOPS-20 or TENEX.
;<VAF.MAC.TCP>FTP.MAC.202,  4-Jun-83 13:57:44, Edit by VAF
;Clear byte size in PREASC. Make verbose and connection close flags be shared.
;Make Data-open flag be nonshared. Take out bit definitions for shared flags.
;<VAF.MAC.TCP>FTP.MAC.201,  3-Jun-83 17:40:56, Edit by VAF
;More PORT stuff. Know about special timeouts when synchonizing data connection
;Use CZ%ABT when closing TELNET connection after QUIT confirmation is in.
;<VAF.MAC.TCP>FTP.MAC.194,  3-Jun-83 13:59:43, Edit by VAF
;Fixes to type handling. Generate better local ports. Always send PORT
;command in PREDAT, unless the connection is already open or the user
;specifies a port.
;<VAF.MAC.TCP>FTP.MAC.187, 24-May-83 18:50:16, Edit by VAF
;Yet another fix to ^A.
;<VAF.MAC.TCP>FTP.MAC.186, 24-May-83 17:42:32, Edit by VAF
;Find delimiters in usernames better.
;<VAF.MAC.TCP>FTP.MAC.185, 24-May-83 17:25:34, Edit by VAF
;New version of TCPSIM. Fix ^A to show current local file.
;<VAF.MAC.TCP>FTP.MAC.178, 19-May-83 14:53:59, Edit by VAF
;Unbreak some page numbering that broke when adding ^A.
;<VAF.MAC.TCP>FTP.MAC.170, 16-May-83 16:47:14, Edit by VAF
;Use CZ%ABT when closing data connection so ASCII sends don't hang.
;<VAF.MAC.TCP>FTP.MAC.167, 13-May-83 14:22:44, Edit by VAF
;Add hash mark printing & ^A progress interrupt.
;<VAF.MAC.TCP>FTP.MAC.162, 13-May-83 11:13:43, Edit by VAF
;Kluge username parsing to get around COMND% uppercasing lossage.
;<VAF.MAC.TCP>FTP.MAC.160, 11-May-83 12:53:59, Edit by VAF
;Only close data connection if it was successfully opened (otherwise, we get
;one of those delightful TCPSIM wedges... Grr...)
;<VAF.MAC.TCP>FTP.MAC.155,  9-May-83 14:58:28, Edit by VAF
;Make TELCFM timeout after 10 seconds. Confirm ICP & bye command.
;<VAF.MAC.TCP>FTP.MAC.150,  5-May-83 17:36:20, Edit by VAF
;Do confirmation for most things sent down TELNET connection
;<VAF.MAC.TCP>FTP.MAC.142,  1-May-83 13:09:14, Edit by VAF
;Use BBN-style synchronizing to open data connection. Maybe it works better.
;<VAF.MAC.TCP>FTP.MAC.2,  1-May-83 08:16:14, Edit by VAF
;Make LOGIN more intelligent. Use F.xxxx for flags which must be shared between
;multiple processes (like F.ABRT, F.DTIP, F.DTDR)
;<VAF.MAC.TCP>FTP.MAC.1, 25-Apr-83 01:42:05, Edit by VAF
;First swing at TCP implementation.
;<MARCY.CMU>FTP.MAC.26,  9-Jan-82 19:38:15, Edit by MARCY
;Fix the crocky parts of this program.
;<MARCY.CMU>FTP.MAC.25, 20-Aug-81 23:01:43, Edit by ALMQUIST
;Fix (badly) multiple get from Tenex site
;<MARCY.CMU>FTP.MAC.16, 23-Jun-81 16:42:47, Edit by MARCY
;Added hosts with long host numbers. Defaults don't work yet.
;<MARCY.CMU>FTP.MAC.11, 10-Jun-81 12:25:54, Edit by MARCY
;Added File lists to mult send and keep version numbers from mult get

COMMENT ~
+-----------------------------------------------------------------------+
|									|
|	    Copyright (C) 1980, 1981, 1982  Glenn A. Marcy		|
|	Copyright (C) 1982, 1983, 1984, 1985  Vincent A. Fuller		|
|									|
|  This software, in source and binary form, is distributed free of	|
|  charge. The binary form of this software may be incorporated into	|
|  public-domain software and the source may be used for reference	|
|  purposes.  Copies may be made of the source provided this copyright	|
|  notice is included.  Wholesale copying of the routines in this	|
|  software or usage of this software in proprietary product without	|
|  prior permission is prohibited.					|
|									|
+-----------------------------------------------------------------------+
|									|
| In an effort to maintain a common, up-to-date version of this program	|	
| we ask that all bug fixes, bug reports, and changes in general be 	|
| sent back to CMU for incorporation and redistribution.		|
|									|
+-----------------------------------------------------------------------+
|									|
| History of FTP:							|
|									|
| This version of FTP was originally based upon the TOPS-20/TENEX NCP	|
| version of FTP written by BBN and DEC. The user interface was written	|
| by Glenn Marcy at CMU, as well as some changes to the low-level code.	|
| Most of the low-level code was re-written by Vince Fuller at CMU with	|
| the changeover to TCP-IP using the BBN/DEC TCP FTP as an example, and	|
| the user interface was extensively modified to use the CMD parsing	|
| package. Several bugfixes to this program are from Mark Crispin at	|
| Stanford. A large number of bugfixes were contributed by Dale Chase	|
| at USC-ISI.								|
|									|
+-----------------------------------------------------------------------+
~

	TITLE FTP - File Transfer Program
	SEARCH MONSYM,MACSYM,CMD
	.REQUIRE SYS:MACREL
	.REQUIRE SYS:CMD
	.REQUIRE TCPSIM

STDAC.

VWHO==4				;Last edited by CMU (VAF)
VMAJ==6				;Major version # (TCP version)
VMIN==0				;Revision #
VEDT==424			;Edit number

;Conditionals for compilation

IFNDEF SETPFL,<SETPFL==0>	;Default to not setting file protections
IFNDEF BIGBUF,<BIGBUF==0>	;Default to no large buffers

IF1,<
    IFN BIGBUF,<PRINTX Assembling with large buffers>
    IFN SETPFL,<PRINTX Assembling to set protections of paged files>
   >

	SUBTTL	Bitsies

F%APPE==1B0			;Append versus send command
F%NULL==1B1			;Receive side going to NUL:
F%KJFN==1B2			;Keep local jfn after data transfer
F%TTY==1B3			;Local file is TTY
F%DISK==1B4			;Local file is on dsk
F%PAGD==1B5			;Transfer is paged mode
F%SEND==1B6			;We are sending (else receiving)
F%OPEN==1B7			;We have a TELNET connection open
F%DATC==1B8			;We have a data connection open
F%DCLS==1B9			;Connection should be closed at end of xfer
F%HASH==1B10			;User wants hash marks every page
F%NPRT==1B11			;No PORT negotiation desired
F%CRLF==1B12			;Do NEWLINE/CRLF hacking
F%STAT==1B13			;Statistics desired
F%RTAN==1B14			;Retain generations
F%TECH==1B15			;Echo commands in take files
F%TALL==1B16			;Allow errors in take files
F%INDB==1B17			;Currently in debug conversation with server
F%XERR==1B18			;Error occurred during data transfer
F%CRHK==1B19			;If doing CRLF hacking for this xfer

;Macro to translate host number to string.

DEFINE GETNAME(BUF,NUM) <
	MOVX T1,.GTHNS
	HRROI T2,BUF
	IFNB <NUM>,<MOVE T3,NUM>
	GTHST%>

;Macro to translate host string to number

DEFINE GETNUM(BUF) <
	MOVX T1,.GTHSN
	HRROI T2,BUF
	GTHST%>

DEFINE CMSG (MSG) <
	CALL CRIF
	TMSG <MSG
>>

DEFINE TCMSG (MSG) <
	TMSG <MSG
>>

DEFINE TCRLF <
	TMSG <
>>

DEFINE EMSG (MSG) <
	HRROI T1,[ASCIZ/MSG/]
	ESOUT%
>

DEFINE ECMSG (MSG) <
	CALL CRIF
	HRROI T1,[ASCIZ/MSG
/]
	ESOUT%
>

DEFINE ERMSG (MSG) <
	JRST [	CMSG <?MSG>
		JRST HALTGO]>

DEFINE PARSE (DSP) <
	CALL RFLDE
	 JRST DSP
	JXN T1,CM%NOP,DSP>

DEFINE CLOSD (JFN,FLGS) <
IFB <FLGS>,<MOVEI T1,JFN>
IFNB <FLGS>,<MOVX T1,<FLGS!JFN>>
	CALL CLOSER>

DEFINE CLOSK (JFN) <
	MOVEI T1,JFN
	CALL CLOSEK>

;Macros to define special tables

DEFINE DEFTAB(TBL,MAX) <
   ..Z==.
   TBL:	BLOCK MAX+1>

DEFINE TABENT(ENT,DATA) <
   ..C==.
   RELOC ..Z+ENT
   DATA
   RELOC ..C>

DEFINE DEFEND(MAXNAM) <MAXNAM==.-..Z>

DEFINE $$(NAM) <<NAM_^D-9>>

OSMAX==$$<.HSVMS>

	SUBTTL	Parameters Constants and Macro's

	SEARCH TCPUNV		;Get TCP definitions

T.BFSZ==200			;Small buffers for TELNET connection
T.NDBF==3			;Triple buffered
IFE BIGBUF,<	T.BFSB==1200	;Page buffers for data connection
		T.NDBB==4>	;Quad buffered
IFN BIGBUF,<	T.BFSB==10000	;Moby buffers for data connection
		T.NDBB==6>	;and many of them

OPDEF	STAT%	[JSYS 745]	;TCP Status jsys
NPDL==	500			;Stack length
LJFSIZ==^D10			;Number of jfns in file list
NHSTS==	2000			;1000 network hosts i.e. XXX + 1
PATHSZ==20			;Length of path names
RCVLSZ==100			;Length of incomming telnet buffer
NTXHDR==40			;Length to allow on reading net
TNXFDB==25			;Length of TENEX FDB
MINFDB==TNXFDB			;Minimum acceptable FDB size
MAXFDB==.FBLEN+10		;Maximum acceptable FDB size

	PHASE 0
P.BYTE:!BLOCK 1			;Transmission byte size
P.TYPE:!BLOCK 1			;Type of transfer
P.TYP2:!BLOCK 1			;2nd type value
P.XTYP:!BLOCK 1			;Concatenation of both
P.STRU:!BLOCK 1			;Structure of transfer
P.MODE:!BLOCK 1			;Mode of transfer
P.SIZE:!BLOCK 0			;Size of this block
	DEPHASE

	PHASE 0
D.USER:!BLOCK 1			;Default User
D.ACCT:!BLOCK 1			;Default Account
D.PASS:!BLOCK 1			;Default Password
D.SIZE:!BLOCK 0			;Default block size
	DEPHASE

DEFINE ALLOC (A,B) <
	A=BASEPC
	BASEPC==BASEPC+B>

	SUBTTL	COMND tables

DEFINE TABLE <
	0
	..TBEG==.
	>

DEFINE TEND <
	..TEND==.
	RELOC ..TBEG-1
	..TEND-..TBEG,,..TEND-..TBEG
	RELOC ..TEND
	>

NAMTAB:	TABLE
	T FTP,0
	TEND

CMDTAB:	TABLE
	T Connect
	T Exit
	T Help,.HELP1
	T Information
	T Push
	T Quit
	T Set
	TEND

CMDTB2:	TABLE
	T Account
	T Append
	T Bye
	[CM%FW+CM%INV
	 ASCIZ /CD/],,.CPATH
	[CM%FW+CM%INV
	 ASCIZ /CONNECT/],,.CPATH
	T CPath
	[CM%FW+CM%INV
	 ASCIZ /CWD/],,.CPATH
	T Debug
	T Delete
	T Directory
	T Disconnect
	T Exit
	T Get
	T Help,.HELP2
	[CM%FW+CM%ABR+CM%INV
	 ASCIZ	/I/],,INFOKW
INFOKW:	T Information
	T Install
	T Login
	T Mount
	T Multiple
	T Password
	T Push
	[CM%FW+CM%ABR+CM%INV
	 ASCIZ	/Q/],,QUITKW
QUITKW:	T Quit
	T Quote
	T Rename
	T Send
	T Set
	T Status
	T Take
	T Type
	T Update
	TEND


$SET:	TABLE			;"Set" subcommands
	T Address
	T Allow,.SALLO
	T CRLF-munging,.SCRLF
	T Defaults
	T Echo,.SECHO
	T Hash-marks,.HASH
	T Mode
	T No,.SETNO
	T Opsys
	T Port
	T Retain
	T Statistics,.SSTAT
	T Structure
	T Timeout
	T Type,.STYPE
	T Verbose
	TEND

$SETNO:	TABLE			;"Set" Commands that may be preceded by "No"
	T Address
	T Allow,.SALLO
	T CRLF-munging,.SCRLF
	T Defaults
	T Echo,.SECHO
	T Hash
	T Opsys
	T Port
	T Retain
	T Statistics,.SSTAT
	T Verbose
	TEND

$INFO:	TABLE
	T All,.IALL
	T Defaults,.IDEFA
	T Foriegn-status,IFHOST
	T Switches,.ISWIT
	T Transfer,.ITRAN
	T Version,.IVER
	TEND

$HELP:	TABLE
	T Foreign,0
	T Local,1
	TEND

$MULT:	TABLE
	T Get,.MGET
	T Send,.MSEND
	TEND



;Break mask for parsing a hostname

HNMBRK:	777777777760		;No controls
	737744001760		;"#", "-", ".", numerics
	400000000260		;Upper case alphabetics, "[", "]"
	400000000760		;Lower case alphabetics

;Break mask for parsing a foriegn username/filename

REMBRK:	777777777760		;All controls are breaks (?)
	400000000020		;Space and question marks are breaks 
	000000000000		;Everything else except DEL is not a break
	000000000020

;Break mask for parsing an ITS username/filename

BRKITS:	777777777760		;All controls are breaks (?)
	000000000020		;Question mark is break
	000000000000		;Everything else except DEL is no break
	000000000020

PMASK:	ASCII /Your password: /	;15 chars...
	BYTE (7) 15,43,43,43,43
	ASCII /###############/
	BYTE (7) 15,115,115,115,115
	ASCII /mmmmmmmmmmmmmmm/
	BYTE (7) 15,44,44,44,44
	ASCII /$$$$$$$$$$$$$$$/
	BYTE (7) 15,15
PMASK2:	BYTE (7) 15,"T","h","a","n"
	ASCIZ /k-You.....
/


	SUBTTL	CMD storage

CMDSTG

INIPMT:	0
FTPPMT:	ASCIZ /FTP>/
	BLOCK ATMBLN-<.-FTPPMT>
HSTPMT:	BLOCK ATMBLN
CMDPMT:	BLOCK ATMBLN
PWDPMT:	ASCIZ /Password: /
LCLPMT:	ASCIZ / (to local file) /
FRNPMT:	ASCIZ / (to remote file) /
LCLPRS:	FLD(.CMOFI,CM%FNC)!CM%HPP!CM%DPP!CM%SDH
	0			;...
	POINT 7,[ASCIZ/local filename/]	;...
	POINT 7,LCLNAM		;...
	0			;...
LCLPRX:	FLD(.CMCFM,CM%FNC)!CM%DPP!LCLPRS
	0
	0
	POINT 7,LCLNAM

FRNPRS:	FLD(.CMTXT,CM%FNC)!CM%HPP!CM%DPP!CM%SDH
	0
	POINT 7,[ASCIZ /foreign filename/]
	POINT 7,FRNPTH
	0
FRNPRX:	FLD(.CMCFM,CM%FNC)!CM%DPP!FRNPRS
	0
	0
	POINT 7,FRNPTH

DEFTMV==1
TIMVAL:	DEFTMV			;Timeout quantum (in seconds)
FTPICS:	^D21			;FTP ICP socket
FTPDAS:	^D20			;FTP data socket

FDTXT1:	.FBCTL			;Can change these words
	.FBBYV
	.FBSIZ
	.FBUSW
IFN SETPFL,<.FBPRT>		;Set file protection
..Z=.
NFDBTX==.-FDTXT1
	.FBCRV
	.FBWRT
	.FBREF
FDBTMN==.-..Z			; Number of times
FDBTXN==.-FDTXT1

FDTXT2:	FB%TMP!FB%FCF		;Temp and type bits
	FB%BSZ			;Byte size
	.FWORD			;Eof
	.FWORD			;And user settable word
IFN SETPFL,<.RHALF>		;Only RH for protection

	.FWORD			;Time this version created
	.FWORD			;Time this version last ,modified
	.FWORD			;Time last referenced

FDTXST:	EXP FDBTM1,FDBTM2,FDBTM3,FDBUS0,FDBUS1
FDTXSN=.-FDTXST

FDTXT:	XWD .FBCRV,FDBTM1
	XWD .FBWRT,FDBTM2
	XWD .FBREF,FDBTM3
FDTXTN==.-FDTXT

FDTXUG:	XWD .GFAUT,FDBUS0
	XWD .GFLWR,FDBUS1

FDTXUS:	XWD .SFAUT,FDBUS0
	XWD .SFLWR,FDBUS1
FDTXUN==.-FDTXUS

PGLEN:	EXP 4,4,4,5		;Header lengths for PGT$LP, $SP, $DP, $AP


	SUBTTL	Interrupt system

LEVTAB:	RETPC1
	RETPC2
	RETPC3

CHNTAB:	3,,CAINT		;^A interrupt
CAICHN==.-1-CHNTAB
	3,,CBINT		;^B interrupt
CBICHN==.-1-CHNTAB
	3,,CPINT		;^P interrupt
CPICHN==.-1-CHNTAB
	3,,ABOINT		;Inferior abort signal interrupt
ABOCHN==.-1-CHNTAB
	2,,INFINT		;Telnet data arrived interrupt
INFCHN==.-1-CHNTAB
	2,,CGINT		;^G interrupt
CGILEV==2
CGICHN==.-1-CHNTAB
	0			;6  - (.ICAOV) Arithmetic overflow
	0			;7  - (.ICFOV) Floating overflow
	0			;8  - Reserved
	0			;9  - (.ICPOV) Pdl overflow
	0			;10 - (.ICEOF) End of file
	0			;11 - (.ICDAE) Data error
	0			;12 - (.ICQTA) Quota exceeded
	0			;13 - Reserved
	0			;14 - Reserved
	0			;15 - (.ICILI) Illeg instruction
	0			;16 - (.ICIRD) Illegal read
	0			;17 - (.ICIWR) Illegal write
	0			;18 - Reserved
	0			;19 - (.ICIFT) Inferior fork termination
	0			;20 - (.ICMSE) Machine size exceeded
	0			;21 - Reserved
	0			;22 - (.ICNXP) Non-existent page referenced
	0			;23 - Available for user
	0			;24 - Available for user
	0			;25 - Available for user
	0			;26 - Available for user
	0			;27 - Available for user
	0			;28 - Available for user
	0			;29 - Available for user
	0			;30 - Available for user
	0			;31 - Available for user
	0			;32 - Available for user
	0			;33 - Available for user
	0			;34 - Available for user
	0			;35 - Available for user

CHNMSK:	1B<CAICHN>!1B<CBICHN>!1B<ABOCHN>!1B<CPICHN>!1B<INFCHN>!1B<CGICHN>

STKINI:	IOWD NPDL,PDL		;Top-level stack pointer



	SUBTTL	Bits which drive response receiver.

RC%TTX==1B0			;Type the text but not the number
RC%TWL==1B1			;Type the whole line
RC%ABO==1B2			;Abort after typing
RC%NUM==7777B17			;Number of response
RC%DSP==.RHALF			;Dispatch address

DEFINE RPTENT (NUMBER,FLAGS,ADDR) <
	FLAGS!FLD(^D<NUMBER>,RC%NUM)!FLD(ADDR,RC%DSP)>

REPTAB:	RPTENT 110,0,0		;Restart marker
	RPTENT 119,RC%TTX,0	;Terminal not avail, will try mailbox
	RPTENT 120,RC%TTX,0	;Sevice ready in nnn minutes
	RPTENT 125,RC%TTX,0	;Data connection already open
	RPTENT 150,RC%TTX,0	;File status reply
	RPTENT 151,RC%TTX,0	;User not local - will forward
	RPTENT 152,RC%TTX,0	;User Unknown
CPRSP2:	RPTENT 200,0,0		;Just an ok to last command
	RPTENT 202,RC%TTX,0	;Command not implemented
	RPTENT 211,RC%TTX,0	;System status or system help reply
FSTRS1:	RPTENT 212,RC%TTX,0	;Directory status
FSTRSP:	RPTENT 213,RC%TTX,0	;File status
	RPTENT 214,RC%TTX,0	;Help message
	RPTENT 215,RC%TTX,0	;<scheme> is the preferred scheme
	RPTENT 220,RC%TTX,0	;Service is ready for new user
	RPTENT 221,RC%TTX,REP221 ;Service closing TELNET connection
	RPTENT 225,RC%TTX,0	;Sta connection open - no tranfer in progress
	RPTENT 226,RC%TTX,REP226 ;Closing data connection
	RPTENT 227,RC%TTX,REP227 ;Entering passive mode (~~needs REP227 action)
	RPTENT 230,RC%TTX,0	;Login received
	RPTENT 250,RC%TTX,REP250 ;Requested file action okay - completed
CPRSP1:	RPTENT 331,0,0		;User ok - send password
	RPTENT 332,0,0		;Pass ok, send acct
	RPTENT 350,RC%TTX,0	;Requested file action pending further info
	RPTENT 354,RC%TTX,0	;Send mail.
ABTCOD==^D400			;Codes higher than this are aborts
	RPTENT 421,RC%ABO!RC%TWL,0 ;Service not available
	RPTENT 425,RC%ABO!RC%TWL,0 ;Can't open data connection
	RPTENT 426,RC%ABO!RC%TWL,0 ;Connection closed, transfer aborted
	RPTENT 450,RC%ABO!RC%TWL,0 ;Requested file action not taken
	RPTENT 451,RC%ABO!RC%TWL,0 ;Requested action aborted - local error
	RPTENT 452,RC%ABO!RC%TWL,0 ;Insufficient storage space in system
	RPTENT 500,RC%ABO!RC%TTX,0 ;Gibberish rcvd
	RPTENT 501,RC%ABO!RC%TTX,0 ;..
	RPTENT 502,RC%ABO!RC%TTX,0 ;..
	RPTENT 503,RC%ABO!RC%TTX,0 ;..
	RPTENT 504,RC%ABO!RC%TTX,0 ;..
	RPTENT 530,RC%ABO!RC%TTX,0 ;Not logged in
	RPTENT 532,RC%ABO!RC%TTX,0 ;Need account for storing files
FSTABT:	RPTENT 550,RC%ABO!RC%TTX,0 ;File not found/no access
	RPTENT 551,RC%ABO!RC%TTX,0 ;Page type unknown
	RPTENT 552,RC%ABO!RC%TTX,0 ;Exceeded storage allocation
	RPTENT 553,RC%ABO!RC%TTX,0 ;File name not allowed
	RPTENT 554,RC%ABO!RC%TTX,0 ;?
	RPTENT 555,RC%ABO!RC%TTX,0 ;?ITS likes to send these...
	RPTENT 777,RC%TWL,REP777 ;Special server breakpoint/debug hack
NREPS==.-REPTAB			;Length of table


	SUBTTL	Global Storage

DEFINE PVALS(NAM,OLDV,NEWV) <
	PRINTX NAM from OLDV to NEWV
>

DEFINE NXTPAG(A) <
	..A==<<A+777>_-9>_9
	PVALS(A,\A,\..A)
	A==..A
	>

GSPAGE==200			;First page of globals
BASEPC==GSPAGE_9		;Start allocation here

ALLOC WINDOW,2000		;First, get on boundary. file window.
ALLOC WINDW2,2000		;A few pages for expanding 32/36 img
ALLOC FRNHST,1			;Foreign host number
ALLOC FRNOPS,1			;Foreign operating system
ALLOC FRNOPH,1			;Foriegn operating system, from GTHST
ALLOC ICPPRT,1			;Local port to used for ICP/TELNET connection
ALLOC LSNPRT,1			;Port to listen for data connection on
ALLOC USRPRT,1			;Port set by user PORT command, if any
ALLOC JOBNO,1			;Job number of this process
ALLOC TIMEX,1			;Initial 8-bits of HPTIM% for port randomizing
ALLOC LDIRNO,1			;Logged-in directory number
ALLOC BATFLG,1			;Result of .JIBAT GETJI% (not -1 if batch)
ALLOC TELJFN,1			;Telnet network socket jfn
ALLOC DATJFN,1			;Data network socket jfn
ALLOC LJFIDX,1			;Local data jfn index
ALLOC LJFTAB,LJFSIZ		;Local data jfn(s)
ALLOC TAKJFN,1			;Take file jfn (only one level, for now...)
ALLOC TAKECH,1			;Flag if echoing
ALLOC HDXFLG,1			;Half-duplex was set by password processing
ALLOC INIFLG,1			;SWITCH.INI flag
ALLOC RSCFLG,1			;Nonzero if we have rescan
ALLOC DIRJFN,1			;Directory jfn in multiple get
ALLOC GBLFWD,1			;Global flag word
ALLOC RFORKH,1			;Fork handle of telnet receiver
ALLOC EFORKH,1			;Fork handle of pushed exec.
ALLOC NAMES,2			;Systat names
ALLOC LCLNAM,ATMBLN		;Temp buffer for GT10X
ALLOC LHSNAM,ATMBLN		;Local host name
ALLOC LHSNUM,1			;Local host number
ALLOC LHSNM2,1			;Local host number to use for foriegn host
ALLOC LHSFLG,1			;Flag if using LHSNUM as LHSNM2
ALLOC PRTSTR,10			;Host number part of port number
ALLOC OLDFRN,ATMBLN		;In DOSTAT - previous name checked
ALLOC FRNPTH,ATMBLN		;Foreign pathname
ALLOC FRNPT2,ATMBLN		;Second foreign path (rename)
ALLOC RCVLIN,RCVLSZ		;Space for the incoming telnet line
ALLOC STATBF,RCVLSZ		;Copy of RCVLIN after a STAT command
ALLOC STATM1,1			;Creation date for file in STAT
ALLOC STATM2,1			;Last write date for file in STAT
ALLOC RCVMSG,RCVLSZ		;Last message received
ALLOC TELBUF,ATMBLN		;Space to build/send telnet stuff
ALLOC REPCOD,1			;Reply code as a number
ALLOC REPEON,1			;First char of reply message
ALLOC REPINT,1			;Reply-interrupt flag
ALLOC REPOK,1			;Reply came flag
ABTMAX==10			;Number of aborts
ALLOC ABTSTK,ABTMAX		;Abort stack
DEFINE PSHABT(ADR) <		;Push an abort on the stack
	MOVE CX,ABTSP
	PUSH CX,[ADR]
	MOVEM CX,ABTSP>
DEFINE POPABT(ADR) <		;Remove abort from stack
	MOVE CX,ABTSP
	ADJSP CX,-1
	MOVEM CX,ABTSP>
ALLOC ABTSP,1			;Pointer to abort stack
ALLOC ABTSPB,1			;Abort stack base
ALLOC F.ABRT,1			;Abort occurred flag
ALLOC F.DTIP,1			;Data transfer in progress flag
ALLOC F.DTDR,1			;Data transfer OK came in
ALLOC F.TCLS,1			;Telnet connection close requested
ALLOC F.VBOS,1			;Verbose flag
ALLOC F.DBUG,1			;FTP server debugging flag
ALLOC STATMP,2			;*** For wedged BBN syncronization code

;Header for paged transfers. do not separate.
ALLOC TYXHED,0			;Name of header
ALLOC TYXNPW,1			;Header length (4 or 5)
ALLOC PAGNO,1			;Page number in disk file
ALLOC TYXNDW,1			;Number of data words after header
ALLOC RECTYP,1			;Record type
  PGT$LP==:0			;Last page
  PGT$SP==:1			;Simple data page
  PGT$DP==:2			;Descriptor page
  PGT$AP==:3			;Access controlled page
  PGT$MI==:PGT$LP		;Minimum paged record type
  PGT$MX==:PGT$AP		;Max paged record type
ALLOC ACCESS,1			;SPACS arg if this is data
TYXHDN==5			;Length of this header
LTYXMN==4			;Minimum header length
;End of do not separate group

;ALLOC TYXSCT,1			;Sequence number for paged mode
ALLOC TYXHDR,NTXHDR		;Make longer in case it grows

ALLOC PARAMS,P.SIZE		;The data transmission parameters
ALLOC PARAM2,P.SIZE		;Copy during actual transfer
ALLOC PARAM3,P.SIZE		;Last ones sent out

ALLOC NBYTES,1			;Number of bytes in a transfer
ALLOC NWORDS,1			;Number of words in dsk file
ALLOC SNDCNT,1			;Running count of chars in window to send
ALLOC SNDPTR,1			;Ptr goes with running count
ALLOC SNDCRL,1			;Flag for last char was CR (DSEND)
ALLOC RCVCRL,1			;Flag for last char was CR (RECEIV)
ALLOC FBYTES,1			;Number of bytes in file to send
ALLOC FILBSZ,1			;Byte size file was written in
ALLOC LCLBSZ,1			;Byte size file opened in
ALLOC LBYTES,1			;Number of logical bytes (=FBYTES
				;  if FILBSZ=LCLBSZ)
ALLOC MGFILS,1			;Number of files tried to get in MGet
ALLOC MGTRXD,1			;Number of files transferred OK in MGet
ALLOC QUIETF,1			;Flag for CKTRAN to be quiet
ALLOC FDB,.FBLEN		;Space for dsk file FDB
ALLOC FDBTM1,10			;Times
ALLOC FDBTM2,10			;...
ALLOC FDBTM3,10			;...
ALLOC FDBUS0,10			;User names
ALLOC FDBUS1,10			;...
ALLOC FDBBKE,0			;End of BLT to clear
ALLOC NPAGES,1			;Number of pages actually transferred
ALLOC PAGENO,1			;Page number to map in dsk file
ALLOC IBPTR,1			;Pointer to WINDOW page
ALLOC LCLBPW,1			;Bytes per word in local file as open
ALLOC CPUTIM,1			;Timing cells
ALLOC DAYTIM,1			;..
ALLOC TCPUTM,1			;Totals of above, during MGET/MSEND
ALLOC TDAYTM,1			;..
ALLOC TNBYTS,1			;..
ALLOC TNPAGS,1			;..
ALLOC HOSTBF,ATMBLN		;Buffer for host name
ALLOC PUSER,1			;Pointer to user string
ALLOC USERBF,ATMBLN		;User name
ALLOC PPASS,1			;Same for password
ALLOC PASSBF,ATMBLN
ALLOC PACCT,1			;And account
ALLOC ACCTBF,ATMBLN
ALLOC PWDTRP,1
ALLOC CMDDSP,1			;Command dispatch address
ALLOC CGSVSP,1			;Saved stack pointer in ^G code
ALLOC TRSAVP,1			;Saved stack pointer in TRDATA
ALLOC PUSHED,1			;In a pushed exec
ALLOC JFNBLK,.GJATR
ALLOC PRT227,1			;Port # from PORT reply (passive mode)

NXTPAG(BASEPC)			;Round up to next page

;TELNET connection buffers - do not separate
ALLOC TELCON,T.SIZE		;Telnet file block, including CDB
ALLOC TELBFH,2*T.NDBF*.TCPBS	;TELNET buffer headers
ALLOC TELRBF,T.BFSZ*T.NDBF	;TELNET receive data buffers
ALLOC TELSBF,T.BFSZ*T.NDBF	;TELNET send data buffers
;End of do not separate group

	SUBTTL	Private storage

PSPAGE==220
PSBASE==PSPAGE_9
BASEPC==PSBASE

ALLOC SAVET1,2			;Save acs T1,T2 here in ABOINT
ALLOC RETPC1,1
ALLOC RETPC2,1
ALLOC RETPC3,1
ALLOC STRTMP,CMDBLN		;A random string space
ALLOC PDL,NPDL
ALLOC GTJSTR,CMDBLN		;String storage for gtjfn arg

NXTPAG(BASEPC)			;Round up to next page

ALLOC DFLTAB,NHSTS		;Defaults table
ALLOC DFLBLK,<NHSTS*3>		;Default structure
ALLOC DFLIDX,1			;End of DFLBLK
ALLOC DFLADR,1			;Default free space pointer
ALLOC DSTOP,0			;Top of the defaults
ALLOC DDATA,10000		;String space for default tables
ALLOC DEND,0			;End of string space

NXTPAG(BASEPC)			;Round up to next page

;Data connection buffers - do not separate
ALLOC DATCON,T.SIZE		;Data file block, including CDB
ALLOC DATBFH,2*T.NDBB*.TCPBS	;Data buffer headers
ALLOC DATBUF,<2*T.BFSB*T.NDBB>	;Data buffers
;End of do not separate group

ALLOC PSTOP,0			;End of private storage


DALLOC:	ADD T1,DFLADR		;Add in the number to allocate
	CAIG T1,DEND		;Ran out ?
	IFSKP.
	  ECMSG <Storage allocator ran out of free space>
	  HALTF%		;Don't continue
	  JRST .-1
	ENDIF.
	EXCH T1,DFLADR		;Put everything where it belongs
	RET

CMERRX:	SKIPN TAKJFN		;Doing TAKE file?
	JRST CMDERR		;No - handle normally
	MOVX T1,<.PRIIN,,.PRIOU>
	MOVEM T1,SBK+.CMIOJ	;Fix jfns in CSB
	MOVX T1,.FHSLF
	GETER%			;Get last error code
	HRRZ T1,T2		;Copy RH to T1
	CAIE T1,IOX4		;This is OK...
	IFSKP.
	  SKIPE INIFLG		;Not SWITCH.INI?
	  IFSKP.		;Yes
	    TMSG <[End of >
	    MOVX T1,.PRIOU
	    MOVE T2,TAKJFN
	    SETZB T3,T4
	    JFNS%
	    TCMSG <]>
	  ENDIF.
	ELSE.			;Real error - print it
	  EMSG <Error processing >
	  EXCH T2,TAKJFN	;Swap error code & jfn...
	  MOVX T1,.PRIOU
	  SETZB T3,T4
	  JFNS%
	  EXCH T2,TAKJFN	;Get back error code...
	  TMSG < - >
	  MOVX T1,.PRIOU
	  SETZ T3,
	  ERSTR%		;Print the error
	   TRNA
	   TRN
	  TCMSG <>
	ENDIF.
	CALL TAKEND		;End the take file
	SKIPE INIFLG		;Was this SWITCH.INI?
	JRST INIDON		;Yes - do sort-of restart
	JRST TAKDON		;No - just go to command loop

ENTVEC:	JRST GO
	JRST GO
VERSIO:	FLD(VWHO,VI%WHO)!FLD(VMAJ,VI%MAJ)!FLD(VMIN,VI%MIN)!FLD(VEDT,VI%EDN)

GO:	RESET%			;Clear stuff in system
	MOVX F,<F%CRLF>		;Default is do CRLF hacking
	MOVE P,STKINI		;Initial stack pointer
	MOVX T1,.FHSLF
	RPCAP%			;Get privs
	IFXN. T2,SC%ANA		;Has arpanet access?
	  TXO T3,SC%ANA		;Turn it on
	  EPCAP%		;and enable
	ENDIF.
	CALL CMDINI		;Initialize CMD package
	MOVX A,<IFIW!CMERRX>	;CMD error address
	MOVEM A,CMDERA		;Set it
	MOVE T1,['20-FTP']	;Something distinctive
	MOVE T2,['20-FTP']	;Something distinctive
	DMOVEM T1,NAMES		;Save them
	SETSN%			;To see if it gets used.
	 TRN
	GETNAME LHSNAM,[-1]	;Get local host name
	 ERMSG <Unable to find local host name>
	GETNUM LHSNAM		;Get local host number
	 ERMSG <Unable to find local host number>
	SKIPN LHSFLG		;Already specified with NETWORK command?
	 MOVEM T3,LHSNUM	;Save local host number
	GJINF%			;Get job info
	MOVEM T3,JOBNO		;Save it
	SETZ T1,		;Want uptime clock
	HPTIM%			;Get time value
	 TRN			;Should never fail...
	MOVEM T1,TIMEX		;Initial port randomizing value
	SETO T1,		;This job
	MOVX T2,<-1,,LDIRNO>	;Want logged-in directory number
	MOVEI T3,.JILNO		;...
	GETJI%
	 TRN
	SETO T1,		;This job
	MOVX T2,<-1,,BATFLG>
	MOVX T3,.JIBAT		;Batch flag...
	GETJI%			;Get it
	 SETZM BATFLG		;Shouldn't happen, but handle it
	MVI. DSTOP,DFLADR	;Setup pointer to free list
	SETOM RFORKH		;..
	CALL TYPINI		;Initialize transfer params
	MVI. <.PRIIN,,.PRIOU>,SBK+.CMIOJ
	MOVX T2,<FTPPMT,,CMDPMT>
	BLT T2,CMDPMT+ATMBLN-1
	MOVE T1,[IOWD ABTMAX,ABTSTK] ;Initialize stack
	PUSH T1,[0]		;Mark top of stack
	MOVEM T1,ABTSPB		;Save stack base
	MOVEM T1,ABTSP		;And start pointer
	MOVX T1,<.TICCA,,CAICHN> ;Channel for control A
	ATI%
	MOVX T1,<.TICCB,,CBICHN> ;Control B
	ATI%
	MOVX T1,<.TICCP,,CPICHN> ;Control P
	ATI%
	MOVX T1,<.TICCG,,CGICHN> ;And control G
	ATI%
	MOVX T1,.FHSLF		;Set up psi for this fork
	MOVX T2,<LEVTAB,,CHNTAB> ;Int vectors
	SIR%
	EIR%
	MOVE T2,CHNMSK
	AIC%

; Do SWITCH.INI and rescan processing now...

	MOVX T1,.RSINI
	RSCAN%			;Initialize RSCAN buffer
	 SETZ T1,
	MOVEM T1,RSCFLG		;Indicate that we have some...

	HRROI T1,ATMBUF		;Pick a buffer, any buffer
	MOVE T2,LDIRNO		;Home directory number
	DIRST%			;Translate it
	 MOVE T1,[POINT 7,ATMBUF] ;This shouldn't happen...
	MOVEI T2,[ASCIZ/SWITCH.INI/] ;File name
	CALL MOVSTR		;Append it
	MOVX T1,GJ%SHT!GJ%OLD
	HRROI T2,ATMBUF
	GTJFN%			;Try to find it...
	IFSKP.			;OK
	  MOVE T3,T1		;Copy JFN
	  MOVX T2,OF%RD!FLD(7,OF%BSZ)
	  OPENF%		;Open it
	  IFSKP.
	    HRRZM T1,TAKJFN	;Save the JFN
	    SETOM INIFLG	;Say doing init
	    HRLZS T1		;LH=JFN
	    HRRI T1,.NULIO	;RH=null
	    MOVEM T1,SBK+.CMIOJ	;Save JFN for COMND% calls
	    JRST CMDBGN		;Go join parser loop
	  ELSE.
	    MOVE T1,T3		;Get jfn back
	    RLJFN%		;And release it
	     TRN
	  ENDIF.
	ENDIF.

;SWITCH.INI EOF and rescan check failure return here

INIDON:	SETZM INIFLG
	SKIPN RSCFLG		;Have rescan?
	 CALL VERPNT		;No - go print program version

;Take file EOF returns here

TAKDON:	MOVE P,STKINI		;Fix possibly screwed stack...
CMDBGN:	MVI. JFNBLK,<SBK+.CMGJB> ;Setup GTJFN block
	SETZM JFNBLK		;Gtjfn block
	MOVX T1,<JFNBLK,,JFNBLK+1>
	BLT T1,JFNBLK+.GJATR-1
	MVI. CMDLUP,CMDDSP	;Dispatch address
CMDLUP:	SETZM OLDFRN		;Clear STAT info (reparse hack)
	SKIPG T1,LJFTAB		;Any local jfn?
	IFSKP.			;Yes
	  CLOSF%		;Close top one
	  IFNSK.		;Error...
	    MOVE T1,LJFTAB	;Try again...
	    RLJFN%		;This time, just releasing
	     TRN		;No error
	  ENDIF.
	ENDIF.
	SKIPN T2,LJFIDX		;Any stacked jfns?
	IFSKP.			;Yes
	  DO.			;Loop over them
	    SKIPLE T1,LJFTAB(T2) ;Get this one
	    CLOSF%		;Try to close it
	    IFJER.		;Failed
	      SKIPLE T1,LJFTAB(T2) ;Retry
	      RLJFN%		;But just release it
	       TRN
	    ENDIF.
	    SOJG T2,TOP.	;Do for all except 0'th
	  ENDDO.
	ENDIF.
	SETZ T2,		;Initialize value
	SKIPLE T1,TELJFN	;Get "JFN", skip if non-existant
	$GTSTS			;Check it's status
	 ERJMP [SETZ T2,
		JRST .+1]
	IFXE. T2,GS%OPN		;Appears to be closed?
	ANDXN. F,F%OPEN		;Flag disagrees?
	  TCMSG <%Connection closed> ;Announce this
	  TXZ F,F%OPEN		;Make sure flag agrees
	ENDIF.
	HRROI T1,FTPPMT		;Get normal prompt
	TXNE F,F%OPEN		;Connection open?
	 HRROI T1,HSTPMT	;Use host-name prompt
CMDLU1:	HRROI T2,[0]		;A null prompt
	MOVEM T2,SBK+.CMRTY	;Set null prompt
	SKIPN TAKJFN		;If SWITCH.INI, then prompt
	 SKIPN RSCFLG		;If rescan, then don't prompt
	  CALL DPROMP
CMDRPS:	MOVE P,STKINI		;Restore stack pointer during reparse
	SKIPE HDXFLG		;Did someone turn off echoing?
	 CALL PWORD2		;Yes - go fix it now
	MV. ABTSPB,ABTSP	;Trim abort stack
	TXZ F,F%KJFN
	SKIPN INIFLG		;Are we parsing SWITCH.INI?
	IFSKP.			;Yes
	  MOVEI T1,[FLDDB. .CMKEY,,NAMTAB,,,<[
		    FLDDB. .CMCFM,,,,,<[
		    FLDDB. .CMTXT]>]>]
	  PARSE CMERRX		;Parse the program name
	  LOAD T4,CM%FNC,.CMFNP(T3)
	  CAIN T4,.CMKEY	;Have a keyword or junk?
	  IFSKP.		;Junk...
	    MOVEI T1,[FLDDB. .CMINI]
	    PARSE CMERRX	;Re-initialize
	    JRST CMDRPS		;And go for next line
	  ENDIF.
	ELSE.
	  SKIPN RSCFLG		;Do we have rescan?
	  IFSKP.		;Yes
	    SETZM RSCFLG	;But no more...
	    MOVEI T1,[FLDDB. .CMKEY,,NAMTAB,,,<[
		      FLDDB. .CMCFM,,,,,<[
		      FLDDB. .CMTXT]>]>]
	    PARSE CMERRX	;Parse program name
	    LOAD T4,CM%FNC,.CMFNP(T3)
	    CAIE T4,.CMKEY	;Found it...
	    IFSKP.
	      MOVEI T1,[FLDDB. .CMCFM,,,,,<[
			FLDBK. .CMFLD,,,<Internet host name>,,HNMBRK]>]
	      PARSE CMERRX	;Parse host name or confirm
	      LOAD T4,CM%FNC,.CMFNP(T3)
	      CAIE T4,.CMFLD	;Got a host name?
	      IFSKP.		;Yup
		CALL CNCT1	;Go attemt connection
		JRST CMDBGN	;And continue FTP
	      ENDIF.
	    ENDIF.
	    JRST INIDON		;No rescan - restart
	  ENDIF.
	ENDIF.
	MOVEI T1,[FLDDB. .CMKEY,,CMDTAB,,,<[
		  FLDBK. .CMFLD,,,<Internet host name>,,HNMBRK]>]
	TXNE F,F%OPEN		;Connection open ?
	 MOVEI T1,[FLDDB. .CMKEY,,CMDTB2,,,<[
		   FLDDB. .CMCFM,CM%SDH]>]
	PARSE CMERRX
	SKIPN TAKECH		;Doing echo for take?
	IFSKP.			;Yes... (hack)
	  HRROI T1,CMDBUF
	  PSOUT%		;Print the input buffer now
	ENDIF.
	PSHABT CMDABT		;Set abort dispatch for command loop
	LOAD T4,CM%FNC,.CMFNP(T3)
	CAIE T4,.CMFLD		;Field (host name)?
	IFSKP.
	  CALL CNCT1		;Go try connect
	ELSE.
	  CAIN T4,.CMCFM	;Confirm?
	   JRST CMDLUP		;Skip the command, then
	  HRRZ T2,(T2)		;Get dispatch
	  TXZ F,F%APPE		;Not append yet
	  CALL (T2)		;Do the command
	ENDIF.
	JRST CMDLUP
CMDLUX: MOVE P,STKINI		;Restore SP after ^G abort
	CALL CRIF		;CRLF
	TMSG <[Aborted]>
	SKIPE TAKJFN		;In a take file?
	 CALL TAKEND		;Abort it
	JRST CMDLUP		;Loop back

;^G given during processing of a command. Forces return to command loop.

CMDABT:	MVI. <PC%USR!CMDLUX>,<RETPC1+CGILEV-1> ;Setup interrupt return address
	RET			;Done

ERROR:	CALL CRIF
	TMSG <?>
	MOVEI T1,.PRIOU
	HRLOI T2,.FHSLF
	SETZ T3,
	ERSTR%
	 TRNA
	 TRN
	RET


	SUBTTL	Random utilities

CRIF:	SAVEAC <T1,T2>
	MOVX T1,.CTTRM
	RFPOS%
	HRROI T1,[ASCIZ /
/]
	TXNE T2,.RHALF
	PSOUT%
	RET

;GTBLT% simulator for non-CMU monitors

$GTBLT:	MOVEI T3,(T1)		;Save table number
	GETAB%			;Get number of entries
	 ERJMP GTBLT2
	HRLZ T4,T1		;Form aobjn pointer
	HRLI T2,T4
GTBLT1:	MOVEI T1,(T3)		;Table number
	HRLI T1,(T4)		;Index
	GETAB%
	 ERJMP [SETZM (T2)
		JRST GTBLT3]
	MOVEM T1,(T2)
GTBLT3:	AOBJN T4,GTBLT1
GTBLT2:	RET


	SUBTTL	(simple) Command definitions

.BYE:	NOISE <and disconnect>
	CONFRM
BYE1:	MOVEI T1,[0]		;No body of bye message
	MOVEI T2,[ASCIZ /QUIT/]
	CALL TELCFM		;Send it & wait for confirmation
	 TRN
	RET

.DISCO:	NOISE <forcibly>
	CONFRM
	MOVEI T1,[0]		;No body of msg
	MOVEI T2,[ASCIZ/QUIT/]	;Quit command
	CALL TELSND		;Send it
	CALLRET TCLOSE		;Force close of connection

.EXIT:	HRROI CX,[ASCIZ/to exec/]
	TXNE F,F%OPEN		;Any connection?
	 HRROI CX,[ASCIZ/and close connection/]
	CALL NOIRTN		;Do noise
	CONFRM			;Confirm it
	TXNE F,F%OPEN
	 CALL BYE1		;Close connection
	HALTF%
	RET

.QUIT:	IFXN. F,F%OPEN
	  NOISE <and leave connection open>
	ELSE.
	  NOISE <and return to exec>
	ENDIF.
	CONFRM
	HALTF%			;Pause
	RET

.MOUNT:	NOISE <foreign structure>
	MOVEI T1,[FLDDB. .CMDEV,CM%SDH!CM%PO,,<structure name>]
	PARSE CMERRX
	DMOVE T1,ATMBUF		;Get name
	DMOVEM T1,FRNPTH	;Save here for now
	CONFRM			;Confirm it
	HRROI T1,FRNPTH		;Name of structure
	HRROI T2,[ASCIZ/SMNT /]
	CALL TELCFM		;Send & get reply
	 TRN			;Failed...
	RET

.PUSH:	NOISE <to exec>
	CONFRM
	CALL PUSH1
	MOVE T1,EFORKH
	WFORK%
	 ERCAL HALTGO
	DMOVE T1,NAMES		;Restore old names
	SETSN%
	 ERCAL HALTGO
	RET

PUSH1:	SKIPN T1,EFORKH
	IFSKP.
	  HRLI T1,.FHSLF
	  SFORK%
	  IFNJE.
	    RFORK%
	     ERJMP HALTGO
	    RET
	  ENDIF.
	ENDIF.
	MOVX T1,GJ%OLD!GJ%SHT	;Try to get SYSTEM:EXEC
	HRROI T2,[ASCIZ /SYSTEM:EXEC.EXE/]
	GTJFN%
	 ERJMP HALTGO
	PUSH P,T1		;Save EXEC's JFN
	MOVX T1,CR%CAP		;Make an inferior fork
	CFORK%
	 ERJMP HALTGO
	MOVEM T1,EFORKH
	EXCH T1,(P)		;Save fork handle, get JFN
	HRL T1,(P)		;Stuff the fork
	GET%
	 ERJMP HALTGO
	MOVX T1,.FHSLF
	RPCAP%
	 ERJMP HALTGO
	MOVE T1,(P)
	TXZ T2,SC%LOG		;No logout
	SETZ T3,
	EPCAP%
	 ERJMP HALTGO
	POP P,T1
	SETZ T2,
	SFRKV%
	 ERCAL HALTGO
	RET

.HELP1:	NOISE <on commands>
	CONFRM
HLPLCL:	MOVX T1,GJ%SHT!GJ%OLD
	HRROI T2,[ASCIZ/HLP:FTP.HLP/]
	GTJFN%			;Find help file
	IFJER.
	  ECMSG <Sorry, help not available - cannot find HLP:FTP.HLP>
	  RET
	ENDIF.
	MOVE T3,T1		;Copy JFN away
	MOVX T2,<OF%RD!FLD(7,OF%BSZ)>
	OPENF%			;Open help file
	IFJER.			;Failed
	  ECMSG <Sorry, help not available - cannot open HLP:FTP.HLP>
	  RLJFN%		;Dump the JFN
	   TRN
	  RET
	ENDIF.
	DO.
	  MOVE T1,T3		;Get jfn back
	  BIN%			;Read character from file
	   ERJMP ENDLP.		;Done
	  MOVEI T1,.PRIOU
	  BOUT%
	  LOOP.			;Do until EOF
	ENDDO.
	CLOSF%			;Try to close
	IFJER.			;Hmm...
	  MOVE T1,T3
	  RLJFN%
	   TRN
	ENDIF.
	RET
	
.HELP2:	NOISE <on commands>
	MOVEI T1,[FLDDB. .CMKEY,,$HELP,,<Local>]
	PARSE CMERRX
	CONFRM
	HRRZ T2,(T2)
	JUMPN T2,HLPLCL		;Do local help
	HRROI T1,[ASCIZ /HELP/]
	HRROI T2,[0]		;No keyword.
	CALL TELCFX		;Read replies
	 TRN
	RET

;"Take (commands from) <file-name>"

.TAKE:	SKIPN TAKJFN		;Are we in a take file already?
	IFSKP.			;Yes
	  CONFRM		;Then confirm to get out of it
TAKEND:	  MOVE T1,TAKJFN
	  CLOSF%		;Close take file
	   TRN
	  SETZM TAKJFN
	  SETZM TAKECH
	  MOVX T1,<.PRIIN,,.PRIOU>
	  MOVEM T1,SBK+.CMIOJ	;Fix jfns
	  RET			;Done
	ENDIF.
	NOISE <commands from file>
	MOVEI T1,[FLDDB. .CMIFI,,,<file name >]
	PARSE CMERRX		;Parse an input file
	HRLZ Q1,T2		;Copy jfn away
	MOVEI T1,[FLDDB. .CMSWI,,$TAKE,,,<[
		  FLDDB. .CMCFM]>]
	PARSE CMERRX
	SETZM TAKECH		;Default to no echo
	TXNE F,F%TECH		;Doing echo by default?
	 SETOM TAKECH		;Yes - do it
	LOAD T4,CM%FNC,.CMFNP(T3)
	CAIE T4,.CMSWI		;Switch?
	IFSKP.			;Yes
	  HRRZ T2,(T2)		;Get switch value
	  CONFRM		;Do confirm
	  MOVEM T2,TAKECH	;Make new echo value
	ENDIF.
	HLRZ T1,Q1		;Get jfn again
	MOVX T2,<OF%RD!FLD(7,OF%BSZ)>
	OPENF%			;Try to open...
	IFJER.			;Nope.
	  CALL ERROR		;Print generic error message
	  HLRZ T1,Q1
	  RLJFN%		;Punt the jfn
	   TRN
	  RET
	ENDIF.
	HRRI Q1,.NULIO		;Assume no echo
	SKIPE TAKECH		;Correct?
	 HRRI Q1,.PRIOU		;Nope - do echoing to here
	MOVEM Q1,.CMIOJ+SBK	;Setup I/O jfns
	HLRZM Q1,TAKJFN		;and stash this jfn
	RET

$TAKE:	TABLE
	T Echo,1
	T Noecho,0
	TEND

;"Rename <from> <to>"

.RENAM:	NOISE <file>
	MOVEI T1,[FLDBK. .CMFLD,CM%SDH,,<foreign filename>,,<[
		    BRMSK. FLDB0.,FLDB1.,FLDB2.,FLDB3.,< !%*,.:;<>?[]>]>]
	PARSE CMERRX
	MOVX T2,<ATMBUF,,FRNPTH>
	BLT T2,FRNPTH+ATMBLN-1
	NOISE <to be>
	MOVEI T1,[FLDBK. .CMFLD,CM%SDH,,<foreign filename>,,<[
		    BRMSK. FLDB0.,FLDB1.,FLDB2.,FLDB3.,< !%*,.:;<>?[]>]>]
	PARSE CMERRX
	MOVX T2,<ATMBUF,,FRNPT2>
	BLT T2,FRNPT2+ATMBLN-1
	CONFRM
	HRROI T1,FRNPTH		;Old name
	HRROI T2,[ASCIZ /RNFR /] ;First command
	CALL TELCFM
	 JRST RENBAD		;Error...
	HRROI T1,FRNPT2
	HRROI T2,[ASCIZ /RNTO /]
	CALL TELCFM
	 TRN
RENBAD:	RET


;"Debug" (remote server)

.DEBUG:	NOISE <remote server>
	CONFRM
	SETOM F.DBUG		;Say debugging...
	JRST DODBU1		;And go into debug mode

;DODBUG - Called from interrupt level (beware)

DODBUG:	TXNE F,F%INDB		;Already in "debugger"
	RET			;Yes - don't re-enter
	ADJSP P,20		;Reserve some stack space for AC's
	MOVEM 0,-16(P)		;Save AC0
	MOVEI 0,-15(P)		;Where to put AC1
	HRLI 0,1		;Start with AC1
	BLT 0,0(P)		;Save AC 1-16
	CALL DODBU1		;Do the work
	HRLI 0,-15(P)		;Get address of saved AC1
	HRRI 0,1		;Start with AC1
	BLT 0,16		;Restore ACs (including SP)
	MOVE 0,-16(P)
	ADJSP P,-20
	RET			;Done

DODBU1:	TXO F,F%INDB		;Say in "debugger"
	CALL CRIF		;Print CRLF if needed
	TCMSG <[Starting debug - type ^Z to terminate]>
	DO.
	  MOVEI T1,.PRIOU
	  BIN%			;Read char
	  CAIN T2,^D26		;Control-Z?
	  EXIT.			;Yes - done with debug
	  MOVE T1,TELJFN	;TELNET jfn...
	  $BOUT
	  MOVX T2,.MOSND	;Push...
	  $MTOPR
	  LOOP.
	ENDDO.
	SETZM F.DBUG		;No longer debugging...
	TXZ F,F%INDB		;No longer in debugger...
	CALL CRIF
	TCMSG <[End of debug]>
	RET

;"Delete <foriegn-file>"

.DELET:	NOISE <foreign file>
	MOVEI T1,[FLDDB. .CMTXT,CM%SDH,,<foreign filename>]
	PARSE CMERRX
	MOVX T2,<ATMBUF,,FRNPTH>
	BLT T2,FRNPTH+ATMBLN-1
	CONFRM
	HRROI T1,FRNPTH
	HRROI T2,[ASCIZ /DELE /]
	CALL TELCFM
	 TRN
	RET

;"Quote <cmd-string>"

.QUOTE:	NOISE <command>
	MOVEI T1,[FLDDB. .CMTXT,CM%SDH,,<foreign server command>]
	PARSE CMERRX
	MOVX T2,<ATMBUF,,FRNPTH>
	BLT T2,FRNPTH+ATMBLN-1
	CONFRM
	HRROI T1,FRNPTH		;Data is what was in user typein
	HRROI T2,[0]		;No keyword.
	CALL TELCFX		;Send & await multiple replies
	 TRN
	RET

;"Cpath <foriegn directory>" - also CD,CONNECT,CWD

.CPATH:	NOISE <to>
	MOVEI T1,[FLDDB. .CMTXT,CM%SDH,,<foreign directory string>]
	PARSE CMERRX
	MOVX T2,<ATMBUF,,FRNPTH>
	BLT T2,FRNPTH+ATMBLN-1
	CONFRM
	MOVX T1,<RC%TTX>	;Force the reply to be printed...
	IORM T1,CPRSP1		;This one...
	IORM T1,CPRSP2		;And this one
	HRROI T1,FRNPTH		;The argument
	HRROI T2,[ASCIZ /CWD /] ;The telnet command
	CALL TELCFM		;Send it
	 TRN
	MOVX T1,<RC%TTX>	;Fix up the flags...
	ANDCAM T1,CPRSP1	;This one...
	ANDCAM T1,CPRSP2	;And this one
	RET

	SUBTTL Connect command, and friends

.CONNE:	NOISE <to host>
	MOVEI T1,[FLDBK. .CMFLD,,,Internet host name,,HNMBRK]
	PARSE CMERRX
CNCT1:	MOVE T2,[ATMBUF,,HOSTBF]
	BLT T2,HOSTBF+ATMBLN-1	;Copy host name to safe place
	CONFRM			;Confirm
	AOS T1,TIMEX		;Get time randomizing factor & increment it
	DPB T1,[POINT 8,ICPPRT,35] ;Put 8-bits worth of time as low bytes
	MOVE T1,JOBNO		;Job number is first byte
	DPB T1,[POINT 8,ICPPRT,27] ;Use it as first byte of socket number
	GETNUM HOSTBF		;Translate name to number
	IFNSK.			;Failed...
	  CALL NUMHST		;See if a number was input
	ANNSK.			;Nope. He loses
	  CALL CRIF
	  TMSG <?Unknown host - ">
	  HRROI T1,HOSTBF
	  PSOUT%
	  TCMSG <">
	  RET
	ENDIF.
	MOVEM T3,FRNHST		;Save foriegn host number
	GETNAME HSTPMT		;Get primary name to prompt string
	IFSKP.			;OK
	  MOVEI T1,">"		;End the prompt
	  IDPB T1,T2
	  SETZ T1,		;And add a null
	  IDPB T1,T2
	ELSE.			;Failed?
	  MOVE T2,[ASCIZ/FTP!/]	;Use something distinctive
	  MOVEM T2,HSTPMT	; as the connected prompt
	  SETZ T4,		;Host status unknown
	ENDIF.
	ANDX T4,HS%STY		;Only want host type
	MOVEM T4,FRNOPS		;Save it
	MOVEM T4,FRNOPH		;And here
CNCT2:	SETZM PRT227		;Nuke any "PORT" setting
	SETOM REPINT		;Say we want interrupts
	SETZM REPOK		;No reply in yet
	SETZM F.ABRT		;No aborts yet
	CALL DOICP		;Open the telnet connections
	IFNSK.			;Failed
	  SETOM FRNHST		;No current foreign host
	  RET			;And quit
	ENDIF.
	TMSG <Connection opened >
	CALL TYPDFL		;Set type defaults
	SETZM PARAM3		;and clear previous transfer paramaters
	MOVX T1,<PARAM3,,PARAM3+1>
	BLT T1,PARAM3+P.SIZE-1
	CALL MAKFRK		;Create TELNET receiver
	IFNSK.			;Failed
	  ECMSG <Can't create forks to handle telnet connections.>
	  JRST CMERRX
	ENDIF.
	MOVEM P5,RFORKH		;One for telnet receive
	MOVE T1,RFORKH		;Receiver handle
	MOVEI T2,RFRKSA		;And starting address
	SFORK%			;Start it.
	MOVE T2,TIMVAL
	SKIPE REPOK		;Got response already?
	IFSKP.			;No.
	  MOVEI T1,^D10000	;Time to wait
	  DO.
	    DISMS%		;Wait
	    SKIPE REPOK		;Reply in yet?
	     EXIT.		;Yes.
	    SOJGE T2,TOP.	;Until done
	    ECMSG <Timeout waiting for ICP confirmation>
	    RET
	  ENDDO.
	ENDIF.
	TXO F,F%OPEN		;Flag it as open
	MOVX T2,CM%WKF		;Connect done, but no login yet - need CM%WKF
	IORM T2,SBK+.CMFLG	;Set it
	SKIPN DFLTAB		;Any defaults?
	 RET			;Nope
	GETNAME ATMBUF,FRNHST	;Get name of this host
	 RET			;Failed. Punt
	MOVEI T1,DFLTAB
	HRROI T2,ATMBUF
	TBLUK%			;Have a default for this host?
	IFXN. T2,TL%EXM		;TBLUK% succeeded?
	  HRRZ T3,(T1)
	  TMSG <[Attempting to log in as >
	  MOVE T1,D.USER(T3)
	  PSOUT%
	  TCMSG <]>
	  MOVE T1,D.USER(T3)	;Get ptr to user
	  SKIPE T2,D.PASS(T3)	;Have a password?
	  IFSKP.		;Nope - use user & ask for password
	    MOVEM T1,PUSER	;Save the user
	    SETZM PPASS
	    SKIPN T1,D.ACCT(T3)	;Any account?
	     SETZ T1,
	    MOVEM T1,PACCT
	    JRST PRSPWD		;And go parse the password
	  ELSE.			;Yes...
	    HRROI T2,[ASCIZ /USER /]
	    CALL TELCFM		;Send user
	     RET		;Failed
	    MOVE T1,D.PASS(T3)
	    HRROI T2,[ASCIZ /PASS /]
	    CALL TELCFM		;And password
	     RET		;Failed
	    SKIPN T1,D.ACCT(T3)	;Any account?
	     RET
	    HRROI T2,[ASCIZ /ACCT /]
	    CALL TELCFM
	     TRN
	    RET
	  ENDIF.
	ELSE.
	  RET
	ENDIF.

;Routine to initialize types. Q1 has 

TYPINI:	MVI. "A",P.TYPE+PARAMS	;ASCII is default type
	MVI. "N",P.TYP2+PARAMS	;Subtype is non-print
	MVI. "F",P.STRU+PARAMS	;File structure
	MVI. "S",P.MODE+PARAMS	;Stream mode
	RET

;Routine to set initial transfer mode defaults according to OS type.

TYPDFL:	CALL TYPINI		;(Re)Initialize them first
	MOVE T1,FRNOPS
	MOVEI T2,^D8		;Assume 8-bit byte size
	CAIE T1,.HS10X		;A tenex?
	CAIN T1,.HST20		; or TOPS-20?
	IFNSK.			;Yes
	  MVI. "P",P.STRU+PARAMS ;Do PAGED
	  MOVEI T2,^D36		;and 36-bits
	ENDIF.
	CAIE T1,.HSITS		;Also for ITS
	CAIN T1,.HSDEC		; and TOPS-10
	MOVEI T2,^D36
	MOVEM T2,P.BYTE+PARAMS	;Stash the answer
	MOVEI T3,"L"		;And logical-byte mode if 36-bit.
	CAIN T2,^D36
	MOVEM T3,P.TYPE+PARAMS
	MOVE T1,[POINT 7,STRTMP] ;Temporary area
	MOVEI Q1,PARAMS		;Point to primary params
	CALL GETTYP		;Make type string
	TMSG <[Assuming TYPE >
	HRROI T1,STRTMP
	PSOUT%
	TMSG <, MODE >
	MOVE T1,P.MODE+PARAMS
	PBOUT%
	TMSG <, STRU >
	MOVE T1,P.STRU+PARAMS
	PBOUT%
	TCMSG <]>
	RET

;Routine to setup string for TYPE command
;Accepts: T1/ Byte pointer to string
;	  Q1/ pointer to appropriate PARAMS

GETTYP:	SKIPN T3,P.TYPE(Q1)	;Type given
	 MOVEI T3,"A"		;Default is ASCII
	MOVEM T3,P.TYPE(Q1)	;Fix it
	IDPB T3,T1		;Put it in the buffer
	CAIE T3,"L"		;Specifying byte size?
	IFSKP.
	  MOVEI T2," "
	  IDPB T2,T1
	  MOVE T2,P.BYTE(Q1)	;Get the size
	  MOVEI T3,^D10
	  NOUT%			;Append on to the string
	   TRN
	ELSE.
	  SKIPN T3,P.TYP2(Q1)	;Any subtype?
	  IFSKP.
	    MOVEI T2," "
	    IDPB T2,T1
	    IDPB T3,T1
	  ENDIF.
	ENDIF.
	SETZ T2,
	IDPB T2,T1		;Terminate the string correctly
	RET

; Routine to try and convert already parsed input into an internet address.
; Called with HOSTBF containing the string to be converted.
; Returns:    +1 if string cannot syntactically be an IP address
;	      +2 Success, number in T3 
; Clobbers T1-T4 

NUMHST:	HRROI T1,HOSTBF		;Point to object string
	PUSH P,Q1		;Save Q1 
	HRLZI T4,-4		;Init count of dotted decimal fields
	SETZ Q1,		;Init address accumulator
	MOVEI T3,^D10		;Init radix to decimal

NUMDEC:	NIN			;Read a number
	 ERJMP NUMBAD		;No number at all
	CAIL T2,0		;Got one, check range for 8-bit IP field
	 CAILE T2,^D255		;...
	  JRST NUMOCT		;Nope, try it as straight octal address
	LSH Q1,^D8		;Shift accumulator
	ADD Q1,T2		; and add this component
	AOBJN T4,NUMDEC		;Loop for four of them

	SKIPG T3,Q1		;Should have a good number
	 JRST NUMBAD		; unless we got all zeroes

NUMGUD:	AOS -1(P)		;All ok, skip return
NUMBAD:	POP P,Q1		;Restore Q1 
	RET			;Return

NUMOCT:	JUMPL T2,NUMBAD		;Don't try if negative
	TRNE T4,-1		; or if first part looked like decimal
	 JRST NUMBAD		;...
	HRROI T1,HOSTBF		;OK, start over at beginning
	MOVEI T3,^D8		;Octal this time
	NIN			;Read it
	 ERJMP NUMBAD		;No such luck
	SKIPL T3,T2		;Make sure bigger than zero
	 CAML T3,[40000,,0]	; and smaller than 33 bits
	  JRST NUMBAD		;Nope, loser
	JRST NUMGUD		;The guy just likes to type long numbers

; Routine for opening doing ICP on TELNET connection

DOICP:	CALL SETLCH		;Setup local host & port info
	SETOM TELJFN		;Telnet JFN not yet assigned
	SETZM TELCON		;Zero it, first
	MOVX T1,<TELCON,,TELCON+1>
	BLT T1,TELRBF		;Clear it out
	MOVEI T1,TELCON+T.CDB	;Base address of CDB
	MOVE T2,LHSNM2		;Use "best" local host number
	MOVEM T2,.TCPLH(T1)
	MOVE T2,ICPPRT		;Local port number for ICP
	MOVEM T2,.TCPLP(T1)	;Set local port
	MOVE T2,FRNHST		;Foriegn host number
	MOVEM T2,.TCPFH(T1)	;Set it
	MOVE T2,FTPICS		;FTP port
	MOVEM T2,.TCPFP(T1)	;Set it
	MOVX T1,.FHSLF
	SETZ T2,
	SETER%			;Clear process error code
	MOVEI T1,TELCON		;Address of connection block
	MOVX T2,<-T.NDBF,,TELRBF> ;Buffer location
	MOVX T3,<T.BFSZ>	;And size
	TXO T3,<TCP%FS>		;Force sync
	$GTJFN			;Attempt to open connection
	IFSKP.
	  MOVEM T1,TELJFN	;Save TELNET jfn
	  MOVX T2,FLD(^D8,OF%BSZ)!FLD(7,OF%MOD)!OF%WR!OF%RD
	  $OPENF
	  IFSKP.
	    SKIPN F.VBOS	;Verbose?
	    RETSKP		;Nope
	    TMSG <[Opened TELNET connection as >
	    MOVEI T1,.PRIOU
	    MOVE T2,LHSNM2
	    MOVEI T3,"."
	    CALL GHSTNM
	    TCMSG <]>
	    RETSKP			    
	  ENDIF.
	ENDIF.
TSYNER:	MOVX T1,.FHSLF		;Handle
	GETER%			;Get last process erorr
	HRRZS T2		;Isolate it
	CAIG T2,600000		;Is it really an error code?
	IFSKP.			;Yes
	  EMSG <Connect failed - >
	  MOVX T1,.PRIOU
	  HRLI T2,.FHSLF
	  SETZ T3,
	  ERSTR%		;Print the error message
	   TRNA
	   TRN
	  TCRLF
	ELSE.
	  ECMSG <Error or timeout synchronizing TELNET connection>
	ENDIF.
	CLOSD TELJFN,CZ%ABT	;Abort/close TELNET connection
	RET

;Routine to setup "best" local host number & initialize PORT string.

SETLCH:	SKIPE LHSFLG		;Forcing the issue?
	IFSKP.			;Nope
	  MOVX T1,.GTHLN	;Want host number of this host on a network
	  MOVE T2,FRNHST	;For this foriegn host
	  GTHST%		;Get my host number on his network...
	ENDIF.
	MOVE T2,LHSNUM		;Not on same network, or forcing issue
SETLC1:	MOVEM T2,LHSNM2		;Setup local host number to use
	HRROI T1,PRTSTR		;Where to put host number prefix on port num
	MOVEI T3,","		;Filler character
	CALL GHSTNM		;Translate it
	SETZ T2,		;Make sure it's ASCIZ
	IDPB T2,T1
	RET

;GHSTNM - Translate host number into ascii string of octet numbers
;Accepts: T1/ destination designator
;	  T2/ host number
;	  T3/ filler byte

GHSTNM:	STKVAR <HNUM,BYT>
	MOVEM T2,HNUM
	MOVEM T3,BYT
	LDB T2,[POINT 8,HNUM,^D11] ;Print octets
	MOVEI T3,^D10
	NOUT%
	 TRN
	MOVE T2,BYT
	BOUT%
	LDB T2,[POINT 8,HNUM,^D19]
	NOUT%
	 TRN
	MOVE T2,BYT
	BOUT%
	LDB T2,[POINT 8,HNUM,^D27]
	NOUT%
	 TRN
	MOVE T2,BYT
	BOUT%
	LDB T2,[POINT 8,LHSNM2,^D35]
	NOUT%
	 TRN
	RET
	ENDSV.

	SUBTTL Login command and friends

;"Login <user> <password> <account>"

.LOGIN:	NOISE <user>
	MOVEI T1,[FLDBK. .CMFLD,CM%SDH,,<foreign user string>,,REMBRK]
	PARSE CMERRX
	MOVE T2,[ATMBUF,,USERBF]
	BLT T2,USERBF+ATMBLN-1
	HRROI T2,USERBF
	MOVEM T2,PUSER
	CALL PWORD		;Try to get a password
	 JRST [	MOVX T1,.PRIIN	;None - clear input & prompt for password
		CFIBF%
		JRST PRSPWD]
	NOISE <account>
	MOVEI T1,[FLDDB. .CMCFM,,,,,<[
		  FLDBK. .CMFLD,CM%SDH,,<foreign account string>,,REMBRK]>]
	PARSE CMERRX
	LOAD T4,CM%FNC,.CMFNP(T3)
	CAIN T4,.CMCFM
	JRST PRSPWD
	MOVX T2,<ATMBUF,,ACCTBF>
	BLT T2,ACCTBF+ATMBLN-1
	CONFRM
	HRROI T2,ACCTBF
	MOVEM T2,PACCT
PRSPWD:	
	SKIPN T1,PUSER		;Any user?
	 JRST LOGINZ		;No - punt
	HRROI T2,[ASCIZ /USER /];Send USER command
	CALL TELSND
	SETOM REPINT		;Indicate that we want interrupts
	SKIPN T1,PACCT		;Have an account?
	 JRST LOGIN2		;Nope - procede
LOGIN0:	HRROI T2,[ASCIZ /ACCT /];And ACCT command
LOGIN1:	CALL TELSND
LOGINA:	SKIPN REPOK		;Reply in early?
LOGIN2:	 WAIT%			;Wait for a TELNET reply...
	MOVE T1,REPCOD		;Get reply code set by TELNET fork
	CAIN T1,^D230		;Login OK response
	 JRST LOGINY		;Yes - done & flag
	CAIE T1,^D530		;Password incorrect?
	IFSKP.			;Yes
	  SETZM PPASS		;Clear password pointer
	  SETZM PASSBF		;Make sure
	  JRST LOGINZ		;And do abort
	ENDIF.
	CAIL T1,ABTCOD		;An abort?
	 JRST LOGINZ		;Done, then
	CAIE T1,^D332		;Wants account string?
	IFSKP.
	  SKIPE T1,PACCT	;Have an account?
	   JRST LOGIN2		;Sent it already - ignore late reply
	  HRROI T1,[ASCIZ/Account: /]
	  CALL DPROMP		;Set the prompt
	  MOVEI T1,[FLDBK. .CMFLD,CM%SDH,,<foriegn account string>,,REMBRK]
	  PARSE CMERRX		;Read it
	  MOVX T2,<ATMBUF,,ACCTBF>
	  BLT T2,ACCTBF+ATMBLN-1 ;Save it
	  CONFRM		;Confirm it
	  MVI. CMDBGN,CMDDSP	;Fix command state block again
	  HRROI T1,ACCTBF
	  MOVEM T1,PACCT
	  JRST LOGIN0		;Go send the account string
	ELSE.
	  CAIE T1,^D331		;Wants a password?
	  JRST LOGIN2		;No - Something random - ignore it
	  SKIPE T1,PPASS	;Do we have one?
	  IFSKP.		;No, get it
	    DO.
	      HRROI T1,PWDPMT	;Password prompt
	      CALL DPROMP	;Set things up...
	      CALL PWORD	;Read a password
	       LOOP.
	      CONFRM
	      MVI. CMDBGN,CMDDSP ;Fix command state block
	      MOVE T1,PPASS	;Get password pointer
	    ENDDO.
	  ENDIF.
	  HRROI T2,[ASCIZ /PASS /]
	  SKIPN F.VBOS		;Worry about typing out pword?
	  JRST LOGIN1		;No - just go send it
	  SETZM F.VBOS		;Yes, be quiet for this
	  CALL TELSND
	  CMSG <Sending password...> ;Just type something safe
	  SETOM F.VBOS		;Back to noisy
	  JRST LOGINA		;Go get response
	ENDIF.
LOGINY:	MOVX T2,CM%WKF		;Login done, so don't need wakeup any more
	ANDCAM T2,SBK+.CMFLG	; so get rid of it now
LOGINZ:	SETZM REPINT
	RET

;"Account" - send ACCT command to remote system

.ACCOU:	NOISE <for foreign host>
	MOVEI T1,[FLDBK. .CMFLD,CM%SDH,,<foreign account string>,,REMBRK]
	PARSE CMERRX
	MOVX T2,<ATMBUF,,ACCTBF>
	BLT T2,ACCTBF+ATMBLN-1
	CONFRM
	HRROI T1,ACCTBF		;Update account pointer
	MOVEM T1,PACCT		;In case needed later
	HRROI T2,[ASCIZ /ACCT /] ;Send the ftp command
	CALL TELCFM
	 TRN
	RET

;"Password" - send PASS command to remote system

.PASSW:	CALL PWORD		;Get password
	LOAD T4,CM%FNC,.CMFNP(T3)
	CAIE T4,.CMCFM		;Only got a confirm?
	IFSKP.
	  HRROI T1,PWDPMT	;Yes, prompt for pword
	  CALL DPROMP		;...
	  CALL PWORD		;Try getting it again
	  MOVEI T1,CMDBGN	;Fix cmd state blk
	  MOVEM T1,CMDDSP	;...
	ENDIF.
	CONFRM			;Parse last confirm
	PUSH P,F.VBOS		;Save verbose flag
	SKIPN F.VBOS		;Are we verbose?
	IFSKP.
	  SETZM F.VBOS		;Clear verbose state
	  CMSG <Sending password...> ;Say something here
	ENDIF.
	MOVE T1,PPASS
	HRROI T2,[ASCIZ /PASS /] ;Send the ftp command
	CALL TELCFM
	 TRN
	POP P,F.VBOS		;Restore verbose state
	RET

;Routine to attempt to get a password. Parses either a CR (confirm) or a
;password string.
;Returns +1/ Confirm seen first
;	 +2/ Password parsed, but not confirmed yet

PWORD:	SETZM PASSBF		;Clear out first word
	MOVX T1,.CTTRM
	RFMOD%			;Kill echoing for password
	SETOM HDXFLG		;Say we did this
	TXZ T2,TT%ECO!TT%ECM	;..
	SFMOD%
	TXNE T2,FLD(.TTLDX,TT%DUM) ;Fullduplex?
	SKIPE BATFLG		;Or a batch job?
	TRNA			;Then don't do halfduplex password stuff
	JRST PWORD1
	MOVE T1,REPARA		;Get reparse addr
	MOVEM T1,PWDTRP		;Save it
	HRRI T1,PWDRPS		;Special password reparse addr
	MOVEM T1,REPARA		;Use it
	NOISE <password>
	MOVEI T1,[FLDDB. .CMCFM,,,,,<[
		  FLDBK. .CMFLD,CM%SDH,,<foreign password string>,,REMBRK]>]
	PARSE CMERRX
	SETZM PPASS		;Assume none
	LOAD T4,CM%FNC,.CMFNP(T3)
	CALL CRIF		;Do crlf if needed (since no echo)
	CAIN T4,.CMCFM		;Just a confirm?
	IFSKP.			;Nope.
	  AOS (P)		;Setup for skip return
	  MOVX T2,<ATMBUF,,PASSBF> ;And copy password buffer
	  BLT T2,PASSBF+ATMBLN-1
	  HRROI T2,PASSBF
	  MOVEM T2,PPASS
	ENDIF.
	MOVE T1,PWDTRP		;Get back orig reparse addr
	MOVEM T1,REPARA		;Restore it
	JRST PWORD2

PWDERR:	TDZA CX,CX		;Repars comes here if error
PWDRPS:	SETO CX,		;Indicate normal entry
	PUSH P,CX		;Save flag
	PUSH P,T1		;Save ACs
	PUSH P,T2		;...
	CALL PWORD2		;Turn echoes back on
	MOVE T1,PWDTRP		;Get saved reparse addr
	MOVEM T1,REPARA		;Put it back
	POP P,T2		;Restore ACs
	POP P,T1		;...
	POP P,CX		;Get flag
	SKIPN CX		;Skip if normal
	 SOS REPARA		;Error, need this for reprompt
	JRST B,@REPARA		;Back to parse place

PWORD1:	CALL CRIF
	HRROI T1,PMASK		;Password mask
	PSOUT%			;Type mask
	MOVE T3,[POINT 7,PASSBF]
	DO.
	  PBIN%			;Get a character
	  CAIE T1,.CHTAB	;Whitespace?
	  CAIN T1," "		;...
	  LOOP.			;Skip it
	ENDDO.
	CAIE T1,.CHLFD		;LF
	CAIN T1,.CHCRT		;or CR by itself?
	 JRST PEND1		;Yes - no password, then
	DO.
	  CAIE T1,.CHDEL	;Is it a del?
	  CAIGE T1," "		;Space or control?
	  EXIT.			;Those are the breaks (pardon the pun...)
	  IDPB T1,T3
	  PBIN%			;Get another character
	  LOOP.
	ENDDO.
	SETZ T1,
	IDPB T1,T3
	SKIPE PASSBF		;Did we end up parsing anything?
	AOS (P)			;Yes - skip return
PEND:	HRROI T1,PASSBF
	MOVEM T1,PPASS
	HRROI T1,PMASK2
	PSOUT%
PEND1:;	MOVX T1,.PRIIN
;	CFIBF%
	BKJFN%			;Stuff break character back
	 ERJMP .+1
PWORD2:	MOVEI T1,.CTTRM
	RFMOD%
	TXO T2,TT%ECO		;Echoing back on
	SFMOD%
	SETZM HDXFLG		;No longer HDX
	RET

	SUBTTL INFORMATION commmand and subcommands


;Dispatch from main command table

.INFOR:	NOISE <about>
	MOVEI T1,[FLDDB. .CMKEY,,$INFO]
	PARSE CMERRX		;Get the option
	HRRZ T2,(T2)		;Get dispatch
	CALLRET (T2)		;Process it

;"Information All" command

.IALL:	CONFRM
	CALL IVER1		;Print version
	CALL ISWIT1		;Print switches
	CALL ITRAN1		;Print transfer parameters
	SKIPE DFLTAB		;Any defaults?
	 CALL IDEFA1		;Print defaults for hosts
	TXNE F,F%OPEN		;If connection open...
	 CALL STATU1		;Print host status
	RET


;"Information Version" command

.IVER:	CONFRM
IVER1:	TMSG < >		;Make this look right...
VERPNT: HRROI T1,LHSNAM		;Local host name
	PSOUT%			;Print it
	TMSG < FTP user process >
	MOVX T1,.PRIOU		;Type version to primary output
	LOAD T2,VI%MAJ,VERSIO	;Get major version
	IFN. T2			;If it exists
	  MOVX T3,FLD(^D8,NO%RDX) ;Type it in octal
	  NOUT%			;...
	   TRN
	ENDIF.
	LOAD T2,VI%MIN,VERSIO	;Get minor version
	IFN. T2			;If non-zero
	  SOS T2		;Subtract 1
	  IDIVI T2,^D26		;Make 2 letters
	  IFN. T2		;Any first letter?
	    MOVEI T2,"A"-1(T2)	;Yes, print
	    BOUT%		;...
	  ENDIF.
	  MOVEI T2,"A"(T3)	;Print second letter
	  BOUT%
	ENDIF.
	LOAD T2,VI%EDN,VERSIO	;Get edit number
	IFN. T2
	  PUSH P,T2
	  MOVEI T2,"("		;Print open paren
	  BOUT%
	  POP P,T2
	  MOVX T3,FLD(^D8,NO%RDX) ;Octal numbers
	  NOUT%			;Print it
	   TRN
	  MOVEI T2,")"		;Print close paren
	  BOUT%
	ENDIF.
	LOAD T2,VI%WHO,VERSIO	;Get group code
	IFN. T2			;Skip if zero
	  PUSH P,T2
	  MOVEI T2,"-"		;Print -
	  BOUT%
	  POP P,T2
	  MOVX T3,FLD(^D8,NO%RDX) ;Octal numbers
	  NOUT%
	   TRN
	ENDIF.
	TCMSG <>
	RET

;"Information Defaults"

.IDEFA:	SKIPE DFLTAB
	IFSKP.
	  CALL CRIF
	  TCMSG <%No defaults set.>
	  RET
	ENDIF.
	NOISE <defaults for host>
	MOVEI T1,[FLDDB. .CMKEY,,DFLTAB,<host name,>,,<[
		  FLDDB. .CMCFM,,,<to list all defaults,>]>]
	PARSE CMERRX
	LOAD T4,CM%FNC,.CMFNP(T3) ;Get field type used
	CAIN T4,.CMCFM		;Confirm
	IFSKP.			;Nope - have host
	  CONFRM	
	  CALLRET IDEFHS
	ENDIF.
IDEFA1:	HLLZ Q1,DFLTAB
	MOVNS Q1
	HRRI Q1,DFLTAB+1
IDEFLP:	MOVEI T2,(Q1)
	CALL IDEFHS
	AOBJN Q1,IDEFLP
	RET

IDEFHS:	TMSG < Set Default >
	HLRO T1,(T2)		;Get LH of entry - ptr to host name
	PSOUT%
	HRRZ T3,(T2)		;Get RH of entry - ptr to default block
	TMSG < /User:>
	MOVE T1,D.USER(T3)
	PSOUT%
	SKIPN D.ACCT(T3)
	IFSKP.
	  TMSG < /Account:>
	  MOVE T1,D.ACCT(T3)
	  PSOUT%
	ENDIF.
	SKIPN D.PASS(T3)
	IFSKP.
	  TMSG < /Password:>
	  MOVE T1,D.PASS(T3)
	  PSOUT%
	ENDIF.
	TCRLF
	RET

;"Information switches"

DEFINE HRRX1(MSG) <
	HRROI T1,[ASCIZ/MSG
/]>

.ISWIT:	CONFRM
ISWIT1:	SKIPN LHSFLG		;Do we have an address set up?
	IFSKP.
	  TMSG < Set Address >
	  MOVEI T1,.PRIOU
	  MOVE T2,LHSNUM
	  MOVEI T3,"."
	  CALL GHSTNM		;Print the host number we have set
	  TCRLF
	ENDIF.
	HRRX1 < Set Allow (errors in TAKE files)>
	TXNE F,F%TALL
	 PSOUT%
	HRRX1 < Set CRLF-munging (for UNIX text files)>
	TXNE F,F%CRLF
	 PSOUT%
	HRRX1 < Set Echo (during TAKE files)>
	TXNE F,F%TECH
	 PSOUT%
	HRRX1 < Set Hash-marks (for timing)>
	TXNE F,F%HASH
	 PSOUT%	
	IFXN. F,F%NPRT		;Not doing port negotiation at all?
	  TCMSG < Set No Port (negotiation)>
	ELSE.
	  SKIPN USRPRT		;Have a user-selected port to use?
	  IFSKP.		;Yes
	    TMSG < Set Port >
	    MOVEI T1,.PRIOU
	    LDB T2,[POINT 8,USRPRT,^D27]
	    MOVEI T3,^D10
	    NOUT%
	     TRN
	    MOVEI T2,"."
	    BOUT%
	    LDB T2,[POINT 8,USRPRT,^D35]
	    NOUT%
	     TRN
	    TCRLF
	  ENDIF.
	ENDIF.
	HRRX1 < Set Retain (generation numbers)>
	TXNE F,F%RTAN
	 PSOUT%
	HRRX1 < Set Statistics>
	TXNE F,F%STAT
	 PSOUT%
	MOVE T2,TIMVAL
	CAIN T2,DEFTMV
	IFSKP.
	  TMSG < Set Timeout >
	  MOVEI T1,.PRIOU
	  MOVEI T3,^D10
	  NOUT%
	   TRN
	  TCMSG < (second(s)>
 	ENDIF.
	HRRX1 < Set Verbose>
	SKIPE F.VBOS
	 PSOUT%
	RET

;"Information Transfer-parameters"

.ITRAN:	CONFRM
ITRAN1:	TMSG < Set Opsys >
	MOVE T1,FRNOPS		;Get current value
	LSH T1,-9
	CAIG T1,OPLMAX		;Too big?
	 SKIPN OPSLST(T1)	;Or no string?
	  SETZ T1,		;No. Use Zero
	HRRO T1,OPSLST(T1)
	PSOUT%
	TCRLF
	MOVE T2,P.TYPE+PARAMS
	TMSG < Set Type >
	HRROI T1,[ASCIZ/Image/]
	CAIN T2,"A"		;Ascii?
	 HRROI T1,[ASCIZ/Ascii/]
	CAIN T2,"E"
	 HRROI T1,[ASCIZ/Ebcdic/]
	CAIN T2,"L"
	 HRROI T1,[ASCIZ/Local-size /]
	PSOUT%
	CAIE T2,"L"
	IFSKP.
	  MOVEI T1,.PRIOU
	  MOVE T2,P.BYTE+PARAMS
	  MOVEI T3,^D10
	  NOUT%
	   TRN
	ELSE.
	  CAIN T2,"I"		;Image has no subtype
	ANSKP.
	  MOVEI T1," "
	  PBOUT%
	  MOVE T2,P.TYP2+PARAMS
	  HRROI T1,[ASCIZ/Non-print/]
	  CAIN T2,"T"
	   HRROI T1,[ASCIZ/Telnet-format/]
	  CAIN T2,"C"
	   HRROI T1,[ASCIZ/Carriage-control/]
	  PSOUT%
	ENDIF.
	TMSG <
 Set Structure >
	MOVE T2,P.STRU+PARAMS
	HRROI T1,[ASCIZ/File/]
	CAIN T2,"R"
	 HRROI T1,[ASCIZ/Record/]
	CAIN T2,"P"
	 HRROI T1,[ASCIZ/Paged/]
	PSOUT%
	TMSG <
 Set Mode >
	MOVE T2,P.MODE+PARAMS
	HRROI T1,[ASCIZ/Stream/]
	CAIN T2,"B"
	 HRROI T1,[ASCIZ/Block/]
	CAIN T2,"C"
	 HRROI T1,[ASCIZ/Compressed/]
	PSOUT%
	TCMSG <>
	RET


;"Status" and "Information Foriegn" command

IFHOST:	CONFRM
	TXNE F,F%OPEN		;Any connection open?
	 JRST STATU1		;Yes - go give info
	TCMSG <%No connection is open>
	RET

.STATU:	NOISE <of foreign host/files>
	MOVEI T1,[FLDDB. .CMCFM,CM%SDH,,<confirm for connection status>,,<[
		  FLDDB. .CMTXT,CM%SDH,,<optional data for host>]>]
	PARSE CMERRX
	LOAD T3,CM%FNC,.CMFNP(T3)
	CAIE T3,.CMCFM
	IFSKP.
STATU1:	  SETZM FRNPTH
	  HRROI T2,[ASCIZ /STAT/]
	ELSE.
	  MOVX T2,<ATMBUF,,FRNPTH>
	  BLT T2,FRNPTH+ATMBLN-1
	  CONFRM
	  HRROI T2,[ASCIZ /STAT /]
	ENDIF.
	HRROI T1,FRNPTH
	CALL TELCFX		;Read multiple replies
	 TRN			;Not interested in which return
	RET

	SUBTTL SET command and subcommands

;Dispatch from main command table

.SET:	TRVAR <SNOFLG>		;Set if "No" encountered
	SETZM SNOFLG		;"No" not encountered yet
	MOVEI T1,[FLDDB. .CMKEY,,$SET]
	PARSE CMERRX		;Get the option
	HRRZ T2,(T2)		;Get dispatch
	CALLRET (T2)		;Process it

;"Set No" option

.SETNO:	NOISE <option>
	MOVEI T1,[FLDDB. .CMKEY,,$SETNO]
	PARSE CMERRX
	SETOM SNOFLG		;Flip "No" flag
	HRRZ T2,(T2)		;Get dispatch
	CALLRET (T2)		;Do the command

;"Set Defaults"

SWITAB:	SWILEN,,SWILEN		;Command switches
	T Account:,.SDACT
	T Password:,.SDPWD
	T User:,.SDUSR
SWILEN==.-SWITAB-1

.DEFAU:	NOISE <for host>
	MOVEI T1,[FLDBK. .CMFLD,,,Internet host name,,HNMBRK]
	PARSE CMERRX
	GETNUM ATMBUF		;Get foriegn host number
	IFNSK.			;Failed...
	  CALL CRIF
	  TMSG <?Unknown host - ">
	  HRROI T1,ATMBUF	;Name parsed
	  PSOUT%
	  TCMSG <">
	  RET
	ENDIF.
	MOVE Q1,T3		;Save host number here
	SKIPE SNOFLG		;Is it "set no defaults"?
	 JRST CLRDEF		;Yes - go do it
	MOVEI T1,[FLDDB. .CMSWI,,SWITAB]
	PARSE CMERRX
	SETZM PUSER
	SETZM PACCT
	SETZM PPASS
	JRST DEFA1
INISET:	SETZM PUSER
	SETZM PACCT
	SETZM PPASS
	JRST DEFA2
DEFA1:	HRRZ T2,(T2)		;Get switch location
 	CALL (T2)		;Set the switch given
DEFA2:	MOVEI T1,[FLDDB. .CMSWI,,SWITAB,,,<[
		  FLDDB. .CMCFM]>]
	PARSE CMERRX
	LOAD T4,CM%FNC,.CMFNP(T3)
	CAIN T4,.CMSWI
	JRST DEFA1
	SKIPN PUSER
	JRST [	ECMSG <You must specify a user.>
		RET]
	GETNAME HOSTBF,Q1	;Translate host number to string
	 TRN			;Not interested in failure
	SKIPE DFLTAB		;Any defaults yet?
	IFSKP.			;Nope
	  MOVX T1,NHSTS-1	;Get max
	  MOVEM T1,DFLTAB	;Initialize table header
	  JRST DEFADD		;And go try and add
	ENDIF.
	MOVEI T1,DFLTAB		;Table address
	HRROI T2,HOSTBF		;Ptr to name
	TBLUK%
	IFXE. T2,TL%EXM		;Found in table?
DEFADD:	  MOVEI T1,ATMBLN	;Buffer size
	  CALL DALLOC		;Get a buffer
	  MOVE T2,T1
	  HRLI T1,HOSTBF	;From the host buffer
	  BLT T1,ATMBLN-1(T2)	;Blt it
	  MOVEI T1,DFLTAB	;Default table
	  MOVSS T2		;Addres in left half
	  HRRI T2,DFLBLK	;Base address of default blocks
	  ADD T2,DFLIDX		;Add the current index
	  TBADD%
	  HRRZ T3,T2		;Copy address of new block here
	  MOVEI T2,D.SIZE	;Size of the default block
	  ADDM T2,DFLIDX	;Bump index to next one
	  MOVEI T1,ATMBLN	;Buffer size
	  CALL DALLOC		;Get a buffer
	  MOVE T2,T1		;The destination
	  HRROM T1,D.USER(T3)	;Make pointer & save it
	  HRLI T1,USERBF	;Get the source
	  BLT T1,ATMBLN-1(T2)	;Blt it
	  SKIPN PACCT		;Account ?
	  IFSKP.
	    MOVEI T1,ATMBLN	;Buffer size
	    CALL DALLOC		;Get a buffer
	    MOVE T2,T1		;The destination
	    HRROM T1,D.ACCT(T3)	;Make pointer & save it
	    HRLI T1,ACCTBF		;Get the source
	    BLT T1,ATMBLN-1(T2)	;Blt it
	  ENDIF.
	  SKIPN PPASS		;Password ?
	   RET
	  MOVEI T1,ATMBLN	;Buffer size
	  CALL DALLOC		;Get a buffer
	  MOVE T2,T1		;The destination
	  HRROM T1,D.PASS(T3)	;Make and save the pointer
	  HRLI T1,PASSBF	;Get the source
	  BLT T1,ATMBLN-1(T2)	;Blt it
	  RET
	ELSE.			;Entry exists - replace it
	  HRRZ T3,(T1)		;Get index
	  MOVE T1,D.USER(T3)	;Get user address
	  MOVE T2,T1		;Copy into T2
	  HRLI T1,USERBF	;User buffer
	  BLT T1,ATMBLN-1(T2)	;Blt it
	  SKIPN PACCT		;Account ?
	  IFSKP.		;Yes
	    SKIPE T1,D.ACCT(T3)	;Get account
	    IFSKP.		;Null - allocate one
	      MOVEI T1,ATMBLN	;Buffer size
	      CALL DALLOC	;Get a buffer
	      HRROM T1,D.ACCT(T3) ;Save the pointer
	    ENDIF.
	    MOVE T2,T1		;Save for the blt
	    HRLI T1,ACCTBF	;Get the source
	    BLT T1,ATMBLN-1(T2)	;Blt it
	  ELSE.
	    SKIPN PPASS		;Password ?
	     RET
	    SKIPE T1,D.PASS(T3)	;Get password
	    IFSKP.		;None yet. Allocate it
	      MOVEI T1,ATMBLN	;Buffer size
	      CALL DALLOC	;Get a buffer
	      HRROM T1,D.PASS(T3) ;Save the pointer
	    ENDIF.
	    MOVE T2,T1		;Save for the blt
	    HRLI T1,PASSBF	;Get the source
	    BLT T1,ATMBLN-1(T2)	;Blt it
	    RET
	  ENDIF.
	ENDIF.

CLRDEF:	CONFRM
	SKIPN DFLTAB
	JRST [	CMSG <?There are no defaults set.>
		RET]
	GETNAME HOSTBF,Q1	;Get name string from number in Q1
	 TRN			;Ignore failure
	MOVEI T1,DFLTAB
	HRROI T2,HOSTBF
	TBLUK%
	IFXE. T2,TL%EXM		;Entry not there?
	  ECMSG <No defaults set for that host.>
	  RET
	ELSE.
	  HLRO T3,(T1)
	  MOVE T2,T1
	  MOVEI T1,DFLTAB
	  TBDEL%
	  HLRZ T1,DFLTAB
	  IFE. T1		;Last one?
	    SETZM DFLTAB
	    MVI. DSTOP,DFLADR	;Setup new pointer to free list
	  ENDIF.
	  CALL CRIF
	  TMSG <Defaults for >
	  MOVE T1,T3
	  PSOUT%
	  TCMSG < cleared.>
	  RET
	ENDIF.

.SDUSR:	MOVEI T1,[FLDBK. .CMFLD,CM%SDH,,<foreign user string>,,REMBRK]
	PARSE CMERRX
	MOVX T2,<ATMBUF,,USERBF>
	BLT T2,USERBF+ATMBLN-1
	SETOM PUSER
	RET

.SDACT:	MOVEI T1,[FLDBK. .CMFLD,CM%SDH,,<foreign account string>,,REMBRK]
	PARSE CMERRX
	MOVE T2,[ATMBUF,,ACCTBF]
	BLT T2,ACCTBF+ATMBLN-1
	SETOM PACCT
	RET

.SDPWD:	MOVEI T1,[FLDBK. .CMFLD,CM%SDH,,<foreign password string>,,REMBRK]
	PARSE CMERRX
	MOVE T2,[ATMBUF,,PASSBF]
	BLT T2,PASSBF+ATMBLN-1
	SETOM PPASS
	RET

.SECHO:	NOISE <during TAKE files>
	CONFRM
	SKIPN SNOFLG		;"No"?
	TXOA F,F%TECH
	TXZ F,F%TECH
	RET

.SALLO:	NOISE <errors during TAKE files>
	CONFRM
	SKIPN SNOFLG		;"No"?
	TXOA F,F%TALL
	TXZ F,F%TALL
	RET

.SSTAT:	NOISE <for transfers>
	CONFRM
	SKIPN SNOFLG		;Really "No"?
	TXOA F,F%STAT		;Enable hash marks
	TXZ F,F%STAT
	RET

OPSTAB:	OPSMAX,,OPSMAX
	[ASCIZ/ITS/],,.HSITS
	[ASCIZ/Tenex/],,.HS10X
	[ASCIZ/TOPS-10/],,.HSDEC
	[ASCIZ/TOPS-20/],,.HST20
	[ASCIZ/Unix/],,.HSUNX
	[ASCIZ/VMS/],,.HSVMS
OPSMAX==.-OPSTAB-1

DEFTAB(OPSLST,OSMAX)
   TABENT(0,[ASCIZ/Unknown/])
   TABENT($$<.HSITS>,[ASCIZ/ITS/])
   TABENT($$<.HS10X>,[ASCIZ/Tenex/])
   TABENT($$<.HSDEC>,[ASCIZ/TOPS-10/])
   TABENT($$<.HST20>,[ASCIZ/TOPS-20/])
   TABENT($$<.HSUNX>,[ASCIZ/Unix/])
   TABENT($$<.HSVMS>,[ASCIZ/VMS/])
DEFEND(OPLMAX)

.OPSYS:	NOISE <type for modes>
	SKIPN SNOFLG		;Turning off?
	IFSKP.			;Yes - reset to GTHST value
	  CONFRM
	  MOVE T2,FRNOPH	;Get original value
	  MOVEM T2,FRNOPS
	  TMSG <[OS type reset to >
	  LSH T1,-9		;Make an index
	  CAIG T1,OPLMAX	;Check range...
	  SKIPN OPSLST(T1)	;Is there a string for that one?
	  SETZ T1,		;No.
	  HRRO T1,OPSLST(T1)	;Get string
	  PSOUT%
	  TCMSG <]>
	ELSE.
	  MOVEI T1,[FLDDB. .CMKEY,,OPSTAB]
	  PARSE CMERRX		;Parse OS type
	  HRRZ T2,(T2)		;Get value
	  CONFRM		;Confirm it
	  MOVEM T2,FRNOPS	;Set it
	ENDIF.
	CALL TYPDFL		;Reset defaults
	RET

.VERBO:	NOISE <mode>
	CONFRM
	SETCM T1,SNOFLG
	MOVEM T1,F.VBOS
	RET

.RETAI:	NOISE <generation numbers>
	CONFRM
	SKIPN SNOFLG		;Really "No"?
	TXOA F,F%RTAN		;Enable hash marks
	TXZ F,F%RTAN
	RET

.HASH:	NOISE <for timing>
	CONFRM
	SKIPN SNOFLG		;Really "No"?
	TXOA F,F%HASH		;Enable hash marks
	TXZ F,F%HASH
	RET

.SCRLF:	NOISE <for UNIX text files>
	CONFRM
	SKIPN SNOFLG		;Really "no"?
	TXOA F,F%CRLF
	TXZ F,F%CRLF
	RET

TYPTAB:	TYPLEN,,TYPLEN
	T Ascii,"A"
	T Ebcdic,"E"
	T Image,"I"
	T Local-size,"L"
TYPLEN==.-TYPTAB-1

TY2TAB:	TY2LEN,,TY2LEN
	T Carriage-Control,"C"
	T Non-Print,"N"
	T TELNET-format,"T"
TY2LEN==.-TY2TAB-1

.STYPE:	SETZB Q1,Q2		;No types yet
	SETZ Q3,		;...
	MOVE P1,PARAMS+P.STRU	;Get structure
	MOVEI T1,[FLDDB. .CMCFM,,,,,<[
		  FLDDB. .CMKEY,,TYPTAB]>]
	PARSE CMERRX
	LOAD T3,CM%FNC,.CMFNP(T3)
	CAIN T3,.CMCFM
	 JRST ITRAN1		;Just wants info
	HRRZ Q1,(T2)		;Get char
	CAIE Q1,"L"		;Specifying byte size?
	IFSKP.
	  MOVEI T1,[FLDDB. .CMNUM,CM%SDH,^D10,<byte size>]
	  PARSE CMERRX		;Get the byte size
	  MOVE Q3,T2		;Keep it
	  CONFRM		;And confirm it
	ELSE.
	  CAIE Q1,"I"		;Image type?
	  IFSKP.		;Yes
	    MOVEI Q3,^D36	;And 36 bit size (look like L 36)
	    CONFRM
	  ELSE.			;Last possibility is ASCII
	    MOVEI Q3,^D8	;Make 8-bit byte size
	    MOVEI T1,[FLDDB. .CMCFM,,,,,<[
		      FLDDB. .CMKEY,,TY2TAB]>]
	    PARSE CMERRX
	    LOAD T3,CM%FNC,.CMFNP(T3)
	    CAIE T3,.CMKEY
	  ANSKP.
	    HRRZ Q2,(T2)	;Get char (subtype)
	    CONFRM
	  ENDIF.
	ENDIF.
	CAIE P1,"P"		;Do we have page structure set?
	IFSKP.			;Yes - make sure it is legal
	  CAIN Q1,"L"		;Must be logical...
	  CAIE Q3,^D36		;And must be bytesize 36
	  MOVEI P1,"F"		;Or else reset to file structure default
	ENDIF.
	MOVEM Q1,PARAMS+P.TYPE	;Set all to new values
	MOVEM Q2,PARAMS+P.TYP2
	MOVEM Q3,PARAMS+P.BYTE
	MOVEM P1,PARAMS+P.STRU
	RET

;"Set mode"

MODTAB:	MODLEN,,MODLEN
;	T Block,"B"		;Not supported
;	T Compressed,"C"	;Not supported
	T Stream,"S"
MODLEN==.-MODTAB-1

.MODE:	MOVEI T1,[FLDDB. .CMKEY,,MODTAB]
	PARSE CMERRX
	HRRZ Q1,(T2)		;Save the value
	CONFRM
	MOVEM Q1,PARAMS+P.MODE
	RET

;"Set Structure"

STRTAB:	STRLEN,,STRLEN
	T File,"F"
	T Page,"P"
;	T Record,"R"		;Not supported
STRLEN==.-STRTAB-1

.STRUC:	MOVEI T1,[FLDDB. .CMKEY,,STRTAB]
	PARSE CMERRX
	HRRZ Q1,(T2)
	CONFRM
	MOVEM Q1,PARAMS+P.STRU
	RET

;"Set Timeout"

.TIMEO:	NOISE <unit>
	MOVEI T1,[FLDDB. .CMNUM,CM%SDH!CM%DPP,^D10,<number of seconds>,1]
	PARSE CMERRX
	MOVE Q1,T2
	NOISE <seconds>
	CONFRM
	MOVEM Q1,TIMVAL
	RET

;"Set (no) Address"

.ADDRE:	NOISE <to use for all connections>
	SKIPE SNOFLG
	 JRST NOADDR
	MOVEI T1,[FLDDB. .CMNUM,CM%SDH,^D10,<1st byte of network/host>]
	PARSE CMERRX		;Get first byte
	MOVE Q1,T2		;Copy it
	MOVEI T1,[FLDDB. .CMTOK,,<POINT 7,[ASCIZ/./]>,,,<[
		  FLDDB. .CMCFM]>]
	PARSE CMERRX		;Separator or confirmation
	LOAD T4,CM%FNC,.CMFNP(T3)
	CAIN T4,.CMCFM		;Not confirm?
	IFSKP.			;Yup... Get 2nd byte
	  MOVEI T1,[FLDDB. .CMNUM,CM%SDH,^D10,<2nd byte of network/host>]
	  PARSE CMERRX		;Get it
	  LSH Q1,^D8		;Position first byte
	  ADD Q1,T2		;And add on second
	  MOVEI T1,[FLDDB. .CMTOK,,<POINT 7,[ASCIZ/./]>,,,<[
		    FLDDB. .CMCFM]>]
	  PARSE CMERRX		;Separator or confirmation
	  LOAD T4,CM%FNC,.CMFNP(T3)
	  CAIN T4,.CMCFM	;Confirmed yet?
	ANSKP.			;Nope. Get last byte
	  MOVEI T1,[FLDDB. .CMNUM,CM%SDH,^D10,<3rd byte of network/host>]
	  PARSE CMERRX		;Get it
	  LSH Q1,^D8		;Position other bytes
	  ADD Q1,T2		;And add this one
	  MOVEI T1,[FLDDB. .CMTOK,,<POINT 7,[ASCIZ/./]>,,,<[
		    FLDDB. .CMCFM]>] ;One more?
	  PARSE CMERRX
	  LOAD T3,CM%FNC,.CMFNP(T3)
	  CAIN T4,.CMCFM	;One more...
	ANSKP.
	  MOVEI T1,[FLDDB. .CMNUM,CM%SDH,^D10,<4th byte of host>]
	  PARSE CMERRX		;Get it
	  LSH Q1,^D8		;Position other bytes
	  ADD Q1,T2		;And add this one	  
	  CONFRM		;And confirm everything
	ENDIF.
	MOVX T1,.GTHLN
	MOVE T2,Q1		;Network number built here
	GTHST%			;Get this host's address on that network
	IFSKP.			;Worked?
	  SETOM LHSFLG		;Flag that this is setup
	  MOVEM T2,LHSNUM	;Setup local host number
	  CALL SETLC1		;Setup PORT string (for printing)
	  TMSG <[Using local address >
	  MOVEI T1,.PRIOU	;Get it
	  MOVE T2,LHSNUM	;Local host number
	  MOVEI T3,"."
	  CALL GHSTNM		;Print the number
	  TMSG <]
>
	  RET			;Done
	ENDIF.
	ECMSG <Host not connected to that network>
	RET

NOADDR:	CONFRM
	SKIPN LHSFLG		;Was anything set up?
	 RET			;No - this is a NO-OP, then
	SETZM LHSFLG		;Clear special network setting
	CALLRET SETLCH		;Reinitialize PRTSTR, etc.

;"Set (no) Port"

.PORT:	SKIPE SNOFLG		;Negated?
	 JRST NOPORT		;Yes...
	NOISE <to use for data connection>
	SETZ Q1,
	MOVEI T1,[FLDDB. .CMNUM,CM%SDH,^D10,<high byte of port>,,<[
		  FLDDB. .CMCFM,CM%SDH,,<Confirm to generate port>]>]
	PARSE CMERRX
	LOAD T4,CM%FNC,.CMFNP(T3) ;Get field type used
	CAIE T4,.CMCFM		;Confirmed?
	IFSKP.			;Yes
	  TXZ F,F%NPRT		;Doing PORT negotiation now
	  SETZM USRPRT		;Clear selected port value
	  RET
	ENDIF.
	MOVE Q1,T2
	MOVEI T1,[FLDDB. .CMTOK,,<POINT 7,[ASCIZ/./]>]
	PARSE CMERRX
	MOVEI T1,[FLDDB. .CMNUM,CM%SDH,^D10,<low byte of port>]
	PARSE CMERRX
	LSH Q1,^D8
	ADD Q1,T2
	CONFRM
	MOVEM Q1,USRPRT		;Save it
	TXZ F,F%NPRT		;Doing port negotiation
	RET

NOPORT:	NOISE <negotiation>
	CONFRM			;Make sure
	TXO F,F%NPRT		;Suppress sending PORT negotiation
	SETZM USRPRT		;No user port
	SETZM LSNPRT		;No listening port, either
	RET
	ENDTV.			;End of TRVAR's for "SET" commands

	SUBTTL File transfer commands - GET/SEND/APPEND/DIRECTORY

; Routine to set up a sane default file name
; Called with T1/ pointer to buffer to use
;	      T2/ JFN of local file
; Clobbers T1,T3,T4
; Special cases are:
;   ITS sites: uses <name> <ext> of original file
;   For Unix sites: uses <name>.<ext>, lowercased, of original file
; All other opsys types use the raw <name>.<ext> TOPS-20 file name.

GETFRN:	PUSH P,T1		;Save pointer
	MOVX T3,FLD(.JSAOF,JS%NAM)!FLD(.JSAOF,JS%TYP)!JS%PAF
	IFXN. F,F%RTAN
	  MOVE T1,FRNOPS
	  CAIE T1,.HS10X
	   CAIN T1,.HST20
	    IORX T3,FLD(.JSAOF,JS%GEN)
	  MOVE T1,(P)
	ENDIF.
	SETZ T4,
	JFNS%			;Get back part of file name
	MOVE T1,FRNOPS		;Get foriegn operating system
	CAIE T1,.HSITS		;Is it ITS?
	IFSKP.			;Yes...
	  MOVE T1,(P)		;Get back pointer
	  DO.			;Loop
	    ILDB T2,T1		;Get a char
	    JUMPE T2,ENDLP.	;Until a null
	    CAIE T2,"."		;Or a dot...
	     LOOP.		;Loop otherwise
	    MOVEI T2," "	;Space is separator for ITS
	    DPB T2,T1		;Fix it
	  ENDDO.
	ELSE.			;Not ITS
	  SKIPE T1		;If zero
	  CAIN T1,.HSUNX	;Or Unix
	  IFNSK.		;Have type 0 or Unix
	    MOVE T1,(P)		;Get back pointer to buffer
	    DO.
	      ILDB T3,T1	;Get a char
	      JUMPE T3,ENDLP.	;Stop on null
	      CAIL T3,"A"	;Less than A
	      CAILE T3,"Z"	;Or greater than Z?
	      TRNA		;Don't change
	      ADDI T3," "	;Map it to lower case
	      DPB T3,T1		;Put the char back
	      MOVEI T2,(T3)	;Copy last char
	      LOOP.
	    ENDDO.
	    CAIE T2,"."		;Was last char a .?
	    IFSKP.		;Yes, get rid of it since Unix
	      SETO T2,		;Minus 1 
	      ADJBP T2,T1	;Back up ptr and put in T2 
	      DPB T3,T2		;Replace . with null
	    ENDIF.
	  ELSE.			;Neither type 0 nor Unix...
	    CAIN T1,.HS10X	;Are we tenex
	    IFXN. F,F%RTAN	; and retaining?
	      MOVE T1,(P)	;Get back ptr
	      MOVEI T2,2	;Number of dots to find
	      DO.
		ILDB T3,T1	;Get next char
		JUMPE T3,ENDLP.	;Shouldn't end early, but check
		CAIE T3,"."	;Have a dot?
		 LOOP.		;No
		SOJG T2,TOP.	;Yes, jump if haven't found enough
		MOVEI T3,";"	;Enough, change last dot to a semi
		DPB T3,T1
	      ENDDO.
	    ENDIF.
	  ENDIF. 
	ENDIF.
GETDE1:	ADJSP P,-1		;Flush saved T1
	RET

; Routine to set up sane local file name.
; Called with T1/ Pointer to foriegn file name string
;	      T2/ Pointer to destination buffer
; Places legal <name>.<ext> filespec in destination buffer.
;
; The following conversions are done:
;   ITS:    STR:DIR;NAME1 NAME2 => NAME1.NAME2
;   Tenex:  STR:<DIR>NAME.TYPE;n => NAME.TYPE
;   Tops10: STR:NAME.TYP[DIR] => NAME.TYP
;   Tops20: STR:<DIR>NAME.TYPE.n => NAME.TYPE	(NB: STR: is optional)
;   Unix:   <path>/NAME => NAME			(NB: path is stuff until /)
;
;(No comments about how disgusting this code is - if you can figure out a
; better way to do it, I'd be glad to flush this crud -- VAF, 13-Aug-83)

GETLCN:	SAVEAC <T3,T4>
	MOVE T3,FRNOPS		;Get foriegn system type
	LSH T3,-9		;Make index
	CAIG T3,GTPMAX		;Out of range system type?
	SKIPN GETLCP(T3)	;Or no scheme defined?
	 MOVEI T3,<.HST20_-^D9> ;Just try TOPS-20, then
	PUSH P,T3
	HRRZ T4,GETLCP(T3)	;Get appropriate routine address
	HLRZ T3,GETLCP(T3)	;And appropriate terminator characterr
	CALL (T4)		;Call the routine
	MOVE T3,(P)		;Get back index
	HRRZ T4,GETLCE(T3)	;Get address of copy routine
	HLRZ T3,GETLCE(T3)	;Get terminator character
	CALL (T4)		;Call the routine
	POP P,T3		;Get back index
	SKIPN T4,GETLCG(T3)	;Anything to be done about gen #s?
	IFSKP.			;Yes...
	  HRRZS T4		;Get just routine
	  CALL (T4)		;Call it
	ENDIF.
	SETZ T3,
	IDPB T3,T2		;Make sure a null at end of file name
	RET			;Done at last
	

;Table of operating system to pre-name stripping routines

DEFTAB(GETLCP,OSMAX)		;Table of opsys-name stripping routines
  TABENT($$<.HS10X>,GETS20)	;Tenex - special
  TABENT($$<.HSITS>,<";",,GETSKP>) ;ITS - skip past ";" delimiting dir
  TABENT($$<.HSDEC>,<":",,GETSKP>) ;Tops-10 - skip past ":" delimiting str
  TABENT($$<.HST20>,GETS20)	;Tops-20 - special
  TABENT($$<.HSUNX>,GETSUN)	;Unix - special
  TABENT($$<.HSVMS>,GETSVM)	;VMS - Skip past "]" delimiting dir
DEFEND(GTPMAX)

;Routine to skip past a given character, also skips any whitespace.
;Called with: T1/ byte pointer
;	      T3/ character to find
;Clobbers T4

GETSKP:	STKVAR <<SAV12,2>>
	DMOVEM T1,SAV12		;Save byte pointer & T2
	SETZ T2,		;No previous character yet
	DO.
	  ILDB T4,T1		;Get next character
	  CAMN T4,T3		;Is it the terminator?
	  CAIN T2,"V"-"@"	;And not being quoted?
	  TRNA			;No. Skip it
	  EXIT.			;Yes - done
	  MOVE T2,T4		;Remember previous character
	  JUMPN T4,TOP.		;Nope - loop back if not a null
	ENDDO.
	MOVE T2,1+SAV12		;Restore T2
	IFE. T4			;Found null?
	  MOVE T1,SAV12		;Restore T1
	  RET			;And return
	ENDIF.
	MOVE T3,T1		;Keep T1 around for flushing whitespace
	DO.
	  ILDB T4,T3		;Read a char
	  CAIE T4," "		;Is it a space?
	   RET			;Nope - done
	  MOVE T1,T3		;Update pointer past space
	  LOOP.			;And loop for each space
	ENDDO.

;Routine to skip over structure and/or diretory for TOPS-20/TENEX file name

GETS20:	MOVEI T3,":"		;First, skip over structure name
	CALL GETSKP
	MOVEI T3,76		;Then, skip to the close angle bracket
	CALL GETSKP
	RET

;Rouine to skip over structure and/or directory for VMS

GETSVM:	MOVEI T3,":"		;First, skip over structure name
	CALL GETSKP
	MOVEI T3,"]"		;Then, skip to the end of the directory name
	CALL GETSKP
	RET

;Routine to skip over path name for Unix file spec. Skips past last "/"
;found in the file name.
;Called with T1/ byte pointer
;Clobbers T3 and T4

GETSUN:	MOVE T3,T1		;Copy byte pointer
	DO.
	  ILDB T4,T3		;Get a char
	  CAIN T4,"/"		;A slash?
	   MOVE T1,T3		;Update pointer past it
	  JUMPN T4,TOP.		;If not end, then get next char
	ENDDO.
	RET

;Table of routines to copy file names

DEFTAB(GETLCE,OSMAX)
  TABENT($$<.HS10X>,<";",,GETEND>) ;TENEX - Copy until ";" found
  TABENT($$<.HSITS>,GETEIT)	;ITS - special
  TABENT($$<.HSDEC>,<"[",,GETEND>) ;TOPS-10 Copy until "[" found
  TABENT($$<.HST20>,GETE20)	;TOPS-20 special
  TABENT($$<.HSUNX>,<0,,GETEND>) ;Unix - copy to null, (assume name OK)
  TABENT($$<.HSVMS>,<";",,GETEND>) ;VMS - Copy until ";" found
DEFEND(GTEMAX)

;Routine to copy name until terminator.
;Called with T1/ Source byte ptr
;	     T2/ Destination byte ptr
;	     T3/ Terminaing character

GETEND:	DO.
	  ILDB T4,T1		;Get a char
	  JUMPE T4,ENDLP.	;Null always terminates...
	  CAMN T4,T3		;Is it the terminator?
	   JRST ENDLP.		;Done, then
	  CAIL T4,"a"		;Is it
	  CAILE T4,"z"		; Lower-case?
	  TRNA			;Nope
	  SUBI T4," "		;Yup - fold it (not necessary, but looks good)
	  IDPB T4,T2		;Copy the char
	  LOOP.			;And loop around
	ENDDO.
	RET

;Copy name for ITS. Copies until null & translates " " to "."
;Called with T1/ Source ptr
;	     T2/ Destination ptr

GETEIT:	DO.
	  ILDB T4,T1		;Get a char
	  CAIN T4," "		;A space?
	   MOVEI T4,"."		;Translate it
	  IDPB T4,T2		;Write char back
	  JUMPN T4,TOP.		;Loop if non-null
	ENDDO.
	RET

;Copy name for Tops-20. Copies until null or second "." encountered.
;Called with T1/ Source ptr
;	     T2/ Destination ptr

GETE20:	MOVEI T4,2		;Indicate no dots yet
	DO.
	  ILDB T3,T1		;Get a char
	  CAIN T3,"."		;A dot?
	  SOJE T4,ENDLP.	;One less dot. If second, then exit
	  IDPB T3,T2		;Deposit char
	  JUMPN T3,TOP.		;Continue if not end
	ENDDO.
	RET

;Table of operating system to generation number disposition

DEFTAB(GETLCG,OSMAX)
  TABENT($$<.HS10X>,<";",,COPYGN>) ;TENEX - Retain if desired
  TABENT($$<.HST20>,<".",,COPYGN>) ;TOPS-20 - Retain if desired
  TABENT($$<.HSVMS>,<";",,COPYGN>) ;VMS - Retain if desired
DEFEND(GTGMAX)

;Routine to retain generation numbers if user desires
;Called with T1/ Source byte ptr
;	     T2/ Destination byte ptr

COPYGN:	TXNN F,F%RTAN		;Are we retaining?
	 RET			;No, do nothing
	PUSH P,T2		;Yes, save dest
	MOVEI T3,^D10		;Want decimal number
	NIN			;Try to read number from (forn) src
	IFJER.			;Don't have it
	  POP P,T2		;Restore dest ptr
	  RET			;and give up
	ENDIF.
	EXCH T2,(P)		;Save number, restore dest ptr
	MOVEI T3,"."		;Dot before gen#
	IDPB T3,T2		;...
	EXCH T1,(P)		;Save src ptr, restore number
	EXCH T1,T2		;Switch number, dest ptr for nout
	MOVEI T3,^D10		;Still talkin decimal
	NOUT			;Write the number
	 TRN			;???
	POP P,T2		;Restore src ptr
	EXCH T2,T1		;Switch src, dest to where they started
	RET			;Done

;"Get <foriegn-file> <local-file>"

.GET:	CALL PRSFRN		;Parse <foriegn-file> <local-file> pair
	 RET			;Failed
	CALLRET GETS1

;"Update <local-file>" - GET if remote file is more recent than local

TIMDIF==3			;Amount of time difference permitted

.UPDAT:	MOVE T1,FRNOPS		;Get foriegn system type
	CAIE T1,.HST20		;TOPS-20?
	CAIN T1,.HS10X		;Or TENEX?
	TRNA			;Yes - OK.
	CALLRET .GET		;Others can't STAT - procede as if GET
	CALL PRSFRN		;Parse file names, setup STAT buffer
	 RET			;Failed.
	HRROI T1,STRTMP		;Where to put file name
	MOVE T2,LJFTAB		;Handle on file to send
	MOVX T3,<FLD(.JSAOF,JS%DEV)!FLD(.JSAOF,JS%DIR)!FLD(.JSAOF,JS%NAM)!
		 FLD(.JSAOF,JS%TYP)!JS%PAF>
	JFNS%			;Get file name, sans generation number
	MOVX T1,GJ%SHT!GJ%OLD
	HRROI T2,STRTMP		;Point at local file name buffer
	GTJFN%			;See if it exists...
	 ERJMP GETS1		;Nope - update, then
	MOVE Q3,T1		;Keep the jfn around...
	SKIPG Q1,STATM1		;Get first time from STAT
	 CALLRET UPDAT1		;No time available...
	SKIPG Q2,STATM2		;Get second time
	 CALLRET UPDAT1
	MOVE T1,Q3		;Get local file jfn again
	MOVEI T2,STRTMP		;Where to put local file times
	MOVEI T3,.RSCRE+1	;Size of block
	RFTAD%			;Read file times
	SUB Q1,.RSCRV+STRTMP	;Compare creation dates
	SUB Q2,.RSWRT+STRTMP	;and write dates
	CAIG Q1,TIMDIF		;his more than a second newer?
	CAILE Q2,TIMDIF		;...
	CALLRET UPDAT1		;Yes - do the update
	TCMSG <[No update needed - file not retrieved]>
	RET
UPDAT1:	MOVE T1,Q3		;Get local file jfn again
	RLJFN%			;Release it
	 TRN
	CALLRET GETS1		;Do the retrieve

;Parse <foriegn-file> then <local-file>, verifying existance of foriegn file.
;Returns:
;	+1/ Failure
;	+2/ Success, ready to do GETS1

PRSFRN:	CALL FNPARS		;Get forien file name
	 RET			;Failed
	MOVE T1,[POINT 7,FRNPTH] ;Try for sane default local filename
	MOVE T2,[POINT 7,LCLNAM] ;...
	CALL GETLCN		;...
	MOVX T1,GJ%FOU		;Use next generation
	MOVEM T1,JFNBLK+.GJGEN
	NOISE <to local file>
	MOVEI T1,LCLPRX		;Parse CR or file name
	PARSE CMERRX
	LOAD T4,CM%FNC,.CMFNP(T3) ;Get code for what we parsed
	CAIE T4,.CMCFM	;Was it a CR?
	IFSKP.
	  HRROI T1,LCLPMT	;Yes, prompt for local file
	  CALL DPROMP
	  MOVEI T1,LCLPRS	;  and parse it (defaults to LCLNAM)
	  PARSE CMERRX
	ENDIF.
	MOVX T1,<ATMBUF,,LCLNAM> ;Update local filename with parsed input
	BLT T1,LCLNAM+ATMBLN-1 ;...
	MOVEM T2,LJFTAB		;Save JFN
	SETZM LJFIDX
	CONFRM
	RETSKP

;"Type <foriegn-file>" - variation on GET

.TYPE:	CALL FNPARS		;Read the file name & verify it
	 RET			;Failed
	CONFRM			;Confirm it
	SETZM LJFIDX		;Only one file
	MOVEI T1,.PRIOU		;Output to primary output
	MOVEM T1,LJFTAB		;Set it
	TXO F,F%TTY		;Going to TTY
	TXZ F,F%SEND
	CALL PREASC		;Send TYPE A N params
	 RET			;Failed - message alreay printed
	HRROI T2,[ASCIZ /RETR /]
	HRROI T1,FRNPTH		;Name for it
	CALL DTRANS		;Do data transfer
	RET

;Parse & check status of foriegn file

FNPARS:	MOVX T1,GJ%FOU		;Use next generation
	MOVEM T1,JFNBLK+.GJGEN
	NOISE <foreign file>
	MOVEI T1,[FLDBK. .CMFLD,CM%SDH,,<foreign filename string>,,REMBRK]
	MOVE T3,FRNOPS		;Get 4n os type
	CAIN T3,.HSITS		;Is it ITS?
	 MOVEI T1,[FLDBK. .CMFLD,CM%SDH,,<foreign filename string>,,BRKITS]
	PARSE CMERRX		;Parse foriegn name
	MOVX T2,<ATMBUF,,FRNPTH>
	BLT T2,FRNPTH+ATMBLN-1
	CALL CKSTAT		;Check status of remote file
	 RET			;STAT failed - punt
	MOVE T1,[POINT 7,FRNPTH] ;Point at place for path
	CALL STAPRS		;Go parse STAT info
	 SETOB T2,T3		;Bad STAT done...
	DMOVEM T2,STATM1	;Save time values for later use
	RETSKP

;Do STAT and analyze result.
;Returns:
;	+1/ Failure, no such file, etc. OLDFRN cleared.
;	+2/ Success.

CKSTAT:	CALL DOSTAT		;Do status
	 RETSKP			;Don't need to do STAT - done
	MOVE T1,REPCOD		;Get reply code
	CAIGE T1,ABTCOD		;Is it an abort?
	IFSKP.			;Yes.
	  SETZM OLDFRN		;Make sure we do it again if necessary...
	  EMSG <No such foriegn file - >
	  HRROI T1,RCVMSG
	  PSOUT%
	ELSE.
	  CAIE T1,^D212		;212 Directory info?
	  IFSKP.		;Yes
	    SETZM OLDFRN
	    ECMSG <Foriegn file name is ambiguous>
	  ELSE.
	    AOS (P)		;Prepare a skip return
	  ENDIF.
	ENDIF.
	RET

;Routine to send STAT command to check if requested file exists

DOSTA1:	SETZM OLDFRN		;Always do a STAT for this entry point
DOSTAT:	SETZM REPCOD		;Clear response
	MOVE T1,FRNOPS		;Get system type again
	CAIE T1,.HST20		;If a -20
	CAIN T1,.HS10X		;Or TENEX
	TRNA			;Then ok
	RET			;Can't do a STAT
	MOVE T1,[POINT 7,FRNPTH] ;Foreign file name
	MOVE T2,[POINT 7,OLDFRN] ;Previous foreign file name
	DO.
	  ILDB T3,T1
	  ILDB T4,T2
	  CAME T3,T4		;Same?
	  EXIT.			;Nope. Exit
	  JUMPN T3,TOP.		;Loop if not null yet
	  RET			;Same name - don't need another STAT
	ENDDO.
	MOVX T1,<FRNPTH,,OLDFRN>
	BLT T1,OLDFRN+ATMBLN-1	;Copy current version away for later check
	MOVX T1,<RC%TTX>	;Get flag for response driver
	ANDCAM T1,FSTRSP	;Don't type this one out...
	ANDCAM T1,FSTRS1	;Or directory status...
	ANDCAM T1,FSTABT	;Or abort
	HRROI T1,FRNPTH		;Point at desired file
	HRROI T2,[ASCIZ/STAT /] ;Command to use
	CALL TELCFX		;Send message, read reply type
	 TRN			;Ignore failure - CKSTAT will check
	MOVX T1,<RCVMSG,,STATBF>
	BLT T1,STATBF+RCVLSZ-1	;Keep STAT result around for later
	AOS (P)			;Successful STAT done
	MOVX T1,RC%TTX		;Flag...
	IORM T1,FSTRSP		;Fix up stat response
	IORM T1,FSTRS1		;...
	IORM T1,FSTABT		;Or abort
	RET

;Parse the STAT buffer.
;Accepts:
;	T1/ Pointer to buffer for foriegn file name
;	STATBF contains STAT result for TOPS-20/TENEX
;Returns:
;	+1/ Failure, STAT result not syntactically correct
;	+2/ Success, T1 updated, T2 has creation date, T3 has write date
;STAT buffer syntax is:
;	213 file-name;Pprot;Aaccount,size,

STAPRS:	STKVAR <DSTPTR>
	MOVEM T1,DSTPTR		;Save pointer
;Read & check 213 response code first.
	MOVE T1,[POINT 7,STATBF] ;Point at STAT buffer
	MOVEI T3,^D10		;DECIMAL
	NIN%			;Read response code
	 ERJMP R		;Failed - punt
	CAIE T2,^D213		;Correct code?
	 RET			;No - done
;Good response. Read out the file name
	DO.
	  ILDB T3,T1		;Get character
	  CAIN T3,";"		;End of name yet?
	  EXIT.			;Yes - done
	  IDPB T3,DSTPTR	;Write over foriegn path...
	  JUMPN T3,TOP.		;Make sure not null...
	ENDDO.
	SETZ T3,
	IDPB T3,DSTPTR
;Next, skip over protection,account,file-size - we don't use them.
	MOVEI T3,","		;Skip to first comma (protection+account)
	CALL GETSKP
	MOVEI T3,","		;Skip to next comma (file size)
	CALL GETSKP
	SETZ T2,		;Default format
	IDTIM%			;Read file creation time
	 SETO T2,		;Indicate failure
	MOVE T3,T2		;Copy this away
	SETZ T2,		;Default format
	IDTIM%			;Read file write time
	 SETO T2,		;Indicate failure
	EXCH T2,T3		;Put T2, T3 in correct order
	MOVE T1,DSTPTR		;And get back updated path byte ptr
	RETSKP

;"Directory" - a special version of retrieve

.DIREC:	NOISE <of foreign files>
	MOVEI T1,[FLDBK. .CMFLD,CM%SDH,,<wild-card filename>,<*.*>,REMBRK]
	PARSE CMERRX
	MOVX T2,<ATMBUF,,FRNPTH>
	BLT T2,FRNPTH+ATMBLN-1
	NOISE <to file>
	MOVEI T1,[FLDDB. .CMFIL,CM%SDH,,<local filename>,<TTY:>]
	PARSE CMERRX
	CONFRM
	HRRZ T1,T2		;Flags in LH will bomb Openf!
	SETZM LJFIDX
	MOVEM T1,LJFTAB
	MOVX T2,FLD(7,OF%BSZ)!OF%WR
	OPENF%
	 JRST GETXX1
	TXZ F,F%SEND
	CALL PREASC
	 JRST DIRBAD		;Error occurred...
	HRROI T2,[ASCIZ /LIST /]
;	CALL DIREC9
	HRROI T1,FRNPTH		;Name for it (Do this different from Get)
	CALL DTRANS		;Do data transfer
DIRBAD:	RET


;Main routine for setting up/starting RETR commands

GETS1:	MOVE T1,LJFIDX		;Get index
	HRRZ T1,LJFTAB(T1)	;Get the JFN
	SKIPG T2,PARAMS+P.BYTE	;Load the byte size
	MOVEI T2,^D8		;The default is 8
	MOVE T3,PARAMS+P.TYPE	;Load tranfer type
	CAIN T3,"A"		;Ascii?
	MOVEI T2,^D7		;Disk file should be ascii
	CAIN T3,"I"		;Image type?
	MOVEI T2,^D36		;Yes. make words, will fix below
	TXNE F,F%TTY		;Going to TTY?
	TXNN F,F%PAGD		;And paged?
	TRNA
	MOVEI T2,^D7		;Then use 7-bit mode
	ROT T2,-6		;Put it in right place for openf
	TXO T2,OF%WR		;And open for writing.
	OPENF%			;Try to open it
	 JRST GETXX1		;Failed - punt
	TXZ F,F%SEND		;Direction flag
	CALL PREDAT		;Send any mode, type PARAMS.
	IFNSK.			;Error return?
	  MOVE T1,LJFIDX	;Get index
	  HRRZ T1,LJFTAB(T1)	;Get the JFN
	  TXO T1,CO%NRJ		;Don't release jfn yet
	  CLOSF%		;Close it
	   TRN
	  TXC T1,DF%EXP!CO%NRJ	;Get rid of bogus file
	  DELF%			;...
	   TRN
	  RET
	ENDIF.
	HRROI T2,[ASCIZ /RETR /] ;Protocol retrieval cue
	HRROI T1,FRNPTH		;Name for it
	CALL DTRANS		;Do data transfer
	SKIPN F.ABRT		;Did someone say abort?
	CALL CKTRAN		;Or did we get a bad reply code?
	TRNA			;Yup.
	RET			;Nope. Done.
	MOVX T1,GJ%SHT!GJ%OLD	;DTRANS released the JFN
	HRROI T2,LCLNAM		; but didn't expunge the file
	GTJFN%			;Is it still there?
	IFNJE.
	  TXO T1,DF%EXP		;Yes, get rid of it
	  DELF%
	   TRN
	ENDIF.
	RET			;Return from get subr

GETXX1:	MOVE T1,LJFIDX		;Get index
	CLOSK LJFTAB(T1)	;Close but keep jfn
GETXX2:	CMSG <?Can't open local file.>
	RET			;Return from gets1


;"Append" and "Send" commands

.APPEN:	TXO F,F%APPE		;Append, not send command.
.SEND:	CALL PRSLCL		;Parse <local-file> <remote-file>
SEND1:	CALL SNDSRV		;Call file sender
	MOVE T1,LJFIDX		;get index
	CLOSD <LJFTAB(T1)>
	RET

;"Install <local-file> <remote-file>" - like SEND, but only if needed...

.INSTA:	CALL PRSLCL		;Parse local file name - no return on error
	CALL DOSTA1		;Do a STAT on the remote file name
	 TRN			;Ignore "STAT not needed" result.
	CALL STAPRS		;Parse STAT result
	 CALLRET SEND1		;Unexpected STAT reply - go send the file.
	DMOVE Q1,T2		;Copy times to Q1,Q2
	MOVE T1,LJFTAB		;Get local JFN
	MOVEI T2,STRTMP		;Where to put local file times
	MOVEI T3,.RSCRE+1	;Size of block
	RFTAD%			;Read file times
	SUB Q1,.RSCRV+STRTMP	;Compare creation dates
	SUB Q2,.RSWRT+STRTMP	;and write dates
	CAML Q1,[-TIMDIF]	;Are his more than a second older?
	CAMGE Q2,[-TIMDIF]	;...
	CALLRET SEND1		;Yes - go send the file
	TCMSG <[No update needed - file not sent]>
	RET

;Parse <local-file> <foriegn-file> pair.
;Sets up for call to SNDSRV.

PRSLCL:	MOVX T1,GJ%OLD		;File must exist
	MOVEM T1,JFNBLK+.GJGEN
	NOISE <local file>
	MOVEI T1,[FLDDB. .CMFIL,CM%SDH,,<local filename>]
	PARSE CMERRX
	SETZM LJFIDX
	MOVEM T2,LJFTAB
	MOVE T1,[POINT 7,FRNPTH] ;Where to put default name
	CALL GETFRN		;Setup the default from the JFN in T2
	NOISE <to foreign file>
	MOVEI T1,FRNPRX
	PARSE CMERRX
	LOAD T4,CM%FNC,.CMFNP(T3);Find out what parsed
	CAIE T4,.CMCFM		;Confirm?
	IFSKP.
	  HRROI T1,FRNPMT	;Yes, prompt for foreign file
	  CALL DPROMP
	  MOVEI T1,FRNPRS	; and parse it (defaults to FRNPTH)
	  PARSE CMERRX
	ENDIF.
	MOVX T2,<ATMBUF,,FRNPTH>
	BLT T2,FRNPTH+ATMBLN-1
	CONFRM
	RET

;Main routine for setting up/starting STOR commands

SNDSRV:	MOVE T1,LJFIDX		;Get index
	HRRZ T1,LJFTAB(T1)	;Get jfn
	SKIPG T2,PARAMS+P.BYTE	;Load the byte size
	 MOVEI T2,^D8		;The default is 8
	MOVE T3,PARAMS+P.TYPE	;Load tranfer type
	CAIN T3,"A"		;Ascii?
	MOVEI T2,^D7		;Disk file should be ascii
	LSH T2,^D30		;Put in place for openf
	TXO T2,OF%RD		;Read file
	TXNE F,F%TTY		;If TTY, force ascii read
	MOVX T2,FLD(7,OF%BSZ)!OF%RD
	OPENF%
	IFNSK.
	  MOVE T1,LJFIDX	;get index
	  CLOSK LJFTAB(T1)
	  ECMSG <Can't open local file.>
	  RET
	ENDIF.
	TXO F,F%SEND		;Direction flag for data fork
	CALL PREDAT		;Set up params
	 RET			;It failed
	HRROI T2,[ASCIZ /STOR /] ;Tell foreign guy to store file
	TXNE F,F%APPE		;Or maybe append it,
	HRROI T2,[ASCIZ /APPE /] ;..
	HRROI T1,FRNPTH		;Under this name
	CALL DTRANS		;Do data transfer
	CALL CKTRAN		;Did we get good reply code?
	 TRN			;No, nothing to do beyone reporting it
	RET			;Successful completion


;"Multiple Send/Get" commands

.MULTI:	MOVEI T1,[FLDDB. .CMKEY,,$MULT]
	PARSE CMERRX
	HRRZ T2,(T2)		;Get dispatch
	JRST (T2)		;Do it

.MSEND:	TXZ F,F%APPE		;Not append
	NOISE <local file group>
	MOVSI T4,-LJFSIZ	;Number of JFN's
MSLP:	MOVEI T1,[FLDDB. .CMFIL,CM%SDH,,<wild-card filename>]
	MVI. <GJ%OLD!GJ%IFG!GJ%FNS!GJ%SHT>,JFNBLK
	SETZ T3,
	PARSE CMERRX
	MOVEM T2,LJFTAB(T4)
	AOBJN T4,MSLP1
	JRST MSLP2
MSLP1:	MOVEI T1,[FLDDB. .CMCMA,,,,,<[
		  FLDDB. .CMCFM]>]
	PARSE CMERRX
	LOAD T3,CM%FNC,.CMFNP(T3)
	CAIN T3,.CMCFM
	 JRST MS00
	JRST MSLP
MSLP2:	CONFRM
MS00:	SETZM TCPUTM		;Clear counters
	SETZM TDAYTM
	SETZM MGFILS
	SETZM MGTRXD
	PSHABT MSABRT		;Setup abort for multiple-send
	MOVNS T4
	HRLZS T4
	PUSH P,T4		;Save original index
	DO.
	  PUSH P,T4		;Save index
	  MOVE T1,[POINT 7,FRNPTH] ;Place to build foriegn file name
	  HRRZ T2,LJFTAB(T4)	;JFN on file
	  CALL GETFRN		;Get reasonable foriegn file name
	  POP P,T4		;Get back index
	  MOVX T1,.PRIOU
	  HRRZ T2,LJFTAB(T4)	;JFN on file
	  SETZ T3,
	  JFNS%
	   ERJMP .+1
	  TMSG ( => )
	  HRROI T1,FRNPTH
	  PSOUT%
	  TCMSG <>
	  TXO F,F%KJFN		;Keep jfn
	  MOVEM T4,LJFIDX	;Use index
	  AOS MGFILS		;Trying another one...
	  CALL SNDSRV		;And do the send
	  AOS MGTRXD		;Another succceded
	  MOVE T1,CPUTIM	;Get CPU time used
	  ADDM T1,TCPUTM	;Count it up
	  MOVE T1,DAYTIM	;Get connect time used
	  ADDM T1,TDAYTM	;...
	  MOVE T1,NBYTES	;Number of bytes
	  ADDM T1,TNBYTS	;...
	  MOVE T1,NPAGES	;Number of pages
	  ADDM T1,TNPAGS
	  MOVE T4,LJFIDX	;Get back index
	  MOVE T1,LJFTAB(T4)	;Now step to next file
	  GNJFN%
	   TRNA			;No more.
	    LOOP.		;Go send this one
	  MOVE T4,LJFIDX	;Get back index
	  AOBJN T4,TOP.		;Decrement index, and do next JFN, if any
	ENDDO.
	POP P,T4		;Get back original JFN count
	POPABT			;Clear abort
MSABR1:	DO.
	  SKIPLE T1,LJFTAB(T4)	;Close out these jfns and release them
	  CLOSF%
	   TRN
	  SETOM LJFTAB(T4)
	  AOBJN T4,TOP.
	ENDDO.
	JRST MULFIN		;Do common finish.

.MGET:	MOVE T1,FRNOPS		;Get foreign system type
	MOVE T2,T1		;Copy for shift
	LSH T2,-^D9		;Make index
	CAIG T1,.HSUNX		;Maximum type we know about
	 SKIPN GETLCP(T2)	;Do we know how to do it?
	IFNSK.
	  MVI. .HSUNX,FRNOPS	;No, try treating it like Unix
	ENDIF.
	NOISE <foreign file group>
	MOVEI T1,[FLDBK. .CMFLD,CM%SDH,,<foreign wild-card filename>,,<[
		    BRMSK. FLDB0.,FLDB1.,FLDB2.,FLDB3.,</ !%*,.:;<>?[]>]>]
	PARSE CMERRX
	MOVX T2,<ATMBUF,,FRNPTH>
	BLT T2,FRNPTH+ATMBLN-1
	CONFRM
	PSHABT MSABRT		;Setup abort for multiple-send
	SETZM MGFILS		;Files tried
	SETZM MGTRXD		;Files transferred OK
	MOVX T1,GJ%FOU!GJ%TMP!GJ%DEL!GJ%SHT ;A temp file to hold list.
	HRROI T2,[ASCIZ /-FTP-TEMP-.TMP;P770000;T/]
	GTJFN%
	 JRST MGX1		;Can't
	SETZM LJFIDX
	MOVEM T1,LJFTAB
	MOVX T2,FLD(7,OF%BSZ)!OF%WR ;Write on it
	OPENF%
	 JRST MGX2		;Can't
	TXZ F,F%SEND		;Declare receive direction
	TXO F,F%KJFN		;Keep the directory file jfn
	CALL PREASC		;Send PARAMS for nlst
	IFNSK.			;Failed.
	  CLOSD LJFTAB		;Close temp file on error
	  RET			;And return
	ENDIF.
	HRROI T1,FRNPTH		;Send nlst of the path name
	HRROI T2,[ASCIZ /NLST /]
	CALL DTRANS		;and do data transfer
	CALL CKTRAN		;Did it go OK?
	IFNSK.
	  MOVE T1,LJFIDX	;No, get index
	  HRRZ T1,LJFTAB(T1)	;Get the jfn
	  MOVEM T1,DIRJFN	;Put here for MGDONE to clean up
	  JRST MGDONE
	ENDIF.
	MOVE T1,LJFIDX		;get index
	HRRZ T1,LJFTAB(T1)	;Now re-open the temp for reading
	MOVX T2,FLD(7,OF%BSZ)!OF%RD ;..
	OPENF%
	IFNSK.			;Failed
MGX2:	  CLOSD LJFTAB
MGX1:	  TMSG <?Can't open scratch file>
	  JRST MGDONE		;Go wrap up
	ENDIF.
	MOVEM T1,DIRJFN		;Hold it
	MOVE T2,LJFIDX		;Get index
	SETOM LJFTAB(T2)
	DO.			;Main loop
	  HRRZ T1,DIRJFN	;Get a file name
	  HRROI T2,FRNPTH	;Where it goes
	  MOVEI T3,PATHSZ*5
	  MOVEI T4,.CHLFD	;Quit on linefeed
	  SIN%
	  ERJMP ENDLP.		;Failed - assume EOF
	  GTSTS%
	  JXN T2,GS%EOF,ENDLP.	;Hit eof... done
	  AOS MGFILS		;Gonna try another
	  MOVE T1,[POINT 7,FRNPTH] ;Point at file name
	  DO.			;Loop
	    ILDB T2,T1		;Scan name
	    CAIE T2,.CHCRT	;CR
	    CAIN T2,.CHLFD	;Or LF?
	    TRNA		;Exit
	    LOOP.		;Else, get next char
	  ENDDO.
	  SETZ T2,		;End of name. make a null
	  DPB T2,T1		;Smash over the cr, lf, or null
	  MOVX T1,GJ%FOU	;Use next generation
	  MOVEM T1,JFNBLK+.GJGEN
	  MOVE T1,[POINT 7,FRNPTH] ;Foriegn file name
	  MOVE T2,[POINT 7,LCLNAM] ;Local file name
	  CALL GETLCN		;Get local name from foriegn name
	  MOVX T1,GJ%FOU!GJ%SHT
	  HRROI T2,LCLNAM
	  GTJFN%		;Try to get this name as jfn
	  IFNSK.		;Error...
	    CALL CRIF
	    TMSG <?Can't open local file - >
	    HRROI T1,LCLNAM
	    PSOUT%
	    CALL ERROR
	    LOOP.		;Loop for next one
	  ENDIF.
	  SETZM LJFIDX
	  MOVEM T1,LJFTAB	;Ok
	  HRROI T1,FRNPTH
	  PSOUT%
	  TMSG ( => )
	  HRROI T1,LCLNAM	;Announce it
	  PSOUT%
	  TCMSG <>
	  HRRZ T1,LJFTAB
	  CALL GETS1		;Do the file get
	   TRN
	  CALL CKTRAQ		;See how it went
	  IFSKP.		;Worked!
	    AOS MGTRXD		;Count it
	    MOVE T1,CPUTIM	;Get CPU time used
	    ADDM T1,TCPUTM	;Count it up
	    MOVE T1,DAYTIM	;Get connect time used
	    ADDM T1,TDAYTM	;...
	    MOVE T1,NBYTES	;Number of bytes
	    ADDM T1,TNBYTS	;...
	    MOVE T1,NPAGES	;Number of pages
	    ADDM T1,TNPAGS
	  ENDIF.
	  CLOSD LJFTAB
	  SKIPN F.ABRT		;Aborted?
	   LOOP.		;Nope - loop for next file
	  MOVE T1,REPCOD	;Get reply code
	  CAIE T1,^D550		;Was it "access denied"?
	  IFSKP.		;Yes - don't quit now
	    TCMSG < (skipping to next file)>
	    LOOP.		;And loop back
	  ENDIF.
	ENDDO.

MGDONE:	POPABT			;Clear multiple-get abort
MGABT1:	SKIPG T1,DIRJFN		;Directory file? (better be)
	IFSKP.			;Yes
	  TXO T1,CO%NRJ		;Don't release JFN
	  CLOSF%		;Close file
	   TRN
	  HRRZ T1,DIRJFN
	  DELF%			;Delete and release jfn
	   TRN
	ENDIF.
	SETOM DIRJFN
	CLOSD LJFTAB
	CALL CRIF		;Get ready to type some info

;Common finish for multiple send/multiple get

MULFIN:	CALL DCLCHK		;Close data connection, if needed
	SKIPLE T2,MGTRXD	;Skip if nothing made it
	IFSKP.
	  EMSG <No files transferred out of > ;Tell the bad news
	ELSE.
	  MOVX T1,.PRIIN	;Say how many worked
	  MOVX T3,^D10
	  NOUT%
	   ERCAL ERROR
	  TMSG < files transferred out of >
	ENDIF.
	MOVE T2,MGFILS		;Say how many we tried
	MOVX T1,.PRIIN
	MOVX T3,^D10
	NOUT%
	 ERCAL ERROR
	TCMSG < files attempted.>
	SKIPN TNBYTS		;Anything done?
	RET			;No. Don't bother with summary.
	TMSG <Total of >
	MOVE T1,TNBYTS		;Number of bytes
	MOVE T2,TNPAGS		;Number of pages
	MOVE T3,TDAYTM		;Amount of real time
	MOVE T4,TCPUTM		;Amount of CPU time
	CALL PRSUM		;Print summary
	TCRLF
	RET

	SUBTTL Routines for handling data transfer

;
; Main entry to data transfer routines
; Called with T1, T2 setup for TELSND of transfer protocol cue

DTRANS:	STKVAR <<T1T2,2>>	;Place to save T1 and T2
	TXZ F,F%XERR		;No error yet.
	DMOVEM T1,T1T2		;Save them
	MOVE T1,LJFIDX		;get index
	HRRZ T1,LJFTAB(T1)	;See what the local device is
	DVCHR%			;..
	TXZ F,F%TTY!F%DISK!F%NULL ;Clear device type flags
	LOAD T1,DV%TYP,T2	;Get dev type field
	CAIN T1,.DVDSK		;Is it the dsk?
	 TXO F,F%DISK		;Yes.
	CAIN T1,.DVNUL		;Nil device?
	 TXO F,F%NULL		;Yes. flag to skip sout to it.
	CAIN T1,.DVTTY		;TTY?
	 TXO F,F%TTY		;Set the flag
	MOVE T1,PARAM2+P.TYPE	;Get trx type
	TXNE F,F%CRLF		;Does user want this?
	 CAIE T1,"A"		;And are we doing ASCII mode?
	  TXZA F,F%CRHK		;No or no - suppress CRLF hacking
	   TXO F,F%CRHK		;Yes and yes
	SKIPN T3,PARAM2+P.MODE	;Current parameters
	 MOVEI T3,"S"		;If none specified, then stream
	SKIPN T4,PARAM2+P.STRU
	 MOVEI T4,"F"		;And file
	CALL DATSET		;Setup data connection
	 JRST DATERR		;Failed
	SETZM F.ABRT		;Clear flags
	SETZM F.DTIP		;...
	SETZM F.DTDR		;...
	DMOVE T1,T1T2		;Restore TELSND parameters
	CALL TELCFM		;Send protocol cue now
	 JRST DATERR		;Rejected
	PSHABT DTRABT		;Setup DTRABT for ^G
	MOVX T1,.FHSLF		;Get run and console times
	RUNTM%			;Before anything starts
	MOVEM T1,CPUTIM
	MOVEM T3,DAYTIM
	SETZM NBYTES		;Number of bytes transferred
	CALL TRDATA		;Transmit data
	POPABT			;Flush DTRABT from stack
DTRABO:	MOVX T1,.FHSLF
	RUNTM%			;Get console and run times
	SUB T1,CPUTIM		;Difference in times
	MOVEM T1,CPUTIM
	SUB T3,DAYTIM
	MOVEM T3,DAYTIM
	MOVX T1,.PRIOU		;Don't foul timing with tty wait
	DOBE%			;So wait first for tty.
	SKIPE F.DTIP		;Transfer in progress?
	 SKIPE F.ABRT		;And not aborted?
	  JRST DTRAN4		;Dont wait
	MOVNI P5,^D30		;Yes, wait a little bit
	IMULI P5,TIMVAL		;Adjust...
	DO.
	  SKIPN F.DTDR		;Done reply is in
	   SKIPE F.ABRT		;Abort in?
	    EXIT.
	  MOVEI T1,^D2000	;No. wait for it.
	  DISMS%
	  AOJL P5,TOP.		;Check now
	ENDDO.
	SKIPE F.DTDR		;250/226 received?
	IFSKP.			;Nope
	  CMSG <?No completion reply received within timeout period>
	ENDIF.
	SKIPN F.ABRT		;Abort received?
	IFSKP.
	  CMSG <Aborted...>
	ENDIF.
DTRAN4:	MOVE T1,LJFIDX		;get index
	IFXN. F,F%KJFN		;Want to hang on to jfn?
	  CLOSK <LJFTAB(T1)>
	ELSE.
	  CLOSD <LJFTAB(T1)>	;No. close and release.
	ENDIF.
	SKIPN F.ABRT		;Aborted?
	IFSKP.			;Yes - abort data JFN
	  CALL DCABRT		;Abort data connection
	  SKIPE TAKJFN		;Are we in a take file?
	  TXNE F,F%TALL		;Errors allowed?
	  TRNA			;no or yes
	  CALL TAKEND		;Nuke the take file on a data error, then
	ENDIF.

	TXNN F,F%STAT		;Statistics?
	SKIPE F.VBOS		;or verbose?
	TRNA			;Yes
	RET
	MOVX T1,.PRIOU		;Tty interference not desired
	DOBE%
	CALL CRIF
	MOVEI T1,"["
	PBOUT%
	MOVE T1,NBYTES
	MOVE T2,NPAGES
	MOVE T3,DAYTIM
	MOVE T4,CPUTIM
	CALL PRSUM		;Print transfer summary
	TCMSG <]>
	RET


;Routine to print summary for transfer
;Accepts:  T1/ #bytes transferred
;	   T2/ #pages transferred
;	   T3/ elapsed time
;	   T4/ runtime
;Assumes transfer just done, to PARAMS+P.BYTE is valid

PRSUM:	ASUBR <NBYT,NPAG,ETIM,RTIM>
	MOVEI T1,.PRIOU		;First, amount of data
	MOVE T2,NBYT		; ..
	MOVEI T3,^D10
	NOUT%
	 TRN
	SKIPG PARAMS+P.BYTE	;Was a byte size stated?
	IFSKP.			;Yes
	  MOVEI T2,"("
	  BOUT%
	  MOVE T2,PARAMS+P.BYTE
	  NOUT%
	   TRN
	  MOVEI T2,")"
	  BOUT%
	ENDIF.
	HRROI T2,[ASCIZ/ bytes /]
	SETZ T3,
	SOUT%
	SKIPN NPAG		;Have a page count?
	IFSKP.			;Yes
	  MOVEI T2,"("
	  BOUT%
	  MOVE T2,NPAG
	  MOVEI T3,^D10
	  NOUT%
	   TRN
	  HRROI T2,[ASCIZ/ pages) /]
	  SETZ T3,
	  SOUT%
	ENDIF.
	HRROI T2,[ASCIZ/at /]
	SETZ T3,
	SOUT%
	SKIPG T2,PARAMS+P.BYTE	;Was a byte size stated?
	 MOVEI T2,^D8		;No, use default
	IMUL T2,NBYT		;Bits
	IMULI T2,^D1000
	IDIV T2,ETIM		;Baud
	MOVEI T3,^D10		;Decimal
	NOUT%			;Prin it
	 TRN
	HRROI T2,[ASCIZ/ bps. Used /]
	SETZ T3,
	SOUT%
	MOVE T2,RTIM
	CALL DCOUT
	HRROI T2,[ASCIZ/ in /]
	SETZ T3,
	SOUT%
	MOVE T2,ETIM
	CALL DCOUT
	TMSG < sec>
	RET
	ENDAS.

DCOUT:	IDIVI T2,^D1000		;Make thousands
	PUSH P,T3		;Stash fraction
	MOVEI T3,^D10
	NOUT%
	 TRN
	MOVEI T2,"."
	BOUT%
	POP P,T2		;Get back fraction
	MOVX T3,<FLD(^D3,NO%COL)!NO%ZRO!NO%LFL!FLD(^D10,NO%RDX)>
	NOUT%			;Print it
	 TRN
	RET

;Error and synchronization routines used by data transfer setup

DATERR:	CALL CRIF		;...
	EMSG <Unable to open data connection - >
	MOVX T1,.PRIOU
	MOVX T2,<.FHSLF,,-1>
	SETZ T3,
	ERSTR%
	 TRN
	 TRN
	TCMSG <>
DATERX:	CALL DCABRT		;Abort partial data connection
	SETZM PARAM3+P.TYPE	;and send new params, please
	SETZM PARAM3+P.TYP2
	SETZM PARAM3+P.STRU
	SETZM PARAM3+P.MODE
	RET


;Routine to setup data connection
;Called with various data port selection variables set.
;Returns +1/Failure, DATJFN cleared
;	 +2/Success, DATJFN setup with data connection "JFN"

DATSET:	SKIPLE DATJFN		;Already have a connection?
	 RETSKP			;No need to get another, then
	SETOM DATJFN		;No data connection JFN yet
	TXZ F,F%DATC		;Flag no data conn yet
	SETZM DATCON		;First word
	MOVX T1,<DATCON,,DATCON+1>
	BLT T1,DATBUF		;Clear it out	
	MOVEI T1,T.CDB+DATCON	;Address of CDB
	TXNN F,F%NPRT		;If suppressing PORT, then default it
	SKIPN T2,LSNPRT		;If a PORT was sent, use that port number
	 MOVE T2,ICPPRT		;No. Default it to same as TELNET connection
	MOVEM T2,.TCPLP(T1)	;Set local port
	MOVE T2,FTPDAS		;Foriegn port is one less than TELNET port
	MOVEM T2,.TCPFP(T1)	;Set it
	MOVE T2,LHSNM2		;Get local host number to use
	MOVEM T2,.TCPLH(T1)	;Set it
	MOVE T2,FRNHST		;Foriegn host we're talking to
	MOVEM T2,.TCPFH(T1)	;Set it
	SKIPN F.VBOS		;Verbose mode?
	IFSKP.			;Yes
	  MOVE T4,T1		;Copy T1
	  TMSG <[Listening as host >
	  MOVEI T1,.PRIOU
	  LDB T2,[POINT 8,.TCPLH(T4),^D11]
	  MOVEI T3,^D10
	  NOUT%
	   TRN
	  MOVEI T2,"."
	  BOUT%
	  LDB T2,[POINT 8,.TCPLH(T4),^D19]
	  NOUT%
	   TRN
	  MOVEI T2,"."
	  BOUT%
	   TRN
	  LDB T2,[POINT 8,.TCPLH(T4),^D27]
	  NOUT%
	   TRN
	  MOVEI T2,"."
	  BOUT%
	  LDB T2,[POINT 8,.TCPLH(T4),^D35]
	  NOUT%
	   TRN
	  TMSG <, port >
	  MOVEI T1,.PRIOU
	  LDB T2,[POINT 8,.TCPLP(T4),^D27]
	  NOUT%
	   TRN
	  MOVEI T2,"."
	  BOUT%
	  LDB T2,[POINT 8,.TCPLP(T4),^D35]
	  NOUT%
	   TRN
	  TCMSG <]>
	ENDIF.
	MOVEI T1,DATCON		;File block
	MOVX T2,<-T.NDBB,,DATBUF>
;***	MOVX T3,<T.BFSB!TCP%WT>	;Wait for connection
	MOVX T3,<T.BFSB>	;*** Just open connection
	$GTJFN			;Listen...
	 RET			;Failed
	MOVEM T1,DATJFN		;Store jfn
	RETSKP

; Worker routine for the DTRANS

TRDATA:	MOVEM P,TRSAVP		;Save stack pointer here in case of error
;	SETZM TYXSCT		;Start sequence numbers at 1
	MOVE T1,DATJFN		;Get data connection jfn
	SKIPG T2,PARAM2+P.BYTE	;Was a byte size stated?
	 MOVEI T2,^D8		;No. default is eight-bit bytes
	MOVEM T2,PARAM2+P.BYTE	;Store back in case default
	LSH T2,36		;Put it in left 6 bits
	TXO T2,FLD(5,OF%MOD)!OF%RD ;Buffered send, listening
	TXNE F,F%SEND		;Sending ?
	 TXC T2,OF%RD!OF%WR	;Change to write.
	$OPENF			;Make it listen
	 JRST DATERR		;Lose...
	TXO F,F%DATC		;Indicate data connection opened
	SETOM F.DTIP		;Flag transfer in progress
	SETZM NPAGES		;Number of pages sent/received
	JXE F,F%SEND,RECEIV	;Receive from server
	JRST DSEND		;Else, do send

;Here on error during data transfer.
;Called with:
;	JSP T1,TRDERM
;Error message follows

TRDERM:	CALL CRIF
	HRROS T1		;Make a byte ptr to message
	ESOUT%
	TCRLF
TRDERR:	MOVE P,TRSAVP		;Restore stack context
	TXO F,F%XERR		;indicate an error occurred
;	CALLRET TRDCLS		;and do common finish

;Here to unmap file window and close data connection

TRDCLS:	CALL PRHEND		;Finish hash mark list, if printing them
	SETO T1,		;Unmap file pages, if any
	MOVX T2,<.FHSLF,,<WINDOW/1000>>
	MOVX T3,PM%CNT!FLD(2,PM%RPT) ;Two pages
	PMAP%
	HRRI T2,<WINDW2/1000>
	PMAP%
	MOVE T1,DATJFN		;Close the data connection
	JXE F,F%DCLS,R		;Need to close?
	MOVEI T1,DATJFN		;Closing data connection
	TXNE F,F%XERR		;Transfer error?
	 TXOA T1,CZ%ABT		;Yes - abort it
	  TXO T1,CO%WCL		;No - wait for connection to close
	CALLRET DCLOS1		;Close data connection

	SUBTTL Send file over data connection

DSEND:	SETZM SNDCRL		;Last char sent wasn't CR (yet)
	TXNE F,F%DISK!F%NULL	;Disk or NULL?
	 JRST SNDDSK		;Yes - handle it separately

;Send file in sequential mode.

	MOVX Q1,<TRNA>		;No-op instruction
	IFXN. F,F%TTY		;Doing TTY?
	  TCMSG <[Enter input - type ^Z to terminate]>
	  MOVE Q1,[CAIN T2,.CHCNZ] ;Check ^Z for EOF...
	ENDIF.
	DO.
	  MOVE T1,LJFIDX	;Get index
	  HRRZ T1,LJFTAB(T1)
	  BIN%
	  XCT Q1		;Maybe check for EOF...
	   JRST SNDEOF
	  IFE. T2		;Null?
	    GTSTS%		;Yes - check for EOF on input
	    TXC T2,GS%OPN!GS%RDF
	    TXNE T2,GS%OPN!GS%RDF!GS%EOF
	    JRST SNDEOF
	    SETZ T2,
	  ENDIF.
	  MOVE T1,DATJFN
	  $BOUT
	   ERJMP STXERR		;Failure
	  AOS NBYTES
	  LOOP.			;Loop back for more
	ENDDO.

;Common EOF for send. Push final data and call common close routine.

SNDEOF:	MOVE T1,DATJFN
	MOVX T2,<.MOSND>	;Send partial buffer
	$MTOPR			;Push data out
	 ERJMP .+1		;Ignore the failure
	CALLRET TRDCLS		;Do common close.

	SUBTTL Send disk or null file, non-paged mode

SNDDSK:	IFXN. F,F%NULL		;Null?
	  SETZM WINDOW		;Make sure window is existant
	  MOVX T3,<^D125000>	;Length of null file
	  MOVEM T3,FBYTES	;Save number of bytes
	  MOVEI T4,^D8		;Say it is an 8-bit file
	ELSE.
	  MOVE T1,LJFIDX	;Get index
	  HRRZ T1,LJFTAB(T1)
	  MOVSI T2,.FBLEN
	  MOVEI T3,FDB
	  GTFDB%
	  MOVE T3,FDB+.FBSIZ	;Get count of bytes
	  MOVEM T3,FBYTES	;Set byte count
	  LOAD T4,FB%BSZ,FDB+.FBBYV ;Byte size
	ENDIF.
	JXN F,F%PAGD,SNDTYX	;Paged transfer

	SKIPN T4		;In case bad
	 MOVEI T4,^D36		;assume 36 bit file
	MOVEM T4,FILBSZ		;Save file byte size
	MOVEI T2,^D36
	IDIVI T2,(T4)		;T2 gets bytes per word
	SKIPN T3,FBYTES		;Get count of file bytes, in writer's size
	 CALLRET SNDEOF		;None - done.
	IDIVI T3,(T2)		;Get writer's words
	SKIPE T4
	AOS T3			;And partial word, if any
	MOVEM T3,NWORDS		;Real number of words
	SETZM PAGENO		;Starts at page 0
	RFBSZ%			;See what size file is now open in
	 TRN			;Error return. should not happen
	MOVEM T2,LCLBSZ		;Copy
	ROT T2,-14		;To byte size place in byte ptr
	IOR T2,[POINT 0,WINDOW]	;Make pointer to WINDOW page
	MOVEM T2,IBPTR		;Save it
	MOVEI T2,^D36		;Find conversion to local bytes per wd
	IDIV T2,LCLBSZ		;...
	MOVEM T2,LCLBPW		;Save that.
	MOVE T1,FILBSZ		;Byte size of write
	CAMG T1,LCLBSZ		;Is it greater than open size?
	IFSKP.
	  IDIV T1,LCLBSZ	;Yes, get write/open
	  IMUL T1,FBYTES	;Number of bytes in current size
	ELSE.
	  MOVE T1,FBYTES	;No, just use number bytes in file
	ENDIF.
	MOVEM T1,LBYTES		;Save # logical bytes
SNDDLP:	DO.
	  IFXN. F,F%DISK	;Only for disk... NUL: doesn't care
	    MOVE T1,LJFIDX	;get index
	    HRLZ T1,LJFTAB(T1)	;Map in a page of file
	    HRR T1,PAGENO
	    MOVX T2,<.FHSLF,,<WINDOW/1000>>
	    MOVX T3,PM%RD	;Readable
	    PMAP%
	  ENDIF.
	  MOVE T1,DATJFN	;Send the data
	  MOVE T2,IBPTR
	  MOVE T3,NWORDS
	  CAIL T3,1000
	   MOVEI T3,1000	;Up to a page
	  MOVNS T3
	  ADDM T3,NWORDS	;Update count, make - for sout
	  IMUL T3,LCLBPW	;Scale for words to bytes
	  ADDM T3,LBYTES	;Count down what we really have
	  SKIPGE T4,LBYTES	;Counted too much (due to partial word)?
	   SUB T3,T4		;Yes, correct the overcount
	  MOVN T4,T3		;+ bytes
	  ADDM T4,NBYTES	;Count them
	  AOS NPAGES
	  TXNE F,F%CRHK		;Doing CRLF hacking?
	   CALL SNCRHK		;Yes - do it now
	  $SOUT			;Send the data
	   ERJMP STXERR		;Error
SNDDNP:   AOS PAGENO		;Send disk next page
	  CALL PRHASH		;Print hash mark
	  SKIPLE NWORDS		;More to go?
	   LOOP.		;Yes - do next page
	ENDDO.
	SKIPN SNDCRL		;No more, was last a CR?
	IFSKP.			;Yes
	  SETZ T2,		;Send a final NUL
	  $BOUT			;...
	ENDIF.
	CALLRET SNDEOF		;And do EOF processing

;Routine to do CRLF hacking for TYPE A N files

SNCRHK:	MOVEM T2,SNDPTR		;Save byte ptr
	MOVEM T3,SNDCNT		;Save count
	SKIPN SNDCRL		;Did we have CR last in prev window?
	IFSKP.			;Yes!
	  ILDB T4,T2		;Check first char this window
	  CAIN T4,"J"-100	;Does LF follow CR?
	  IFSKP.		;No, need null to follow CR
	    SETZ T2,		;...
	    $BOUT		;Send it
	  ENDIF.
	  MOVE T2,SNDPTR	;Reset ptr, start of window
	  SETZM SNDCRL		;Business taken care of, clear flag
	ENDIF.
	DO.			;Loop to scan this window
	  ILDB T4,T2		;Check next char
	  AOSE T3		;Count and check for last
	   CAIE T4,"M"-100	;Check for CR
	  IFSKP.		;Not last char and have CR?
	    ILDB T4,T2		;Yes!  Check next char
	    CAIE T4,"J"-100	;Does LF follow CR?
	    IFSKP.		;Yes
	      AOS T3		; just account for the LF
	    ELSE.		;No
	      SETO T4,		;Get a -1 
	      ADJBP T4,T2	;Back up ptr
	      EXCH T4,SNDPTR	;Have to send partial window; get start
	      MOVE T2,T4	; into right place
	      EXCH T3,SNDCNT	;Save updated count
	      SUB T3,SNDCNT	;T3/ -count in partial window
	      $SOUT		;Send up to and including CR
	       ERJMP STXERR
	      SETZ T2,
	      $BOUT		;Send NUL
	       ERJMP STXERR
	      MOVE T2,SNDPTR	;Pick up where we left off
	      MOVE T3,SNDCNT	;...
	    ENDIF.
	  ELSE.			;Here if last char in window or not CR
	    CAIN T4,"M"-100	;Is char a CR?
	     SETOM SNDCRL	;Yes, must be last char, flag it!
	  ENDIF.
	  JUMPL T3,TOP.		;Loop if more chars in window
	ENDDO.
	MOVE T2,SNDPTR		;Scanned all window
	MOVE T3,SNDCNT		;Now ready to send whats left (maybe all)
	RET

	SUBTTL Send disk file, paged mode

SNDTYX:	SETOM PAGENO		;Set window page number to zero-1
	DO.
	  CALL STXNPG		;Get next page...
	   EXIT.		;No more pages.
	  HRRZM T1,PAGNO	;Page number we are doing
	  MOVEM T2,TYXNDW	;Number of data words for page
	  ADDM T2,NBYTES	;And count in transfer length
	  MOVX T1,PGT$SP	;Simple page record type
	  MOVEM T1,RECTYP	;Say so
	  CALL STXSPG		;Send this page
	  AOS NPAGES
	  CALL PRHASH		;Print hash mark
	  LOOP.			;And do next page
	ENDDO.
STXEOF:				;Last page done - do EOF for paged xfer
	SETZM ACCESS		;Clear ACCESS and page number
	SETZM PAGNO		;..
	MOVX T1,PGT$DP		;Descriptor page
	MOVEM T1,RECTYP		;To header
	CALL STXMFD		;Build descriptor page
	MOVEM T1,TYXNDW		;Length of it...
	CALL STXSPG		;Send descriptor page
;	TXO F,F%FDB		;FDB sent
	MOVX T1,<PGT$LP>	;Last page
	MOVEM T1,RECTYP
	SETZM TYXNDW		;No data
	CALL STXSPG		;Send last page
	CALLRET SNDEOF		;and do common EOF for SEND

;Get the next page for a paged transfer.
;Called with:
;	PAGENO/ Next page to be transferred
;	LJFIDX,LJFTAB set up
;Returns:
;	+1, no more pages
;	+2, next page mapped in WINDOW, T1<RH> has PN, T2 has word count
;	Updates PAGENO, sets ACCESS in paged header

STXNPG:	AOS T1,PAGENO		;Next page to consider
	MOVE T2,LJFIDX		;Get index
	HRL T1,LJFTAB(T2)	;Page pointer
	RPACS%			;Find the access for the page
	MOVEM T2,ACCESS		;Store in case it exists, in hdr.
	IFXE. T2,PA%PEX		;Make sure page exists...
	  FFUFP%		;Are there any more pages?
	   RET			;No. Failure return
	ENDIF.
	MOVX T2,<.FHSLF,,<WINDOW/1000>>
	MOVX T3,PM%RD		;Map it in for reading
	PMAP%
	MOVEI T2,1000		;It is a page long
	SKIPN WINDOW-1(T2)	;Have a trailing zero?
	 SOJG T2,.-1		;Yes - Decrease size
	CAIGE T2,2		;Must have some data, though...
	 MOVX T2,2		;So use a minimal amount
	RETSKP

;Routine to send one page of a paged transfer
;Accepts:
;	Paged header set up for data size (RECTYP,TYXNDW,PAGNO,ACCESS)

STXSPG:
;	AOS T1,TYXSCT		;Count net seq number
	MOVE T3,RECTYP		;Get page type
	MOVE T2,PGLEN(T3)	;Get corresponding header length
	MOVEM T2,TYXNPW		;Into header
	MOVE T1,DATJFN		;Now. send this stuff.
	MOVN T3,T2		;Now that many words of hdr
	MOVE T2,[POINT 36,TYXHED] ;Point to the data
	$SOUT
	 ERJMP STXERR		;Error
	MOVN T3,TYXNDW		;Then the data
	MOVE T2,[POINT 36,WINDOW]
	SKIPE T3		;Omit if none
	 $SOUT
	  ERJMP STXERR
	JUMPN T3,STXERR		;Error
	RET

STXERR:	JSP T1,TRDERM		;Transfer error occurred
	ASCIZ/Unexpected close of data connection./


;Build an FDB (PGT$DP record) for the local file in WINDOW.
;Copies FDB to WINDOW and adds the strings. Returns with record ready to send.
;Returns:
;	T1/ Length of descriptor data

STXMFD:	SETO T1,		;Clear WINDOW page
	MOVX T2,<.FHSLF,,<WINDOW/1000>>
	SETZ T3,		;Just one page
	PMAP%
	MOVX T1,<FDB,,WINDOW>	;Copy the FDB to the WINDOW
	BLT T1,WINDOW+.FBLEN-1

;Write extra FDB string info into table

;First the time strings

	MOVX T4,<-FDTXTN,,FDTXT> ;Aobjn ptr to info descriptor
	MOVX T3,<OT%4YR!OT%TMZ!OT%SCL> ;Odtim flags
	DO.			;Start of loop
	  HRRO T1,(T4)		;String ptr
	  HLRZ T2,(T4)		;FDB offset
	  CAILE T2,.FBLEN	;In FDB?
	   JRST STXMFX		;No, give up on extra stuff
	  MOVE T2,FDB(T2)	;Get time
	  ODTIM%		;Write it
	   ERJMP STXMFX		;???
	  AOBJN T4,TOP.		;Loop while more
	ENDDO.

;Now the user strings

	MOVX T4,<-FDTXUN,,FDTXUG> ;Aobjn ptr to table descriptor
	MOVE T1,LJFIDX		;Get index
	MOVE T1,LJFTAB(T1)	; for current jfn
	DO.			;Another loop
	  HLL T1,(T4)		;Get function
	  HRRO T2,(T4)		;String ptr
	  GFUST%		;Get user string
	   ERJMP STXMFX		;???
	  AOBJN T4,TOP.		;Loop if more
	ENDDO.

;Now write extra info into descriptor page

	HRROI T1,WINDOW+.FBLEN	;Ptr to where we left off
	SETZ T3,
	MOVX T4,<-FDTXSN,,FDTXST> ;Aobjn ptr for info strings
	DO.			;Loop
	  HRRO T2,(T4)		;String ptr
	  SOUT%			;Write one
	   ERJMP STXMFX		;???
	  IDPB T3,T1		;Make asciz
	  HRROI T1,1(T1)	;Next free word
	  AOBJN T4,TOP.		;Loop for more
	ENDDO.

	HRRZI T1,-WINDOW(T1)	;Total length, fdb+extra info
	TRNA			;Use it
STXMFX:	 MOVEI T1,.FBLEN	;Just fdb as length of data
	RET

	SUBTTL Receive file over data connection

; Receive direction after connection open.

RECEIV:	SETZM RCVCRL		;#226 Clear a flag
	SETO T1,		;Get the WINDOW page free
	MOVX T2,<.FHSLF,,<WINDOW/1000>>
	SETZ T3,		;Just one page
	PMAP%
	JXN F,F%PAGD,RCVTYX	;Paged transfer handled elsewhere
	DO.
	  CALL RCVWND		;Receive one window's worth of data
	  JUMPE T3,RCVEOF	;If no bytes, then EOF
	  MOVE T1,LJFIDX	;get index
	  HRRZ T1,LJFTAB(T1)	;Where to put the data
	  ADDM T3,NBYTES	;Bytes transferred so far (one page worth)
	  AOS NPAGES
	  TXNN F,F%NULL		;Don't waste time on NUL:
	   CALL RCVWRT		;Write the window
	  CALL RCKEOF		;Check for EOF on receive...
	   LOOP.		;Nope. Continue.
	ENDDO.
RCVEOF:				;Here on EOF for receive.
	CALLRET TRDCLS		;Do common close for file and connection


;Routine to receive next window of data from the data connection.
;Accepts:
;	Data connection set up.
;Returns:
;	T2/ Appropriate byte pointer to WINDOW
;	T3/ Count of bytes received
;	WINDOW has data, up to a page worth.

RCVWND: MOVE T1,PARAM2+P.BYTE	;Byte size sent
	MOVX T2,^D36		;Bits per word
	IDIVI T2,(T1)		;Bytes per word
	IMULI T2,1000		;Pages worth of bytes
	MOVNS T3,T2		;Negative for SIN%
	MOVE T2,T1		;Byte size
	LSH T2,30		;Put in right lace
	IOR T2,[POINT 0,WINDOW] ;Make a byte pointer to WINDOW
	PUSH P,T2		;Save starting byte ptr
	PUSH P,T3		;And count
	MOVE T1,DATJFN		;Network JFN
	$SIN
	 ERJMP RTXERE		;Error
	CALL PRHASH		;Print hash marks
	POP P,T4		;Starting count
	POP P,T2		;And pointer
	SUB T3,T4		;Actual count read by SIN
	RET


;Routine to write out received window.
;Does CR/NULL kluge for translating braindamaged Unix text files if needed
;and writes the window contents to the local file.
;Called with:
;	T1/ JFN on local file
;	T2/ Pointer to window
;	T3/ Count of bytes in window (positive)

RCVWRT:	IFXE. F,F%CRHK		;If not CRLF crud, do simple case.
	  MOVNS T3		;Negative count
	  SOUT%
	  RET
	ENDIF.
	SKIPN RCVCRL		;Was last char of last window a CR?
	IFSKP.			;Yes
	  MOVE T4,T2		;Copy the src ptr
	  ILDB T4,T4		;Check first char of this window
	  SKIPE T4		;Is it a nul?
	  IFSKP.		;Yes, strip it out
	    IBP T2		; by bumping the ptr
	    SOS NBYTES		; and don't count it in summary
	    SOJE T3,R		; but do account for reading one char
	  ENDIF.
	  SETZM RCVCRL		;Clear flag
	ENDIF.
	DO.			;Start a loop
	  MOVEI T4,"M"-100	;Stop at CR
	  SOUT%			;Write up to and including CR if any
	  SKIPE T3		;Finish whole window?
	  IFSKP.		;Yes
	    LDB T3,T2		;Check last char in window
	    CAIN T3,"M"-100	;Was it a CR?
	     SETOM RCVCRL	;Yes, set flag
	    EXIT.		;Get out of the loop
	  ENDIF.
	  MOVE T4,T2		;Copy src ptr
	  ILDB T4,T4		;Get char after CR
	  SKIPE T4		;Is it null?
	  IFSKP.		;Yes, strip it
	    IBP T2		; by bumping ptr
	    SOS NBYTES		; and don't count in summary
	    SOJE T3,ENDLP.	;Get out if this null was last in window
	  ENDIF.
	  LOOP.			;Loop for some more chars
	ENDDO.
	RET

;Check for EOF on receive.
;Returns:
;	+1 Not at EOF yet
;	+2 EOF occurred.

RCKEOF: SETZ T2,		;Init, so it will be 0 if no jfn
	SKIPLE T1,DATJFN	;See if have gotten to eof yet
	 $GTSTS
	TXNE T2,GS%OPN!GS%RDF	;Still happy?
	 TXNE T2,GS%ERR		;..
	  JRST RCVERR		;No.
	JXN T2,GS%EOF,RSKP	;End of file?
	RET

;Standard error handler for receive

RCVERR:	CALL CRIF
	EMSG <Data connection error: >
	MOVX T1,.PRIOU		;Print it
	MOVX T2,<.FHSLF,,-1>
	SETZ T3,
	ERSTR%
	 TRN
	 TRN
	TCRLF
	CALLRET TRDERR		;Handle transfer error

	SUBTTL Paged-mode receive

;Do a paged-mode receive, DSK: only.

RCVTYX:	DO.
	  SETO T1,		;Throw away any junk in window page
	  MOVX T2,<.FHSLF,,<WINDOW/1000>>
	  SETZ T3,		;Just one page
	  PMAP%
	  SETMM WINDOW		;Touch it to get a blank page
	  MOVE T1,DATJFN	;Now get the header length
	  $BIN
	   ERJMP RTXERE
	  JUMPE T2,RTXPG0	;Should not have a zero byte here
	
	  MOVEM T2,TYXHDR	;Store in scratch area
	  CAIL T2,LTYXMN	;Range check it
	   CAIL T2,NTXHDR	;Will it fit in this buffer?
	    JRST RTXHDB		;No good. format error (DRCEHL)
	  MOVN T3,T2		;Ok, read the header
	  ADDI T3,1		;Count included count word
	  MOVE T2,[POINT 36,TYXHDR+1]
	  $SIN
	   ERJMP RTXERE
	  JUMPN T3,RTXHDX	;If didn't get it all, format error
	  MOVX T3,<TYXHDR,,TYXHED> ;Copy it to real area known length
	  BLT T3,TYXHED+TYXHDN-1
	  MOVE T3,TYXNDW	;Get the length out of the header
	  SKIPL T3		;Negative?
	  CAILE T3,1000		;Or too big?
	   JRST RTXDTZ		;Format error
	  MOVE T2,[POINT 36,WINDOW] ;Ok, read it into the window
	  MOVNS T3		;This many words, negative.
	  SKIPE T3		;Allow for empty body
	  $SIN
	   ERJMP RTXERE
	  JUMPN T3,RTXDIN	;Make sure got it all
	  CALL PRHASH		;Print has mark, if desired
;	  AOS T3,TYXSCT		;Check the sequence number
	  MOVE T1,RECTYP	;Get data record type
	  CAIL T1,PGT$MI	;Too small?
	  CAILE T1,PGT$MX	;Or too big?
	  SETO T1,		;Make out of range
	  CALL PGTDTB(T1)	;Handle the specified page
	   TRNA
	    EXIT.		;EOF occurred... Do it
RTXNXT:	  CALL RCKEOF		;EOF yet?
	   LOOP.		;Nope. Do next page of data
	ENDDO.
	CALLRET RCVEOF		;Done with receive.

;Dispatch table for paged transfer records.
;RETSKP indicates that EOF has occurred.

	CALLRET RTXUNK		;Unknown page type
PGTDTB:	CALLRET RSKP		;PGT$LP - Last page
	CALLRET RTXDAP		;PGT$SP - Simple data page
	CALLRET RTXFDB		;PGT$DP - Descriptor (FDB) page
	CALLRET RTXACP		;PGT$AP - Access controlled page

;Unknown page type - print warning and continue

RTXUNK:	MOVE T2,T1		;Copy the page type
	CALL CRIF
	TMSG <%Unknown paged record type encountered: >
	MOVEI T1,.PRIOU
	MOVEI T3,^D8
	NOUT%
	 TRN
	TCRLF
	RET

;Data page - write it to the local file

RTXACP:				;Access-controlled page is same for now
RTXDAP:	MOVE T1,LJFIDX		;Get index
	IFXE. F,F%DISK		;Not going to disk?
	  HRRZ T1,LJFTAB(T1)	;Get destination JFN
	  MOVE T2,[POINT 7,WINDOW] ;Point at file window
	  MOVE T3,TYXNDW	;Count the transferred bytes
	  IMULI T3,^D5		;And get byte count right
	  MOVNS T3		;Negative count
	  TXNN F,F%NULL		;Dont waste time on nil
	   SOUT%
	ELSE.
	  MOVE T2,PAGNO		;Here in the file
	  HRL T2,LJFTAB(T1)	;Make JFN,,Page
	  MOVX T1,<.FHSLF,,<WINDOW/1000>> ;Put the data in the file
	  MOVX T3,PM%WR		;Write access
	  PMAP%			;In it goes
	ENDIF.
	MOVE T1,TYXNDW		;Count the transferred byted
	ADDM T1,NBYTES		;..
	AOS NPAGES
	RET

;FDB record. Update FDB for local file.

RTXFDB:	TXNN F,F%DISK		;Only do this for disk files
	 RET
	MOVE T1,WINDOW		;Get fdb length word
	ANDI T1,77		;Only want length part
	CAIL T1,MINFDB		;Look like an FDB?
	 CAILE T1,MAXFDB+10	;...
	  JRST RTXFDZ		;No - FDB size out of range

	MOVX T4,<-FDBTXN,,0>	;Update the FDB
RTXFDL:	DO.
	  MOVE T1,LJFIDX	;get index
	  MOVE T1,LJFTAB(T1)	;Make pointer to FDB word
	  HRL T1,FDTXT1(T4)	;This word of FDB
	  MOVE T2,FDTXT2(T4)	;This mask to change
	  MOVE T3,FDTXT1(T4)	;From this word of net FDB
	  MOVE T3,WINDOW(T3)	;..
	  CHFDB%		;Put in the data
	  AOBJN T4,TOP.		;Loop for changeable words of FDB
	ENDDO.

;Get extra ASCIZ information after FDB into individual strings

	MOVX T4,<-FDTXSN,,0>	;Aobjn ptr for string table
	MOVE T1,TYXNDW		;Build ptr beyond end
	HRROI T1,WINDOW(T1)	;...
	PUSH P,T1		;Save it
	MOVE T1,WINDOW		;Build ptr to beginning
	ANDI T1,77		;...
	HRROI T1,WINDOW(T1)	;...
	SETZ T3,
	DO.
	  HRRO T2,FDTXST(T4)	;Dest ptr for current string
	  SIN			;Get it
	  IFJER.		;This should never happen
	    POP P,(P)
	    ECMSG <? SIN failure processing FDB strings - some FDB data lost>
	    RET			;And done with FDB
	  ENDIF.
	  IDPB T3,T2		;Make it Asciz
	  HRROI T1,1(T1)	;Beginning of next string
	  CAMLE T1,(P)		;At end yet?
	   EXIT.		;Yes
	  AOBJN T4,TOP.		;No, loop if more
	ENDDO.
	POP P,(P)		;Discard saved ptr

	MOVX T4,<-FDTXUN,,0>	;Aobjn ptr to table of writer strings
	MOVE T1,LJFIDX		;Get back jfn
	MOVE T1,LJFTAB(T1)	;...
	DO.
	  SKIPN T2,FDTXUS(T4)	;Did we get this far?
	   EXIT.		;No, stop
	  HLL T1,T2		;Yes, get function code
	  HRROS T2		;Make ptr
	  SFUST			;Set the writer
	   ERJMP .+1
	  AOBJN T4,TOP.		;Loop if more
	ENDDO.
	RET			;Done with FDB - should be done

;All of the format errors that can occur for paged transfers.

RTXPG0:	JSP T1,TRDERM
	ASCIZ/Paged header length was zero./
RTXHDB:	JSP T1,TRDERM
	ASCIZ/Paged header is too large./
RTXHDX:	JSP T1,TRDERM
	ASCIZ/Incomplete paged header received./
RTXDTZ:	JSP T1,TRDERM
	ASCIZ/Illegal size of data for paged transfer./
RTXDIN:	JSP T1,TRDERM
	ASCIZ/Incomplete paged data received./
RTXFDZ:	JSP T1,TRDERM
	ASCIZ/Illegal size of FDB for paged transfer./
RTXERE:	JSP T1,TRDERM
	ASCIZ/Read error on network data connection./

	SUBTTL Routines for handling TELNET connection

; Initialize connection parameters

;PREASC is used when a standard ascii connection (i.e. LIST/NLST commands)
;is desired.

PREASC:	MVI. "A",PARAM2+P.TYPE
	MVI. "N",PARAM2+P.TYP2
	MVI. "F",PARAM2+P.STRU
	MVI. "S",PARAM2+P.MODE
	MVI. ^D8,PARAM2+P.BYTE
	JRST PREDT1

PREDAT:	MOVX T1,<PARAMS,,PARAM2> ;Copy permanent PARAMS
	BLT T1,PARAM2+P.SIZE-1	;..
PREDT1:	SETZM F.ABRT		;Clear abort flag
	TXO F,F%DCLS		;Assume close required at EOF
	MOVE T1,PARAM2+P.MODE
	MOVE T2,PARAM2+P.STRU
	CAIE T1,"C"		;Mode compressed
	 CAIN T1,"B"		;or blocked
	  TXZ F,F%DCLS		;Don't have to close
	CAIN T1,"S"		;Mode S
	 CAIE T2,"P"		;And structure P
	  SKIPA			;...
	   TXZ F,F%DCLS		;Doesn't have to
	TXZ F,F%PAGD		;Assume not paged xfer
	CAIE T2,"P"		;Paged?
	IFSKP.			;Yes
	  TXO F,F%PAGD		;Set flag
	  MOVE T3,PARAM2+P.BYTE	;Get byte size
	  CAIN T3,^D36		;Only 36-bit is allowed for paged
	  IFSKP.
	    CMSG <?Paged mode transfer must be 36-bit bytesize.>
	    RET
	  ENDIF.
	  TXNN F,F%SEND		;Only need to check for disk if sending
	ANSKP.
	  MOVE T1,LJFIDX	;get index
	  HRRZ T1,LJFTAB(T1)	;Send. see if a disk
	  DVCHR%
	  LOAD T2,DV%TYP,T2
	  CAIN T2,.DVDSK	;Disk?
	ANSKP.			;Nope
	  CMSG <?Paged mode sends must be from DSK: files.>
	  RET
	ENDIF.

	TXNE F,F%DCLS		;Need to close after this transfer?
	TXNN F,F%DATC		;And have an open data connection already?
	IFSKP.			;Yes
	  HRROI T1,[ASCIZ/[Closing old data connection]
/]
	  SKIPN F.DBUG
	   PSOUT%		;Say we are doing this
	  CALL DCABRT		;Punt old data connection
	ENDIF.
	SETZM STRTMP
	MOVE T1,[POINT 7,STRTMP]
	MOVEI Q1,PARAM2
	CALL GETTYP
	MOVE T2,STRTMP		;Whole thing
	CAMN T2,PARAM3+P.XTYP	;Previous type same?
	IFSKP.			;Nope
	  MOVEM T2,PARAM2+P.XTYP ;Save value
	  HRROI T1,STRTMP
	  HRROI T2,[ASCIZ /TYPE /]
	  CALL TELCFM		;Set type & confirm it
	   JRST PREBAD		;Error...
	ELSE.			;Nope...
	  SKIPN F.VBOS		;Verbose?
	  IFSKP.
	    TCMSG <[Reusing old TYPE value]>
	  ENDIF.
	ENDIF.
	SKIPN T1,PARAM2+P.STRU	;Structure value
	 MOVEI T1,"F"		;Default is file
	MOVEM T1,PARAM2+P.STRU	;Update it
	HRROI T2,[ASCIZ /STRU /]
	CAMN T1,PARAM3+P.STRU	;Same as old?
	IFSKP.
	  CALL TELSCF		;No - send new one
	   JRST PREBAD		;Error
	ELSE.
	  SKIPN F.VBOS
	  IFSKP.
	    TCMSG <[Reusing old STRU value]>
	  ENDIF.
	ENDIF.
	SKIPN T1,PARAM2+P.MODE	;Mode
	 MOVEI T1,"S"		;Default is stream
	HRROI T2,[ASCIZ /MODE /]
	CAMN T1,PARAM3+P.MODE	;Same as old?
	IFSKP.
	  CALL TELSCF		;No - send new value
	   JRST PREBAD
	ELSE.
	  SKIPN F.VBOS
	  IFSKP.
	    TCMSG <[Reusing old MODE value]>
	  ENDIF.
	ENDIF.
	JXN F,F%NPRT,PREDT3	;If suppressing PORT, then done
;	SETZM LSNPRT		;Assume no port yet
	TXNN F,F%DCLS		;Are we allowed to use the old connection?
	SKIPG DATJFN		;And a connection exists?
	IFSKP.			;Yes - no new port
	  HRROI T1,[ASCIZ/[Reusing old data connection]
/]
	  SKIPE F.VBOS		;If verbose
	   PSOUT%		; Then say something
	  JRST PREDT3		;Go skip the port stuff
	ENDIF.
	SKIPE Q1,USRPRT		;User specified a port with Port cmd?
	IFSKP.			;Nope - generate one
	  AOS T1,TIMEX		;Get time based randomizing value
	  DPB T1,[POINT 8,Q1,^D35] ;Put 8-bits of time as low byte
	  MOVE T1,JOBNO		;Get job number
	  DPB T1,[POINT 8,Q1,^D27] ;Use it as high byte of port number
	ENDIF.
	MOVEM Q1,LSNPRT		;Save port number for listening
	MOVE T1,[POINT 7,STRTMP]
	MOVEI T2,PRTSTR		;Host number part of port number
	CALL MOVSTR		;Put it on first
	MOVEI T2,","		;Add punctuation
	IDPB T2,T1
	MOVEI T3,^D10		;Decimal for numbers...
	LDB T2,[POINT 8,Q1,^D27] ;High byte of port number
	NOUT%
	 TRN
	MOVEI T2,","
	IDPB T2,T1
	LDB T2,[POINT 8,Q1,^D35] ;Low byte of port number
	NOUT%
	 TRN
	HRROI T1,STRTMP		;This buffer
	HRROI T2,[ASCIZ /PORT /];The command
	CALL TELCFM		;Send down TELNET conn & wait for confirm
	 JRST PREBAD		;Error...
PREDT3:	AOS (P)			;Indicate good return
	MOVX T1,<PARAM2,,PARAM3>
	BLT T1,PARAM3+P.SIZE-1	;Save params just used
	RET			;Return

;Complain if we can't init the connection

PREBAD:	ECMSG <Failed to initialize data connection.>
	RET


	SUBTTL Inferior fork routines

RFRKSA:	MOVE F,GBLFWD		;Get flags
	MOVE P,[IOWD NPDL,PDL]	;Local process stack
	DO.
	  SETZM RCVLIN		;Start of line. clear buffer.
	  MOVX T1,<RCVLIN,,RCVLIN+1>
	  BLT T1,RCVLIN+RCVLSZ-1 ;..
	  MOVE P4,[POINT 7,RCVLIN] ;Point to start of buffer
	  MOVEI P5,RCVLSZ*5	;Count line length
	  DO.
	    MOVE T1,TELJFN
	    $BIN
	     ERJMP TNRERR	;Failure - close connections
	    IFE. T2		;Null character?
	      $GTSTS
	      TXC T2,GS%OPN!GS%RDF
	      TXNE T2,GS%OPN!GS%RDF!GS%EOF
	       JRST TNRERR
	      SETZ T2,
	    ENDIF.
	    SKIPN F.DBUG	;Debugging FTP server?
	    IFSKP.		;Yes
	      MOVE T1,T2	;Get character
	      PBOUT%		;and print it...
	      LOOP.		;Just loop
	    ENDIF.
	    JUMPE T2,TOP.	;Skip nulls,
	    CAIE T2,.CHCRT	;Cr's and
	     CAIL T2,200	;Telnet control character?
	      LOOP.		;Skip
	    CAIN T2,.CHLFD	;Lf is EOL
	     EXIT.		;Have a line, then
	    IDPB T2,P4		;No. store character in input buffer.
	    SOJG P5,TOP.	;Count in case of huge line
	  ENDDO.
	  SETZ T2,		;Make sure a null at end
	  IDPB T2,P4
	  MOVX T1,<RCVLIN,,RCVMSG> ;Copy last message for later perusal
	  BLT T1,RCVMSG+RCVLSZ-1 ;    ie, by other forks.
	  SETZB T1,P5		;Clear number and digit counter
	  MOVE P4,[POINT 7,RCVLIN]
	  DO.
	    ILDB T2,P4		;Get a reply code digit
	    CAIL T2,"0"		;Decimal digit?
	     CAILE T2,"9"	;..
	      EXIT.		;Nope - done with reply code, then
	    IMULI T1,^D10	;Yes. accumulate decimal number
	    ADDI T1,-"0"(T2)	;..
	    AOJA P5,TOP.	;Count digits. loop.
	  ENDDO.
	  MOVEM T2,REPEON	;Remember terminating character
	  SKIPN P5		;Were there any digits in number?
	   SETO T1,		;No. make a phony reply value.
	  MOVEM T1,REPCOD	;Store reply code
	  MOVSI P5,-NREPS	;Counter for number of known replies
	  DO.
	    LOAD T2,RC%NUM,REPTAB(P5) ;Get a known reply
	    CAMN T2,REPCOD	;Is that what we got?
	     JRST TNRFND	;Reply found.
	    AOBJN P5,TOP.	;No. loop
	  ENDDO.
	  CALL CRIF
	  MOVEI T1,"<"
	  PBOUT%
	  HRROI T1,RCVLIN	;Funny reply. not found. type it.
	  PSOUT%
	  TCMSG <>
	  JRST TNRFN1		;To rest of reply handler

TNRFND:	  MOVE T2,REPTAB(P5)	;Get bits for what to do.
	  SKIPN F.VBOS		;Verbose?
	  IFSKP.		;Yup
	    TXZ T2,RC%TTX	;Yes. diddle up flags
	    TXO T2,RC%TWL	;..
	  ENDIF.
	  IFXN. T2,RC%TWL!RC%TTX ;Want to type this one?
	    CALL CRIF
	    MOVEI T1,"<"	;Herald prefixing server typeout
	    PBOUT%		;Yes. prefix character first
	    SETO T1,
	    ADJBP T1,P4
	    TXNE T2,RC%TTX	;Type text?
	    PSOUT%		;Yes.
	    HRROI T1,RCVLIN	;Type whole thing?
	    TXNE T2,RC%TWL	;..
	    PSOUT%		;Yes.
	    TCMSG <>
	  ENDIF.
	  LOAD T3,RC%DSP,REPTAB(P5) ;Dispatch address, if any.
	  SKIPE T3		;Have one?
	   CALL (T3)		;Call appropriate routine
TNRFN1:	  MOVE T1,REPCOD	;Get the reply number
	  IFXN. T2,RC%ABO	;Is this one an abort?
	    SETOM F.ABRT	;Tell superior
	    MOVX T1,.FHSUP	;Interrupt superior
	    MOVX T2,1B<ABOCHN>	;On abort channel
	    IIC%
	    LOOP.		;And loop for another line
	  ELSE.			;Not an abort
	    SKIPE REPINT	;Superior wants an interrupt?
	     SKIPGE REPCOD	;Is this a real response?
	      LOOP.		;Nope - done
	    MOVX T1,.FHSUP	;Superior handle
	    MOVX T2,1B<INFCHN>	;Info channel
	    IIC%		;Interrupt him...
	    LOOP.		;And back again
	  ENDIF.
	ENDDO.


;Come here on TELNET connection I/O failure

TNRERR:	SKIPE F.TCLS		;Close request already in?
	 HALTF%			;Yes, just quit
	CMSG <-- Connection closed -->
	JRST TNRCLS		;And close up


;Special acknowlegement routines


;221 - QUIT reply

REP221:	MOVX T1,.FHSUP		;Superior
	MOVX T2,1B<INFCHN>	;Info channel
	IIC%			;Indicate that a reply is in...
TNRCLS:	SETOM F.TCLS		;Request close of TELNET connection
	MOVEI T1,.FHSUP
	MOVX T2,1B<ABOCHN>
	IIC%
	HALTF%

;777 - debug/breakpoint (TOPS-20 only hack)

REP777:	SETOM F.DBUG		;Flag this
	MOVX T1,.FHSUP
	MOVX T2,1B<INFCHN>	;Info channel
	IIC%			;Tell him
	RET

;227 - Entering Passive Mode.  h1,h2,h3,h4,p1,p2

REP227:	SETZ T1,
	PUSH P,T1		;For Host
	PUSH P,T2		;For Port
	MOVX T3,<POINT 8,-1(P),3> ;Point to temp for host (rigth justified)
	ADDI P4,1		;Move over five characters, "PORT "
	MOVX T4,<-6,,0>		;Six bytes
	DO.			;Top of outer loop for each byte
	  SETZ T1,		;See if we can read a number
	  DO.			;Top for each char in each byte
	    ILDB T2,P4		;Character
	    CAIL T2,"0"		;Digit?
	     CAILE T2,"9"
	      EXIT.
	    IMULI T1,^D10
	    ADDI T1,-"0"(T2)	;Add in the digit
	    LOOP.		;aand back for another one
	  ENDDO.
	  CAIL T1,0		;Range check bytes
	   CAILE T1,255
	    EXIT.		;Lose
	  IDPB T1,T3		;Stash the byte
	  AOBJN T4,TOP.		;Get next byte
	ENDDO.
	POP P,T2		;Port
	LSH T2,^D<16-36>	;Right justify
	POP P,T1		;Host (already justified)
	IFXN. T4,.LHALF		;Got all the bytes?
	  ECMSG <Invalid PORT reply received>
	ELSE.
	  MOVEM T4,PRT227	;Store for receive fork to see.
	ENDIF.
	RET			;Return to TELNET dispatcher.

;226 - Closing data connection
;250 - File action completed
;(These are the same, functionally)

REP226:
REP250:	SETOM F.DTDR		;Done reply is in
	SETZM F.DTIP		;No longer in progress
	RET

;CKTRAN- Check flags + last reply code and do an error message if appropriate
;	CALL CKTRAN
;	Returns +1 if there was an error to report
;		+2 otherwise
;
;CKTRAQ- Quiet entry.  Same as CKTRAN, but don't output anything

CKTRAN:	TDZA T4,T4		;Noisy
CKTRAQ:	SETO T4,		;Quiet
	MOVEM T4,QUIETF		;Remember
	MOVE T1,REPCOD		;Get last reply code
	CAIGE T1,ABTCOD		;Did last response look bad?
	IFSKP.
	  HRROI T1,RCVMSG	;Yes, use foreign string as errmsg
	  SKIPN QUIETF		;Skip if quiet
	  ESOUT%		;Write it standardly
	   ERJMP .+1
	  RET			;Ret +1 
	ENDIF.
	AOS (P)			;Return +2 
	RET

	SUBTTL Misc routines

BOMB:	CALL CRIF
	EMSG <"Impossible error in" FTP at location >
	HRRZ T2,(P)
	SOS T2,
	MOVX T1,.PRIOU
	MOVX T3,FLD(^D8,NO%RDX)
	NOUT%
	 ERJMP .+1
	HALTF%			;Halt and restart
	JRST GO

HALTGO:	CALL ERROR
	HALTF%			;Halt and restart
	JRST GO

;Routines for statistics (hash mark printing)

PRHASH:	TXNN F,F%HASH		;Wants hash marks?
	 RET			;Nope
	PUSH P,T1		;Save T1
	MOVEI T1,"#"
	PBOUT%			;Print the mark
	POP P,T1		;Restore T1
	RET

PRHEND:	TXNN F,F%HASH		;Is he getting hash marks?
	 RET			;Nope
	PUSH P,T1		;Save T1
	TCMSG <>		;End the string of hash marks
	POP P,T1		;Restore T1
	RET

;Subroutine to send stuff on the telnet connection

TELSND:	SAVEAC <T1,T2,T3,T4>
	SETZM REPOK		;Clear response indicators
	SETZM REPCOD
	DMOVE T3,T1
	MOVE T1,[POINT 7,TELBUF]
	MOVE T2,T4
	CALL MOVSTR
	MOVE T2,T3
	CALL MOVSTR
	MOVEI T2,[ASCIZ /
/]
	CALL MOVST0
	MOVE T1,TELJFN
	HRROI T2,TELBUF
	SETZB T3,T4
	$SOUT
	IFJER.
TELSER:	  CMSG <-- Connection closed -->
	  CALL TCLOSE
	  RET
	ENDIF.
	SKIPN F.VBOS		;Verbose?
	IFSKP.			;Then print what was just sent
	  CALL CRIF
	  HRROI T1,TELBUF
	  PSOUT%
	  MOVE T1,TELJFN
	ENDIF.
	MOVX T2,.MOSND		;Send accumulated buffer
	$MTOPR			;..
	 ERJMP .+1
	RET

;Send one character to TELNET connection. Called with character in T1

TELBOU:	SAVEAC <T1,T2>		;Preserve these
	MOVE T2,T1		;Copy char
	MOVE T1,TELJFN		;Get TELNET connection handle
	$BOUT			;Try bout
	 ERJMP TELSER		;Error - connection dead
	SKIPN F.VBOS		;Verbose?
	IFSKP.			;Yes
	  MOVEI T1,.PRIOU	;To primary output
	  BOUT%			;Write the character
	  MOVE T1,TELJFN	;Get back jfn
	ENDIF.
	MOVX T2,.MOSND		;PUSH function
	$MTOPR			;Force send to happen
	 ERJMP .+1		;Ignore failure
	RET

;Routine to send strings & await confirmation
;Accepts: T1,T2/ Args to TELSND
;Returns: +1 on abort confirm
;         +2 otherwise

TELCFM:	SETZM F.ABRT		;No abort received yet
	SETOM REPINT		;Indicate we want an interrupt
	CALL TELSND		;Send the buffer
	MOVEI T2,6		;Set up wait reply loop
	DO.
	  SKIPE REPOK		;Check if got reply...
	   EXIT.		;Got it
	  MOVE T1,TIMVAL	;Timeout quantum
	  IMULI T1,^D5000	;Multiply by 5 seconds
	  DISMS%		;Wait for a response
	  SOJG T2,TOP.		;Loop unless timed out
	ENDDO.
	SKIPE REPOK		;Got a response?
	IFSKP.			;Nope...
TELTIM:	  ECMSG <Timeout waiting for confirmation reply>
	  MOVE T1,LJFIDX	;Current JFN index
	  MOVEI T1,LJFTAB(T1)	;Get pointer to jfn
	  CALL CLOSER		;Close it
	  SETZM LJFIDX		;Kill index
	  JRST TELRBD		;Return bad
	ENDIF.
	SKIPN F.ABRT		;Have an abort?
	 AOS (P)		;Nope - indicate successful return
TELRBD:	SETZM REPINT
	RET			;And return

;Routine to send strings & await possible multiple confirmations
;Accepts: Same as TELCFM
;Returns: Same as TELCFM

TELCFX:	SETZM F.ABRT		;No aborts yet
	SETOM REPINT		;Want interrupts
	CALL TELSND		;Send it
	DO.
	  MOVE T1,TIMVAL	;Time quantum
	  IMULI T1,^D10000	;Make 10 seconds
	  SKIPN REPOK		;Reply already in?
	   DISMS%		;Wait for it...
	  SKIPN REPOK		;Came in?
	   JRST TELTIM		;Timeout...
	  SKIPE F.ABRT		;Check for an abort
	   EXIT.		;Yup
	  SETZM REPOK		;Clear flag
	  MOVE T1,REPEON	;What character terminator?
	  CAIN T1,"-"		;- means more text to come
	   LOOP.		;So loop for it
	  AOS (P)		;Got what we came for...
	ENDDO.
	SETZM REPINT		;No more interrupts
	RET

;Subroutine to close open connections

TCLOSE:	SKIPLE T1,RFORKH
	 KFORK%
	CALL DCABRT		;Nuke data connection
	CLOSD TELJFN,CZ%ABT	;Close TELNET & abort late data
	SETOM RFORKH
	SETZM F.TCLS		;Request for close has been satisfied
	TXZ F,F%OPEN		;No longer have an open connection
	SETZM PARAM3		;Say have sent no PARAMS
	MOVX T1,<PARAM3,,PARAM3+1>
	BLT T1,PARAM3+P.SIZE-1
	RET

;Subroutine to send a letter-param to telnet conn
;Call:	T1/ the character

TELSP:	SETZM STRTMP
	DPB T1,[POINT 7,STRTMP,6]
	HRROI T1,STRTMP
	JRST TELSND		;Mostly just use telsnd routine

;As above, but do confirmation (via TELCFM)

TELSCF:	SETZM STRTMP
	DPB T1,[POINT 7,STRTMP,6]
	HRROI T1,STRTMP
	JRST TELCFM

	SUBTTL Random file routines

;Close data connection down

DCLCHK:	TXNE F,F%DCLS		;Need to close data connection?
	 CALLRET DCLOSE		;Do normal data connection close
	RET			;No. Don't do anything

DCABRT:	SKIPA T1,[CZ%ABT!DATJFN] ;Entry to abort connection
DCLOSE:	MOVEI T1,DATJFN		;Point at data conn jfn
DCLOS1:	CALL CLOSER		;Entry with flags and JFN set up in T1
	TXZ F,F%DATC		;Don't have a data connection any more
	RET

;Close & release a file (connection)
;T1/ Flags,,Connection

CLOSER:	PUSH P,T1		;Save flags & pointer
	HRRZS T1		;Get just the address
	SKIPLE (T1)		;Anything there?
	IFSKP.			;Nope.
	  POP P,T1		;Restore
	  RET			;And quit
	ENDIF.
	PUSH P,T2
	HRRZ T1,(T1)
	$GTSTS
	HLL T1,-1(P)		;Get flags back...
	IFXN. T2,GS%OPN		;File open?
	  $CLOSF		;Close it, then
	   TRN
	ELSE.
	  IFXN. T1,777600	;TCPSIM connection?
	    MOVE T1,T.JCN(T1) ;Get the JCN
	    TXO T1,TCP%JS
	    ABORT%		;Abort unopened connection
	     TRN
	  ELSE.
	     RLJFN%	;JFN
	      TRN
	  ENDIF.
	ENDIF.
	POP P,T2
	POP P,T1
	SETOM (T1)
	RET

CLOSEK:	SKIPG (T1)
	RET
	PUSH P,T1
	HRRZ T1,(T1)
	TXO T1,CO%NRJ
	CLOSF%
	 TRN
	POP P,T1
	RET

;Subroutine to make an inferior. Returns handle in P5.

MAKFRK:	MOVX T1,CR%CAP		;Pass on capabilities
	CFORK%			;Make the fork
	 RET			;Can't
	RPCAP%			;Make it legal to psi the superior
	TXO T2,SC%SUP		;..
	TXO T3,SC%SUP		;..
	EPCAP%
	MOVEM F,GBLFWD		;Save flags
	MOVE P5,T1		;Copy for return from this routine
	MOVX T1,<.FHSLF,,770>	;Is ddt present?
	RPACS%
	JXE T2,PA%PEX,MAKFK1	;Page doesn't exist
	MOVX T3,PM%RWX!PM%CNT!FLD(1000,PM%RPT) ;Pretend storage runs to top
	TRNA
MAKFK1:	MOVX T3,PM%RWX!PM%CNT!FLD(PSPAGE,PM%RPT) ;Top of storage
	HRLZI T1,.FHSLF		;This process, page 0
	HRLZ T2,P5		;Inferior handle
	PMAP%			;Create the page in inferior
	MOVX T3,PM%CNT!FLD(<<PSTOP-PSBASE+777>/1000>,PM%RPT) ;All private pages
	SETO T1,		;Make page go away in inferior
	HRLZ T2,P5		;Fork handle
	HRRI T2,PSPAGE		;Page number
	PMAP%			;All gone
;	HRLI T2,.FHSLF		;Now let go of it in top fork
;	PMAP%
	RETSKP

	SUBTTL Interrupt routines

;Telnet data arrived interrupt. IIC%ed by TELNET fork if REPINT is nonzero.

INFINT:	SETOM REPOK		;Indicate that a reply came
	DMOVEM T1,1(P)		;Save T1 and T2 past the SP
	MOVE T1,RETPC2		;Get interrupted PC
	MOVE T2,-1(T1)		;Get instruction there
	IORX T1,PC%USR		;Set user bit to alter PC
	CAME T2,[DISMS%]	;Timed wait?
	CAMN T2,[WAIT%]		;Or simple wait?
	MOVEM T1,RETPC2		;Yes - make the wait return
	SKIPE F.DBUG		;Debug requested?
	 CALL DODBUG		;Yes - go to it now
	DMOVE T1,1(P)		;Restore saved ACs
	DEBRK%			;That's all...

;Telnet abort interrupt. IIC%ed by TELNET fork if abort received.

ABOINT:	DMOVEM T1,SAVET1	;Save a couple of acs
	SKIPN F.TCLS		;Connection close pending?
	IFSKP.
	  CALL TCLOSE		;Close connections
	ELSE.
	  MOVEI T1,"G"-100	;Type a bell
	  SKIPN BATFLG		;If batch job, then skip this.
	   PBOUT%
	  TXNE F,F%DATC		;Have data connection?
	   CALL DCLCHK		;Close it, if necessary
	ENDIF.
	MOVE T1,RETPC3		;Get interrupted PC
	MOVE T2,-1(T1)		;Get instruction there
	IORX T1,PC%USR		;Set user bit to alter PC
	CAME T2,[DISMS%]	;Timed wait?
	CAMN T2,[WAIT%]		;Or simple wait?
	MOVEM T1,RETPC3		;Yes - make the wait return
	SETOM F.ABRT		;Set abort flag
	SETOM REPOK		;Indicate that a reply came
ABORTN:	DMOVE T1,SAVET1		;Restore acs
	DEBRK%

;Control-A interrupt. Prints progress on data transfer.

CAINT:	PUSH P,T1		;Preserve registers
	PUSH P,T2
	PUSH P,T3
	PUSH P,T4
	CALL CAINTX		;Do the work
	POP P,T4
	POP P,T3		;Restore some ACs
	POP P,T2
	POP P,T1
	DEBRK%
	
CAINTX:	CALL CRIF
	SKIPN F.DTIP		;Data transfer in progress?
	 JRST CAINT2		;Nope.
	MOVEI T1,"["
	PBOUT%
	MOVEI T1,.PRIOU
	MOVE T2,NBYTES		;Number of bytes
	MOVEI T3,^D10		;In decimal
	NOUT%
	 TRN
	MOVE T2,P.TYPE+PARAM2	;Get transfer type
	CAIE T2,"L"		;Logical byte mode?
	IFSKP.			;Yes - print byte size
	  MOVEI T2,"("
	  BOUT%
	  MOVE T2,P.BYTE+PARAM2	;Get byte size
	  NOUT%			;Print it
	   TRN
	  MOVEI T2,")"
	  BOUT%
	ENDIF.
	TMSG < bytes >
	SKIPN NPAGES		;Any page count?
	IFSKP.
	  MOVEI T1,"("
	  PBOUT%
	  MOVEI T1,.PRIOU
	  MOVE T2,NPAGES
	  MOVEI T3,^D10
	  NOUT%
	   TRN
	  TMSG < pages) >
	ENDIF.
	HRROI T1,[ASCIZ/received /]
	TXNE F,F%SEND		;Which direction...?
	 HRROI T1,[ASCIZ/sent /]
	PSOUT%
	TMSG <for file >
	MOVEI T1,.PRIOU
	MOVE T2,LJFIDX		;Index of current jfn
	HRRZ T2,LJFTAB(T2)	;Get the jfn itself
	SETZB T3,T4
	JFNS%
	IFJER.
	  TMSG <?>		;Handle failure...
	ENDIF.
	TCMSG <]>
	RET
CAINT2:	TCMSG <[No data transfer in progress]>
	RET


;Control-G interrupt - Abort current operation

CGINT:	PUSH P,T1		;Save all temps
	PUSH P,T2
	PUSH P,T3
	PUSH P,T4
	CALL CGINTX
	POP P,T4
	POP P,T3
	POP P,T2
	POP P,T1
	DEBRK%

CGINTX:	MOVEI T1,"G"-"@"	;Control-G
	PBOUT%			;Print it
	MOVEM P,CGSVSP		;Save stack pointer
	MOVE T2,ABTSP		;Get stack pointer
	SKIPE (T2)		;Anything there?
	IFSKP.			;No.
	  CALL CRIF
	  TCMSG <[No abortable operation in progress]>
	  RET			;Done
	ENDIF.
	DO.
	  POP T2,T1		;Get address
	  MOVEM T2,ABTSP	;Update pointer
	  CALL (T1)		;Call appropriate routine
	  MOVE T2,ABTSP
	  SKIPE (T2)		;Done yet?
	  LOOP.			;No - do next
	ENDDO.
	RET
CGRET:	MOVE P,CGSVSP		;Restore stack pointer
	RET			;And return

;Here when abort during data transfer
;*NOTE* This code still crashes remote servers. Someone should fix this.

DTRABT:	CALL CRIF		;Make a newline
	TCMSG <Aborting data transfer...>
	MOVE T1,FRNOPS		;Check 4N opsys type
	CAIE T1,.HST20		;TOPS-20?
	CAIN T1,.HS10X		;Or TENEX?
	IFSKP.			;Nope.
	  MOVEI T1,[0]
	  MOVEI T2,[ASCIZ/ABOR/] ;Use ABOR command, then
	  CALL TELSND		;Send abort request
	ELSE.
	  MOVEI T1,"C"-"@"	;Control-C
	  CALL TELBOU
	ENDIF.
	SETOM F.ABRT		;Make an abort
	CALLRET DTRABO		;Return through abort code

;Here when abort during multiple-get

MGABRT:	CALL MABQRY		;Really do it?
	 JRST CGRET		;No - just return (data xfer aborted)
	JRST MGABT1

;Here when abort during multiple-send

MSABRT:	CALL MABQRY		;Really want to abort all transfers?
	 JRST CGRET		;No...
	MOVE T4,LJFIDX		;Get number of JFNS
	JRST MSABR1		;Clean up after it...

MABQRY:	DO.
	  MOVX T1,.PRIIN
	  CFIBF%
	  TMSG <Abort remainder of multiple transfer?>
	  PBIN%			;Get answer
	  MOVE T2,T1
	  TCRLF
	  ANDX T2,137		;Force uppercase
	  CAIN T2,"Y"		;Yes?
	  RETSKP		;Success-return
	  CAIN T2,"N"
	  RET			;Done
	  ECMSG <Please answer "Y" or "N">
	  LOOP.
	ENDDO.

;Control-B interrupt. Causes FTP to continue in the background.

CBINT:	PUSH P,T1
	PUSH P,T2
	PUSH P,T3
	PUSH P,T4
	MOVX T1,<.PRAST,,.FHSLF>
	MOVEI T2,T4
	MOVEI T3,1
	MOVX T4,<3,,0>
	PRARG%
	HALTF%
	POP P,T4
	POP P,T3
	POP P,T2
	POP P,T1
	DEBRK%

;Control-P interrupt. Causes push to inferior exec.

CPINT:	PUSH P,T1
	PUSH P,T2
	PUSH P,T3
	CALL PUSH1
	HRRZ T1,RETPC3
	SUBI T1,1
	MOVE T1,(T1)
	CAME T1,[COMND%]
	IFSKP.
	  MOVE T1,EFORKH
	  WFORK%
	   ERCAL HALTGO
	  DMOVE T1,NAMES	;Restore old names
	  SETSN%
	   ERCAL HALTGO
	  SETZM PUSHED
	ELSE.
	  SETOM PUSHED
	ENDIF.
	POP P,T3
	POP P,T2
	POP P,T1
	DEBRK%

	SUBTTL	String subroutines

MOVSTR:	SAVEAC <T4>
	HRLI T2,(<POINT 7,0>)
MOVST1:	ILDB T4,T2
	JUMPE T4,R
	IDPB T4,T1
	JRST MOVST1

;Move string and terminating null

MOVST0:	SAVEAC <T4>
	HRLI T2,(<POINT 7,0>)
MOVST2:	ILDB T4,T2
	IDPB T4,T1
	JUMPN T4,MOVST2
	RET

	END <3,,ENTVEC>
