;[SRI-NIC]SRC:<LOC.SYSTEM>TTYINI.MAC.4,  8-Aug-88 23:24:33, Edit by MKL
; add SUN ttytype
;ACCT:<UTILITIES.SUBSYS>TTYINI.MAC.12,  9-Jul-81 12:27:02, Edit by J.JQJOHNSON
; Colon after /ADDRESS:.
;ACCT:<UTILITIES.SUBSYS>TTYINI.MAC.11, 30-Jun-81 16:51:32, Edit by R.RMK
; Put out the line in error when error encountered.
;ACCT:<UTILITIES.SUBSYS>TTYINI.MAC.10, 21-Apr-81 01:22:51, Edit by B.BOMBADIL
; add ZENITH-19 as a synonym for HEATH-19
;ACCT:<UTILITIES.SUBSYS>TTYINI.MAC.9,  8-Apr-81 17:20:38, Edit by B.BOMBADIL
; have PMAP% preload pages of binary file to reduce user's wait time
;ACCT:<UTILITIES.SUBSYS>TTYINI.MAC.8,  3-Apr-81 00:08:53, Edit by B.BOMBADIL
; fix bug in neighbor parsing pointed out by Bob Kanefsky
;<B.BOMBADIL>TTYINI.MAC.5, 28-Mar-81 02:20:58, Edit by B.BOMBADIL
;<B.BOMBADIL>TTYINI.MAC.2, 28-Mar-81 01:02:54, Edit by B.BOMBADIL
; set up /PRINT-NODE: switch and set job location
; if no value is given, the location is set to LOCAL::
; change version number to 2 (tty records are now 18. words long)
;ACCT:<UTILITIES.SUBSYS>TTYINI.MAC.5, 14-Feb-81 13:01:33, Edit by J.JPBION
; for now, give a list of suggested names for LOCTAB: values.
;  FINGER and NLINE use these
;ACCT:<UTILITIES.SUBSYS>TTYINI.MAC.4, 14-Feb-81 12:59:43, Edit by B.BOMBADIL
; fix duplicate location code (ERL206==14)
;ACCT:<UTILITIES.SUBSYS>TTYINI.MAC.3, 11-Nov-80 14:12:24, Edit by J.JQJOHNSON
; start adding LOTSW switches for planned move to GSB.
;ACCT:<UTILITIES.SUBSYS>TTYINI.MAC.2, 11-Nov-80 13:29:37, by J.JQJOHNSON
; rework reading binary file to use values specifed in TTYINI command line
;PS:<J.JQJOHNSON>TTYINI.MAC.11 28-Oct-80 14:56:06, Edit by J.JQJOHNSON
; improve documentation and help message
;<J.JQJOHNSON>TTYINI.MAC.10, 28-Oct-80 11:07:45, Edit by J.JQJOHNSON
; on reading binary file, type number is a number rather than a routine
;<J.JQJOHNSON>TTYINI.MAC.6, 24-Oct-80 20:43:47, Edit by J.JQJOHNSON
; convert format of /BINARY-FILE to 16 words per tty and name TTYINI.BIN
;<B.BOMBADIL>TTYINI.MAC.3, 23-Oct-80 22:08:28, Edit by B.BOMBADIL
; Add /BINARY-FILE command and supporting code.
;  Changes are enclosed in IFN/IFE BINSW switches.
;ACCT:<ADMINISTRATION.PROGRAMS>TTYINI.MAC.115,  6-Oct-80 17:10:34, J.JQJOHNSON
; add GILLOTINE and IBM-3101 keywords
; binary file handling commented out for now
;<J.JQJOHNSON>TTYINI.MAC.114,  4-Jun-80 13:26:40, Edit by J.JQJOHNSON
; add support for reading binary info from TTYDAT.BIN if it exists
; add CTLSF and support for /[NO]PAUSE-ON-COMMAND
;<J.JQJOHNSON>TTYINI.MAC.112,  3-Jun-80 08:43:28, Edit by J.JQJOHNSON
;correct alphabetization of TAB keyword
;<STANFORD-UTILITIES>TTYINI.MAC.111,  6-Apr-80 03:24:16, Edit by ADMIN.MRC
;<STANFORD-UTILITIES>TTYINI.MAC.110,  6-Apr-80 03:18:56, Edit by ADMIN.MRC
;<STANFORD-UTILITIES>TTYINI.MAC.109,  6-Apr-80 03:11:11, Edit by ADMIN.MRC
;<STANFORD-UTILITIES>TTYINI.MAC.108,  6-Apr-80 02:52:55, Edit by ADMIN.MRC
;<STANFORD-UTILITIES>TTYINI.MAC.107,  6-Apr-80 01:55:59, Edit by ADMIN.MRC
;<STANFORD-UTILITIES>TTYINI.MAC.106,  6-Apr-80 01:54:06, Edit by ADMIN.MRC
;Changes for Stanford operation
;<HELLIWELL>TTYINI.MAC.105, 29-Mar-80 21:08:06, EDIT BY HELLIWELL

TITLE	TTYINI - SET TERMINAL CHARACTERISTICS

SEARCH MONSYM,MACSYM
.REQUIRE SYS:MACREL
EXT <JSMSG0>
SALL

BINSW==1			;BINARY FILE CREATION OPTION IS ON

VGROUP==4			;edit by customer
VMAJOR==15
VMINOR==2
VEDIT==14

DEFINE DATE<ASCIZ \28-March-81\>

A=1
B=2
C=3
D=4
E=5

;16 IS USED BY MACSYM

P=17

MAXCHR==^D200

MAXLEN==<MAXCHR+5>/5

ABCHR==^D50

ABLEN==<ABCHR+5>/5

PDLLEN==20


DEFINE JCERR(TEXT)<
	 ERCAL [JSMSG<TEXT>
		RET]>

DEFINE JSMSG(TEXT,CHAR)<
IFB<CHAR><TMSG <
?>>
IFNB<CHAR><TMSG <
CHAR>>
IFNB<TEXT><TMSG <TEXT: >>
	CALL JSMSG0
>

DEFINE FMSG(TEXT)<
	HRROI B,[ASCIZ \TEXT\]
	SETZ C,
	SOUT
>

DEFINE FCHR(CHR)<
	MOVEI B,CHR
	BOUT
>

DEFINE FVER<
	FMSG (\VMAJOR)
IFN VMINOR,<
IFG VMINOR-^D26,<
	VMIN1==<VMINOR-1>/^D26
	FCHR <"A"+VMIN1-1>
>
	VMIN1==VMINOR-<<VMINOR-1>/^D26*^D26>
	FCHR <"A"+VMIN1-1>
>
IFN VEDIT,<
	FCHR<"(">
	FMSG(\VEDIT)
	FCHR<")">
>
IFN VGROUP,<
	FCHR<"-">
	FMSG(\VGROUP)
>
>
SUBTTL	MACROS

;LOAD A BLOCK WITH DATA AND ALLOCATE ENOUGH SPACE
;FOR LARGEST WORD

DEFINE LDBLK(LIST)<
..LEN==0
	IRP LIST,<.LDWRD(LIST)>
	.ORG .+..LEN
>

;USED TO STRIP OFF <>

DEFINE .LDWRD(A)<LDWRD(A)>

;LOAD 1 WORD CHECK MAX LENGTH

DEFINE LDWRD(A,B,C)<
	.ORG .+<A>
IFNB<C><C:>
	IFB<B>,<0;>B
	.ORG .-<A>-1
IFGE <A>-..LEN,<..LEN==<A>+1>
>

;KEYWORD TABLE MACROS

DEFINE TABLE<
	...BEG==.
	BLOCK 1
>

DEFINE TEND<
...LEN==.-...BEG
.ORG ...BEG
	...LEN-1,,...LEN
.ORG .+...LEN
>

DEFINE T(TEXT,VALUE)<	[ASCIZ \TEXT\],,VALUE>

;LOAD A FUNCTION DESCRIPTOR BLOCK
;USE FLDDB. MACRO FROM MONSYM. ARGS AS FOLLOWS:
;FLDDB.(TYP,FLGS,DATA,HLPM,DEFM,LST)
;TYP	COMND FUNCTION CODE (I.E. .CMKEY)
;FLGS	FLAGS (I.E. CM%SDH, SUPPRESS DEFAULT HELP)
;DATA	ARG TO SPECIFIC FUNCTION (I.E. RADIX FOR .CMNUM)
;HLPM	USER SUPPLIED HELP STRING (AUTOMATICALLY SETS CM%HPP)
;DEFM	DEFAULT STRING (AUTOMATICALLY SETS CM%DPP)
;LST	POINTER TO NEXT FUNCTION DESCRIPTOR BLOCK

;DEFINE SINGLE DATA WORD (OR WORDS)

DEFINE DATA(ADDR,SIZE)<
ADDR:	IFB<SIZE>,<BLOCK 1;>BLOCK SIZE
>

DEFINE CONFIRM(ERROR)<
	CALL DOCFM
IFB<ERROR>< JRST COMERR>
IFNB<ERROR>< JRST ERROR>
>


DEFINE NIY<
	TMSG <
?Not implemented yet.
>
	JRST COMLOP
>

DEFINE COMINI(TEXT)<
IFNB<TEXT><HRROI A,[ASCIZ \TEXT\]>
IFB<TEXT><HRROI A,CMBUF>
	MOVE B,[.PRIIN,,.PRIOU]
	CALL DOINI
>

DEFINE FIELD(FDB,ERROR)<
	MOVEI B,FDB
	CALL DOCOM
IFB<ERROR>< JRST COMERR>
IFNB<ERROR>< JRST ERROR>
>

DEFINE RFIELD(FDB)<
	MOVEI B,FDB
	MOVEI A,CMSTAT
	COMND
	 ERJMP ERSCAN
	TXNE A,CM%NOP
	JRST ERSCAN
>

DEFINE CHECK(ADDR,NAME)<
	SKIPL ADDR
	JRST [	SKIPE FILEF
		RETSKP
		TMSG <?Cannot give NAME more than once
>
		RET]
>

DEFINE DEFAULT(SWIT,VAL)<
	MOVEI A,VAL
	SKIPGE SWIT
	MOVEM A,SWIT
>
SUBTTL	DATA AREA

EV:	JRST STRT
	JRST STRT
JOBVER:	BYTE (3)VGROUP(9)VMAJOR(6)VMINOR(18)VEDIT
EVL==.-EV

PDL:	BLOCK PDLLEN


;IPCF stuff
FkPid:	.IPCIW			;function
	0			;no copies
FNam:	Asciz /MICOMS/
PidLn=.-FkPid			;length of block
OurPid:	0			;our pid
FPid:	0			;foreign pid
ResLn=10
DesBlk:	Block	ResLn
MsgBlk:	Block	ResLn


CMSTAT:	LDBLK(<<.CMFLG,REPARS>,<.CMIOJ,<.PRIIN,,.PRIOU>>,<.CMBFP,<-1,,CMBUF>>,<.CMPTR,<-1,,CMBUF>>,<.CMCNT,MAXCHR>,<.CMINC,0>,<.CMABP,<POINT 7,ABBUF>>,<.CMABC,ABCHR>,<.CMGJB,CMGJFN>>)

CMGJFN:	BLOCK 16

CMBUF:	BLOCK MAXLEN

ABBUF:	BLOCK ABLEN

INIBLK:	FLDDB.(.CMINI)

TTYINI:	FLDDB.(.CMKEY,,RESKEY)

RESKEY:	TABLE
	T TTYINI,0
	TEND

COMAND:	FLDDB.(.CMCFM,,,,,COMSWT)

COMSWT:	FLDDB.(.CMSWI,,TYPSWT,,,COMTYP)

TYPSWT:	TABLE
IFN BINSW,<
	T ADDRESS:,$ADDRE
	T ASSIGNABLE,$ASSIG
	T BINARY-FILE,$BINMK
IFN LOTSW,<
	T CONSULTINGTERMINAL,$CONSU
>;IFN LOTSW
>;IFN BINSW	
	T DEFAULT-TYPE:,$DTYPE
	T EXIT,$EXIT
IFN BINSW,<
IFN LOTSW,<
	T EXPRESSTERMINAL,$EXPRE
>;IFN LOTSW
>;IFN BINSW
	T FILE:,$FILE
	T FLAG,$FLAG
	T FORMFEED,$FORM
	T FULLDUPLEX,$FULL
	T HALFDUPLEX,$HALF
	T HELP,$HELP
	T LENGTH:,$LENGT
	T LINE-HALFDUPLEX,$LHALF
IFN BINSW,<
	T LOCATION,$LOCAT
>;IFN BINSW
	T LOWERCASE,$LOWER
	T NO-EOP,%PAUSE
	T NO-PAGE-SPEED:,%PGSPD
	T NO-PAUSE-AT-END-OF-PAGE,%PAUSE
	T NO-PAUSE-ON-COMMAND,%CTLS
	T NOFILE,%FILE
	T NOFLAG,%FLAG
	T NOFORMFEED,%FORM
	T NOLOWERCASE,%LOWER
	T NORAISE,%RAISE
	T NOTAB,%TAB
IFN BINSW,<
IFN LOTSW,<
	T OVERHEAD,$OVERH
>;IFN LOTSW
>;IFN BINSW
	T PAUSE-AT-END-OF-PAGE,$PAUSE
	T PAUSE-ON-COMMAND,$CTLS
IFN BINSW,<
IFN LOTSW,<
	T PRINT-NODE:,$PRINT
>;IFN LOTSW
>;IFN BINSW
	T RAISE,$RAISE
	T TAB,$TAB
IFN BINSW,<
IFN LOTSW,<
	T TOBACK:,$TOBAC
	T TODIAGONAL:,$TODIA
	T TOFRONT:,$TOFRO
	T TOGLASS:,$TOGLA
	T TOLEFT:,$TOLEF
	T TOPARTITION:,$TOPAR
	T TORIGHT:,$TORIG	
>;IFN LOTSW
>;IFN BINSW
	T VT100-52,$10052
	T VT100-ANSI,$100AN
	T WIDTH:,$WIDTH
	TEND

COMSPD:	FLDDB.(.CMKEY,,SPDKEY,<
 Speed at or below which to disable /PAUSE-ON-END-OF-PAGE,
>)

SPDKEY:	TABLE
	T 110,^D110
	T 1200,^D1200
	T 134,^D134
	T 150,^D150
	T 1800,^D1800
	T 200,^D200
	T 2400,^D2400
	T 300,^D300
	T 4800,^D4800
	T 50,^D50
	T 600,^D600
	T 75,^D75
	T 9600,^D9600
	TEND

COMTYP:	FLDDB.(.CMKEY,,COMKEY)

COMDTY:	FLDDB.(.CMKEY,,COMKEY)

COMKEY:	TABLE
	T 33,$TT33
	T 35,$TT35
	T 37,$TT37
	T 43,$TT43
	T AAA,$TTANN
	T ADM-3,$TTADM
	T ANN-ARBOR,$TTANN
	T C100,$TTCPT
	T CHECK,-1
	T CONCEPT-100,$TTCPT
	T DATAMEDIA-2500,$TTDAM
	T DEFAULT,$TTDEF
	T DM2500,$TTDAM
	T EXECUPORT,$TTEXE
	T GILLOTINE,$TTGIL
	T GT40,$TTG40
	T H19,$TTH19
	T HAZELTINE-1500,$TTHAZ
	T HEATH-19,$TTH19
	T HP2645A,$TTHP
	T IBM-3101,$TTIBM
	T IDEAL,$TTIDL
	T LA120,$TT120
	T LA30,$TTL30
	T LA34,$TTL34
	T LA36,$TTL36
	T NVT,$TTIDL
	T SOROC-IQ120,$TTSRC
	T SUN,$TTSUN
	T TEKTRONIX-4025,$TTTEK
	T TELERAY-1061,$TTTEL
	T TERMINET,$TTTRM
	T VT05,$TTV05
	T VT100,$TT100
	T VT50,$TTV50
	T VT52,$TTV52
	T VT55,$TTV52
	T Z19,$TTH19
	T ZENITH-19,$TTH19
	TEND

COMCFM:	FLDDB.(.CMCFM)

COMNUM:	FLDDB.(.CMNUM,,^D10)

COMLIN:	FLDDB.(.CMCFM,,,,,COMSTR)

COMSTR:	FLDDB.(.CMTOK,,<-1,,[ASCIZ /*/]>,,,COMOCT)

COMOCT:	FLDDB.(.CMNUM,,10)

COMEOL:	FLDDB.(.CMTXT)

COMFIL:	FLDDB.(.CMFIL)

FILBLK:	LDBLK(<<.GJGEN,GJ%OLD>,<.GJEXT,<-1,,[ASCIZ /CMD/]>>,<.GJNAM,[ASCIZ /TTYINI/]>>)
FILLEN==.-FILBLK

;SAMPLES OF OTHER BLOCKS
;NOISE:	FLDDB.(.CMNOI,,<-1,,[ASCIZ /NOISE/]>)
;IFILE:	FLDDB.(.CMIFI)
;OFILE:	FLDDB.(.CMOFI)
;ARBFIL:FLDDB.(.CMFIL)
;FILBLK:	LDBLK(<<.GJGEN,GJ%OLD>,<.GJEXT,<-1,,[ASCIZ /EXT/]>>,<.GJNAM,[ASCIZ /NAME/]>>)
;FILLEN==.-FILBLK

IFN BINSW,<
DATA	BINFLG
DATA	THELIN
>;IFN BINSW
DATA	REPPDL
DATA	REPPC
DATA	SYSCOM
DATA	PTY0
DATA	OURLIN
DATA	EXITS
DATA	HELPS
DATA	CHANGE
DATA	FILEF
DATA	IJFN
DATA	SAVMOD
DATA	PASS

DATABG:
DATA	TYPE
DATA	DTYPE
DATA	EXITF
DATA	FLAGF
DATA	FORMF
DATA	HELPF
DATA	LENGTH
DATA	LINEF
DATA	LOWERF
DATA	PAUSEF
DATA	CTLSF
DATA	SPEED
DATA	RAISEF
DATA	TABF
DATA	WIDTH
DATA	VT100F
DATA	FJFN

IFN BINSW,<
DATA	PRINT,2
DATA	ADDRE,6
DATA	ASSIG
DATA	CONSU
DATA	EXPRE
DATA	LOCAT
DATA	OVERH
DATA	DIRARR,8
>;IFN BINSW

DATALN==.-DATABG

DATA	TMPARG,DATALN

;TERMINAL TYPE TABLE FOR ANSI RESPONSE TO <ESC>Z

ANSITB:
T100AN:	;LABEL USED FOR /VT100-52
	$TT100,,[ASCIZ /VT100]/] ; (1) VT100
	$TT120,,[ASCIZ /LA120]/] ; (2) LA120
	$TTL34,,[ASCIZ /LA34]/]	; (3) LA34
   ANSIMX==.-ANSITB

;TERMINAL TYPE TABLE FOR DEC RESPONSE TO <ESC>Z

DEFINE DECENT(LETTER,ROUTINE,TYPE,ADDR)<
	LDWRD(<<"LETTER">-<"A">>,<ROUTINE,,[ASCIZ \TYPE]\]>,ADDR)
>

DECTAB:
..LEN==0
DECENT	A,$TTV50,VT50
DECENT	H,$TTV50,VT50
DECENT	C,$TTV52,VT52
DECENT	K,$TTV52,VT52
DECENT	L,$TTV52,VT52
DECENT	(Z,$TTV52,<VT100(VT52)>,T10052)	;T10052 USED BY /VT100-ANSI
DECENT	E,$TTV52,<VT55(VT52)>
DECMAX==..LEN
.ORG DECTAB+DECMAX

SUDTAB:
..LEN==0
DECENT	A,$S0532,<SUDS(GT40/VT05/32)>
DECENT	B,$S0542,<SUDS(GT62/VT05/42)>
DECENT	C,$S5232,<SUDS(GT40/VT52/32)>
DECENT	D,$S5242,<SUDS(GT62/VT52/42)>
SUDMAX==..LEN
.ORG SUDTAB+SUDMAX
SUBTTL	STARTUP
STRT:	RESET
	MOVE P,[IOWD PDLLEN,PDL]
	MOVE A,['PTYPAR']
	SYSGT
	HRRZM A,PTY0
	SETOM SYSCOM
	GJINF
	JUMPE A,NOLOG		;NOT LOGGED IN - MUST USE FILE
	SETZ A,
	RSCAN
	 ERJMP ERSCAN
	JUMPE A,ERSCAN
	COMINI()
	RFIELD(TTYINI)		;MUST START WITH PROGRAM NAME, OR NO ERRORS
	MOVEI B,COMCFM
	MOVEI A,CMSTAT
	COMND
	 ERJMP REPAR1
	TXNE A,CM%NOP
	JRST REPAR1
NOLOG:	SETOM DATABG
	MOVE A,[DATABG,,DATABG+1]
	BLT A,DATABG+DATALN-1
	SETZM CHANGE
	AOS CHANGE
	JRST COMDON		;GO DO TYPE FROM FILE

ERSCAN:	HRROI A,[0]
	RSCAN
	 ERJMP .+1
	SETZM SYSCOM
	TMSG <TTYINI VERSION >
	MOVEI A,.PRIOU
	LDB B,[POINT 9,JOBVER,11]	;MAJOR
	MOVEI C,10
	NOUT
	 JCERR
	LDB B,[POINT 6,JOBVER,17]	;MINOR
	JUMPE B,NOMINR
	SUBI B,1
	IDIVI B,^D26
	JUMPE B,NOMINF
	MOVEI A,"A"-1(B)
	PBOUT
NOMINF:	MOVEI A,"A"(C)
	PBOUT
NOMINR:	HRRZ B,JOBVER			;EDIT
	JUMPE B,NOEDIT
	TMSG <(>
	MOVEI A,.PRIOU
	MOVEI C,10
	NOUT
	 JCERR
	TMSG <)>
NOEDIT:	LDB B,[POINT 3,JOBVER,2]
	JUMPE B,NOGRP
	TMSG <->
	MOVEI A,.PRIOU
	MOVEI C,10
	NOUT
	 JCERR
NOGRP:	TMSG <, >
	HRROI A,[DATE]
	PSOUT
	TMSG <.
>
COMLOP:	CALL CLEAN
	SKIPE SYSCOM
	HALTF
COMLP1:	SETZM SYSCOM
	HRROI A,[ASCIZ /TTYINI>/]
	MOVE B,[.PRIIN,,.PRIOU]
	CALL DOINI
	CALL CLEAN
REPAR1:	SETZM CHANGE
	SETZM FILEF
IFN BINSW,<
	SETZM BINFLG		;NOT CREATING A BINARY FILE
>;IFN BINSW
	SETOM DATABG
	MOVE A,[DATABG,,DATABG+1]
	BLT A,DATABG+DATALN-1
COMNXT:	FIELD(COMAND)
	HRRZ B,(B)
	MOVE A,B
	HRRZ C,C
	CAIN C,COMAND
	JRST COMDON		;CONFIRMED
	CAIN C,COMTYP
	MOVEI A,SETTYP
	CALL (A)
	 JRST COMERR
	JRST COMNXT

REPARS:	MOVE P,REPPDL
	MOVE A,REPPC
	MOVEM A,(P)
	RET

DOINI:	MOVEM A,CMSTAT+.CMRTY
	MOVEM B,CMSTAT+.CMIOJ
	MOVE A,(P)
	MOVEM A,REPPC
	MOVEM P,REPPDL
	MOVEI A,CMSTAT
	MOVEI B,INIBLK
	COMND
	 ERJMP FATAL
	TXNN A,CM%NOP
	RET
FATAL:	JSHLT

DOCFM:	MOVEI B,COMCFM
DOCOM:	MOVEI A,CMSTAT
	COMND
	 ERJMP R
	TXNE A,CM%NOP
	RET
	RETSKP

COMERR:	JSMSG <Command error>
	JRST COMLOP

CLEAN:	MOVX A,CZ%NCL!FLD(.FHSLF,CZ%PRH)
	CLZFF
	 JCERR <Failed to release unopened JFNs>
	RET

COMEND:	SKIPL EXITF
	HALTF
	JRST COMLOP
SUBTTL	COMMAND HANDLERS
$DTYPE:	FIELD(COMDTY,R)
	HRRZ B,(B)
	CHECK DTYPE,DEFAULT-TYPE
	MOVEM B,DTYPE
	JRST CRET

SETTYP:	CHECK TYPE,TYPE
	MOVEM B,TYPE
	JRST CRET

$EXIT:	SKIPE FILEF
	JRST [	SETZM EXITS
		RETSKP]
	CHECK EXITF,EXIT
	SETZM EXITF
	RETSKP

%FLAG:	TDZA A,A
$FLAG:	MOVEI A,1
	CHECK FLAGF,FLAG
	MOVEM A,FLAGF
	JRST CRET

%FORM:	TDZA A,A
$FORM:	MOVEI A,1
	CHECK FORMF,FORMFEED
	MOVEM A,FORMF
	JRST CRET

$HELP:	SKIPE FILEF
	JRST [	SETZM HELPS
		RETSKP]
	CHECK HELPF,HELP
	SETZM HELPF
	RETSKP

$LENGT:	CHECK LENGTH,LENGTH
	FIELD(COMNUM,R)
	MOVEM B,LENGTH
	JRST CRET

%LOWER:	TDZA A,A
$LOWER:	MOVEI A,1
	CHECK LOWERF,LOWERCASE
	MOVEM A,LOWERF
	JRST CRET

$100AN:	TDZA A,A
$10052:	MOVEI A,1
	SKIPL VT100F
	JRST [	SKIPE FILEF
		RETSKP
		TMSG <?Cannot give VT100->
		HRROI A,[ASCIZ /ANSI/]
		SKIPE VT100F
		HRROI A,[ASCIZ /52/]
		PSOUT
		TMSG < more than once
>
		RET]
	MOVEM A,VT100F
	JRST CRET

%PGSPD:	CHECK SPEED,NO-PAGE-SPEED
	FIELD(COMSPD,R)		;GET SPEED
	HRRZ B,(B)		;GET VALUE
	MOVEM B,SPEED		;AND SAVE HERE
	JRST CRET

%PAUSE:	TDZA A,A
$PAUSE:	MOVEI A,1
	CHECK PAUSEF,PAUSE-AT-END-OF-PAGE
	MOVEM A,PAUSEF
	JRST CRET		;NO, DONE

%CTLS:	TDZE A,A
$CTLS:	MOVEI A,1
	CHECK CTLSF,PAUSE-ON-COMMAND
	MOVEM A,CTLSF
	JRST CRET

%RAISE:	TDZA A,A
$RAISE:	MOVEI A,1
	CHECK RAISEF,RAISE
	MOVEM A,RAISEF
	JRST CRET

%TAB:	TDZA A,A
$TAB:	MOVEI A,1
	CHECK TABF,TAB
	MOVEM A,TABF
	JRST CRET

$WIDTH:	CHECK WIDTH,WIDTH
	FIELD(COMNUM,R)
	MOVEM B,WIDTH
	JRST CRET

$FULL:	MOVEI A,.TTFDX
	JRST DODUM

$HALF:	MOVEI A,.TTHDX
	JRST DODUM

$LHALF:	MOVEI A,.TTLDX
DODUM:	CHECK LINEF,DUPLEX
	MOVEM A,LINEF
	JRST CRET

%FILE:	SETZ A,
	JRST GFILE

$FILE:	MOVE A,[FILBLK,,CMGJFN]
	BLT A,CMGJFN+FILLEN-1
	FIELD(COMFIL,R)
	MOVE A,B
GFILE:	CHECK FJFN,FILE
	MOVEM A,FJFN
CRET:	AOS CHANGE
	RETSKP

IFN BINSW,<
COMQST:	FLDDB. .CMQST

$ADDRE:	CHECK ADDRE,ADDRESS
	FIELD(COMQST,R)
	HRROI A,ADDRE
	HRROI B,ABBUF
	MOVEI C,5*6		;UP TO 35 CHARACTERS
	SETZB D,ADDRE		;CLEAR LOW BIT, SINCE BUGGY MONITOR DOESN'T
	SOUT			;COPY THE STRING
	JRST CRET


;HERE ON /PRINT-NODE: TO SET THE USER'S DECNET NODE

$PRINT:	CHECK PRINT,PRINT-NODE
	FIELD (COMQST,R)
	HRROI A,PRINT
	HRROI B,ABBUF
	MOVEI C,6		;UP TO 6 CHARACTERS IN A NODE NAME
	SETZB D,PRINT		;END ON A NULL, CLEAR DATA AREA
	SETZM PRINT+1		;CLEAR SECOND WORD OF DATA AREA
	SOUT			;COPY THE STRING
	JRST CRET

$ASSIG:	MOVEI A,1
	CHECK ASSIG,ASSIGNABLE
	MOVEM A,ASSIG
	JRST CRET

$OVERH:	MOVEI A,1
	CHECK OVERH,OVERHEAD
	MOVEM A,OVERH
	JRST CRET

$CONSU:	MOVEI A,1
	CHECK CONSU,CONSULTANT
	MOVEM A,CONSU
	JRST CRET

$EXPRE:	MOVEI A,1
	CHECK EXPRE,EXPRESSTERMINAL
	MOVEM A,EXPRE
	JRST CRET

LOCKEY:	FLDDB. (.CMKEY,,LOCTAB,,,COMNUM) ;KEYWORD OR A NUMBER

$LOCAT:	CHECK LOCAT,LOCATION
	FIELD(LOCKEY)
	HRRZ C,C		;GET FIELD ACTUALLY PARSED
	CAIN C,LOCKEY		;DID WE PARSE A KEYWORD?
	 HRRZ B,(B)		;YES.  IF NOT, NUMBER IS ALREADY IN B.
	MOVEM B,LOCAT
	JRST CRET

IFN LOTSW,<
LOCTAB:	TABLE			;SUGGESTED NAMES FOR VALUES
	T ARPANVT,11		;LOCARP
	T CERAS105,1		;LOC105
	T CERASLOBBY,2		;LOCLOB
	T CERASOTHER,3		;LOCCOT
	T DECNVT,12		;LOCDEC
	T DIALIN,6		;LOCDIA
	T ERL206,14		;LOCERL
	T ETHERNVT,10		;LOCETH
	T GANDALF,7		;LOCGAN
	T PTY,13		;LOCPTY
	T TERMAN104,4		;LOCTER
	T TERMANOTHER,5		;LOCTOT
	T UNKNOWN,0		;LOCUNK
	TEND
>;IFN LOTSW
IFE LOTSW,<
LOCTAB:	TABLE			;SUGGESTED NAMES FOR VALUES
	T UNKNOWN,0		;LOCUNK
	TEND
>;IFE LOTSW

$TOBAC:	MOVEI D,5
	JRST DIRECT

$TODIA:	SKIPA D,[4]
$TOFRO:	MOVEI D,3
	JRST DIRECT

$TOGLA:	SKIPA D,[2]
$TOLEF:	MOVEI D,0
	JRST DIRECT

$TOPAR:	SKIPA D,[6]
$TORIG:	MOVEI D,1

DIRECT:	CHECK(DIRARR(D),<neighbor specification>)
	FIELD(COMOCT,R)		;PARSE AN OCTAL TERMINAL NUMBER
	MOVEM B,DIRARR(D)
	JRST CRET
>;IFN BINSW

SUBTTL COMMAND EXECUTION

COMDON:	HRROI A,HLPMES
	SKIPL HELPF
	PSOUT
	SKIPG CHANGE
	JRST COMEND
	SETOM FILEF		;NOW READING FILE
	MOVNI A,1
	MOVE B,[1,,3]
	MOVEI C,.JITNO
	GETJI
	 JSHLT
	MOVEM C,OURLIN
FILCHK:	MOVE A,TYPE		;SEE IF NEED CHECK NOW
	CAIN A,-1
	JRST [	CALL DOCHK
		SKIPL TYPE	;STILL UNKNOWN?
		JRST COMXCT	;NOPE, NO FILE PLEASE
		JRST CKFILE]
CKFILE:	SKIPLE A,FJFN
	JRST FILGOT
	JUMPE A,COMXCT		;DONE IF EXPLICIT NOFILE
	SKIPGE TYPE		;DEFAULT SEARCH ONLY IF NO TYPE
	SKIPL FILEF		;TRIED YET?
	JRST COMXCT		;YES, NO MORE
	MOVEI A,1
	MOVEM A,FILEF		;FLAG TRYING DEFAULT FILE
IFN BINSW,<
	SKIPN BINFLG		;DON'T IF WRITING A BINARY FILE!
	CALL GETBIN		;try to get the data from TTYINI.BIN
	 SKIPA			;failed.  File not found or something
	JRST COMXCT		;success.  Go do it. 
>;IFN BINSW
	MOVX A,GJ%OLD!GJ%SHT
	HRROI B,[ASCIZ /SYSTEM:TTYINI.CMD/]
	GTJFN
	 JRST [	JSMSG(<Can't get SYSTEM:TTYINI.CMD:>,%)
		JRST COMXCT]
FILGOT:	HRRZM A,IJFN
	MOVX B,FLD(7,OF%BSZ)!OF%RD
	OPENF
	 JRST [	TMSG <
?Can't open >
		MOVEI A,.PRIOU
		MOVE B,IJFN
		SETZ C,
		JFNS
		 ERCAL R
		TMSG < because: >
		CALL JSMSG0
		JRST COMLOP]
	SETOM FJFN
	MOVE A,[DATABG,,TMPARG]	;SAVE USER ARGS
	BLT A,TMPARG+DATALN-1
FILLOP:	HRROI A,CMBUF
	MOVEI B,.NULIO
	HRL B,IJFN
	CALL DOINI
	CALL CLEAN		;CLEAN UP LAST SCAN
	SETOM EXITS
	SETOM HELPS
	MOVE A,[TMPARG,,DATABG]
	BLT A,DATABG+DATALN-1
	FIELD(COMLIN,FILERR)
	HRRZ C,C
	CAIN C,COMSTR
IFN BINSW,<
	  JRST [SETZ B,		;Take TTY# (0)
		JRST BINLIN]
>;IFN BINSW
IFE BINSW,<
	JRST ISOURS		;* ALWAYS MATCHES
>;IFE BINSW
	CAIE C,COMOCT
	JRST FILLOP		;IGNORE BLANK LINES
IFN BINSW,<
	SKIPE BINFLG		;SKIP IF NOT CREATING A BINARY FILE
	JRST BINLIN		;WRITE A LINE IN THE BINARY FILE
>;IFN BINSW
	CAMN B,OURLIN		;FIND OUR LINE?
	JRST ISOURS		;YES
	jrst filer1		;no.  Not ours
FILERR:	MOVEI A,.FHSLF
	GETER
	HRRZ B,B
	CAIN B,COMNX9		;EOF?
	JRST FILNON		;YES, NONE FOUND
filer1:	FIELD(COMEOL,FILLOP)	;EAT LINE
	JRST FILLOP

ISOURS:	FIELD(COMAND,TRMERR)
	HRRZ B,(B)
	MOVE A,B
	HRRZ C,C
	CAIN C,COMAND
	JRST FILDON		;CONFIRMED
	CAIN C,COMTYP
	MOVEI A,SETTYP
	CALL (A)
	 JRST TRMERR
	JRST ISOURS

TRMERR:	JSMSG <Command error in file>
	TMSG  <Line was:  >
	HRROI A,CMBUF
	PSOUT
	TMSG <
Will ignore terminal data line and continue scan
>
	JRST FILERR

FILNON:	MOVE A,[TMPARG,,DATABG]
	BLT A,DATABG+DATALN-1
	JRST FILDN1

FILDON:	HRROI A,[ASCIZ \%Ignoring /EXIT from file
\]
	SKIPL EXITS
	PSOUT
	HRROI A,[ASCIZ \%Ignoring /HELP from file
\]
	SKIPL HELPS
	PSOUT
FILDN1:
IFN BINSW,<
	SKIPE BINFLG		;SKIP IF NOT CREATING A BINARY FILE
	CALL MAKBIN		;WRITE OUT THE BINARY FILE
>;IFN BINSW
	MOVE A,IJFN
	CLOSF
	 JCERR <CLOSF failed>
	JRST FILCHK

COMXCT:	SKIPL B,TYPE
	JRST DOSTYP
	SKIPGE B,DTYPE		;DEFAULT?
	JRST NOSTYP
	MOVEM B,TYPE		;YES, SET AS TYPE
	CAIN B,-1
	CALL DOCHK
	SKIPGE B,TYPE
	JRST NOSTYP
DOSTYP:	tlc b,377777		; if type=377777,,typeno then treat
	tlze b,377777		; as type num. instead of routine addr
	 CALL (B)
	MOVEI A,.CTTRM
	STTYP
	 JCERR <STTYP failed>
	CAIE B,.TTTEL		;TELERAYS RUN THE TELERAY PROGRAM FOR FREE HERE
	 JRST NOSTYP		; TO SET UP THEIR TABS
	MOVX A,CR%CAP
	CFORK
	 JRST NOSTYP
	MOVEI D,(A)
	MOVX A,GJ%OLD!GJ%SHT
	HRROI B,[ASCIZ/SYS:TELERAY.EXE/]
	GTJFN
	 JRST NOSTYP
	HRLI A,(D)
	GET
	MOVEI A,(D)
	SETZ B,
	SFRKV
	WFORK
	KFORK
NOSTYP:	MOVEI A,.CTTRM
	RFMOD
	SKIPN LOWERF
	TXZ B,TT%LCA
	SKIPLE LOWERF
	TXO B,TT%LCA
	SKIPN FORMF
	TXZ B,TT%MFF
	SKIPLE FORMF
	TXO B,TT%MFF
	SKIPN TABF
	TXZ B,TT%TAB
	SKIPLE TABF
	TXO B,TT%TAB
	SKIPN FLAGF
	TXZ B,TT%UOC
	SKIPLE FLAGF
	TXO B,TT%UOC
	SKIPN RAISEF
	TXZ B,TT%LIC
	SKIPLE RAISEF
	TXO B,TT%LIC
	SKIPL C,LINEF
	STOR C,TT%DUM,B
IFNDEF .MOXOF,<
	SKIPN PAUSEF		;FIRST, USE PAUSE-AT-END-OF-PAGE
	TXZ B,TT%PGM
	SKIPLE PAUSEF
	TXO B,TT%PGM
>;IFNDEF .MOXOF
	SKIPN CTLSF		;USE PAUSE-ON-COMMAND IF ANY
	TXZ B,TT%PGM
	SKIPLE CTLSF
	TXO B,TT%PGM
	STPAR
	 JCERR <STPAR failed>
	SKIPGE C,LENGTH
	JRST NOLEN
	MOVEI A,.CTTRM
	MOVEI B,.MOSLL
	MTOPR
	 JCERR <Length MTOPR failed>
NOLEN:	SKIPGE C,WIDTH
	JRST NOWID
	MOVEI A,.CTTRM
	MOVEI B,.MOSLW
	MTOPR
	 JCERR <Width MTOPR failed>
NOWID:
IFN BINSW,<
IFN LOTSW,<
	MOVE A,PRINT		;FETCH FIRST WORD OF NODE NAME
	CAMN A,[-1]		;-1 MEANS NOTHING SET
	JRST NOSTJB		;SO SKIP THIS
	SETO A,			;-1 FOR THIS JOB
	MOVX B,.SJLLO		;FUNCTION IS SET JOB LOCATION
	HRROI C,PRINT		;POINTER TO NODE NAME
	SETJB%			;SET IT
	 JCERR <Unable to set job location>
NOSTJB:
>;IFN LOTSW
>;IFN BINSW
IFDEF .MOXOF,<
	SKIPGE PAUSEF
	JRST NOXOF
	MOVEI A,.CTTRM
	MOVEI B,.MOXOF
	MOVEI C,.MOONX
	SKIPN PAUSEF
	MOVEI C,.MOOFF
	MTOPR
	 JCERR <Pause MTOPR failed>
NOXOF:
>;IFDEF .MOXOF
	SKIPGE SPEED		;SPEED TO CUT-OFF AT SPECIFIED?
	JRST COMEND
	MOVEI A,.CTTRM
	MOVEI B,.MORSP
	MTOPR
	 ERJMP [JSMSG <Failed to read speed for controlling terminal>
		JRST COMEND]
	CAMN C,[-1]
	JRST COMEND
	HRRZ C,C		;GET OUTPUT SPEED
	CAMLE C,SPEED		;SPECIFIED SPEED LESS THAN ACTUAL?
	JRST COMEND		;YES, LEAVE PAGE MODE ON
IFDEF .MOXOF,<
	MOVEI A,.CTTRM
	MOVEI B,.MOXOF
	MOVEI C,.MOOFF
	MTOPR
	 JCERR <Failed to set /NO-PAUSE-AT-END-OF-PAGE>
>;IFDEF .MOXOF
	JRST COMEND

	XLIST
HLPMES:	ASCIZ \
TTYINI is a program to set terminal types. Normally it reads the
necessary information from the file SYSTEM:TTYINI.BIN. You may
selectively override any or all of the values contained in the file.
The command format is an optional terminal type name followed by
optional switches.

Available terminal type names:

33		Model 33 hardcopy terminal.
35		Model 35 hardcopy terminal.
37		Model 37 hardcopy terminal.
43		Model 43 hardcopy terminal.
ADM-3		LSI ADM-3 or other "glass teletype".
ANN-ARBOR	Ann Arbor terminal.
CHECK		Special type.  When given, causes the terminal to be
		polled to determine type. Currently works for VT50,
		VT52, VT55, VT100, LA34 and LA120 terminals. In
		addition, it will recognize suds terminals (GT40, GT42
		or GT62 running VT05G).  If a SUDS terminal is
		recognized, /LOWERCASE and /NORAISE will be assumed. If
		the type is successfully determined, reading of any
		file is suppressed. A VT100 can be in VT52 mode. This
		case is indicated during the checking procedure.
DATAMEDIA-2500	Datamedia model 2500 or modified 3000 terminal.
DEFAULT		System default terminal type.
EXECUPORT	Execuport terminal.
GT40		DEC GT40 graphics terminal.
HAZELTINE-1500	Hazeltine 1500 terminal.
HEATH-19	Heath-19 or similar terminal.
HP2645A		HP 2645 or related terminal.
IDEAL		Does no special character processing.
LA120		DEC LA120 terminal.
LA30		DEC LA30 terminal.
LA34		DEC LA34 terminal.
LA36		DEC LA36 terminal.
NVT		"Network Virtual Terminal", equivalent to IDEAL.
SOROC		Soroc IQ120 terminal.
TELERAY-1061	Teleray 1061 terminal with edit key.
TERMINET	Terminet terminal.  (worst possible)
TEKTRONIX-4025	Tektronix 4025 terminal.
VT05		DEC VT05 video terminal.
VT100		DEC VT100 video terminal.
VT50		DEC VT50 video terminal.
VT52		DEC VT52 video terminal.
VT55		DEC VT55 video terminal. (VT52 with printer)

The following switches may be given:

/BINARY-FILE	Instead of setting terminal parameters, read the
		file SYSTEM:TTYINI.CMD and write a new copy of
		SYSTEM:TTYINI.BIN.  Various special switches may
		be included in TTYINI.CMD; see below.
/DEFAULT-TYPE:type-name
		If terminal type not specified, use this type.
/EXIT		Exit at end of command.
/FILE:filespec	Read "filespec" for terminal data by line number.
/FLAG		Flag upper case output (precede by ').
/FORMFEED	Send formfeed characters directly to terminal.
/FULLDUPLEX	Set terminal to FULL DUPLEX mode.
/HALFDUPLEX	Set terminal to CHARACTER HALF DUPLEX mode.
/HELP		Print this text.
/LENGTH:n	Set terminal length (lines per page) to "n".
/LINE-HALFDUPLEX
		Set terminal to LINE HALF DUPLEX mode.
/LOWERCASE	Pass lower case characters to terminal.
/NOFILE		Never read a file.
/NOFLAG		Don't flag upper case output.
/NOFORMFEED	Simulate formfeed characters.
/NOLOWERCASE	Convert lower case to upper case on output.
/NO-PAGE-SPEED:n
		The value "n" is the speed at or below which to
		disable /PAUSE-ON-END-OF-PAGE. If the speed
		of output from the computer to the terminal is
		higher than the specified speed, the /PAUSE-ON-
		END-OF-PAGE will be allowed either implicitly or
		explicitly.
/NO-PAUSE-AT-END-OF-PAGE
		Don't pause when end of page is reached.
/NO-PAUSE-ON-COMMAND
		Don't pause when ^S is typed.
/NORAISE	Don't convert lower case to upper case on input.
/NOTAB		Simulate tab characters.
/PAUSE-AT-END-OF-PAGE
		Stop terminal output at end of page (when lines per
		page lines have been output). Type ^Q to cause output
		to continue.
/PAUSE-ON-COMMAND
		Stop terminal output when ^S is typed. Type ^Q to cause 
		output to continue.
/RAISE		Convert lower case to upper case on input.
/TAB		Send tab characters directly to terminal.
/VT100-52	Used in conjuction with CHECK option. If terminal is
		successfully identified as a VT100 in ANSI mode, it is
		switched to VT100 in VT52 mode and that terminal type
		is assumed.
/VT100-ANSI	Used in conjuction with CHECK option. If terminal is
		successfully identified as a VT100 in VT52 mode, it is
		switched to VT100 in ANSI mode and that terminal type
		is assumed.
/WIDTH:n	Set terminal width to "n" characters.

If terminal type is not given and no /FILE:filespec or /NOFILE switches
are given, the file SYSTEM:TTYINI.BIN is read.

The file SYSTEM:TTYINI.CMD (read by the /BINARY-FILE command to build
SYSTEM:TTYINI.BIN) contains information in text format for each line.
Each line of the file has the following format:

<line #> <same as TTYINI command line>

The <line #> indicates which line the command line applies to.  The
file is parsed using the COMND JSYS.  Several special switches are
only applicable inside of TTYINI.CMD:
/ADDRESS:"quotedstring"
		Use "quotedstring" as the location name known to the
		FINGER program.
/ASSIGNABLE	Assignable by the queueing system.
/CONSULTINGTERMINAL
		Reserved for a LOTS consultant.
/EXPRESSTERMINAL
		Reserved for short (5 min. or less) terminal sessions.
/LOCATION:location
		Location of the terminal (currently one of ARPANVT,
		CERAS105, CERASLOBBY, CERASOTHER, DECNVT, DIALIN,
		ERL206, GANDALF, PTY, TERMAN104, TERMANOTHER, UNKNOWN).
/PRINT-NODE:"NODE"
		Set the default print node for a job on this terminal
/OVERHEAD	Not subject to the normal 90 minute session time limit.
/TOBACK:n	Terminal "n" is located "Behind you".
/TODIAGONAL:n	Terminal "n" is located "Diagonally opposite you".
/TOFRONT:n	Terminal "n" is located "Facing you".
/TOGLASS:n	Terminal "n" is located "Across the glass from you".
/TOLEFT:n	Terminal "n" is located "On your left".
/TOPARTITION:n	Terminal "n" is located "Across the partition from you".
/TORIGHT:n	Terminal "n" is located "On your right".

Examples:

	TTYINI<cr>

Determine terminal data from SYSTEM:TTYINI.BIN by line number.

	TTYINI DATAMEDIA/WIDTH:84/LENGTH:38

Set terminal data explicity, this particular command would be
appropriate for a SUAI Datadisk terminal running DTN.

The following type names imply the indicated default switches
unless explicity overridden:

LA120	/NORAISE
LA34	LA120/NORAISE/NOFORMFEED/LOWERCASE
LA36	/NORAISE/LOWERCASE
GT40	/NORAISE/PAUSE-AT-END-OF-PAGE/LOWERCASE
VT05	/RAISE/PAUSE-AT-END-OF-PAGE
VT50	/NORAISE/PAUSE-AT-END-OF-PAGE
VT52	/NORAISE/PAUSE-AT-END-OF-PAGE/LOWERCASE
VT55	VT52/NORAISE/PAUSE-AT-END-OF-PAGE/LOWERCASE
VT100	/NORAISE/PAUSE-AT-END-OF-PAGE/LOWERCASE
\
	LIST


SUBTTL	CHECK HANDLER, TYPE ROUTINES

DOCHK:	TMSG <[Terminal type is >
	MOVEI A,.PRIOU
	DOBE			;WAIT TILL OUT
	CFIBF
	RFMOD
	MOVEM B,SAVMOD
	TDZ B,[TT%ECO!TT%DAM]
	SFMOD
	DOBE
	SETOM PASS		;FIRST PASS
	HRROI A,[BYTE(7)33,132]	;QUERY FOR FIRST PASS
PASS2:	PSOUT			;QUERY TERMINAL
	MOVEI A,.PRIOU
	DOBE
	MOVEI C,^D20		;20 * 250 MS = 5 SECONDS
CHKLOP:	SOJL C,CHKLOS
	CALL GETCHR
	 JRST CHKLOP
	CAIE A,33		;CORRECT RESPONSE?
	JRST CHKBAD		;NOT EVEN FIRST CHARACTER CORRECT
	CALL GETCHR
	 JRST CHKLOS
	CAIE A,"/"		;DEC terminal response?
	JRST CKANSI		;NO, TRY ANSI RESPONSE
	CALL GETCHR		;yes, get arg
	 JRST CHKLOS
	CAIL A,"A"
	CAILE A,"A"+DECMAX-1
	JRST CHKLOS		;NOT IN DESIRED RANGE
	SKIPN DECTAB-"A"(A)
	JRST CHKLOS		;NO ENTRY FOR THIS ONE
	MOVEI E,DECTAB-"A"(A)
	CAIN E,T10052		;IS THIS VT100 IN 52 MODE?
	SKIPE VT100F		;YES, REQUESTING SWITCH TO 100 MODE?
	CAIA			;NO, OK
	JRST S100AN		;YES, SWITCH TO 100 MODE
	MOVE D,DECTAB-"A"(A)
CHKOK:	MOVEI A,.PRIIN
	CFIBF
	JRST CHKEND

S100AN:	HRROI A,[BYTE(7)33,"<"]	;SET TO VT100-ANSI MODE
	PSOUT
	MOVE D,T100AN		;ASSUME OK, GET DISPATCH FOR VT100-ANSI
	JRST CHKOK

CHKBAD:	SETZM PASS		;IF BAD RESPONSE, NO SECOND-PASS
CHKLOS:	MOVEI A,.PRIIN
	CFIBF
	AOSN PASS		;IS THIS FIRST PASS?
	JRST [	HRROI A,[BYTE (7)33,133,"C"+40]
		JRST PASS2]	;YES, TRY AGAIN WITH ANSI QUERY SEQ
	MOVE D,[-1,,[ASCIZ /UNKNOWN]/]]
CHKEND:	MOVE B,SAVMOD
	SFMOD
	HLREM D,TYPE
	HRRZ A,D
	PSOUT
	RET

CKANSI:	CAIE A,"["
	JRST CKSUDS
	MOVEI C,"?"
	CALL CHKCHR
	 JRST CHKLOS
	CALL GETCHR		; GET TYPE CODE
	 JRST CHKLOS
	CAIL A,"1"
	 CAILE A,"0"+ANSIMX
	  JRST CHKLOS
	MOVEI E,ANSITB-"1"(A)
CHKARG:	CALL GETCHR
	 JRST CHKLOS
	CAIE A,";"
	JRST CHKANE
	CALL GETCHR
	 JRST CHKLOS
	CAIL A,"0"
	CAILE A,"7"
	JRST CHKLOS
	JRST CHKARG

CHKANE:	CAIE A,"C"+40
	JRST CHKLOS
	CAIN E,T100AN		;VT100 IN ANSI MODE?
	SKIPG VT100F		;YES, REQUESTING SWITCH TO 52 MODE?
	CAIA			;NO, GO AHEAD
	JRST S10052		;YES, DO IT
	SKIPN D,(E)		;GET DISPATCH AND STRING (IF ANY)
	JRST CHKLOS
	JRST CHKOK

S10052:	HRROI A,[BYTE(7)33,"[","?","2","L"+40]	;SET TO VT100-52 MODE
	PSOUT
	MOVE D,T10052		;ASSUME OK, GET DISPATCH FOR VT100-52
	JRST CHKOK

CKSUDS:	CAIE A,"\"		;SUDS TERMINAL?
	JRST CHKLOS
	CALL GETCHR		;yes, get arg
	 JRST CHKLOS
	CAIL A,"A"
	CAILE A,"A"+SUDMAX-1
	JRST CHKLOS		;NOT IN DESIRED RANGE
	SKIPN SUDTAB-"A"(A)
	JRST CHKLOS
	MOVE D,SUDTAB-"A"(A)
	JRST CHKOK

CHKCHR:	CALL GETCHR
	 RET
	CAMN C,A
	RETSKP
	RET

GETCHR:	MOVEI A,.PRIIN
	SIBE
	JRST GETCH1
	MOVEI A,^D250
	DISMS
	MOVEI A,.PRIIN
	SIBE
	JRST GETCH1
	RET

GETCH1:	PBIN
	ANDI A,177
	RETSKP

$TT33:	MOVEI B,.TT33
	RET

$TT35:	MOVEI B,.TT35
	RET

$TT37:	MOVEI B,.TT37
	RET

$TT43:	MOVEI B,.TT43
	RET

$TTADM:	MOVEI B,.TTADM
	JRST VIDXIT

$TTANN:	MOVEI B,.TTANN
	DEFAULT WIDTH,^D80
	JRST VIDXIT

$TTCPT:	MOVEI B,.TTCPT
	JRST VIDXIT

$TTDAM:	MOVEI B,.TTDAM
	JRST VIDXIT

$TTDEF:	MOVEI B,.TTDEF
	RET

$TTEXE:	MOVEI B,.TTEXE
	RET

$TTG40:	MOVEI B,.TTG40
	JRST VIDXIT

$TTGIL:	MOVEI B,.TTGIL
	JRST VIDXIT
	
$TTHAZ:	MOVEI B,.TTHAZ
	JRST VIDXIT

$TTH19:	MOVEI B,.TTH19
	JRST VIDXIT

$TTSUN:	MOVEI B,.TTSUN
	JRST VIDXIT

$TTHP:	MOVEI B,.TTHP
	JRST VIDXIT

$TTIBM:	MOVEI B,.TTIBM
	JRST VIDXIT	

$TTIDL:	MOVEI B,.TTIDL
	RET

$TTL30:	MOVEI B,.TTL30
	RET

$TTL34:	MOVEI B,.TT120
	DEFAULT FORMF,0
	JRST LOWXIT

$TTL36:	MOVEI B,.TTL36
	JRST LOWXIT

$TTSRC:	MOVEI B,.TTSRC
	JRST VIDXIT

$TTTEK:	MOVEI B,.TTTEK
	DEFAULT LENGTH,^D34
	DEFAULT WIDTH,^D78
	JRST VIDXIT

$TTTEL:	MOVEI B,.TTTEL
	JRST VIDXIT

$TTTRM:	MOVEI B,.TTDEF
	RET

$TTV05:	MOVEI B,.TTV05
	DEFAULT RAISEF,1
	RET

$TTV50:	MOVEI B,.TTV50
	DEFAULT PAUSEF,1
	RET

$TT120:	MOVEI B,.TT120
	DEFAULT RAISEF,0
	RET

$TT100:
IFDEF .TT100,<
	SKIPA B,[.TT100]
>;IFDEF .TT100
$TTV52:	MOVEI B,.TTV52
VIDXIT:	DEFAULT PAUSEF,1
LOWXIT:	DEFAULT RAISEF,0
	DEFAULT LOWERF,1
	RET

$S0532:	DEFAULT LENGTH,^D32
	JRST $TTS05

$S0542:	DEFAULT LENGTH,^D42
$TTS05:	MOVEI B,.TTV05
	JRST $TTSUD

$S5232:	DEFAULT LENGTH,^D32
	JRST $TTS52

$S5242:	DEFAULT LENGTH,^D42
$TTS52:	MOVEI B,.TTV52
$TTSUD:	DEFAULT WIDTH,^D80
	JRST VIDXIT

	SUBTTL BINARY FILE HANDLING

IFN BINSW,<

BINPAG==500			;just a random unused block of pages
BINADR==BINPAG*1000


comment \
assumed file format: (if changed here, change the definitions in
	the file generation program too)

header [n words, where n is the length of a single tty data block]
0/	# of blocks (not including this) in file [maxK]
1/	# of words per block [n]
2/	version #

3/	start of 1st block, for TTY0 (the fake, generic, * one)
	...
k*n/	[for k:=1 to maxK] one tty entry, for line k
	see below for definition of one entry
\

;OFFSETS INTO HEADER RECORD
b%maxK==BINADR
b%n==	BINADR+1
B%VERS==BINADR+2
b%headl==3			;length of header

;DEFAULTS FOR NEW FILES
B%DEFL==^D18			;DEFAULT LENGTH OF FILE
B%VNO==2			;VERSION NUMBER

comment \
Each line has an associated terminal block of the following format:

TYPE
    ttynumber = 1..511;             (* Up to 511 lines *)
    directiontype = (toleft, toright, acrossglass, facing, diagonal,
		     behind, acrosspartition);      (* For fing/neighbor *)
    locationtype =  (ceras105, ceraslobby, cerasother,
		     terman104, termanother,
		     dialin, gandalf,
		     ethernvt, arpanvt, decnvt)	    (* Typical locations *)
    flagtype =      (consultant, assignable, overhead, formfeed,
		     lowercase, tabs, pagepause, commandpause,
		     raise, flag);
    tty = RECORD (* Tty *)
	      ttytype,		    (* Terminal type number, or -1 if ? *)
	      defttytype,	    (* Default type number or -1 if ? *)
	      length,		    (* Terminal length or -1 if ? *)
	      width:     integer;   (* Terminal width or -1 if ? *)
				    (* Total 4 wds *)
	      address:   PACKED ARRAY[1..30] OF char;
				    (* String for finger.  6 wds *)
	      location:  locationtype;
				    (* Where it is for finger.  1 wd *)
	      neighbors: PACKED ARRAY[directiontype] OF ttynumber;
				    (* For FINGER/NEIGHBORS.  2 wds *)
	      dplxmode:  (fullduplex, noduplex, halfduplex, linehduplex);
				    (* 1 wd *)
	      bits:     PACKED SET OF flagtype;
				    (* Bits.  2 wds currently *)
	      print-node: PACKED ARRAY [1..10] OF char;
				    (* 6 letter DECnet node name.  2 wds *)
	  END  (* Tty *)	(* 18 words, currently *)
\


	PHASE 0			;DEFINITIONS OF TTY DATA BLOCKS
; N.B. ALL FIELDS ARE -1 IF UNKNOWN
B%TTYTYPE:	0		;TERMINAL TYPE NUMBER
B%DEFTTYTYPE:	0		;DEFAULT TERMINAL TYPE NUMBER
B%LENGTH:	0		;TERMINAL LENGTH
B%WIDTH:	0		;TERMINAL WIDTH
B%ADDRESS:	BLOCK 6		;PACKED ARRAY [1..30] OF CHAR
B%LOCATION:	0		;UNKNOWN,CERAS105,CERASLOBBY,CERASOTHER,
				; TERMAN104,TERMANOTHER,DIALIN,GANDALF,
				; ETHERNVT,ARPANVT,DECNVT, ETC...
B%NEIGHBOR:	BLOCK 2		;PACKED ARRAY [DIRECTION] OF 0..511--I.E. 9 BIT
				; DIRECTION=(TOLEFT,TORIGHT,ACROSSGLASS,FACING,
				; DIAGONALLY-OPPOSITE,BEHIND,ACROSSPARTITION
B%DPLXMODE:	0
B%BITS:		BLOCK 2		;SEE BELOW
B%PRINT:	BLOCK 2		;SIX LETTER DECNET NODE NAME
	DEPHASE

; BITS IN B%BITS
B%CONSULTANT==	1B0		;NOT USED IN THIS PROGRAM
B%ASSIGNABLE==	1B1		;NOT USED IN THIS PROGRAM
B%OVERHEAD==	1B2		;NOT USED IN THIS PROGRAM
B%FORMFEED==	1B3
B%LOWERCASE==	1B4
B%TABS==	1B5
B%PAGEPAUSE==	1B6
B%COMMANDPAUSE==1B7
B%RAISE==	1B8
B%FLAG==	1B9
B%EXPRESS==	1B10		;NOT USED IN THIS PROGRAM

	SUBTTL BINARY FILE READING

;BINLOC -- find location of data block for our terminal in file
; mapped in at BINPAG
;call:	with file mapped at BINPAG
;	A/ set up with our line number
;ret:	+1 our terminal is not in file
;	+2 success, with 
;    a/ base of data block for our terminal
BINLOC:	JUMPL A,R
	CAMLE A,B%MAXK		;COMPARE WITH MAXK
	 RET			;.LE. 0 OR .GE. MAXK
	IMUL A,B%N		;COMPUTE OFFSET FROM INDEX
	ADDI A,BINADR+b%headl	;COMPUTE ADDRESS FROM OFFSET
	RETSKP


;GETBIN -- get default data from binary file TTYINI.BIN
;call:
;ret:	+1 error, e.g. file not found, or bad format
;	+2 ok
GETBIN:	STKVAR <NBINPG>
	MOVX A,GJ%OLD!GJ%SHT
	HRROI B,[ASCIZ/SYSTEM:TTYINI.BIN/]
	GTJFN
	 ERJMP R		;NO FILE
	HRRZM A,IJFN
	HRRZ A,A
	SIZEF			;GET # OF PAGES IN 3
	 ERJMP GETBI0		;OOPS.  RELEASE JFN AND GIVE UP
	MOVEM C,NBINPG
	MOVE 2,[44B5!OF%RD]
	OPENF
	 ERJMP GETBI0		;SOMEONE WRITING IT?
	HRLZ A,A		;NOW MAP THE FILE
	MOVE B,[.FHSLF,,BINPAG]
	MOVX C,PM%CNT!PM%RD!PM%PLD
	HRR C,NBINPG
	PMAP			;MAP FILE IN AT BINPAG
	MOVE A,OURLIN		;GET OUR LINE NUMBER
	CALL BINLOC		;FIGURE OUT WHERE OUR DATA IS
	  JRST [SETZ A,		;Try TTY0 (the fake, default one)
		CALL BINLOC
		  JRST GETBI0		; NOT IN FILE
		JRST .+1]
	CALL BINRD		;PROCESS BINARY FILE NOW
	SETO A,			;NOW CLEAR FILE
	MOVE B,[.FHSLF,,BINPAG]
	MOVX C,PM%CNT
	HRR C,NBINPG
	PMAP			;UNMAP THE OLD FILE
	 ERJMP GETBI0
	HRRZ A,IJFN		;USE ONLY GOOD HALF OF IJFN
	CLOSF
	 ERJMP GETBI0
	RETSKP			;OK
GETBI0:	HRRZ A,IJFN
	RLJFN
	 ERJMP R		;DON'T CARE
	RET


;BINRD -- process binary data mapped in.
;call:	a/ base of data block for our terminal
;ret:	+1 always, with various data for TTYINI set
BINRD:
	SKIPLE B,B%TTYTYPE(A)
	 JRST [	HRLI B,377777	;use special flag for LH
		SKIPGE TYPE	;DON'T CHANGE IF ALREADY SET
		 MOVEM B,TYPE	;SET TYPE IF KNOWN
		JRST .+1 ]
	SKIPLE B,B%DEFTTYTYPE(A)
	 JRST [	HRLI B,377777	;indicate actual type # rather than routine
		SKIPGE DTYPE	;DON'T CHANGE IF ALREADY SET
		 MOVEM B,DTYPE	;SET /DEFAULT: IF KNOWN
		JRST .+1 ]
	SKIPG B,LENGTH		;USE EXISTING VALUE IF ANY
	 SKIPL B,B%LENGTH(A)
	  MOVEM B,LENGTH	;SET /WIDTH:
	SKIPG B,WIDTH
	 SKIPL B,B%WIDTH(A)
	  MOVEM B,WIDTH		;SET /LENGTH:
	SKIPG B,LINEF		;USE EXISTING VALUE IF ANY
	 SKIPL B,B%DPLXMODE(A)
	  MOVEM B,LINEF		;SET DUPLEX MODE

;SET PRINT NODE

	DMOVE B,PRINT		;GET PRINT NODE (TWO WORDS)
	CAME B,[-1]		;ANYTHING SET?
	JRST BINRD0		;SOMETHING ALREADY THERE, SKIP TO THE BITS
	DMOVE B,B%PRINT(A)	;FETCH DEFAULT 
	CAMN B,[-1]		;DO WE KNOW ANYTHING?
	DMOVE B,[ASCIZ/LOCAL/]	;NO, SO USE LOCAL:: AS OUR NODE NAME
	DMOVEM B,PRINT		;SET THE NODE NAME UP
	
BINRD0:	MOVE B,B%BITS(A)	;GET TABLE OF BITS (N.B. WE USE ONLY
				;FIRST WORD!)
	HRLZI C,-BINRLN		;GET NUMBER OF BITS WE'RE CHECKING.
BINRD1:	MOVEI D,1		;GET A "TRUE" VALUE
	TDNN B,BINRTB(C)	;IS THIS BIT SET?
	 MOVEI D,0		;NO, USE FALSE
	SKIPGE @BINRTL(C)	;USE EXISTING VALUE IF ANY
	 MOVEM D,@BINRTL(C)
	AOBJN C,BINRD1
	RET			;ALL DONE

BINRTB:	B%FORMFEED
	B%LOWERCASE
	B%TABS
	B%PAGEPAUSE
	B%COMMANDPAUSE
	B%RAISE
	B%FLAG
BINRLN==.-BINRTB
BINRTL:	IFIW!FORMF
	IFIW!LOWERF
	IFIW!TABF
	IFIW!PAUSEF
	IFIW!CTLSF
	IFIW!RAISEF
	IFIW!FLAGF
IFN <.-BINRTL>-BINRLN,<PRINTX %WARNING.  BINRTB & BINRTL TABLES NOT SAME LENGTH
>
	SUBTTL WRITE BINARY FILE FROM RAW DATA FILE


$BINMK:	CONFIRM			;WAIT FOR CONFIRMATION
	SETOM BINFLG		;FLAG THAT WE'RE CREATING A BINARY FILE
	AOS CHANGE		;THIS NEEDS TWIDDLING FOR SOME REASON
	TMSG <Generating binary file...> ;SAY WHAT WE'RE DOING
	CALL STRBIN		;SET UP BINARY FILE
	JRST COMDON		;JOIN PARSE LOOP

;HERE TO PROCESS A LINE OF THE RAW DATA FILE

BINLIN:	MOVEM B,THELIN		;SAVE TTY NUMBER IN THELIN
	CALL BINLN0		;PARSE THE LINE
	JRST FILLOP		;AND ON FOR MORE LINES

BINLN0:	FIELD(COMAND,TRMERR)
	HRRZ B,(B)
	MOVE A,B
	HRRZ C,C
	CAIN C,COMAND		;CONFIRMATION?
	JRST BINWRT		;YES, GO GET THE NEXT LINE OF DATA
	CAIN C,COMTYP		;PARSED A TTY TYPE?
	MOVEI A,SETTYP
	CALL (A)		;CALL ROUTINE TO FETCH TTY TYPE IN B
	 JRST COMERR		;OOPS
	JRST BINLN0		;LOOP OVER THE REST OF THE LINE


;OK, WE'VE SET UP THE LOCAL VERSIONS OF THE DATA FOR THIS LINE.  PROCESS THEM.
BINWRT:	MOVE A,THELIN		;GET LINE NUMBER
	CAMLE A,B%MAXK		;LARGER THAN MAX SEEN SO FAR?
	 MOVEM A,B%MAXK		; YES.
	CALL BINLOC		;FIND BASE OF DATA FOR THAT LINE (INTO A)
	 JRST [	JSMSG <Invalid line number specified>
		JRST COMLOP ]	;OOPS.  INVALID LINE NUMBER
	MOVE 14,A
	SKIPLE B,TYPE		;SET TYPE IF KNOWN
	 CALL (B)		;CALL THE RELEVANT ROUTINE
	MOVEM B,B%TTYTYPE(14)
	SKIPLE B,DTYPE		;SET /DEFAULT: IF KNOWN
	 CALL (B)		;N.B. WE SET FLAGS BASED ON DEFAULT TYPE!
	MOVEM B,B%DEFTTYTYPE(14)
	MOVE B,LENGTH		;SET /WIDTH:
	MOVEM B,B%LENGTH(14)
	MOVE B,WIDTH		;SET /LENGTH:
	MOVEM B,B%WIDTH(14)
	MOVE B,LINEF		;SET DUPLEX MODE
	MOVEM B,B%DPLXMODE(14)
	SETZB B,C		;START WITH FALSE IN ALL
	TXO B,B%LOWERCASE!B%COMMANDPAUSE!B%PAGEPAUSE ;SOME DEFAULT TO ON
	SKIPN LOWERF		;CLEAR /LOWER?
	 TXZ B,B%LOWERCASE	;YES
	SKIPN PAUSEF		;CLEAR /PAUSE-AT-END-OF-PAGE?
	 TXZ B,B%PAGEPAUSE	;DEFAULT TO ON
	SKIPN CTLSF		;CLEAR /PAUSE-ON-COMMAND?
	 TXZ B,B%COMMANDPAUSE	; YES
	MOVEI D,1		;GET A "TRUE" VALUE FOR COMPARISON
	CAMN D,FORMF		;SET /FORMFEED
	 TXO B,B%FORMFEED
	CAMN D,TABF		;SET /TAB
	 TXO B,B%TABS
	CAMN D,RAISEF		;SET /RAISE
	 TXO B,B%RAISE
	CAMN D,FLAGF		;SET /FLAG
	 TXO B,B%FLAG
	CAMN D,ASSIG
	 TXO B,B%ASSIGNABLE
	CAMN D,OVERH
	 TXO B,B%OVERHEAD
	CAMN D,CONSU
	 TXO B,B%CONSULTANT
	CAMN D,EXPRE
	 TXO B,B%EXPRESS
	DMOVEM B,B%BITS(14)	;FINALLY, SAVE ALL THE BITS
	HRROI A,B%ADDR(14)	;SET UP ADDRESS STRING FOR FINGER
	HRROI B,ADDRE
	MOVEI C,5*6
	SETZ D,
	SOUT
	DMOVE A,PRINT		;FETCH NODE (TWO WORDS)
	DMOVEM A,B%PRINT(14)	;SET UP DECNET NODE
	MOVE B,LOCAT		;AND LOCATION
	MOVEM B,B%LOCATION(14)
	HRLZI A,-8		;NUMBER OF DIRECTIONS
	MOVE B,[POINT 9,B%NEIGHBOR(14)]
BINWR7:	MOVE C,DIRARR(A)	;GET ENTRY
	IDPB C,B
	AOBJN A,BINWR7		;PACK IT
	RET


;INITIALIZE THE BINARY FILE
STRBIN:	SETOM BINADR
	MOVE A,[BINADR,,BINADR+1]
	BLT A,BINADR+<B%DEFL*^D255> ;MAX 254 TERMINALS
	MOVEI A,B%DEFL
	MOVEM A,B%N		;NUMBER OF BLOCKS PER WORD
	SETZM B%MAXK		;NUMBER OF TERMINALS IN FILE
	MOVEI A,B%VNO
	MOVEM A,B%VERSI		;VERSION NUMBER OF FILE FORMAT
	RET

;HERE TO SAVE OUR DATA IN A BINARY FILE
MAKBIN:	STKVAR <BINJFN,BINEOF>		;JFN OF BINARY FILE
	MOVSI A,(GJ%FOU!GJ%SHT)
	HRROI B,[ASCIZ/SYSTEM:TTYINI.BIN/]
	GTJFN			;GET A HANDLE ON THE FILE
	 JSHLT			;SOME ERROR
	HRRZM A,BINJFN		;SAVE JFN
	MOVE B,[^D36B5+OF%WR]	;FULL WORD, WRITE ACCESS
	OPENF			;OPEN THE FILE
	 JSHLT			;SOME ERROR
	MOVE A,[.FHSLF,,BINPAG]	;SOURCE
	HRLZ B,BINJFN		;DESTINATION
	MOVE C,B%MAXK		;GET NUMBER OF ENTRIES
	IMUL C,B%N		;GET TOTAL NUMBER OF WORDS IN USE
	MOVEM C,BINEOF
	ADDI C,777
	LSH C,-9		;AND CONVERT TO PAGES
	TXO C,PM%CNT		;TURN ON COUNTING TOO
	PMAP			;MAP FROM MEMORY TO FILE
	MOVE A,BINJFN
	HRLI A,.FBSIZ		;CHANGE THE # OF BYTES
	SETO B,
	MOVE C,BINEOF
	CHFDB
	HRLI A,.FBBYV		;CHANGE THE BYTE SIZE
	MOVX B,FB%BSZ
	MOVE C,[^D36B11]	;36 BIT
	CHFDB
	MOVE A,BINJFN		;JFN OF BINARY FILE
	CLOSF			;CLOSE THE FILE
	 JSHLT			;SOME ERROR
	TMSG <[OK]
>		;SIGNAL THAT ALL WENT OKAY
	call wakmic
	RET			;RETURN TO CALLER

>;IFN BINSW


;send ipcf to micoms program
wakmic:	tmsg <Notifying MICOMS program of new database >
	skipn	fpid		;have micoms pid?
	 call	getpid		;get needed pids

	Setzm	DesBlk+.IPCFL	;flags
	Move	1,OurPid
	Movem	1,DesBlk+.IPCFS	;our pid
	Move	1,FPid		;F pid
	Movem	1,DesBlk+.IPCFR	;send to fpid
	Move	1,[1,,MsgBlk]	;length,,address of message
	Movem	1,DesBlk+.IPCFP	;save function pointer
	Move	1,[SIXBIT /NEWBIN/]
	Movem	1,MsgBlk
	Movei	1,.IPCFP+1	;length of pdb
	Movei	2,DesBlk	;address of description block
	MSEND%
	 Erjmp	nomicu		;too bad
	tmsg <[OK]
>
gonex:	ret			;always ok

nomicu:	tmsg <?unable to contact MICOMS program.
>
	ret

;get us pid of micoms program, and one for ourselves
getpid:	Setz	1,		;no pid yet
	Skipn	OurPid		;if we don't have one...
	 Txo	1,IP%CPD	; create a pid
	Movem	1,DesBlk+.IPCFL	;save in flag word area
	Move	1,OurPid
	Movem	1,DesBlk+.IPCFS
	Setzm	DesBlk+.IPCFR	;0 means send to Info
	Move	1,[PidLn,,FkPid]	;pid data block stuff
	Movem	1,DesBlk+.IPCFP ;save function pointer
	Movei	1,.IPCFP+1	;length of pdb
	Movei	2,DesBlk	;address of ipcf block
	MSEND%			;send request to INFO
	 Erjmp	[ret]

	Setzm	DesBlk+.IPCFL	;no flags
	Move	1,DesBlk+.IPCFS	;get our pid
	Movem	1,OurPid	;save it for later
	Movem	1,DesBlk+.IPCFR	;we are reciever
	Setzm	DesBlk+.IPCFS	;no sender yet
	Move	1,[ResLn,,MsgBlk] ;destination buffer
	Movem	1,DesBlk+.IPCFP
	Movei	1,.IPCFP+1	;length of message
	Movei	2,DesBlk
	MRECV%			;get reply from INFO
	 Erjmp	[ret]
	Load	1,IP%CFE,DesBlk
	Cain	1,.IPCNN
	 ret			;name not found
	Move	1,MsgBlk+.IPCI1	;get pid
	Movem	1,FPid		;save it
	Ret			;got pids

END XWD EVL,EV
