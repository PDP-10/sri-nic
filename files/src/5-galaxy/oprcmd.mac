;SRC:<5-GALAXY>OPRCMD.MAC.12, 23-Jul-86 16:10:54, Edit by KNIGHT
; SET NEW-LPFORM-FILE
;SRC:<5-GALAXY>OPRCMD.MAC.11, 23-Jul-86 09:36:09, Edit by KNIGHT
; SET DEFAULT PRINTER-VERIFICATION
;SRC:<5-GALAXY>OPRCMD.MAC.10, 22-Jul-86 15:54:55, Edit by KNIGHT
; Search QSRMAC
;SRC:<5-GALAXY>OPRCMD.MAC.9, 22-Jul-86 15:46:07, Edit by KNIGHT
; CMU/CU lintprint modifictions
;SRC:<5-GALAXY>OPRCMD.MAC.8,  4-Mar-86 11:36:53, Edit by KNIGHT
; Make SET FOREIGN-PRINTER limit junk work.
;SRC:<5-GALAXY>OPRCMD.MAC.7, 25-Feb-86 14:04:34, Edit by KNIGHT
; Enable RELEASE (FOREIGN PRINTER JOBS)
;SRC:<5-GALAXY>OPRCMD.MAC.6, 20-Feb-86 14:37:31, Edit by KNIGHT
;SRC:<5-GALAXY>OPRCMD.MAC.5, 14-Jan-86 15:55:18, Edit by KNIGHT
; Add foreign printer stuff
;[SRI-NIC]SRC:<5-GALAXY>OPRCMD.MAC.4,  1-Aug-85 16:42:21, Edit by HSS
; Disallow /Device for laser ('cause we're dumping the shitty Stanford
; LSRSPL
;[SRI-NIC]SRC:<5-GALAXY>OPRCMD.MAC.3, 26-Jun-85 18:10:33, Edit by HSS
; At ENA105:, a $KEY needed to be a $KEYDSP
;[SRI-NIC]SRC:<6-GALAXY>OPRCMD.MAC.2, 16-May-85 15:10:43, Edit by HSS
; [LSRSPL] Add LASER support

	TITLE	OPRCMD - command tables for ORION
	SUBTTL	Preliminaries

;
;
;		COPYRIGHT (C) DIGITAL EQUIPMENT CORPORATION
;	     1975,1976,1977,1978,1979,1980,1981,1982,1983,1984
;
;     THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY  BE  USED
;     AND COPIED ONLY IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE
;     AND WITH THE INCLUSION OF THE ABOVE COPYRIGHT NOTICE.   THIS
;     SOFTWARE  OR ANY OTHER COPIES THEREOF MAY NOT BE PROVIDED OR
;     OTHERWISE MADE AVAILABLE TO ANY OTHER PERSON.  NO  TITLE  TO
;     AND OWNERSHIP OF THE SOFTWARE IS HEREBY TRANSFERRED.
;     
;     THE INFORMATION  IN  THIS  SOFTWARE  IS  SUBJECT  TO  CHANGE
;     WITHOUT  NOTICE  AND SHOULD NOT BE CONSTRUED AS A COMMITMENT
;     BY DIGITAL EQUIPMENT CORPORATION.
;     
;     DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE OR RELIABILITY
;     OF  ITS  SOFTWARE  ON  EQUIPMENT  WHICH  IS  NOT SUPPLIED BY
;     DIGITAL.


	SALL
	SEARCH	GLXMAC
	SEARCH	ORNMAC
	SEARCH	QSRMAC
	SEARCH  MONSYM,MACSYM
	PROLOG(OPRCMD)

;Version numbers

	CMDMAN==:147			;Maintenance edit number
	CMDDEV==:174			;Development edit number
	VERSIN (CMD)			;Generate edit number

	.DIRECTIVE FLBLST



	INTERN	OPRCMD	;MAKE VECTOR ADDRESS AVAILABLE
OPRCMD:	EXP	2	;SIZE
	EXP	INITCM	;POINTER TO THE INI FUNCTION
	EXP	CMDFDB	;TOP LEVEL DISPATCH
	SUBTTL	Table of Contents


;		Table of Contents for OPRCMD
;
;
;			   Section			      Page
;   1. Preliminaries. . . . . . . . . . . . . . . . . . . . .    1
;   2. Table of Contents. . . . . . . . . . . . . . . . . . .    2
;   3. Revision history . . . . . . . . . . . . . . . . . . .    3
;   4. Special Macro Definitions. . . . . . . . . . . . . . .    4
;   5. $UNIT Macro. . . . . . . . . . . . . . . . . . . . . .    4
;   6. $STNUM Macro . . . . . . . . . . . . . . . . . . . . .    4
;   7. $STREAM Macro. . . . . . . . . . . . . . . . . . . . .    4
;   8. $EXPL Macro Definition . . . . . . . . . . . . . . . .    5
;   9. $URANGE Macro Definition . . . . . . . . . . . . . . .    6
;  10. $SRANGE Macro Definition . . . . . . . . . . . . . . .    6
;  11. Subroutine macros. . . . . . . . . . . . . . . . . . .    7
;  12. Command Dispatch . . . . . . . . . . . . . . . . . . .    8
;  13. Argument Subroutines . . . . . . . . . . . . . . . . .    9
;  14. START command tables . . . . . . . . . . . . . . . . .   10
;  15. CONTINUE command tables. . . . . . . . . . . . . . . .   11
;  16. SHUTDOWN command tables. . . . . . . . . . . . . . . .   11
;  17. STOP command tables. . . . . . . . . . . . . . . . . .   12
;  18. ABORT command tables . . . . . . . . . . . . . . . . .   13
;  19. HOLD command tables. . . . . . . . . . . . . . . . . .   14
;  20. RELEASE command tables . . . . . . . . . . . . . . . .   14
;  21. DEFINE command tables. . . . . . . . . . . . . . . . .   15
;  22. CANCEL command tables. . . . . . . . . . . . . . . . .   16
;  23. MODIFY command tables. . . . . . . . . . . . . . . . .   17
;  24. SHOW command tables. . . . . . . . . . . . . . . . . .   18
;  25. SHOW STATUS command tables . . . . . . . . . . . . . .   20
;  26. SHOW SYSTEM-LIST command tables. . . . . . . . . . . .   21
;  27. LOCK/UNLOCK command tables . . . . . . . . . . . . . .   22
;  28. SHWNOD . . . . . . . . . . . . . . . . . . . . . . . .   23
;  29. RESPOND command tables . . . . . . . . . . . . . . . .   24
;  30. REQUEUE command tables . . . . . . . . . . . . . . . .   25
;  31. BACKSPACE command tables . . . . . . . . . . . . . . .   26
;  32. FORWARDSPACE command tables. . . . . . . . . . . . . .   26
;  33. ALIGN command table. . . . . . . . . . . . . . . . . .   27
;  34. SUPPRESS command tables. . . . . . . . . . . . . . . .   28
;  35. ROUTE command tables . . . . . . . . . . . . . . . . .   29
;  36. SEND command tables. . . . . . . . . . . . . . . . . .   30
;  37. SET command tables . . . . . . . . . . . . . . . . . .   32
;  38. SET STRUCTURE command tables . . . . . . . . . . . . .   33
;  39. SET TAPE command tables. . . . . . . . . . . . . . . .   34
;  40. SET DISK command tables. . . . . . . . . . . . . . . .   35
;  41. SET ONLINE command tables. . . . . . . . . . . . . . .   36
;  42. SET USAGE command tables . . . . . . . . . . . . . . .   37
;  43. SET TAPE INITIALIZE command tables . . . . . . . . . .   38
;  44. SET NODE command tables. . . . . . . . . . . . . . . .   39
;  45. SET SCHEDULER command tables (TOPS20). . . . . . . . .   40
;  46. SET PORT command tables. . . . . . . . . . . . . . . .   41
;  47. ENABLE/DISABLE command tables. . . . . . . . . . . . .   42
;  48. ENACLS . . . . . . . . . . . . . . . . . . . . . . . .   44
;  49. CLOSE command tables . . . . . . . . . . . . . . . . .   45
;  50. DEFINE command tables. . . . . . . . . . . . . . . . .   45
;  51. REPORT command tables. . . . . . . . . . . . . . . . .   46
;  52. MOUNT command tables (TOPS10). . . . . . . . . . . . .   47
;  53. NEXT - NEXT COMMAND. . . . . . . . . . . . . . . . . .   48
;  54. IDENTIFY command tables. . . . . . . . . . . . . . . .   49
;  55. SWITCH . . . . . . . . . . . . . . . . . . . . . . . .   50
;  56. DISMOUNT command tables. . . . . . . . . . . . . . . .   51
;  57. UNLOAD . . . . . . . . . . . . . . . . . . . . . . . .   51
;  58. RECOGNIZE command tables . . . . . . . . . . . . . . .   51
;  59. PUSH command tables. . . . . . . . . . . . . . . . . .   52
;  60. HELP command tables. . . . . . . . . . . . . . . . . .   53
;  61. SHOW ALLOCATION command tables . . . . . . . . . . . .   54
SUBTTL	Revision history

COMMENT \

146	4.2.1484	9-Aug-82
	Allow secondary ports to work on MODIFY commands.

147	4.2.1555	24-Oct-83
	Add some range checking stuff to prevent too many objects at
a time from being started.

*****  Release 4.2 -- begin maintenance edits  *****

*****  Release 5.0 -- begin development edits  *****

160	5.1003		4-Jan-83
	Move to new development area.  Add version vector.  Clean up
edit organization.  Update TOC.

161	5.1021		5-Apr-83
	Add SET STR SHARED/EXCLUSIVE.  Add SET PORT CI ONLINE/OFFLINE.

162	5.1026		6-May-83
	Add new ENABLE/DISABLE OUTPUT options for BUGCHK, BUGINF and SYSTEM
messages.

163	5.1027		10-May-83
	Change SET PORT CI ONLINE/OFFLINE to AVAILABLE/UNAVAILABLE.

164	5.1035		18-Jul-83
	Add support for new DISMOUNT (with) REMOVAL/NOREMOVAL.  While here,
clearify a SET ONLINE help message.

165	5.1058		23-Nov-83
	Make the SET TERMINAL command invisible for this release.  Remove
it in next release.

166	5.1069		23-Jan-84
	Add SHOW STATUS STRUCTURE command.

167	5.1075		3-Feb-84
	Add structure name to SHOW STATUS STRUCTURE command if desired.

170	5.1080		5-Feb-84
	Add UNDEFINE STRUCTURE FOO: command.

171	5.1111		1-Mar-84
	Add MOUNT STRUCTURE alias: /STRUCTURE-ID:structure name command

172	5.1124		2-Apr-84
	Add controller number to the SET DISK UNAVAILABLE.

173	5.1162		21-Sep-84
	Add changes to support SNA Workstations

174	5.1169		19-Oct-84
	Correct problems due to new SNA Workstations functionality.

\   ;End of Revision History
SUBTTL	Special Macro Definitions
IFN NICSW,<
SUBTTL	$PNKEY Macro
SUBTTL	$FTKEY Macro
SUBTTL	$PTKEY Macro

;Define a macro to parse printer name keywords
DEFINE $PNKEY (NEXT,ALT,%FDBL,%PDBL,%PDB) <
	.XCREF %FDBL,%PDBL,%PDB
	SUPPRESS %FDBL,%PDBL,%PDB
%PDB:!	XWD %PDBL,%FDBL
IFIDN <ALT> <>,<FLD(.CMKEY,CM%FNC)!CM%HPP>
IFDIF <ALT> <>,<FLD(.CMKEY,CM%FNC)!CM%HPP!ALT+1>
	0
	POINT 7,[ASCIZ /printer name,/]
%FDBL==.-%PDB
	NEXT
	SAVEPK
	0
	BLDPNM
%PDBL==.-%PDB
>	;End $PNKEY definition

;Define a macro to parse forms type keywords
DEFINE $FTKEY (NEXT,ALT,%FDBL,%PDBL,%PDB) <
	.XCREF %FDBL,%PDBL,%PDB
	SUPPRESS %FDBL,%PDBL,%PDB
%PDB:!	XWD %PDBL,%FDBL
IFIDN <ALT> <>,<FLD(.CMKEY,CM%FNC)!CM%HPP>
IFDIF <ALT> <>,<FLD(.CMKEY,CM%FNC)!CM%HPP!ALT+1>
	0
	POINT 7,[ASCIZ /forms type,/]
%FDBL==.-%PDB
	NEXT
	SAVEPK
	0
	BLDFMT
%PDBL==.-%PDB
>	;End $FTKEY definition

;Define a macro to parse printer keywords
DEFINE $PTKEY (NEXT,ALT,%FDBL,%PDBL,%PDB) <
	.XCREF %FDBL,%PDBL,%PDB
	SUPPRESS %FDBL,%PDBL,%PDB
%PDB:!	XWD %PDBL,%FDBL
IFIDN <ALT> <>,<FLD(.CMKEY,CM%FNC)!CM%HPP>
IFDIF <ALT> <>,<FLD(.CMKEY,CM%FNC)!CM%HPP!ALT+1>
	0
	POINT 7,[ASCIZ /paper type,/]
%FDBL==.-%PDB
	NEXT
	SAVEPK
	0
	BLDPPT
%PDBL==.-%PDB
>	;End $PTKEY definition
>;IFN NICSW

SUBTTL	$UNIT Macro
SUBTTL	$STNUM Macro
SUBTTL	$STREAM Macro


;	!=======================================================!
;	!                   $UNIT (NEXT_PDB)                    !
;	!-------------------------------------------------------!
;	!               PARSE A UNIT NUMBER ONLY                !
;	!=======================================================!

;DEFINE A MACRO TO DO THE PARSING FOR A SINGLE UNIT NUMBER
DEFINE	$UNIT(NEXT,%UNI01,%UNI02),<
	.XCREF	%UNI01,%UNI02
	SUPPRESS %UNI01,%UNI02
	$NOISE	(%UNI01,<unit number>)
%UNI01:	$NUMBER	(%UNI02,^D10,<unit number (/NODE:)>,<$ACTION(CHKVAL)>)
%UNI02:	$NODE(NEXT)
>	;END $UNIT DEFINITION




;	!=======================================================!
;	!                   $STNUM (NEXT_PDB)                   !
;	!-------------------------------------------------------!
;	!              PARSE A STREAM NUMBER ONLY               !
;	!=======================================================!

;DEFINE A MACRO TO DO THE PARSING FOR A SINGLE STREAM NUMBER
;WITHOUT AN OPTIONAL NODE SPECIFICATION
DEFINE	$STNUM(NEXT,%STN01),<
	.XCREF	%STN01
	SUPPRESS %STN01
	$NOISE	(%STN01,<stream number>)
%STN01:	$NUMBER	(NEXT,^D10,<stream number>,$ACTION(CHKVAL))
>	;END $STNUM DEFINITION




;	!=======================================================!
;	!                  $STREAM (NEXT_PDB)                   !
;	!-------------------------------------------------------!
;	!           PARSE A STREAM WITH OPTIONAL NODE           !
;	!=======================================================!

;DEFINE A MACRO TO DO THE PARSING FOR A SINGLE STREAM NUMBER
DEFINE	$STREAM(NEXT,%STR01,%STR02),<
	.XCREF	%STR01,%STR02
	SUPPRESS %STR01,%STR02
	$NOISE	(%STR01,<stream number>)
%STR01:	$NUMBER	(%STR02,^D10,<stream number (/NODE:)>,$ACTION(CHKVAL))
%STR02:	$NODE(NEXT)
>	;END $STREAM DEFINITION
SUBTTL	$EXPL Macro Definition


;	!=======================================================!
;	!            $EXPL (NEXT_PDB,<KEYWORD-LIST>)            !
;	!-------------------------------------------------------!
;	!                     /REASON:TEXT                      !
;	!=======================================================!

;DEFINE A <EXPL> DEFINITION MACRO
DEFINE $EXPL (NXTLNK,ALTADR,%A,%B,%C)<
	.XCREF	%A,%B,%C
	SUPPRESS %A,%B,%C
	$SWITCH(%B,%A,ALTADR)
%A:	$STAB
	ORNSWI	(<REASON:>,RSN)
	$ETAB
%B:	$CRLF	(<$ALTER(%C),$ACTION(TXTLIN##),$HELP(<confirm for multiple line response>)>)

%C:	$CTEXT	(CONFRM,<single line response>)
>
SUBTTL	$URANGE Macro Definition
SUBTTL	$SRANGE Macro Definition

;	!=======================================================!
;	!                  $URANGE (NEXT_PDB)                   !
;	!-------------------------------------------------------!
;	!         PARSE A UNIT RANGE WITH OPTIONAL NODE         !
;	!=======================================================!

;DEFINE A MACRO TO DO THE PARSING FOR A RANGE OF UNIT NUMBERS
DEFINE	$URANGE(NEXT,%URG01,%URG02),<
	.XCREF	%URG01,%URG02
	SUPPRESS %URG01,%URG02
	$NOISE	(%URG01,<unit number>)
%URG01:	$ORANGE(%URG02,<number or range (n:m)(/NODE:)>)
%URG02:	$NODE(NEXT)
>	;END $URANGE DEFINITION
;	!=======================================================!
;	!                  $SRANGE (NEXT_PDB)                   !
;	!-------------------------------------------------------!
;	!        PARSE A STREAM RANGE WITH OPTIONAL NODE        !
;	!=======================================================!

;DEFINE A MACRO TO DO THE PARSING FOR A RANGE OF STREAM NUMBERS
DEFINE	$SRANGE(NEXT,%SRG01,%SRG02),<
	.XCREF	%SRG01,%SRG02
	SUPPRESS %SRG01,%SRG02
	$NOISE	(%SRG01,<stream number>)
%SRG01:	$ORANGE(%SRG02,<number or range (n:m)(/NODE:)>)
%SRG02:	$NODE(NEXT)
>	;END $SRANGE DEFINITION
SUBTTL	Subroutine macros

;DEFINE A MACRO TO ACTUALLY PARSE A RANGE OF OCTAL NUMBERS SPECIFIED AS
;   NUMBER:NUMBER (OR JUST NUMBER) WITH AN OPTIONAL NODE SWITCH

	DEFINE	$RANGE(NEXT,HLPT,ARGLST,%RNG01,%RNG02),<
	.XCREF	%RNG01,%RNG02
	SUPPRESS %RNG01,%RNG02
	$NUMBER	(%RNG01,^D10,HLPT,<$ACTION(STOBTH),ARGLST>)

%RNG01:	$TOKEN	(%RNG02,<:>,<$HELP(<colon to specify a range>),$ALTERNATE(NEXT)>)

%RNG02:	$NUMBER	(NEXT,^D10,,<$ACTION(STOHGH)>)

>	;END DEFINITION OF $RANGE

;$ORANGE (that's O-RANGE, not the citrus fruit!) is the same as $RANGE with
;one difference, the range itself is checked for width using routine STOOHG
;instead of STOHGH.

	DEFINE	$ORANGE(NEXT,HLPT,ARGLST,%ORG01,%ORG02),<
	.XCREF	%ORG01,%ORG02
	SUPPRESS %ORG01,%ORG02
	$NUMBER	(%ORG01,^D10,HLPT,<$ACTION(STOBTH),ARGLST>)

%ORG01:	$TOKEN	(%ORG02,<:>,<$HELP(<colon to specify a range>),$ALTERNATE(NEXT)>)

%ORG02:	$NUMBER	(NEXT,^D10,,<$ACTION(STOOHG)>)

>	;END DEFINITION OF $ORANGE

;DEFINE A MACRO FOR CORRECT PARSING OF THE OPTIONAL /NODE SWITCH

DEFINE	$NODE(NEXT,%NOD01,%NOD02),<
	.XCREF	%NOD01,%NOD02
	SUPPRESS %NOD01,%NOD02

	$SWITCH (%NOD02,%NOD01,<$ALTERNATE(NEXT)>)

%NOD01:	$STAB
	ORNSWI(NODE:,NOD)
	$ETAB

%NOD02:	$NODNM	(NEXT,<node name>,<$FLAGS(CM%PO!CM%NSF)>)

>	;END $NODE DEFINITION

SUBTTL	SNADST Macro Definition

; SNADST (next-pdb) - Parse destination field for SNA Workstation line printer
;		      or card punch stream

DEFINE	SNADST (NEXT,%A,%B,%C,%D,%E,%F), <
	$CTEXT(%A,<node"user password account"::dev:[directory]>,<$FLAGS(CM%BRK),$BREAK(DSTBRK)>)
%A:	$SWIDSP	(%D,<$ALTERNATE(NEXT)>)
%B:	$SWIDSP	(%E,<$ALTERNATE(NEXT)>)
%C:	$SWIDSP	(%F,<$ALTERNATE(NEXT)>)

%D:	$STAB
	DSPTAB	(%B,.SWNTL,<NOTRANSLATE>)
	DSPTAB	(%C,.SWSPL,<SPOOL>)
	$ETAB

%E:	$STAB
	DSPTAB	(NEXT,.SWSPL,<SPOOL>)
	$ETAB

%F:	$STAB
	DSPTAB	(NEXT,.SWNTL,<NOTRANSLATE>)
	$ETAB

	IF2 <PURGE %A,%B,%C,%D,%E,%F>

	>			;End of SNADST macro definition

DSTBRK:	BRMSK. (EOLB0.,EOLB1.,EOLB2.,EOLB3.,,</>)	;Break set
SUBTTL	Command Dispatch

INITCM:: $INIT(CMDFDB)
CMDFDB:: $KEYDSP(CMDTAB,<$ACTION(CMDACT##),$ERROR(BADCOM)>)

CMDTAB:	$STAB
TOPS10<	ORNDSP(,\"32,CTZ,CM%INV) >
	ORNDSP(ABOFDB,ABORT,CNC)
	ORNDSP(ALIFDB,ALIGN,ALI)
	ORNDSP(BKSFDB,BACKSPACE,BKS)
	ORNDSP(CANFDB,CANCEL,DEL)
	ORNDSP(CLOFDB,CLOSE,CLO)
	ORNDSP(UNVFDB,CONTINUE,CNT)
IFN	FTDN60,<
	ORNDSP(DEFFDB,DEFINE,DEF)
>;END FTDN60
	ORNDSP(ENAFDB,DISABLE,DIS)
	ORNDSP(DSMFDB,DISMOUNT,DSM) 
	ORNDSP(ENAFDB,ENABLE,ENA)
IFN	NUMAPL,<			;CHECK IS ANY APPLICATION TABLES
	ORNDSP(ENTFDB##,ENTER,ENT)
>;END NUMAPL
	ORNDSP(EXTFDB##,EXIT,EXT)
	ORNDSP(BKSFDB,FORWARDSPACE,FWS)
	ORNDSP(HLPFDB,HELP,HLP)
	ORNDSP(HLDFDB,HOLD,HLD)
	ORNDSP(IDNFDB,IDENTIFY,IDN)
TOPS10<	ORNDSP(LOCFDB,LOCK,LOC)>
	ORNDSP(MODFDB,MODIFY,MOD)
	ORNDSP(MTNFDB,MOUNT,MTN)
	ORNDSP(NXTFDB,NEXT,NXT)		;[NXT] Operator NEXT command
TOPS20<	ORNDSP(PUSFDB,PUSH,PUS)>
TOPS10<	ORNDSP(RECFDB,RECOGNIZE,REC)>
	ORNDSP(HLDFDB,RELEASE,REL)
	ORNDSP(RPTFDB,REPORT,RPT)
	ORNDSP(REQFDB,REQUEUE,REQ)
	ORNDSP(RSPFDB,RESPOND,RSP)
	ORNDSP(RTEFDB,ROUTE,RTE)
	ORNDSP(SNDFDB,SEND,SND)
	ORNDSP(SETFDB,SET,SET)
	ORNDSP(SHWFDB,SHOW,SHW)
	ORNDSP(SHDFDB,SHUTDOWN,SHD)
	ORNDSP(STAFDB,START,STA)
	ORNDSP(STPFDB,STOP,PAU)
	ORNDSP(SUPFDB,SUPPRESS,SUP)
TOPS20<	ORNDSP(SWIFDB,SWITCH,SWI)>
	ORNDSP(TAKOPR##,TAKE,TAK)
	ORNDSP(UNDFDB,UNDEFINE,UDF)
	ORNDSP(WAIOPR##,WAIT,WAI)
	$ETAB

BADCOM:	MOVEI	S2,[ASCIZ/Invalid OPR command specified/]
	$RETF				;BAD COMMAND

IFN NICSW,<
	SUBTTL	PKT subroutines
;Save a printer keyword
SAVEPK:	MOVE	S1,ARGFRE##	;Get the argument pointer
	SUBI	S1,1		;Back it up one
	MOVE	S2,(S1)		;Get the value saved
	MOVE	S2,(S2)		;Off by a level of indirection
	MOVEM	S2,(S1)		;Correct the problem
	$RETT			;And return true

;Build the printer name table
BLDPNM:	$CALL	CHKPKT		;Check the printer keyword tables
	SKIPT			;Need to map them in ??
	$CALL	MAPPKT		;Yes, map 'em in
	MOVE	S1,PKTPAG	;Get the address of the printer keywords
	MOVE	S1,.UTOFF(S1)	;Get the address of the unit name table
	MOVE	S2,CURPDB##	;Get the address of the current PDB
	MOVEM	S1,.CMDAT(S2)	;And save the address of the keyword table
	$RETT			;Return true

;Build the forms name table
BLDFMT:	$CALL	CHKPKT		;Check the printer keyword tables
	SKIPT			;Need to map them in ??
	$CALL	MAPPKT		;Yes, map 'em in
	MOVE	S1,PKTPAG	;Get the address of the printer keywords
	MOVE	S1,.FTOFF(S1)	;Get the address of the forms name table
	MOVE	S2,CURPDB##	;Get the address of the current PDB
	MOVEM	S1,.CMDAT(S2)	;And save the address of the keyword table
	$RETT			;Return true

;Build the paper name table
BLDPPT:	$CALL	CHKPKT		;Check the printer keyword tables
	SKIPT			;Need to map them in ??
	$CALL	MAPPKT		;Yes, map 'em in
	MOVE	S1,PKTPAG	;Get the address of the printer keywords
	MOVE	S1,.PTOFF(S1)	;Get the address of the paper name table
	MOVE	S2,CURPDB##	;Get the address of the current PDB
	MOVEM	S1,.CMDAT(S2)	;And save the address of the keyword table
	$RETT			;Return true

;Check for a new printer keyword table file
CHKPKT:	SKIPG	PKTPAG		;Have printer keyword tables yet ??
	$RETF			;No, definitely get them then
	MOVX	S1,GJ%SHT!GJ%OLD ;Old file
	HRROI	S2,[ASCIZ /SYSTEM:PRINTER-KEYWORD-TABLES.BIN.0/]
	GTJFN%
	JRST	S..MPG
	HRRZS	S1
	MOVEM	S1,PKTJFN	;Save the jfn
	MOVE	S2,[1,,.FBWRT]	;Last write time
	MOVEI	T1,S2		;In S2
	GTFDB%			;Get it
	CAMG	S2,PKTTIM	;A newer version ??
	JRST [	MOVE S1,PKTJFN	;No, get the jfn
		RLJFN%		;And release it
		 TRN		;...
		SETZM PKTJFN	;Zero the jfn
		$RETT]		;And return true
	MOVEM	S2,PKTTIM	;Save the new time
	$RETF			;Return false and map the file

MAPPKT:	SKIPE	PKTPAG		;Need the space ??
	JRST	MAPK.0		;No, just map in the file
	MOVEI	S1,2		;Need two pages
	$CALL	M%AQNP		;A page each for the keyword tables and strings
	PG2ADR	S1		;Make an address
	MOVEM	S1,PKTPAG	;Save the address of the keyword tables
	MOVX	S1,GJ%SHT!GJ%OLD ;Old file
	HRROI	S2,[ASCIZ /SYSTEM:PRINTER-KEYWORD-TABLES.BIN.0/]
	GTJFN%
	$STOP	(MPG,Cannot GTJFN% for PKT file)
	HRRZS	S1
	MOVEM	S1,PKTJFN	;Save the jfn
	MOVE	S2,[1,,.FBWRT]	;Last write time
	MOVEI	T1,S2		;In S2
	GTFDB%			;Get it
	MOVEM	S2,PKTTIM	;And save it
MAPK.0:	MOVE	S1,PKTJFN	;Get the JFN
	MOVX	S2,FLD(^D36,OF%BSZ)!OF%RD
	OPENF%			;Open the file
	$STOP	(MPO,Cannot OPENF% the PKT file)
	HRLZ	S1,PKTJFN	;Get the jfn,,zero
	MOVE	S2,PKTPAG	;And the buffer address
	ADR2PG	S2		;Make it a page number
	HRLI	S2,.FHSLF	;This process
	MOVX	T1,PM%CNT!PM%RD!PM%CPY!PM%PLD!FLD(2,PM%RPT)
	PMAP%			;Map the file
	MOVE	S1,PKTPAG	;Address of the buffer
	SETMM	(S1)		;Make the table private
	SETMM	1000(S1)	;And the strings
	MOVE	S1,PKTJFN	;Get the JFN again
	CLOSF%			;Close the file
	 ERJMP .+1		;...
	RLJFN%			;Release the JFN
	 TRN			;...
	SETZM	PKTJFN		;Zero the jfn
	MOVE	S1,PKTPAG	;Address of the buffer
	ADDM	S1,.UTOFF(S1)	;The address of the unit names table
	ADDM	S1,.PTOFF(S1)	;The address of the paper types table
	ADDM	S1,.FTOFF(S1)	;The address of the form types table
	HRLZ	S2,@.UTOFF(S1)	;Get the number of keywords here
	JUMPE	S2,MAPK.2	;If none, go on
	MOVNS	S2		;Make it negative
	ADD	S2,.UTOFF(S1)	;And point at the table
MAPK.1:	HLRZ	T1,1(S2)	;Get the keyword name address
	ADD	T1,PKTPAG	;Add in the table address
	HRLZS	T1		;And get it back into the left half
	HRR	T1,1(S2)	;Get the value address
	ADD	T1,PKTPAG	;Add the table address in here, also
	MOVEM	T1,1(S2)	;Put back the entry with absolute addresses
	AOBJN	S2,MAPK.1	;Do all of the entries in the table
MAPK.2:	HRLZ	S2,@.PTOFF(S1)	;Get the number of keywords here
	JUMPE	S2,MAPK.4	;If none, go on
	MOVNS	S2		;Make it negative
	ADD	S2,.PTOFF(S1)	;And point at the table
MAPK.3:	HLRZ	T1,1(S2)	;Get the keyword name address
	ADD	T1,PKTPAG	;Add in the table address
	HRLZS	T1		;And get it back into the left half
	HRR	T1,1(S2)	;Get the value address
	ADD	T1,PKTPAG	;Add the table address in here, also
	MOVEM	T1,1(S2)	;Put back the entry with absolute addresses
	AOBJN	S2,MAPK.3	;Do all of the entries in the table
MAPK.4:	HRLZ	S2,@.FTOFF(S1)	;Get the number of keywords here
	JUMPE	S2,MAPK.6	;If none, go on
	MOVNS	S2		;Make it negative
	ADD	S2,.FTOFF(S1)	;And point at the table
MAPK.5:	HLRZ	T1,1(S2)	;Get the keyword name address
	ADD	T1,PKTPAG	;Add in the table address
	HRLZS	T1		;And get it back into the left half
	HRR	T1,1(S2)	;Get the value address
	ADD	T1,PKTPAG	;Add the table address in here, also
	MOVEM	T1,1(S2)	;Put back the entry with absolute addresses
	AOBJN	S2,MAPK.5	;Do all of the entries in the table
MAPK.6:	$RETT			;Return true
>;IFN NICSW
SUBTTL	Argument Subroutines

;ACTION ROUTINE CALLED ON $UNIT MACRO TO BARF ON NEGATIVE UNIT
;NUMBER ARGUMENTS.
CHKVAL:	SKIPL	CR.RES(S2)	;CHECK THAT NUMBER
	$RETT			;IT'S GOOD
	PUSHJ	P,FIXIT
	MOVEI	S2,[ASCIZ/Negative number improper/]
	$RETF

CHKPOS:	SKIPLE	CR.RES(S2)	;CHECK THE NUMBER
	$RETT			;O.K..RETURN
	PUSHJ	P,FIXIT		;FIXUP COMMAND
	MOVEI	S2,[ASCIZ/Number must be positive/]
	$RETF			;RETURN FALSE

; ACTION ROUTINE TO CHECK PRIORITY RANGES
CHKPRI:	SKIPLE	T1,CR.RES(S2)	;CHECK THAT NUMBER
	CAILE	T1,^D63
	SKIPA
	$RETT			;IT'S GOOD
	PUSHJ	P,FIXIT
	MOVEI	S2,[ASCIZ/Priority not in range/]
	$RETF

;TEMPORARY STORAGE FOR RANGE ARGUMENT
	$DATA	LSTARG,1		;LAST PARSED ARGUMENT ADDRESS
IFN NICSW,<
	$DATA	PKTPAG,1		;{G6} Where the PKT file is mapped
	$DATA	PKTJFN,1		;{G6} Printer keyword table file jfn
	$DATA	PKTTIM,1		;{G6} Time that last version was made
>;IFN NICSW
	$GDATA	CMDCOD,1		;COMMAND FUNCTION CODE

STOBTH:	SKIPGE	T1,CR.RES(S2)
	PJRST	CHKVAL		;ABORT COMMAND
	MOVEM	T1,LSTARG
	$RETT

;  Routine STOOHG to check width of range for object commands as well as
;  the stuff checked by STOHGH.

STOOHG:	SKIPGE	T1,CR.RES(S2)		;Is the range at least positive?
	PJRST	CHKVAL			;No, abort command
	SUB	T1,LSTARG		;Subtract the beginning of range
	JUMPL	T1,STOH.1		;Bad range
	CAIGE	T1,MXOBJR		;Too big?
	$RETT				;Just fine
	JRST STOH.1			;Bad range

;  Action routine STOHGH to check range validity based on bottom and top
;  of range.

STOHGH:	SKIPGE	T1,CR.RES(S2)
	PJRST	CHKVAL		;ABORT COMMAND
	CAMGE	T1,LSTARG
	SKIPA			;SKIP AND LOAD ERROR
	$RETT

STOH.1:	PUSHJ	P,FIXIT
	MOVEI	S2,[ASCIZ /Improper range specification/]
	$RETF

FIXIT:	HRRZ	T4,CR.FLG(S2)	;GET ADR OF CMDBLK
	MOVE	T1,.CMPTR(T4)	;GET COMMAND POINTER
	MOVE	T2,.CMABP(T4)	;GET BP TO ATOM BUFFER
FIXI.1:	ILDB	T3,T2
	JUMPE	T3,FIXI.2	;DONE.. ALL FIXED UP
	PUSHJ	P,DBP		;DECREMENT THE BP
	AOS	.CMCNT(T4)
	JRST	FIXI.1		;TRY NEXT CHARACTER
FIXI.2:	MOVEM	T1,.CMPTR(T4)	;STORE ADJUSTED BP
	POPJ	P,0

;LOCAL ROUTINE TO DECREMENT BYTE POINTER IN T1
DBP:	SOS	T1
	IBP	T1
	IBP	T1
	IBP	T1
	IBP	T1
	$RETT
SUBTTL	START command tables

STAFDB:	$NOISE (STAF01,<object>)

STAF01:	$KEYDSP(STAF02)

STAF02:	$STAB
	ORNDSP(STAF03,BATCH-STREAM,BAT)
;[LSRSPL]	ORNDSP(STAF04,<CARD-PUNCH>,CDP)
IFN NICSW,<
REPEAT 0,<ORNDSP(STAF04,<FOREIGN-PRINTER>,PLT)>
>;IFN NICSW
IFN FTFTS,<
	ORNDSP(STAF03,<FAL-STREAM>,FAL)
	ORNDSP(STAF03,<FTS-STREAM>,FTS)
> ;End FTFTS conditional
IFN NICSW,<
REPEAT 0,<ORNDSP(STAF04,<LASER-PRINTER>,CDP)>
>;IFN NICSW
	ORNDSP(SHD030,<NODE>,NOD)
IFE NICSW,<
	ORNDSP(STAF04,<PAPER-TAPE-PUNCH>,PTP)
	ORNDSP(STAF04,<PLOTTER>,PLT)
>;IFE NICSW
	ORNDSP(STAF11,PRINTER,LPT)
IFE NICSW,<
	ORNDSP(STAF04,READER,RDR)
>;IFE NICSW
	$ETAB

STAF03:	$SRANGE(CONFRM)

STAF04:	$URANGE	(CONFRM)

IFE NICSW,<
STAF11:	$URANGE(STAF12)
>;IFE NICSW
IFN NICSW,<
STAF11:	$PNKEY (STAF12)	
>;IFN NICSW

STAF12:	$SWITCH	(STAF14,STAF13,<$ALTERNATE(<CONFRM>)>)

STAF13:	$STAB
	ORNSWI	(<DEVICE:>,DEV)
	$ETAB

STAF14:	$DEV(CONFRM,<$HELP(<tape drive name>)>)
SUBTTL	CONTINUE command tables
SUBTTL	SHUTDOWN command tables

COMMENT	\
NOTE: SHOULD IT BECOME DESIRABLE FOR THE SHUTDOWN AND
CONTINUE COMMANDS TO BE NO LONGER SYNTACTICALLY IDENTICAL THEN THE
COMMON USE OF THIS PDB CHAIN DEFINITION IS NO LONGER VALID.
\

SHDFDB:	$NOISE	(SHD010,<scheduling for>)

UNVFDB:	$NOISE (UNVF01,<object>)

UNVF01:	$KEYDSP(UNVF02)

UNVF02:	$STAB
	ORNDSP(UNVF03,BATCH-STREAM,BAT)
IFE NICSW,<
	ORNDSP(UNVF04,<CARD-PUNCH>,CDP)
>;IFE NICSW
IFN NICSW,<
REPEAT 0,<ORNDSP(UNVF04,<FOREIGN-PRINTER>,PLT)>
>;IFN NICSW
IFN FTFTS,<
	ORNDSP(UNVF03,<FAL-STREAM>,FAL)
	ORNDSP(UNVF03,<FTS-STREAM>,FTS)
> ;End FTFTS conditional
IFN NICSW,<
REPEAT 0,<ORNDSP(UNVF04,<LASER-PRINTER>,CDP)>
>;IFN NICSW
IFE NICSW,<
	ORNDSP(UNVF04,<PAPER-TAPE-PUNCH>,PTP)
	ORNDSP(UNVF04,<PLOTTER>,PLT)
	ORNDSP(UNVF04,PRINTER,LPT)
	ORNDSP(UNVF04,READER,RDR)
>;IFE NICSW
IFN NICSW,<
	ORNDSP(UNVF05,PRINTER,LPT)
>;IFN NICSW
	$ETAB

UNVF03:	$SRANGE(CONFRM)

UNVF04:	$URANGE(CONFRM)

IFN NICSW,<
UNVF05:	$PNKEY (CONFRM)
>;IFN NICSW
	
CONFRM:	$CRLF

SHD010:	$KEYDSP(SHD020)

SHD020:	$STAB
	ORNDSP(UNVF03,BATCH-STREAM,BAT)
IFE NICSW,<
	ORNDSP(UNVF04,<CARD-PUNCH>,CDP)
>;IFE NICSW
IFN NICSW,<
REPEAT 0,<
	ORNDSP(UNVF04,<FOREIGN-PRINTER>,PLT)
	ORNDSP(UNVF04,<LASER-PRINTER>,CDP)
>;REPEAT 0
>;IFN NICSW
	ORNDSP(SHD030,NODE,NOD)
IFE NICSW,<
	ORNDSP(UNVF04,<PAPER-TAPE-PUNCH>,PTP)
	ORNDSP(UNVF04,<PLOTTER>,PLT)
	ORNDSP(UNVF04,PRINTER,LPT)
	ORNDSP(UNVF04,READER,RDR)
>;IFE NICSW
IFN NICSW,<
	ORNDSP(SHD040,PRINTER,LPT)
>;IFN NICSW
	$ETAB

SHD030:	$NODNM(CONFRM,<node name>,<$FLAGS(CM%PO!CM%NSF)>)

IFN NICSW,<
SHD040:	$PNKEY (SHD070,SHD050)

SHD050:	$SWITCH (SHD070,SHD060)	
SHD060:	$STAB
	ORNSWI(ALL,ALL)
	$ETAB

SHD070:	$SWITCH (CONFRM,SHD080,<$ALTERNATE(<CONFRM>)>)
SHD080:	$STAB
	ORNSWI(PURGE,PUR)
	$ETAB
>;IFN NICSW
SUBTTL	STOP command tables

STPFDB:	$NOISE (STPF01,<object>)

STPF01:	$KEYDSP(STPF02)

STPF02:	$STAB
	ORNDSP(STPS01,BATCH-STREAM,BAT)
IFE NICSW,<
	ORNDSP(STPU01,<CARD-PUNCH>,CDP)
>;IFE NICSW
IFN NICSW,<
REPEAT 0,<ORNDSP(STPU01,<FOREIGN-PRINTER>,PLT)>
>;IFN NICSW
IFN FTFTS,<
	ORNDSP(STPU01,<FTS-STREAM>,FTS)
> ;End FTFTS conditional
IFN NICSW,<
REPEAT 0,<ORNDSP(STPU01,<LASER-PRINTER>,CDP)>
>;IFN NICSW
IFE NICSW,<
	ORNDSP(STPU01,<PAPER-TAPE-PUNCH>,PTP)
	ORNDSP(STPU01,<PLOTTER>,PLT)
	ORNDSP(STPU01,PRINTER,LPT)
	ORNDSP(STPU01,READER,RDR)
>;IFE NICSW
IFN NICSW,<
	ORNDSP(STPP01,PRINTER,LPT)
>;IFN NICSW
	$ETAB

STPS01:	$NOISE	(STPN01,<stream number>)

STPU01:	$NOISE	(STPN01,<unit number>)

IFN NICSW,<
STPP01:	$PNKEY (STP010,STPP02)

STPP02:	$SWITCH (STP010,STPP03)
STPP03:	$STAB
	ORNSWI(ALL,ALL)
	$ETAB
>;IFN NICSW

STPN01:	$NUMBER	(STPN02,^D10,<number or range (n:m)(/NODE:)>,<$ACTION(STOBTH)>)
STPN02:	$TOKEN	(STPN03,<:>,<$HELP(<colon to specify a range>),$DEFAULT(IMMEDIATELY),$ALTERNATE(STPN04)>)
STPN03:	$NUMBER	(STPN04,^D10,,<$ACTION(STOHGH)>)
STPN04:	$SWITCH (STPN06,STPN05,<$ALTERNATE(STP010)>)
STPN05:	$STAB
	ORNSWI(NODE:,NOD)
	$ETAB
STPN06:	$NODNM	(STP010,<node name>,<$FLAGS(CM%PO!CM%NSF)>)


STP010:	$KEYDSP	(STP020,<$DEFAULT(<IMMEDIATELY>),$ALTERNATE(CONFRM)>)

STP020:	$STAB
	ORNDSP(STP030,<AFTER>,AFT)
	ORNDSP(CONFRM,<IMMEDIATELY>,IMM)
	$ETAB

STP030:	$KEY(CONFRM,STP040)

STP040:	$STAB
	ORNKEY(<CURRENT-REQUEST>,ACR)
	ORNKEY(<EVERY-REQUEST>,AER)
	$ETAB


SUBTTL	ABORT command tables


ABOFDB:	$NOISE	(ABO010,<current job on>)

ABO010:	$KEYDSP	(ABO020)
ABO020:	$STAB
	ORNDSP	(ABO060,<BATCH-STREAM>,BAT)
IFE NICSW,<
	ORNDSP	(ABO030,<CARD-PUNCH>,CDP)
>;IFE NICSW
IFN NICSW,<
REPEAT 0,<ORNDSP	(ABO030,<FOREIGN-PRINTER>,PLT)>
>;IFN NICSW
IFN FTFTS,<
	ORNDSP	(ABO060,<FAL-STREAM>,FAL)
	ORNDSP	(ABO060,<FTS-STREAM>,FTS)
> ;End FTFTS conditional
IFN NICSW,<
REPEAT 0,<ORNDSP	(ABO030,<LASER-PRINTER>,CDP)>
>;IFN NICSW
IFE NICSW,<
	ORNDSP	(ABO030,<PAPER-TAPE-PUNCH>,PTP)
	ORNDSP	(ABO030,<PLOTTER>,PLT)
	ORNDSP	(ABO030,<PRINTER>,LPT)
	ORNDSP	(ABO090,<READER>,RDR)
>;IFE NICSW
IFN NICSW,<
	ORNDSP	(ABO025,<PRINTER>,LPT)
>;IFN NICSW
	$ETAB

IFN NICSW,<
ABO025:	$PNKEY (ABO040)
>;IFN NICSW

; Output device tables
;
ABO030:	$UNIT	(ABO040)
ABO040:	$SWITCH	(ABO100,ABO050,<$ALTERNATE(ABO100)>)
ABO050:	$STAB
	ORNSWI	(<PURGE>,PUR)
	$ETAB


; Batch tables
;
ABO060:	$STREAM	(ABO070)
ABO070:	$SWITCH	(ABO100,ABO080,<$ALTERNATE(ABO100),$DEFAULT(</ERROR-PROCESSING>)>)
ABO080:	$STAB
	ORNSWI	(<ERROR-PROCESSING>,ERR)
	ORNSWI	(<NOERROR-PROCESSING>,NER)
	ORNSWI	(<PURGE>,PUR)
	$ETAB


; Card reader tables
;
ABO090:	$UNIT	(ABO100)


ABO100:	$EXPL	(CONFRM,<$ALTER(CONFRM)>)
SUBTTL	HOLD command tables
SUBTTL	RELEASE command tables

HLDFDB:	$KEY	(HLD030,HLD010)

HLD010:	$STAB
	ORNKEY	(<BATCH-JOBS>,BAT)
IFE NICSW,<
ORNKEY	(<CARD-PUNCH-JOBS>,CDP)
>;IFE NICSW
IFN NICSW,<
REPEAT 0,<ORNKEY	(<FOREIGN-PRINTER-JOBS>,PLT)>
>;IFN NICSW
IFN FTFTS,<
	ORNKEY	(<FTS-JOBS>,FTS)
> ;End FTFTS conditional
IFN NICSW,<
REPEAT 0,<ORNKEY	(<LASER-PRINTER-JOBS>,CDP)>
>;IFN NICSW
IFE NICSW,<
	ORNKEY	(<PAPER-TAPE-PUNCH-JOBS>,PTP)
	ORNKEY	(<PLOTTER-JOBS>,PLT)
>;IFE NICSW
	ORNKEY	(<PRINTER-JOBS>,LPT)
	$ETAB

HLD030:	$NUMBER(CONFRM,^D10,<request-id>,<$ACTION(CHKPOS),$ALTERNATE(HLD035)>)

HLD035:	$USER(CONFRM,<$ALTERNATE(HLD040)>)

HLD040:	$TOKEN(HLD050,<*>,<$HELP(<* to specify all requests>)>)

HLD050:	$NODE(CONFRM)
SUBTTL	DEFINE command tables

IFN	FTDN60,<
DEFFDB:	$KEY(DEF020,DEF010,<$DEFAULT(<NODE>)>)

DEF010:	$STAB
	ORNKEY(<NODE>,NOD)
	$ETAB

DEF020:	$NOISE(DEF030,<name>)

DEF030:	$NODNM(DEF040,<node name for IBM emulation/termination>,<$FLAGS(CM%PO!CM%NSF)>)

DEF040:	$NOISE(DEF050,<type>)

DEF050:	$KEYDSP(DEF060,<$DEFAULT(<HASP>)>)

DEF060:	$STAB
	ORNDSP(DEF063,<2780>,278)
	ORNDSP(DEF063,<3780>,378)
	ORNDSP(DEF063,<HASP>,HSP)
	ORNDSP(DEF140,<SNA-WORKSTATION>,SNA)
	$ETAB

DEF063:	$SWITCH	(DEF070,DEF065,<$ALTERNATE(DEF080),$DEFAULT(</SIGNON-REQUIRED>)>)
DEF065:	$STAB
	ORNSWI(<NO-SIGNON-REQUIRED>,NSN)
	ORNSWI(<SIGNON-REQUIRED>,SON)
	$ETAB

DEF070:	$NOISE(DEF080,<mode>)

DEF080:	$KEY(DEF100,DEF090,<$DEFAULT(<TERMINATION>)>)

DEF090:	$STAB
	ORNKEY(EMULATION,EMU)
	ORNKEY(TERMINATION,TRM)
	$ETAB

DEF100:	$NOISE(DEF110,<port>)

DEF110:	$NUMBER(DEF120,^D8,<port number for DN60>)

DEF120:	$NOISE(DEF130,<line>)

DEF130:	$NUMBER(CONFRM,^D8,<line number for DN60>)

DEF140:	$KEYDSP(DEF142,<$DEFAULT(<GATEWAY>)>)

DEF142:	$STAB
	ORNDSP(DEF180,<ACCESS-NAME>,ACC)
	ORNDSP(DEF150,<GATEWAY>,GWY)
	$ETAB

DEF150:	$NODNM(DEF160,<node name for SNA Gateway>,<$FLAGS(CM%PO!CM%NSF)>)
DEF160:	$KEY(DEF170,DEF162,<$DEFAULT(<ACCESS-NAME>)>)

DEF162:	$STAB
	ORNKEY(<ACCESS-NAME>,ACC)
	$ETAB

DEF170:	$FIELD(CONFRM,<access name>)

DEF180:	$FIELD(DEF190,<access name>)

DEF190:	$KEY(DEF200,DEF192,<$DEFAULT(<GATEWAY>)>)

DEF192:	$STAB
	ORNKEY(<GATEWAY>,GWY)
	$ETAB

DEF200:	$NODNM(CONFRM,<node name for SNA Gateway>,<$FLAGS(CM%PO!CM%NSF)>)

>;END FTDN60
SUBTTL	CANCEL command tables

CANFDB:	$KEYDSP(CAN010)

CAN010:	$STAB
	ORNDSP	(CAN020,<BATCH-REQUEST>,BAT)
IFE NICSW,<ORNDSP	(CAN020,<CARD-PUNCH-REQUEST>,CDP)>
IFN NICSW,<
REPEAT 0,<ORNDSP (CAN020,<FOREIGN-PRINTER-REQUEST>,PLT)>
>;IFN NICSW
IFN FTFTS,<
	ORNDSP	(CAN020,<FTS-REQUEST>,FTS)
> ;End FTFTS conditional
IFN NICSW,<
REPEAT 0,<ORNDSP	(CAN020,<LASER-PRINTER-REQUEST>,CDP)>
>;IFN NICSW
	ORNDSP	(CAN040,<MOUNT-REQUEST>,MNT)
IFE NICSW,<
	ORNDSP	(CAN020,<PAPER-TAPE-PUNCH-REQUEST>,PTP)
	ORNDSP	(CAN020,<PLOTTER-REQUEST>,PLT)
>;IFE NICSW
	ORNDSP	(CAN020,<PRINTER-REQUEST>,LPT)
	$ETAB

CAN020:	$NUMBER(CONFRM,^D10,<request number to cancel in queue or if active>,<$ACTION(CHKPOS),$ALTERNATE(CAN030)>)

TOPS20 <
CAN030:	$USER(CONFRM,<$HELP(<user name whose jobs will be canceled>),$ALTERNATE(HLD040)>)
>;END TOPS20

TOPS10 <
CAN030:	$USER(CONFRM,<$HELP(<[project,programmer] whose jobs will be canceled>),$ALTERNATE(HLD040)>)
>;END TOPS10

CAN040:	$DEV(CAN060,<$HELP(<structure name to cancel all mount requests for>),$FLAGS(CM%PO),$ALTERNATE(CAN050)>)

TOPS10<
CAN050:	$NUMBER(CAN060,^D10,<mount request number to cancel>,<$ACTION(CHKPOS),$ALTERNATE(CAN055)>)
CAN055:	$TOKEN(CAN060,<*>,<$HELP(<* to specify all pending requests>)>)
>
TOPS20<
CAN050:	$NUMBER(CAN060,^D10,<mount request number to cancel>,<$ACTION(CHKPOS)>)
>

CAN060:	$EXPL(CONFRM,<$ALTERNATE(CONFRM)>)

SUBTTL	MODIFY command tables

MODFDB:
	$KEYDSP	(MOD010)

MOD010:	$STAB
TOPS10<	ORNDSP	(MOD300,<ACTIVE-SWAPPING-LIST>,ASL) >
	ORNDSP	(MOD020,<BATCH-REQUEST>,BAT)
IFE NICSW,<
	ORNDSP	(MOD020,<CARD-PUNCH-REQUEST>,CDP)
>;IFE NICSW
TOPS10<	ORNDSP	(MOD200,<CRASH-DUMP-LIST>,CDL) >
IFN NICSW,<
REPEAT 0,<ORNDSP	(MOD020,<FOREIGN-PRINTER-REQUEST>,PLT)>
>;IFN NICSW
IFN FTFTS,<
	ORNDSP	(MOD020,<FTS-REQUEST>,FTS)
> ;End FTFTS conditional
IFN NICSW,<
REPEAT 0,<ORNDSP	(MOD020,<LASER-PRINTER-REQUEST>,CDP)>
>;IFN NICSW
IFE NICSW,<
	ORNDSP	(MOD020,<PAPER-TAPE-PUNCH-REQUEST>,PTP)
	ORNDSP	(MOD020,<PLOTTER-REQUEST>,PLT)
>;IFE NICSW
	ORNDSP	(MOD020,<PRINTER-REQUEST>,LPT)
TOPS10<	ORNDSP	(MOD200,<SYSTEM-SEARCH-LIST>,SSL) >
	$ETAB

MOD020:	$NUMBER(MOD030,^D10,<request number to modify in queue>,<$ACTION(CHKPOS),$ALTERNATE(MOD070)>)

MOD030:	$KEYDSP(MOD040)

MOD040:	$STAB
	ORNDSP(MOD050,<PRIORITY>,PRI)
	$ETAB

MOD050:	$NOISE(MOD060,<to be>)

MOD060:	$NUMBER(CONFRM,^D10,<priority for request in range 1 to 63>,<$ACTION(CHKPRI)>)

MOD070:	$USER(MOD030,<$ALTERNATE(MOD080)>)
MOD080:	$TOKEN(MOD090,<*>,<$HELP(<* to specify all requests>)>)

MOD090:	$NODE(MOD030)

TOPS10<

;More of the MODIFY command tables

;Here if MODIFYing lists pertaining to file structures
MOD200:	$NOISE	(MOD210,<to>)

MOD210:	$KEY	(MOD230,MOD220)

MOD220:	$STAB
	ORNKEY	(EXCLUDE,EXC)
	ORNKEY	(INCLUDE,INC)
	$ETAB

MOD230:	$DEV	(CONFRM,$HELP(<file structure name>))

;Here if MODIFYing lists pertaining to disk drives (units)
MOD300:	$NOISE	(MOD310,<to>)

MOD310:	$KEY	(MOD320,MOD220)

MOD320:	$DEV	(CONFRM,<$HELP(<disk unit name>),$FLAGS(CM%PO)>)

>;END TOPS10
SUBTTL	SHOW command tables


SHWFDB:	$KEYDSP(SHW010)

SHW010:	$STAB
TOPS10<	ORNDSP(ALC000,ALLOCATION,ALC) >
	ORNDSP(SHW110,<CONTROL-FILE>,CTL)
	ORNDSP(SHW020,MESSAGES,MSG)
	ORNDSP(SHW030,OPERATORS,OPR)
	ORNDSP(SHW210,PARAMETERS,PRM)
	ORNDSP(SHW400,QUEUES,QUE)
	ORNDSP(CONFRM,<ROUTE-TABLE>,RTE)
TOPS20<	ORNDSP(CONFRM,SCHEDULER,SCH)>
	ORNDSP(STS000,STATUS,STS)
TOPS10<	ORNDSP(SYS000,<SYSTEM-LISTS>,SLS) >
	ORNDSP(SHW060,TIME,DAY)	;DAYTIME CHANGES TO TIME
	$ETAB

SHW020:	$NUMBER(CONFRM,^D10,<message number>,<$ALTER(SHW030),$ACTION(CHKVAL)>)

SHW030:	$NODE(CONFRM)

SHW060:	$CRLF(<$ACTION(SHWDAY##)>)

SHW110:	$NOISE	(SHW120,<for>)
SHW120:	$KEY (SHW140,SHW130,<$DEFAULT(<BATCH-STREAM>)>)

SHW130:	$STAB
	ORNKEY(<BATCH-STREAM>,BAT)
	$ETAB

SHW140:	$NOISE	(SHW145,<stream number>)
SHW145:	$NUMBER	(SHW150,^D10,<stream number>,$ACTION(CHKVAL))

SHW150:	$SWITCHES(,SHW160,<$ALTER(CONFRM)>)
SHW160:	$STAB
	ORNSDP	(SHW170,<LINES:>,LNS)
	$ETAB
SHW170:	$NUMBER	(CONFRM,^D10,<number of lines>,$ACTION(CHKVAL))

SHW210:	$KEYDSP(SHW220,<$ALTER(SHW320)>)

SHW220:	$STAB
	ORNDSP	(SHW230,<BATCH-STREAM>,BAT)
IFE NICSW,<
	ORNDSP	(SHW230,<CARD-PUNCH>,CDP)
>;IFE NICSW
IFN NICSW,<
	ORNDSP	(SHW230,<FOREIGN-PRINTER>,PLT)
>;IFN NICSW
IFN FTFTS,<
	ORNDSP	(SHW230,<FAL-STREAM>,FAL)
	ORNDSP	(SHW230,<FTS-STREAM>,FTS)
> ;End FTFTS conditional
IFN NICSW,<
REPEAT 0,<ORNDSP	(SHW230,<LASER-PRINTER>,CDP)>
>;IFN NICSW
	ORNDSP	(SHWNOD,<NETWORK-NODE>,NOD)
IFE NICSW,<
	ORNDSP	(SHW230,<PAPER-TAPE-PUNCH>,PTP)
	ORNDSP	(SHW230,<PLOTTER>,PLT)
	ORNDSP	(SHW230,<PRINTER>,LPT)
>;IFE NICSW
IFN NICSW,<
	ORNDSP	(SHW225,<PRINTER>,LPT)
>;IFN NICSW
	$ETAB

IFN NICSW,<
SHW225:	$PNKEY(CONFRM,CONFRM)
>;IFN NICSW

SHW230:	$SWITCH(SHW260,SHW250,<$ALTERNATE(SHW270)>)

SHW250:	$STAB
	ORNSWI(<NODE:>,NOD)
	$ETAB

SHW260:	$NODNM(CONFRM,<node name>,<$FLAGS(CM%PO!CM%NSF)>)

SHW270:	$RANGE(SHW280,<number or range (n:m)(/NODE:)>,<$ALTERNATE(CONFRM)>)

SHW280:	$NODE(CONFRM)

SHW320:	$SWITCH(SHW340,SHW330,<$ALTERNATE(CONFRM)>)

SHW330:	$STAB
	ORNSWI(<NODE:>,NOD)
	$ETAB

SHW340:	$NODNM(CONFRM,<node name>,<$FLAGS(CM%PO!CM%NSF)>)

;  Continued on next page
;Continued from previous page

;  SHOW QUEUE command

SHW400:	$KEYDSP(SHW420,<$DEFAULT(ALL),$ALTER(SHW430)>);NODE OR CONFIRM

SHW420:	$STAB
	ORNDSP	(SHW430,<ALL-JOBS>,ALL)
	ORNDSP	(SHW430,<BATCH-JOBS>,BAT)
IFE NICSW,<
	ORNDSP	(SHW430,<CARD-PUNCH-JOBS>,CDP)
>;IFE NICSW
IFN NICSW,<
REPEAT 0,<ORNDSP	(SHW430,<FOREIGN-PRINTER-JOBS>,PLT)>
>;IFN NICSW
IFN FTFTS,<
	ORNDSP	(SHW430,<FTS-REQUEST>,FTS)
> ;End FTFTS conditional
IFN NICSW,<
REPEAT 0,<ORNDSP	(SHW430,<LASER-PRINTER-JOBS>,CDP)>
>;IFN NICSW
	ORNDSP	(SHW470,<MOUNT-REQUESTS>,MNT)
IFE NICSW,<
	ORNDSP	(SHW430,<PAPER-TAPE-PUNCH-JOBS>,PTP)
	ORNDSP	(SHW430,<PLOTTER-JOBS>,PLT)
	ORNDSP	(SHW430,<PRINTER-JOBS>,LPT)
>;IFE NICSW
IFN NICSW,<
	ORNDSP	(SHW421,<PRINTER-JOBS>,LPT)
>;IFN NICSW
TOPS20<	ORNDSP	(SHW470,<RETRIEVAL-REQUESTS>,RET)>
	$ETAB

IFN NICSW,<
SHW421:	$PNKEY (SHW422,SHW422)

SHW422:	$SWITCH(,SHW423,<$ALTER(CONFRM),$ACTION(SHRSWT)>)
SHW423:	$STAB
	ORNSDP	(NEXT,<ALL>,ALL)
	ORNSDP	(NEXT,<SHORT>,SHT)
	ORNSDP	(SHW429,<USER:>,USR)
	$ETAB

SHW429:	$USER	(NEXT)
>;IFN NICSW

SHW430:	$SWITCH	(,SHW440,<$ALTER(CONFRM),$ACTION(SHRSWT)>) ;Switch or confirm

SHW440:	$STAB
	ORNSDP	(NEXT,<ALL>,ALL)
	ORNSDP	(SHW450,<NODE:>,NOD)
	ORNSDP	(NEXT,<SHORT>,SHT)
	ORNSDP	(SHW460,<USER:>,USR)
	$ETAB

SHW450:	$NODNM	(NEXT,<node name>,<$FLAGS(CM%PO!CM%NSF)>)

SHW460:	$USER	(NEXT)

SHW470:	$SWITCH	(,SHW480,<$ALTER(CONFRM),$ACTION(SHRSWT)>) ;Switch or confirm

SHW480:	$STAB					;  But no node allowed!
	ORNSDP	(NEXT,<ALL>,ALL)
	ORNSDP	(NEXT,<SHORT>,SHT)
	ORNSDP	(SHW490,<USER:>,USR)
	$ETAB

SHW490:	$USER	(NEXT)
SUBTTL	SHOW STATUS command tables

STS000:	$KEYDSP(STS010,<$ALTER(STS100)>)

STS010:	$STAB
	ORNDSP	(STS020,<BATCH-STREAM>,BAT)
IFE NICSW,<
	ORNDSP	(STS020,<CARD-PUNCH>,CDP)
>;IFE NICSW
	ORNDSP	(STS190,<DISK-DRIVE>,DSK)
IFN NICSW,<
REPEAT 0,<ORNDSP	(STS020,<FOREIGN-PRINTER>,PLT)>
>;IFN NICSW
IFN FTFTS,<
	ORNDSP	(STS020,<FAL-STEAM>,FAL)
	ORNDSP	(STS020,<FTS-STREAM>,FTS)
> ;End FTFTS conditional
IFN NICSW,<
REPEAT 0,<ORNDSP	(STS020,<LASER-PRINTER>,CDP)>
>;IFN NICSW
	ORNDSP	(SHWNOD,<NETWORK-NODE>,NOD)
IFE NICSW,<
	ORNDSP	(STS020,<PAPER-TAPE-PUNCH>,PTP)
	ORNDSP	(STS020,<PLOTTER>,PLT)
	ORNDSP	(STS020,<PRINTER>,LPT)
	ORNDSP	(STS020,<READER>,RDR)
>;IFE NICSW
IFN NICSW,<
	ORNDSP	(STS015,<PRINTER>,LPT)
>;IFN NICSW
	ORNDSP	(STS250,<STRUCTURE>,STR)
	ORNDSP	(STS160,<TAPE-DRIVE>,TAP)
	$ETAB

IFN NICSW,<
STS015:	$PNKEY(STS130,STS130)
>;IFN NICSW

STS020:	$SWITCH(STS040,STS030,<$ALTERNATE(STS050)>)

STS030:	$STAB
	ORNSWI(<NODE:>,NOD)
	$ETAB

STS040:	$NODNM(STS130,<node name>,<$FLAGS(CM%PO!CM%NSF)>)

STS050:	$RANGE(STS060,<number or range (n:m)(/NODE:)>,<$ALTERNATE(STS130)>)

STS060:	$NODE(STS130)

STS100:	$SWITCH(STS120,STS110,<$ALTERNATE(STS130)>)

STS110:	$STAB
	ORNSWI(<NODE:>,NOD)
	$ETAB

STS120:	$NODNM(STS130,<node name>,<$FLAGS(CM%PO!CM%NSF)>)
STS130:	$SWITCH(CONFRM,STS140,<$ALTERNATE(CONFRM)>)

STS140:	$STAB
	ORNSWI(SHORT,SHT)
	$ETAB

STS150:	$DEV(STS170,<$HELP(<tape drive name>),$ALTERNATE(STS170)>)

STS160:	$CRLF(<$ALTERNATE(STS150)>)

STS170:	$SWITCH(CONFRM,STS180,<$ALTERNATE(CONFRM)>)

STS180:	$STAB
	ORNSWI(ALL,ALL)
TOPS20<	ORNSWI(CHARACTERISTICS,CHR) >	;TOPS20 ONLY
	ORNSWI(FREE,FRE)
	$ETAB

STS190:	$SWITCH(CONFRM,STS200,<$ALTERNATE(CONFRM)>)

STS200:	$STAB
	ORNSWI(ALL,ALL)
	ORNSWI(FREE,AVA)
	ORNSWI(MOUNTED,MNT)
	$ETAB

TOPS10<
STS250:	$DEV(STS260,<$HELP(<structure name>),$ALTERNATE(STS260),$FLAGS(CM%PO)>)
>;END TOPS10
STS250:	$SWITCH(CONFRM,STS270,<$ALTERNATE(STS280)>)
STS270:	$STAB
	ORNSWI(ALL,ALL)
	ORNSWI(MOUNTED,MNT)
	ORNSWI(UNMOUNTED,AVA)
	$ETAB

STS280:	$DEV(CONFRM,<$HELP(<structure name>),$ALTERNATE(CONFRM),$FLAGS(CM%PO)>)
SUBTTL	SHOW SYSTEM-LIST command tables

TOPS10<
SYS000=CONFRM				;TO DELETE THE 'UNNECCESSARY CODE'
REPEAT 0,<
SYS000:	$CRLF	($ALTERNATE(SYS010))

SYS010:	$KEY	(CONFRM,SYS020)

SYS020:	$STAB
	ORNKEY	(<ACTIVE-SWAPPING-LIST>,ASL)
	ORNKEY	(<CRASH-DUMP-LIST>,CDL)
	ORNKEY	(<SYSTEM-SEARCH-LIST>,SSL)
	$ETAB
>;END REPEAT 0
>;END TOPS10
SUBTTL	LOCK/UNLOCK command tables

TOPS10 <

	;LOCK COMMAND

LOCFDB:	$NOISE(LOC010,<structure>)

LOC010:	$DEV(LOC015,<$FLAGS(CM%PO),$HELP(<structure name>)>)

LOC015:	$NOISE(LOC020,<at>)

LOC020:	$FTAD(LOC030,<$ALTERNATE(LOC030)>)

LOC030:	$SWITCH (CONFRM,LOC040,<$ALTERNATE(CONFRM)>)
LOC040:	$STAB
	ORNSWI(NOUNLOAD,NUL)
	$ETAB

	;UNLOCK COMMAND

ULCFDB:	$NOISE(ULC010,<structure>)

ULC010:	$DEV(ULC015,<$FLAGS(CM%PO),$HELP(<structure name>)>)

ULC015:	$NOISE(ULC020,<at>)

ULC020:	$FTAD(CONFRM,<$ALTERNATE(CONFRM)>)


>;END TOPS10
SUBTTL	SHWNOD	SHOW STATUS/PARAMETERS FOR NODE

SHWNOD:	$CRLF	(<$ALTERNATE(SHWN01)>)

SHWN01:	$NODNM(CONFRM,<node name>,<$FLAGS(CM%PO!CM%NSF)>)

SUBTTL	RESPOND command tables

RSPFDB:	$NOISE	(RSP001,<to message number>)

RSP001:	$NUMBER	(RSP005,^D10,<message number>,$ACTION(CHKVAL))

RSP005:	$CRLF	(<$ALTER(RSP010),$ACTION(TXTLIN##),$HELP(<confirm for multiple line response>)>)

RSP010:	$CTEXT	(CONFRM,<single line response>)
SUBTTL	REQUEUE command tables


REQFDB:	$NOISE	(REQ010,<current job on>)

REQ010:	$KEYDSP	(REQ020)
REQ020:	$STAB
	ORNDSP	(REQ030,<BATCH-STREAM>,BAT)
IFE NICSW,<
	ORNDSP	(REQ040,<CARD-PUNCH>,CDP)
>;IFE NICSW
IFN NICSW,<
REPEAT 0,<ORNDSP	(REQ040,<FOREIGN-PRINTER>,PLT)>
>;IFN NICSW
IFN FTFTS,<
	ORNDSP	(REQ030,<FTS-STREAM>,FTS)
> ;End FTFTS conditional
IFN NICSW,<
REPEAT 0,<ORNDSP	(REQ040,<LASER-PRINTER>,CDP)>
>;IFN NICSW
IFE NICSW,<
	ORNDSP	(REQ040,<PAPER-TAPE-PUNCH>,PTP)
	ORNDSP	(REQ040,<PLOTTER>,PLT)
	ORNDSP	(REQ040,<PRINTER>,LPT)
>;IFE NICSW
IFN NICSW,<
	ORNDSP	(REQ035,<PRINTER>,LPT)
>;IFN NICSW
	$ETAB


; Batch tables
;
REQ030:	$STREAM	(REQ100)


; Output device tables
;
IFN NICSW,<
REQ035:	$PNKEY (REQ050)	
>;IFN NICSW

REQ040:	$UNIT	(REQ050)
REQ050:	$KEYDSP	(REQ060,<$DEFAULT(CURRENT-POSITION),$ALTER(REQ100)>)
REQ060:	$STAB
	ORNDSP	(REQ070,<BEGINNING-OF>,BEG)
	ORNDSP	(REQ100,<CURRENT-POSITION>,CUR)
	$ETAB
REQ070:	$KEY	(REQ100,REQ080)
REQ080:	$STAB
	ORNKEY	(<COPY>,CPY)
	ORNKEY	(<FILE>,FIL)
	ORNKEY	(<JOB>,JOB)
	$ETAB

REQ100:	$EXPL	(CONFRM,<$ALTER(CONFRM)>)
SUBTTL	BACKSPACE command tables
SUBTTL	FORWARDSPACE command tables

BKSFDB:	$KEY (BKS002,BKS001,<$DEFAULT(<PRINTER>)>)

BKS001:	$STAB
	ORNKEY (<PRINTER>,LPT)
	$ETAB

IFE NICSW,<
BKS002:	$UNIT(BKS003)
>;IFE NICSW
IFN NICSW,<
BKS002:	$PNKEY (BKS003)
>;IFN NICSW

BKS003:	$SWITCH(,BKS004)

BKS004:	$STAB
	ORNSDP(BKS005,<COPIES:>,CPY)
	ORNSDP(CONFRM,<FILE>,FIL)
	ORNSDP(BKS007,<PAGES:>,PAG)
	$ETAB

BKS005:	$NUMBER	(CONFRM,^D10,<number of copies>,$ACTION(CHKVAL))
REPEAT 0,<
BKS006:	$NUMBER	(CONFRM,^D10,<number of files>,<$ACTION(CHKFIL),$DEFAULT(<1>)>)
>
BKS007:	$NUMBER	(CONFRM,^D10,<number of pages>,$ACTION(CHKVAL))

REPEAT 0,<
CHKFIL:	SKIPG	T1,CR.RES(S2)	;CHECK THAT NUMBER
	JRST	CHKF.1		;GENERTE AN ERROR
	CAIN	T1,1		;WAS IT A 1
	$RETT			;O.K..RETURN
CHKF.1:	PUSHJ	P,FIXIT
	MOVEI	S2,[ASCIZ/only one file allowed/]
	$RETF
>
SUBTTL	ALIGN command table

ALIFDB:	$NOISE (ALI001,<forms on>)

ALI001:	$KEY (ALI003,ALI002,<$DEFAULT(<PRINTER>)>)

ALI002:	$STAB
	ORNKEY (<PRINTER>,LPT)
	$ETAB

IFE NICSW,<
ALI003:	$UNIT(ALI010)
>;IFE NICSW
IFN NICSW,<
ALI003:	$PNKEY (ALI010)
>;IFN NICSW

ALI004:	$IFILE	(ALI005,<alignment file>,<$ALTER(ALI005)>)

ALI005:	$SWITCH(,ALI006,<$ALTER(CONFRM),$ACTION(SHRSWT)>)

ALI006:	$STAB
	ORNSDP(ALI007,<PAUSE:>,PAU)
	ORNSDP(ALI008,<REPEAT-COUNT:>,RPT)
	$ETAB

ALI007:	$NUMBER (NEXT,^D10,<seconds to pause>,$ACTION(CHKVAL))

ALI008:	$NUMBER (NEXT,^D10,<times to print>,$ACTION(CHKVAL))

ALI009:	$STAB
	ORNSWI(STOP,STP)
	$ETAB

ALI010:	$SWITCH(CONFRM,ALI009,<$ALTER(ALI004)>)
SUBTTL	SUPPRESS command tables

SUPFDB:	$NOISE (SUP001,<carriage control on>)

SUP001:	$KEY (SUP010,SUP005,<$DEFAULT(<PRINTER>)>)


SUP005:	$STAB
	ORNKEY (<PRINTER>,LPT)
	$ETAB

IFE NICSW,<
SUP010:	$UNIT(SUP015)
>;IFE NICSW
IFN NICSW,<
SUP010:	$PNKEY (SUP015)
>;IFN NICSW

SUP015:	$SWITCH(CONFRM,SUP020,<$DEFAULT(</JOB>),$ALTER(CONFRM)>)

SUP020:	$STAB
	ORNSWI(FILE,FIL)
	ORNSWI(JOB,JOB)
	ORNSWI(STOP,STP)
	$ETAB
SUBTTL	ROUTE command tables

RTEFDB:	$NOISE	(RTEF05,device)

RTEF05:	$KEYDSP(RTEF10)

RTEF10:	$STAB
	ORNDSP(RTEF50,<ALL-DEVICES>,ALL)
IFE NICSW,<
	ORNDSP(RTEF15,<CARD-PUNCH>,CDP)
	ORNDSP(RTEF15,<PAPER-TAPE-PUNCH>,PTP)
	ORNDSP(RTEF15,<PLOTTER>,PLT)
>;IFE NICSW
	ORNDSP(RTEF15,<PRINTER>,LPT)
	$ETAB

RTEF15:	$NOISE	(RTEF20,<unit number>)
RTEF20:	$NUMBER	(RTEF35,^D10,<source device unit number>,$ALTERN(RTEF25))
RTEF25:	$KEYDSP	(RTEF30)
RTEF30:	$STAB
	ORNDSP	(RTEF35,<ALL-UNITS>,ALL)
	$ETAB

;To explain the following magical line...
;The default '(' is to allow an ESC to go to the next field and display noise.
;The ERRPDB is used to only get to the next field on switch error or ESC.
;The alternate is to permit entering the destination or crlf
RTEF35:	$SWITCH	(RTEF39,RTEF36,<$DEFAULT(<(>),$ERRPDB(RTEF40),$ALTER(RTEF45)>)
RTEF36:	$STAB
	ORNSWI(NODE:,NOD)
	$ETAB
RTEF39:	$NODNM	(RTEF40,<node name>,<$FLAGS(CM%PO)>)

RTEF40:	$NOISE	(RTEF45,<to unit number>)
RTEF45:	$NUMBER	(RTEF48,^D10,<destination unit number>,<$ALTERNATE(RTEF46)>)
RTEF46:	$KEYDSP	(RTEF47,<$ALTERNATE(RTEF80)>)
RTEF47:	$STAB
	ORNDSP	(RTEF48,<ALL-UNITS>,ALL)
	$ETAB
RTEF48:	$NODE	(CONFRM)

;For parsing all devices

RTEF50:	$NOISE	(RTEF55,<on node>)
RTEF55:	$KEYDSP	(RTEF60,<$HELP(<ALL-NODES>),$ALTERNATE(RTEF65)>)
RTEF60:	$STAB
	ORNDSP	(RTEF70,<ALL-NODES>,ALL)
	$ETAB

RTEF65:	$NODNM	(RTEF70,<source node name>,<$FLAGS(CM%PO!CM%NSF)>)

RTEF70:	$NOISE	(RTEF75,<to node>)
RTEF75:	$NODNM	(CONFRM,,<$ALTERNATE(RTEF80),$FLAGS(CM%PO!CM%NSF)>)

RTEF80:	$CRLF	($HELP(<confirm to delete routing>))
SUBTTL	SEND command tables

SNDFDB:	$NOISE	(SND001,<to>)

SND001:	$KEYDSP	(SND005)

SND005:	$STAB
	ORNDSP(SND040,<ALL>,ALL)
	ORNDSP(SND015,<BATCH-STREAM>,BAT)
	ORNDSP(SND010,<JOB>,JOB)
	ORNDSP(SND025,<OPERATOR>,OPR)
	ORNDSP(SND020,<TERMINAL>,TRM)
	$ETAB

SND010:	$NUMBER(SND030,^D10,<job number>,$ACTION(CHKVAL))
SND015:	$STNUM(SND025)
SND020:	$NUMBER(SND030,^D8,<terminal number>,$ACTION(CHKVAL))
SND025:	$NODE(SND030)

SND030:	$CRLF	(<$ALTER(SND035),$ACTION(TXTLIN##),$HELP(<confirm for multiple line response>)>)

SND035:	$CTEXT	(CONFRM,<single line response>)
SND040:	$NODE(SND035)
SUBTTL	SET command tables

SETFDB:	$KEYDSP(SET010)

SET010:	$STAB
	ORNDSP(SET170,BATCH-STREAM,BAT)
IFE NICSW,<
	ORNDSP(SET490,<CARD-PUNCH>,CDP)
>;IFE NICSW
TOPS20<	ORNDSP(SET700,<DISK-DRIVE>,DSK)>
IFN NICSW,<
REPEAT 0,<ORNDSP(SET370,<FOREIGN-PRINTER>,PLT)>
>;IFN NICSW
	ORNDSP(SET070,JOB,JOB)
IFN NICSW,<
REPEAT 0,<ORNDSP(SET490,<LASER-PRINTER>,CDP)>
	ORNDSP(CONFRM,<NEW-LPFORM-FILE>,DFT)
>;IFN NICSW
IFN	FTDN60,<
	ORNDSP(SETNOD,<NODE>,NOD)
>;END FTDN60
TOPS20<	ORNDSP(SET800,<ONLINE>,ONL)>
IFE NICSW,<
	ORNDSP(SET430,<PAPER-TAPE-PUNCH>,PTP)
	ORNDSP(SET370,PLOTTER,PLT)
>;IFE NICSW
	ORNDSP(SETP00,PORT,POR)
	ORNDSP(SET200,PRINTER,LPT)
TOPS20<	ORNDSP(SETSCH,<SCHEDULER>,SCH)>
TOPS20<	ORNDSP(SET600,<STRUCTURE>,STR)>
	ORNDSP(SET630,<TAPE-DRIVE>,TAP)
	ORNDSP(SET020,TERMINAL,TRM,CM%INV)
TOPS10<	ORNDSP(SET900,USAGE,USG)>
	$ETAB

SET020:	$KEYDSP(SET030,<$ACTION(SETRTN##)>)

SET030:	$STAB

TOPS10<	ORNDSP(SET350,KEYPAD,KPD)
	ORNDSP(SET350,NOKEYPAD,NKP)>
	ORNDSP(SET040,<TYPE>,TYP)
	$ETAB

SET040:	$NOISE (SET050,<to be>)
SET050:	$KEY(SET350,SET060,<$ACTION(SETRTN##)>)

SET060:	$STAB
DEFINE X(PARNAM,SIXNAM,SUF,EOLSEQ),<
	KEYTAB(.TT'SUF,<PARNAM>)
>;END DEFINE X
	TRMTYP				;Generate the options
	$ETAB

SET070:	$NOISE(SET080,<job number>)
SET080:	$NUMBER(SET090,^D10,<job number>,$ACTION(CHKVAL))

SET090:	$KEYDSP(SET100)

SET100:	$STAB
	ORNDSP(CONFRM,<NOOPR-INTERVENTION>,NOI)
	ORNDSP(CONFRM,<OPR-INTERVENTION>,OIA)
TOPS20<	ORNDSP(SET110,SCHEDULER-CLASS,CLS)>
	$ETAB

TOPS20 <
SET110:	$NOISE(SET120,<to be>)

SET120:	$NUMBER(CONFRM,^D10,<scheduler class to put the job in>)

>;END TOPS20

SET170:	$SRANGE(SET180)
SET180:	$KEYDSP(SET250)

IFE NICSW,<
SET200:	$URANGE(SET210)
>;IFE NICSW
IFN NICSW,<
SET200:	$PNKEY (SET210)
>;IFN NICSW
SET210:	$KEYDSP(SET300)


SET250:	$STAB
	ORNDSP(SET295,ATTRIBUTE,ATR)
TOPS10<	ORNDSP(SET290,<MEMORY-LIMITS>,MEM)>
	ORNDSP(CONFRM,NOOPR-INTERVENTION,NOI)
	ORNDSP(CONFRM,OPR-INTERVENTION,OIA)
	ORNDSP(SET260,PRIORITY-LIMITS,PRL)
	ORNDSP(SET270,TIME-LIMITS,TIM)
	$ETAB

SET260:	$RANGE(CONFRM,<maximum priority limit or a range (1-63)>)
SET270:	$RANGE(CONFRM,<maximum time limits in minutes or a range>)
SET280:	$NUMBER(CONFRM,^D10,<line number>,$ACTION(CHKVAL))
;GET MEMORY LIMITS

TOPS10 <
SET290:	$RANGE(CONFRM,<maximum number of pages or a range>)
> ;End TOPS10

SET295:	$KEYDSP(SET297)
SET297:	$STAB
	ORNDSP(CONFRM,BATCON,BAT)
	ORNDSP(CONFRM,SITGO,SIT)
	$ETAB

SET300:	$STAB
	ORNDSP(SET790,DESTINATION,DST)
	ORNDSP(SET330,FORMS-TYPE,FOT)
	ORNDSP(SET340,LIMIT-EXCEEDED-ACTION,LEA)
	ORNDSP(SET310,PAGE-LIMITS,PGL)
	ORNDSP(SET260,PRIORITY-LIMITS,PRL)
	$ETAB

SET310:	$RANGE(CONFRM,<maximum number of pages or a range>)

SET320:	$STAB
	ORNKEY(ABORT,CNC)
	ORNKEY(ASK,ASK)
	ORNKEY(PROCEED,IGN)
	$ETAB

IFE NICSW,<
SET330:	$FIELD(CONFRM,<forms name>)
>;IFE NICSW
IFN NICSW,<
SET330:	$FTKEY (CONFRM)			;{G6} Forms type keywords
>;IFN NICSW
SET340:	$KEY(CONFRM,SET320)
SET350:	$CRLF(<$ACTION(SETTRM##)>)

SET370:	$URANGE	(SET380)

SET380:	$KEYDSP	(SET390)

SET390:	$STAB
	ORNDSP	(SET330,<FORMS-TYPE>,FOT)
	ORNDSP	(SET340,LIMIT-EXCEEDED-ACTION,LEA)
	ORNDSP	(SET480,<OUTPUT-LIMIT>,OPL)
	ORNDSP	(SET260,PRIORITY-LIMITS,PRL)
	$ETAB

SET430:	$URANGE	(SET440)

SET440:	$KEYDSP	(SET450)

SET450:	$STAB
	ORNDSP	(SET330,<FORMS-TYPE>,FOT)
	ORNDSP	(SET340,LIMIT-EXCEEDED-ACTION,LEA)
	ORNDSP	(SET470,<OUTPUT-LIMIT>,OPL)
	ORNDSP	(SET260,PRIORITY-LIMITS,PRL)
	$ETAB

SET470:	$RANGE(CONFRM,<maximum limit in feet or a range>)
SET480:	$RANGE(CONFRM,<maximum limit in minutes or a range>)
SET490:	$URANGE(SET500)

SET500:	$KEYDSP	(SET510)

SET510:	$STAB
	ORNDSP	(SET790,<DESTINATION>,DST)
	ORNDSP	(SET330,<FORMS-TYPE>,FOT)
	ORNDSP	(SET340,LIMIT-EXCEEDED-ACTION,LEA)
	ORNDSP	(SET530,<OUTPUT-LIMIT>,OPL)
	ORNDSP	(SET260,PRIORITY-LIMITS,PRL)
	$ETAB

SET530:	$RANGE(CONFRM,<maximum limit in cards or a range>)
SUBTTL	SET STRUCTURE command tables

TOPS20 <

SET600:	$DEV	(SET610,<$HELP(<structure name>),$FLAGS(CM%PO)>)

SET610:	$KEYDSP(SET620)

SET620:	$STAB
	ORNDSP(SET622,<ACKNOWLEDGED>,ACK)
	ORNDSP(SET624,<AVAILABLE>,AVA)
	ORNDSP(CONFRM,<DOMESTIC>,DOM)
	ORNDSP(CONFRM,<EXCLUSIVE>,EXL)
	ORNDSP(CONFRM,<FOREIGN>,FOR)
	ORNDSP(SET622,<IGNORED>,IGN)
	ORNDSP(CONFRM,<REGULATED>,REG)
	ORNDSP(CONFRM,<SHARED>,SHR)
	ORNDSP(SET624,<UNAVAILABLE>,UAV)
	ORNDSP(CONFRM,<UNREGULATED>,URG)
	$ETAB

SET622:	$NOISE(CONFRM,<as a new mountable structure>)

SET624:	$NOISE(CONFRM,<to new users>)

>;END TOPS20
SUBTTL	SET TAPE command tables

SET630:	$DEV(SET640,<$HELP(<tape drive name>)>)

SET640:	$KEYDSP(SET650,<$ACTION(SET655)>)

SET650:	$STAB
	ORNDSP(SET660,<AVAILABLE>,AVA)
	ORNDSP(SETINI,<INITIALIZE>,INI)
	ORNDSP(SET670,<UNAVAILABLE>,UAV)
	$ETAB

	$DATA	VOLIDF,1		;Volume id flag (used for INITIALIZE)
					;if 0 then switch not used
					;if -1 then switch used
					;if 1 then switch needed (ANSI labels)

SET655:	SETZM	VOLIDF			;Initialize volid flag
	$RETT

SET660:	$NOISE(CONFRM,<for use by system>)

SET670:	$CRLF	(<$ALTER(SET680),$ACTION(TXTLIN##),$HELP(<confirm for multiple line explanation for drive unavailable>)>)

SET680:	$CTEXT	(CONFRM,<single line response>)
SUBTTL	SET DISK command tables

TOPS20 <

SET700:	$NOISE(SET705,<on>)

SET705:	$KEY(SET720,SET710,<$DEFAULT(<CHANNEL>)>)

SET710:	$STAB
	ORNKEY(<CHANNEL>,CHN)
	$ETAB

SET720:	$NUMBER(SET722,^D10,<channel number>,<$ACTION(CHKCHN)>)

SET722:	$KEYDSP(SET724,<$DEFAULT(<DRIVE>)>)

SET724:	$STAB
	ORNDSP(SET726,<CONTROLLER>,CON)
	ORNDSP(SET750,<DRIVE>,DRV)
	$ETAB

SET726:	$NUMBER(SET730,^D10,<controller number or -1 if none>)

SET730:	$KEY(SET750,SET740,<$DEFAULT(<DRIVE>)>)

SET740:	$STAB
	ORNKEY(<DRIVE>,DRV)
	$ETAB

SET750:$NUMBER(SET760,^D10,<drive number>,<$ACTION(CHKVAL)>)

SET760:	$KEYDSP(SET770)

SET770:	$STAB
	ORNDSP(SET660,<AVAILABLE>,AVA)
	ORNDSP(SET670,<UNAVAILABLE>,UAV)
	$ETAB

SET790:	$NOISE(SET792,<to be>)

SET792:	SNADST	(CONFRM)

>;END TOPS20

SUBTTL	SET ONLINE command tables

TOPS20 <
SET800:	$NOISE(SET810,<device address>)

SET810:	$NUMBER(SET820,<^D8>,<channel number>,<$ACTION(CHKCHN)>)

SET820:	$COMMA(SET830)

SET830:	$NUMBER(SET840,<^D8>,<device unit number>,<$ACTION(CHKVAL)>)

SET840:	$COMMA(SET850,<$ALTERNATE(<CONFRM>)>)

SET850:	$NUMBER(SET860,<^D8>,<controller number or -1 if no controller number>,<$DEFAULT(<-1>)>)

SET860:	$NOISE(SET865,<alternate address>)

SET865:	$NUMBER(SET870,<^D8>,<alternate channel>,<$ACTION(CHKCHN),$ALTERNATE(CONFRM)>)

SET870:	$COMMA(SET875)

SET875:	$NUMBER(SET880,<^D8>,<alternate device unit number>,<$ACTION(CHKVAL)>)

SET880:	$COMMA(SET885,<$ALTERNATE(<CONFRM>)>)

SET885:	$NUMBER(CONFRM,<^D8>,<alternate controller number or -1>,<$DEFAULT(<-1>)>)

CHKCHN:	SKIPL	S1,CR.RES(S2)	;CHECK THAT NUMBER
	CAILE	S1,7		;IN BOUNDS
	SKIPA			;BAD NUMBER
	$RETT			;IT'S GOOD
	PUSHJ	P,FIXIT
	MOVEI	S2,[ASCIZ/channel number not in range 0:7/]
	$RETF

IFN NICSW,<
SETDFT:	$NOISE(SETD10,<for>)
SETD10:	$KEYDSP(SETD20,<$DEFAULT(<PRINTER-VERIFICATION>)>);F1
SETD20:	$STAB
	ORNDSP(CONFRM,<PRINTER-VERIFICATION>,PFV);F1
	$ETAB
>;IFN NICSW
>;END TOPS20




SUBTTL	SET USAGE command tables

TOPS10<

SET900:	$KEYDSP(SET901)
SET901:	$STAB
	ORNDSP(SET910,BILLING-CLOSURE,UBC)
	ORNDSP(SET920,FILE-CLOSURE,UFC)
	$ETAB

SET910:	$TIME(CONFRM)

SET920:	$KEYDSP(SET925,<$ALTER(SET950)>)

SET925:	$STAB
	ORNDSP(SET930,DAILY,DLY)
	ORNDSP(SET940,EVERY,WKY)
	ORNDSP(SET960,NOW,NOW)
	$ETAB

SET930:	$NOISE(SET932,<at>)
SET932:	$TIME(SET960)

SET940:	$KEY(SET945,SET942)
SET942:	$STAB
	KEYTAB(2,FRIDAY)
	KEYTAB(5,MONDAY)
	KEYTAB(3,SATURDAY)
	KEYTAB(4,SUNDAY)
	KEYTAB(1,THURSDAY)
	KEYTAB(6,TUESDAY)
	KEYTAB(0,WEDNESDAY)
	$ETAB

SET945:	$NOISE(SET946,<at>)
SET946:	$TIME(SET960)

SET950:	$TAD(SET960)


SET960:	$SWITCH(CONFRM,SET965,<$ALTERNATE(CONFRM)>)
SET965:	$STAB
	ORNSWI(<NO-SESSION-ENTRIES>,NOS)
	$ETAB

> ;End TOPS10 conditional

SUBTTL	SET TAPE INITIALIZE command tables
SETINI:	$SWITCH(,INI010,<$ACTION(SHRSWT),$ALTERNATE(INI250)>)

INI010:	$STAB
TOPS10<	ORNDSP(INI300,<ABORT>,CNC) >
	ORNSDP(INI140,<COUNT:>,CNT)
	ORNSDP(INI020,<DENSITY:>,DEN)
	ORNSDP(INI240,<INCREMENT:>,INC)
	ORNSDP(INI040,<LABEL-TYPE:>,LBT)
	ORNSDP(INI060,<OVERRIDE-EXPIRATION:>,OVR)
	ORNSDP(INI080,<OWNER:>,OWN)
	ORNSDP(INI100,<PROTECTION:>,PRO)
	ORNSDP(INI120,<TAPE-DISPOSITION:>,TDP)
	ORNSDP(INI170,<VOLUME-ID:>,VID)
	$ETAB


INI020:	$KEY(NEXT(SETINI),INI030,<$DEFAULT(<1600>)>)

INI030:	$STAB
	ORNKEY(1600,160)
	ORNKEY(200,200)
	ORNKEY(556,556)
	ORNKEY(6250,625)
	ORNKEY(800,800)
	$ETAB

INI040:	$KEY(NEXT(SETINI),INI050,<$ACTION(INI057),$DEFAULT(<ANSI>)>)

INI050:	$STAB
	ORNKEY(ANSI,ANS)
	ORNKEY(EBCDIC,EBC)
TOPS20<	ORNKEY(TOPS-20,T20)>
INI055:	ORNKEY(UNLABELED,UNL)
	$ETAB

INI057:	MOVE	S1,CR.RES(S2)		;Get the result from the key table
	CAIE	S1,INI055		;Was the label type unlabeled?
	SKIPE	VOLIDF			;No - skip if still need volume id
	$RETT				;No further action needed
	MOVEI	S1,1
	MOVEM	S1,VOLIDF		;Set that we need volid to be specified
	$RETT

INI060:	$KEY(NEXT(SETINI),INI070,<$DEFAULT(<NO>)>)

INI070:	$STAB
	ORNKEY(NO,NO)
	ORNKEY(YES,YES)
	$ETAB

TOPS20 <
INI080:	$USER(NEXT(SETINI),<$HELP(<user who owns the tape>)>)
>;END -20

TOPS10 <
INI080:	$USER(NEXT(SETINI),<$HELP(<user PPN who owns the tape>)>)
>;END -10

INI100:	$NUMBER(NEXT(SETINI),^D8,<protection for the tape as an octal number>)

INI120:	$KEY(NEXT(SETINI),INI130,<$DEFAULT(<UNLOAD>)>)

INI130:	$STAB
	ORNKEY(HOLD,HLD)
	ORNKEY(UNLOAD,UNL)
	$ETAB

INI140:	$NUMBER(NEXT(SETINI),^D10,<number of volumes to be initialized>,<$ACTION(CHKPOS),$DEFAULT(<10>)>)

INI170:	$FIELD(NEXT(SETINI),<volume-id without quotes>,<$PREFILL(INI175)>)

INI175:	SETOM	VOLIDF				;Say we saw volume id
	$RETT

INI240:	$NUMBER(NEXT(INI200),^D10,<increment value for assigning next volume-id>,<$ACTION(CHKPOS),$DEFAULT(<1>)>)

INI250:	$CRLF ($ACTION(INI260))

INI260:	SKIPG	VOLIDF				;Is it not needed or not used?
	$RETT					;Yes
	MOVEI	S2,[ASCIZ/Volid must be specified/]
	$RETF

INI300:	$CRLF	(<$HELP(<confirm to abort tape initialization>)>)
SUBTTL	SET NODE command tables

IFN	FTDN60,<

SETNOD:	$NODNM(SETN10,<node name>,<$FLAGS(CM%PO!CM%NSF)>)

SETN10:	$KEYDSP(SETN12,<$ALTERNATE(SETN20)>)

SETN12:	$STAB
	ORNDSP(SETN95,<BYTES-PER-MESSAGE>,BPM)
	ORNDSP(SETN40,<CLEAR-SEND-DELAY>,CSD)
	ORNDSP(SETN60,<RECORDS-PER-MESSAGE>,RPM)
	ORNDSP(SETN80,<TIMEOUT-CATEGORY>,TOU)
	ORNDSP(SETN90,<TRANSPARENCY>,TRA)
	$ETAB

SETN20:	$KEYDSP(SETN22)

SETN22:	$STAB
	ORNDSP(SETN31,<APPLICATION>,PLU)
	ORNDSP(SETN35,<CHARACTER-SET>,CHS)
	ORNDSP(SETN32,<CIRCUIT>,CIR)
	ORNDSP(SETN33,<DATA>,DAT)
	ORNDSP(SETN34,<LOGON-MODE>,LOM)
	$ETAB

SETN31:	$CTEXT(CONFRM,<IBM application>)

SETN32:	$CTEXT(CONFRM,<circuit-ID>)

SETN33:	$CTEXT(CONFRM,<IBM logon data>)

SETN34:	$CTEXT(CONFRM,<IBM logon mode>)

SETN35:$IFILE(CONFRM,<Translation table file>)

SETN40:	$NUMBER(CONFRM,^D10,<time in jiffies>,<$ACTION(CHKVAL)>)

SETN50:	$KEY(CONFRM,SETN55,<$DEFAULT(<ON>)>)

SETN55:	$STAB
	ORNKEY(<OFF>,OFF)
	ORNKEY(<ON>,ON)
	$ETAB

SETN60:	$NUMBER(CONFRM,^D10,<records per message for 2780>,<$ACTION(CHKVAL)>)

SETN80:	$KEY(CONFRM,SETN85)

SETN85:	$STAB
	ORNKEY(<PRIMARY>,PRI)
	ORNKEY(<SECONDARY>,SEC)
	$ETAB

SETN90:	$KEY(CONFRM,SETN55)
SETN95:	$NUMBER(CONFRM,^D10,<bytes per message size for the front end>)
>;END FTDN60
SUBTTL	SET SCHEDULER command tables (TOPS20)


TOPS20	<
SETSCH:	$KEYDSP(SETS10,<$DEFAULT(<BIAS-CONTROL>)>)

SETS10:	$STAB
	ORNDSP(SETS50,<BATCH-CLASS>,BAT)
	ORNDSP(SETS20,<BIAS-CONTROL>,BIA)
	ORNDSP(SETS40,<CLASS>,CLS)
	$ETAB
SETS20:	$NOISE(SETS30,<to>)

SETS30:	$NUMBER(CONFRM,^D10,<<decimal number, a small number to favor interactive processes, larger number for compute-bound>>,<$ACTION(CHKVAL)>)

SETS40:	$NOISE(SETS42,<number>)

SETS42:	$NUMBER(SETS44,^D10,<scheduler class number>,<$ACTION(CHKVAL)>)

SETS44:	$NOISE(SETS46,<to percent>)

SETS46:	$NUMBER(CONFRM,^D10,<percent for this scheduler class (0-99)>,<$ACTION(CHKPER)>)

SETS50:	$KEY(CONFRM,SETS52,<$ALTERNATE(SETS54)>)

SETS52:	$STAB
	ORNKEY(<BACKGROUND>,BCK)
	ORNKEY(<NONE>,NON)
	$ETAB

SETS54:	$NUMBER(CONFRM,^D10,<scheduler class for batch>,<$ACTION(CHKVAL)>)


CHKPER:	SKIPL	T1,CR.RES(S2)	;CHECK THAT NUMBER
	CAILE	T1,^D100	;TOO LARGE
	SKIPA
	$RETT			;RETURN
	PUSHJ	P,FIXIT
	MOVEI	S2,[ASCIZ/scheduler percent out of range/]
	$RETF
>;END TOPS20
SUBTTL	SET PORT command tables

SETP00:	$KEY(SETP20,SETP10,<$DEFAULT(<CI>)>)

SETP10:	$STAB
	ORNKEY(<CI>,CI)
	$ETAB

SETP20:	$KEY(CONFRM,SETP30)

SETP30:	$STAB
	ORNKEY(<AVAILABLE>,AVA)
	ORNKEY(<UNAVAILABLE>,UAV)
	$ETAB

SUBTTL	ENABLE/DISABLE command tables


ENAFDB:	$KEYDSP	(ENA001,<$DEFAULT(OUTPUT-DISPLAY)>)

ENA001:	$STAB
TOPS20<	ORNDSP(ENA050,<AUTOMATIC-VOLUME-RECOGNITION>,AVR)>
TOPS20<	ORNDSP(ENACLS,<CLASS-SCHEDULER>,CLS)>
TOPS20<	ORNDSP(CONFRM,<FILE-RETRIEVAL-WAITS>,RET)>
	ORNDSP(CONFRM,<LOGGING>,LGG)
	ORNDSP(ENA100,<OUTPUT-DISPLAY>,OPD)
	ORNDSP(CONFRM,<QUEUE-REQUESTS>,QUE)
TOPS10<	ORNDSP(CONFRM,<STRUCTURE-RECOGNITION>,ASR)>
TOPS10< ORNDSP(ENA050,<VOLUME-RECOGNITION>,AVR)>
	$ETAB

ENA050:	$NOISE(ENA065,<for>)

ENA065:	$KEY(CONFRM,ENA070,<$ALTERNATE(ENA075)>)

ENA070:	$STAB
TOPS10< ORNKEY(<DISK-DRIVES>,DSK)>
	ORNKEY(<TAPE-DRIVES>,TAP)
	$ETAB
TOPS20<
ENA075:	$DEV(CONFRM,$HELP(tape drive name))
>;END TOPS20
TOPS10<
ENA075:	$DEV(CONFRM,<$HELP(<tape or disk drive name>)>)
>;END TOPS10

;continued on next page
;continued from previous page

;  Here on ENABLE/DISABLE OUTPUT-DISPLAY

ENA100:	$NOISE	(ENA105,<of>)

IFG	NUMAPL,<
ENA105:	$KEYDSP(ENA110,<$ALTERNATE(ENA140)>)
>;END NUMAPL
IFLE	NUMAPL,<
; [3]	ENA105:	$KEY(ENA110)
ENA105:	$KEYDSP(ENA110)			;[3] Correct typo
>;END

ENA110:	$STAB
	ORNDSP(ENA160,<ALL-MESSAGES>,ALM)
	ORNDSP(ENA160,<BATCH-MESSAGES>,BAT)
	ORNDSP(CONFRM,<BUGCHK-MESSAGES>,CHK)
	ORNDSP(CONFRM,<BUGINF-MESSAGES>,INF)
	ORNDSP(ENA160,<CARD-PUNCH-MESSAGES>,CDP)
	ORNDSP(ENA160,<CARD-READER-INTERPRETER-MESSAGES>,BIN)
IFN FTFTS,<
	ORNDSP(ENA160,<FAL-MESSAGES>,FAL)
>  ; End of FTFTS conditional
	ORNDSP(ENA160,<FILE-RETRIEVAL-MESSAGES>,RET)
IFN FTFTS,<
	ORNDSP(ENA160,<FTS-MESSAGES>,FTS)
>  ; End of FTFTS conditional
	ORNDSP(ENA160,<MOUNT-MESSAGES>,MNT)
	ORNDSP(ENA160,<PAPER-TAPE-PUNCH-MESSAGES>,PTP)
	ORNDSP(ENA160,<PLOTTER-MESSAGES>,PLT)
	ORNDSP(ENA160,<PRINTER-MESSAGES>,LPT)
	ORNDSP(ENA160,<READER-MESSAGES>,RDR)
	ORNDSP(CONFRM,<SYSTEM-MESSAGES>,SYM)
	ORNDSP(ENA160,<USER-MESSAGES>,USR)
	$ETAB

IFG	NUMAPL,<
ENA140:	$KEY(CONFRM,ENA150)

	DEFINE	X(A,B,C),<ORNKEY(<A'-MESSAGES>,<B>)>

ENA150:	$STAB
	TABAPL
	$ETAB
>;END NUMAPL

ENA160:	$SWITCH(NEXT(ENA160),ENA170,<$ACTION(SHRSWT),$ALTERNATE(CONFRM)>)

ENA170:	$STAB
	ORNSWI(<INFORMATION-MESSAGES>,OTH)
	ORNSWI(<JOB-MESSAGES>,JOB)
	ORNSWI(<OPR-ACTION-MESSAGES>,OAM)
	$ETAB
SUBTTL	ENACLS	ENABLE CLASS SCHEDULER command tables

TOPS20 <

ENACLS:	$SWITCH(,ENAC10,<$ALTERNATE(CONFRM),$ACTION(SHRSWT),$PREFILL(ENAACT)>)

ENAC10:	$STAB
	ORNSDP(ENAC30,<CLASS-ASSIGNMENTS:>,CAS)
	ORNSDP(ENAC20,<WINDFALL:>,WFL)
	$ETAB

ENAC20:	$KEY(NEXT(ENAC10),ENAC25,<$DEFAULT(<ALLOCATED>)>)

ENAC25:	$STAB
	ORNKEY(<ALLOCATED>,ALO)
	ORNKEY(<WITHHELD>,WHD)
	$ETAB

ENAC30:	$KEY(NEXT(ENAC10),ENAC35,<$DEFAULT(<ACCOUNT>)>)

ENAC35:	$STAB
	ORNKEY(ACCOUNT,ACT)
	ORNKEY(<POLICY-PROGRAM>,PPR)
	$ETAB

ENAACT:	MOVE	S1,CMDCOD			;GET THE COMMAND CODE
	CAIE	S1,.KYDIS			;WAS IT DISABLE?
	$RETT					;NO..RETURN O.K.
	MOVEI	S1,CONFRM			;GET CONFRM ADDRESS
	AOS	S1				;BUMP TO NEXT PDB
	STORE	S1,CR.PDB(S2),RHMASK		;RESET NEXT PDB
	$RETT					;RETURN
>;END TOPS20
SUBTTL	CLOSE command tables
SUBTTL	DEFINE command tables


CLOFDB:	$KEYDSP	(CLO001,<$DEFAULT(<LOG>)>)
CLO001:	$STAB
	ORNDSP	(CONFRM,LOG,LOG)
	$ETAB
SUBTTL	REPORT command tables


RPTFDB:	$NOISE	(RPT005,<by>)

RPT005:	$FIELD (RPT015,<user name>)

RPT015:	$DEV	(RPT020,<$HELP(<device being reported>),$FLAGS(CM%PO)>)

RPT020:	$CRLF	(<$ALTER(RPT025),$ACTION(TXTLIN##),$HELP(<confirm for multiple line response>)>)


RPT025:	$CTEXT	(CONFRM,<single line response>)
SUBTTL	MOUNT command tables

TOPS10<

MTNFDB:	$KEY	(MTN020,MTN010,<$DEFAULT(<STRUCTURE>)>)
MTN010:	$STAB
	ORNKEY	(<STRUCTURE>,STR)
	$ETAB
MTN020:	$DEV	(MTN030,<$HELP(<structure name>),$FLAGS(CM%PO)>)
MTN030:	$NOISE	(MTN040,<as>)
MTN040:	$DEV	(MTN050,<$HELP(<alias name>),$ALTERNATE(MTN050),$FLAGS(CM%PO)>)
MTN050:	$SWITCH	(CONFRM,MTN060,<$ALTERNATE(<CONFRM>)>)
MTN060:	$STAB
	ORNSWI	(<WRITE-LOCKED>,WLK)
	$ETAB

>;END TOPS10

MTNFDB:	$KEY	(MTN020,MTN010,<$DEFAULT(<STRUCTURE>)>)
MTN010:	$STAB
	ORNKEY	(<STRUCTURE>,STR)
	$ETAB
MTN020:	$DEV	(MTN030,<$HELP(<alias name>),$FLAGS(CM%PO)>)

MTN030:	$SWITCH	(MTN050,MTN040,<$ALTERNATE(<CONFRM>)>)
MTN040:	$STAB
	ORNSWI(<STRUCTURE-ID:>,SID)
	$ETAB

MTN050:	$DEV	(CONFRM,<$HELP(<structure name>),$FLAGS(CM%PO)>)
	SUBTTL	NEXT - NEXT COMMAND

NXTFDB:	$NOISE	(NXT010,<job on>)		;[NXT]

NXT010:	$KEYDSP(NXT020)				;[NXT]

NXT020:	$STAB					;[NXT]
	ORNDSP(NXT040,BATCH-STREAM,BAT)		;[NXT]
IFE NICSW,<
	ORNDSP(NXT030,CARD-PUNCH,CDP)		;[NXT]
>;IFE NICSW
IFN NICSW,<
REPEAT 0,<
	ORNDSP(NXT030,<FOREIGN-PRINTER>,PLT)
	ORNDSP(NXT030,LASER-PRINTER,CDP)	;[LSRSPL]
>;REPEAT 0
>;IFN NICSW
IFE NICSW,<
	ORNDSP(NXT030,PAPER-TAPE-PUNCH,PTP)	;[NXT]
	ORNDSP(NXT030,PLOTTER,PLT)		;[NXT]
	ORNDSP(NXT030,PRINTER,LPT)		;[NXT]
>;IFE NICSW
IFN NICSW,<
	ORNDSP(NXT045,PRINTER,LPT)		;[NXT]
>;IFN NICSW
	$ETAB					;[NXT]

NXT030:	$NOISE	(NXT050,<unit number>)		;[NXT]
NXT040:	$NOISE	(NXT050,<stream number>)	;[NXT]
IFN NICSW,<
NXT045:	$PNKEY (NXT100)
>;IFN NICSW

NXT050:	$NUMBER	(NXT080,^D10,<number (/NODE:)>,<$ACTION(STOBTH),>) ;[NXT]
NXT080:	$SWITCH (NXT090,NXT085,<$DEFAULT(<REQUEST-ID>),$ALTER(NXT100)>) ;[NXT]
NXT085:	$STAB					;[NXT]
	ORNSWI(NODE:,NOD)			;[NXT]
	$ETAB					;[NXT]
NXT090:	$NODNM	(NXT100,<node name>,<$FLAGS(CM%PO!CM%NSF)>) ;[NXT]

NXT100:	$KEYDSP	(NXT110,<$DEFAULT(<REQUEST-ID>)>) ;[NXT]

NXT110:	$STAB					;[NXT]
	ORNDSP(NXT120,<REQUEST-ID>,RQN)		;[NXT]
	$ETAB					;[NXT]

NXT120:	$NUMBER(CONFRM,^D10,<request number of the next job to schedule>,<$ACTION(CHKPOS)>) ;[NXT]

SUBTTL	IDENTIFY command tables

TOPS20 <
IDNFDB:	$NOISE(IDN010,<tape on drive>)>

TOPS10 <
IDNFDB:	$NOISE(IDN010,<device>)>

TOPS20 <
IDN010:	$DEV(IDN020,<$HELP(<tape drive name>)>)>

TOPS10 <
IDN010:	$DEV(IDN020,<$HELP(<device name>)>)>

IDN020:	$NOISE(IDN030,<with>)

IDN030:	$KEYDSP(IDN040,<$DEFAULT(<REQUEST-ID>)>)

IDN040:	$STAB
	ORNDSP(IDN050,<REQUEST-ID>,RQN)
TOPS20<	ORNDSP(CONFRM,<SCRATCH>,SCR) >	;ONLY VALID ON TOPS20
	ORNDSP(IDN060,<VOLUME-ID>,VID)
	$ETAB

IDN050:	$NUMBER(CONFRM,^D10,<request number of the mount request>,<$ACTION(CHKPOS)>)

IDN060:	$QUOTE(CONFRM,<volume-id in quotes if has non-alphanumeric characters>,<$ALTERNATE(IDN070)>)

IDN070:	$FIELD(CONFRM,<volume-id without quotes>)


SUBTTL	SWITCH	command tables (TOPS20)


TOPS20 <
SWIFDB:	$NOISE(SWI010,<request number>)

SWI010:	$NUMBER(SWI020,^D10,<request number of the mount request to switch>)

SWI020:	$NOISE(SWI030,<to new volume>)

SWI030:	$QUOTE(SWI050,<volume-id in quotes if has non-alphanumeric characters>,<$ALTERNATE(SWI040)>)

SWI040:	$FIELD(SWI050,<volume-id without quotes>)

SWI050:	$NOISE(SWI060,<on drive>)

SWI060:	$DEV(CONFRM,<$HELP(<tape drive to switch request to>),$ALTERNATE(CONFRM)>)

>;END TOPS20
SUBTTL	DISMOUNT command tables


DSMFDB:$KEYDSP(DSM010)

DSM010:	$STAB
	ORNDSP(DSM020,<STRUCTURE>,STR)
	ORNDSP(DSM030,<TAPE-DRIVE>,TAP)
	$ETAB

TOPS20 <

DSM020:	$DEV	(DSM060,<$HELP(<structure name to dismount>)>)

DSM060:	$NOISE (DSM070,<with>,<$ALTERNATE(CONFRM)>)

DSM070:	$KEY (CONFRM,DSM080,<$ALTERNATE(CONFRM)>)

DSM080:	$STAB
	ORNKEY (<NO-REMOVAL>,NRM)
	ORNKEY (<REMOVAL>,REM)
	$ETAB

> ;End TOPS20

DSM030:	$DEV	(CONFRM,<$HELP(<tape drive from which to dismount tape>)>)

TOPS10 <

DSM020:	$DEV	(DSM040,<$HELP(<structure name to dismount>),$FLAGS(CM%PO)>)

DSM040:	$SWITCH(,DSM050,<$ACTION(SHRSWT),$ALTERNATE(CONFRM)>)

DSM050:	$STAB
	ORNSDP(NEXT(DSM040),<NOCHECK>,NCK)
	ORNSDP(NEXT(DSM040),<REMOVE>,REM)
	$ETAB

> ;End TOPS10

	comment \
	;removed on July 11,1979
SUBTTL	UNLOAD	command tables (removed)

UNLFDB:	$NOISE(UNL010,<tape drive>)

UNL010:	$DEV	(CONFRM,<$HELP(<tape drive to unload>)>)

;	UNDEFINED FOR NOW
	\;end of comment


SUBTTL	RECOGNIZE command tables


TOPS10 <
RECFDB:	$NOISE(REC010,<labels on>)

REC010:	$DEV (CONFRM,<$HELP(<tape or disk drive to recognize>),$FLAGS(CM%PO)>)
>;END TOPS10

SUBTTL	PUSH command tables
TOPS20 <

PUSFDB::	$NOISE(PUS100,<to EXEC level>)

PUS100:	$CRLF(<$ACTION(PUSHRT##)>)
>;END TOPS20


SUBTTL	HELP command tables

	ND	CR.ADR,4		;Address of current argument

HLPFDB:: $NOISE	(HLPFD1,<with>)

HLPFD1:	$CTEXT(,<command>,<$ACTION(HLPACT),$DEFAULT(HELP)>)

HLPACT:	MOVE	T1,CR.ADR(S2)		;Get the data
	HRROI	T1,ARG.DA(T1)		;Point to the string
	$CALL	SETOUT##		;Setup proper $TEXT defaults
	MOVEI	S1,HEPFD		;Point to help file
	MOVE	S2,T1			;Point to string
	$CALL	P$HELP##
	$CALL	SNDOUT##		;Send the output
	$CALL	P$NPRO##		;Mark no processing
	$RETT				;Return

;File descriptor for help file for OPR

TOPS20	<
HEPFD:	XWD	HSIZ,0
	ASCIZ /HLP:OPR.HLP/
HSIZ==.-HEPFD
>

TOPS10	<
HLPFD:	$BUILD	FDMSIZ
	$SET(.FDLEN,FD.LEN,FDMSIZ)
	$SET(.FDSTR,,<SIXBIT/HLP/>)
	$SET(.FDNAM,,<SIXBIT/OPR/>)
	$SET(.FDEXT,,<SIXBIT/HLP/>)
	$EOB
>

SUBTTL	SHOW ALLOCATION command tables

TOPS10<
ALC000:	$KEYDSP	(ALC010)

ALC010:	$STAB
	ORNDSP	(CONFRM,<ALL-REQUESTS>,ALL)
	ORNDSP	(ALC020,<BATCH-REQUEST>,BRQ)
	ORNDSP	(ALC030,JOB,JOB)
	$ETAB

ALC020:	$NUMBER	(CONFRM,^D10,<request-id for batch job>,<$ALTERNATE(ALC040)>)

ALC030:	$NUMBER	(CONFRM,^D10,<job number>)

ALC040:	$CRLF	($HELP(<confirm for all batch requests>))
>;END TOPS10
SUBTTL UNDEFINE command tables

UNDFDB:	$KEY (UND020,UND010,<$DEFAULT(<STRUCTURE>)>)

UND010:	$STAB
	ORNKEY (STRUCTURE,STR)
	$ETAB

UND020:	$DEV (CONFRM,<$HELP(<structure name>),$FLAGS(CM%PO)>)
	END
