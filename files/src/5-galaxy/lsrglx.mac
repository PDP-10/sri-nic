;[SRI-NIC]SRC:<5-GALAXY>LSRGLX.MAC.8, 23-Mar-88 17:23:29, Edit by MKL
; changed hello name back to LSRSPL, cause that's what the EXEC
; expects the default LASER printer to be
;[SRI-NIC]SRC:<5-GALAXY>LSRGLX.MAC.7, 22-Mar-88 14:56:02, Edit by MKL
; now used with IMGSPL.  Changed name in hello packet.
;SRC:<5-GALAXY>LSRGLX.MAC.4, 19-Sep-86 12:44:11, Edit by KNIGHT
; Respond to .OTLPT
;SRC:<5-GALAXY>LSRGLX.MAC.2, 20-Jun-86 12:59:43, Edit by KNIGHT
;GETDEV to .GTDEV

	TITLE LSRGLX - GALAXY INTERFACE FOR LSRSPL
	SUBTTL EXTERN/INTERN DEFINITIONS

; BILLY BROWN
; UNIVERSITY OF TEXAS AT AUSTIN
; JUNE, 1983

	SEARCH MACSYM
	SEARCH MONSYM
	SEARCH QSRMAC
	SEARCH ORNMAC
	SEARCH GLXMAC
	SEARCH LSRMAC
	EXTERN .JBOPS
	.REQUIRE SYS:MACREL
	SALL


;	EXTERNAL ROUTINES TO PROCESS REQUESTS

	EXTERN DOJOB		;PROCESS THE JOB
	EXTERN DOACT		;PROCESS ACCOUNTING
	EXTERN .GTDEV		;ASSIGN DEVICE ON STARTUP
	EXTERN RELDEV		;RELEASE DEVICE ON SHUTDOWN


;	INTERNAL ROUTINES TO TALK TO GALAXY

	INTERN .SPOL.		;ENTRY POINT
	INTERN JOBINF		;JOB INFORMATION BLOCK
	INTERN SNOOZE		;PAUSE EXECUTION
	INTERN CHKMSG		;CHECK FOR QUASAR/ORION MESSAGES
	INTERN CHKPNT		;CHECKPOINT TO QUASAR
	INTERN DEVSTS		;UPDATE DEVICE STATUS
	INTERN SPLSTS		;SPOOLER STATUS STRING
	INTERN TEXT.		;TEST UTILITY
	INTERN .WTO.		;ORION MESSAGE ROUTINES
	INTERN .ACK.
	INTERN .WTOJ.
	INTERN .LOG.


	SUBTTL DEFINEITIONS

OBJTYP== .OTLPT			;GALAXY OBJECT TYPE
MSGPAG== 600			;PAGE FOR IPCF MESSAGES
MSG== MSGPAG*1K

STKLEN== 1000			;LENGTH OF THE STACK
PDBLEN==4			;LENGTH OF PACKET DESCRIPTOR BLOCKS


	SUBTTL STORAGE

OBJBLK:	BLOCK 3			;OBJECT DESCRIPTOR BLOCK

MYPID:	BLOCK 1			;OUR PID
QSRPID:	BLOCK 1			;QUASAR'S PID
ORNPID:	BLOCK 1			;ORION'S PID


SNDPDB:	BLOCK PDBLEN		;PDB FOR SENDS TO QUASAR AND ORION

PAGRCV:	EXP IP%CFR!IP%CFV	;PDB FOR PAGE RECEIVES
	EXP 0
	EXP MYPID
	XWD 1K,<MSG/1K>

SHTRCV:	EXP IP%CFR		;PDB FOR SHORT RECEIVES
	EXP 0
	EXP MYPID
	XWD 1K,MSG

PRVPDB:	EXP IP%CFS		;PDB FOR PRIVATE SYSTEM SETUP
	MYPID
	EXP 0
	EXP PRVMSG

PRVMSG:	EXP .IPCIW		;PACKET TO <SYSTEM>INFO
PRVMS1:	BLOCK 1
PRVMS2:	BLOCK 50

HELLO:	XWD HELLEN,.QOHEL	;HELLO BLOCK TO QUASAR
	EXP 0
	EXP 0
	SIXBIT "LSRSPL"		;PROGRAM NAME
	XWD %%.QSR,0		;QUASAR VERSION, FLAGS
	XWD 1,1			;NUMBER OF OBJECTS, MAX NUMBER OF JOBS
	XWD 0,OBJTYP		;OBJECT LIST
HELLEN==.-HELLO

SPLSTS:	BLOCK 50		;STRING SPACE FOR SPOOLER STATUS

TXTBUF:	BLOCK 50		;TEMP TEXT BUFFER
WTOADR:	BLOCK 1			;WTO TEMP VARIABLES
WTOPTR:	BLOCK 1
WTOACS:	BLOCK 5

JOBINF:	BLOCK 1000		;EXTERNAL QUEUE ENTRY FOR CURRENT JOB


	SUBTTL MAIN LOOP

.SPOL.:	MOVEI A,.FHSLF		;THIS PROCESS
	SETOB B,C		;ENABLE EVERYTHING
	EPCAP
	SETZ F,			;NO FLAGS
	CALL INIT		;INITIALIZE THINGS



MAIN:	CALL GETMSG		;GET A MESSAGE
	TXNN F,F%UP		;DEVICE STARTED?
	 JRST MAIN		;NO, GET ANOTHER MESSAGE
	JRST MAIN2		;NO SLEEP FIRST TIME INTO LOOP

MAIN1:	MOVEI A,5		;WAIT FIVE SECONDS
	CALL SNOOZE
MAIN2:	TXNN F,F%UP		;STILL STARTED?
	 JRST MAIN		;NO, BACK TO THE TOP
	CALL CHKMSG		;CHECK FOR A MESSAGE
	TXNN F,F%JOB		;DO WE HAVE A JOB?
	 JRST MAIN1		;NO, NOTHING TO DO
	TXZ F,F%REQ!F%ABT!F%HDR	;RESET THESE
	CALL DOJOB		;DO THE JOB
	CALL DOACT		;DO THE ACCOUNTING
	CALL RELJOB		;RELEASE THE JOB
	JRST MAIN1		;LOOP BACK



; SNOOZE - DISMISS FOR THE NUMBER OF SECONDS IN A.

SNOOZE:	IMULI A,^D1000		;CONVERT TO MILISECONDS
	DISMS			;SLEEP
	RET			;RETURN

	SUBTTL IPCF MESSAGE RECEIVER

; GETMSG - WAITS FOR AND READS A MESSAGE FROM QUASAR OR ORION.
; CHKMSG - LOOKS FOR A MESSAE AND PROCESSES IT IF ONE IS WAITING.
;	   MESSAGES ARE PROCESSED AS SOON AS THEY ARE READ.

CHKMSG:	TXZA F,F%F1		;F1 - ON IF WE MUST READ A MESSAGE
GETMSG:	TXO F,F%F1
	TRVAR <NXTMSG>
GETMS1:	MOVEI A,PDBLEN		;LENGTH OF PDB
	MOVEI B,PAGRCV		;TRY FOR A PAGE
	MOVX C,IP%CFB		;GET THE DONT-BLOCK FLAG
	TXNE F,F%F1		;WANT TO WAIT?
	 ANDCAM C,.IPCFL(B)	;YES
	TXNN F,F%F1
	 ORM C,.IPCFL(B)
	MRECV			;GET THE MESSAGE
	 JRST [	CAIN A,IPCFX2	;NO MESSAGE AVAILABLE?
		 RET		;YES, QUIT NOW
		CAIE A,IPCF16	;DATA MODES DIFFERENT?
		 JRST NORECV	;NO, CAN'T CONTINUE
		MOVEI A,PDBLEN	;SAME LENGTH
		MOVEI B,SHTRCV	;TRY FOR A SHORT MESSAGE
		MOVE C,[1K,,MSG];RESET THIS
		MOVEM C,SHTRCV+.IPCFP
		MRECV		;GET IT
		 JRST NORECV	;CON'T
		JRST .+1 ]	;DONTINUE
	MOVEM A,NXTMSG		;SAVE FLAGS FOR THE NEXT ONE
	MOVE A,.IPCFS(B)	;GET THE SENDER
	CAME A,QSRPID		;FROM QUASAR?
	CAMN A,ORNPID		;OR ORION?
	 SKIPA			;YES
	 JRST GETMS1		;NO, GET ANOTHER ONE
	HRRZ A,MSG+.MSTYP	;GET THE MESSAGE TYPE
	MOVE D,[-TYPNUM,,TYPTAB]
GETMS2:	HRRZ B,(D)		;GET THE NEXT MESSAGE TYPE
	CAMN A,B		;A MATCH?
	 JRST GETMS3		;YES
	AOBJN D,GETMS2		;NO, TRY AGAIN
	JRST GETMS1		;NOT A MATCH, GET ANOTHER MESSAGE

GETMS3:	HLRZ A,(D)		;GET THE ROUTINE ADDRESS
	CALL (A)		;DO IT
	SKIPE NXTMSG		;IS THERE A MESSAGE WAITING?
	 JRST GETMS1		;YES, DO IT TOO
	RET			;DONE


NORECV:	TMSG <?SPOOL: Can't receive IPCF messages>
	HALTF
	RET


; GALAXY MESSAGES WE WILL PAY ATTENTION TO

TYPTAB:	XWD	SETUP,.QOSUP	;SETUP OR SHUTDOWN
	XWD	NXTJOB,.QONEX	;NEXT JOB DESCRIPTION
	XWD	ECANCL,.QOABO	;EXEC CANCEL COMMAND
	XWD	OCANCL,.OMCAN	;OPR CANCEL COMMAND
	XWD	REQUEU,.OMREQ	;OPR REQUEUE COMMAND
	XWD	CHKPNT,.QORCK	;QUASAR CHECKPOINT REQUEST
TYPNUM==.-TYPTAB


	SUBTTL JOB ABORT REQUESTED BY USED

ECANCL:	TXNE F,F%HDR		;PRINTING THE HEADER PAGE?
	 RET			;YES, DON'T ABORT
	TXOE F,F%ABT		;ALREADY ABORTING?
	 RET			;YES, DON'T DO IT TWICE
	RET			;DONE



	SUBTTL JOB ABORT REQUESTED BY OPRATOR

OCANCL:	TXNE F,F%HDR		;PRINTING HEADER?
	 RET			;YES
	TXOE F,F%ABT		;ALREADY ABORTING?
	 RET			;YES
	MOVE A,JOBINF+.EQJBB	;GET THE JOB NAME
	ACK (<Aborting>,<Job %61 aborting>)
	RET			;DONE


	SUBTTL REQUEUE REQUESTED BY OPERATOR

REQUEU:	TXOE F,F%REQ!F%ABT	;ALREADY REQUEUED OR ABORTED?
	 JRST REQUE1		;YES
	MOVE A,JOBINF+.EQJBB	;GET THE JOB NAME
	ACK (<Job requeued>,<Job %61 requeued>)
	RET			;DONE

REQUE1:	MOVE A,JOBINF+.EQJBB	;GET THE JOB NAME
	ACK (<Job Not Requeued>,<Job %61 finishing up>)


	SUBTTL NEXT JOB DESCRIPTION

NXTJOB:	TXOE F,F%JOB		;ALREADY HAVE A JOB?
	 RET			;YES, IGNORE THIS ONE
	MOVE A,[MSG,,JOBINF]	;GET THE JOB INFORMATION
	HLRZ B,MSG		;GET THE MESSAGE LENGTH
	BLT A,JOBINF(B)		;MOVE IT INTO THE JOB INFO BLOCK
	RET			;DONE

	SUBTTL DEVICE SETUP

SETUP:	MOVE A,MSG+SUP.FL	;GET THE FLAGS
	TXNE A,SUFSHT		;REALLY A SETUP?
	 JRST SHTDWN		;NO, SHUTDOWN MESSAGE

	MOVE A,MSG+SUP.TY	;GET THE OBJECT TYPE
	CAIE A,OBJTYP		;OUR OBJECT TYPE?
	 JRST SETBAD
	MOVEM A,OBJBLK		;SAVE IT
	DMOVE A,MSG+SUP.UN	;UNIT AND NODE
	DMOVEM A,OBJBLK+1
	CALL .GTDEV		;GET THE DEVICE (UNIT NUMBER STILL IN A)
	 JRST SETBAD		;CAN'T

	TXO F,F%UP
	WTO <Started>		;TELL ORION WE'RE OK
	MOVEI A,%RSUOK		;GET OK CODE
	SETZM MSG+RSU.CD
	JRST SETUP1		;TELL QUASAR WE'RE OK

SETBAD:	WTO <Not available>
	SKIPE A			;ANY ERROR CODE RETURNED?
	 MOVEI A,DIAGX2		;NO, SAY NOT AVAILABLE
	MOVEM A,MSG+RSU.CD
	MOVEI A,%RSUNA		;SAY NOT AVAILABLE

SETUP1:	MOVEM A,MSG+RSU.CO	;STORE THE RESPONSE CODE
	DMOVE A,OBJBLK		;GET THE OBJECT BLOCK
	DMOVEM A,MSG+RSU.TY	;STORE IT
	MOVE A,OBJBLK+2
	MOVEM A,MSG+RSU.NO
	MOVEI A,%LOWER		;SAY LOWER CASE
	HRLM A,MSG+RSU.DA	;SO QUASAR WILL SCHEDULE FOR US
	SETZM MSG+RSU.PN	;NO PROTYPE NODE NAME
	MOVE A,[RSU.SZ,,.QORSU]	;GET HEADER INFORMATION
	MOVEM A,MSG
	CALL SNDQSR		;SEND IT TO QUASAR
	RET			;DONE


	SUBTTL DEVICE SHUTDOWN

SHTDWN:	TXNE F,F%JOB		;HAVE A JOB?
	 RET			;YES, DON'T SHUTDOWN
	MOVE A,MSG+SUP.TY	;GET THE OBJECT TYPE
	CAIE A,OBJTYP		;OUR OBJECT TYPE?
	 RET			;NO, DON'T SHUTDOWN
	CALL RELDEV		;RELEASE THE DEVICE
	RET			;DONE


	SUBTTL JOB CHECKPOINT

CHKPNT:	MOVE A,JOBINF+.QEITN	;GET THE TASK NAME
	MOVEM A,MSG+CHE.IT	;STORE IT
	MOVX A,CH.FCH!CH.FST	;GET SOME FLAGS
	MOVEM A,MSG+CHE.FL	;STORE IT
	HRROI A,MSG+CHE.ST	;POINT TO THE STATUS MESSAGE
	HRROI B,SPLSTS		;AND TO THE STATUS STRING
	SETZ C,
	SOUT			;WRITE IT OUT
	IDPB C,A		;ASCIZ IT
	HRRZS A			;GET ADDRESS OF LAST WORD
	SUBI A,MSG-1		;GET THE MESSAGE LENGTH
	HRLZM A,MSG		;STORE IT
	MOVEI A,.QOCHE		;GET CHECKPOINT TYPE
	HRRM A,MSG		;STORE IT
	CALL SNDQSR		;SEND IT TO QUASAR
	RET			;DONE


	SUBTTL DEVICE STATUS UPDATE

DEVSTS:	DMOVE A,OBJBLK		;GET THE OBJECT BLOCK
	DMOVEM A,MSG+STU.RB
	MOVE A,OBJBLK+2
	MOVEM A,MSG+STU.RB+2
	MOVX A,%ACTIV		;ASSUME DEVICE IS ACTIVE
	TXNE F,F%OFF		;IS IT OFF LINE?
	 MOVX A,%OFLNE		;YES
	TXNN F,F%UP		;STARTED?
	 MOVX A,%IDLE		;YES
	MOVEM A,MSG+STU.CD
	MOVE A,[STU.SZ,,.QOSTU]	;GET THE HEADER WORD
	MOVEM A,MSG		;STORE IT
	CALL SNDQSR		;SEND IT OFF
	RET			;DONE

	SUBTTL SNDQSR/SNDORN - SEND A MESSAGE TO QUASAR OR ORION

SNDQSR:	SKIPA A,QSRPID		;GET QUASAR'S PID
SNDORN:	MOVE A,ORNPID		;GET ORION'S PID

	SETZM MSG+1		;NO FLAGS
	SETZM MSG+2		;NO ACK CODE
	MOVEM A,SNDPDB+.IPCFR	;SAVE RECEIVER PID
	MOVE A,MYPID		;GET OUR PID
	MOVEM A,SNDPDB+.IPCFS	;SAVE AS SENDER PID
	SETZM SNDPDB		;NO FLAGS
	HLLZ A,MSG		;GET LENGTH OF MESSAGE
	HRRI A,MSG		;AND ADDRESS
	MOVEM A,SNDPDB+.IPCFP	;STORE IT
	MOVEI A,4		;LENGTH OF PDB
	MOVEI B,SNDPDB		;ADDRESS OF PDB
	MSEND			;SEND IT OFF
	 SKIPA
	RET			;DONE

	TMSG <?SPOOL: Send to Quasar or Orion failed>
	HALTF
	RET


	SUBTTL GALAXY INTERFACE INITIALIZATION

INIT:	MOVEI C,.MUCRE		;CREATE A PID
	MOVEM C,MSG
	MOVEI C,.FHSLF		;THIS PROCESS
	MOVEM C,MSG+1
	MOVEI A,3
	MOVEI B,MSG
	MUTIL			;GET IT
	 JRST NOPIDS
	MOVE C,MSG+2
	MOVEM C,MYPID		;SAVE IT

	SKIPN .JBOPS		;PRIVATE SYSTEM?
	 CALL SYSPID		;NO, GET SYSTEM PIDS
	SKIPE .JBOPS
	 CALL PRVPID		;YES, GET PRIVATE PIDS

	MOVE A,[HELLO,,MSG]	;GET THE HELLO MESSAGE
	BLT A,MSG+HELLEN	;MOVE INTO THE MESSAGE BUFFER
	CALL SNDQSR		;SEND IT TO QUASAR
	RET			;READY TO GO


; SYSPID - GET PIDS FOR SYSTEM QUASAR AND ORION

SYSPID:	MOVEI A,3		;LENGTH OF BLOCK
	MOVEI B,MSG		;ADDRESS OF BLOCK
	MOVEI C,.MURSP		;READ FROM PID TABLE
	MOVEM C,MSG
	MOVEI C,.SPQSR		;READ QUASAR'S PID
	MOVEM C,MSG+1
	MUTIL			;GET QUASAR'S PID
	 JRST [MOVEI A,3000	;SLEEP AND TRY AGAIN
	       DISMS%
	       JRST SYSPID]
	MOVE C,MSG+2		;GET QUASARS PID
	MOVEM C,QSRPID		;SAVE IT

	MOVEI C,.SPOPR		;READ ORION'S PID
	MOVEM C,MSG+1
	MUTIL
	 JRST NOPIDS
	MOVE C,MSG+2		;GET ORION'S PID
	MOVEM C,ORNPID		;SAVE IT
	RET			;DONE


; PRVPID - GET PIDS FOR PRIVATE QUASAR AND ORION

PRVPID:	HRROI A,[ASCIZ /QUASAR/]
	CALL PRVGET
	MOVEM A,QSRPID
	HRROI A,[ASCIZ /ORION/]
	CALL PRVGET
	MOVEM A,ORNPID
	RET


; PRVGET - GET PRIVATE PID FOR PROCESS. NAME POINTER IN A.

PRVGET:	TXZ F,F%F1
PRVGT1:	PUSH P,A
	MOVE P3,[POINT 7,PRVMS2]
	GJINF
	MOVE B,(P)
	TEXT (PRVTXT,<[%U1]%S2>)
	SETZ A,
	IDPB A,P3
	HRRZS P3
	SUBI P3,PRVMSG-1
	HRLM P3,PRVPDB+.IPCFP
	SETZM PRVMS1		;NO CC
	MOVEI A,4
	MOVEI B,PRVPDB
	MSEND
	 JRST NOPIDS
	MOVEI A,4
	MOVEI B,SHTRCV
	MRECV
	 JRST NOPIDS
	POP P,C
	MOVE A,MSG+1
	LDB B,[POINT 6,SHTRCV,29]
	CAIE B,76
	 RET
	MOVE P3,[POINT 7,SPLSTS]
	TEXT (PRVTXT,<%%SPOOL: Waiting for %S3 to start%_>)
	SETZ A,
	IDPB A,P3
	HRROI A,SPLSTS
	TXON F,F%F1
	 PSOUT
	MOVEI A,3
	CALL SNOOZE
	MOVE A,C
	JRST PRVGT1

PRVTXT:	IDPB A,P3
	RET


NOPIDS:	TMSG <?SPOOL: Can't set up PIDs>
	HALTF
	JRST .-1


	SUBTTL RELEASE THE CURRENT JOB

RELJOB:	TXZ F,F%JOB		;NO MORE JOBS
	TXNE F,F%REQ		;IS THIS A REQUEUE?
	 JRST REQJOB		;YES, REAUEUE IT INSTEAD
	MOVE A,[REL.SZ,,.QOREL]	;GET HEADER WORD
	MOVEM A,MSG		;STORE IT
	MOVE A,JOBINF+.EQITN	;GET THE INTERNAL TASK NAME
	MOVEM A,MSG+REL.IT	;STORE IT
	SETZM MSG+REL.FL	;NO FALGS
	SETZM MSG+REL.TX	;NO TEXT
	MOVE A,[MSG+REL.TX,,MSG+REL.TX+1]
	BLT A,MSG+REL.SZ	;ZERO THE BLOCK
	CALL SNDQSR		;SEND IT OFF
	RET			;DONE

REQJOB:	MOVE A,[REQ.SZ,,.QOREQ]	;GET THE FUNCTION
	MOVEM A,MSG		;STORE IT
	MOVE A,JOBINF+.EQITN	;GET THE TASK NAME
	MOVEM A,MSG+REQ.IT	;STORE IT
	MOVX A,RQ.HBO		;HAVE OPR HOLD IT
	MOVEM A,MSG+REQ.FL
	CALL SNDORN		;SEND IT OFF
	RET			;DONE


	SUBTTL TEXT ROUTINES

TEXT.:	MOVEM P,TXTBUF		;SAVE THE STACK POINTER
	TRVAR <TXTRTN,TXTPTR,<TXTACS,5>>
	PUSH P,P1		;SAVE THIS
	MOVEI P1,TXTACS		;GET ADDRESS OF SAVED AC BUFFER
	HRLI P1,A		;MAKE BLT POINTER
	BLT P1,4+TXTACS		;SAVE AC1 - AC5
	POP P,P1		;RESTORE THIS
	MOVE C,TXTBUF		;GET STACK POINTER
	MOVE A,(C)		;GET RETURN ADDRESS
	MOVE B,1(A)		;GET ROUTINE ADDRESS
	MOVEM B,TXTRTN		;SAVE IT
	MOVE B,3(A)		;GET STRING ADDRESS
	MOVEI B,@B		;GET REAL ADDRESS
	HLL B,[POINT 7,0]	;MAKE IT A POINTER
	MOVEM B,TXTPTR

TEXT1:	ILDB A,TXTPTR		;GET NEXT BYTE
TEXT1A:	JUMPE A,TXTEND		;END ON A ZERO BYTE
	CAIN A,"%"		;SOME THING SPECIAL?
	 JRST TEXT2		;YES
TEXT1B:	CALL @TXTRTN		;PROCESS THIS CHARACTER
	JRST TEXT1		;LOOP BACK

TXTEN1:	MOVEI A,.CHCRT		;END OF STRING, SEND A CRLF
	CALL @TXTRTN
	MOVEI A,.CHLFD		;SEND A LF
	CALL @TXTRTN
TXTEND:	HRLI 5,TXTACS		;GET POINTER TO THE ACS
	HRRI 5,A		;MAKE BLT POINTER
	BLT 5,5			;RESTORE
	RET			;ALL DONE


; HERE TO PROCESS THE "%" CHARACTER

TEXT2:	ILDB A,TXTPTR		;GET ARGUMENT
	CAIN A,"U"		;USER NAME?
	 JRST TEXT.U
	CAIN A,"F"		;FILE NAME?
	 JRST TEXT.F
	CAIN A,"N"		;DECIMAL NUMBER?
	 JRST TEXT.N
	CAIN A,"O"		;OCTAL NUMBER?
	 JRST TEXT.O
	CAIN A,"6"		;SIXBIT WORD?
	 JRST TEXT.6
	CAIN A,"E"		;ERROR STRING?
	 JRST TEXT.E
	CAIN A,"T"		;TIME?
	 JRST TEXT.T
	CAIN A,"D"		;DATE?
	 JRST TEXT.D
	CAIN A,"S"		;STRING?
	 JRST TEXT.S
	CAIN A,"_"		;CRLF AND QUIT?
	 JRST TXTEN1
	CAIN A,"%"		;A "%"?
	 JRST TEXT1B
	JRST TEXT1A		;NONE OF THESE, PROCESS THE CHARACTER



; GETAC - RETURNS THE VALUE IN B FOR THE NEXT AC NUMBER.

GETAC:	ILDB A,TXTPTR		;GET THE CHARACTER
	CAIL A,"1"		;TOO LOW?
	CAILE A,"5"		;OR TOO HIGH?
	 JRST GETAC1		;YES
	SUBI A,"1"		;CONVERT TO BINARY AND SUBTRACT ONE
	MOVEI B,TXTACS		;GET POINTER TO AC BUFFER
	ADD B,A			;GET ADDRESS OF THE ONE WE WANT
	MOVE B,(B)		;GET THE VALUE
	RET			;RETURN IT

GETAC1:	ADJSP P,-1		;BAD VALUE, BALANCE THE STACK
	JRST TEXT1A		;PROCESS THIS ONE


; "U" - USER NAME

TEXT.U:	CALL GETAC		;GET THE NUMBER
	HRROI A,TXTBUF		;POINT TO THE TEXT BUFFER
	DIRST			;WRITE IT OUT
	 JRST TEXT1		;CAN'T
	JRST TXTOUT		;SEND THE BUFFER


; "F" - FILE NAME

TEXT.F:	CALL GETAC		;GET THE JFN
	HRROI A,TXTBUF
	MOVX C,JS%DEV!JS%DIR!JS%NAM!JS%TYP!JS%GEN!JS%PAF
	JFNS			;WRITE IT OUT
	 ERJMP TEXT1		;FAILED
	JRST TXTOUT		;SEND THE BUFFER


; "N" - DECIMAL NUMBER
; "O" - OCTAL NUMBER

TEXT.N:	SKIPA C,[^D10]		;DECIMAL
TEXT.O:	MOVEI C,10		;OCTAL
	CALL GETAC		;GET THE NUMBER
	HRROI A,TXTBUF
	NOUT			;WRITE IT OUT
	 JRST TEXT1
	JRST TXTOUT		;SEND IT OUT


; "6" - SIXBIT WORD

TEXT.6:	CALL GETAC		;GET THE WORD
	MOVEI C,6		;SEE HOW MANY CHATACTERS TO PRINT
	TRNE B,77
	 JRST TEXT60
	MOVEI C,5
	TRNE B,7700
	 JRST TEXT60
	MOVEI C,4
	TRNE B,77000
	 JRST TEXT60
	MOVEI C,3
	TLNE B,77
	 JRST TEXT60
	MOVEI C,2
	TLNE B,7700
	 JRST TEXT60
	MOVEI C,1
	TLNN B,770000
	 RET			;NOTHING THERE
TEXT60:	PUSH P,B		;SAVE THE WORD
	PUSH P,C		;SND THE COUNT
	PUSH P,[POINT 6,-2(P)]	;SAVE A POINTER
TEXT6A:	ILDB A,(P)		;GET THE NEXT BYTE
	ADDI A,40		;CONVERT TO ASCII
	CALL @TXTRTN		;PROCESS IT
	SOSLE -1(P)		;ANY LEFT?
	 JRST TEXT6A		;YES, DO THEM
	ADJSP P,-3		;FLUSH THE STACK
	JRST TEXT1		;DONE


; "E" - ERROR STRING

TEXT.E:	CALL GETAC		;GET THE ERROR NUMBER
	HRLI B,.FHSLF		;THIS FORK
	HRROI A,TXTBUF		;POINT TO THE BUFFER
	SETZ C,			;NO LIMIT
	ERSTR			;WRITE IT OUT
	 JRST TEXT1		;CANT
	 JRST TEXT1
	JRST TXTOUT		;SEND IT OUT

; "T" - TIME
; "D" - DATE

TEXT.T:	SKIPA C,[OT%NDA!]	;TIME ONLY
TEXT.D:	MOVX C,OT%NTM		;DATE ONLY
	CALL GETAC		;GET THE TIME
	HRROI A,TXTBUF		;POINT TO THE BUFFER
	ODTIM			;OUTPUT IT
	JRST TXTOUT		;SEND IT OUT


; "S" - STRING

TEXT.S:	CALL GETAC		;GET THE STRING ADDRESS
	HLL B,[POINT 7,0]	;MAKE IT A POINTER
	PUSH P,B		;SAVE IT
	JRST TXTOT1		;JOIN COPY CODE


TXTOUT:	SETZ B,			;ASCIZ THE STRING
	IDPB B,A
	PUSH P,[POINT 7,TXTBUF]	;SAVE A POINTER
TXTOT1:	ILDB A,(P)		;GET NEXT CHARACTER
	JUMPE A,TXTOT2		;END ON A ZERO BYTE
	CALL @TXTRTN		;PROCESS IT
	JRST TXTOT1		;LOOP BACK
TXTOT2:	SETZM TXTBUF		;ZERO THE BUFFER
	ADJSP P,-1		;BAKANCE THE STACK
	JRST TEXT1		;LOOP BACK


	SUBTTL ORION MESSAGES

.WTO.:	PUSH P,[0]		;NO FLAGS
	PUSH P,[.OMWTO]		;WTO CODE
	JRST WTOX

.ACK.:	PUSH P,[WT.SJI]		;ACK FLAG
	PUSH P,[.OMACK]		;ACK CODE
	JRST WTOX

.WTOJ.:	PUSH P,[WT.JOB]		;JOB FLAG
	PUSH P,[.OMWTO]		;WTO CODE
	JRST WTOX

.LOG.:	PUSH P,[0]		;NO FLAGS
	PUSH P,[.OMLOG]		;LOG CODE
	JRST WTOX

WTOX:	POP P,MSG		;FILL IN THE MESSAGE TYPE
	POP P,MSG+.OFLAG	;FILL IN THE FLAGS
	MOVE P1,[1,,WTOACS]	;SAVE CALLERS ACS
	BLT P1,WTOACS+4		;SAVE AC1 - 1C5
	MOVE A,[4,,.WTOBJ]	;START WITH THE OBJECT BLOCK
	MOVE B,OBJBLK
	DMOVEM A,MSG+5
	DMOVE A,OBJBLK+1
	DMOVEM A,MSG+7
	MOVEI A,1		;ONE ARGUMENT SO FAR
	MOVEM A,MSG+.OARGC	;SAVE IT
	MOVEI A,MSG+11		;NEXT FREE ADDRESS
	MOVEM A,WTOADR		;SAVE IT
	MOVE A,(P)		;GET THE RETURN ADDRESS
	MOVE A,1(A)		;GET THE STRING
	MOVEI B,.WTTYP		;TYPE FIELD
	CALL WTOTXT		;FILL IT IN
	MOVE A,(P)		;GET RETURN ADDRESS
	MOVE A,3(A)		;GET SECOND STRING
	MOVEI B,.WTTXT		;TEXT FIELD
	CALL WTOTXT		;FILL IT IN
	MOVE A,WTOADR		;GET NEXT FREE ADDRESS
	SUBI A,MSG		;GET TOTAL ADDRESS
	HRLM A,MSG		;SAVE IT
	CALL SNDORN		;SEND IT OFF
	MOVE P1,[WTOACS,,1]	;RESTORE CALLERS ACS
	BLT P1,5
	RET			;DONE


WTOTXT:	SKIPN A			;ANY STRING?
	 RET			;NO, DONE
	AOS MSG+.OARGC		;BUMP THE ARGUMENT COUNT
	MOVEM B,@WTOADR		;FILL IN NEXT FIELD TYPE
	PUSH P,WTOADR		;SAVE THIS ADDRESS
	AOS B,WTOADR		;BUMP FREE ADDRESS
	HLL B,[POINT 7,0]	;MAKE A STRING POINTER
	MOVEM B,WTOPTR		;SAVE IT
	MOVE P2,A		;GET THE STRING
	MOVE P1,[WTOACS,,1]	;RESTORE CALLERS ACS
	BLT P1,5
	CALL TEXT.		;EXPAND THE TEXT
	  SKIPA
	  WTOFIL
	  SKIPA
	  Z (P2)
	MOVE P1,[1,,WTOACS]	;SAVE CALLERS ACS AGAIN
	BLT P1,WTOACS+4
	SETZ A,			;ASCIZ THE STRING
	IDPB A,WTOPTR
	HRRZ B,WTOPTR		;GET LAST ADDRESS USED
	AOS B			;ADJUST
	MOVEM B,WTOADR		;SAVE IT
	POP P,A			;GET FIRST ADDRESS
	SUB B,A			;GET LENGTH OF FIELD
	HRLM B,(A)		;FILL IT IN
	RET			;DONE


WTOFIL:	IDPB A,WTOPTR		;SAVE THE BYTE
	RET			;RETURN

	END
