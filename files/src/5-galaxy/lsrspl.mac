;XS:<5-GALAXY>LSRSPL.MAC.49, 18-Feb-87 10:01:56, Edit by KNIGHT
;  Flush call to CHKFMT
;XS:<5-GALAXY>LSRSPL.MAC.48, 22-Jan-87 11:13:49, Edit by KNIGHT
; Check for CR's before LF's, supply them if not there
;XS:<5-GALAXY>LSRSPL.MAC.47, 21-Jan-87 16:51:27, Edit by KNIGHT
; Where practical, use .EQOWN instead of .EQOID
;[SRI-NIC]XS:<5-GALAXY>LSRSPL.MAC.39,  4-Nov-86 20:05:50, Edit by MKL
; Do /LANDSCAPE and /BOOK
;[SRI-NIC]XS:<5-GALAXY>LSRSPL.MAC.39,  4-Nov-86 20:04:13, Edit by MKL
; Add call to setup TTY stuff
;[SRI-NIC]SRC:<5-GALAXY>LSRSPL.MAC.31, 23-Oct-86 15:47:03, Edit by MKL
; set HDRSEN at CHKHD1+n if found @DOCUMENT in file
;SRC:<5-GALAXY>LSRSPL.MAC.29, 23-Oct-86 15:28:29, Edit by KNIGHT
; Fix bogus ASCIZ in CHKHDR
;SRC:<5-GALAXY>LSRSPL.MAC.28, 23-Oct-86 15:08:01, Edit by KNIGHT
; Reinstate check of HDRSEN in FIXHDR
;SRC:<5-GALAXY>LSRSPL.MAC.19, 20-Jun-86 13:00:21, Edit by KNIGHT
;SIN to SIN%
;SRC:<5-GALAXY>LSRSPL.MAC.18, 20-Jun-86 12:59:56, Edit by KNIGHT
;GETDEV to .GTDEV
;XS:<DEC-5-1.GALAXY-SOURCES>LSRSPL.MAC.17, 20-Jun-86 12:35:06, Edit by KNIGHT
;Make this hack accept 8 bit ASCII
	TITLE LSRSPL - TOPS20 GALAXY/IS INTERFACE
	SUBTTL DEFINITIONS

; BILLY BROWN
; UNIVERSITY OF TEXAS AT AUSTIN
; JUNE, 1983


	SEARCH MACSYM
	SEARCH MONSYM
	SEARCH QSRMAC
	SEARCH ORNMAC
	SEARCH GLXMAC
	SEARCH ACTSYM
	SEARCH LSRMAC
	.TEXT '/RUNAME:LSRSPL'
	.REQUIRE LSRGLX.REL
	SALL


; INTERNALS

	INTERN GLXINI, ONLINE, OFFLIN
	INTERN DOJOB, DOACT, .GTDEV, RELDEV
	INTERN PCNTX

;EXTERNALS

	EXTERN .SPOL., MAINX, PCOUNT
	EXTERN JOBINF, SNOOZE, CHKMSG
	EXTERN CHKPNT, DEVSTS, SPLSTS
	EXTERN TEXT., .WTO., .ACK.
	EXTERN .WTOJ., .LOG.


%LSR==2				;VERSION NUMBER
TTYNO== 25			;TERMINAL NUMBER TO USE
TTYSPD==^d9600			;SPEED TO SET TTY TO
ACCTSW==0			;0= NO ACCOUNTING, -1= ACCOUNTING

F%ASC==1B35			;FILE IS ASCII FORMAT
F%IMP==1B34			;FILE IS IMPRESS FORMAT
IFN NICSW,<
F%8ASC==1B33			;FILE IS 8 BIT ASCII FORMAT
F%CRSN==1B32			;CR SEEN LAST CHARACTER
>;IFN NICSW

	SUBTTL STORAGE

TMPFIL:	ASCIZ "PS:<SPOOL>FOOBAR.IS"

FSAVE:	BLOCK 1			;SAVED GALAXY INTERFACE FLAGS
FILPTR:	BLOCK 1			;POINTER TO CURRENT FILE BLOCK
PAGCNT:	BLOCK 1			;COUNT OF PAGES
NCOPY:	BLOCK 1			;NUMBER OF COPIES FOR CURRENT FILE
NFILES:	BLOCK 1			;COUNT OF FILES TO PRINT
FILCNT:	BLOCK 1			;FILES PRINTED SO FAR

INJFN:	BLOCK 1			;INPUT JFN
OUTJFN:	BLOCK 1			;OUTPUT JFN

CURLIN:	BLOCK 1			;CURRENT LINE FOR PAGE COUNTING
PCNTX:	BLOCK 1			;PAGE COUNT FOR ASCII FILES
LINES:	BLOCK 1			;LINES PER PAGE

ARGBLK:	BLOCK 5			;CHKAC ARGUMENT BLOCK
DEVNAM:	BLOCK 5			;DEVICE NAME BUFFER

BUFFER:	BLOCK 5			;BUFFER FOR ANYTHING (ACCOUTING)
JOBPRI:	BLOCK 1			;CURRENT JOBS PRIORITY (ACCOUNTING)
RUNTIM:	BLOCK 1			;SPOOLER RUNIME (ACCOUNTING)
TIMNOW:	BLOCK 1			;TIME REQUESTED STARTED (ACCOUNTING)
HDRSEN:	BLOCK 1			;SAY HEADER WAS SEEN

	SUBTTL GET DEVICES ON STARTUP

.GTDEV:	MOVEI A,.TTDES		;GET TTY DESIGNATOR
	IORI A,TTYNO		;FILL IN TERMINAL NUMBER
	ASND			;ASSIGN THE DEVICE
	 RET			;CAN'T RETURN ERROR CODE
	AOS (P)			;GIVE SKIP RETURN
	SETZM DEVNAM		;ZERO THE BUFFER
	MOVE B,A		;GET THE DESIGNATOR
	HRROI A,DEVNAM		;POINT TO THE BUFFER
	DEVST			;WRITE THE NAME
	 RET
	SETZ B,			;ASCIZ IT
	IDPB B,A
	CALL TTYSET		;SETUP TTY STUFF
	RET			;DONE

TTYSET:	MOVEI A,.TTDES		;GET TTY DESIGNATOR
	IORI A,TTYNO		;FILL IN TERMINAL NUMBER
	RFMOD%			; get current mode for this line
	 Erjmp	.+1
	Txz B,TT%LEN!TT%WID!TT%ECO!TT%DAM!TT%PGM
	SFMOD%
	 Erjmp	.+1
	STPAR%
	 Erjmp	.+1
	Movei B,.MOSPD
	Move C,[TTYSPD,,TTYSPD]
	MTOPR%
	Movei B,.MOSTF
	Movx C,MO%NUM!MO%NTM
	MTOPR%			;refuse user messages
	Movei B,.MOSNT
	Movei C,.MOSMN
	MTOPR%			;refuse system messages
	Ret

	SUBTTL RELEASE DEVICES ON STUTDOWN

RELDEV:	MOVEI A,.TTDES		;GET TTY DESIGNAOTR
	IORI A,TTYNO
	RELD			;RELEASE IT
	 WTO (<Can't release printer line>,<%E1: Shutting down anyway>)
	RET			;ALL DONE

	SUBTTL PROCESS A JOB

DOJOB:	MOVEI A,.FHSLF		;GET OUR RUN TIME
	RUNTM%			;"RUNTM" IS DEFINED IN IS, USE "RUNTM%"
	MOVNM A,RUNTIM		;SAVE FOR LATER
	GTAD			;GET CURRENT DATE AND TIME
	MOVEM A,TIMNOW		;SAVE FOR LATER
	SETZM PAGCNT		;NO PAGES PRINTED YET
	SETZM FILCNT		;NO FILES PRINTED YET
	HRRZ A,JOBINF+.EQSPC	;GET NUMBER OF FILES IN REQUEST
	MOVEM A,NFILES		;SAVE IT
	HRRZ A,JOBINF+.EQLEN	;GET LENGTH OF THE EQ HEADER
	ADDI A,JOBINF		;GET ADDRESS OF FIRST FILE
	MOVEM A,FILPTR		;SAVE IT
	LDB B,[POINT 9,.FPINF(A),35]	;GET THE COPY COUNT
	MOVEM B,NCOPY		;SAVE IT
IFE NICSW,<	
	MOVE A,JOBINF+.EQOID	;GET THE USER NUMBER
>;IFE NICSW
IFN NICSW,<
	MOVEI A,JOBINF+.EQOWN	;USE EXTERNAL OWNER
>;IFN NICSW
	MOVE B,JOBINF+.EQJBB	;GET THE JOB NAME
	MOVE C,JOBINF+.EQRID	;GET THE REQUEST ID
IFE NICSW,<
	WTOJ (<Begin>,<job %62, Req #%N3 for %U1>)
>;IFE NICSW
IFN NICSW,<
	WTOJ (<Begin>,<job %62, Req #%N3 for %S1>)
>;IFN NICSW

DOJOB1:	AOS FILCNT		;BUMP THE FILE COUNT
	CALL DOFILE		;PRINT THIS FILE
	MOVE A,FILCNT		;GET THE NUMBER OF FILES PRINTED
	CAML A,NFILES		;DONE THEM ALL?
	 JRST DOJOB2		;YES, QUIT
	MOVE A,FILPTR		;GET POINTER TO LAST FILE
	HLRZ B,.FPLEN(A)	;GET THE LENGTH OF THE FP
	ADD A,B			;MOVE TO THE FD
	HLRZ B,.FDLEN(A)	;GET LENGTH OF THE FD
	ADD A,B			;MOVE TO NEXT FILE
	MOVEM A,FILPTR
	JRST DOJOB1		;LOOP BACK

DOJOB2:	RET			;DONE


	SUBTTL OUTPUT A FILE

DOFILE:	SETZM PCNTX		;RESET THIS
	CALL GETFIL		;GET THE FILE TO BE PRINTED
	 RET			;CAN'T
	CALL CHKACC		;CHECK USER ACCESS TO THIS FILE
	 JRST [	MOVE A,INJFN	;NO ACCESS, GET THE JFN
		LOG (<Can't print file>,<%F1: Read access required>)
		RLJFN		;RELEASE THE JFN
		 JFCL
		RET ]		;DONE

	MOVE A,INJFN		;GET THE JFN
	MOVE B,[FLD(8,OF%BSZ)!OF%RD]
	TXNE F,F%ASC		;ASCII FILE
	 MOVE B,[FLD(7,OF%BSZ)!OF%RD]
	OPENF			;OPEN IT
	 JRST [	MOVE B,INJFN	;CAN'T GET THE JFN
		LOG (<Can't print file>,<%F2: %E1>)
		RLJFN		;RELEASE THE FILE
		 JFCL
		RET ]		;DONE
IFE NICSW,<
	CALL CHKFMT		;CHECK THE FORMAT OF THE FILE
	 JRST [	MOVE A,INJFN	;WRONG FORMAT, GET THE JFN
		LOG (<Can't print file>,<%F1: Bad file format>)
		CLOSF		;RELEASE IT
		 JFCL
		RET ]		;DONE
>;IFE NICSW
	CALL FIXHDR		;FIX UP THE FILE HEADER
	 JRST [	MOVE A,INJFN	;MUST BE A DISK SPACE PROBLEM
		LOG (<Can't print file>,<%F1: FOOBAR.IS creation failure>)
		CLOSF		;RELEASE IT
		 JFCL
		TXO F,F%REQ	;REQUEUE THIS REQUEST
		RET ]

	MOVEM F,FSAVE		;SAVE GALAXY INTERFACE FLAGS
	CALL MAINX		;PRINT THE FILE
	MOVE F,FSAVE
	SKIPN A,PCNTX		;ANY PAGE COUNT FROM BEFORE?
	 HRRZ A,PCOUNT		;NO, GET COUNT FROM IS
	MOVE B,FILPTR		;GET THE FILE POINTER
	MOVE B,.FPINF(B)	;GET THE FLAGS
	TXNE B,FP.2PG		;TWO FORMS PER PAGE?
	 JRST [	IDIVI A,2	;YES, CUT IT IN HALF
		ADD A,B		;ADD IN HALF PAGE
		JRST .+1 ]
	IMUL A,NCOPY		;ACCOUNT FOR /COPIES:N
	ADDM A,PAGCNT		;ADD IT IN

	MOVX A,GJ%SHT!GJ%OLD	;GET THE TEMP FILE AGAIN
	HRROI B,TMPFIL
	GTJFN
	 RET
	TXO A,DF%EXP		;WANT TO EXPUNGE
	MOVE C,A		;SAVE THE JFN AND THE FLAG
	DELF			;DELETE IT
	 JRST [	MOVEI A,3	;WANT SOME MORE
		CALL SNOOZE
		MOVE A,C	;GET THE JFN BACK
		DELF		;TRY AGAIN
		 WTO (<Can't delete temp file>,<Won't go away: %E1>)
		JRST .+1 ]
	RET			;DONE




	SUBTTL CHECK USER ACCESS TO THE PRINT FILE

CHKACC:	MOVE A,INJFN		;SET THE JFN
	TXO A,CK%JFN		;SAY IT IS A JFN
	MOVEM A,ARGBLK+.CKAUD
	MOVE A,JOBINF+.EQSEQ	;GET EXTERNAL VALUES
	TXNE A,QE.PRV		;USER ENABLED?
	 JRST CHKAC1		;YES
	SETZM A,ARGBLK+.CKAEC	;NO
	MOVE A,JOBINF+.EQOID	;SET THE USER NUMBER
	MOVEM A,ARGBLK+.CKALD
	HRROI A,JOBINF+.EQCON	;SET DIRECTORY POINTER
	MOVEM A,ARGBLK+.CKACD
	MOVX A,.CKARD		;WANT READ ACCESS
	MOVEM A,ARGBLK+.CKAAC
	MOVEI A,5		;LENGTH OF ARGUMENT BLOCK
	MOVEI B,ARGBLK		;ADDRESS OF ARGUMENT BLOCK
	CHKAC
	 JRST CHKAC1		;FAILED, ASSUME OK
	SKIPE A			;ACCESS ALLOWED?
CHKAC1:	 AOS (P)		;YES, SKIP RETURN
	RET			;DONE


	SUBTTL CHECK THE FORMAT OF THE FILE

CHKFMT:	MOVE A,INJFN		;GET JFN OF INPUT FILE
	MOVE B,[1,,.FBBYV]	;WANT FILE I/O INFO
	MOVEI C,E		;SAVE IN REGISTER 5
	GTFDB%			;GET FDB INFO
	 ERJMP CHKFM2		;ERROR -- RETURN
	LDB B,[POINT 5,E,11]	;WANT FILE BYTE SIZE
	CAIN B,^D8		;IS BYTE SIZE IS 8
	 TXNN F,F%ASC		;AND ASCII
	  CAIA
	   JRST CHKFM2		;THEN WE SHOULD ERROR
	SETZM HDRSEN		;NO HEADER YET
	TXNN F,F%IMP		;IMPRESS FILE?
	 JRST CHKHDR		;NO, CHECK FOR A HEADER
	MOVE A,INJFN		;GET THE JFN
	BIN			;READ THE FIRST BYTE
	CAIN B,"@"		;IS IT MARKER CHARACTER?
	 JRST [ BKJFN%		;BACKUP OVER IT
		 JFCL		;IGNORE ERRORS
		SETOM HDRSEN	;REMEMBER HEADER SEEN
		JRST FMTOK]	;AND RETURN OK
	CAIL B,"0"		;MUST BE A DIGIT
	CAILE B,"9"
	SKIPA			;NOT A DIGIT
FMTOK:	 AOS (P)		;IS ONE, SKIP RETURN
CHKFM2:	RET


CHKHDR:	MOVE A,INJFN		;LOOK FOR A JOB HEADER
	RFPTR			;GET THE POINTER
	 RET			;OOPS
	PUSH P,B		;SAVE IT
	BIN			;GET THE FIRST BYTE
	CAIE B,"@"		;DOES IT START OUT RIGHT?
	 JRST CHKHD2		;NO, USE DEFAULT VALUES
	HRROI B,BUFFER		;POINT TO THE BUFFER
	MOVNI C,8		;GET EIGHT CHARACTERS
	SIN%
	SETZ C,			;ASCIZ IT
	IDPB C,B
	HRROI A,BUFFER		;CHECK FOR A VALID HEADER
	HRROI B,[ASCIZ /DOCUMENT/]
	STCMP			;COMPARE
	JUMPN A,CHKHD2		;NOT A HEADER
	MOVE A,INJFN		;GET THE FILE AGAIN
CHKHD1:	BIN			;GET THE NEXT CHARACTER
	 ERJMP CHKHD2		;NOT A VALID HEADER
	CAIE B,")"		;END OF THE HEADER?
	 JRST CHKHD1		;YES
;	ADJSP P,-1		;BALANCE THE STACK
	setom hdrsen		;saw a valid header
;	JRST CHKHDR		;LOOK FOR ANOTHER ONE

CHKHD2:	MOVE A,INJFN		;GET THE JFN
	POP P,B			;GET THE POINTER
	SFPTR			;SET IT
	 JFCL
	AOS (P)			;ASCII FILES ARE ALWAYS OK
	RET			;DONE

	SUBTTL PRE-PROCESS THE FILE

FIXHDR:	HRROI B,TMPFIL		;GET JFN ON THE TEMP FILE
	MOVX A,GJ%SHT!GJ%NEW!GJ%FOU
	GTJFN
	 JRST [	LOG (<Can't find FOOBAR.IS>,<%E1: Requeuing>)
		RET ]
	HRRZM A,OUTJFN		;SAVE THE JFN
IFN NICSW,<
	TXZ F,F%CRSN
>;IFN NICSW
	MOVE B,[FLD(8,OF%BSZ)!OF%WR]
	OPENF			;OPEN IT
	 JRST [	LOG (<Can't open FOOBAR.IS>,<%E1: Requeuing>)
		MOVE A,OUTJFN
		RLJFN		;RELEASE IT
		 JFCL
		RET ]

	SKIPE HDRSEN		;HEADER ALREADY PERSENT
	 JRST FIXHD1		;THEN SKIP MOST OF THIS
	GTAD%			;GET TIME AND DATE
	TEXT (HDRTXT,<@DOCUMENT(Spooldate "%D1 %T1",>)
IFE NICSW,<
	MOVE A,JOBINF+.EQOID	;GET THE USER NUMBER
>;IFE NICSW
IFN NICSW,<
	MOVEI A,JOBINF+.EQOWN	;GET POINTER TO THE USER STRING
>;IFN NICSW
	MOVE B,INJFN		;GET THE FILE NAME
	MOVE C,FILPTR		;POINT TO THE FP
IFE NICSW,<
	TEXT (HDRTXT,<Name "%F2",Owner "%U1",>)
>;IFE NICSW
IFN NICSW,<
	TEXT (HDRTXT,<Name "%F2",Owner "%S1",>)
>;IFN NICSW
	TEXT (HDRTXT,< Language >)

	HRROI A,[ASCIZ /Diablo, hmi 11, htabs on, at (0.75 0.25 cc), bottommargin 480/]	;default to Diablo
	MOVE B,.FPINF(C)	;GET FLAGS
	TXNE B,FP.2PG		;IF 2 PAGE THEN DO BOOK
	 HRROI A,[ASCIZ /Printer, formsperpage 2, formwidth 80/]	
	HLRZ B,.FPFR1(C)	;GET FORMWIDTH
	CAIN B,^d132		;IF 132 THEN DO LANDSCAPE
	 HRROI A,[ASCIZ /Printer, formwidth 132/]	
	TXNE F,F%IMP		;IS IT IMPRESS?
	 HRROI A,[ASCIZ /Impress/]

	TEXT (HDRTXT,<%S1>)
	MOVE B,NCOPY		;GET COPY COUNT
	CAILE B,1		;WANT MORE THAN ONE?
	  JRST [TEXT (HDRTXT,<, Copies %N2>)
		MOVE A,.FPINF(C)
		TXNE A,FP.COL	;WANT PAGE COLLATION?
		 TEXT (HDRTXT,<,Pagecollation Yes>)
		JRST .+1 ]

	MOVE A,JOBINF+.EQLIM	;GET THE FORMS TYPE
	CAME A,[SIXBIT/NORMAL/]	;IS IT THE DEFAULT?
	 TEXT (HDRTXT,<, Paper %61>)	;NO, OUTPUT IT

	MOVE A,.FPINF(C)	;GET THE FILE INFO BITS
	TXNE A,FP.REV		;WANT PAGE REVERSAL
	 TEXT (HDRTXT,<, Pagereversal Yes>)
	TXNN A,FP.REV		;WANT PAGE REVERSAL
	 TEXT (HDRTXT,<, Pagereversal No>)
	MOVE A,FILCNT		;SEE WHICH FILE THIS IS
	CAMN A,NFILES		;LAST ONE?
	 TEXT (HDRTXT,<, Jobheader Yes>)

	SETZM CURLIN		;RESET THE LINE COUNTER
	TXNE F,F%IMP		;THIS AN IMPRESS FILE?
	  JRST [TEXT (HDRTXT,<)>)
		 JRST FIXHD1]	;NO, END HEADER AND SKIP THIS

	MOVE A,FILPTR		;POINT TO THE FP
	HRRZ B,.FPFR1(A)	;GET THE LINES PER PAGE
	SKIPN B			;DEFAULT?
	 MOVEI B,^D60		;NOT THERE, MUST BE
	MOVEM B,LINES		;SAVE THIS
	CAIE B,^D60		;USING THE DEFAULT?
	 TEXT (HDRTXT,<, Formlength %N2>)
	HLRZ B,.FPFR1(A)	;GET FORMWIDTH
	SKIPE B			;DEFAULT?
	 TEXT (HDRTXT,<, Formwidth %N2>)
	HLRZ B,.FPFR2(A)	;GET TOP MARGIN
	SKIPE B			;DEFAULT?
	 JRST [	TEXT (HDRTXT,<, Topmargin %N2>)
		CAML B,LINES	;VALID NUMBER?
		 JRST .+1	;NO
		MOVNS B		;NEGATE IT
		ADDM B,LINES
		JRST .+1 ]
	HRRZ B,.FPFR2(A)	;GET LEFT MARGIN
	SKIPE B			;DEFAULT?
	 TEXT (HDRTXT,<, Leftmargin %N2>)
	MOVE B,.FPINF(A)	;GET THE FLAGS
	TXNE B,FP.2PG		;WANT TWO FORMS?
	 TEXT (HDRTXT,<, Formsperpage 2>)
	TEXT (HDRTXT,<)>)	;END THE HEADER
	JRST FIXHD1		;SKIP NEXT PART

FIXHD0:	MOVE A,INJFN		;BACK TO THE INPUT FILE
	BIN			;INPUT A BYTE
	JUMPN B,.-1		;UNTIL A NULL BYTE IS FOUND
	MOVE B,[POINT 1,BUFFER]	;POINT TO SOMETHING
	MOVNI C,8		;READ 8 MORE BYTES
	SIN%

FIXHD1:	MOVE A,INJFN		;READ FROM THE INPUT FILE
	BIN
	 ERJMP FIXHD2		;UNTIL SOMETHING GOES WRONG
IFE NICSW,<	
	TXNN F,F%IMP		;IMPRESS?
	 CALL CHKPAG		;NO, HAVE TO COUNT PAGES
>;IFE NICSW
IFN NICSW,<
	IFXE. F,F%IMP		;IMPRESS?
	  CALL CHKPAG		;NO, HAVE TO COUNT PAGES
	  CAIE B,.CHCRT		;CARRIAGE RETURN?
	  IFSKP.
	    TXO F,F%CRSN	;FLAG IT
	  ELSE.
	    CAIE B,.CHLFD	;LINEFEED?
	    IFSKP.
	      IFXE. F,F%CRSN	;LAST CHAR A CARRIAGE RETURN?
	        MOVE A,OUTJFN	;NO, THEN SEND ONE
	        MOVEI B,.CHCRT
	        BOUT%
	        MOVEI B,.CHLFD
	      ENDIF.
	    ENDIF.
	    TXZ F,F%CRSN	;LAST CHAR WAS NOT CR
	  ENDIF.
	ENDIF.
>;IFN NICSW
	MOVE A,OUTJFN		;COPY TO THE TEMP FILE
	BOUT
	 ERJMP FIXHD3
	JRST FIXHD1		;LOOP BACK

FIXHD2:	MOVE B,FILPTR		;GET THE FILE POINTER
	MOVE B,.FPINF(B)	;GET FILE INFO BITS
	MOVE A,INJFN		;CLOSE THE FILES
	TXNE B,FP.SPL		;IF A SPOOLED FILE
	 TXO A,CO%NRJ		;DON'T RETURN JFN
	CLOSF
	 JFCL
	TXNE B,FP.SPL		;WAS IT A SPOOLED FILE?
	 JRST [ MOVE A,INJFN	;GET THE FILE JFN
		TXO A,DF%EXP	;EXPUNGE THE FILE
		DELF%		;DELETE IT
		 JFCL		;IGNORE
		JRST .+1]
	MOVE A,OUTJFN
	CLOSF
	 JFCL
	TXNN F,F%IMP		;IS IT AN IMP FILE?
	 AOS PCNTX		;NO, CHARGE FOR PARTIAL PAGE
	AOS (P)			;ALL DONE
	RET			;SKIP RETURN

FIXHD3:	SETO A,			;REPORT LAST PROCESS ERROR
	LOG (<Can't make FOOBAR.IS>,<%E1: Requeuing>)
	RET			;DONE


HDRTXT:	MOVE B,A		;GET THE BYTE
	MOVE A,OUTJFN		;GET THE OUTPUT FILE
	BOUT			;OUTPUT IT
	 ERJMP .+1		;LET IT BARF LATER
	RET			;DONE



	SUBTTL COUNT PAGES FOR ASCII FILES

CHKPAG:	CAIN B,.CHLFD		;IS IT A LINE FEED?
	 JRST [	AOS C,CURLIN	;YES, BUMP THE CURRENT LINE
		CAME C,LINES	;OFF THE PAGE?
		 RET		;NO
		JRST CHKPG1 ]	;YES	
	CAIE B,.CHFFD		;IS IT A FORM FEED?
	 RET			;NO

CHKPG1:	AOS PCNTX		;NEW PAGE, BUMP THE COUNT
	SETZM CURLIN		;RESET LINE NUMBER
	RET			;DONE


	SUBTTL GETFIL - GET THE INPUT FILE

GETFIL:	MOVE D,FILPTR		;POINT TO THE FILE PARAMETER BLOCK
	HLRZ B,.FPLEN(D)	;GET LENGTH OF THE FP
	ADD B,D			;MOVE TO THE FD
	AOS B			;MOVE TO THE FILE NAME
	MOVE C,B		;SAVE IT IN CASE OF ERROR
	HRROS B			;MAKE IT A POINTER
	MOVX A,GJ%SHT!GJ%OLD	;GET A JFN ON IT
	GTJFN
	 JRST [	LOG (<Can't print file>,<%S3: %E1>)
		RET ]		;THAT WAS EASY
	MOVEM A,INJFN		;SAVE THE JFN

	TXZ F,F%IMP!F%ASC	;RESET THESE
	LDB A,[POINT 6,.FPINF(D),5]
	CAIN A,.FPFAS		;ASCII FORMAT?
	 TXO F,F%ASC
	CAIN A,.FPFIM		;BINARY?
	 TXO F,F%IMP
IFE NICSW,<
	TXNN F,F%IMP!F%ASC
>;IFE NICSW
IFN NICSW,<
	CAIN A,.FPF8B		;8-BIT ASCII?
	 TXO F,F%8ASC		; YES
	TXNN F,F%IMP!F%ASC!F%8ASC
>;IFN NICSW
IFE NICSW,<
	TXNN F,F%IMP!F%ASC
>;IFE NICSW
	 TXO F,F%IMP		;DEFAULT TO IMPRESS
	AOS (P)
	RET			;DONE


	SUBTTL ROUTINES CALLED BY IS

ONLINE:	MOVE F,FSAVE		;GET GALAXY FLAGS
	TXZN F,F%OFF		;WAS IT OFF LINE?
	 RET			;NO
	CALL DEVSTS		;UPDATE THE STATUS
	MOVEM F,FSAVE		;SAVE FLAGS AGAIN
	RET



OFFLIN:	MOVE F,FSAVE		;SAME AS ABOVE
	TXOE F,F%OFF
	 RET
	CALL DEVSTS
	WTO <Offline>
	MOVEM F,FSAVE
	RET


GLXINI:	JRST .SPOL.		;SWITCH ENTRY TO SPOOL MODULE


	SUBTTL ACCOUNTING

DOACT:
IFE NICSW,<	
	MOVE A,JOBINF+.EQOID	;GET THE USER NUMBER
>;IFE NICSW
IFN NICSW,<
	MOVEI A,JOBINF+.EQOWN	;USE EXTERNAL OWNER
>;IFN NICSW
	MOVE B,JOBINF+.EQJBB	;GET THE JOB NAME
	MOVE C,JOBINF+.EQRID	;GET THE REQUEST ID
	AOS D,PAGCNT		;GET THE PAGE COUNT
IFE NICSW,<
	WTOJ (<End>,<job %62, Req #%N3 for %U1 (%N4 pages)>)
>;IFE NICSW
IFN NICSW,<
	WTOJ (<End>,<job %62, Req #%N3 for %S1 (%N4 pages)>)
>;IFN NICSW

	MOVX A,.FHSLF		;THIS FORK
	RUNTM%			;GET OUR RUNTIME
	ADDM A,RUNTIM		;GET TIME USED
	MOVX A,.USENT		;WRITE AN ENTRY
	MOVEI B,ACTLST		;POINT TO THE LIST
IFN ACCTSW,<
	USAGE			;DO IT
	 ERJMP ACTERR		;RATS
>;IFN ACCTSW
	RET			;DONE

ACTERR:	SETO A,			;TELL ORION WHAT WENT WRONG
	WTO (<Accounting Error>,<USAGE%% failed: %E1>)
	RET			;DONE

ACTLST:	USENT.	(.UTOUT,1,1,0)
	USTAD.	(-1)			;CURRENT DATE/TIME
	USPNM.	(<SIXBIT/LSRSPL/>,US%IMM) ;PROGRAM NAME
	USPVR.	(%LSR,US%IMM)		;PROGRAM VERSION
	USAMV.	(-1)			;ACCOUNTING MODULE VERSION
	USNOD.	(JOBINF+.EQROB+.ROBND)	;NODE NAME
	USSRT.	(RUNTIM)		;RUN TIME
	USSDR.	(0,US%IMM)		;DISK READS
	USSDW.	(0,US%IMM)		;DISK WRITES
	USJNM.	(JOBINF+.EQJOB)		;JOB NAME
	USQNM.	(<SIXBIT /LSR/>,US%IMM)	;QUEUE NAME
	USSDV.	(DEVNAM)		;DEVICE NAME
	USSSN.	(JOBINF+.EQRID)		;JOB SEQUENCE NUMBER
	USSUN.	(PAGCNT)		;TOTAL PAGES PRINTED
	USSNF.	(NFILES)		;TOTAL FILES PROCESSED
	USCRT.	(JOBINF+.EQAFT)		;CREATION DATE/TIME OF REQUEST
	USSCD.	(TIMNOW)		;SCHEDULED DATE/TIME
	USFRM.	(<SIXBIT /LETTER/>,US%IMM) ;FORMS TYPE
	USDSP.	(<SIXBIT/NORMAL/>,US%IMM)  ;DISPOSITION
	USPRI.	(JOBPRI)		;JOB PRIORITY
	USJNO.	(-1)			;JOB NUMBER
	USTRM.	(-1)			;TERMINAL DESIGNATOR
	USLNO.	(-1)			;TTY LINE NUMBER
	USTXT.	(<-1,,[ASCIZ / /]>)	;SYSTEM TEXT
	USNM2.	(<POINT 7,JOBINF+.EQOWN>) ;USER NAME
	USACT.	(<POINT 7,JOBINF+.EQACT>) ;ACCOUNT STRING POINTER
	0				;END OF LIST

	END
