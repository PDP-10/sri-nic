;SRC:<5-GALAXY>ORION.MAC.4, 23-Jul-86 13:20:29, Edit by KNIGHT
; Add NEWDFT
;SRC:<5-GALAXY>ORION.MAC.3, 22-Jul-86 10:17:21, Edit by KNIGHT
; Define WDAPNM
;SRC:<5-GALAXY>ORION.MAC.2, 21-Jul-86 15:21:52, Edit by KNIGHT
;CMU/CU lineprinter modifictions
	TITLE	ORION - DRIVER FOR THE OPERATOR INTERFACE PROGRAM
	SUBTTL	Preliminaries

;
;
;
ASCIZ /
         COPYRIGHT (C) DIGITAL EQUIPMENT CORPORATION
	 1975,1976,1977,1978,1979,1980,1981,1982,1983,1984
/
;     THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY  BE  USED
;     AND COPIED ONLY IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE
;     AND WITH THE INCLUSION OF THE ABOVE COPYRIGHT NOTICE.   THIS
;     SOFTWARE  OR ANY OTHER COPIES THEREOF MAY NOT BE PROVIDED OR
;     OTHERWISE MADE AVAILABLE TO ANY OTHER PERSON.  NO  TITLE  TO
;     AND OWNERSHIP OF THE SOFTWARE IS HEREBY TRANSFERRED.
;
;     THE INFORMATION  IN  THIS  SOFTWARE  IS  SUBJECT  TO  CHANGE
;     WITHOUT  NOTICE  AND SHOULD NOT BE CONSTRUED AS A COMMITMENT
;     BY DIGITAL EQUIPMENT CORPORATION.
;
;     DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE OR RELIABILITY
;     OF  ITS  SOFTWARE  ON  EQUIPMENT  WHICH  IS  NOT SUPPLIED BY
;     DIGITAL.


	SEARCH GLXMAC,ORNMAC,QSRMAC
	PROLOG(ORION)
	ERRSET				;SETUP ALL ERROR ROUTINES EXTERNAL
	PARSET				;PARSER ROUTINES

IFN	FTDN60,<
	.REQUIR	OPRCMD			;IF DN60 LOAD SYNTAX TABLES
> ;End FTDN60

	.OBSOP==1			;SYSTEM OPERATOR PRIVS

	EXTERNAL TABSRC			;TABLE SEARCH
	EXTERNAL ARGRTN			;SETUP ARGUMNET IN MESSAGE
	EXTERNAL BLDOBJ			;BUILD AN OBJECT
	EXTERNAL CMDEND			;FINISH COMMAND AND SEND TO QUASAR
	INTERNAL .JBVER			;AVAILABLE FOR OPRLOG
;	INTERNAL CHKWHL			;CHECK FOR WHEEL ROUTINE
	INTERNAL GETJOB			;GET JOB INFO
	INTERNAL SNDAOP			;SEND MESSAGE TO ALL OPRS

	ENTRY	OPRENB			;OPR ENABLED FOR NODE
	SUBTTL	Edit vector and Version numbers

ORNVEC:	BLDVEC	(GLXMAC,GMC,L)
	BLDVEC	(ORNMAC,OMC,L)
	BLDVEC	(QSRMAC,QMC,L)
	BLDVEC	(ORION,ORN,L)
	BLDVEC	(OPRPAR,PAR)
	BLDVEC	(OPRQSR,QSR)
	BLDVEC	(OPRLOG,LOG)
	BLDVEC	(OPRERR,ERR)
	BLDVEC	(OPRNET,NET)

	ORNMAN==:342			;Maintenance edit number
	ORNDEV==:372			;Development edit number
	VERSIN (ORN)			;Generate edit number

	ORNWHO==0
	ORNVER==5
	ORNMIN==0

	EXTERNAL PAREDT,QSREDT,LOGEDT,ERREDT,NETEDT
	ORNVRS==<VRSN.(ORN)>+GMCEDT+OMCEDT+QMCEDT+PAREDT+QSREDT+
		LOGEDT+ERREDT+NETEDT

	.JBVER==137

	LOC	.JBVER
	EXP	ORNVRS
	RELOC
	SUBTTL	Table of Contents


;		Table of Contents for ORION
;
;
;			   Section			      Page
;   1. Preliminaries. . . . . . . . . . . . . . . . . . . . .    1
;   2. Edit vector and Version numbers. . . . . . . . . . . .    2
;   3. Table of Contents. . . . . . . . . . . . . . . . . . .    3
;   4. Revision history . . . . . . . . . . . . . . . . . . .    4
;   5. Constants and declarations . . . . . . . . . . . . . .    5
;   6. Global Storage . . . . . . . . . . . . . . . . . . . .    6
;   7. Main Data Storage. . . . . . . . . . . . . . . . . . .    7
;   8. WTO storage. . . . . . . . . . . . . . . . . . . . . .    8
;   9. Interrupt vector definitions . . . . . . . . . . . . .    9
;  10. Initialization block . . . . . . . . . . . . . . . . .   10
;  11. ORION. . . . . . . . . . . . . . . . . . . . . . . . .   11
;  12. MAIN . . . . . . . . . . . . . . . . . . . . . . . . .   12
;  13. I$SYSV - Get system variables. . . . . . . . . . . . .   14
;  14. REQTIM . . . . . . . . . . . . . . . . . . . . . . . .   15
;  15. PROIPC . . . . . . . . . . . . . . . . . . . . . . . .   16
;  16. IPCCMS . . . . . . . . . . . . . . . . . . . . . . . .   17
;  17. GOPHMS . . . . . . . . . . . . . . . . . . . . . . . .   18
;  18. ORNINT . . . . . . . . . . . . . . . . . . . . . . . .   19
;  19. MSGCHK . . . . . . . . . . . . . . . . . . . . . . . .   20
;  20. RETMSG . . . . . . . . . . . . . . . . . . . . . . . .   21
;  21. OPRHEL . . . . . . . . . . . . . . . . . . . . . . . .   22
;  22. APLHEL . . . . . . . . . . . . . . . . . . . . . . . .   23
;  23. CHKNOD . . . . . . . . . . . . . . . . . . . . . . . .   24
;  24. GETNOD . . . . . . . . . . . . . . . . . . . . . . . .   25
;  25. OPRSET . . . . . . . . . . . . . . . . . . . . . . . .   26
;  26. SNDSET . . . . . . . . . . . . . . . . . . . . . . . .   27
;  27. TEXT . . . . . . . . . . . . . . . . . . . . . . . . .   28
;  28. SPGOUT . . . . . . . . . . . . . . . . . . . . . . . .   29
;  29. W$WTOR . . . . . . . . . . . . . . . . . . . . . . . .   30
;  30. W$KWTO . . . . . . . . . . . . . . . . . . . . . . . .   31
;  31. W$NODE . . . . . . . . . . . . . . . . . . . . . . . .   32
;  32. W$KMES . . . . . . . . . . . . . . . . . . . . . . . .   33
;  33. W$WTO. . . . . . . . . . . . . . . . . . . . . . . . .   34
;  34. W$CHEK . . . . . . . . . . . . . . . . . . . . . . . .   35
;  35. W$LOGM . . . . . . . . . . . . . . . . . . . . . . . .   36
;  36. W$VALID. . . . . . . . . . . . . . . . . . . . . . . .   37
;  37. WTOTXT, WTOTYP, WTOANS and WTOACD routines . . . . . .   38
;  38. WTOJOB,WTOERR,WTORTE and WTODES  routines. . . . . . .   39
;  39. WTOOBJ . . . . . . . . . . . . . . . . . . . . . . . .   40
;  40. WTOOCD . . . . . . . . . . . . . . . . . . . . . . . .   41
;  41. WTONOP . . . . . . . . . . . . . . . . . . . . . . . .   41
;  42. WTODTY . . . . . . . . . . . . . . . . . . . . . . . .   41
;  43. W$MTXT . . . . . . . . . . . . . . . . . . . . . . . .   42
;  44. W$CRLF . . . . . . . . . . . . . . . . . . . . . . . .   43
;  45. W$2TAB . . . . . . . . . . . . . . . . . . . . . . . .   43
;  46. OPRMSG . . . . . . . . . . . . . . . . . . . . . . . .   44
;  47. W$MESS . . . . . . . . . . . . . . . . . . . . . . . .   45
;  48. MSGFIN . . . . . . . . . . . . . . . . . . . . . . . .   46
;  49. W$JOBH . . . . . . . . . . . . . . . . . . . . . . . .   47
;  50. GETJOB/GETJBT. . . . . . . . . . . . . . . . . . . . .   48
;  51. GLOC . . . . . . . . . . . . . . . . . . . . . . . . .   49
;  52. GETUSR . . . . . . . . . . . . . . . . . . . . . . . .   50
;  53. GETNAM . . . . . . . . . . . . . . . . . . . . . . . .   51
;  54. W$SHOW . . . . . . . . . . . . . . . . . . . . . . . .   52
;  55. W$ASND . . . . . . . . . . . . . . . . . . . . . . . .   52
;  56. W$ACKM . . . . . . . . . . . . . . . . . . . . . . . .   53
;  57. TXTMOV . . . . . . . . . . . . . . . . . . . . . . . .   53
;  58. CMDMES . . . . . . . . . . . . . . . . . . . . . . . .   54
;  59. COMMAN . . . . . . . . . . . . . . . . . . . . . . . .   55
;  60. FNDAPL . . . . . . . . . . . . . . . . . . . . . . . .   56
;  61. Dispatch Table for Command Messages. . . . . . . . . .   57
;  62. TAKCMD . . . . . . . . . . . . . . . . . . . . . . . .   58
;  63. TAKEND . . . . . . . . . . . . . . . . . . . . . . . .   58
;  64. TAKABT . . . . . . . . . . . . . . . . . . . . . . . .   58
;  65. GETPAG . . . . . . . . . . . . . . . . . . . . . . . .   59
;  66. RELPAG . . . . . . . . . . . . . . . . . . . . . . . .   59
;  67. ERRALL . . . . . . . . . . . . . . . . . . . . . . . .   60
;  68. DISABLE/ENABLE commands. . . . . . . . . . . . . . . .   61
;  69. ENAODP . . . . . . . . . . . . . . . . . . . . . . . .   62
;  70. MAPBIT . . . . . . . . . . . . . . . . . . . . . . . .   63
;  71. ENALOG . . . . . . . . . . . . . . . . . . . . . . . .   65
;  72. CLSLOG . . . . . . . . . . . . . . . . . . . . . . . .   65
;  73. ENACLS . . . . . . . . . . . . . . . . . . . . . . . .   66
;  74. ENARET . . . . . . . . . . . . . . . . . . . . . . . .   67
;  75. NOTIFY . . . . . . . . . . . . . . . . . . . . . . . .   68
;  76. SEND . . . . . . . . . . . . . . . . . . . . . . . . .   69
;  77. SNDALL . . . . . . . . . . . . . . . . . . . . . . . .   70
;  78. DEFNOD . . . . . . . . . . . . . . . . . . . . . . . .   70
;  79. TTYNOD . . . . . . . . . . . . . . . . . . . . . . . .   71
;  80. SENDOP . . . . . . . . . . . . . . . . . . . . . . . .   72
;  81. BLDSND . . . . . . . . . . . . . . . . . . . . . . . .   73
;  82. BLDALL . . . . . . . . . . . . . . . . . . . . . . . .   73
;  83. SNDALX . . . . . . . . . . . . . . . . . . . . . . . .   74
;  84. SNDTTY . . . . . . . . . . . . . . . . . . . . . . . .   75
;  85. SHOW . . . . . . . . . . . . . . . . . . . . . . . . .   76
;  86. SHWOPR . . . . . . . . . . . . . . . . . . . . . . . .   77
;  87. SHWSCH . . . . . . . . . . . . . . . . . . . . . . . .   78
;  88. SHWMSG . . . . . . . . . . . . . . . . . . . . . . . .   79
;  89. FINSHW . . . . . . . . . . . . . . . . . . . . . . . .   79
;  90. MSGNOD . . . . . . . . . . . . . . . . . . . . . . . .   80
;  91. BLKDPY . . . . . . . . . . . . . . . . . . . . . . . .   80
;  92. GETMSG . . . . . . . . . . . . . . . . . . . . . . . .   81
;  93. FNDMSG . . . . . . . . . . . . . . . . . . . . . . . .   82
;  94. CHKMSG . . . . . . . . . . . . . . . . . . . . . . . .   83
;  95. NXTMSG . . . . . . . . . . . . . . . . . . . . . . . .   83
;  96. REPORT . . . . . . . . . . . . . . . . . . . . . . . .   84
;  97. CHKWTO . . . . . . . . . . . . . . . . . . . . . . . .   85
;  98. OPRLST . . . . . . . . . . . . . . . . . . . . . . . .   86
;  99. OPRDPY . . . . . . . . . . . . . . . . . . . . . . . .   87
; 100. RESPON . . . . . . . . . . . . . . . . . . . . . . . .   88
; 101. Operator privilege checking routines . . . . . . . . .   89
; 102. GETPRV . . . . . . . . . . . . . . . . . . . . . . . .   90
; 103. OPRENB . . . . . . . . . . . . . . . . . . . . . . . .   91
; 104. O$REMOTE/O$HOST/O$SYSTEM/CHKWHL Routs. to check privs.   92
; 105. TOPS20 Privilege checking routines . . . . . . . . . .   93
; 106. G$ACK. . . . . . . . . . . . . . . . . . . . . . . . .   94
; 107. BLDACK . . . . . . . . . . . . . . . . . . . . . . . .   95
; 108. ADDNOD . . . . . . . . . . . . . . . . . . . . . . . .   96
; 109. LOCNOD . . . . . . . . . . . . . . . . . . . . . . . .   97
; 110. DELNOD . . . . . . . . . . . . . . . . . . . . . . . .   98
; 111. NODONL . . . . . . . . . . . . . . . . . . . . . . . .   99
; 112. ADDOPR . . . . . . . . . . . . . . . . . . . . . . . .  100
; 113. EXPTAB . . . . . . . . . . . . . . . . . . . . . . . .  101
; 114. VALOPR . . . . . . . . . . . . . . . . . . . . . . . .  102
; 115. CHKOPR . . . . . . . . . . . . . . . . . . . . . . . .  102
; 116. DELOPR . . . . . . . . . . . . . . . . . . . . . . . .  103
; 117. SNDLST . . . . . . . . . . . . . . . . . . . . . . . .  104
; 118. RSDPID . . . . . . . . . . . . . . . . . . . . . . . .  105
; 119. MOVARG . . . . . . . . . . . . . . . . . . . . . . . .  106
; 120. MOVAR2 . . . . . . . . . . . . . . . . . . . . . . . .  106
; 121. SNDAOP . . . . . . . . . . . . . . . . . . . . . . . .  107
; 122. SNDOPR . . . . . . . . . . . . . . . . . . . . . . . .  108
; 123. CHKOSD . . . . . . . . . . . . . . . . . . . . . . . .  109
; 124. MOVBLK . . . . . . . . . . . . . . . . . . . . . . . .  110
; 125. REQMSG . . . . . . . . . . . . . . . . . . . . . . . .  111
; 126. RSDMSG . . . . . . . . . . . . . . . . . . . . . . . .  112
; 127. REQNST . . . . . . . . . . . . . . . . . . . . . . . .  113
; 128. ADDSFL . . . . . . . . . . . . . . . . . . . . . . . .  114
; 129. DELSPL . . . . . . . . . . . . . . . . . . . . . . . .  115
; 130. CHKSFL . . . . . . . . . . . . . . . . . . . . . . . .  115
; 131. CLRSFL . . . . . . . . . . . . . . . . . . . . . . . .  116
; 132. SNDQSR . . . . . . . . . . . . . . . . . . . . . . . .  117
; 133. SNDACT . . . . . . . . . . . . . . . . . . . . . . . .  117
; 134. SQSD60 . . . . . . . . . . . . . . . . . . . . . . . .  117
; 135. SNDMSG . . . . . . . . . . . . . . . . . . . . . . . .  118
; 136. SPDOPR . . . . . . . . . . . . . . . . . . . . . . . .  119
; 137. SNDPID . . . . . . . . . . . . . . . . . . . . . . . .  120
; 138. Interrupt Handler. . . . . . . . . . . . . . . . . . .  121
; 139. Default PDBs for OPRCMD. . . . . . . . . . . . . . . .  122
; 140. SETOUT . . . . . . . . . . . . . . . . . . . . . . . .  123
; 141. SNDOUT . . . . . . . . . . . . . . . . . . . . . . . .  123
; 142. OUTRTN . . . . . . . . . . . . . . . . . . . . . . . .  123
; 143. SETPTR . . . . . . . . . . . . . . . . . . . . . . . .  123
SUBTTL	Revision history

COMMENT \

342	4.2.1528	9-Nov-82
	Fix copyright.

*****  Release 4.2 -- begin maintenance edits  *****

*****  Release 5.0 -- begin development edits  *****

360	5.1003		30-Dec-82
	Move to new development area.  Add version vector.  Clean up
edit organization.  Update TOC.

361	5.1010		8-Feb-83
	Rearrange the channel table (CHNTAB).

362	5.1026		6-May-83
	Add support for QUEUE% JSYS.  Add support for new argument block
type .WTDTY for display type.  Add support for new ENABLE/DISABLE output
types.

363	5.1046		21-Oct-83
	Change version number from 4 to 5.

364	5.1071 		30-Jan-84
	Modify support for QUEUE% JSYS. Change way of determining if
	from QUEUE% by using function code .IPCCG

365	5.1080		5-Feb-84
	Add support for UNDEFINE STRUCTURE command with a dispatch entry
to routine Q$UNDE.

366	5.1092		13-Feb-84
	Make ORION a system process by setting IB.SYS in IB.

367	5.1099		16-Feb-84
	In GOPHMS, pick up job number from ACK word in QUEUE% message and
store in the corresponding MDB.

370	5.1111		1-Mar-84
	Add support for MOUNT STRUCTURE alias:/STRUCTURE-ID:structure name
command with a dispatch address to routine Q$MOUNT.

371	5.1152		12-July-84
	Add error message on SEND failure.

372	5.1155		16-Aug-84
	Add acknowledgement message after DISABLE/ENABLE OUTPUT BUGxxx.

\   ;End of Revision History
COMMENT \

THIS MODULE IS THE MAIN LOOP FOR ORION. IT RECEIVES ALL IPCF MESSAGES
AND DISPATCHES TO THE CORRECT PROCESSING ROUTINE. IT ALSO CONTAINS
ALL THE CODE TO INITIALIZE THE NEEDED GLX MODULES.

\

SUBTTL	Constants and declarations

	XP	PDLEN,^D200		;Size or our PDL

SUBTTL	Global Storage

	$DATA	PDL,PDLEN		;OUR PDL

	$DATA	G$STAD,0		;START OF DATA AREA
	$GDATA	G$HOST,1		;NODE NAME OF CENTRAL SITE
	$GDATA	G$HSTN,1		;NODE NUMBER OF CENTRAL SITE
	$GDATA	G$NOW,1			;CURRENT TIME OF DAY
	$GDATA	G$OPR,1			;T/F FOR OPR ON DUTY

	$GDATA	G$ERR,1			;ERROR CODE FOR ACK'ING THIS MESSAGE
	$GDATA	G$SEQ,1			;GLOBAL SEQUENCE NUMBER FOR
					;OPR DISPLAYS.
	$GDATA	G$FLAG,1		;SENDER'S FLAGS (FROM IPCF MESSAGE)
	$GDATA	G$SND,1			;SENDER'S PID
	$GDATA	G$PRVS,1		;SENDER'S PRIVS (FROM IPCF MESSAGE)
	$GDATA	G$SID,1			;SENDER'S ID
	$GDATA	G$JOB,1			;SENDER'S JOB NUMBER
	$GDATA	G$NODE,1		;SENDER'S NODE NAME (SIXBIT)
	$GDATA	G$NODX,2		;SENDER'S NODE NAME (ASCII)
	$GDATA	G$PRIV,1		;SENDER'S PRIVS

	$GDATA	G$NODL,1		;NODE LIST NUMBER
	$GDATA	G$OPRA,1		;OPR ADDRESS ORIGINATING REQUEST
	$GDATA	G$ASND,1		;FLAG TO FORCE SENDS OF MESSAGE
	$GDATA	G$JDAT,1		;BATCH-STREAM..WTO BITS
	$GDATA	G$OUTP,1		;OUTPUT MESSAGE PAGE FLAG

	$GDATA	G$ARG1,1		;ERROR ARGUMENT 1
	$GDATA	G$ARG2,1		;ERROR ARGUMENT 2
	$GDATA	G$ARG3,1		;ERROR ARGUMENT 3

	$GDATA	G$SNDF,1		;COUNT OF SEND FAILURES
	$GDATA	G$RSDL,1		;LIST NUMBER FOR RESEND ENTRIES
	$GDATA	G$NSNT,1		;COUNT OF MESSAGES NOT SENT YET
	$GDATA	G$SNDL,1		;LIST FOR MESSAGES NOT SENT YET
	$GDATA	G$RSDC,1		;NUMBER OF MESSAGES TO RESEND COUNT
	$GDATA	G$CHKM,1		;WTOR MESSAGE CHECK REQUESTED
	$GDATA	G$MSGC,1		;NUMBER OF THE MESSAGE BEING PROCESSED
	$GDATA	G$SFPD,1		;SEND FAILURE PID
	$GDATA	G$MJOB,1		;ORIONS JOB NUMBER
	$GDATA	G$MAXP,1		;MAXIMUM PACKET SIZE

TOPS20<
	$GDATA	G$NETL,1		;NETWORK SERVER LIST
>;END TOPS20

	$GDATA	G$2SCR,2		;2 WORD GENERIC SCRATCH SPACE
SUBTTL	Main Data Storage



;TEMPORARY STORAGE FOR TEXT MOVER

	$DATA	TXTPTR,1		;SAVE AREA FOR BYTE POINTER
	$DATA	PARBLK,PAR.SZ		;PARSER CALL BLOCK
	$DATA	PARBUF,1		;PARSER BUFFER POINTER
	$DATA	SNDBLK,SAB.SZ		;SEND BLOCK FOR MESSAGES
	$DATA	SNDPTR,1		;SEND ROUTINE POINTER
	$DATA	TABADR,1		;OPR DATA BASE ADDRESS
	$DATA	TABFRE,1		;OPR DATA BASE FREE COUNT
	$DATA	TABCNT,1		;OPR DATA BASE AVAILABLE COUNT

;BYTE POINTER AND COUNTER FOR COMMON TEXT STORAGE ROUTINE

	$DATA	STRBP,1			;BYTE POINTER WORD
	$DATA	STRCT,1			;BYTE COUNT WORD

TOPS10<
;PLACE FOR OPERATORS PPN
	$DATA	OPRPPN,1		;OPR PPN ON -10
	$DATA	FRCLIN,1		;LINE NUMBER OF 'FRCLIN'
	$DATA	SNDTXT,^D15		;TEXT BUFFER FOR 'SEND ALL' (72 CHR MAX)
>;END TOPS10

SUBTTL	WTO storage

	$DATA	WDATXT,1		;WTO TEXT DATA ADDRESS
	$DATA	WDAOBJ,1		;WTO OBJECT BLOCK ADDRESS
	$DATA	WDAOBT,1		;WTO OBJECT TYPE
	$DATA	WDADES,1		;WTO DESTINATION VALUE
	$DATA	WDAJOB,1		;WTO JOB NUMBER
	$DATA	WDAERR,1		;WTO ERROR CODE
	$DATA	WDARTE,1		;WTO ROUTE CODE
	$DATA	WDATYP,1		;WTO TYPE CODE
	$DATA	WDAANS,1		;WTO ANSWER BLOCK
	$DATA	WDAFLG,1		;WTO FLAG WORD
	$DATA	WDAACD,1		;WTO APPLICATION CODE BLOCK
	$DATA	WDADTY,1		;WTO display type
IFE NICSW,<
	WDAEND==WDADTY			;END OF WTO FIELDS
>;IFE NICSW
IFN NICSW,<
	$DATA	WDAPNM,1		;WTO PRINTER NAME
	WDAEND==WDAPNM			;END OF WTO FIELDS
>;IFN NICSW


	$DATA	WTOCNT,1		;COUNT OF OUTPUT BYTES IN MESSAG
	$DATA	WTOPTR,1		;OUTPUT BYTE POINTER
	$DATA	SRCPTR,1		;SOURCE POINTER
	$DATA	DESPTR,1		;DESTINATION POINTER
	$DATA	DESCNT,1		;DESTINATION COUNT
	$DATA	RSDCNT,1		;RESEND COUNT OF OPRS TO SEND TO
	$DATA	MSGCNT,1		;COUNT OF OPRS RECIEVING THIS MESSAGE
	$DATA	OPRRCT,1		;COUNT OF ENTRIES IN RESEND LIST
	$DATA	OPRRSL,1		;OPR RESEND LIST NUMBER
	$DATA	PAGFLG,1		;PAGE MESSAGE TO BE SENT
	$DATA	NOALTN,1		;NO ALTERNATE NODES ON SEND FLAG
	$DATA	SCRWRD,1		;SCRATCH WORD FOR EACH COMMAND

;JOB RELATED DATA FOR LOG AND DISPLAY

	$GDATA	JOBNUM,1		;JOB NUMBER
	$GDATA	JOBTTY,1		;JOB TERMINAL NUMBER
	$GDATA	JOBNOD,1		;Job's node
	$GDATA	JOBLIN,1		;Job's line
	$GDATA	JOBUSN,2		;JOB USER NAME
	$GDATA	JOBNAM,1		;JOB PROGRAM NAME
	$GDATA	JOBJLT,1		;JOB LOGGED IN TIME
	$GDATA	JOBID,1			;JOB NUMBER OR PPN

	$GDATA	JOBTER,1		;ITEXT ADDRESS FOR TERMINAL DATA
	$GDATA	JOBTXT,1		;ITEXT FOR JOB HEADER LINE

	$DATA	SFLADR,1		;ADDRESS OF SEND FAIL PIDS TABLE
	$DATA	SFLCNT,1		;NUMBER OF POSSIBLE ENTRIES IN TABLE
	$DATA	SFLFRE,1		;NUMBER OF FREE ENTRIES

;NSP DATA FOR LINKS

TOPS20<
	$DATA	LEV1PC,1		;PC FOR LEVEL 1 INTERRUPT
	$DATA	LEV2PC,1		;PC FOR LEVEL 2 INTERRUPT
	$DATA	LEV3PC,1		;PC FOR LEVEL 3 INTERRUPT
	$GDATA	TRMFRK,1		;FORK TERMINATION FLAG
	$GDATA	NSPCON,1		;CONNECT INTERRUPT FLAG -1..CONNECT
	$GDATA	NSPACT,1		;FLAG FOR NSP SETUP -1..ACTIVE
	$GDATA	NODNAM,2		;NODE NAME FOR CURRENT CONNECT
	$GDATA	SRVDAT,2		;STORAGE FOR SERVER DATA CHECK
	$GDATA	SRVTBL,SRV.SZ*NUMSRV	;ALLOCATE TABLE SPACE
	$GDATA	SRVACS,20		;BLOCK FOR THE ACS
	$DATA	NFYDIR,1		;NOTIFY DIRECTORY BLOCK
	$DATA	NFYSUB,1		;SUBJECT POINTER
	$DATA	NFYTXT,1		;TEXT POINTER
	$DATA	SCHBLK,10		;SCHEDULER DATA WORDS

>;END TOPS20

	$DATA	DATEND,0		;END OF THE DATA AREA

	DATASZ==G$STAD-DATEND		;SIZE OF THE DATA AREA

FNDXCT:	CAMN	P1,MSL.ID(S2)		;MATCH INSTRUCTION
NULTXT:: ITEXT	(<>)
SUBTTL	Interrupt vector definitions


TOPS20<

LEVTAB:: EXP	LEV1PC
	EXP	LEV2PC
	EXP	LEV3PC

;  Interrupt channel table

CHNTAB::
	BLOCK	6			; 0- 5 -- Reserved for SERVER links
	BLOCK	3			; 6- 8 -- Fixed interrupts, not used
	BLOCK	1			;    9 -- .ICPOV - PDL overflow;
					;	  Enabled by library
	BLOCK	5			;10-14 -- Fixed interrupts, not used
	BLOCK	1			;   15 -- .ICILI - illegal instruction
					;	  Enabled by library
	BLOCK	1			;   16 -- .ICIRD - illegal memory read
					;	  Enabled by library
	BLOCK	1			;   17 -- .ICIWR - illegal memory write
					;	  Enabled by library
	BLOCK	1			;   18 -- Reserved for DEC
	BLOCK	1			;   19 -- .ICIFT - inferior fork term.
					;	  May be set to support DN200
	BLOCK	3			;20-22 -- Fixed interrupts, not used
	XWD	IPCLEV,INT		;   23 -- Set for IPCF interrupts
	BLOCK	^D12			;24-35 -- Not currently used
>;END TOPS20

TOPS10<
INTVEC:
IPCINT:	$BUILD	.PSVIS+1
	$SET(.PSVNP,,INT)
	$EOB
>;END TOPS10

SUBTTL	Initialization block

IPBBLK:	$BUILD	IB.SZ
	$SET(IB.FLG,IP.STP,1)		;SET FOR STOPCODES TO CATCH ANY CRASHES
	$SET(IB.FLG,IB.SYS,1)		;Set system process
	$SET(IB.PRG,,%%.MOD)		;PROGRAM NAME
IFN	FTDN60,<
	$SET(IB.OUT,,OUTRTN)		;NO DEFAULT SETUP
>;END FTDN60
IFE	FTDN60,<
	$SET(IB.OUT,,.RETT)		;NULL OUTPUT ROUTINE
>;END FTDN60
TOPS20<
	$SET(IB.INT,,<LEVTAB,,CHNTAB>)
>;END TOPS20
TOPS10<
	$SET(IB.INT,,INTVEC)
>;END TOPS10
	$SET(IB.PIB,,PIBBLK)		;ADDRESS OF PID BLOCK
	$EOB


PIBBLK:	$BUILD	PB.MXS			;SIZE OF BLOCK
	$SET(PB.HDR,PB.LEN,PB.MXS)	;MAXIMUM SIZE OF BLOCK
	$SET(PB.SYS,IP.MNP,^D10)	;ALLOW FOR 10. PIDS
	$SET(PB.SYS,IP.BQT,-1)		;SEND AND RECEIVE TO MAX.
	$SET(PB.FLG,IP.RSE,1)		;RETURN ON SEND ERRORS
	$SET(PB.FLG,IP.PSI,1)		;CONNECT PID TO PSI
	$SET(PB.FLG,IP.SPB,1)		;SET IF IPCF SENDER WAS PRIVILEGED
	$SET(PB.FLG,IP.JWP,1)		;GET JOB WIDE PID
	$SET(PB.INT,IP.SPI,SP.OPR)	;SYSTEM ORION
TOPS10<	$SET(PB.INT,IP.CHN,<IPCINT-INTVEC>)> ;OFFSET FOR IPCF BLOCK
TOPS20<	$SET(PB.INT,IP.CHN,^D23)>	;CHANNEL FOR IPCF
	$SET(PB.LOC,,<-1,,G$NODX>)	;SPACE FOR LOCATION STRING
	$EOB


;DEFINE THE OBJECT BLOCK

	DEFINE	X(A,B),<$SET(.OT'B,,.ZZ)
		.ZZ==.ZZ+1>

OBJBLK:	$BUILD	.OTMAX+1		;MAXIMUM NUMBER OF OBJECTS
	.ZZ==1				;SETUP ENTRIES
	OBJORN				;EXPAND ENTRIES
	$EOB				;END OF BLOCK

SUBTTL	ORION	Main entry and initialization

ORION:	RESET				;RESET THE WORLD
	MOVE	P,[IOWD PDLEN,PDL]	;SET UP STACK POINTER
	MOVX	S1,IB.SZ		;GET THE SIZE OF THE IPB
	MOVEI	S2,IPBBLK		;GET ADDRESS OF THE IPB
	$CALL	I%INIT##		;INITIALIZE THE IPCF INTERFACE
	MOVEI	S1,DATASZ		;SIZE OF THE DATA BASE
	MOVEI	S2,G$STAD		;START OF DATA BASE
	$CALL	.ZCHNK			;ZERO THE DATA BASE
	$CALL	I%NOW			;GO GET THE DATE/TIME
	MOVEM	S1,G$NOW		;SAVE AS THE CURRENT TIME
	SETZM	G$SEQ			;CLEAR GLOBAL SEQUENCE NUMBER
	$CALL	L%CLST			;CREATE NODE LIST
	MOVEM	S1,G$NODL		;SAVE THE NUMBER
	$CALL	L%CLST			;CREATE A LIST
	MOVEM	S1,G$RSDL		;SAVE AS RESEND LIST
	$CALL	L%CLST			;CREATE A LIST
	MOVEM	S1,G$SNDL		;SAVE AS UNSENT LIST
	$CALL	L$INIT##		;INIT LOG ROUTINE
	SKIPE	LOGINT##		;LOGGING ENABLED?
	$CALL	L$OPNL##		;OPEN ORIONS LOG FILE
	$CALL	EXPTAB			;SETUP OPR TABLE AND OPR RESEND TABLE
	$CALL	I%ION			;LIBRARY TURN ON INTERRUPTS
	$CALL	ORNINT			;SETUP ORION NEEDED DATA
IFN NICSW,<
	$CALL	P%LPIN##		;BUILD THE PRINTER LIST
>;IFN NICSW
	JRST	MAIN			;NOW GO ENTER MAIN LOOP
SUBTTL	MAIN	IPCF message processing loop

;THIS ROUTINE RECEIVES THE NEXT IPCF MESSAGE FROM THE QUEUE WHEN IT IS
;AVAILABLE, CHECKS ITS FORMAT, AND DISPATCHS ON ITS TYPE

MAIN:	$CALL	I$SYSV			;GET SYSTEM VARIABLES
	$CALL	C%RECV			;CHECK FOR MESSAGE
	JUMPT	MAIN.0			;IF A MESSAGE, PROCESS IT
TOPS20<
	SKIPE	NSPCON			;DID WE GET A CONNECT
	$CALL	N$CONN##		;PROCESS THE CONNECT
	SKIPE	TRMFRK			;FORK TERMINATIONS?
	$CALL	N$TERM##		;TERMINATE FORK AND LINKS
>;END TOPS20
	MOVEI	S1,0			;SLEEP UNTIL SOMETHING TO DO
	$CALL	I%SLP			;SLEEP AND/OR PROCESS TIMERS
	JRST 	MAIN			;GO TO MAIN

;  Here when there is a message

MAIN.0:	SETZM	G$ERR			;CLEAR ERROR FLAG
	MOVE	P1,S1			;COPY MDB ADDR TO P1
	LOAD	MI,MDB.MS(P1),MD.ADR	;GET MESSAGE ADDRESS
	MOVE	S1,MDB.SP(P1)		;GET THE PID
	MOVEM	S1,G$SND		;SAVE THE PID
	LOAD	S1,MDB.FG(P1),IP.CFC	;GET SYSTEM SENDER WORD

;  Determine where the message is from

	JUMPE	S1,MAIN.1		;FROM A GALAXY COMPONENT
	CAIE	S1,.IPCCC		;FROM [SYSTEM]INFO
	JRST	[			
		CAIE  S1,.IPCCG	           ;FROM [SYSTEM]GOPHER?
		JRST  MAIN.2		   ;NO, SOME KIND OF ERROR
		MOVE  S2,P1                ;SAVE ADDRESS OF MDB FOR LATER USE
		$CALL GOPHMS		   ;GO PROCESS
		JUMPF MAIN.2		   ;ERROR, GO CLEAN UP
		JRST  MAIN.1		   ;CONVERTED, CONTINUE PROCESSING
		]
	LOAD	S1,MDB.FG(P1),IP.CFE	;LOAD ERROR CODE
	SKIPE	S1			;ERROR CODE PRESENT?
	JRST	MAIN.2			;YES, PITCH MESSAGE
	$CALL	IPCCMS			;PROCESS SYSTEM MESSAGE
	JRST	MAIN.2			;GO TO FINISH
MAIN.1:	LOAD	S1,MDB.FG(P1),IP.CFM	;LOOK AT PACKET HEADER
	CAXN	S1,.IPCFN		;IS IS A RETURNED MESSAGE?
	JRST	MAIN.3			;CHECK FOR OPR AND THEN PITCH
	MOVE	S2,P1			;AIM AT THE MDB
	$CALL	PROIPC			;CALL DISPATCH AND CHECKING AS SUBROUTINE
	MOVE	S1,.MSFLG(MI)		;GET MESSAGE FLAGS
	MOVEM	S1,G$FLAG		;SAVE THE MESSAGE FLAGS
	LOAD	S1,G$FLAG,MF.ACK	;ACK REQUESTED?
	SKIPN	S1			;SKIP IF REQUESTED
;  Here to clean up

MAIN.2:	SKIPE	G$ERR			;ALWAYS SEND ACK ON ERROR
	$CALL	G$ACK			;ACKNOWLEDGE THE MESSAGE
	SKIPE	G$ERR			;WAS THERE AN ERROR
	$CALL	L$ERR##			;LOG THE ERROR
	$CALL	C%REL			;RELEASE THE MESSAGE
	JRST	MAIN			;AND LOOK FOR MORE MESSAGES

;Here on a returned message

MAIN.3:	MOVE	S1,MDB.SP(P1)		;GET THE SENDERS PID
	$CALL	VALOPR			;CHECK IS IT WAS AN OPR
	JUMPF	MAIN.2			;RELEASE IT AND CONTINUE ON
	MOVE	S1,MDB.SP(P1)		;GET THE SENDERS PID
	$CALL	DELOPR			;DELETE THE OPR
	JRST	MAIN.2			;CONTINUE ON
	SUBTTL	I$SYSV - Get system variables

;This routine fetchs the system variables that may be changing.
;Currently there are:
;	G$NOW/		current UDT
;	G$OPR/		true/false for operator on duty
;(routine name and most code borrowed from I$SYSV in QSRTxx)

I$SYSV:	$CALL	I%NOW			;GET CURRENT TIME
	MOVEM	S1,G$NOW		;SAVE FOR THE WORLD TO KNOW
TOPS10 <
	SETOM	G$OPR			;ASSUME OPERATOR ON DUTY
	MOVX	S1,%CNSTS		;GETTAB ARGS
	GETTAB	S1,			;GET THE MONITOR'S STATES WORD
	  SETZ	S1,			;SICK MONITOR
	TXNE	S1,ST%NOP		;CHECK
	SETZM	G$OPR			;NO OPERATOR ON DUTY
>
TOPS20 <
	SETOM	G$OPR			;ASSUME OPERATOR ON DUTY
	MOVX	S1,.SFOPR		;GET FUNCTION CODE
	TMON				;ASK MONITOR FOR OPR IN ATTENDANCE
	SKIPN	S2			;ANYONE AROUND ???
	SETZM	G$OPR			;NO
>
	$RET				;AND RETURN
SUBTTL	REQTIM	Routine to put a request on the event queue

;ACCEPTS	S1/ UDT or 0,,Milliseconds
;		S2/ PC of routine to be called

;The routine will be called at the appropriate time from I%SLP


REQTIM::STKVAR <<TIMBLK,.TIMPC+1>>	;Get request block
	MOVEM	S1,.TITIM+TIMBLK	;Save request time
	MOVEM	S2,.TIMPC+TIMBLK	;Save the event PC
	MOVEI	S2,.TIMEL		;Assume elapsed time
	TLNE	S1,700000		;Unless date is present
	MOVEI	S2,.TIMDT		;Request UDT
	MOVEM	S2,.TIFNC+TIMBLK	;Save the function
	SETZM	.TIPSI+TIMBLK		;Clear PSI word
	MOVEI	S1,.TIMPC+1		;Get length of request
	MOVEI	S2,TIMBLK		;Get address of block
	$CALL	I%TIMR			;Place on the timer queue
	$RET				;Return true/false per timer

SUBTTL	PROIPC	Process an IPCF message

;CALL -
;	S2/	MDB ADDRS
;	MI/	INCOMING MESSAGE ADRS

PROIPC:	$SAVE	<P1>			;PRSERVE SOME SPACE
	MOVE	P1,S2			;COPY THE MDB POINTER
	AOS	G$MSGC			;BUMP COUNT OF MESSAGES
	SETZM	G$OPRA			;CLEAR OPERATOR ADDRESS WORD
	SETZM	G$ASND			;ALWAYS SEND FLAG OFF
	LOAD	S1,MDB.PV(P1)		;GET THE SENDER'S PRIVS
	STORE	S1,G$PRVS		;SAVE FOR ALL
	LOAD	S1,S1,MD.PJB		;GET THE JOB NUMBER
	STORE	S1,G$JOB		;SAVE FOR ALL
	MOVEI	S2,JI.TLC		;GET PHYSICAL LOCATION
	$CALL	I%JINF
	MOVEM	S2,G$NODE		;SAVE FOR ALL TO SEE
	LOAD	S1,MDB.SD(P1)		;GET SENDER'S ID
	STORE	S1,G$SID		;SAVE FOR ANYONE
	SKIPN	G$SND			;CHECK FOR ZERO PID
	  PJRST  E$IPS			;INVALID PID SPECIFIED
	LOAD	S1,.MSTYP(MI),MS.CNT	;GET THE LENGTH FROM THE HEADER
	LOAD	S2,MDB.MS(P1),MD.CNT	;AND FROM THE MDB
	CAMLE	S1,S2			;SENDER'S LENGTH BETTER BE CORRECT
	JRST	E$BML			;BAD MESSAGE LENGTH
	LOAD	T1,.MSTYP(MI),MS.TYP	;GET MESSAGE TYPE
	MOVEM	T1,G$ARG1		;SAVE MESSAGE TYPE
	CAIG	T1,.OMOFF		;VALID ORION MESSAGE
	JRST	PROI.2			;CHECK QUASAR MESSAGES
	CAIN	T1,.OMCMD		;IS IT A COMMAND
	JRST	PROI.1			;BYPASS MSGCHK AND CONTINUE
	MOVE	S2,P1			;COPY OVER THE MDB POINTER
	$CALL	MSGCHK			;CONSISTENCY CHECK THE MESSAGE
	$RETIF				;BAD RETURN..RETURN
PROI.1:	LOAD	S1,.MSTYP(MI),MS.TYP	;GET THE MESSAGE TYPE
	MOVEI	S2,MANTAB		;ENABLE DISPATCH TABLE
	$CALL	TABSRC			;SEARCH THE TABLE
	JUMPF	E$IMT			;ERROR..IGNORE THE MESSAGE
	PUSHJ	P,(S2)			;Process the routine
	$RET				;Return, preserving the return
PROI.2:	CAIE	T1,.QONWA		;NODE WENT AWAY
	$RETF				;RETURN FALSE
	PJRST	DELNOD			;DELETE NODE ROUTINE

MANTAB:	$STAB
	.OMWTO,,W$WTO			;WRITE TO OPERATOR
	.OMCMD,,COMMAN			;COMMAND MESSAGE(FROM OPR PARSER PROGRAM)
	.OMWTR,,W$WTOR			;WTOR FOR NOW
	.OMACK,,W$ACKM			;WTO FOR NOW
	.OMACS,,W$SHOW			;SHOW ACK RESPONSE FROM QUASAR
	.OMOHL,,OPRHEL			;OPR HELLO MESSAGE
	.OMOSR,,OPRSET			;OPR SETUP REPLY
	.OMAHL,,APLHEL			;APPLICATION HELLO MESSAGE
	.OMLOG,,W$LOGM			;LOG MESSAGE
	.OMNFY,,NOTIFY			;NOTIFY CODE
	.OMTKE,,TAKEND			;END OF TAKE COMMAND
IFN	FTDN60,<
	.OMD60,,CMDMES			;COMMAND MESSAGE FROM CDRIVE
>;END FTDN60
	.OMDSP,,RETMES			;RETURNED DN60 DISPLAY MESSAGE
IFN NICSW,<
	.OMDFT,,NEWDFT			;REBUILD PRINTER LISTS
>;IFN NICSW
	$ETAB
SUBTTL	IPCCMS	Process messages from [SYSTEM]IPCC

;CALL -
;	MI/	INCOMING MESSAGE FROM IPCC

	SYSPRM	LOGMSK,RHMASK,RHMASK	;MASK TO GET JOB NUMBER
	SYSPRM	OB.BSN,OB.BSN,OB%BSN	;BATCH STREAM NUMBER FIELD

IPCCMS:	LOAD	S1,LGO.HD(MI),LOGMSK	;GET FUNCTION CODE
	CAIN	S1,.IPCSL		;LOGOUT MESSAGE
	JRST	IPCC.0			;YES, HANDLE IT
	$RET				;NO, FLUSH IT

;HERE ON A LOGOUT MESSAGE
IPCC.0:	$SAVE	<P1,P2,P3>
	LOAD	S1,LGO.JB(MI),LG.JOB	;GET THE JOB NUMBER
	STORE	S1,G$PRVS,MD.PJB	;SAVE THE JOB NUMBER
	STORE	S1,G$JOB		;DITTO
	MOVX	S2,MSL.JB		;MATCH ON JOB NUMBER
	HRRM	S2,FNDXCT		;SAVE IN COMPARE
	$CALL	FNDMSG			;FIND THE MESSAGE
	JUMPF	IPCC.2			;NONE..TRY ANY OPRS TO DELETE
IPCC.1:	SETZ	P1,			;CLEAR P1 FOR SCRATCH
	EXCH	P1,G$ERR		;SAVE ERROR CODE
	MOVX	S1,E$JLO		;JOB LOGGED OUT
	$CALL	W$KMES			;KILL THE MESSAGE
	$CALL	L$KMJB##		;LOG THE MESSAGE
	MOVEM	P1,G$ERR		;RESTORE THE ERROR CODE
	LOAD	S1,G$JOB		;GET JOB NUMBER
	$CALL	NXTMSG			;GET THE NEXT MESSAGE
	JUMPT	IPCC.1			;KILL OTHER MESSAGES ALSO
IPCC.2:	LOAD	P3,G$JOB		;GET JOB NUMBER
	MOVE	P1,TABADR		;GET THE TABLE ADDRESS
	MOVE	P2,TABCNT		;MAXIMUM NUMBER OF ENTRIES
	SUB	P2,TABFRE		;GET ACTIVE OPRS
	SKIPN	P2			;ANY OPRS RUNNING?
	$RET				;NONE SETUP SO FAR..RETURN
IPCC.3:	SKIPN	T2,TOP.OA(P1)		;GET OPR ENTRY ADDRESS
	JRST 	IPCC.5			;ZERO..TRY NEXT ONE
	CAME	P3,OPR.JB(T2)		;CHECK JOB FOR MATCH
	JRST	IPCC.4			;MATCH..SETUP FOR RETURN
	MOVE	S1,OPR.PD(T2)		;GET THE PID
	$CALL	DELOPR			;DELETE THE OPR
IPCC.4:	ADDI	P1,TOP.SZ		;BUMP TO NEXT ENTRY
	SOJG	P2,IPCC.3		;LOOP THROUGH ALL ENTRIES
	$RET				;NO SUCH OPR, ALL DONE WITH LOGOUT
IPCC.5:	ADDI	P1,TOP.SZ		;BUMP TO NEXT ENTRY
	JRST	IPCC.3			;TRY NEXT ONE
SUBTTL	GOPHMS	Process messages from [SYSTEM]GOPHER

;CALL -
;	MI/	INCOMING MESSAGE FROM THE GOPHER
;	S2/	MDB ADRS
;RETURNS -
;	TRUE/	MESSAGE PROCESSED - continue processing converted message
;	FALSE/	THE MESSAGE WAS BAD

GOPHMS:	LOAD	S1,.MSCOD(MI),MD.PJB	;GET THE JOB NUMBER
	STORE	S1,MDB.PV(S2),MD.PJB	;STORE JOB NUMBER IN THE MDB
	LOAD	S1,.MSTYP(MI),MS.TYP	;GET THE FUNCTION TYPE
	CAIN	S1,.QUWTO		;WRITE TO OPERATOR?
	JRST	[
		MOVX  S1,.OMWTO		   ;YES, CONVERT
		JRST  GOPHM1
		]
	CAIE	S1,.QUWTR		;WRITE TO OPERATOR WITH REPLY?
	PJRST	E$IFC##			;NO, AN ERROR
	MOVX	S1,.OMWTR		;YES, CONVERT
GOPHM1:	STORE	S1,.MSTYP(MI),MS.TYP	;STORE THE CONVERTED FUNCTION TYPE
	$SAVE	<P1,P2>
	$CALL	MSGCHK			;MAKE SURE THE MESSAGE LOOKS REASONABLE
	$RETIF				;IT DOESN'T, QUIT
	MOVEI	S1,.OHDRS(MI)		;AIM AT THE START OF THE BLOCKS
	$CALL	P$SETU##		;START THE BLOCK GETTER
	SKIPG	P1,.OARGC(MI)		;GET THE ARGUMENT BLOCK COUNT
	PJRST	E$ICS##			;NO GOOD, QUIT
GOPH.1:	$CALL	P$NARG##		;GET THE NEXT ARGUMENT BLOCK ADRS
	MOVSI	P2,-GOPHLN		;# OF ENTRIES TO  CHECK
	LOAD	S1,ARG.HD(S2),AR.TYP	;GET THIS BLOCK TYPE
GOPH.2:	HLRZ	TF,GOPHMP(P2)		;GET THIS CODE
	CAIE	TF,0(S1)		;IS THIS THE RIGHT BLOCK TYPE?
	AOBJN	P2,GOPH.2		;NO, TRY THE NEXT TYPE
	JUMPGE	P2,E$IFC##		;NO MATCH, GIVE UP
	HRRZ	TF,GOPHMP(P2)		;GET OUR BLOCK TYPE
	STORE	TF,ARG.HD(S2),AR.TYP	;CONVERT TO OUR TYPE
	$CALL	P$NEXT##		;STEP TO THE NEXT BLOCK
	SOJG	P1,GOPH.1		;CONVERT EACH BLOCK
	$RETT				;INDICATE MORE PROCESSING REQUIRED

;Conversion table for mapping user argument block types
; Into 'old' style WTO blocks

GOPHMP:	XWD	.QBNOD,.WTDES		;NODE BLOCK -- DESTINATION NODE
	XWD	.QBTYP,.WTTYP		;TYPE BLOCK -- MAP IT!
	XWD	.QBMSG,.WTTXT		;MESSAGE BLOCK -- MAKE IT A TEXT BLOCK
	XWD	.QBDTY,.WTDTY		;Display type
	GOPHLN==.-GOPHMP		;NUMBER OF ENTRIES
SUBTTL	ORNINT	Initialization routines

;THIS ROUTINE WILL GET THE REQUIRED MONITOR INFORMATION NEEDED
;BY ORION FOR PROCESSING.

ORNINT:	$CALL	I%HOST			;GET HOST NAME/NUMBER
	MOVEM	S1,G$HOST		;SAVE THE HOST NAME IN SIXBIT.
	MOVEM	S2,G$HSTN		;SAVE THE HOST NUMBER
	$CALL	C%MAXP			;GET MAXIMUM PACKET SIZE
	MOVEM	S1,G$MAXP		;SAVE MAXIMUM PACKET SIZE

TOPS10<
;FIND THE OPERATOR PPN
	MOVX	S1,%LDFFA		;GETTABB THE FAILSAFE PPN
	GETTAB	S1,			;...
	  $STOP(CFO,Cannot GETTAB operator PPN)
	MOVEM	S1,OPRPPN		;SAVE FOR LATER
	MOVX	S1,%CNFLN		;Gettab the FRCLIN line number
	GETTAB	S1,			;...
	  $STOP	(CGF,Cannot GETTAB FRCLIN line number)
	ADDI	S1,.UXTRM		;Make it a UDX
	MOVEM	S1,FRCLIN		;Store it
>;END TOPS10

	MOVE	S1,G$HOST		;NODE OF CENTRAL SITE
	$CALL	CHKNOD			;CHECK THE NODE
	JUMPT	ORNI.1			;ADD THE NODE
	MOVE	S1,G$HOST		;GET THE CENTRAL SITE
	SETZ	S2,			;ZERO THE NODE NUMBER
ORNI.1:	$CALL	ADDNOD			;SETUP THE NODE
	MOVX	T1,ND.SYS		;MARK AS SYSTEM OPERATOR
	IORM	T1,NOD.FL(S1)		;S1 ADDRESS OF NODE LIST ENTRY
	SETOM	S1			;SET FOR MY JOB
	MOVX	S2,JI.JNO		;GET MY JOB NUMBER
	$CALL	I%JINF			;GET THE JOB INFO
	MOVEM	S2,G$MJOB		;SAVE MY JOB NUMBER
TOPS20<
	SKIPN	DEBUGW			;ARE WE DEBUGGING?
	$CALL	N$INIT##		;NO..SETUP THE NSP SRV IF CAN
	SKIPE	S1,G$MJOB		;ARE WE RUNNING UNDER JOB 0
	$RETT				;NO..JUST RETURN
	SETZB	T3,T4			;CLEAR T3 AND T4
	MOVE	T1,[POINT 6,G$HOST]	;GET THE LOCATION
	MOVE	T2,[POINT 7,T3]		;PLACE TO STORE STRING
	MOVEI	P1,6			;MAXIMUM LENGTH
ORNI.2:	ILDB	S2,T1			;GET A BYTE
	JUMPE	S2,ORNI.3		;O.K. SET THE LOCATION
	ADDI	S2,40			;CONVERT TO ASCII CHARACTER
	IDPB	S2,T2			;SAVE THE BYTE
	SOJG	P1,ORNI.2		;CHECK NUMBER OF CHARACTERS
ORNI.3:	MOVX	S2,.SJLLO		;SETUP LOCATION
	HRROI	T1,T3			;GET STRING
	SETJB				;SET IT UP
	ERJMP	.+1			;IGNORE ERROR FOR NOW
>;END TOPS20
	$RET				;RETURN
SUBTTL	MSGCHK	Message length and header validation

;THIS ROUTINE WILL CHECK OUT THE LENGTH AND HEADER INFO FOR
;THE MESSAGE AND ALL ARGUMNET BLOCKS SPECIFIED
;CALL -
;	S2/	MDB ADRS
;	MI/	ADRS OF INCOMING MESSAGE

MSGCHK:	$SAVE	<P1>
	MOVE	P1,S2			;COPY THE MDB ADRS OVER
	LOAD	S2,MDB.MS(P1),MD.CNT	;GET THE SIZE OF THE MESSAGE
	MOVE	T1,MI			;SAVE START ADDRESS IN T1
	ADDI	T1,(S2)			;COMPUTE ENDING ADDRESS OF MESSAGE
	LOAD	T2,.MSTYP(MI),MS.CNT	;GET THE COUNT FROM MESSAGE
	ADDI	T2,(MI)			;COMPUTE LENGTH OF MESSAGE
	CAMLE	T2,T1			;WITHIN ACTUAL LIMITS
	PJRST	E$MTS			;MESSAGE TO SHORT
	MOVEI	S1,.OHDRS(MI)		;GET ADDRESS OF FIRST ARGUMENT
	CAMLE	S1,T1			;LENGTH WITHIN BOUNDS
	PJRST	E$MTS			;MESSAGE TO SHORT
	SKIPN	T2,.OARGC(MI)		;ANY ARGUMENTS IN MESSAGE
	JRST	MSGC.3			;YES..CHECK THEM OUT
MSGC.1:	SKIPG	T2			;VALID COUNT FIELD
	PJRST	E$ICS			;INVALID COUNT SPECIFIED
	SKIPA				;SKIP OVER INCREMENT FIRST TIME
MSGC.2:	ADDI	S1,1			;POINT TO NEXT HEADER
	MOVEI	T3,ARG.HD(S1)		;ADDRESS OF ARGUMENT HEADER
	CAMLE	T3,T1			;ADDRESS IN MESSAGE
	PJRST	E$BML			;BAD MESSAGE LENGTH SPECIFIED
	LOAD	S2,ARG.HD(S1),AR.LEN	;GET THE LENGTH
	SKIPG	S2			;MAKE SURE POSITIVE
	PJRST	E$IAL			;INVALID ARGUMENT LENGTH
	ADDI	S1,-1(S2)		;COMPUTE ADDRESS OF NEXT ARGUMENT
	CAMLE	S1,T1			;STILL WITHIN BOUNDS
	JRST	E$BML			;BAD MESSAGE LENGTH
	SOJG	T2,MSGC.2		;PROCESS ALL ARGUMENTS
MSGC.3:	SUBI	S1,1			;DECREMENT BY 1
	CAMLE	S1,T1			;SHOULD BE EXACT OR LESS
	JRST	E$BML			;BAD MESSAGE LENGTH
	$RETT				;RETURN TRUE


IFN NICSW,<
	SUBTTL	NEWDFT	Rebuild the printer lists

NEWDFT:	$CALL	P%LPOU##		;Clear out the previous list
	$CALL	P%LPIN##		;Rebuild the list
	$RETT				;And return true
>;IFN NICSW
SUBTTL	RETMSG	Returned DN60 message display

;This routine will resend the Display message that was sent to
;Quasar to the Central Site Operator

RETMES:	$CALL	SPGOUT			;SETUP PAGE FOR OUTPUT
	MOVE	S1,G$HOST		;GET CENTRAL SITE NODE ENTRY
	$CALL	FNDNOD			;FIND THE NODE
	JUMPT	SNDAOP			;SEND TO ALL OPERATOR AND RETURN
	JRST	S..CNE			;NO CENTRAL SITE NODE
SUBTTL	OPRHEL	Hello message from OPR

;THIS MESSAGE IS SENT BY OPR TO SIGNON TO ORION
;IF SUCCESSFUL ORION WILL CREATE THE APPROPRIATE NODE AND
;OPR ENTRIES AND SEND A SETUP TO THE OPR OF THE CURRENT
;RUNTIME VALUES.

OPRHEL:	SKIPG	T2,.OARGC(MI)		;VALID ARGUMENT COUNT
	PJRST	E$ICS			;INVALID COUNT SPECIFIED
	LOAD	T1,.OHDRS+ARG.HD(MI),AR.TYP ;GET THE TYPE
	CAIE	T1,.OPHEL		;HELLO BLOCK?
	PJRST	E$ITM			;INVALID TYPE IN MESSAGE
	SOJG	T2,E$ICS		;INVALID ARGUMENT COUNT
	LOAD	S1,.OHDRS+OPH.OV(MI)	;GET ORNMAC VERSION NUMBER
;	CAIE	S1,%%.OPR		;SAVE VERSION
;	PJRST	E$WVN			;WRONG VERSION NUMBER ERROR..
	$CALL	GETPRV			;AND GET THIS OPR'S PRIVILEGES
	JUMPF	E$IPE			;NONE!, GIVE 'EM THE GONG!
	MOVE	P3,S1			;SAVE THE PRIVS
TOPS10<
	CAXE	P3,OP.HST		;HOST OPR?
	CAXN	P3,OP.SYS		;SYSTEM OPR?
	SKIPA	S1,G$HOST		;YES, THEY LIVE AT CENTRAL!
>;END TOPS10
	$CALL	GETNOD			;FIND OUT WHERE THIS OPR LIVES
	JUMPF	E$CLO			;Can't?  Can't locate operator
	MOVEM	S1,G$ARG1		;Save node name for any errors ahead
	TXNE	P3,OP.REM		;Are we remote and
	CAME	S1,G$HOST		;  connected to the host?
	SKIPA				;No
	PJRST	E$IPE			;Yes, bad combination...
	$CALL	CHKNOD			;MAKE SURE IT'S FOR REAL!
	JUMPF	E$ION			;IT'S A PHONY!
	DMOVE	P1,S1			;SAVE NAME AND NUMBER
	DMOVE	S1,P1			;RESTORE NODE VALUES
	MOVE	T1,P3			;AND GET BACK OPR CAPABILITY BITS
	$CALL	ADDOPR			;ADD OPR TO DATA BASE
	JUMPF	E$OPD			;OPR PID ALREADY DEFINED
	PJRST	SNDSET			;SEND SETUP AND RETURN
SUBTTL	APLHEL	Hello message from application (NCP)

;THIS MESSAGE IS SENT BY AN APPLICATION TO SIGNON TO ORION
;THIS ROUTINE WILL CHECK OUT THE NAME AND IF VALID ASSIGN AN
;IDENTIFIER TO THE APPLICATION AND RETURN THE VALUE TO THE
;APPLICATION.

APLHEL:	$CALL	CHKWHL			;PRIVILEGE CHECK
	JUMPF	E$IPE			;INSUFFICIENT PRIVILEGES ENABLED
	SKIPG	T2,.OARGC(MI)		;ARGUMENT COUNT GREATER THAN 0
	PJRST	E$ICS			;INVALID COUNT SPECIFIED
	CAIE	T2,1			;BETTER BE JUST ONE ARGUMENT
	PJRST	E$ICS			;INVALID COUNT SPECIFIED
	LOAD	T1,.OHDRS+ARG.HD(MI),AR.TYP ;GET THE ARGUMENT TYPE
	CAIE	T1,.AHNAM		;APPLICATION HELLO NAME
	PJRST	E$ITM			;INVALID TYPE IN MESSAGE
	LOAD	T1,.OHDRS+ARG.HD(MI),AR.LEN ;GET LENGTH OF BLOCK
	CAIGE	T1,1			;BETTER BE GREATER THAN 1
	PJRST	E$IAL			;INVALID ARGUMENT LENGTH SPECIFIED
	HRROI	S2,.OHDRS+ARG.DA(MI)	;ADDRESS OF TEST STRING
	MOVEI	S1,APLTAB		;TABLE HEADER
	$CALL	S%TBLK			;LOOKUP ENTRY IN TABLE
	TXNN	S2,TL%EXM		;EXACT MATCH ON STRING
	JRST	E$ANI			;INVALID APPLICATION NAME
	MOVEI	S2,APLTAB+1		;ADDRESS OF FIRST ENTRY
	HLRZM	S2,G$ARG1		;SAVE NAME FOR MESSAGES
	SUB	S1,S2			;GET TABLE OFFSET
	MOVE	T1,S1			;SAVE THE OFFSET
	MOVE	S2,G$SND		;GET SENDERS PID
	MOVEM	S2,APLPID(T1)		;SAVE PID IN TABLE
	$CALL	GETPAG			;GET MESSAGE OUT PAGE..MO SET ON RETURN
	MOVX	S1,.OMHAC		;HELLO ACKNOWLEDGMENT
	STORE	S1,.MSTYP(MO),MS.TYP	;SAVE THE TYPE
	MOVE	S1,.MSCOD(MI)		;[321] GET USERS ACK CODE
	MOVEM	S1,.MSCOD(MO)		;[321] RETURN IT TO HIM...
	AOS	.OARGC(MO)		;BUMP ARGUMENT COUNT
	MOVX	S1,.AHTYP		;APPLICATION HELLO TYPE CODE
	STORE	S1,.OHDRS+ARG.HD(MO),AR.TYP ;SAVE TYPE IN HEADER
	MOVX	S1,ARG.SZ		;MINIMUM SIZE OF BLOCK
	STORE	S1,.OHDRS+ARG.HD(MO),AR.LEN ;SAVE LENGTH OF BLOCK
	MOVE	S1,APLCOD(T1)		;GET APPLICATION CODE
	STORE	S1,.OHDRS+ARG.DA(MO)	;SAVE DATA IN BLOCK
	MOVEI	S1,.OHDRS+ARG.SZ	;SIZE OF THE MESSAGE
	STORE	S1,.MSTYP(MO),MS.CNT	;SAVE COUNT IN MESSAGE
	MOVE	P3,T1			;SAVE TABLE OFFSET
	MOVE	S1,G$SND		;GET SENDERS PID
	MOVEI	S2,PAGSIZ		;SEND THE PAGE
	$CALL	SNDPID			;SEND THE MESSAGE
	$RETIT				;RETURN
	SETZM	APLPID(P3)		;CLEAR TABLE ENTRY
	$CALL	RELPAG			;RETURN THE PAGE
	PJRST	E$AHF			;APPLICATION HELLO FAILURE

	DEFINE	X(A,B,C),<ORNDSP(,<A>,<B>)>

APLTAB:	$STAB
	TABAPL				;EXPAND APPLICATION TABLES
	$ETAB

APLPID: BLOCK	NUMAPL			;PID TABLE OF APPLICATIONS

	DEFINE	X(A,B,C),<EXP	.KY'B>

APLCOD:	TABAPL				;EXPAND THE APPLICATION SYMBOLS


; Generate requests for the application tables
;
DEFINE	X	(A,B,C),<
	EXTERN	C
	.REQUIR	C
>
	TABAPL
SUBTTL	CHKNOD	Validate the OPR node data

;THIS ROUTINE WILL VALIDATE THE OPR NODE IN MESSAGE WITH
;THE NODE THE OPR SIGNED ON WITH TO INSURE NODE IS VALID
;ON RETURN TRUE:
;		S1/ NODE NAME IN SIXBIT
;		S2/ NODE NUMBER (IF APPLICABLE)

TOPS10<
CHKNOD:	MOVE	T1,[XWD .NDRNN,T2]	;CONVERT THE NODE NAME/NUM IN T2
	HRRZI	T2,2			;2 ARGS SPECIFIED..LENGTH
	MOVE	T3,S1			;NODE NUMBER TO CONVERT,,RIGHT HALF
	NODE.	T1,			;ISSUE NODE UUO
	 JRST	[CAME T1,[XWD .NDRNN,T2] ;LOST BECAUSE NO NETWORKS?
		$RETF			;NO, A REAL ERROR
		PJRST	I%HOST]		;YES, JUST RETURN HOST NAME
	TLNN	T1,770000		;SIXBIT ANSWER..NODE NAME
	JRST	CHKN.1			;SET UP NODE NUMBER
	MOVE	S2,S1			;PUT NUMBER IN S2
	MOVE	S1,T1			;PUT NAME IN S1
	$RETT				;RETURN TRUE
CHKN.1:	MOVE	S2,T1			;PUT NUMBER IN S2
	$RETT				;RETURN S1,,NODE NAME
>;END TOPS10

TOPS20<
CHKNOD:	MOVE	T3,S1			;HOLD THE NODE NAME
	CAMN	S1,G$HOST		;IS IT CENTRAL SITE?
	JRST	CHKN.1			;YES..RETURN
	MOVX	S1,.NDVFY		;NODE VERIFY FUNCTION
	MOVEI	S2,T1			;ADDRESS OF THE BLOCK
	HRROI	T1,G$NODX		;GET THE NODE
	SETZM	T2			;CLEAR THE FLAGS
	NODE				;DO THE NODE JSYS
	ERJMP	.RETF			;ERROR..RETURN FALSE
	TXNN	T2,ND%EXM		;DID IT MATCH
	$RETF				;RETURN FALSE
CHKN.1:	MOVE	S1,T3			;GET NODE NAME BACK IN SIXBIT
	SETZ	S2,			;CLEAR AC 2
	$RETT				;RETURN TRUE
>;END TOPS20
SUBTTL	GETNOD	Extract located node of message sender

;This routine will find out where the sender is located.
;On the -20, this information comes as part of the IPCF descriptor.
;On the -10, the location of the job's terminal is returned
;Call
;		G$JOB/	Job number of the sender
;		MI/	incoming message address
;Returns
;	 True	S1/	Sixbit node name
;	 False 	Can't find the node name

TOPS20<
GETNOD:	SKIPN	S1,.OHDRS+OPH.ND(MI)	;GET THE NODE NODE FROM THE MESSAGE ITSELF
	MOVE	S1,G$HOST		;NONE GIVEN , ASSUME CENTRAL
	MOVEM	S1,G$NODE		;SAVE FOR THIS MESSAGE
	$RETT
>;END TOPS20
TOPS10<
GETNOD:	$SAVE	<P1>
	LOAD	S1,G$JOB		;GET THE JOB NUMBER
	LOAD	P1,G$JOB		;Get it again
GETN.1:	CTLJOB	P1,			;Try for a controlling job
	 $RETF				;Job number must be illg.
	CAMN	P1,[-1]			;Are we done?
	JRST	GETN.2			;Yes
	MOVE	S1,P1			;There is one
	JRST	GETN.1			;Go try for another
GETN.2:	TRMNO.	S1,			;GET THIS JOB'S TERMINAL #
	 $RETF				;CAN'T?? GIVE UP
	GTNTN.	S1,			;FIND OUT WHERE THAT TTY LIVES
	 $RETF				;ITS DEAD, QUIT
	HLRZS	S1			;GET JUST THE TERM #
	MOVE	P1,S1			;SAVE FOR RETURN
	MOVEI	TF,2			;1 ARGUMENT, 2 WORDS IN LIST
	MOVE	S2,[XWD .NDRNN,TF]	;AIM AT THE ARGUMENT BLOCK
	NODE.	S2,			;CONVERT TO SIXBIT NAME
	 JRST	[CAME	S2,[XWD .NDRNN,TF] ;LOST BECAUSE FTNET OFF?
		$RETF			;NO, A REAL GARBAGE NODE!
		PJRST	I%HOST]		;YES, JUST SAY OPR AT HOST NODE
	MOVE	S1,S2			;MOVE IT INTO PLACE
	MOVE	S2,P1			;AND PUT BACK THE NODE NUMBER
	$RETT
>;END TOPS10
SUBTTL	OPRSET	Process setup reply from OPR

;THIS ROUTINE WILL PROCESS A SETUP REPLY FROM OPR AND
;ENABLE OPR FOR APPROPRIATE MESSAGES

OPRSET:	SKIPG	.OARGC(MI)		;VALID ARGUMENT COUNT
	PJRST	E$ICS			;INVALID COUNT SPECIFIED
	MOVE	S1,G$SND		;GET SENDERS PID
	$CALL	VALOPR			;VALIDATE THE NODE
					;RETURNS TRUE S2 OPR ENTRY ADDRESS
	JUMPF	E$ISM			;INVALID SETUP MESSAGE
	MOVEM	S2,G$OPRA		;SAVE THE OPR ADDRESS
	LOAD	T1,.OHDRS+ARG.HD(MI),AR.TYP ;GET TYPE CODE
	CAIN	T1,.ORFAL		;FAILURE RETURN
	PJRST	OPRS.1			;FIX OPR DATA BASE
	CAIE	T1,.ORSUC		;SUCCESSFUL??
	PJRST	E$ITM			;INVALID TYPE IN MESSAGE
	MOVX	S1,OP.NST		;OPR NOT SETUP
	TDNN	S1,OPR.FL(S2)		;WAS OPR ALREADY SETUP
	PJRST	OPRS.3			;YES..ERROR
	ANDCAM	S1,OPR.FL(S2)		;MARK AS SETUP
	SKIPG	G$NSNT			;ANY UNSENT MESSAGES
	$RETT				;NO JUST RETURN
	MOVE	S1,G$OPRA		;Get OPR data base address
	$CALL	O$HOST			;System or host?
	JUMPF	.RETT			;No.. don't send outstanding msgs
	MOVX	S1,R.SOPR		;ONLY SENDS TO OPR
	$CALL	SNDLST			;TRY SENDING THE MESSAGES
	$RETT				;RETURN TRUE

OPRS.1:	SOSG	.OARGC(M)		;ANY ARGUMNETS LEFT
	  JRST	OPRS.2			;NO..IGNORE TEXT LOGGING
	LOAD	T1,.OHDRS+ARG.HD(MI),AR.LEN ;GET THE LENGTH
	ADDI	T1,.OHDRS(M)		;POSITION TO NEXT ARGUMENT
	LOAD	S1,ARG.HD(T1),AR.TYP	;GET ARGUMENT TYPE
	CAIE	S1,.CMTXT		;TEXT ??
	  JRST	OPRS.2			;NO..IGNORE TEXT
	MOVEI	S1,ARG.DA(T1)		;ADDRESS OF THE TEXT
	$CALL	L$SETF##		;LOG SETUP FAILURE
OPRS.2:	MOVE	S1,G$SND		;GET THE SENDERS PID
	$CALL	DELOPR			;DELETE THE OPR BLOCK
	$RETT				;RETURN TRUE
OPRS.3:	MOVE	S1,G$SND		;GET THE SENDERS PID
	$CALL	DELOPR			;DELETE THE OPR
	PJRST	E$OAS			;OPR ALREADY SETUP..OPR DELETED
SUBTTL	SNDSET	Send setup reply to OPR

;THIS ROUTINE SEND THE CURRENT SETTINGS TO OPR IN RESPONSE TO
;THE HELLO MESSAGE

SNDSET:	$CALL	GETPAG			;PAGE FOR OUTPUT IN MO
	MOVX	S1,.OMOST		;OPR SETUP CODE
	STORE	S1,.MSTYP(MO),MS.TYP	;SAVE IN MESSAGE
	MOVX	S1,.OHDRS		;SIZE OF MESSAGE FOR NOW
	STORE	S1,.MSTYP(MO),MS.CNT	;SAVE THE COUNT IN MESSAGE
	MOVE	S1,G$SND		;GET OPR PID
	MOVEM	S1,G$ARG1		;SAVE THE PID
	MOVX	S2,PAGSIZ		;SEND A PAGE
	$CALL	SPDOPR			;SEND THE MESSAGE
	 $RETIT				;OK..RETURN
	PJRST	E$OSF			;OPR SETUP FAILURE
	$RETF				;RETURN FALSE FROM SEND
SUBTTL	TEXT	Routine to Process a TEXT Message

;THIS ROUTINE JUST SHIPS THE MESSAGE ON TO THE APPROPRIATE OPERATOR
;IF MF.NOM IS SET, THE MESSAGE IS THROWN AWAY

TEXT:	LOAD	S1,.MSCOD(MI)		;GET THE CODE TO LOOK FOR
	$CALL	VALOPR			;FIND THE OPR ENTRY
	JUMPF	E$ODE			;OPR NO LONGER EXISTS
	LOAD	S1,.MSFLG(MI)		;GET FLAG WORD
	TXNE	S1,MF.NOM		;NO MESSAGE..IN ACK
	$RETT				;YES..JUST RETURN
	$CALL	SPGOUT			;SETUP OUTPUT PAGE
	AOS	OPR.OC(S2)		;BUMP MESSAGE OUT COUNT
	MOVE	S1,OPR.PD(S2)		;GET THE PID TO SEND TO
	MOVEI	S2,PAGSIZ		;GET SIZE OF MESSAGE
	$CALL	SPDOPR			;SEND PID TO OPR
	$RETT				;RETURN TRUE ALWAYS
SUBTTL	SPGOUT	Setup output page to send

;This Routine will make an Output Page to Send where
;we wish to send the input message out

SPGOUT:	$CALL	GETPAG			;GET A PAGE
	HRLI	S1,(MI)			;SOURCE ADDRESS
	HRRI	S1,(MO)			;DESTINATION
	BLT 	S1,PAGSIZ-1(MO)		;MOVE THE DATA
	$RETT				;RETURN
SUBTTL	W$WTOR	Process a WTOR Message

W$WTOR:	MOVE	P1,.OFLAG(MI)		;GET FLAG WORD
	TXNE	P1,WT.KIL		;CHECK FOR KILL MESSAGE
	PJRST	W$KWTO			;PROCESS KILL MESSAGE
	$CALL	W$VALID			;VALIDATE A WTO MESSAGE
	$RETIF				;FAILS...RETURN
	$CALL	W$CHEK			;CHECK IF USER ALLOWED TO SEND
	$RETIF				;ERROR..RETURN
	$CALL	OPRMES			;SETUP THE MESSAGE
	MOVX	S1,.OMWTR		;GET THE DISPLAY TYPE
	STORE	S1,.MSTYP(MO),MS.TYP	;SAVE TYPE IN MESSAGE
	AOS	G$SEQ			;ASSIGN A SEQUENCE NUMBER
	MOVEI	T1,[ITEXT(< ^7/[74]/^D/G$SEQ/^7/[76]/	>)]
	$CALL	W$MESS			;BUILD OUTPUT MESSAGE
	JUMPT	WTOR.1			;O.K. CONTINUE ON
	SOS	G$SEQ			;DECREMENT MESSAGE COUNT FROM FAILURE
	PJRST	WTERRO			;WT ERROR RETURN
WTOR.1:	$CALL	L$WTOR##		;LOG THE WTOR MESSAGE
	$CALL	W$NODE			;GET THE NODE TO SEND TO
	MOVE	T1,S1			;SAVE THE ENTRY ADDRESS
	LOAD	S1,NOD.ML(T1)		;GET MESSAGE LIST NUMBER
	$CALL	L%LAST			;POSITION TO THE END
	LOAD	S1,NOD.ML(T1)		;GET MESSAGE LIST NUMBER
	LOAD	S2,ARG.HD+.OHDRS(MO),AR.LEN ;GET LENGTH OF ARGUMENT
	MOVE	T3,S2			;SAVE SIZE IN T3
	ADDI	S2,MSL.SZ		;GET SIZE OF TOTAL ENTRY
	$CALL	L%CENT			;CREATE AN ENTRY
	JUMPF	WTERRO			;Shouldn't happen, but quit this.
	MOVE	T2,S2			;SAVE ADDRESS OF THE ENTRY
	HRLI	S1,ARG.HD+.OHDRS(MO)	;GET START OF BLT
	HRRI	S1,MSL.SZ(T2)		;ADDRESS OF DESTINATION
	ADDI	T3,MSL.SZ(T2)		;GET ENDING ADDRESS
	BLT	S1,-1(T3)		;MOVE THE DATA
	MOVE	S1,G$SND		;SENDERS PID
	MOVEM	S1,MSL.PD(T2)		;SAVE IN MESSAGE BLOCK
	MOVEM	T1,MSL.ND(T2)		;SAVE NODE ADDRESS IN MESSAGE LIST
	AOS	NOD.CT(T1)		;BUMP THE NODE COUNT
	MOVE	S1,.MSCOD(MI)		;GET MESSAGE HEADER CODE
	MOVEM	S1,MSL.CD(T2)		;SAVE THE MESSAGE CODE
	MOVE	S1,G$SEQ		;GET THE SEQUENCE NUMBER
	MOVEM	S1,MSL.ID(T2)		;SAVE SEQUENCE NUMBER
	SKIPN	S1,WDAJOB		;WAS THERE A JOB NUMBER
	LOAD	S1,G$JOB		;GET SENDERS JOB NUMBER
	MOVEM	S1,MSL.JB(T2)		;SAVE JOB NUMBER
	MOVX	T3,MS.TER		;TERMINAL NOTIFY ON FAILURE
	MOVX	S2,WT.NFY		;GET THE NOFITFY TERMINAL FLAG
	TDNN	S2,.OFLAG(MI)		;WAS IT SET?
	JRST	WTOR.2			;NO..BYPASS SETTING LOGGED IN TIME
	IORM	T3,MSL.FL(T2)		;SAVE THE FLAG BIT WITH MESSAGE
	MOVX	S2,JI.JLT		;GET LOGGED IN TIME FOR JOB
	$CALL	I%JINF			;GET LOGGED IN TIME
	MOVEM	S2,MSL.JT(T2)		;SAVE THE VALUE FOR LATER
WTOR.2:	SKIPN	G$CHKM			;NEED TO REQUEST MESSAGE CHECK?
	$CALL	REQMSC			;YES..GO DO IT
	MOVE	S1,T1			;NODE ENTRY
	$CALL	SNDAOP			;Send to all operators
	$RET				;Return preserving AC0


SUBTTL	W$KWTO	Kill a WTOR request by code

;THIS ROUTINE WILL KILL A WTOR REQUEST BY CODE AND INFORM
;ALL OPRS OF THE DELETED MESSAGE

W$KWTO:	MOVEI	S2,[ITEXT(< by user ^U/G$SID/ job ^D/G$JOB/>)]
	MOVEM	S2,G$ARG3		;SAVE USER INFO FOR KILL
	TXNN	P1,WT.SJI		;DID USER WISH TO SUPPRESS JOB INFO
	JRST	WTOK.0			;NO..LOOK FOR MESSAGE NOW
	$CALL	CHKWHL			;CHECK IF PRIVILEGED
	JUMPF	E$IPE			;INSUFFICIENT PRIVILEGES
	MOVEI	S2,NULTXT		;SETUP NULL TEXT
	MOVEM	S2,G$ARG3		;SAVE THE ARGUMENT
WTOK.0:	MOVX	S1,MSL.CD		;GET THE CODE FIELD
	MOVE	P3,.MSCOD(MI)		;GET THE ACK CODE TO CHECK FOR
	TXNE	P1,WT.KAL		;KILL ALL FOR THE JOB
	   JRST [MOVX	S1,MSL.JB	;SETUP JOB NUMBER FOR THE MATCH
		LOAD P3,G$JOB		;GET THE JOB NUMBER
		JRST 	.+1]		;CONTINUE ON
	HRRM	S1,FNDXCT		;SAVE FOR COMPARE
	MOVE	S1,P3			;GET THE MESSAGE CODE
	MOVEM	S1,G$ARG1		;SAVE CODE FOR POSSIBLE ERROR
	SETZM	G$ARG2			;CLEAR MESSAGE KILLED COUNT
	$CALL	FNDMSG			;TRY TO FIND A MESSAGE
	JUMPF	E$NMC			;NO MESSAGES WITH CODE
WTOK.1:	SETZ	P1,			;CLEAR P1 FOR SCRATCH
	EXCH	P1,G$ERR		;SAVE ERROR CODE
	MOVEI	S1,E$CWM		;SETUP USER CANCEL MESSAGE
	$CALL	W$KMES			;KILL THE MESSAGE
	$CALL	L$KMES##		;LOG THE MESSAGE
	MOVEM	P1,G$ERR		;RESTORE THE ERROR CODE
WTOK.2:	MOVE	S1,P3			;GET THE CODE AGAIN
	$CALL	NXTMSG			;GET NEXT MESSAGE
	JUMPT	WTOK.1			;PROCESS SECOND MESSAGE
	SETZM	G$ERR			;CLEAR ERROR CODE
	SKIPE	G$ARG2			;ANY MESSAGES KILLED
	JRST	WTOK.3			;CHECK FOR ACK
	MOVE	S1,P3			;GET THE CODE
	MOVEM	S1,G$ARG1		;SAVE THE CODE
	PJRST	E$NMC			;NO MESSAGE CANCELED
WTOK.3:	LOAD	S1,.MSFLG(MI),MF.ACK	;ACK REQUESTED?
	SKIPN	S1			;USER WANT AN ACK
	$RETT				;NO..JUST RETURN
	PJRST	E$MCJ			;MESSAGES CANCELED FOR JOB
SUBTTL	W$NODE	Determine destination node for message

W$NODE:	SKIPN	S1,WDADES		;ANY DESTINATION SET
	JRST	WTNO.1			;NO..USE CENTRAL SITE
	$CALL	FNDNOD			;CHECK THIS NODE
	$RETIT				;O.K...FOUND IT
WTNO.1:	MOVE	S1,G$HOST		;GET CENTRAL SITE NODE
	$CALL	FNDNOD			;LOCATE THIS ONE
	$RETIT				;BETTER SUCCEED
	$STOP(CNE,Central site node not present)
SUBTTL	W$KMES	Kill a message and notify OPR


W$KMES:	$CALL	(S1)			;SETUP MESSAGE
	MOVE	S1,MSL.ID(S2)		;GET SEQUENCE NUMBER
	MOVEM	S1,G$ARG1		;SAVE THE NUMBER
	MOVE	S1,MSL.ND(S2)		;GET NODE MESSAGE FOUND AT
	PUSH	P,S1			;SAVE NODE LIST ADDRESS
	SOS	NOD.CT(S1)		;DECREMENT MESSAGE NODE COUNT
	MOVE	S1,NOD.ML(S1)		;GET MESSAGE LIST NUMBER
	$CALL	L%DENT			;DELETE THE MESSAGE
	$CALL	BLDACK			;BUILD ACK MESSAGE
	POP	P,S1			;GET NODE ADDRESS
	$CALL	SNDAOP			;SEND IT TO ALL OPRS AT NODE
	AOS	G$ARG2			;BUMP KILLED COUNT
	$RETT				;RETURN TRUE
SUBTTL	W$WTO	Process a WTO message

;THIS ROUTINE WILL PROCESS A WTO MESSAGE AND SEND IT TO
;THE APPROPRIATE OPERATOR

W$WTO:	$CALL	W$CHEK			;CHECK IF USER ALLOWED TO SEND
	$RETIF				;ERROR..RETURN
	$CALL	W$VALID			;VALIDATE THE MESSAGE
	$RETIF				;ERROR..RETURN
	$CALL	OPRMES			;BUILD OUTPUT MESSAGE
	$CALL	W$MESS			;SETUP OUTPUT TEXT
	JUMPF	WTERRO			;WT ERROR RETURN
	$CALL	L$WTO##			;LOG WTO MESSAGE
WTOSND:	$CALL	W$NODE			;GET THE NODE FOR MESSAGE
	$CALL	SNDAOP			;Send the message
	$RET				;Return preserving AC0


WTERRO:	$CALL	RELPAG			;RETURN THE PAGE
	$RETF				;RETURN FALSE
SUBTTL	W$CHEK	Check if WTO/WTOR allowed for this job

W$CHEK:	SKIPE	S1,WDAJOB		;WTO/WTOR IN SOMEONE'S BEHALF ?
	JRST	CHEK.1			;YES
	$CALL	CHKWHL			;CHECK IF PRIVILEGED
	$RETIT				;O.K.. IGNORE THE CHECK
	LOAD	S1,G$JOB		;GET THE JOB NUMBER

CHEK.1:	MOVX	S2,JI.BAT		;GET BATCH DATA AND OPR FIELDS
	$CALL	I%JINF			;GET THE DATA
	LOAD	S1,S2,OB.WTO		;GET THE WTO FLAGS
	SKIPN	S1			;ANY VALUE SET
	$RETT				;NO..ITS O.K...RETURN
	CAIN	S1,.OBNOM		;NO MESSAGES ALLOWED
	JRST	CHEK.2			;NOT ALLOWED - CHECK FOR BATCH
	LOAD	S1,.MSTYP(MI),MS.TYP	;GET MESSAGE TYPE
	CAIE	S1,.OMWTR		;WAS IT A WTOR
	$RETT				;NO - RETURN TRUE

CHEK.2:	TXNN	S2,OB.BSS		;BATCH STREAM ?
	PJRST	E$WNA			;NO - A TIMESHARING JOB
	$CALL	M%GPAG			;GET A PAGE
	MOVE	MO,S1			;SAVE ADDRESS
	HRLI	S1,CANMSG		;SET UP BLT
	BLT	S1,CANSIZ-1(MO)		;COPY INTO IPCF PAGE
	LOAD	S1,S2,OB.BSN		;GET BATCH STREAM NUMBER
	MOVEM	S1,.OARGC+2+OBJ.UN(MO)	;STORE IT
	MOVE	S1,G$HOST		;GET NODE NUMBER
	MOVEM	S1,.OARGC+2+OBJ.ND(MO)	;STORE IT
	SETZM	G$SND			;TO MAKE ACK CODE ZERO
	PUSHJ	P,SNDQSR		;CANCEL THE BATCH JOB
	$RETF				;ENOUGH OF THIS 


; Prototype message block
; This block contains the information that would noramlly be generated by an
; "ABORT BATCH-STREAM nnn /ERROR-PROCESSING /REASON:No operator intervention
; allowed." command to OPR.
;
CANMSG:	XWD	CANSIZ,.OMCAN		;(.MSTYP) MESSAGE LENGTH AND TYPE
	XWD	0,0			;(.MSFLG) FLAGS
	XWD	0,0			;(.MSCOD) ACK CODE
	XWD	0,0			;(.OFLAG) FLAGS
	XWD	0,3			;(.OARGC) ARGUMENT COUNT
	XWD	4,.OROBJ		;OBJECT BLOCK HEADER
	XWD	0,.OTBAT		;BATCH
	XWD	0,0			;STREAM
	XWD	0,0			;NODE NUMBER
	XWD	2,.CANTY		;ERROR PROCESSING BLOCK HEADER
	XWD	0,.CNERR		;/ERROR-PROCESSING
	XWD	7,.ORREA		;REASON BLOCK HEADER
	ASCIZ	|No operator intervention allowed.| ;/REASON TEXT
CANSIZ==.-CANMSG			;LENGTH OF MESSAGE
IFG <CANSIZ-24>,<PRINTX ? Cancel message size too big; change WDACAN>
SUBTTL	W$LOGM	Log a message

;THIS MESSAGE IS A WTO/WTOR/ACK TYPE MESSAGE JUST PLACING INFO IN LOG
;AND NOT SENDING IT.. IF THERE IS NO LOG THE MESSAGE WILL BE IGNORED

W$LOGM:	SKIPN	LOGINT			;LOGGING ENABLED
	$RETT				;NO..JUST RETURN..IGNORE IT
	$CALL	W$VALID			;VALIDATE THE MESSAGE
	$RETIF				;ERROR..RETURN
	$CALL	OPRMES			;BUILD OUTPUT MESSAGE
	$CALL	W$MESS			;SETUP OUTPUT TEXT
	JUMPF	WTERRO			;WT ERROR RETURN
	$CALL	L$LOG##			;LOG WTO MESSAGE
	PJRST	RELPAG			;RELEASE PAGE AND RETURN
SUBTTL	W$VALID	Validate WTO, WTOR and ACK Messages

;THIS ROUTINE WILL TAKE THE FREE FORMATTED WTO, WTOR
;AND ACK MESSAGES AND MAP THEM INTO THE FIXED FORMATED MESSAGE
;CURRENTLY USED BY OPR AND ORION. THE ROUTINE WILL VALIDATE
;THE FIELDS AND PRIVILEGE CHECK APPROPRIATE FIELDS. ERRORS WILL
;BE GENERATED FOR ALL DUPLICATION OF ENTRIES IN THE MESSAGE.

W$VALID:LOAD	S1,.MSTYP(MI),MS.CNT	;GET THE MESSAGE LENGTH
	MOVEM	S1,G$ARG1		;SAVE MESSAGE LENGTH IN ARGUMENT
	CAILE	S1,WTOMAX		;CHECK IF WITHIN BOUNDS
	PJRST	E$WTL			;WTO MESSAGE TO LARGE
	SKIPG	P2,.OARGC(MI)		;GET THE ARGUMENT COUNT
	PJRST	E$ICS			;INVALID ARGUMENT COUNT SPECIFIED
	TXZ	FLAG,F.WFLG		;CLEAR WTO FLAGS
	MOVE	S1,[WDATXT,,WDATXT+1]	;WTO TEXT DATA POINTER
	SETZM	WDATXT			;CLEAR FIRST WORD
	BLT	S1,WDAEND		;CLEAR THE DATA WORDS
	MOVX	S1,WO.JOB		;JOB MESSAGE FLAG
	MOVX	S2,WT.JOB		;JOB MESSAGE FLAG FROM MESSAGE
	TDNE	S2,.OFLAG(MI)		;WAS IT SET
	IORM	S1,WDAFLG		;SET THE FLAG
	MOVX	S1,WO.OAC		;OPERATOR ACTION MESSAGE
	LOAD	S2,.MSTYP(MI),MS.TYP	;GET MESSAGE TYPE
	CAIN	S2,.OMWTR		;WAS IT WTOR
	IORM	S1,WDAFLG		;SET THE FLAG
	MOVEI	S1,.OHDRS(MI)		;ADDRESS OF FIRST ARGUMENT
	$CALL	P$SETU			;SETUP THE PARSER POINTER
	MOVX	S1,WO.EVM		;CHECK IF OTER MESSAGE
	SKIPN	WDAFLG			;ANYTHING SET?
	IORM	S1,WDAFLG		;TURN ON OTHER FLAG
VALW.1:	$CALL	P$NARG			;GET THE NEXT ARGUMENT
	MOVE	P1,S2			;SAVE ARGUMENT ADDRESS
	LOAD	P3,ARG.HD(S2),AR.LEN	;SAVE THE ARGUMENT LENGTH
	CAILE	S1,.WTLST		;VALID ARGUMENT TYPE
	PJRST	E$ITM			;INVALID TYPE..ERROR AND RELEASE
					;PAGE
	HRRZ	S2,WTODSP(S1)		;GET THE PROCESSING ROUTINE
	$CALL	(S2)			;PROCESS THE ARGUMENT
	$RETIF				;BAD RETURN..RETURN
	$CALL	P$NEXT			;POSITION TO THE NEXT ONE
	SOJG	P2,VALW.1		;PROCESS THE REST OF THE ARGUMENTS
	$RETT				;Return, no longer do length check

;DISPATCH TABLE FOR WTO WTOR AND ACK PROCESSING

WTODSP:	.WTTXT,,WTOTXT			;PROCESS MAIN TEXT STRING
	.WTOBJ,,WTOOBJ			;PROCESS OBJECT BLOCK
	.WTDES,,WTODES			;PROCESS DESTINATION NODE
	.WTJOB,,WTOJOB			;PROCESS JOB NUMBER
	.WTERR,,WTOERR			;PROCESS ERROR CODE
	.WTRTE,,WTORTE			;PROCESS ROUTE CODE
	.WTTYP,,WTOTYP			;PROCESS TYPE TEXT
	.WTANS,,WTOANS			;PROCESS ANSWER BLOCK
	.WTACD,,WTOACD			;PROCESS APPLICATION CODE BLOCK
	.WTOCD,,WTOOCD			;PROCESS OBJECT TYPE BLOCK
	.WTNOP,,.RETT			;NOOP FOR MONITOR WTO MESSAGES
	.WTDTY,,WTODTY			;DISPLAY TYPE INFO
SUBTTL	WTOTXT, WTOTYP, WTOANS and WTOACD routines

;THESE ROUTINES WILL SETUP DATA POINTER TO FIELDS AND VALIDATE
;FIELDS FOR PRIVILEGES WHERE REQUIRED

WTOTXT:	TXOE	FLAG,F.WTXT		;HAVE WE PROCESSED TEXT BEFORE
	PJRST	E$DTM			;DUPLICATE TYPE IN MESSAGE
	MOVEI	S1,ARG.DA(P1)		;POINTER TO ACTUAL TEXT
	MOVEM	S1,WDATXT		;TEXT POINTER FIELD
	$RETT				;RETURN TRUE

WTOTYP:	TXOE	FLAG,F.WTYP		;TYPE MESSAGE SEEN
	PJRST	E$DTM			;DUPLICATE TYPE IN MESSAGE
	$CALL	CHKWHL			;THIS BLOCK NEEDS PRIVS
	SKIPT				;HE/SHE/IT HAS THEM
	SKIPA	S1,[ARG.DA+[XWD	7,.WTTYP
			ASCIZ |Message from timesharing user|]]
	MOVEI	S1,ARG.DA(P1)		;POINTER TO ACTUAL TEXT
	MOVEM	S1,WDATYP		;TYPE DATA FIELD
	$RETT				;RETURN TRUE

WTOANS:	TXOE	FLAG,F.WANS		;ANSWER BLOCK SPECIFIED SO FAR
	PJRST	E$DTM			;DUPLICATE TYPE IN MESSAGE
	LOAD	S1,.MSTYP(MI),MS.TYP	;GET MESSAGE TYPE
	CAIE	S1,.OMWTR		;WTOR MESSAGE
	PJRST	E$IWF			;INVALID WTO FIELD
	MOVEI	S1,ARG.DA(P1)		;POINTER TO ACTUAL TEXT
	MOVEM	S1,WDAANS		;SAVE ANSWER DATA POINTER
	$RETT				;RETURN TRUE
WTOACD:	TXOE	FLAG,F.WACD		;CODE SPECIFIED SO FAR
	PJRST	E$DTM			;DUPLICATE TYPE IN MESSAGE
	TXNE	FLAG,F.WOBJ!F.WOCD	;WAS THERE AN OBJECT BLOCK
	PJRST	E$AON			;APPLICA AND OBJECT NOT ALLOWED	TOGETHER
	MOVE	S1,ARG.DA(P1)		;GET THE CODE TYPE
	MOVEM	S1,G$ARG1		;SAVE THE ARGUMENT
	$CALL	FNDAPL			;FIND THE APPLICATION
	JUMPF	E$ACI			;APPLICATION CODE INVALID
	MOVEM	S1,WDAOBT		;SAVE APPLICATION OBJECT TYPE
	MOVE	T1,APLTAB+1(S2)		;GET COMMAND TABLE ENTRY
	HLRZM	T1,WDAACD		;SAVE THE NAME
	HLRZM	T1,G$ARG1		;SAVE NAME FOR POSSIBLE ERRORS
	SKIPN	S1,APLPID(S2)		;IS THERE A PID THERE
	PJRST	E$ANS			;APPLICATION NOT SIGNED ON
	CAME	S1,G$SND		;BETTER BE FOR SAME JOB
	PJRST	E$CPM			;CODE PID MISMATCH FOR APPLICATION
	$RETT				;RETURN TRUE
SUBTTL	WTOJOB,WTOERR,WTORTE and WTODES  routines



WTOJOB:	TXOE	FLAG,F.WJOB		;JOB NUMBER SEEN SO FAR
	PJRST	E$DTM			;YES..DUPLICATE TYPE IN MESSAGE
	$CALL	CHKWHL			;PRIVILEGE CHECK JOB FIELD
	JUMPF	E$WJP			;WTO JOB FIELD REQUIRES PRIVILEGES
	LOAD	S1,ARG.DA(P1)		;GET JOB NUMBER
	MOVEM	S1,WDAJOB		;SAVE THE JOB NUMBER
	CAIE	P3,ARG.SZ		;PROPER SIZE FIELD
	PJRST	E$IAL			;INVALID ARGUMENT LENGTH
	$RETT				;RETURN TRUE





WTOERR:	TXOE	FLAG,F.WERR		;ERROR CODE SEEN BEFORE
	PJRST	E$DTM			;DUPLICATE TYPE IN MESSAGE
	LOAD	S1,ARG.DA(P1)		;GET DATA FIELD
	MOVEM	S1,WDAERR		;SAVE ERROR CODE
	CAIE	P3,ARG.SZ		;PROPER SIZE FIELD
	PJRST	E$IAL			;INVALID ARGUMENT LENGTH
	$RETT				;RETURN TRUE


WTORTE:	TXOE	FLAG,F.WRTE		;ROUTE CODE SEEN BEFORE
	PJRST	E$DTM			;DUPLICATE TYPE IN MESSAGE
	LOAD	S1,ARG.DA(P1)		;GET THE ROUTE CODE
	MOVEM	S1,WDARTE		;SAVE THE ROUTE CODE
	CAIE	P3,ARG.SZ		;PROPER SIZE FIELD
	PJRST	E$IAL			;INVALID ARGUMENT LENGTH
	$RETT				;RETURN TRUE


WTODES:	TXOE	FLAG,F.WDES		;DESTINATION CODE SPECIFIED
	PJRST	E$DTM			;DUPLICATE TYPE IN MESSAGE
	LOAD	S1,ARG.DA(P1)		;GET DESTINATION CODE
	MOVEM	S1,WDADES		;SAVE DESTINATION DATA
	CAIE	P3,ARG.SZ		;PROPER SIZE FIELD
	PJRST	E$IAL			;INVALID ARGUMENT LENGTH
	CAME	S1,[-1]			;IS IT FOR ALL NODES
	$RETT				;RETURN TRUE
	$CALL	CHKWHL			;IS IT A WHEEL?
	$RETIT				;OK..RETURN
	PJRST	E$IPE			;INSUFFICIENT PRIVILEGES

SUBTTL	WTOOBJ	Process WTO object block

;THIS ROUTINE WILL ANALYZE AN OBJECT BLOCK AND PLACE THE
;DATA IN THE OUTPUT MESSAGE

WTOOBJ:	TXOE	FLAG,F.WOBJ		;OBJECT BLOCK PROCESSED
	PJRST	E$DTM			;DUPLICATE TYPE IN MESSAGE
	$CALL	CHKWHL			;PRIVILEGES REQUIRED FOR OBJECT
	JUMPF	E$WOP			;OBJECT BLOCK REQUIRES PRIVILEGES
	TXNE	FLAG,F.WACD!F.WOCD	;APPLICATION CODE SET
	PJRST	E$AON			;APPLIC AND OBJECT NOT ALLOWED TOGETHER
	$CALL	WTOC.1			;PROCESS THE CODE
	$RETIF				;PASS FALSE UP
	MOVE	S1,OBJ.TY+ARG.DA(P1)	;GET OBJECT TYPE
	CAIN	S1,.OTMNT		;WAS IT A MOUNT MESSAGE
	JRST	WTOO.1			;BYPASS UNIT CHECK
	LOAD	T1,OBJ.UN+ARG.DA(P1),OU.LRG ;GET LOW RANGE NUMBER
	SKIPGE	T1			;MUST BE .GEQ. 0
	PJRST	E$IOU			;ILLEGAL RANGE UNIT
	LOAD	T2,OBJ.UN+ARG.DA(P1),OU.HRG ;GET HIGH RANGE
	SKIPE	T2			;BETTER BE ZERO
	PJRST	E$RIW			;RANGE INVALID IN WTO OBJECT BLOCK
WTOO.1:	MOVEI	S1,ARG.DA(P1)		;ADDRESS OF OBJECT BLOCK
	MOVEM	S1,WDAOBJ		;SAVE IN OBJECT WORD
	LOAD	T1,OBJ.ND+ARG.DA(P1)	;GET NODE NAME FROM BLOCK
	SKIPN	WDADES			;DESTINATION SET
	MOVEM	T1,WDADES		;SAVE NODE NAME FOR DESTINATION
	$RETT				;RETURN TRUE
SUBTTL	WTOOCD	Object block type

;THIS ROUTINE WILL SETUP THE OBJECT TYPE FOR SCREENING AND
;MAKE SURE THAT NO OBJECT OR APPLICATION WERE SPECIFIED

WTOOCD:	TXOE	FLAG,F.WOCD		;OBJECT TYPE PROCESSED
	PJRST	E$DTM			;DUPLICATE TYPE IN MESSAGE
	$CALL	CHKWHL			;PRIVILEGES REQUIRED FOR OBJECT
	JUMPF	E$WTP			;OBJECT BLOCK REQUIRES PRIVILEGES
	TXNE	FLAG,F.WACD!F.WOBJ	;APPLICATION CODE SET
	PJRST	E$AON			;APPLIC AND OBJECT NOT ALLOWED TOGETHER
WTOC.1:	MOVE	S1,OBJ.TY+ARG.DA(P1)	;GET OBJECT TYPE
	MOVEM	S1,G$ARG1		;SAVE THE OBJECT TYPE IN CASE OF ERROR
	MOVEM	S1,WDAOBT		;SAVE THE OBJECT TYPE
	CAILE	S1,0			;WITHIN RANGE?
	CAILE	S1,.OTMAX
	PJRST	E$IOT			;NO..INVALID OBJECT TYPE
	$RETT				;RETURN

SUBTTL	WTODTY	Process a Display TYpe block

;  This routine fetches the display type from the argument block.

WTODTY:	TXOE	FLAG,F.WDTY		;Set and check for this type argument
	PJRST	E$DTM			;Duplicate, error

;  Need to check here somehow for some types to come from the monitor...

	SKIPLE	S1,ARG.DA(P1)		;Get the argument type
	CAILE	S1,.QBDMX		;Check for legit type
	PJRST	E$ITM			;No good

	MOVEM	S1,WDADTY		;Save the type
	$RETT				;  and return

SUBTTL	W$MTXT	Get the text into the message

;THIS ROUTINE WILL GET THE WTO,WTOR AND ACK TEXT INTO THE
;MESSAGE FOR OUTPUT AND LOGGING
;THIS ROUTINE IS CALLED WITH S1 CONTAINING THE LINE SIZE DESIRED
;AND ALL LINES AFTER FIRST WILL BE PRECEDED BY TWO TABS

W$MTXT:	MOVE	T1,WDATXT		;ADDRESS OF THE TEXT
	HRLI	T1,(POINT 7,0)		;MAKE A BYTE POINTER
	MOVE	T2,WTOPTR		;DESTINATION POINTER IN T2
	MOVE	T4,WTOCNT		;GET COUNT OF SPACE IN MESSAGE
	SKIPN	P1			;FORMATTING?
	PUSHJ	P,W$2TAB		;YES - OUTPUT TWO TABS
	SETZM	SRCPTR			;CLEAR SAVED SOURCE POINTER
MTXT.0:	HRLOI	T3,377777		;GET A LARGE NUMBER
MTXT.1:	ILDB	S2,T1			;GET THE BYTE FROM SOURCE
	JUMPE	S2,MTXT.5		;NULL...END OF DATA
	CAIN	S2,.CHCRT		;IS IT A CARRIAGE RETURN
	JRST	MTXT.1			;YES..IGNORE IT
	CAIE	S2,.CHLFD		;IS IT A LINE FEED
	JRST	MTXT.2			;NO..SAVE BYTE
	MOVEI	S2," "			;GET A BLANK
	SETZ	T3,			;RESET LINE COUNT
MTXT.2:	CAIE	S2," "			;IS IT A BLANK
	JRST	MTXT.3			;NO JUST SAVE THE DATA
	MOVEM	T1,SRCPTR		;SAVE THE SOURCE POINTER
	MOVEM	T2,DESPTR		;SAVE DESTINATION POINTER
	MOVEM	T4,DESCNT		;MESSAGE COUNT FIELD
MTXT.3:	SOJLE	T4,MTXT.6		;DECREMENT THE COUNT
	IDPB	S2,T2			;PLACE BYTE IN DESTINATION
	SOJG	T3,MTXT.1		;GET THE NEXT BYTE
	SKIPN	SRCPTR			;HAVE A BLANK IN MESSAGE
	JRST	MTXT.4			;FINISH LINE
	SETZ	T1,			;CLEAR T1 FOR SRCPTR RESET
	EXCH	T1,SRCPTR		;GET THE SOURCE POINTER AND RESET IT
	MOVE	T2,DESPTR		;GET DESTINATION POINTER
	MOVE	T4,DESCNT		;GET DESTINATION COUNT
MTXT.4:	PUSHJ	P,W$CRLF		;END THE LINE
	JUMPF	MTXT.6			;NO MORE ROOM
	SKIPN	P1			;FORMATTING?
	PUSHJ	P,W$2TAB		;YES - OUTPUT TWO TABS
	JUMPF	MTXT.6			;NO MORE ROOM
	JRST	MTXT.0			;GET NEXT LINE
MTXT.5:	PUSHJ	P,W$CRLF		;END THE LINE
MTXT.6:	MOVEI	S2,0			;GET A NULL
	IDPB	S2,T2			;SAVE BYTE IN MESSAGE
	MOVEM	T4,WTOCNT		;RESTORE COUNT FOR MESSAGE
	MOVEM	T2,WTOPTR		;RESTORE DESTINATION POINTER
	$RETT				;RETURN TRUE
SUBTTL	W$CRLF	Terminate line with CRLF

;THIS ROUTINE WILL PUT CRLF ON LINE FROM W$MTXT

W$CRLF:	MOVEI	S2,.CHCRT		;GET A CARRIAGE RETURN
	IDPB	S2,T2			;SAVE IN DESTINATION
	SOJL	T4,.RETF		;NO MORE ROOM RETURN FALSE
	MOVEI	S2,.CHLFD		;GET A LINE FEED
	IDPB	S2,T2			;SAVE IN DESTINATION
	SOJL	T4,.RETF		;NO MORE ROOM.RETURN FALSE
	$RETT				;RETURN TRUE


SUBTTL	W$2TAB	Insert two TABs into message

W$2TAB:	MOVEI	S2,11			;PUT OUT A TAB
	IDPB	S2,T2			;SAVE IN DESTINATION
	SOJL	T4,.RETF		;NO MORE ROOM RETURN FALSE
	IDPB	S2,T2			;SAVE IN DESTINATION
	SOJL	T4,.RETF		;NO MORE ROOM RETURN FALSE
	$RETT				;RETURN TRUE
SUBTTL	OPRMSG	Build a message for OPR

;THIS ROUTINE WILL BUILD THE TEXT MESSAGE FOR OPR AND TO BE USED
;BY LOGGING IF ENABLED


OPRMES:	$CALL	GETPAG			;GET THE OUTPUT MESSAGE IN MO
	MOVX	S1,.OMDSP		;GET THE DISPLAY TYPE
	STORE	S1,.MSTYP(MO),MS.TYP	;SAVE TYPE IN MESSAGE
	MOVEI	S1,<<PAGSIZ-1>-<ARG.DA+2+.OHDRS>>*5 ;NUMBER OF BYTES AVAILABLE
					;Page size -1 (so 777 works)
					;Minus size of header of argument block
					;  and message header
					;SAVE ROOM FOR TRUNCATING
	MOVEM	S1,WTOCNT		;SAVE IN WTOCNT
	MOVSI	S1,(POINT 7,0)		;SETUP BYTE POINTER
	HRRI	S1,ARG.DA+1+.OHDRS(MO)	;ADDRESS TO SAVE TEXT
	MOVEM	S1,WTOPTR		;SAVE THE BYTE POINTER
	MOVE	S1,G$NOW		;GET THE TIME
	MOVEI	P3,ARG.HD+.OHDRS(MO)	;ADDRESS OF FIRST ARGUMENT
	MOVEM	S1,ARG.DA(P3)		;SAVE THE TIME-STAMP
	MOVX	S1,.ORDSP		;OPR DISPLAY BLOCK
	STORE	S1,ARG.HD(P3),AR.TYP	;SAVE THE TYPE
	$RETT				;RETURN TRUE
SUBTTL	W$MESS	Setup a WTO/WTOR/ACK message

W$MESS:	SKIPN	S2,.OFLAG(MI)		;ANY FLAGS SET IN MESSAGE
	JRST	WTOM.1			;NO..PROCESS MESSAGE
	TXNN	S2,WT.PRV		;ANY PRIVILEGED BITS LIT
	JRST	WTOM.1			;NO..CONTINUE ON
	$CALL	CHKWHL			;WAS USER PRIVILEGED??
	JUMPF	E$IPE			;INSUFFICIENT PRIVILEGE
	TXZ	S2,WT.JOB		;JOB MESSAGE FLAG
	JUMPE	S2,WTOM.1		;NONE ON..PASS CHECK
WTOM.1:	LOAD	S1,.MSTYP(MI),MS.TYP	;GET MESSAGE TYPE
	CAIE	S1,.OMWTR		;WAS IT A WTOR??
	MOVEI	T1,[ITEXT(	)]	;NO..SAVE TAB FOR FIRST FIELD
	MOVEI	T2,[ITEXT()]		;SAVE NULL OBJECT POINTER
	MOVEI	T3,[ITEXT()]		;SAVE NULL TYPE POINTER
	TXNN	FLAG,F.WOBJ		;WAS THERE AN OBJECT BLOCK
	JRST	WTOM.2			;CHECK OUT TYPE
IFN NICSW,<
	MOVE	S2,WDAOBJ		;Get object block address
	MOVE	S1,OBJ.TY(S2)		;Get the object type
	CAIE	S1,.OTLPT		;Printer ?
	JRST	WTOM.A			;No, use regular code
	SETZ	S1,			;Use node local
	MOVE	S2,OBJ.UN(S2)		;And the unit number
	$CALL	P%FUNI##		;Get the printer entry
	MOVE	S1,PP.NAM(S2)		;Get the printer name
	MOVEM	S1,WDAPNM		;Save the printer name
	MOVEI	T2,[ITEXT(<Printer ^W/WDAPNM/>)] ;And make up the object text
	JRST	WTOM.2			;And skip the regular code
WTOM.A:	
>;IFN NICSW
	MOVEI	T2,[ITEXT(<^B/@WDAOBJ/>)];GET OBJECT BLOCK
	MOVE	S1,@WDAOBJ+OBJ.TY	;GET TYPE FIELD
	CAIE	S1,.OTBAT		;WAS IT BATCH?
	JRST	WTOM.2			;NO..CONTINUE ON
	SKIPE	WDAJOB			;WAS THERE A JOB NUMBER
	MOVEI	T2,[ITEXT(<^B/@WDAOBJ/ JOB #^D/WDAJOB/ >)]
WTOM.2:	TXNE	FLAG,F.WACD		;WAS THERE AN APPLICATION  CODE
	MOVEI	T2,[ITEXT(<^T/@WDAACD/>)];SETUP APPLICATION CODE LINE
					;*** SET LENGTH ON APPLICATION CODE
	TXNN	FLAG,F.WTYP		;TYPE FIELD PRESENT
	JRST	WTOM.3			;NO SKIP OVER
	MOVEI	T3,[ITEXT(<  -- ^T/@WDATYP/ -->)]
	MOVX	S1,WT.NDA		;NO DASHES ON TYPE
	TDNE	S1,.OFLAG(MI)		;WAS IT SPECIFIED
	MOVEI	T3,[ITEXT(<  ^T/@WDATYP/>)]
WTOM.3:	$TEXT	(WTORTN,<^I/(T1)/^I/(T2)/^I/(T3)/^A>)
	TXNE	FLAG,F.WOBJ!F.WACD	;OBJECT OR APPLICATION BLOCK
	JRST	WTOM.4			;YES..BYPASS W$JOBH
	MOVX	S1,WT.SJI		;SUPPRESS JOB INFO
	TDNN	S1,.OFLAG(MI)		;WAS IT SET?
	$CALL	W$JOBH			;SETUP W$JOBH FIELD
WTOM.4:	$TEXT	(WTORTN,<>)		;OUTPUT CR,LF
	SKIPN	WDATXT			;CHECK IF ANY TEXT DATA
	JRST	MSGFIN			;NO..FINISH THE MESSAGE
	MOVX	S1,WT.NFO		;NO FORMATTING OF MESSAGE
	TDNN	S1,.OFLAG(MI)		;WANT TO FORMAT THE MESSAGE?
	TDZA	P1,P1			;YES
	SETO	P1,			;CLEAR FORMATTING FLAG
	PUSHJ	P,W$MTXT		;GET THE TEXT FOR WTO
	JRST	MSGFIN			;FINISH THE MESSAGE
SUBTTL	MSGFIN	Finish DISPLAY message


MSGFIN::SETZ	S1,			;SETUP A NULL
	IDPB	S1,WTOPTR		;SAVE A NULL ON THE END
	HRRZ	S1,WTOPTR		;GET LAST ADDRESS
	ADDI	S1,1			;BUMP IT BY 1
	ANDI	S1,777			;GET MESSAGE LENGTH
	STORE	S1,.MSTYP(MO),MS.CNT	;SAVE THE COUNT
	SUBI	S1,.OHDRS		;SIZE OF ARGUMENT BLOCK
	STORE	S1,ARG.HD(P3),AR.LEN	;SAVE ARGUMENT LENGTH
	AOS	.OARGC(MO)		;BUMP THE ARGUMENT COUNT
	$RETT				;RETURN

WTORTN:	SOSGE	WTOCNT			;ROOM IN MESSAGE
	$RETF				;FALSE RETURN..TRUNCATE MESSAGE
	IDPB	S1,WTOPTR		;SAVE THE BYTE
	$RETT				;RETURN TRUE


SUBTTL	W$JOBH	Setup a job header message

;THIS ROUTINE WILL SETUP THE JOB INFORMATION FOR WTO/WTOR
;MESSAGES

W$JOBH:	LOAD	S1,G$JOB		;GET THE JOB NUMBER
	$CALL	GETJOB			;GET THE JOB INFO
	TXNE	FLAG,F.WTYP		;WAS THERE A TYPE BLOCK
	SKIPA	S1,[[ITEXT (<^M^J		>)]] ;<CRLF> <TAB> <TAB>
	MOVEI	S1,[ITEXT (<-- Message from timesharing user --^M^J		>)]
	$TEXT	(WTORTN,<^I/(S1)/^I/@JOBTXT/^A>) ;OUTPUT THE JOB DATA
	$RETT				;RETURN
SUBTTL	GETJOB/GETJBT	Get job information

;THIS ROUTINE WILL OBTAIN JOB INFORMATION ABOUT A USER GIVEN
;THE JOB NUMBER
;GETJBT is the same as GETJOB but tries to include node (location) info.
;CALL	S1/	JOB NUMBER
;
;	S1 PRESERVED

GETJBT:: SETOM	S2			;Set a temp flag
	SKIPA
GETJOB:: SETZM	S2			;set a temp flag
	STKVAR <TRMFLG>		;Get a variable for tty desc.
	MOVEM	S2,TRMFLG		;Save the terminal flag
	MOVEM	S1,JOBNUM		;SAVE THE JOB NUMBER
	MOVX	S2,JI.PRG		;GET PROGRAM NAME
	$CALL	I%JINF			;GET THE INFO
	JUMPF	GETJ.3			;ERROR..RETURN
	MOVEM	S2,JOBNAM		;PROGRAM NAME
	MOVX	S2,JI.USR		;GET USER # OR PPN
	$CALL	I%JINF			;GET VALUE
	JUMPF	GETJ.3			;ERROR..SETUP DEFAULT
	SKIPN	S2			;VALID USER NUMBER
	JRST	GETJ.3			;NO..USE DEFAULT
	MOVEM	S2,JOBID		;SAVE THE ID
TOPS10<
	$CALL	GETNAM			;GET THE USER NAME
>;END TOPS10
	MOVX	S2,JI.TNO		;GET THE TERMINAL NUMBER
	$CALL	I%JINF			;GET THE DATA
	JUMPF	GETJ.3			;ERROR..RETURN
	SKIPGE	S2			;VALID TERMINAL?
	  JRST	[MOVEI	T1,-2		;Detached indicator
		MOVEM	T1,JOBTTY	;Set it
		MOVEI	T1,[ITEXT (<detached>)] ;NO DETACHED
		JRST	GETJ.1]		;SAVE VALUE AND CONTINUE
	MOVEM	S2,JOBTTY		;SAVE THE TERMINAL NUMBER
	SKIPN	TRMFLG			;Do we want to do node location of term?
	JRST	GETJ.0			;No
	$CALL	GLOC			;Get the physical location of TTY
	JUMPF	GETJ.0			;No can do... just give terminal number
	MOVEM	S1,JOBNOD		;Remember the job's node
	MOVEM	S2,JOBLIN		;and the line on that node
	MOVE	S1,JOBNUM		;Restore job number to S1
	MOVEI	T1,[ITEXT (<at ^N/JOBNOD/_^O/JOBLIN/ TTY^O/JOBTTY/>)]
	SKIPA				;Don't do it again
GETJ.0:	MOVEI	T1,[ITEXT (<at terminal ^O/JOBTTY/>)]
GETJ.1:	MOVEM	T1,JOBTER		;SAVE JOB TERMINAL DATA
	MOVX	S2,JI.BAT		;GET BATCH INFO
;*** 7.01 DEPENDENT CODE
	$CALL	I%JINF			;GET JOB INFO
	JUMPF	GETJ.2			;ERROR..RETURN
	TXNN	S2,OB.BSS		;BATCH STREAM NUMBER SET?
	JRST	GETJ.2			;NO..CONTINUE ON
	MOVEM	S2,G$JDAT		;JOB DATA FLAG
	MOVEI	S2,[ITEXT (<in batch-stream ^D/G$JDAT,OB.BSN/>)]
	MOVEM	S2,JOBTER		;SAVE TERMINAL DATA
GETJ.2:	MOVEI	T1,[ITEXT (<job ^D/JOBNUM/ ^P/JOBID/ ^I/USRNAM/^I/@JOBTER/>)]
	MOVEM	T1,JOBTXT		;SAVE JOB TEXT POINTER
	$RETT				;RETURN TRUE
GETJ.3:	MOVEI	T1,[ITEXT (<job ^D/JOBNUM/ ^P/G$SID/>)]
	MOVEM	T1,JOBTXT		;SAVE AS JOBTXT
	SETOM	JOBTTY			;NO JOB FLAG
	MOVEI	T1,NULTXT		;NULL TEXT
	MOVEM	T1,JOBTER		;NO TERMINAL DATA
	$RETT				;RETURN TRUE

TOPS20<
USRNAM==NULTXT
>;END TOPS20
TOPS10<
USRNAM:	ITEXT	(<^W6/JOBUSN/^W/JOBUSN+1/ >)
>;END TOPS10
	SUBTTL	GLOC	Get physical location of TTY

;  This routine determines the physical location of a TTY.  It should
;  be a part of the I%JINF but the answer needs 2 words not one.

;  Accepts	S1 / Job number

;  Returns	False if the routine fails.
;		Possible failures include:
;			Not yet implemented
;			Invalid job number

;		True
;		S1 / Node name/number
;		S2 / Terminal line number

GLOC:
TOPS20<	$RETF				;Not yet implemented >
TOPS10<
	MOVEI	S2,JI.TNO		;Terminal number function
	$CALL	I%JINF			;get it
	$RETIF				;Failures are unacceptable
	ADDI	S2,.UXTRM		;Make it UDX
	GTNTN.	S2,			;Get the node number,,line number
	 $RETF				;Couldn't get it
	HLRZ	S1,S2			;Move the node number
	HRRZS	S2,S2			;Only the line number
	$RETT				;Return happy
> ; End of TOPS10
SUBTTL	GETUSR	Get user info for notify

;THIS ROUTINE WILL GET EXTRA INFO REQUIRED BY NOTIFY AND USE
;GET JOB TO GET THE REST

;CALL	S1/	JOB NUMBER

GETUSR:: $CALL	GETJOB			;GET JOB INFO
	SKIPL	JOBTTY			;HAVE VALID TERMINAL
	JRST	GETU.1			;O.K. CONTINUE ON
	SETOM	S2			;Get -1
	CAME	S2,JOBTTY		;Invalid, or not attached?
	PJRST	E$NJD			;NOTIFY JOB DETACHED
	PJRST	E$JDE			;NOTIFY JOB INVALID
GETU.1:	MOVX	S2,JI.JLT		;JOB LOGGED IN TIME
	$CALL	I%JINF			;GET THE DATA
	MOVEM	S2,JOBJLT		;SAVE JOB LOGGED IN TIME
	$RETT				;O.K..RETURN TRUE
SUBTTL	GETNAM	Get user name

;THIS ROUTINE WILL GET USER NAME FOR A  GIVEN JOB
;CALL S1/	JOB NUMBER

TOPS10<
GETNAM:	HRLZ	S2,S1			;PLACE JOB NUMBER IN LEFT HALF
	HRRI	S2,.GTNM1		;GET THE USER NAME
	GETTAB	S2,			;GETTAB IT
	  JRST	GETJ.3			;ERROR..RETURN
	MOVEM	S2,JOBUSN		;SAVE IN USER NAME
	HRLZ	S2,S1			;JOB NUMBER IN LEFT HALF
	HRRI	S2,.GTNM2		;SECOND HALF OF NAME
	GETTAB	S2,			;GET IT
	  JRST	GETJ.3			;ERROR..RETURN
	MOVEM	S2,JOBUSN+1		;SAVE THE USER NAME SECOND PART
	$RET				;RETURN
>;END TOPS10
SUBTTL	W$SHOW	Show ACK message from QUASAR

;THIS MESSAGE IS AN ANSWER TO A SHOW COMMAND FROM QUASAR
;AND IS ALREADY FORMATED.

W$SHOW:	$CALL	CHKWHL			;CHECK IF WHEEL
	JUMPF	E$ARP			;ERROR..RETURN
	LOAD	S1,.MSFLG(MI)		;GET FLAG WORD
	TXNE	S1,MF.NOM		;NULL ACK
	PJRST	ACKM.1			;LOG THE NULL ACK AND RETURN
	$CALL	SPGOUT			;SETUP PAGE FOR OUTPUT
	$CALL	L$SHWA##		;LOG THE MESSAGE
	$CALL	W$ASND			;SEND THE ACK
	$RETT				;RETURN

SUBTTL	W$ASND	Send an ACK to OPR

;THIS ROUTINE WILL SEND THE MESSAGE TO THE APPROPRIATE OPR
;AND UPDATE THE COUNTS

W$ASND:	SKIPN	S1,.MSCOD(MI)		;GET THE ACK CODE
	PJRST	W$WTO			;ZERO - CHANGE INTO WTO INSTEAD
	CAMN	S1,[-1]			;IS IT A -1 CODE
	PJRST	RELPAG			;YES..THEN DO NOT SEND TO ANYONE
	$CALL	VALOPR			;VALIDATE OPR
	JUMPF	ASND.1			;OPR NOT VALID..RELEASE PAGE AND RETURN
	MOVEM	S2,G$OPRA		;SAVE THE OPR ADDRESS
	AOS	OPR.OC(S2)		;BUMP OUTPUT COUNT
	MOVE	S1,OPR.PD(S2)		;GET OPR PID
	MOVEI	S2,PAGSIZ		;GET SIZE OF MESSAGE
	PJRST	SPDOPR			;SEND THE MESSAGE
ASND.1:	$CALL	RELPAG			;RELEASE THE PAGE
	PJRST	E$ODE			;OPR DOESN'T EXIST ERROR
SUBTTL	W$ACKM	Process an ACK message

;THIS ROUTINE WILL VALIDATE AND THEN PROCESS AN
;ACKNOWLEDGEMENT MESSAGE

W$ACKM:	$CALL	CHKWHL			;CHECK IF PRIVILEGED
	JUMPF	E$ARP			;ACK REQUIRES PRIVILEGES
	LOAD	S1,.MSFLG(MI)		;GET FLAG WORD
	TXNE	S1,MF.NOM		;NULL ACK
	JRST	ACKM.1			;YES..LOG AND RETURN
	$CALL	W$VALID			;VALIDATE THE WTO MESSAGE
	$RETIF				;FALSE RETURN...RETURN
	SETZM	WDAFLG			;CLEAR THE FLAGS FOR ACKS
	$CALL	OPRMES			;BUILD THE MESSAGE
	$CALL	W$MESS			;SETUP THE DATA
	JUMPF	WTERRO			;WT ERROR RETURN
	$CALL	L$ACK##			;LOG THE ACK MESSAGE
	$CALL	W$ASND			;SEND THE ACK
	$RETT				;RETURN
ACKM.1:	$CALL	L$NACK##		;LOG NULL ACK
	$RETT				;RETURN


SUBTTL	TXTMOV	Text Move Routine

;CALLED WITH
;	S1/	ADDRESS OF THE DESTINATION
;	S2/	ADDRESS OF THE SOURCE
;
;RETURNS
;	S1/	UPDATED BYTE POINTER


TXTMOV:	HRLI	S2,(POINT 7,0)		;MAKE A BYTE POINTER
	HRLI	S1,(POINT 7,0)		;BYTE POINTER FOR DESTINATION
	MOVEM	S2,TXTPTR		;SAVE THE SOURCE POINTER
TXTM.1:	ILDB	S2,TXTPTR		;GET FIRST BYTE OF DATA
	JUMPE	S2,TXTM.2		;NULL BYTE ..EXIT
	IDPB	S2,S1			;SAVE THE BYTE
	JRST	TXTM.1			;GET NEXT BYTE
TXTM.2:	IDPB	S2,S1			;SAVE THE NULL FOR ASCIZ
	$RETT				;RETURN
SUBTTL	CMDMES	Process a DN60 command message

;THIS ROUTINE WILL PROCESS A COMMAND PASSED IN THE MESSAGE AND
;PASS IT ON TO THE APPROPRIATE OPR (DN60 ONLY)
	PPPLLL==777000			;PORT /LINE MASK

IFN	FTDN60,<
CMDMES:	$CALL	CHKWHL			;BETTER BE WHEEL OR OPERATOR
	$RETIF				;ERROR..RETURN
	MOVEI	S1,.OHDRS(MI)		;GET THE START OF THE BLOCKS
	$CALL	P$SETU			;SETUP THE POINTER
	$CALL	P$NFLD			;GET NEXT FIELD
	JUMPF	E$ITM			;INVALID TYPE ARGUMENT
	CAIE	S1,.ORNOD		;WAS IT A NODE BLOCK
	PJRST	E$ITM			;INVALID TYPE ARGUMENT
	MOVE	T3,ARG.DA(S2)		;GET THE NODE NAME IN SIXBIT
	$CALL	P$NFLD			;GET THE NEXT FIELD
	JUMPF	E$ITM			;INVALID TYPE MESSAGE
	CAIE	S1,.ORD60		;WAS IT A DN60 BLOCK
	PJRST	E$ITM			;INVALID BLOCK TYPE
	DMOVE	P1,ARG.DA(S2)		;GET THE DATA WORDS
	HLRZ	S1,P1			;GET THE PORT NUMBER
	HRRO	S2,P1			;SETUP -1,, LINE NUMBER
	STORE	S1,S2,PPPLLL		;SAVE  AS -1,,PPPLLL
	MOVEM	S2,.MSCOD(MI)		;SAVE ACK CODE
	EXCH	S2,G$SND		;SAVE AS THE SENDER
	MOVE	S1,G$SND		;GET THE HANDLE
	$CALL	VALOPR			;VALIDATE THE OPR
	JUMPF	E$ONS			;OPR NOT SETUP
	MOVEM	S2,G$OPRA		;SAVE OPR ADDRESS
	$CALL	P$TEXT			;CHECK FOR A TEXT BLOCK
	JUMPF	E$ITM			;INVALID TYPE BLOCK
	MOVEI	S1,ARG.DA(S1)		;ADDRESS OF THE STRING
	MOVEM	S1,PARBLK+PAR.SR	;SAVE THE TEXT ADDRESS
	MOVEI	S1,INITCM##		;ADDRESS OF THE TABLES
	MOVEM	S1,PARBLK+PAR.TB	;SAVE THE TABLE ADDRESS
	MOVEI	S1,PAR.SZ		;SIZE OF THE BLOCK
	MOVEI	S2,PARBLK		;ADDRESS OF THE BLOCK
	$CALL	PARSER##		;PROCESS THE MESSAGE
	JUMPT	CMDM.1			;O.K..
	MOVE	T1,PRT.EM(S2)		;ADDRESS OF THE MESSAGE
	MOVEM	T1,G$ARG1		;SAVE THE MESSAGE
	PJRST	E$PER			;PARSER ERROR RETURN
CMDM.1:	MOVE	MI,PRT.CM(S2)		;GET MESSAGE ADDRESS
	JRST	COMMAN			;PROCESS THE COMMAND
>;END FTDN60
SUBTTL	COMMAN	Process an OPR command message (ala OPRPAR)

;THIS ROUTINE TAKES THE MESSAGE SENT BY THE PARSER AS THE RESULT OF A
;VALID COMMAND AND DISPATCHES TO THE APPROPRIATE ACTION ROUTINE BASED
;ON THE COMMAND TYPE
;IT IS CALLED WITH MI POINTING TO THE PAGE CONTAINING THE MESSAGE

COMMAN:	MOVE	S1,G$SND		;GET THE SENDERS PID
	$CALL	VALOPR			;VALIDATE THE OPERATOR
	JUMPF	E$ONS			;OPR NOT SETUP
	MOVEM	S2,G$OPRA		;SAVE OPR ENTRY ADDRESS
TOPS20<
	MOVX	T1,MD.PWH!MD.POP	;GET WHEEL AND OPR FLAGS
	MOVX	S1,OP.REM		;IS IT REMOTE OPERATOR
	TDNE	S1,OPR.FL(S2)		;CHECK THE FLAG
	ANDCAM	T1,G$PRVS		;YES..CLEAR PRIVILEGES FOR MESSAGES
>;END TOPS20
	MOVE	T1,OPR.FL(S2)		;GET THE FLAGS
	TXNE	T1,OP.NST		;CHECK IF SETUP?
	PJRST	E$ONS			;OPERATOR NOT SETUP
	TXNE	T1,OP.ABT		;WAS ABORT SET
	$RETT				;YES..EXIT NOW
	$CALL	L$CMD##			;LOG THE COMMAND
	SKIPG	T1,.OARGC(MI)		;GET THE ARGUMENT COUNT
	JRST	E$ICS			;INVALID COUNT SPECIFIED
	CAILE	T1,COM.AL		;LESS THAN MAX SIZE
	JRST	E$ICS			;WRONG COUNT SPECIFIED
	MOVX	T2,CM.NPR		;NO PROCESSING REQUIRED
	TDNE	T2,.OFLAG(MI)		;CHECK IF SET??
	$RETT				;YES..RETURN TRUE
COMM.1:	SKIPN	S2,COM.PB(MI)		;WAS PARSER BLOCK FILLED IN
	PJRST	E$CMI			;COMMAND MESSAGE INVALID
	SKIPE	S1,COM.TY(MI)		;CHECK FOR APPLICATION MESSAGE
	JRST	COMM.6			;YES..SEND TO APPLICATION
	ADDI	S2,(MI)			;POINT PB AT THE BLOCK
	MOVE	S1,S2			;GET THE BLOCK POINTER
	$CALL	P$SETU			;SETUP THE POINTER
	$CALL	P$KEYW			;GET THE FIRST KEYWORD
	JUMPF	COMM.3			;INVALID COMMAND
	MOVSI	T1,-COMLEN		;GET NEGATIVE TABLE LENGTH FOR AOBJN
COMM.2:	HLRZ	T2,COMTAB(T1)		;GET THE CODE FOR THIS INDEX
	CAME	T2,S1			;MATCH?
	AOBJN	T1,COMM.2		;LOOP 'TILL COUNT EXPIRES OR MATCH IS FOUND
	JUMPGE	T1,E$IFC		;ILLEGALLY FORMATTED COMMAND
	HRRZ	T1,COMTAB(T1)		;GET DISPATCH ADDRESS FROM TABLE
	HRRZ	T2,@T1			;GET THE ROUTINE ADDRESS IN T2
	$CALL	GETPAG			;OUTPUT PAGE IN MO
	HLRZ	S1,@T1			;PLACE CODE TYPE IN S1
	STORE	S1,.MSTYP(MO),MS.TYP	;SAVE TYPE IN MESSAGE
	MOVEI	P3,.OHDRS(MO)		;FREE POINTER FOR OUTPUT
	$CALL	(T2)			;DISPATCH TO CORRECT ROUTINE
	JUMPF	COMM.3			;BAD RETURN..SHOW ERROR
	SKIPN	G$ERR			;ANY ERROR CODES SET
	$RETT				;RETURN
	JRST	COMM.5			;DUMP ERROR IN LOG
COMM.3:	$CALL	E$IFC			;ILLEGALLY FORMATTED COMMAND
	JRST	COMM.5			;PUT MESSAGE IN LOG
COMM.4:	$CALL	E$MTS			;MESSAGE TOO SHORT
COMM.5:	CAME	MO,G$OUTP		;WAS PAGE RELEASE ALREADY
	PJRST	RELPAG			;NO,,RELEASE PAGE AND RETURN
	$RETT				;JUST RETURN
COMM.6:	$CALL	FNDAPL			;FIND THE APPLICATION
	JUMPF	E$IFC			;INVALID FIELD IN COMMAND
COMM.7:	MOVE	T1,APLTAB+1(S2)		;GET COMMAND TABLE ENTRY
	HLRZM	T1,G$ARG1		;SAVE THE NAME
	SKIPN	T2,APLPID(S2)		;IS THERE A PID THERE
	  JRST	TAKABT			;INVALID APPLICATION SPECIFIED
	MOVE	T1,G$SND		;GET SENDERS PID
	MOVEM	T1,.MSCOD(MI)		;SAVE IN CODE WORD
	$CALL	SPGOUT			;SETUP THE OUTPUT PAGE
	MOVEI	S2,PAGSIZ		;SEND A PAGE
	MOVE	S1,T2			;GET THE PID
	$CALL	SNDPID			;SEND THE MESSAGE
	$RETIT				;OK..RETURN
	$CALL	RELPAG			;RELEASE THE PAGE
	PJRST	TAKABT			;DO TAKE FILE ABORT
SUBTTL	FNDAPL	Find an application

;THIS ROUTINE WILL FIND THE APPLICATION
;
;S1/	CODE OF APPLICATION
;
;RETURN TRUE:	S1/	CODE OF APPLICATION
;		S2/	OFFSET INTO CODE TABLE

FNDAPL:	MOVSI	S2,-NUMAPL		;GET NUMBER OF ENTRIES
	SKIPN	S2			;ANY ENTRIES
	$RETF				;NONE..RETURN FALSE
FNDA.1:	MOVE	T1,APLCOD(S2)		;GET THE FIRST ENTRY
	CAMN	S1,T1			;DOES IT MATCH
	$RETT				;MATCH..RETURN TRUE
	AOBJN	S2,FNDA.1		;TRY NEXT ENTRY
	$RETF				;NOT FOUND..RETURN FALSE
SUBTTL	Dispatch Table for Command Messages


;EACH ENTRY HERE HAS THE APPROPRIATE KEYWORD CODE IN THE LH AND
;THE ADDRESS OF THE ROUTINE FOR THAT COMMAND IN THE RIGHT HALF

COMTAB:
	.KYALI,,[.OMALI,,Q$ALGN##]	;ALIGN COMMAND
	.KYBKS,,[.OMBKS,,Q$BSPACE##]	;BACKSPACE COMMAND
	.KYCNC,,[.OMCAN,,Q$ABORT##]	;ABORT COMMAND
	.KYCLO,,[0,,CLSLOG]		;CLOSE COMMAND
	.KYCNT,,[.OMCON,,Q$CONTIN##]	;CONTINUE COMMAND
IFN	FTDN60,<
	.KYDEF,,[.OMDEF,,Q$DEFINE##]	;DEFINE COMMAND
>;END FTDN60
	.KYDEL,,[.OMDEL,,Q$CANCEL##]	;CANCEL COMMAND
	.KYDIS,,[.OMDIS,,DISABLE]	;DISABLE MESSAGE
	.KYDSM,,[.ODDSM,,Q$DISMOUNT##]	;DISMOUNT COMMAND
	.KYENA,,[.OMENA,,ENABLE]	;ENABLE MESSAGE
	.KYFWS,,[.OMFWS,,Q$FSPACE##]	;FORWARDSPACE COMMAND
	.KYHLD,,[.OMHLD,,Q$HOLD##]	;HOLD
	.KYIDN,,[.ODIDN,,Q$IDENTIFY##]	;IDENTIFY COMMAND
TOPS10<	.KYLOC,,[.ODLOC,,Q$LOCK##]>	;LOCK COMMAND
	.KYMOD,,[.OMMOD,,Q$MODIFY##]	;MODIFY COMMAND
	.KYMTN,,[.ODMTS,,Q$MOUNT##]	;MOUNT COMMAND FOR STRUCTURES
	.KYNXT,,[.OMNXT,,Q$NEXT##]	;[NXT] NEXT COMMAND
	.KYPAU,,[.OMPAU,,Q$PAUSE##]	;PAUSE COMMAND
TOPS10<	.KYREC,,[.ODREC,,Q$RECOGNIZE##] >;RECOGNIZE COMMAND
	.KYREL,,[.OMREL,,Q$RELEASE##]	;RELEASE, PROCESSED LIKE HOLD
	.KYREQ,,[.OMREQ,,Q$REQUE##]	;REQUEUE COMMAND
	.KYRPT,,[0,,REPORT]		;REPORT COMMAND
	.KYRTE,,[.OMRTD,,Q$ROUTE##]	;DEVICE ROUTE COMMAND
	.KYRSP,,[.OMRSP,,RESPON]	;RESPOND COMMAND
	.KYSND,,[.OMDSP,,SEND]		;SEND COMMAND
	.KYSET,,[.OMSET,,Q$SET##]	;SET COMMAND
	.KYSHW,,[.OMSHS,,SHOW]		;SHOW COMMAND ..DEFAULT TYPE OF STATUS
	.KYSHD,,[.OMSHT,,Q$SHUTDN##]	;SHUTDOWN COMMAND
	.KYSTA,,[.OMSTA,,Q$START##]	;START COMMAND
	.KYSUP,,[.OMSUP,,Q$SUPPRE##]	;SUPPRESS COMMAND
TOPS20 <.KYSWI,,[.ODSWI,,Q$SWITCH##]>	;SWITCH COMMAND
	.KYTAK,,[0,,TAKCMD]		;TAKE COMMAND
	.KYUDF,,[0,,Q$UNDE##]		;Undefine command
COMLEN==.-COMTAB
SUBTTL	TAKCMD	Setup for a TAKE command

;THIS COMMAND WILL SETUP THE OPR AS IN A TAKE COMMAND
;BY TURNING ON A FLAG IN THE OPR DATA BASE

TAKCMD:	$CALL	RELPAG			;RETURN THE PAGE
	MOVE	S1,G$OPRA		;GET OPR ADDRESS
	MOVX	S2,OP.TAK		;GET TAKE FLAG
	IORM	S2,OPR.FL(S1)		;SAVE THE FLAG
	$RETT				;AND RETURN


SUBTTL	TAKEND	Reset effects of TAKE command

;THIS ROUTINE WILL CLEAR TAKE FILE FLAGS IN OPR DATA BASE

TAKEND:	MOVE	S1,G$SND		;GET THE SENDER
	$CALL	VALOPR			;VALIDATE THE OPERATOR
	JUMPF	E$ONS			;OPR NOT SETUP
	MOVEM	S2,G$OPRA		;SAVE OPR ADDRESS
	MOVX	S1,OP.TAK!OP.ABT	;GET TAKE FLAG
	ANDCAM	S1,OPR.FL(S2)		;CLEAR THE FLAG
	$RETT				;RETURN

SUBTTL	TAKABT	Abort current TAKE command

;THIS ROUTINE WILL GENERATE ERROR FOR TAKE FILE ABORT
;WHERE G$ARG1 ALREADY CONTAINS THE ADDRESS OF THE STRING
;FOR THE ERROR MESSAGE

TAKABT:	MOVE	S2,G$OPRA		;GET OPR ADDRESS
	MOVE	S1,OPR.FL(S2)		;GET THE FLAGS
	TXNN	S1,OP.TAK		;WAS IT A TAKE COMMAND
	PJRST	E$IAP			;INVALID PROCESS..NOT RUNNING
	TXOE	S1,OP.ABT		;WAS ABORT SET
	$RETT				;YES...JUST RETURN
	MOVEM	S1,OPR.FL(S2)		;RESET THE FLAGS
	MOVE	S1,COM.CM(MI)		;GET OFFSET FOR TEXT
	ADDI	S1,ARG.DA(MI)		;POINTER TO TEXT
	MOVEM	S1,G$ARG2		;SAVE THE ADDRESS
	MOVE	S2,S1			;GET THE ADDRESS
	HRLI	S2,(POINT 7,0)		;MAKE A POINTER
TAKA.1:	ILDB	S1,S2			;GET A BYTE
	JUMPE	S1,TAKA.2		;NULL EXIT
	CAIE	S1,.CHCRT		;IS IT A CARRIAGE RETURN
	JRST	TAKA.1			;TRY NEXT ONE
	SETZ	S1,0			;MAKE A NULL
	DPB	S1,S2			;REPLACE WITH A NULL
TAKA.2:	PJRST	E$TAB			;TAKE ABORT
SUBTTL	GETPAG	Setup MO with address of output message

;THIS ROUTINE WILL GET A PAGE ADDRESS SETUP IN MO BY GETTING A NEW PAGE.

GETPAG:: $CALL	M%GPAG			;GET A PAGE
	MOVE	MO,S1			;SAVE ADDRESS IN MO
	$RETT				;RETURN TRUE





SUBTTL	RELPAG	Release output page

;SETS UP SAVED WORD G$OUTP WITH ADDRESS OF PAGE

RELPAG:: MOVE	S1,MO			;get the current page pointer
	$CALL	M%RPAG			;RELEASE THE PAGE
	SETZM	MO			;clear pointer to minimize confusion
	$RETT				;RETURN TRUE
SUBTTL	ERRALL	Error Message to All


;This routine will Build the ACK for an error and send it to
;all Operators on the system


ERRALL:: LOAD	S1,G$JOB		;GET JOB NUMBER
	$CALL	GETJOB			;GET JOB INFO
	$CALL	BLDACK			;BUILD THE ACK
	SETOM	S1			;SEND TO ALL
	SETZM	G$ERR			;CLEAR ERROR WORD
	SETOM	G$ASND			;FORCE MESSAGE OUT
	PJRST	SNDAOP			;SEND TO ALL OPERATOR
SUBTTL	DISABLE/ENABLE commands

;THE ENABLE AND DISABLE COMMANDS ARE COMPLEMENTS OF EACH OTHER
;FOR ALL ACTIONS

ENABLE:	TDZA	P1,P1			;Clear flag for enable
DISABL:	SETOM	P1			;Set flag for disable
	$CALL	P$KEYW			;GET A KEYWORD
	$RETIF				;ERROR..CHECK OTHER OPTIONS
	MOVEI	S2,ENADSP		;ENABLE DISPATCH TABLE
	$CALL	TABSRC			;SEARCH THE TABLE
	$RETIF				;ERROR..RETURN
	MOVE	S1,G$SND		;GET SENDER'S PID
	PJRST	(S2)			;PROCESS ROUTINE AND RETURN


ENADSP:	$STAB
	.KYAVR,,Q$ETAPE##		;ENABLE AVR
	.KYQUE,,ENAQUE			;ENABLE QUEUE REQUESTS
	.KYLGG,,ENALOG			;ENABLE LOGGING
	.KYOPD,,ENAODP			;ENABLE OUTPUT-DISPLAY
TOPS20<	.KYCLS,,ENACLS>			;ENABLE CLASS SCHEDULER
TOPS20<	.KYRET,,ENARET>			;ENABLE FILE-RETREVIAL WAITS
TOPS10<	.KYASR,,Q$ESTR##>		;ENABLE ASR
	$ETAB

ENAQUE:	$CALL	VALOPR			;INSIST ON OPR
	JUMPF	E$IPE			;NOT OPR, QUIT
	MOVE	S1,G$HOST		;Get host node name
	$CALL	OPRENB			;Must be system or host
	$RETIF				;Return on failure
	PJRST	CMDEND			;FINISH COMMAND AND SEND
SUBTTL	ENAODP	ENABLE OUTPUT display command

ENAODP:	$CALL	P$KEYW			;GET A KEYWORD
	$RETIF				;ERROR..RETURN

	MOVEI	S2,DSPTYP		;Get address of table
	$CALL	TABSRC			;Search for keword
	JUMPT	ENAO.6			;Not object, go check keywords

;  Here if object type of display control

	MOVE	P3,S1			;Save the keyword type
	SETZ	P2,			;No switches seen
ENAO.1:	$CALL	P$SWIT			;CHECK FOR A SWITCH
	JUMPF	ENAO.2			;Finished on last switch
	CAIN	S1,.SWJOB		;IS IT JOB MESSAGES
	IORX	P2,WO.JOB		;Yes
	CAIN	S1,.SWOAM		;OPERATOR ACTION MESSAGES?
	IORX	P2,WO.OAC		;Yes
	CAIN	S1,.SWOTH		;WAS IT OTHER?
	IORX	P2,WO.EVM		;Yes
	JRST	ENAO.1			;Try for another switch
ENAO.2:	CAIN	P2,0			;Any switches seen?
	MOVX	P2,WO.ALL		;No..setup all
	CAIN	P3,.KYALM		;Want all message types
	JRST	[$CALL	ENAO.8		;Yes - Process other types
		MOVSI	P3,-<.OTMAX+NUMAPL+1>	;Do for all types
		JRST	ENAO.3]		;Continue processing		
ENAO.3:	HRRZ	S1,P3			;Get keyword type
	MOVE	S2,P2			;Get flags to set or clear
ENAO.4:	SKIPN	P1			;Want to Enable
	$CALL	SETODP			;Yes..go do it
	SKIPE	P1			;No..want to disable
	$CALL	CLRODP			;Yes..go do it
	$RETIF				;Return on failure
	AOBJN	P3,ENAO.3		;Repeat for all types
	PJRST	E$ODM			;Return the ACK
;  Here if just a general type of display message

ENAO.6:	MOVE	S1,S2			;Get the value
	$CALL	MAPBIT			;Map it to a bit
	ADD	S1,G$OPRA		;Add the base address of the OPR entry
	MOVE	P3,OPR.DP(S1)		;Get the word to be changed
	SKIPE	P1			;Test to set or clear
	TDZA	P3,S2			;Disable - clear
	TDO	P3,S2			;Enable - set
	MOVEM	P3,OPR.DP(S1)		;Return the value
	PJRST	E$ODM			;Return the ACK

;  Here if all general types

ENAO.8:	MOVSI	S1,.OPDMX		;Get number of words to change
	HRR	S1,G$OPRA		;Get the base

ENAO.9:	SETOM	OPR.DP(S1)		;Default to enable all
	SKIPE	P1			;Test to set or clear
	SETZM	OPR.DP(S1)		;Disable - clear
	AOBJN	S1,ENAO.9		;Go back for more
	$RET				;Continue all processing

DSPHLP:	ROT	S2,			;Instruction to be executed above

DSPTYP:	$STAB
	.KYCHK,,.QBCHK			;BUGCHK type of message
	.KYINF,,.QBINF			;BUGINF
	.KYSYM,,.QBSYS			;General system message
	$ETAB

SUBTTL	MAPBIT	MAP BIT based on value

;  This routine, given a value returns the word and bit number for that
;  value, where the value 1 maps to bit 0 and value 37 maps to bit 0
;  word 1.

;  Accepts	S1 / Value (assumed to be positive, non-zero number)

;  Returns	S1 / Word number
;		S2 / Bit mask (one bit set)

;  Uses T1

MAPBIT:	SUBI	S1,1			;Adjust to start with 0 for word count
	IDIVI	S1,^D36			;Get word count and remainder
	MOVN	T1,S2			;Set up rotation value
	HRLZI	S2,400000		;Get a bit
	ROT	S2,(T1)			;Rotate
	$RET

;SETODP	Set flags to ENABLE output display
;CLRODP Clear flags to DISABLE output display

;Accepts	S1/ Object type
;		S2/ Flags

SETODP:	MOVE	TF,[IORM T1,OPR.OF(S1)]	;Set the flags
	SKIPA
CLRODP:	MOVE	TF,[ANDCAM T1,OPR.OF(S1)] ;Clear the flags
	MOVE	T1,S2			;Save the flags
	CAILE	S1,APLBEG		;Application object type?
	SUBI	S1,APLBEG-.OTMAX	;Yes..compute object offset
	CAIL	S1,.KYUSR		;Check range
	CAILE	S1,NUMAPL+.OTMAX
	PJRST	E$IFC			;Bad command message
	IDIVI	S1,<^D36/<WID(WO.ALL)>>	;Compute word offset
	IMULI	S2,<WID(WO.ALL)>	;Compute bit offset
	MOVNS	S2			;Force shift right
	LSH	T1,0(S2)		;Position the mask
	ADD	S1,G$OPRA		;Add Base of OPR entry
	XCT	TF			;Set/Clear the flag
	$RETT				;Return to caller

SUBTTL	ENALOG	ENABLE/DISABLE LOG command

;THIS ROUTINE WILL EITHER OPEN OR CLOSE THE LOG FILE WHERE POSSIBLE
;ELSE GENERATE AN ERROR

ENALOG:	MOVX	S1,FWMASK		;POINT TO ALL NODES
	$CALL	OPRENB			;MUST BE SYSTEM
	$RETIF
	$CALL	P$CFM			;IS THERE A CONFIRM?
	$RETIF				;NO..BAD COMMAND
	SKIPN	P1			;DISABLING?
	  JRST	ENAL.1			;ENABLE LOG
	$CALL	L$REL##			;RELEASE THE LOG FILE
	JUMPF	.RETT			;ERROR RETURN.. MESSAGE GENERATED
	SETZM	LOGINT##		;LOGGING DISABLED
	$CALL	E$LFC			;SET LOG FILE CLOSED
ENAL.0:	$CALL	RELPAG			;RELEASE THE PAGE
	PJRST	ERRALL			;ERROR MESSAGE TO ALL OPERATORS
ENAL.1:	$CALL	L$OPNL##		;OPEN THE LOG
	JUMPF	.RETT			;ERROR..RETURN
	SETOM	LOGINT##		;MARK LOGGING ENABLED
	$CALL	E$OLO			;ORION LOG FILE OPEN
	PJRST	ENAL.0			;FINISH IT OFF

SUBTTL	CLSLOG	Process the CLOSE LOG command

;THIS ROUTINE WILL PROCESS THE CLOSE COMMAND AND CLOSE THE LOG FILE

CLSLOG:	MOVX	S1,FWMASK		;POINT TO ALL NODES
	$CALL	OPRENB			;MUST BE SYSTEM OPR
	$RETIF
	$CALL	L$CLOS##		;CLOSE THE LOG
	$RETT

SUBTTL	ENACLS	ENABLE CLASS-SCHEDULING commands (TOPS20)


;CLASS SCHEDULER SETTING FOR THE -20

TOPS20<
ENACLS:	MOVX	S1,FWMASK		;POINT TO ALL NODES
	$CALL	OPRENB			;MUST BE SYSTEM
	$RETIF
	SETZM	P2			;SCHEDULER VALUES
ENAC.1:	$CALL	P$CFM			;END OF COMMAND
	JUMPT	ENAC.3			;DO THE FUNCTION
	$CALL	P$SWIT			;CHECK FOR A SWITCH
	$RETIF				;ERROR..RETURN
	CAIE	S1,.SWCAS		;WAS IT CLASS ASSIGNMENTS
	JRST	ENAC.2			;NO..TRY WINDFALL
	$CALL	P$KEYW			;GET THE KEYWORD
	$RETIF				;ERROR..RETURN
	SETZM	T2			;CLEAR INDICATOR WORD
	CAIN	S1,.KYACT		;IS IT BY ACCOUNT?
	MOVX	T2,SK%ACT		;GET THE ACCOUNT FLAG
	IOR	P2,T2			;PLACE VALUES IN P2
	JRST	ENAC.1			;CHECK FOR END
ENAC.2:	CAIE	S1,.SWWFL		;WINDFALL?
	$RETF				;NO..BAD COMMAND
	$CALL	P$KEYW			;GET THE KEYWORD
	$RETIF				;ERROR..RETURN
	SETZM	T2			;CLEAR THE VALUE
	CAIN	S1,.KYWHD		;WAS IT WITHHELD
	MOVX	T2,SK%WDF		;WITHHOLD WINDFALL
	IOR	P2,T2			;PLACE VALUE IN P2
	JRST	ENAC.1			;CHECK FOR THE END
ENAC.3:	SKIPE	P1			;ENABLE COMMAND
	MOVX	P2,SK%STP		;TURN OF SCHEDULER
	MOVX	S1,.SKICS		;GET THE FUNCTION
	MOVEI	S2,T1			;BLOCK IN T1
	MOVEI	T1,2			;LENGTH OF THE BLOCK
	MOVE	T2,P2			;GET THE DATA
	SKED%				;DO THE FUNCTION
	  ERJMP	ENAC.4			;TRAP ERROR
	MOVEI	S1,[ASCIZ/enabled/]	;ENABLED
	SKIPE	P1			;ENABLING?
	MOVEI	S1,[ASCIZ/disabled/]	;DISABLED
	MOVEM	S1,G$ARG1		;SAVE THE ERROR
	PJRST	E$CSE			;CLASS SCHEDULER ENABLED/DISABLED
ENAC.4:	MOVE	S1,[EXP -2]		;LAST -20 ERROR
	MOVEM	S1,G$ARG1		;SAVE THE ARGUMENT
	PJRST	E$CSF			;CLASS SCHEDULER ERROR
>;END TOPS20
SUBTTL	ENARET	ENABLE FILE-RETRIEVAL commands (TOPS20)

TOPS20<
ENARET:	MOVE	S1,G$HOST		;GET LOCAL HOST
	$CALL	OPRENB			;Check OPR privs
	$RETIF
	MOVEI	T1,[ASCIZ/enable/]	;GET THE ENABLE
	SKIPE	P1			;ENABLE OR DISABLE?
	MOVEI	T1,[ASCIZ/disable/]	;DISABLING
	MOVEM	T1,G$ARG1		;SAVE THE VALUE
	MOVE	S2,P1			;VALUE SAME AS ENABLE/DISABLE VALUE
	MOVEI	S1,.SFRTW		;SET FUNCTION CODE
	SMON				;SET THE VALUE
	ERJMP	E$RWF			;TRAP THE ERROR AND GENERATE A MESSAGE
	PJRST	E$FRW			;FILE RETREVIAL WAITS MODIFIED
>;END TOPS20
SUBTTL	NOTIFY	Write message to terminal for quasar

;OUTPUT TO TERMINAL FOR QUASAR

NOTIFY:	$CALL	CHKWHL			;MUST BE WHEEL
	JUMPF	E$NRW			;NOTIFY REQUIRES WHEEL
	MOVEI	S1,.OHDRS(MI)		;SETUP POINTER TO BLOCK
	$CALL	P$SETU			;SETUP THE PARSER POINTER
	MOVX	S1,NT.MLU		;NOTIFY VIA MAIL
	TDNE	S1,.OFLAG(MI)		;IS IT SET?
	JRST	NOTI.1			;YES..DO MAIL
	$CALL	L$NTFY##		;LOG THE NOTIFY
	$CALL	P$NARG			;GET THE NEXT ARGUMENT
	MOVE	P1,S2			;SAVE THE BLOCK ADDRESS
	CAIE	S1,.JOBID		;JOB ID BLOCK
	PJRST	E$IFC			;BAD MESSAGE
	LOAD	S1,JBI.JB(P1)		;GET THE JOB NUMBER
	$CALL	GETUSR			;GET USER INFO
	$RETIF				;NOT THERE..RETURN
	LOAD	S1,JBI.LI(P1)		;GET LOGGED IN TIME
	CAME	S1,JOBJLT		;SAME JOB
	PJRST	E$JDE			;JOB TO NOTIFY NOT THERE
	$CALL	P$NEXT			;GET TO NEXT FIELD
	$CALL	P$TEXT			;TEXT BLOCK
	JUMPF	E$IFC			;BAD MESSAGE
	MOVEI	S2,ARG.DA(S1)		;POINT TO THE DATA
	PUSHJ	P,NOTCHK		;CHECK TO SEE IF USER WANTS MESSAGE
	  SKIPF				;DOESN'T WANT IT
	MOVE	S1,JOBTTY		;GET LINE NUMBER
	$CALL	SNDTTY			;SEND THE MESSAGE
	$RETT				;RETURN
NOTI.1:
TOPS10<
	$RETT				;RETURN FOR NOW
>;END TOPS10
TOPS20<
	$CALL	P$TEXT			;GET THE TEXT
	JUMPF	E$IFC			;ILLEGALLY FORMATTED COMMAND
	HRROI	S2,ARG.DA(S1)		;POINTER TO TEXT
	MOVEM	S2,NFYTXT		;NOTIFY TEXT POINTER
	$CALL	P$DIR			;GET THE DIRECTORY
	JUMPF	E$IFC			;BAD COMMAND
	MOVEM	S1,NFYDIR		;NOTIFY DIRECTORY
	$CALL	P$NFLD			;GET NEXT FIELD DATA
	JUMPF	E$IFC			;SHOULDN'T FAIL
	CAIE	S1,.NTSUB		;IS IT THE SUBJECT
	PJRST	E$IFC			;BAD COMMAND
	HRROI	S1,ARG.DA(S2)		;GET THE DATA POINTER
	MOVEM	S1,NFYSUB		;NOTIFY SUBJECT
	$CALL	MLINIT##		;INIT THE CALL
	MOVEI	S1,NFYDIR		;GET ADDRESS OF BLOCK
	MOVEI	S2,1			;DEC MAIL
	$CALL	MLTOWN##		;MAIL IT
	$CALL	MLDONE##		;FINISHED IT..
	$RETT				;RETURN
>;END TOPS20


; Check to see if a user wants notify junk to come out on his/hers/its TTY
; Call:	PUSHJ	P,NOTCHK
;
; TRUE return:	user wants notify
; FALSE return:	user doesn't want notify
;
NOTCHK:
TOPS10	<				;TOPS-10 ONLY
	MOVN	TF,JOBNUM		;GET NEGATIVE JOB NUMBER
	JOBSTS	TF,			;READ JOB STATUS
	  $RETF				;NOT THERE
	TXNE	TF,JB.UML		;AT MONITOR LEVEL ?
	$RETT				;YES - OK TO SEND
	$SAVE	<T1,T2>			;SAVE SOME ACS
	MOVE	TF,[2,,T1]		;SET UP UUO
	MOVX	T1,.TOSND		;LOAD FUNCTION CODE
	MOVE	T2,JOBTTY		;LOAD TTY NUMBER
	TXO	T2,.UXTRM		;OFFSET BY UNIVERSAL DEVICE INDEX
	TRMOP.	TF,			;READ TTY GAG SETTING
	  MOVEI	TF,.-.			;CAN'T - ASSUME GAGGED
	JUMPE	TF,.RETF		;TTY GAGGED ?
	$RETT				;NO
>					;END OF TOPS-10 CONDITIONAL

TOPS20	<				;TOPS-20 ONLY
	$RETT				;RETURN
>					;END OF TOPS-20 CONDITIONAL
SUBTTL	SEND	Process the SEND command

SEND:	$CALL	P$KEYW			;Get the KEYWORD
	$RETIF				;Return on failure
	MOVEI	S2,SNDDSP		;Point to the possibles
	$CALL	TABSRC			;Find the right one
	$RETIF				;Return on failure
	PJRST	0(S2)			;Dispatch to processor

SNDDSP:	$STAB
	.KYALL,,SNDALL			;SEND ALL
	.KYBAT,,SNDBAT			;SEND BATCH-STREAM
	.KYJOB,,SNDJOB			;SEND JOB
	.KYOPR,,SENDOP			;SEND OPERATOR
	.KYTRM,,SNDTRM			;SEND TERMINAL
	$ETAB


SNDBAT:	$CALL	P$PREV			;Point parse before keyword
	$CALL	BLDOBJ			;Build the object block
	 $RETIF
	$CALL	BLDSND			;Build the message to send
	$RETIF				;Return on failure
	MOVX	S1,.OMSND		;Set the message type
	STORE	S1,.MSTYP(MO),MS.TYP	;STORE IN THE MESSAGE
	$CALL	SNDQSR			;Send it off
	$RET				;And return

SNDJOB:	$CALL	P$NUM			;Get terminal number
	$RETIF				;Return on failures
	MOVX	S2,JI.TNO		;Get terminal number
	$CALL	I%JINF
	JUMPF	E$CSU			;Can't send to user
	CAMN	S2,[EXP -1]		;Detatched?
	PJRST	E$CSU			;Yes..Can't send to user
	SKIPA	S1,S2			;Terminal number to S1
SNDTRM:	$CALL	P$NUM			;Get Terminal number
	$RETIF				;Return on failure
	$SAVE	<P1>			;Preserve an AC
	MOVE	P1,S1			;Save the number
	$CALL	BLDSND			;Build the message to send
	MOVEI	S2,ARG.DA(S1)		;Point to message
	MOVE	S1,P1			;Restore terminal numbre
	$CALL	SNDTTY			;Send it off
	JUMPF	E$CSU			;Can't send to user
	PJRST	E$SCC			;Say send complete

SUBTTL	SNDALL	Process SEND ALL command

SNDALL:	$SAVE	<P1>			;Preserve an AC
	$CALL	DEFNOD			;Get default node for OPR
	MOVE	P1,S1			;Store in P1
SNDAL1:	$CALL	P$SWITCH		;Check for switches
	JUMPF	SNDAL2			;None there..use default
	CAIE	S1,.SWNOD		;Was it /NODE?
	$RETF				;No..return the failure
	$CALL	P$NODE			;Yes..get the specified node
	MOVEM	S1,G$ARG1		;Save for error text
	MOVE	P1,S1			;Save the node name for the future
	$CALL	TTYNOD			;Check for terminal lines and ck. node
	JUMPF	E$INT			;No dice..return the error
SNDAL2:	MOVE	S1,P1			;Get node to check
	$CALL	OPRENB			;Check the privs
	$RETIF				;Return on failure
	$CALL	BLDALL			;Build the message
	$RETIF				;Return on failure
	$CALL	SNDALX			;Do the send
	$CALL	RELPAG			;Release the page
	PJRST	E$SCC			;Ack the operator


SUBTTL	DEFNOD	Routine to return default node for OPR

;DEFNOD return the default node to associate with this OPR.
;If the OPR has system privs the default is All nodes [-1]
;else the physically located node is the default

;Accepts	G$OPRA setup from received message

;Returns	S1/ Physically located node or [-1] for all


DEFNOD:	MOVE	S1,G$OPRA		;Get OPR address
	$CALL	O$SYSTEM		;System OPR?
	JUMPT	[MOVX	S1,FWMASK	;Yes..default to ALL
		 JRST	DEFND1]		;Go return
	MOVE	S1,G$OPRA		;No..get OPR address
	MOVE	S1,OPR.ND(S1)		;Get Node data address
	MOVE	S1,NOD.NM(S1)		;Get OPR's default
DEFND1:	$RET
SUBTTL	TTYNOD	Check for terminals on node

;  This routine checks for any terminals on a node specified.

;  For TOPS-10, it checks for any terminals on the node.
;  For TOPS-20, it checks that the node specified is the host
;  node since there is no terminal concentration currently.

;  Calls:	None
;  Needs:	None
;  Uses:	T regs.  (TOPS-10 only)
;  Args:	S1 / Node name/number
;  Returns:	True if terminals exist, false otherwise.

TTYNOD:
TOPS10<

;  Need to set up an argument block for NODE. uuo using the T registers

	MOVEI	T1,4			;Length of argument block
	MOVE	T2,S1			;Get the node name
	SETZM	T3			;For no good reason, this MUST be 0!
	HRRZI	T4,.TYTTY		;Check for terminal lines
	MOVE	S1,[XWD .NDRCI,T1]	;Set it up
	NODE.	S1,			;Try it out
	  $RETF				;Someone's lying
	HLRZ	S1,T4			;Get the number of terminals
	SKIPLE	S1			;Do we have any?
	$RETT				;Yes
	$RETF				;No
> ; End of TOPS10

TOPS20<
	CAME	S1,G$HOST		;Only allow the system name as node
	$RETF				;Confused operator
	$RETT
> ; End of TOPS20
SUBTTL	SENDOP	Send to operator command

;THIS ROUTINE WILL BUILD AND QUEUE UP A MESSAGE TO OPRS
;BASED ON THE SEND COMMAND

SENDOP:	SETOM	G$ASND			;FORCE MESSAGE TO OPRS
	$CALL	P$SWIT			;CHECK FOR A SWITCH
	JUMPT	SENO.1			;CHECK OUT SWITCH
	MOVE	S1,G$OPRA		;GET OPERATOR ADDRESS
	MOVE	S2,OPR.ND(S1)		;GET NODE ADDRESS
	MOVE	P2,NOD.NM(S2)		;GET NODE NAME
	CAME	P2,G$HOST		;IS IT CENTRAL SITE?
	JRST	SENO.2			;NO..USE LOCAL NODE
	$CALL	BLDSND			;BUILD THE SEND
	$RETIF				;ERROR RETURN
	SETOM	S1			;SEND TO ALL OPERATORS
	$CALL	SNDAOP			;SEND TO ALL
	JRST	SENO.3			;Go to return
SENO.1:	CAIE	S1,.SWNOD		;WAS IT A NODE
	$RETF				;NO..ERROR..RETURN
	$CALL	P$NODE			;GET THE NODE
	$RETIF				;ERROR ..RETURN
	MOVE	P2,S1			;SAVE THE NODE VALUE
SENO.2:	MOVEM	P2,G$ARG1		;SAVE THE NODE NAME
	MOVE	S1,P2			;GET NODE NAME
	$CALL	FNDNOD			;FIND THE NODE
	JUMPF	E$NON			;NO OPERATORS AT NODE
	MOVE	P2,S2			;GET NODE ENTRY ADDRESS
	$CALL	BLDSND			;BUILD THE SEND MESSAGE
	$RETIF				;ERROR..ABORT NOW
	SETOM	NOALTN			;NO ALTERNATE NODES
	MOVE	S1,P2			;GET NODE ENTRY ADDRESS
	$CALL	SNDNAL			;SEND TO ALL OPERATORS NO ALTERNATES
	JUMPF	E$NON			;NO OPERATORS AT NODE AND RETURN
SENO.3:	PJRST	E$SCC			;Send command complete and return
SUBTTL	BLDSND	Build the SEND text

; Here to build the SEND text for all types of sends except TOPS-10
; SEND ALL commands.
;
TOPS20	<BLDALL:>			;TOPS-20 only
BLDSND:	$CALL	BLDINI			;SETUP FOR BUILDING SEND TEXT STRING
	$RETIF				;PROPAGATE ERROR BACK TO CALLER
	$TEXT	(BLDRTN,<^M^J^C/G$NOW/ From operator ^I/(S2)/:
	=^7/[76]/^T/1(S1)/
^0>)
	JRST	BLDFIN			;FINISH UP

NODTXT:	ITEXT	(<^N/NOD.NM(T1)/>)
TTYTXT:	ITEXT	(<terminal ^O/OPR.TN(T2)/>)


SUBTTL	BLDALL	Build the TOPS-10 SEND ALL text


TOPS10	<				;TOPS-10 only
; Here to build the SEND text for TOPS-10 SEND ALL commands.
;
BLDALL:	$CALL	BLDINI			;Setup text pointers
	$RETIF				;Propagate error back to caller
	$TEXT	(BLDRTN,<^T/1(S1)/>)	;Store the string
	$RETT				;Go finish up
>;END of TOPS-10 conditional


; Setup building of the SEND text string
;
BLDINI:	$CALL	P$TEXT			;GET THE TEXT
	$RETIF				;NO TEXT..RETURN
	HRLI	T1,(POINT 7,0)		;SETUP BYTE POINTER
	HRRI	T1,ARG.DA(P3)		;ADDRESS FOR THE TEXT
	MOVEM	T1,SNDPTR		;SAVE THE SEND BYTE POINTER
	MOVE	T2,G$OPRA		;GET OPR ADDRESS
	MOVE	T1,OPR.ND(T2)		;GET NODE ADDRESS
	MOVE	T3,G$HOST		;GET NODE OF CENTRAL SITE
	MOVEI	S2,TTYTXT		;ASSUME TTYTXT
	CAME	T3,NOD.NM(T1)		;CENTRAL SITE
	MOVEI	S2,NODTXT		;NO..USE NODE TEXT
	$RETT				;RETURN


; Here to finish up the building of SEND text strings
;
BLDFIN:	HRRZ	S2,SNDPTR		;GET THE ADDRESS
	AOS	S1,S2			;BUMP AND SAVE IN S1
	SUB	S2,P3			;COMPUTE THE BLOCK SIZE
	MOVEI	S1,.CMTXT		;GET BLOCK TYPE
	MOVE	T4,P3			;GET TEXT ADDRESS
	$CALL	ARGRTN			;SAVE THE ARGUMENT
	ANDI	P3,777			;GET THE MESSAGE LENGTH
	STORE	P3,.MSTYP(MO),MS.CNT	;SAVE THE MESSAGE COUNT
	MOVE	S1,T4			;GET TEXT ADDRESS
	$RETT				;RETURN TRUE

BLDRTN:	IDPB	S1,SNDPTR		;SAVE THE BYTE
	$RETT				;RETURN TRUE
SUBTTL	SNDALX	Send message to all terminals



; TOPS-10 SEND ALL command support
;
TOPS10	<				;TOPS-10 only
SNDALX:	MOVE	S1,[POINT 7,SNDTXT]	;Byte pointer to store SEND ALL text
	MOVEM	S1,STRBP		;Store it
	MOVEI	S1,^D72			;# characters maximum
	MOVEM	S1,STRCT		;Store byte count
	MOVEI	T1,[ITEXT (<^O/P1/_>)]	;Assume node number
	TLNE	P1,770000		;Is it?
	MOVEI	T1,[ITEXT(<^W/P1/_>)]	;No - a node name
	CAMN	P1,[-1]			;Was it ALL?
	MOVEI	T1,[ITEXT (<ALL:>)]	;Yes - message to all nodes
	$TEXT	(SNDCHR,<SEND ^I/@T1/^T/ARG.DA(P3)/^M^A>) ;Monitor SEND command
	MOVX	S1,.TOTYP		;TRMOP. to stuff text down TTY's throat
	MOVE	S2,FRCLIN		;Send text to FRCLIN
	MOVEI	S2+1,SNDTXT		;Point to text
	MOVX	TF,<3,,S1>		;Set up for CALLI
	TRMOP.	TF,			;Do SEND ALL command
	  $RETF				;Can't
	$RETT				;Return sucessful

SNDCHR:	SOSG	STRCT			;Count bytes
	MOVX	S1,.CHCRT		;Load a carriage return to end buffer
	IDPB	S1,STRBP		;Store character
	CAXE	S1,.CHCRT		;End of line ?
	$RETT				;No - return
	MOVX	S1,.CHNUL		;Get a <NUL>
	IDPB	S1,STRBP		;Make sure text is properly terminated
	$RETF				;Stop $TEXT
>;END of TOPS-10 conditional



; TOPS-20 SEND ALL command support
;
TOPS20	<				;TOPS-20 only
SNDALX:	HRROI	S2,ARG.DA(S1)		;This gets the text as remembered
					; from BLDFIN
	SETOM	S1			;SEND TO ALL TERMINALS
	TTMSG				;SEND THE TEXT
	ERJMP	.RETF			;FAILED RETURN FALSE
	$RETT				;RETURN TRUE
>;END of TOPS-20 conditional
SUBTTL	SNDTTY	Send a message to a terminal

;THIS ROUTINE WILL SEND A MESSAGE  TO A TERMINAL
;
;CALL	S1/	TERMINAL NUMBER
;	S2/	ADDRESS OF TEXT


;CHECK IF TERMINAL WANTS MESSAGES

SNDTTY:

TOPS10<	$CALL	.SAVET			;SAVE AC'S
	TXO	S1,.UXTRM		;MAKE SURE IT IS A UDX
	MOVX	T1,<3,,T2>		;SET UP ARG POINTER
	MOVX	T2,.TODSP		;LOAD OUTSTR FUNCION
	MOVE	T3,S1			;GET TERMINAL NUMBER
	MOVE	T4,S2			;GET MESSAGE ADDRESS
	TRMOP.	T1,			;OUTPUT THE STRING
	  PJRST	E$CSU			;GIVE AN ERROR
	$RETT				;RETURN TRUE
>;END TOPS10

TOPS20<	TRO	S1,400000		;FLAG IT AS A TERMINAL NUMBER
	HRRO	S2,S2			;POINT AT THE TEXT
	TTMSG				;SEND THE TEXT
	ERJMP	.RETF			;FAILED ..RETURN FALSE
	$RETT				;RETURN TRUE
>;END TOPS20
SUBTTL	SHOW	SHOW Command

SHOW:	$CALL	P$KEYW			;GET A KEYWORD
	$RETIF				;MUST BE A KEYWORD..ELSE RETURN
	MOVSI	S2,-SHWLEN		;MAKE AOBJN POINTER TO DISPATCH TABLE
SHOW.1:	HLRZ	T1,SHWDSP(S2)		;GET AN ENTRY FROM TABLE
	CAMN	T1,S1			;DOES THIS ENTRY MATCH?
	JRST	SHOW.2			;YES, GO PROCESS IT
	AOBJN	S2,SHOW.1		;NO, LOOK AT NEXT
	$RETF				;NO MATCH, BAD COMMAND
SHOW.2:	HRRZ	S2,SHWDSP(S2)		;GET THE ADDRESS TO DISPATCH TO
	JRST	(S2)			;EXECUTE THE ROUTINE

SHWDSP:
	.KYSTS,,Q$SHWS##		;SHOW STATUS
	.KYMSG,,SHWMSG			;SHOW MESSAGES
	.KYQUE,,Q$SHWQ##		;SHOW QUEUES
	.KYPRM,,Q$SHWP##		;SHOW PARAMETERS
	.KYOPR,,SHWOPR			;SHOW OPERATORS
	.KYRTE,,Q$SHWR##		;SHOW ROUTE TABLES
	.KYCTL,,Q$SHWC##		;SHOW CONTROL-FILE
TOPS20<	.KYSCH,,SHWSCH >		;SHOW SCHEDULER
TOPS10<	.KYSLS,,Q$SLST## >		;SHOW SYSTEM LISTS
TOPS10<	.KYALC,,Q$SALC## >		;SHOW ALLOCATION
SHWLEN==.-SHWDSP

SUBTTL	SHWOPR	Show operators command

;THIS ROUTINE WILL DISPLAY OPR ON SYSTEM TO OPR ISSUING THE COMMAND

SHWOPR:	MOVX	S1,.OMDSP		;SETUP OPR DISPLAY MESSAGE
	STORE	S1,.MSTYP(MO),MS.TYP	;SAVE THE TYPE COUNT
	$CALL	P$SWIT			;CHECK FOR A SWITCH
	JUMPF	SHWO.1			;MUST BE CRLF
	CAIE	S1,.SWNOD		;WAS IT A NODE
	$RETF
	$CALL	P$NODE			;GET THE NODE VALUE
	$RETIF				;INVALID MESSAGE
	MOVEM	S1,G$ARG1		;SAVE NODE NAME
	$CALL	FNDNOD			;VALIDATE THE NODE
	JUMPF	E$NON			;NO SUCH NODE
	MOVE	P1,S1			;SAVE THE NODE ADDRESS
	MOVEI	S1,SHOT.1		;SHOW OPERATOR TEXT
	$CALL	SHWMTX			;SHOW MESSAGE TEXT POINTER
	MOVE	S2,P1			;PUT NODE ADDRESS IN S2
	$CALL	OPRLST			;OPERATORS AT NODE
	JUMPT	FINSHW			;HAVE SOME..SEND IT
	PJRST	E$NON			;NO MESSAGES FOR THE NODE
SHWO.1:	MOVEI	S1,SHOT.1		;SHOW OPERATOR TEXT
	$CALL	SHWMTX			;SHOW MESSAGE TEXT
	SETZM	P1			;CLEAR MESSAGES FLAG
	MOVE	S1,G$NODL		;GET NODE LIST NUMBER
	$CALL	L%FIRST			;GET FIRST ENTRY
	JUMPF	E$NOD			;No operators defined
SHWO.2:	$CALL	OPRLST			;OPERATORS AT NODE
	SKIPF				;NO MESSAGES SKIP FLAG SETTING
	SETOM	P1			;MESSAGES FOUND
	MOVE	S1,G$NODL		;GET NODE LIST NUMER
	$CALL	L%NEXT			;GET NEXT ENTRY
	JUMPT	SHWO.2			;PROCESS MESSAGES
	SKIPE	P1			;SEND ANY MESSAGES
	JRST	FINSHW			;YES..SEND MESSAGE
	PJRST	E$NOD			;NO OPERATORS DEFINED


SHWMTX:	MOVE	T1,G$NOW		;GET CURRENT TIME
	MOVEM	T1,ARG.DA(S1)		;SAVE TIME IN THE BLOCK
	MOVS	T1,S1			;SOURCE TEXT ADDRESS
	HRR	T1,P3			;DESTINATION ADDRESS
	LOAD	T2,(S1),AR.LEN		;LENGTH OF THE BLOCK
	ADD	P3,T2			;GET END ADDRESS
	BLT	T1,-1(P3)		;MOVE THE TEXT
	AOS	.OARGC(MO)		;BUMP ARGUMENT COUNT
	$RETT				;RETURN

SHMT.1:	XWD	SHLTXT,.ORDSP		;TEXT BLOCK
	BLOCK	1			;ROOM FOR TIME STAMP
	ASCIZ/		-- System messages outstanding --
/
SHLTXT==.-SHMT.1			;SIZE OF THE BLOCK
SHOT.1:	XWD	SHOTLN,.ORDSP		;TEXT BLOCK
	BLOCK	1			;ROOM FOR TIME STAMP
	ASCIZ/		-- Operators --

    Node      Type   Terminal  Job             User
-----------  ------  --------  ---  ----------------------------
/
SHOTLN=.-SHOT.1				;SIZE OF THE BLOCK


SUBTTL	SHWSCH	Show scheduler information

;THIS COMMAND IS TO DUMP THE SCHEDULER INFORMATION ON THE -20


TOPS20<
SHWSCH:	$CALL	P$CFM			;END OF COMMAND?
	$RETIF				;ERROR..RETURN
	$CALL	RELPAG			;RELEASE GIVEN PAGE
	$CALL	OPRMES			;SETUP THE MESSAGE
	MOVEI	S1,.SKRBC		;READ BIAS CONTROL
	MOVEI	S2,T1			;BLOCK IN T1
	MOVEI	T1,2			;LENGTH OF  BLOCK
	SKED%				;GET THE DATA
	   ERJMP SCHERR			;SCHEDULER ERROR
	MOVE	P1,T2			;SAVE THE VALUE
	MOVEI	S1,.SKRCV		;GET SCHEDULER DATA
	SKED%				;GET THE VALUE
	  ERJMP SCHERR			;SCHEDULER ERROR
	MOVE	P2,T2			;SAVE SCHEDULER INFO
	MOVEI	S1,[ASCIZ/on/]		;ASSUME ON
	TXNE	P2,SK%STP		;CHECK IF OFF
	MOVEI	S1,[ASCIZ/off/]		;YES..
	$TEXT	(WTORTN,<		-- System scheduler information --

		Class scheduler: ^T/(S1)/		Bias control: ^D/P1/>)
	MOVEI	P1,[ITEXT(<none set>)]	;ASSUME NONE-SET
	TXNE	P2,SK%DRG		;BATCH ON DREGS QUEUE?
	MOVEI	P1,[ITEXT(<background>)]	;YES.. SETUP BACKGROUND
	TXNE	P2,SK%STP		;CHECK IF ON
	JRST	SCHS.1			;NO..BYPASS CLASS SCHEDULER BATCH READ
	MOVEI	S1,.SKBCR		;READ BATCH CLASS SETTINGS
	MOVEI	S2,T1			;ADDRESS OF THE BLOCK
	MOVEI	T1,2			;LENGTH OF THE BLOCK
	SKED%				;GET THE VALUE
	  ERJMP  SCHERR			;ERROR..RETURN
	SKIPL	T2			;ANY SET(-1=NONE)
	MOVEI	P1,[ITEXT(<^D/T2/>)]	;GET THE NUMBER
SCHS.1:	$TEXT	(WTORTN,<						Batch class: ^I/(P1)/>)
	TXNE	P2,SK%STP		;CLASS SCHEDULER ON
	JRST	SCHS.4			;NO..FINISH OFF COMMAND
	MOVEI	T3,0			;START WITH CLASS 0
	$TEXT	(WTORTN,<
					    ------Load averages-------
		CLASS    SHARE(%)   USE(%)  1-MIN     5-MIN     15-MIN>)
SCHS.2:	MOVEI	S1,.SKRCS		;READ CLASS INFORMATION
	MOVEI	S2,SCHBLK		;SCHEDULER BLOCK
	MOVEI	T1,7			;LENGTH OF BLOCK
	MOVEM	T1,SCHBLK+.SACNT	;SAVE THE LENGTH
	MOVEM	T3,SCHBLK+.SACLS	;SAVE THE CLASS
	SKED%				;GET THE DATA
	  ERJMP	SCHS.3			;NO MORE..DONE NOW
	SKIPN	T4,SCHBLK+.SASHR	;ANY SHARE?
	AOJA	T3,SCHS.2		;NO..TRY NEXT ONE
	MOVE	S1,.SASHR+SCHBLK	;GET THE SHARE
	FMPRI	S1,(100.)		;GET WHOLE NUMBER
	FIXR	S1,S1			;GET INTERGER NUMBER
	MOVEM	S1,.SASHR+SCHBLK	;SAVE THE NUMBER
	MOVE	S1,.SAUSE+SCHBLK	;GET THE USE
	FMPRI	S1,(100.)		;MAKE A WHOLE NUMBER
	FIXR	S1,S1			;MAKE INTERGER NUMBER
	MOVEM	S1,.SAUSE+SCHBLK	;SAVE THE NUMBER
	MOVE	S1,.SA1ML+SCHBLK	;GET THE 1 MINUTE LOAD
	FMPRI	S1,(100.)		;GET WHOLE NUMBER
	FIXR	S1,S1			;GET INTERGER NUMBER
	IDIVI	S1,^D100		;NOW GET NUMBER AND FRACTION
	HRL	S2,S1			;PLACE IN LEFT HALF
	MOVEM	S2,.SA1ML+SCHBLK	;SAVE NUMBERS BACK
	MOVE	S1,.SA5ML+SCHBLK	;GET THE 5 MINUTE LOAD
	FMPRI	S1,(100.)		;GET WHOLE NUMBER
	FIXR	S1,S1			;GET INTERGER NUMBER
	IDIVI	S1,^D100		;NOW GET NUMBER AND FRACTION
	HRL	S2,S1			;PLACE IN LEFT HALF
	MOVEM	S2,.SA5ML+SCHBLK	;SAVE NUMBERS BACK
	MOVE	S1,.SA15L+SCHBLK	;GET THE 15 MINUTE LOAD
	FMPRI	S1,(100.)		;GET WHOLE NUMBER
	FIXR	S1,S1			;GET INTERGER NUMBER
	IDIVI	S1,^D100		;NOW GET NUMBER AND FRACTION
	HRL	S2,S1			;PLACE IN LEFT HALF
	MOVEM	S2,.SA15L+SCHBLK	;SAVE NUMBERS BACK
	$TEXT	(WTORTN,<		  ^D/SCHBLK+.SACLS/       ^D3R/SCHBLK+.SASHR/       ^D3R/SCHBLK+.SAUSE/    ^D3R/SCHBLK+.SA1ML,LHMASK/.^D2R0/SCHBLK+.SA1ML,RHMASK/    ^D3R/SCHBLK+.SA5ML,LHMASK/.^D2R0/SCHBLK+.SA5ML,RHMASK/    ^D3R/SCHBLK+.SA15L,LHMASK/.^D2R0/SCHBLK+.SA15L,RHMASK/>)
	AOJA	T3,SCHS.2		;NO..TRY NEXT ONE
SCHS.3:	MOVEI	S1,[ASCIZ/allocated/]	;DEFAULT FOR WINDFALL
	MOVEI	S2,[ASCIZ/policy program/];DEFAULT FOR CLASS ASSIGNMENTS
	TXNE	P2,SK%WDF		;WITHHOLD WINDFALL?
	MOVEI	S1,[ASCIZ/withheld/]	;YES
	TXNE	P2,SK%ACT		;CLASS BY ACCOUNTS
	MOVEI	S2,[ASCIZ/account/]	;YES
	$TEXT	(WTORTN,<
		Windfall: ^T/(S1)/		Classes by ^T/(S2)/>)
SCHS.4:	$CALL	MSGFIN			;FINISH THE MESSAGE
	$CALL	L$SHWM##		;LOG THE MESSAGE
	MOVE	S1,G$SND		;GET SENDERS PID
	MOVEI	S2,PAGSIZ		;PAGE MESSAGE
	$CALL	SPDOPR			;SEND TO OPR
	$RETT				;RETURN O.K.
SCHERR:	PJRST	E$SFF			;SCHEDULER FUNCTION FAILED
>;END TOPS20
SUBTTL	SHWMSG	Show messages command

;THIS ROUTINE WILL BUILD A MESSAGE FOR OPR WITH OUTSTANDING
;WTOR MESSAGES

SHWMSG:	MOVX	S1,.OMDSP		;SETUP OPR DISPLAY MESSAGE
	STORE	S1,.MSTYP(MO),MS.TYP	;SAVE THE TYPE COUNT
	$CALL	P$SWIT			;CHECK FOR A SWITCH
	JUMPF	SHWM.2			;NO..TRY FOR A NUMBER
	CAIE	S1,.SWNOD		;WAS IT A NODE
	$RETF
	$CALL	P$NODE			;GET THE NODE VALUE
	$RETIF				;INVALID MESSAGE
	MOVEM	S1,G$ARG1		;SAVE NODE NAME
	$CALL	FNDNOD			;VALIDATE THE NODE
	JUMPF	E$NMN			;NO SUCH NODE
	MOVE	P1,S1			;SAVE THE NODE ADDRESS
	MOVE	S1,NOD.NM(S1)		;GET THE NODE NAME
	$CALL	OPRENB			;CHECK IF ENABLED FOR NODE
	$RETIF				;INVALID NODE
	MOVEI	S1,SHMT.1		;SHOW MESSAGE  TEXT
	$CALL	SHWMTX			;SHOW MESSAGE TEXT POINTER
	MOVE	S2,P1			;PUT NODE ADDRESS IN S2
	$CALL	MSGNOD			;OUTPUT THE MESSAGES
	JUMPT	FINSHW			;HAVE SOME..SEND IT
	PJRST	E$NMN			;NO MESSAGES FOR THE NODE

SHWM.2:	$CALL	P$NUM			;GET A NUMBER
	JUMPF	SHWM.3			;MUST BE CRLF
	MOVEM	S1,G$ARG1		;SAVE THE MESSAGE NUMBER
	$CALL	GETMSG			;GET THE MESSAGE
	JUMPF	E$NSM			;NO SUCH MESSAGE
	MOVEI	S1,SHMT.1		;SHOW MESSAGE  TEXT
	$CALL	SHWMTX			;SHOW MESSAGE TEXT
	$CALL	BLDDPY			;MOVE THE MESSAGE
	JRST	FINSHW			;FINISH OFF THE MESSAGE

;Here if just SHOW MESSAGES <cr>
;If system OPR, show all messages, otherwise, just messages
; for this OPRs node

SHWM.3:	MOVEI	S1,SHMT.1		;SHOW MESSAGE  TEXT
	$CALL	SHWMTX			;SHOW MESSAGE TEXT
	MOVE	S1,G$OPRA		;GET THE OPR ADDRESS
	MOVE	S2,OPR.ND(S1)		;GET THE NODE ADDRESS
	MOVE	S2,NOD.NM(S2)		;GET THE NAME
	MOVEM	S2,G$ARG1		;SAVE THE VALUE
	$CALL	O$SYSTEM		;IS THIS A SYSTEM OPR?
	JUMPF	SHWM.5			;NO ..DO JUST THIS NODE
	SETZM	P1			;CLEAR MESSAGES FLAG
	MOVE	S1,G$NODL		;GET NODE LIST NUMBER
	$CALL	L%FIRST			;GET FIRST ENTRY
	JUMPF	E$NOM			;STRANGE, NO NODES!
SHWM.4:	$CALL	MSGNOD			;GET MESSAGES FOR THIS NODE
	SKIPF				;NO MESSAGES SKIP FLAG SETTING
	SETOM	P1			;MESSAGES FOUND
	MOVE	S1,G$NODL		;GET NODE LIST NUMER
	$CALL	L%NEXT			;GET NEXT ENTRY
	JUMPT	SHWM.4			;PROCESS MESSAGES
	SKIPE	P1			;SEND ANY MESSAGES
	JRST	FINSHW			;YES..SEND MESSAGE
	PJRST	E$NOM			;NO OUTSTANDING MESSAGES

;Here for a non-system OPR
SHWM.5:	MOVE	S2,OPR.ND(S1)		;GET THE OPR DATA BASE ENTRY
	$CALL	MSGNOD			;OUTPUT THE MESSAGES
	JUMPT	FINSHW			;FINISH OFF THE MESSAGE
	PJRST	E$NMN			;NO MESSAGES FOR NODE


SUBTTL	FINSHW	Finish a SHOW message

;This Routine will finish off a SHOW OPERATOR or SHOW MESSAGES
;command and LOG it.

FINSHW:	$CALL	P$CFM			;END OF MESSAGE
	$RETIF				;ERROR..RETURN
FINS.1:	ANDI	P3,777			;GET MESSAGE LENGTH
	STORE	P3,.MSTYP(MO),MS.CNT	;SAVE LENGTH IN MESSAGE
	$SAVE	<T1,T2>			;WE KNOW L$SHWM SMASHES THESE
	$CALL	L$SHWM##		;LOG THE SHOW MESSAGE
	MOVE	S1,G$SND		;GET THE SENDERS PID
	MOVEI	S2,PAGSIZ		;SEND A PAGE
	$CALL	SPDOPR			;SEND THE MESSAGE
	$RETT				;RETURN TRUE

SUBTTL	MSGNOD	 Routine to Build Display Blocks for a Node

;CALLED WITH S2 CONTAINING THE ADDRESS OF AN ENTRY IN THE NODE LIST
;MO MUST POINT AT A OPERATOR DISPLAY MESSAGE

MSGNOD:	LOAD	S1,NOD.ML(S2)		;GET THIS NODE'S MESSAGE LIST NUMBER
	MOVE	T1,S1			;SAVE MESSAGE LIST NUMBER
	$CALL	L%FIRST			;FIND THE FIRST MESSAGE
	$RETIF				;NONE FOR THIS NODE,RETURN
MSGN.1:	$CALL	BLDDPY			;GO BUILD A DISPLAY BLOCK
MSGN.2:	MOVE	S1,T1			;COPY MESSAGE LIST NUMBER TO S1
	$CALL	L%NEXT			;FIND NEXT ENTRY
	JUMPT	MSGN.1			;LOOP FOR ALL MESSAGES
	$RETT				;LOOP IF NO MORE


SUBTTL	BLKDPY	Build message into output

;THIS ROUTINE WILL MOVE TEXT BLOCK FROM MESSAGE LIST TO OUTPUT MESSAGE MO
;CALLED WITH:	S2	ADDRESS OF MESSAGE ENTRY

BLDDPY:	MOVSI	T3,MSL.SZ(S2)		;ADDRESS OF MESSAGE TEXT
	HRR	T3,P3			;FIRST FREE OUTPUT ADDRESS
	LOAD	T4,MSL.SZ(S2),AR.LEN	;LENGTH OF THE BLOCK
	ADD	P3,T4			;COMPUTE ENDING ADDRESS
	CAIL	P3,777(MO)		;MAKE SURE WILL FIT IN MESSAGE
	PJRST	BLDD.1			;NO..SEND AND CONTINUE ON
	BLT	T3,-1(P3)		;MOVE THE BLOCK
	AOS	.OARGC(MO)		;CLEAR THE ARGUMENT COUNT
	$RETT				;RETURN TRUE
BLDD.1:	PUSH	P,S2			;SAVE MESSAGE ADDRESS
	MOVX	S1,WT.MOR		;SET MORE COMING FLAG
	IORM	S1,.OFLAG(MO)		;TURN ON THE FLAG
	$CALL	FINS.1			;SEND THE MESSAGE
	$CALL	GETPAG			;GET A PAGE FOR OUTPUT
	MOVX	S1,.OMDSP		;SETUP DISPLAY MESSAGE
	STORE	S1,.MSTYP(MO),MS.TYP	;SAVE THE TYPE
	MOVEI	P3,.OHDRS(MO)		;GET FIRST FREE ADDRESS
	POP	P,S2			;RESTORE S2
	JRST	BLDDPY			;TRY THIS ONE AGAIN
SUBTTL	GETMSG	Get a message given the number

;THIS ROUTINE WILL BE CALLED WITH THE MESSAGE NUMBER IN S1
;AND RETURN TRUE WITH MESSAGE ENTRY ADDRESS IN S2

GETMSG:	MOVE	S2,G$OPRA		;GET THE OPR ENTRY ADDRESS
	MOVE	S2,OPR.ND(S2)		;GET NODE ENTRY ADDRESS
	MOVEI	T1,MSL.ID		;GET MESSAGE ID
	HRRM	T1,FNDXCT		;SAVE FOR COMPARE
	$CALL	CHKMSG			;CHECK FOR MESSAGE..THIS NODE
	$RETIT				;O.K. FOUND..SEND ANSWER
	MOVE	S1,G$OPRA		;GET OPR ADDRESS
	$CALL	O$SYSTEM		;SYSTEM OPR?
	$RETIF				;Return on failure
	MOVE	S2,OPR.ND(S1)		;GET NODE ENTRY
	MOVE	S1,P1			;GET NUMBER OF ANSWER
	MOVEI	T1,MSL.ID		;GET MESSAGE ID
	HRRM	T1,FNDXCT		;SAVE FOR COMPARE
	PJRST	FNDMSG			;CHECK FOR MESSAGE AND RETURN

SUBTTL	FNDMSG	Find a message for node

;THIS ROUTINE WILL SEARCH ALL NODES AND CHECK FOR MESSAGE
;
;CALL	S1/	MESSAGE NUMBER
;
;RETURN	TRUE	S2/ ADDRESS OF MESSAGE ENTRY


FNDMSG:	$CALL	.SAVE2			;SAVE P1 AND P2
	MOVE	P1,S1			;RELOCATE SEQUENCE NUMBER
FNDM.1:	MOVE	S1,G$NODL		;GET NODE LIST NUMBER
	$CALL	L%FIRST			;FIND THE FIRST ONE
	$RETIF				;EMPTY NODE LIST
FNDM.2:	MOVE	S1,P1			;MESSAGE TO SEARCH FOR
	$CALL	CHKM.1			;CHECK NODE FOR MESSAGE
	JUMPT	FNDM.3			;FOUND ..RETURN
	MOVE	S1,G$NODL		;GET NODE LIST NUMBER AGAIN
	$CALL	L%NEXT			;LOOK FOR THE NEXT NODE
	JUMPT	FNDM.2			;LOOP
	$RETF				;FAILURE
FNDM.3:	MOVE	P1,S2			;SAVE THE ENTRY
	MOVE	S1,G$NODL		;GET NODE LIST NUMBER
	$CALL	L%RENT			;REMEMBER THE ENTRY
	$RETIF				;Can't remember???
	MOVE	S2,P1			;RESTORE MESSAGE ADDRESS
	$RETT				;RETURN TRUE
SUBTTL	CHKMSG	Search node for a message

;THIS ROUTINE WILL CHECK FOR THE MESSAGE AT A NODE
;
;CALL	S1/	MESSAGE NUMBER
;	S2/	NODE ADDRESS
;
;RETURN	TRUE:	S2/	MESSAGE ADDRESS

CHKMSG:	$CALL	.SAVE2			;SAVE P1 AND P2
CHKM.1:	DMOVE	P1,S1			;SAVE THE MESSAGE ID AND NODE ADDRESS
	LOAD	S1,NOD.ML(P2)		;GET THE MESSAGE LIST NUMBER
	$CALL	L%FIRST			;FIND THE FIRST MESSAGE
	$RETIF				;RETURN..IF NONE THERE
CHKM.2:	XCT	FNDXCT			;EXECUTE THE MATCH
	JRST	CHKM.4			;SAVE THE ENTRY
CHKM.3:	MOVE	S1,NOD.ML(P2)		;GET MESSAGE LIST NUMBER AGAIN
	$CALL	L%NEXT			;FIND NEXT MESSAGE IN THE LIST
	JUMPT	CHKM.2			;CHECK THIS ENTRY
	$RETF				;NO..RETURN FALSE
CHKM.4:	HRRZ	S1,FNDXCT		;GET THE COMPARE TYPE
	CAIE	S1,MSL.CD		;WAS IT THE CODE
	JRST	CHKM.5			;IGNORE NEXT CHECK
	MOVE	S1,G$SND		;GET SENDERS PID
	CAME	S1,MSL.PD(S2)		;IS IT SAME PID
	JRST	CHKM.3			;NO..GET NEXT ENTRY
CHKM.5:	MOVE	P1,S2			;SAVE THE MESSAGE ADDRESS
	MOVE	S1,NOD.ML(P2)		;GET MESSAGE LIST NUMBER
	$CALL	L%RENT			;REMEMBER THIS ENTRY
	$RETIF				;Can't remember???
	MOVE	S2,P1			;RESTORE MESSAGE ADDRESS
	$RETT				;RETURN TRUE


SUBTTL	NXTMSG	Get the next message

;THIS ROUTINE WILL GET NEXT MESSAGE AFTER FNDMSG HAS FOUND ONE
;
;	S1/	MESSAGE NUMBER  OR ID

NXTMSG:	$CALL	.SAVE2			;SAVE P1 AND P2
	MOVE	P1,S1			;SAVE MESSAGE ID
	MOVE	S1,G$NODL		;GET NODE LIST
	$CALL	L%PREM			;GET REMEMBERED ENTRY
	JUMPF	FNDM.1			;SEARCH THE LIST
	MOVE	P2,S2			;SAVE NODE ADDRESS
	MOVE	S1,NOD.ML(P2)		;GET MESSAGE LIST ADDRESS
	$CALL	L%PREM			;GET REMEMBERED ENTRY
	JUMPF	NXTM.1			;NONE SET..CHECK ALL MESSAGES AT NODE
	$STOP(REI,<Remembered entry ^O/S2/ in list ^D/S1/ invalid>)
NXTM.1:	MOVE	S2,P2			;GET NODE ADDRESS
	JRST	FNDM.2			;PROCESS MESSAGE NOW
SUBTTL	REPORT	Log messages in SYSERR file

;THIS COMMAND WILL LOG THE ENTRY TO SYSERR

					;NEEDED SYMBOLS

	SLMTTY==0			;JOB#,,TTY#
	SLMPPN==1			;PPN OR POINTER TO BLOCK
	SLMWHO==2			;REPORTED BY FIELD
	SLMDEV==3			;DEVICE TO REPORT
	SLMMSG==4			;POINTER TO REASON

	ER.SLM==16			;TOPS-10 ERROR TYPE
	SEC%SL==116			;TOPS-20 ERROR TYPE
	SYSCOD==777000,,0		;MASK FOR STORING CODE ON -20

REPORT:	MOVE	S1,G$OPRA		;Get OPR address
	MOVE	S1,OPR.ND(S1)		;Get Node address
	MOVE	S1,NOD.NM(S1)		;Get Node name
	$CALL	OPRENB			;Must have remote privs
	$RETIF
	MOVEI	P1,.OARGC(MO)		;GET POINTER TO DATA AREA
	$CALL	P$SIXF			;GET THE REPORTER NAME
	$RETIF				;NOT THERE..ERROR
	MOVEM	S1,SLMWHO(P1)		;SAVE THE ID
	$CALL	P$DEV			;GET THE DEVICE NAME
	$RETIF				;ERROR..RETURN
	HRROI	S1,ARG.DA(S1)		;Setup pointer to device name
	$CALL	S%SIXB			;convert device name to sixbit
	MOVEM	S2,SLMDEV(P1)		;SAVE DEVICE NAME
	LOAD	S1,G$JOB		;GET JOB NUMBER
	HRLM	S1,SLMTTY(P1)		;SAVE JOB NUMBER
	$CALL	GETJOB			;GET JOB INFO OF SENDER
	MOVE	S1,JOBTTY		;GET TERMINAL NUMBER
	HRRM	S1,SLMTTY(P1)		;SAVE TERMINAL NUMBER

TOPS10<
REPO.1:	SKIPN	S1,G$SID		;GET SENDERS ID
	PJRST	E$IUM			;INVALID USER IN MESSAGE
	MOVEM	S1,SLMPPN(P1)		;SAVE THE PPN
	MOVEI	P2,SLMMSG+1		;OFFSET FOR TEXT START
>;END TOPS10

TOPS20<
REPO.1:	MOVE	S2,G$SID		;GET SENDERS ID
	HRROI	S1,SLMMSG+1		;GET PLACE TO STORE IT
	MOVEM	S1,SLMPPN(P1)		;SAVE THE POINTER
	ADDI	S1,(P1)			;ADD IN ACTUAL DISPLACEMENT
	DIRST				;MAKE A STRING FROM NUMBER
	  JRST	E$IUM			;INVALID USER IN MESSAGE
	IBP	S1			;INCREMENT THE BYTE POINTER
	HRRZ	P2,S1			;GET LAST ADDRESS
	ADDI	P2,1			;POINT TO NEXT FREE LOCATION
	SUB	P2,P1			;GET RELATIVE OFFSET
>;END TOPS20

	$CALL	P$TEXT			;GET THE EXPLANATION
	$RETIF				;ERROR..RETURN
	SUBI	S2,1			;DECREMNT COUNT BY HEADER SIZE
	MOVN	T1,S2			;GET SIZE OF BLOCK
	MOVS	T2,T1			;PLACE COUNT IN LEFT HALF
	HRR	T2,P2			;GET ADDRESS FOR DATA
	MOVEM	T2,SLMMSG(P1)		;SAVE POINTER IN BLOCK
	MOVEI	S2,ARG.DA(S1)		;GET ADDRESS OF TEXT
	MOVE	S1,P2			;GET ADDRESS OF DESTINATION
	ADD	S1,P1			;GET ACTUAL LOCATION
	$CALL	TXTMOV			;MOVE THE TEXT
	HRRZ	S1,S1			;GET ENDING ADDRESS

TOPS10<
REPO.2:	SUBI	S1,-1(P1)		;GET THE LENGTH
	ADDI	S1,2			;SIZE OF HEADER
	MOVE	T1,S1			;SAVE LENGTH IN T1
	MOVX	S1,ER.SLM		;GET TYPE OF SYERR ENTRY
	STORE	S1,.OFLAG(MO)		;SAVE IN MESSAGE
	MOVX	S1,.DMERR		;DAEMON FUNCTION CODE
	STORE	S1,.MSCOD(MO)		;SAVE IN MESSAGE
	MOVS	T2,T1			;PLACE LENGTH IN LEFT HALF
	HRRI	T2,.MSCOD(MO)		;GET STARTING ADDRESS
	DAEMON	T2,			;DO THE FUNCTION
	  PJRST	E$SUF			;SYSERR UPDATE FAILED
>;END TOPS10

TOPS20<
REPO.2:	SUBI	S1,-1(P1)		;GET THE LENGTH
	ADDI	S1,4			;ADD 4 WORD HEADER
	MOVE	T1,S1			;SAVE THE LENGTH
	MOVX	S1,SEC%SL		;GET FUNCTION CODE
	STORE	S1,.MSTYP(MO),SYSCOD	;SAVE THE CODE
	MOVEI	S1,.MSTYP(MO)		;START OF FUNCTION
	MOVE	S2,T1			;LENGTH OF THE BLOCK
	SYERR				;DO THE SYSERR UPDATE
	ERJMP	E$SUF			;SYSERR UPDATE FAILED
>;END TOPS20
	PJRST	E$SEM			;SYSERR ENTRY MADE
SUBTTL	CHKWTO	Routine to check for outstanding WTORS for all nodes

;This routine is a TIMER event and as such will be called from I%SLP
;when any WTOR's are outstanding

CHKWTO:	SETZM	G$CHKM			;Clear request flag
	MOVE	S1,G$NODL		;Get the node list
	$CALL	L%FIRST			;Get the first node
	 JUMPF	E$NOM			;Strange..

CHKWT0:	MOVE	T2,NOD.NM(S2)		;Get the node name
	MOVE	S1,NOD.ML(S2)		;Point to the message list
	$CALL	L%FIRST			;Any messages?
	 JUMPF	CHKWT2			;No..try the next
	SKIPT	G$OPR			;Yes..OPR around to see it?
	 JRST	CHKWT3			;No..dont bother outputing
	MOVEI	T1,0			;Yes..init the count

CHKWT1:	$CALL	L%NEXT			;Count the messages
	ADDI	T1,1			;Bump the count
	JUMPT	CHKWT1			;Loop back
	$WTO(<^D/T1/ outstanding message(s)^T/WTBELL/>,,,<$WTNOD(T2),$WTFLG(WT.SJI)>)
CHKWT3:	SETOM	G$CHKM			;Request another check

CHKWT2:	MOVE	S1,G$NODL
	$CALL	L%NEXT			;Check the next node
	JUMPT	CHKWT0
	SKIPN	G$CHKM			;Want another check?
	$RETT				;No..just return

REQMSC:	MOVX	S1,<^D5*^D60*^D1000>	;Wait 5 minutes
	MOVEI	S2,CHKWTO		;Same routine
	$CALL	REQTIM			;Make the request
	SETOM	G$CHKM			;Remember we made it
	$RETT

WTBELL:	BYTE (7) .CHBEL,.CHBEL,.CHBEL

SUBTTL	OPRLST	 Routine to Build Display Blocks for an Operator

;CALLED WITH S2 CONTAINING THE ADDRESS OF AN ENTRY IN THE NODE LIST
;MO MUST POINT AT A OPERATOR DISPLAY MESSAGE

OPRLST:	$CALL	OPRSPT			;OPR SETUP POINTERS
	LOAD	S1,NOD.OP(S2)		;GET THE OPERATOR LIST NUMBER
	MOVE	T1,S1			;SAVE OPERATOR LIST NUMBER
	$CALL	L%FIRST			;FIND THE FIRST MESSAGE
	$RETIF				;NONE FOR THIS NODE,RETURN
OPRL.1:	MOVE	S1,OPR.ND(S2)		;GET NODE ENTRY ADDRESS
	$CALL	OPRDPY			;GO BUILD A DISPLAY BLOCK
OPRL.2:	MOVE	S1,T1			;COPY MESSAGE LIST NUMBER TO S1
	$CALL	L%NEXT			;FIND NEXT ENTRY
	JUMPT	OPRL.1			;LOOP FOR ALL MESSAGES
	HRRZ	S2,WTOPTR		;GET LAST ADDRESS
	SUBI	S2,-1(P3)		;GET THE LENGTH
	MOVEI	S1,.CMTXT		;GET ARGUMENT TYPE
	$CALL	ARGRTN			;SAVE THE ARGUMENT
	$RETT				;LOOP IF NO MORE


SUBTTL	OPRDPY	Build Operator Info

;THIS ROUTINE WILL PLACE TEXT IN THE MESSAGE
;CALLED WITH:	S1	NODE ENTRY ADDRESS
;		S2	ADDRESS OF OPERATOR ENTRY

OPRDPY:	$SAVE	<P1,P2>
	DMOVE	P1,S1			;SAVE THE NODE AND OPR ADRSSES
	MOVE	S1,OPR.FL(S2)		;GET OPERATOR FLAGS
	MOVEI	S2,[ASCIZ/user  /]	;THE DEFAULT
	TXNE	S1,OP.HST		;IS THIS A HOST OPERATOR?
	MOVEI	S2,[ASCIZ/host  /]	;YES
	TXNE	S1,OP.REM		;IS IT REMOTE?
	MOVEI	S2,[ASCIZ/remote/]	;YES
	TXNE	S1,OP.SYS		;IS IT SYSTEM OPR?
	MOVEI	S2,[ASCIZ/system/]	;YES, SAY SO
	$TEXT	(OPRRTN,<^N11/NOD.NM(P1)/  ^T/0(S2)/     ^O3R/OPR.TN(P2)/    ^D3R/OPR.JB(P2)/  ^I/OPRUSN/^U/OPR.US(P2)/>)
	$RET				;RETURN

TOPS20<
OPRUSN==NULTXT
>;END TOPS20
TOPS10<
OPRUSN:	ITEXT	(<^W6/OPR.UN(P2)/^W/OPR.UN+1(P2)/ >)
>;END TOPS10

OPRRTN:	IDPB	S1,WTOPTR		;SAVE THE BYTE
	$RETT				;RETURN TRUE
OPRR.1:	MOVX	S1,WT.MOR		;SET MORE COMING FLAG
	IORM	S1,.OFLAG(MO)		;TURN ON THE FLAG
	$CALL	FINS.1			;SEND THE MESSAGE
	$CALL	GETPAG			;GET A PAGE FOR OUTPUT
	MOVX	S1,.OMDSP		;SETUP DISPLAY MESSAGE
	STORE	S1,.MSTYP(MO),MS.TYP	;SAVE THE TYPE
	MOVEI	P3,.OHDRS(MO)		;GET FIRST FREE ADDRESS
	$CALL	OPRSPT			;OPR SET POINTER
	JRST	OPRDPY			;TRY THIS ONE AGAIN


;S2 MUST BE PRESERVED

OPRSPT:	MOVEI	S1,ARG.DA(P3)		;FREE LOCATION IN MESSAGE
	HRLI	S1,(POINT 7,)		;MAKE A BYTE POINTER
	MOVEM	S1,WTOPTR		;SAVE THE POINTER
	MOVEI	S1,ARG.DA(P3)		;GET THE POINTER
	MOVEI	T1,PAGSIZ		;SIZE OF A PAGE
	ANDI	S1,777			;MAKE AS OFFSET
	SUBI	T1,-1(S1)		;GET NUMBER OF FREE WORDS
	IMULI	T1,NCHPW		;NUMBER OF CHARACTERS PER WORD
	MOVEM	T1,WTOCNT		;COUNT OF SPACE REMAINING
	$RET				;RETURN
SUBTTL	RESPON	Respond command

;THIS ROUTINE WILL PROCESS A RESPOND MESSAGE TO A WTO AND PASS
;THE ANSWER TO THE REQUESTOR

RESPON:	$CALL	P$NUM			;GET THE NUMBER FROM MESSAGE
	$RETIF				;NO..INVALID MESSAGE..RETURN
	MOVE	P1,S1			;SAVE MESSAGE NUMBER IN P1
	$CALL	GETMSG			;GET THE MESSAGE
					;O.K..IN S2
	JUMPF	RESP.5			;NO..GIVE ERROR
RESP.1:	MOVE	P2,S2			;SAVE THE MESSAGE ADDRESS
	MOVE	S1,MSL.ND(P2)		;GET THE NODE MESSAGE FOUND OUT
	MOVE	S1,NOD.NM(S1)		;GET THE NODE NAME
	$CALL	OPRENB			;SEE IF OPR ENABLED FOR NODE
	JUMPF	RESP.6			;NO..SETUP ERROR
	MOVEI	T1,MSL.SZ(P2)		;GET START OF MESSAGE
	LOAD	S1,MSL.CD(P2)		;GET SENDERS CODE
	STORE	S1,.MSCOD(MO)		;SAVE IN MESSAGE
RESP.2:	$CALL	P$CURR			;GET THE CURRENT POINTER
	MOVE	T4,S1			;SAVE THE BLOCK POINTER
	$CALL	P$TEXT			;GET THE TEXT ADDR AND LEN
	$RETIF				;NOT TEXT..ERROR..RETURN
	$CALL	MOVARG			;BUILD TEXT ARGUMENT
	MOVE	S1,G$SND		;GET PID OF OPR SENDING IT
	MOVEM	S1,ARG.DA(P3)		;SAVE THE PID IN BLOCK
	MOVE	S1,G$OPRA		;GET THE OPR ADDRESS
	MOVE	T1,OPR.TN(S1)		;GET THE TERMINAL NUMBER
	MOVE	S2,OPR.ND(S1)		;GET THE NODE ENTRY
	MOVE	S2,NOD.NM(S2)		;GET THE NODE NAME
	CAME	S2,G$HOST		;SAME AS OUR NODE.. USE TERMINAL
	MOVE	T1,S2			;GET THE NODE NAME
	MOVEM	T1,ARG.DA+1(P3)		;SAVE THE DATA
	MOVEI	S1,.ACKID		;GET ACK ID
	MOVEI	S2,ARG.SZ+1		;SIZE OF BLOCK
	$CALL	ARGRTN			;SAVE THE ARGUMENT
	ANDI	P3,777			;GET MESSAGE LENGTH
	STORE	P3,.MSTYP(MO),MS.CNT	;SAVE MESSAGE LENGTH
	LOAD	S1,MSL.PD(P2)		;PID OF THE SENDER
	MOVEI	S2,PAGSIZ		;PAGE MODE MESSAGE
	$CALL	SNDPID			;SEND THE MESSAGE
	JUMPT	RESP.4			;O.K. RELEASE MESSAGE AND RETURN
	MOVX	S1,MS.TER		;NOTIFY ANYWAY?
	TDNE	S1,MSL.FL(P2)		;CHECK IF SET
	JRST	RESP.7			;YES.. OUTPUT TO USER TERMINAL
	MOVEM	P1,G$ARG1		;SAVE THE NUMBER
RESP.3:	$CALL	E$MNV			;MESSAGE NO LONGER VALID..
	$CALL	RELPAG			;RELEASE THE PAGE
RESP.4:	MOVE	S2,MSL.ND(P2)		;NODE MESSAGE FOUND AT
	SOS	NOD.CT(S2)		;DECREMENT THE COUNT
	MOVE	S1,NOD.ML(S2)		;GET THE LIST NUMBER
	$CALL	L%DENT			;DELETE THE ENTRY
	$RETT				;RETURN TRUE
RESP.5:	MOVEM	P1,G$ARG1		;SAVE THE NUMBER
	$CALL	E$NSM			;NO SUCH MESSAGE
	$RETT				;RETURN TRUE
RESP.6:	MOVEM	P1,G$ARG1		;SAVE THE MESSAGE NUMBER ARG1
	MOVE	S1,MSL.ND(P2)		;GET NODE ADDRESS
	MOVE	S1,NOD.NM(S1)		;GET NODE NAME
	MOVEM	S1,G$ARG2		;SAVE ARG2
	PJRST	E$ONE			;OPR NOT ENABLED FOR NODE
RESP.7:	MOVE	S1,MSL.JB(P2)		;GET THE JOB NUMBER
	$CALL	GETUSR			;GET THE USER INFO
	JUMPT	RESP.8			;O.K.. CONTINUE ON
	SETZM	G$ERR			;CLEAR ERROR CODE
	MOVEM	P1,G$ARG1		;SAVE THE MESSAGE NUMBER
	JRST	RESP.3			;GENERATE AN ERROR
RESP.8:	MOVE	S1,MSL.JT(P2)		;GET THE JOB LOGGED IN TIME
	CAME	S1,JOBJLT		;SAME JOB?
	JRST	RESP.3			;NO..GENERATE AN ERROR
	MOVE	S1,T4			;GET THE CURRENT PARSER POINTER
	$CALL	P$SETU			;SETUP THE PARSER POINTER
	MOVEI	P3,.OHDRS(MO)		;OUTPUT POINTER
	$CALL	BLDSND			;BUILD THE SEND
	MOVEI	S2,ARG.DA(S1)		;POINT TO THE DATA
	MOVE	S1,JOBTTY		;GET TERMINAL NUMBER
	$CALL	SNDTTY			;SEND THE MESSAGE
	$CALL	RELPAG			;RELEASE THE PAGE
	JRST	RESP.4			;AND RELEASE THE MESSAGE
SUBTTL	Operator privilege checking routines

;The routines on the following pages are called to check various
;operator capabilities from Orions command processing level.  The
;following capabilies are defined:


;WHEEL capability

;	OPR can do anything to any node.  This also includes
;	full file access.  For TOPS10  the full file
;	access PPN implies wheel.

;SYSTEM capability

;	OPR can do anything to any node with this capabilility.

;HOST capability

;	OPR can do anything to the host node.

;REMOTE capability

;	OPR can do anything to the node where the terminal is
;	physically connected. (Excluding the host system)

SUBTTL	GETPRV	Find out if the sender could be an OPR of sorts

;This routine is called to determine if the sender has any operator
;capability.

;Accepts	G$PRVS and G$SID set up from received message

TOPS20<
GETPRV:	$CALL	CHKWHL			;Check for wheel or operator
	$RETIF				;Not a wheel, forget it
	MOVX	S1,OP.SYS		;Wheel, claim to be a system OPR
	MOVE	TF,.OFLAG(MI)		;Get the flag bits from the hello msg.
	TXNE	TF,OP.RMT		;Does it claim to be remote?
	MOVX	S1,OP.REM		;Yes, set the privs to say so
	$RETT
> ; End of TOPS20

TOPS10<
GETPRV:	MOVX	TF,TRUE			;Set for true return
	MOVX	S1,OP.SYS		;Assume system OPR
	SKIPT	DEBUGW			;Debugging or Wheel?
	$CALL	CHKWHL
	$RETIT				;Yes..allow system privs
	LOAD	S1,G$JOB		;GET THE JOB NUMBER
	MOVX	S2,JI.BAT		;GET BATCH DATA AND OPR FIELDS
	$CALL	I%JINF			;GET THE DATA
	LOAD	S1,S2,OB.OPR		;GET THE OPERATOR BITS
	MOVEI	S2,PRVTAB		;ADRS OF PRIVILEGE BIT CONVERSION TABLE
	$CALL	TABSRC			;MAP IT
	$RETIF				;Return on failure
	MOVE	S1,0(S2)		;GET THE PRIV BIT
	$RETT				;AND RETURN

PRVTAB:	$STAB
	XWD	.OBSOP,[EXP OP.SYS]	;SYSTEM OPERATOR
	XWD	.OBHOP,[EXP OP.HST]	;HOST ONLY OPERATOR
	XWD	.OBROP,[EXP OP.REM]	;REMOTE ONLY OPERATOR
	$ETAB

> ; End of TOPS10
SUBTTL	OPRENB	Operator enabled for a node

;This routine checks to see if an OPR has sufficient privileges
;to perform a function for a specified node.

;Accepts	S1/ Node name or number or -1 for all nodes


;Returns TRUE	OPR has sufficient privileges
;	 FALSE	OPR doesn't have enough privs

;If all nodes are specifed [-1] then system privs are required.
;If the specified node is the host then host or system privs are required.
;If the specified node is not the host, then the operator must be
;physically connected to the node and have remote privileges.

OPRENB:	MOVE	S2,S1			;Save the node name
	MOVE	S1,G$OPRA		;Get the OPR data base address
	CAME	S2,[-1]			;All nodes?
	JRST	OPRE.2			;No, try for host or remote

;Need system privs.

OPRE.1:	$CALL	O$SYSTEM		;Check for privs
	JUMPF	E$OSY			;Failed, do not return
	$RET				;Return passing true up

;Here to try for host privs.

OPRE.2:	CAME	S2,G$HOST		;On the host name or
	CAMN	S2,G$HSTN		;  number
	SKIPA				;Yes
	JRST	OPRE.3			;Go try for remote

;Need host privs.

	$CALL	O$HOST			;Check for privs.
	JUMPF	E$OHS			;Failed, do not return
	$RET				;Return passing true up

;Here to try for remote

OPRE.3:	$SAVE	<P1>			;Need an ac here
	MOVE	P1,OPR.ND(S1)		;Get node data address
	CAME	S2,NOD.NM(P1)		;On node name or
	CAMN	S2,NOD.NU(P1)		;  number?
	SKIPA
	JRST	OPRE.1			;Try for system just for grins

;Need remote privs.

	$CALL	O$REMOTE		;Check for privs
	JUMPF	E$ORS			;Failed, do not return
	$RET				;Return passing true up
	SUBTTL	O$REMOTE/O$HOST/O$SYSTEM/CHKWHL Routs. to check privs.

;Accepts	S1/ OPR data base address (not needed for CHKWHL)

;Returns TRUE	OPR has privs needed
;	 FALSE	Opr is not privy

O$REMOTE:
	MOVX	TF,OP.REM		;Get remote capability
	TDNE	TF,OPR.FL(S1)		;Have it?
	$RETT				;Yes
	PJRST	O$SYSTEM		;No, try for system

TOPS10 <

O$HOST:
	MOVX	TF,OP.HST		;Get Host capability
	TDNE	TF,OPR.FL(S1)		;Have it?
	$RETT				;Yes
	PJRST	O$SYSTEM		;No..Check for system and return

O$SYSTEM:
	MOVX	TF,OP.SYS		;Get system capability
	TDNE	TF,OPR.FL(S1)		;Have it?
	$RETT				;Yes..we have a winner

	;Fall through

>; End of TOPS10

CHKPRV:	MOVX	TF,OP.D60		;Get the OPR is a DN60 bit.
	TDNE	TF,OPR.FL(S1)		;Is this an on the behalf of?
	$RETF				;Yes, he is not a WHEEL!
					;Continue checking
CHKWHL:	SKIPE	DEBUGW			;DEBUGGING ???
	$RETT				;YES,,THEN OK
	MOVX	TF,MD.PWH!MD.POP	;CHECK FOR WHEEL OR OPERATOR
	TDNN	TF,G$PRVS		;WAS SENDER PRIVILEGED
	$RETF				;NO..RETURN FALSE
	$RETT				;YES..RETURN TRUE

SUBTTL	TOPS20 Privilege checking routines

TOPS20<
O$HOST:
O$SYSTEM:
	PJRST	CHKPRV			;Go for privs
>;END TOPS20

SUBTTL	G$ACK	Send an ACK to sender if requested

;THIS ROUTINE SENDS AN ACKNOWLEDGEMENT MESSAGE IF ONE WAS REQUESTED.
;IF THERE WAS NO ERROR, A FLAG IS SET IN THE MESSAGE HEADER

G$ACK:	$CALL	BLDACK			;BUILD AN ACK MESSAGE
	LOAD	S1,.MSCOD(MI)		;GET CODE FROM ORIGINAL MESSAGE
	STORE	S1,.MSCOD(MO)		;AND SAVE IT IN ACK MESSAGE
	SKIPN	S1,G$SND		;PID TO SEND TO
	  PJRST	RELPAG			;INVALID PID, SKIP SEND AND RELEASE PAGE
	MOVEI	S2,PAGSIZ		;GET PAGE SIZE
	$CALL	SNDPID			;SEND THE MESSAGE
	$RETIT				;O.K. RETURN
	PJRST	RELPAG			;RELEASE PAGE AND RETURN
SUBTTL	BLDACK	Build an ACK message

;THIS ROUTINE WILL BUILD AN ACK MESSAGE TO BE SENT ON ERROR
;OR FOR MESSAGES TO OPR FROM ORION

BLDACK:	$CALL	GETPAG			;GET PAGE FOR OUTPUT
	MOVX	S1,MT.TXT		;GET MESSAGE TYPE CODE
	STORE	S1,.MSTYP(MO),MS.TYP	;SAVE MESSAGE TYPE
	SKIPE	G$ERR			;WAS THERE AN ERROR??
	JRST	BLDA.1			;YES, NEED TO BUILD TEXT MESSAGE
	MOVX	S1,MF.NOM		;FLAG THIS AS JUST AN ACK
	IORM	S1,.MSFLG(MO)		;SAVE IN MESSAGE HEADER
	MOVX	S1,.OHDRS		;ACK HEADER SIZE
	STORE	S1,.MSTYP(MO),MS.CNT	;SAVE IN HEADER
	$RETT				;RETURN
BLDA.1:	MOVE	S1,G$ERR		;GET THE ERROR CODE
	MOVE	S2,STSTBL(S1)		;GET STATUS FLAGS
	MOVEM	S2,.MSFLG(MO)		;SAVE THE FLAGS IN MESSAGE
	SKIPGE	S1,G$ERR		;GET ERROR CODE
	JRST	BLDA.3			;NO..PROCESS AS ITEXT
	MOVE	S2,TXTTBL(S1)		;ADDRESS OF MESSAGE
	MOVEI	S1,ARG.DA+.OHDRS(MO)	;ADDRESS TO STORE DATA
	$CALL	TXTMOV			;MOVE THE DATA
BLDA.2:	HRRZS	S1			;GET ENDING ADDRESS
	ADDI	S1,1			;BUMP IT BY 1
	ANDI	S1,777			;GET MESSAGE LENGTH
	STORE	S1,.MSTYP(MO),MS.CNT	;SAVE COUNT IN MESSAGE
	SUBI	S1,.OHDRS		;GET SIZE OF BLOCK
	STORE	S1,ARG.HD+.OHDRS(MO),AR.LEN	;SAVE ARGUMENT LENGTH
	MOVX	S1,.CMTXT		;GET TEXT CODE
	STORE	S1,ARG.HD+.OHDRS(MO),AR.TYP	;SAVE ARGUMENT TYPE
	AOS	.OARGC(MO)		;BUMP ARGUMENT COUNT
	$RETT				;RETURN
BLDA.3:	MOVEI	S2,ARG.DA+.OHDRS(MO)	;GET PLACE TO STORE TEXT
	HRLI	S2,(POINT 7,0)		;MAKE A POINTER
	MOVEM	S2,TXTPTR		;SAVE THE POINTER
	$TEXT	(ACKERR,<^I/@TXTTBL(S1)/^0>)	;PLACE TEXT IN MESSAGE
	MOVE	S1,TXTPTR		;GET TXTPTR
	JRST	BLDA.2			;FINISH OFF THE MESSAGE
ACKERR:	IDPB	S1,TXTPTR		;SAVE THE CHARACTER
	$RETT				;RETURN TRUE

SUBTTL	ADDNOD	Add a node to the list

COMMENT	\
ROUTINE TO SEE IF NODE IS ENTERED IN THE NODE LIST. IF NOT
ONE IS ENTERED AND THE MESSAGE AND OPR PID LISTS ARE GENERATED.

ON ENTRY:  S1=SIXBIT NODE NAME TO SEARCH FOR
	  S2/NODE NUMBER
TRUE RETURN: S1=ADR OF NODE BLOCK
\

ADDNOD:	$CALL	FNDNOD			;LOCATE THE NODE BLOCK
	$RETIT				;OK..RETURN
	MOVE	S1,G$NODL		;GET LIST NUMBER AGAIN
	$CALL	L%LAST			;POSITION TO END OF LIST
	MOVE	S1,G$NODL		;GET LIST NUMBER AGAIN
	MOVEI	S2,NOD.SZ		;NUMBER OF WORDS
	$CALL	L%CENT			;CREATE THE ENTRY
	SKIPT				;Skip this if true
	$STOP(CCE,Can't create list entry)
	STORE	T1,NOD.NM(S2)		;PLANT THE NODE NAME
	STORE	T2,NOD.NU(S2)		;SAVE NODE NUMBER
	MOVE	T1,S2			;COPY ENTRY ADDRESS TO T1
	$CALL	L%CLST			;CREATE A MESSAGE LIST
	STORE	S1,NOD.ML(T1)		;STORE MESSAGE LIST NUMBER
	SETZM	NOD.CT(T1)		;CLEAR MESSAGE COUNT
	SETZM	NOD.TM(T1)		;AUTO DISPLAY TIME
	$CALL	L%CLST			;CREATE A PID LIST
	STORE	S1,NOD.OP(T1)		;STORE THE OPR LIST NUMBER
	MOVE	S1,T1			;COPY ENTRY ADDRESS TO T1
	$RETT				;RETURN TRUE



SUBTTL	LOCNOD	Locate a node in the list

;THIS ROUTINE WILL LOCATE A GIVEN NODE IN THE NODE LIST
;AND RETURN TRUE IF FOUND WITH S2 ADDRESS OF ENTRY

;LOCNOD:	$CALL	CHKNOD		;CHECK THE NODE
;	$RETIF				;BAD NODE..RETURN
FNDNOD:	DMOVE	T1,S1			;COPY OUR ARG TO T1,T2
	MOVE	S1,G$NODL		;GET NODE LIST NUMBER
	$CALL	L%FIRST			;POSITION TO FIRST
	$RETIF				;NONE..RETURN FALSE
LOCN.1:	TLNN	T1,770000		;WAS IT SIXBIT?
	JRST	LOCN.3			;TRY NODE NUMBER
	CAME	T1,NOD.NM(S2)		;IS THIS THE NODE WE WANT?
	JRST	LOCN.4			;NOT THIS ONE, GO LOOK AT NEXT
LOCN.2:	MOVE	S1,S2			;COPY ENTRY ADDRESS TO S1
	$RETT				;AND RETURN
LOCN.3:	CAMN	T1,NOD.NU(S2)		;MATCH NODE NUMBER?
	JRST	LOCN.2			;SET NODE AND RETURN
LOCN.4:	MOVE	S1,G$NODL		;GET NOD LIST NUMBER
	$CALL	L%NEXT			;STEP TO NEXT ENTRY
	JUMPT	LOCN.1			;SEE IF ITS THE ONE
	DMOVE	S1,T1			;RESTORE NODE VALUES
	$RET				;NO..PASS FALSE UP
SUBTTL	DELNOD	Delete a node from the list

;This Routine will Delete a Node entry (Oprs at the Node).

DELNOD:	LOAD	S1,.OHDRS+ARG.HD(MI),AR.TYP	;GET THE MESSAGE TYPE
	CAIE	S1,.OROBJ		;OBJECT BLOCK?
	$RETF				;ERROR..RETURN
	LOAD	T1,.OHDRS+ARG.DA+OBJ.ND(MI)	;GET THE NODE NAME
	MOVX	S1,%ONLINE		;GET THE ONLINE FLAG
	TDNE	S1,.MSFLG(MI)		;WAS IT ONLINE?
	JRST	NODONL			;NODE ONLINE PROCESSING
	MOVE	S1,G$NODL		;GET THE NODE LIST
	$CALL	L%FIRST			;GET THE FIRST
	SKIPT				;O.K.. SKIP
	$STOP(NDE,Node database empty)
DELN.1:	MOVX	T2,ND.D60		;DN60 NODE
	TDNN	T2,NOD.FL(S2)		;IS IT A DN60 NODE?
	JRST	DELN.3			;NO..GET NEXT NODE
	CAME	T1,NOD.NM(S2)		;CHECK THE NODE NAME
	JRST	DELN.3			;NO.. TRY NEXT ONE
	MOVE	T2,S2			;SAVE NODE LIST ENTRY
DELN.2:	MOVE	S1,NOD.OP(T2)		;GET THE OPR LIST NUMBER
	$CALL	L%FIRST			;POSITION TO FIRST
	JUMPF	DELN.4			;O.K..EXIT NOW
	MOVE	S1,OPR.PD(S2)		;GET THE PID
	$CALL	DELOPR			;DELETE THE OPR
	JRST	DELN.2			;TRY AGAIN
DELN.3:	MOVE	S1,G$NODL		;GET THE NODE LIST
	$CALL	L%NEXT			;GET THE NEXT ONE
	JUMPT	DELN.1			;TRY IT
	$RETT				;RETURN
DELN.4:	MOVE	S1,G$NODL		;GET THE NODE LIST NUMBER
	$CALL	L%DENT			;DELETE THE ENTRY
	$RETIT				;O.K. RETURN
	$STOP	(DDF,Delete DN60 node failed)


SUBTTL	NODONL	Node on line for DN60

;This Routine will create the Opr and Node for a Dn60 Operator

NODONL:	SKIPN	P1,.OFLAG(MI)		;PORT ,,LINE MEANS DN60 ?
	$RETT				;NO ...RETURN
	HLRZ	S1,P1			;GET THE PORT NUMBER
	HRRO	S2,P1			;SETUP -1,, LINE NUMBER
	STORE	S1,S2,PPPLLL		;SAVE  AS -1,,PPPLLL
	EXCH	S2,G$SND		;SAVE AS THE SENDER
	MOVE	S1,.OHDRS+ARG.DA+OBJ.ND(MI) ;GET THE NODE NAME
	MOVEM	S1,G$ARG1		;SAVE THE NODE
	SETZ	S2,			;CLEAR NODE NUMBER
	TLNN	S1,700000		;Is it a real node name?
	MOVE	S2,S1			;No - set the real node number
	MOVX	T1,OP.REM!OP.D60	;REMOTE, AND DN60 OPR
	$CALL	ADDOPR			;ADD THE OPERATOR
	JUMPF	E$OAE			;OPR ALREADY EXISTS
	MOVE	S1,OPR.ND(S2)		;GET THE NODE ADDRESS
	MOVX	T1,ND.D60		;SET AS DN60 NODE
	IORM	T1,NOD.FL(S1)		;SET THE FLAG
	MOVX	T1,OP.NST		;CLEAR OPR NOT SETUP STATUS
	ANDCAM	T1,OPR.FL(S2)
	$RETT				;O.K. RETURN
SUBTTL	ADDOPR	Add an OPR to data base and node list

;THIS ROUTINE WILL CREATE AN ENTRY IN THE OPR TABLE AS WELL AS
;THE NODE-OPR LIST
;CALL -
;	S1/	NODE NAME
;	S2/	NODE NUMBER
;	T1/	OPERATOR PRIVILEGE BITS
;RETURN TRUE:	S2/ ADDRESS OF OPR ENTRY

ADDOPR:	$CALL	.SAVE3			;SAVE P1 AND P2 AND P3
	DMOVE	P1,S1			;SAVE THE NODE DATA
	MOVE	P3,T1			;SAVE THE OPERATOR FLAGS
TOPS10< $CALL	CHKOPR	>		;Check for duplicate OPR's
	MOVE	S1,G$SND		;GET THE OPRS PID
	$CALL	VALOPR			;CHECK IF SETUP
	JUMPT	.RETF			;FOUND...ERROR
	DMOVE	S1,P1			;RESTORE NODE DATA
	$CALL	ADDNOD			;LOCATE THE NODE OR CREATE NODE
					;S1 HAS NODE ENTRY ADDRESS ON RETURN
	MOVE	T1,S1			;SAVE NODE ADDRESS IN T1
	MOVE	S1,NOD.OP(T1)		;NODE LIST OF OPRS FOR NODE
	MOVE	T2,S1			;SAVE OPR LIST NUMBER IN T2
	MOVEI	S2,OPR.SZ		;SIZE OF OPR ENTRY
	$CALL	L%CENT			;CREATE AN ENTRY
	SKIPT				;Skip this if true
	PUSHJ	P,S..CCE		;Can't create entry, go STOP
	MOVE	S1,G$SND		;GET THE PID OF OPR..
	STORE	S1,OPR.PD(S2)		;SAVE PID IN ENTRY
	AOS	NOD.OC(T1)		;BUMP THE ACTIVE OPERATOR COUNT
	MOVX	S1,OP.NST		;NOT SETUP FLAG
	IORM	S1,OPR.FL(S2)		;SAVE IN OPR ENTRY FLAGS
	STORE	T1,OPR.ND(S2)		;SAVE NODE ENTRY ADDRESS IN OPR ENTRY
	STORE	T2,OPR.LS(S2)		;SAVE OPR LIST NUMBER IN LIST
ADDO.2:	MOVE	P1,S2			;SAVE OPR LIST ADDRESS IN P1
	SKIPN	TABFRE			;ANY FREE ENTRIES IN LIST
	$CALL	EXPTAB			;EXPAND THE OPR TABLE
	MOVE	S1,TABADR		;ADDRESS OF TABLE
ADDO.3:	SKIPN	TOP.PD(S1)		;IS THIS A FREE ENTRY
	JRST	ADDO.4			;FOUND ENTRY..PROCESS IT
	ADDI	S1,TOP.SZ		;TABLE ENTRY SIZE
	JRST	ADDO.3			;TRY NEXT ONE
ADDO.4:	MOVE	T1,S1			;SAVE CURRENT ADDRESS IN T1
	SOS	TABFRE			;DECREMENT FREE COUNT
	MOVE	T2,G$SND		;GET THE PID
	STORE	T2,TOP.PD(T1)		;SAVE PID IN TABLE
	STORE	P1,TOP.OA(T1)		;SAVE OPR ENTRY ADDRESS IN TABLE
	STORE	T1,OPR.TP(P1)		;SAVE TABLE ADDRESS IN OPR ENTRY
	MOVEM	P1,G$OPRA		;SAVE OPR ADDRESS
	$CALL	L$AOPR##		;ADD THE OPERATOR LOGGING
	MOVE	S1,G$SID		;GET USER NUMBER OR PPN
	MOVEM	S1,OPR.US(P1)		;SAVE USER IN OPR BLOCK
TOPS10<
	LOAD	S1,G$JOB		;GET THE JOB NUMBER
	$CALL	GETNAM			;GET THE USER NAME
	DMOVE	S1,JOBUSN		;GET USER NAME
	DMOVEM	S1,OPR.UN(P1)		;SAVE THE NAME
>;END TOPS10
	LOAD	S1,G$JOB		;GET JOB NUMBER
	MOVEM	S1,OPR.JB(P1)		;SAVE OPR JOB NUMBER
	MOVX	S2,JI.TNO		;GET TERMINAL NUMBER
	$CALL	I%JINF			;GET JOB INFO
	JUMPF	ADDO.5			;IGNORE IF FALSE***
	MOVEM	S2,OPR.TN(P1)		;SAVE TERMINAL NUMBER
ADDO.5:	MOVE	S2,P1			;GET OPR ADDRESS
	IORM	P3,OPR.FL(S2)		;AND SAVE THE FLAGS, TOO
	ADD	P1,[POINT <WID(WO.ALL)>,OPR.OF]
	MOVX	P2,.RTJST(-1,WO.ALL)	;GET ALL FLAGS
	MOVEI	P3,.OTMAX+NUMAPL+1	;GET NUMBER OF FIELDS

ADDO.6:	IDPB	P2,P1			;REQUEST DISPLAY FOR ALL
	SOJG	P3,ADDO.6

	MOVSI	P3,.OPDMX-1		;Get the number of OPR display words
	HRR	P3,S2			;Start at the beginning of DB entry
ADDO.7:	SETOM	OPR.DP(P3)		;Set the word to indicate all
	AOBJN	P3,ADDO.7		;Go back for more

	$RETT				;RETURN TRUE
SUBTTL	EXPTAB	Expand OPR table

;THIS ROUTINE WILL EXPAND THE OPR TABLE TO MAKE ROOM
;FOR MORE ENTRIES
;AS WELL AS THE OPR RESEND TABLE LENGTH

EXPTAB:	MOVE	S1,TABCNT		;GET COUNT OF ENTRIES NOW
	ADDI	S1,^D10			;INCREMENT TABLE BY 10 ENTRIES
	IMULI	S1,TOP.SZ		;OPR TABLE SIZE
	$CALL	M%GMEM			;GET THE MEMORY
	EXCH	S2,TABADR		;SAVE NEW ADDRESS AND GET OLD
	JUMPE	S2,EXPT.1		;FIRST TIME..NO TABLE SO FAR
	MOVE	T1,S2			;SAVE ADDRESS IN T1
	HRL	S2,S2			;SOURCE ADDRESS IN LEFT HALF
	HRR	S2,TABADR		;DESTINATION ADDRESS IN RIGHT
	MOVE	S1,TABCNT		;NUMBER OF ENTRIES
	IMULI	S1,TOP.SZ		;MULTIPLY BY ENTRY SIZE
	ADD	S1,TABADR		;ADD IN TABLE ADDRESS
	BLT	S2,-1(S1)		;MOVE THE TABLE
	MOVE	S2,T1			;PUT OLD ADDRESS IN S2
	MOVE	S1,TABCNT		;NUMBER OF ENTRIES
	IMULI	S1,TOP.SZ		;SIZE OF TABLE
	$CALL	M%RMEM			;RELEASE THE MEMORY
EXPT.1:	MOVE	S1,OPRRCT		;GET OPR COUNT
	ADDI	S1,^D10			;GET INCREMENT SIZE
	$CALL	M%GMEM			;GET SOME MEMORY
	EXCH	S1,OPRRCT		;GET THE OLD COUNT AND REPLACE WITH NEW
	EXCH	S2,OPRRSL		;RESEND LIST ADDRESS
	JUMPE	S2,EXPT.2		;FIRST TIME..=0 GO TO EXPT.1
	$CALL	M%RMEM			;RETURN THE OLD LIST
EXPT.2:	MOVEI	S1,^D10			;NUMBER OF ENTRIES TO INCREMENT
	ADDM	S1,TABCNT		;SAVE TABLE ENTRIES
	ADDM	S1,TABFRE		;SAVE FREE ENTRY COUNT
	MOVE	S1,TABADR		;GET THE TABLE ADDRESS
	MOVE	S2,TABCNT		;GET THE TABLE COUNT
EXPT.3:	SKIPN	T1,TOP.OA(S1)		;VALID ENTRY?
	$RETT				;NO..END OF LIST
	MOVEM	S1,OPR.TP(T1)		;RESET THE ADDRESS
	ADDI	S1,TOP.SZ		;GET NEXT ADDRESS
	SOJG	S2,EXPT.3		;TRY THE NEXT ONE
	$RETT				;ALL DONE..RETURN
SUBTTL	VALOPR	Validate the OPR

;THIS ROUTINE WILL CHECK TO SEE IF A GIVEN OPR PID IS VALID
;TO SEND COMMANDS TO ORION

;RETURNS S2/ ADDRESS OF OPR LIST ENTRY

VALOPR:	MOVE	S2,TABADR		;GET THE TABLE ADDRESS
	SKIPN	T1,TABCNT		;MAXIMUM NUMBER OF ENTRIES
	$RETF				;NONE SETUP SO FAR..RETURN
VALO.1:	CAMN	S1,TOP.PD(S2)		;CHECK PID FOR MATCH
	JRST	VALO.2			;MATCH..SETUP FOR RETURN
	ADDI	S2,TOP.SZ		;BUMP TO NEXT ENTRY
	SOJG	T1,VALO.1		;LOOP THROUGH ALL ENTRIES
	$RETF				;OPR NOT HERE..RETURN FALSE
VALO.2:	MOVE	S2,TOP.OA(S2)		;OPR LIST ENTRY ADDRESS
	$RETT				;RETURN TRUE

TOPS10 <
	SUBTTL	CHKOPR	Check if previously OPR

;  The purpose of this routine is to determine if the job trying
;  to start OPR has previously had OPR running and had ^Cd out.
;  If this is the case, then delete the previous OPR entry.
;  T1 contains Operator priv. bits (inc. DN60)

;	preserves all ACs except S1 and S2

CHKOPR:	TXNE	T1,OP.D60		;Is this a DN60 (from QUASAR)?
	$RET				;Yes - don't want any deleting

	$SAVE	<T1>
	MOVE	S2,TABADR		;Get table address
	SKIPN	T1,TABCNT		;Maximum number of entries
	$RET				;None - quit without prejudice
; LOOP

CHKO.1:	MOVE	S1,TOP.OA(S2)		;Get address of OPR entry
	MOVE	S1,OPR.JB(S1)		;Get the job number of this entry
	CAMN	S1,G$JOB		;Is this from the same job
	JRST	CHKO.2			;Yes, go get rid of it
	ADDI	S2,TOP.SZ		;Bump to next entry
	SOJG	T1,CHKO.1		;Loop on all entries
	$RET				;Done - quit without prejudice

CHKO.2:	MOVE	S1,TOP.PD(S2)		;Get the PID for the duplicate OPR
	$CALL	DELOPR			;Delete the OPR
	$RET				;and finish
> ;End of TOPS10
SUBTTL	DELOPR	Delete an OPR entry from table and node list

;THIS ROUTINE WILL REMOVE AN OPR ENTRY FROM THE TABLE
;OF OPRS AS WELL AS FROM THE NODE LIST OF OPRS.


DELOPR:	$CALL	.SAVET			;SAVE T REGS
	$CALL	VALOPR			;VALIDATE THE OPR
	SKIPT				;O.K...SKIP
	$RETF				;JUST RETURN FALSE
	MOVE	T1,OPR.TP(S2)		;ADDRESS OF OPR TABLE ENTRY
	AOS	TABFRE			;BUMP FREE ENTRY COUNT
	MOVE	T2,OPR.PD(S2)		;OPR PID
	SETZM	TOP.OA(T1)		;CLEAR ADDRESS OF ENTRY
	SETZM	TOP.PD(T1)		;CLEAR PID
	MOVE	S1,OPR.LS(S2)		;OPR LIST NUMBER
	$CALL	L%FIRST			;POSITION TO FIRST
	SKIPT				;OPR DELETE FATAL ERRO
	$STOP(ODE,OPR delete entry error)
DELO.1:	CAMN	T2,OPR.PD(S2)		;FOUND THE ENTRY
	JRST	DELO.2			;YES...DELETE ENTRY
	MOVE	S1,OPR.LS(S2)		;GET LIST NUMBER FROM ENTRY
	$CALL	L%NEXT			;GET NEXT ENTRY
	JUMPT	DELO.1			;CHECK OUT ENTRY
	$CALL	S..ODE			;FATAL ERROR EXIT
DELO.2:	MOVE	T1,OPR.ND(S2)		;GET NODE ADDRESS
	SOS	NOD.OC(T1)		;REDUCE OPRS AT NODE COUNT
	MOVEM	S2,G$OPRA		;SAVE OPR ADDRESS
	$CALL	L$DOPR##		;DELETE THE OPERATOR LOGGING
	MOVE	S2,G$OPRA		;GET OPR ADDRESS
	MOVE	S1,OPR.LS(S2)		;LIST NUMBER
	$CALL	L%DENT			;DELETE THE ENTRY
	JUMPF	S..ODE			;OPR DELETE ERROR
	$RET				;RETURN

;***NODE COUNT OF OPRS GOES TO ZERO..NODE NOT THERE..DELETE NODE
SUBTTL	SNDLST	Send unsent messages to OPR and OBJECTS

;THIS ROUTINE WILL TRY TO SEND THE UNSENT MESSAGES TO THE
;APPROPRIATE OPR OR OBJECT

;CALL	S1/	MESSAGES TO SEND

SNDLST:	$CALL	.SAVE1			;SAVE AN AC
	MOVE	P1,S1			;SAVE THE FLAGS
	MOVE	S1,G$SNDL		;GET SEND LIST
	$CALL	L%FIRST			;POSITION TO THE FIRST
	JUMPF	.RETT			;NONE..RETURN
SNDL.1:	TDNN	P1,RSD.FL(S2)		;CHECK FLAGS FOR OBJECT
	JRST	SNDL.2			;NO MATCH..TRY NEXT ONE
	MOVE	S1,G$SND		;GET SENDERS PID(OBJECT)
	$CALL	RSDPID			;RESEND TO PID AND DELETE IF O.K.
	JUMPF	.RETT			;ERROR..STOP SENDING
SNDL.2:	MOVE	S1,G$SNDL		;GET SEND LIST
	$CALL	L%NEXT			;POSITION TO THE NEXT ENTRY
	JUMPT	SNDL.1			;O.K...TRY NEXT ONE
	$RETT				;RETURN O.K.

SUBTTL	RSDPID	Resend messages to a specific PID

;CALL 	S1/	PID TO RESEND TO

RSDPID:	$CALL	.SAVE1			;SAVE 1 FOR SCRATCH
	MOVE	MO,RSD.MS(S2)		;GET MESSAGE ADDRESS
	ADDI	MO,(S2)			;GET ACTUAL ADDRESS
	MOVE	P1,S2			;SAVE ENTRY ADDRESS
	LOAD	S2,.MSTYP(MO),MS.CNT	;GET MESSAGE SIZE
	$CALL	CHKSFL			;CHECK FOR SEND FAILURES
	JUMPT	RSDP.3			;YES..JUST REQUEUE
	$CALL	SNDMSG			;SEND THE MESSAGE
	JUMPF	RSDP.2			;FAIL..QUEUE UP FOR RESEND
RSDP.1:	SOS	G$NSNT			;DECREMENT NOT SENT COUNT
	MOVE	S1,G$SNDL		;GET SEND LIST
	PJRST	L%DENT			;DELETE THE ENTRY AND RETURN
RSDP.2:	MOVE	S1,SNDBLK+SAB.PD	;GET THE PID
	$CALL	ADDSFL			;ADD THE SEND FAILURE
	MOVE	S1,G$RSDL		;QUEUE UP FOR RESEND
	$CALL	L%LAST			;POSTION TO THE END
	LOAD	S2,RSD.HD(P1),RS.LEN	;GET THE LENGTH OF ENTRY
	MOVE	S1,G$RSDL		;GET LIST NUMBER
	$CALL	L%CENT			;CREATE AN ENTRY
	SKIPT				;Skip this if true
	PUSHJ	P,S..CCE		;Can't create entry, go STOP
	MOVE	S1,G$SND		;GET SENDERS PID
	MOVE	T1,RSD.PD(P1)		;GET PID OFFSET
	ADDI	T1,(P1)			;POINT TO PID AREA
	MOVEM	S1,(T1)			;SAVE THE PID
	AOS	RSD.CT(P1)		;BUMP COUNT OF PIDS
	MOVE	S1,P1			;OLD ENTRY
	$CALL	MOVBLK			;MOVE THE BLOCK TO OTHER LIST
	SKIPN	G$RSDC			;FIRST MESSAGE TO RESEND?
	$CALL	REQRSD			;YES..REQUEST RESEND
	AOS	G$RSDC			;BUMP THE RESEND COUNT
	SETZM	RSDCNT			;CLEAR THE RESEND COUNT
	JRST	RSDP.1			;NOW DELETE OLD ONE
RSDP.3:	MOVEM	S1,SNDBLK+SAB.PD	;SAVE THE PID
	JRST	RSDP.2			;REQUEUE THE MESSAGE
SUBTTL	MOVARG	Setup argument in output message

;THIS ROUTINE WILL MOVE AN ARGUMENT BLOCK FROM INPUT TO OUTPUT
;MESSAGE
;
;CALL	S1/	ADDRESS OF SOURCE TEXT
;	S2/	LENGTH IN WORDS OF TEXT
;
;RETURN	P3/ UPDATED TO NEXT FREE OUTPUT LOCATION

MOVARG:: HRL	T1,S1			;ADDRESS OF TEXT SOURCE
	HRRI	T1,ARG.HD(P3)		;DESTINATION ADDRESS
	ADD	P3,S2			;GET ENDING ADDRESS
	BLT	T1,-1(P3)		;MOVE TEXT TO MESSAGE
	AOS	.OARGC(MO)		;BUMP THE ARGUMENT COUNT
	$RETT				;RETURN TRUE

SUBTTL	MOVAR2	Add a 2 word argument to the message

;ADDS A 2 WORD BLOCK TO THE MESSAGE
;CALL -
;	S1/	BLOCK TYPE
;	S2/	ARGUMENT DATA
;RETURNS -
;	TRUE

MOVAR2:: HRLI	S1,ARG.DA+1		;LENGTH
	MOVEM	S1,G$2SCR+ARG.HD	;SAVE IN TEMP
	MOVEM	S2,G$2SCR+ARG.DA	;SAVE DATA
	DMOVE	S1,[EXP G$2SCR,ARG.DA+1] ;AIM AT BLOCK, AND LENGTH
	PJRST	MOVARG			;MOVE IT IN


;*** CHECK FOR NULL ANSWER...
SUBTTL	SNDAOP	Send a message to all OPRs

;THIS ROUTINE WILL SEND A MESSAGE TO ALL OPRS AT A GIVEN NODE
;OR TO SYSTEM NODE IF NO OPRS AT THAT NODE
;OR IF -1 IS SET IN NODE ADDRESS TO ALL OPRS AT ALL NODES

SNDAOP:	SETZM	NOALTN			;ALTERNATE NODE IF NODE FAILS

;THIS ENTRY IS FOR NO ALTERNATES AND CALLER AS MADE NOALTN -1 TO
;PREVENT SEARCH OF OTHER NODES IF FAILS
SNDNAL:	$CALL	.SAVE1			;GET AN AC FOR SCRATCH
	MOVE	P1,S1			;SAVE THE NODE LIST ENTRY
	SETZM	MSGCNT			;CLEAR COUNT OF SENDS
	SETZM	RSDCNT			;SET RESEND COUNT INDICATOR
	CAMN	P1,[-1]			;IS IT -1
	JRST	SNDA.8			;YES..SEND TO ALL NODES
	$CALL	SNDOPR			;SEND TO THE OPRS AT NODE
	MOVX	S1,WT.SND		;GET 'SEND TO CENTRAL AND REMOTE' BIT
	TDNE	S1,.OFLAG(MI)		;WANT THIS?
	JRST	SNDA.1			;YES
	JUMPT	SNDA.5			;SENT O.K. CHECK RESENDS
	SKIPE	NOALTN			;SEND TO ALTERNATES ON FAILURE?
	$RET				;NO..RETURN..PASSING FALSE UP
SNDA.1:	MOVE	T1,NOD.FL(P1)		;GET ENTRIES FLAGS
	TXNE	T1,ND.SYS		;WAS IT THE SYSTEM NODE
	JRST	SNDA.5			;YES..CHECK RESEND AND RETURN
	MOVE	S1,G$NODL		;GET NODE LIST ENTRY
	$CALL	L%FIRST			;GET THE FIRST ENTRY
	JUMPF	SNDA.5			;No entries, skip this
SNDA.2:	MOVE	T1,NOD.FL(S2)		;CHECK FLAGS OF ENTRY
	TXNE	T1,ND.SYS		;SYSTEM OPR?
	JRST	SNDA.4			;YES..SEND TO ALL AT THIS NODE
SNDA.3:	MOVE	S1,G$NODL		;GET THE NODE LIST
	$CALL	L%NEXT			;GET THE NEXT ENTRY
	JUMPT	SNDA.2			;O.K. TRY NEXT ENTRY
	JRST	SNDA.5			;CHECK SEND AND RESEND INFO
SNDA.4:	MOVE	P1,S2			;GET THE ENTRY ADDRESS
	$CALL	SNDOPR			;SEND TO ALL OPRS
					;CHECK RESEND AND SEND AFTER RETURN
SNDA.5:	SKIPG	RSDCNT			;ANY RESENDS?
	JRST	SNDA.6			;YES.. REQUEUE THE MESSAGE
	SKIPN	G$RSDC			;FIRST MESSAGE TO BE RESENT?
	$CALL	REQRSD			;YES..REQUEST RESEND
	AOS	G$RSDC			;BUMP THE RESEND COUNT
	MOVX	S1,R.SOPR		;RESENDS FOR OPR
	MOVE	S2,G$RSDL		;RESENDS..(SEND FAILURE LIST)
	JRST	SNDA.7			;REQUEUE AND RELEASE
SNDA.6:	SKIPLE	S1,MSGCNT		;SENT MESSAGE TO ANYONE??
	PJRST	RELPAG			;YES..RELEASE PAGE AND RETURN
	AOS	G$NSNT			;BUMP NOT SENT COUNT
	MOVX	S1,R.SOPR!R.NSNT	;OPR MESSAGE NOT SENT
	MOVE	S2,G$SNDL		;LIST FOR UNSENT MESSAGES
SNDA.7:	$CALL	REQMSG			;REQUEUE THE MESSAGE
	PJRST	RELPAG			;RELEASE THE PAGE AND RETURN
SNDA.8:	MOVE	S1,G$NODL		;GET NODE LIST NUMBER
	$CALL	L%FIRST			;POSITION TO THE FIRST
	JUMPF	SNDA.5			;No entries, skip this
SNDA.9:	MOVE	P1,S2			;GET THE ADDRESS IN P1
	$CALL	SNDOPR			;SEND TO ALL OPRS AT NODE
	MOVE	S1,G$NODL		;GET NODE LIST NUMBER
	$CALL	L%NEXT			;GET THE NEXT ENTRY
	JUMPF	SNDA.5			;ANALYZE RESULTS AND RETURN
	JRST	SNDA.9			;TRY NEXT ONE
SUBTTL	SNDOPR	Send a message to at least one OPR

;THIS ROUTINE WILL SEND THE MESSAGE TO ALL OPRS AND RETURN FALSE
;IF NO OPRS AT NODE OTHERWISE WILL BE QUEUED UP FOR THE OPR


SNDOPR:	MOVE	T4,MSGCNT		;SAVE MESSAGE COUNT VALUE
	MOVE	T3,RSDCNT		;GET THE CURRENT RESEND COUNT
	LOAD	S1,NOD.OP(P1)		;GET OPR LIST NUMBER
	$CALL	L%FIRST			;POSITION TO FIRST ENTRY
	$RETIF				;RETURN FALSE
SNDO.1:	MOVEM	S2,G$OPRA		;SAVE OPR BASE ADDRESS
	MOVE	T2,OPR.FL(S2)		;GET THE OPRS FLAGS
	TXNE	T2,OP.NST		;IS OPR SETUP?
	JRST	SNDO.6			;IGNORE THIS OPR
	$CALL	CHKOSD			;CHECK IF OPR WANTS MESSAGE
	JUMPF	SNDO.5			;NO..BYPASS THIS OPR
SNDO.2:	MOVE	S2,G$OPRA		;GET THE OPR ADDRESS
	LOAD	S1,OPR.PD(S2)		;GET THE OPRS PID
	MOVE	T2,S1			;SAVE THE PID
	$CALL	CHKSFL			;CHECK FOR SEND FAILURES ON PID
	JUMPT	SNDO.4			;MARK FOR RESEND
	LOAD	S2,.MSTYP(MO),MS.CNT	;GET THE MESSAGE LENGTH
	$CALL	SNDMSG			;SEND THE MESSAGE
	JUMPT	SNDO.5			;O.K. COUNT IT AND SEND TO OTHERS
	AOS	G$SNDF			;BUMP SEND FAILURE COUNT
	CAXE	S1,ERNSP$		;NO SUCH PID??
	JRST	SNDO.4			;MARK TO RESEND
SNDO.3:	MOVE	S1,T2			;GET THE BAD PID
	$CALL	DELOPR			;DELETE THE OPERATOR
	JRST	SNDO.6			;TRY NEXT OPERATOR
SNDO.4:	MOVE	S1,T2			;GET THE PID
	$CALL	ADDSFL			;ADD SEND FAILURE PID
	JRST	SNDO.6			;TRY NEXT OPR
SNDO.5:	AOS	MSGCNT			;BUMP THE SEND COUNT
SNDO.6:	LOAD	S1,NOD.OP(P1)		;GET OPR PID LIST
	$CALL	L%NEXT			;GET THE NEXT ENTRY
	JUMPT	SNDO.1			;TRY NEXT OPR
	CAML	T4,MSGCNT		;SEND ANY MESSAGES
	CAMGE	T3,RSDCNT		;REQUEUE ANY MESSAGES
	$RETT				;YES..RETURN TRUE
	$RETF				;NO..SENDS
SUBTTL	CHKOSD	Check message flags for OPR

;THIS ROUTINE WILL DETERMINE IF OPR WANTS TO SEE THE MESSAGE
;AND
;
;RETURN	TRUE:	OPR WANTS TO SEE IT
;RETURN FALSE:	OPR DOESN'T WANT TO SEE IT

CHKOSD:	SKIPE	G$ASND			;ALWAYS SEND MESSAGE?
	$RETT				;YES..MAKE OPR SEE IT
	MOVE	S1,WDAOBT		;GET OBJECT TYPE FROM MESSAGE
	MOVE	S2,WDAFLG		;GET THE FLAGS FROM MESSAGE

;  Here to check for object display

	MOVE	TF,S2			;Save the flags
	CAILE	S1,APLBEG		;Application object type?
	SUBI	S1,APLBEG-.OTMAX	;Yes..compute object offset
	CAILE	S1,.OTMAX+NUMAPL	;Check range
	$RETF

	IDIVI	S1,<^D36/<WID(WO.ALL)>>	;Compute word offset
	IMULI	S2,<WID(WO.ALL)>	;Compute bit offset
	MOVNS	S2			;Force shift righte
	LSH	TF,0(S2)		;Position the flags
	ADD	S1,G$OPRA		;Add base of OPR entry
	TDNN	TF,OPR.OF(S1)		;Test the flags
	$RETF				;All flags were off

;  Here to send or not based on message type

	SKIPN	S1,WDADTY		;Get display type, any set?
	$RETT				;No, then we don't care
	$CALL	MAPBIT			;Go get bit to check
	ADD	S1,G$OPRA		;Add base of OPR entry
	TDNN	S2,OPR.DP(S1)		;Is it ok?
	$RETF				;No
	$RETT				;Yes, allow it

SUBTTL	MOVBLK	Move a standard argument block

;THIS ROUTINE WILL MOVE A STANDARD GALAXY BLOCK FROM
;SOURCE ADDRESS TO DESTINATION ADDRESS
;THE LENGTH IS GOTTEN FROM SOURCE FIRST WORD..(HEADER)
;
;CALL	S1/	SOURCE ADDRESS
;	S2/	DESTINATION ADDRESS
;
;RETURN	S2/	UPDATED DESTINATION ADDRESS
;
;SCRATCH AC T1

MOVBLK:	HRL	T1,S1			;GET SOURCE ADDRESS IN LEFT HALF
	HRR	T1,S2			;AND DESTINATION IN RIGHT HALF
	LOAD	S1,ARG.HD(S1),AR.LEN	;GET THE LENGTH OF BLOCK
	ADD	S2,S1			;GET ENDING ADDRESS
	BLT	T1,-1(S2)		;MOVE THE BLOCK
	$RETT				;RETURN TRUE
SUBTTL	REQMSG	Reque a message to be sent later

;THIS ROUTINE WILL SETUP THE RESEND ENTRY FOR A MESSAGE
;
;CALL	S1/	FLAGS FOR REQUEUE
;	S2/	LIST NUMBER TO REQUEUE IN
;
;RETURN	S2/	ENTRY ADDRESS

REQMSG:	DMOVE	T3,S1			;SAVE S1 AND S2 IN T3 AND T4
	MOVE	S1,T4			;GET RESEND LIST ADDRESS
	$CALL	L%LAST			;POSITION TO THE END
	LOAD	S2,.MSTYP(MO),MS.CNT	;GET THE MESSAGE COUNT
	ADDI	S2,RSD.SZ		;GET SIZE OF BLOCK AND PID LIST HEADER
	SKIPG	S1,RSDCNT		;ANY RESENDS
	MOVEI	S1,1			;ALWAYS LEAVE 1
	ADD	S2,S1			;GET THE NEW COUNT
	MOVE	S1,T4			;GET RESEND LIST NUMBER
	MOVE	T1,S2			;SAVE SIZE OF ENTRY
	$CALL	L%CENT			;CREATE AN ENTRY
	SKIPT				;Skip this if true
	PUSHJ	P,S..CCE		;Can't create entry, go STOP
	STORE	T1,RSD.HD(S2),RS.LEN	;SAVE THE LENGTH
	MOVE	S1,G$NOW		;GET THE TIME
	MOVEM	S1,RSD.TM(S2)		;SAVE TIME IN ENTRY
	MOVE	T2,S2			;SAVE ENTRY ADDRESS
	MOVEI	S1,RSD.SZ		;GET RESEND BLOCK SIZE
	MOVEM	S1,RSD.PD(S2)		;SAVE AS PID OFFSET
	MOVEI	T1,RSD.SZ+1		;OFFSET FOR MESSAGE..LEAVE FOR 1 PID
	SKIPG	RSDCNT			;MOVE PID LIST IF ANY
	JRST	REQM.1			;ASSUME 1
	HRL	S1,OPRRSL		;ADDRESS OF RESEND LIST
	HRRI	S1,RSD.SZ(S2)		;START OF FREE AREA
	MOVEI	T1,RSD.SZ(S2)		;ADDRESS OF DESTINATION STARTING POINT
	ADD	T1,RSDCNT		;ADD IN NUMBER OF PIDS
	BLT	S1,-1(T1)		;MOVE THE PIDS
	SUB	T1,S2			;GET THE OFFSET
REQM.1:	MOVEM	T1,RSD.MS(S2)		;SAVE OFFSET FOR MESSAGE
	MOVE	T2,S2			;SAVE MESSAGE ADDRESS
	ADD	S2,T1			;POSITION TO TEXT
	MOVEI	S1,.MSTYP(MO)		;GET THE MESSAGE ADDRESS
	$CALL	MOVBLK			;MOVE THE BLOCK
	IORM	T3,RSD.FL(T2)		;NO..SAVE THE FLAGS
	MOVE	S2,T2			;SAVE THE ADDRESS
	SETZ	S1,			;CLEAR S1
	EXCH	S1,RSDCNT		;RESET AND GET RSDCNT
	MOVEM	S1,RSD.CT(S2)		;SAVE THE COUNT
	$RETT				;RETURN S2, ENTRY ADDRESS
SUBTTL	RSDMSG	Resend requed messages

;THIS ROUTINE WILL TRY TO SEND ANY MESSAGES QUEUED UP IN THE SYSTEM
;AND WILL DELETE FROM THE QUEUE WHEN SENT TO ALL PIDS OR RETRY COUNT
;EXHAUSTED

RSDMSG:	SKIPN	G$RSDC			;ANY MESSAGES TO RESEND
	$RETT				;NO..RETURN O.K.
	$CALL	RSDM.0			;YES..SEND WHAT WE CAN
	SKIPN	G$RSDC			;GET ALL OF THEM?
	$RETT				;YES..JUST RETURN
REQRSD:	MOVEI	S1,^D15*^D1000		;NO..RETRY IN 15 SECONDS
	MOVEI	S2,RSDMSG
	$CALL	REQTIM			;MAKE THE TIMER REQUEST
	$RETT

RSDM.0:	$CALL	CLRSFL			;CLEAR SEND FAILURE LIST
	SETZM	RSDCNT			;CLEAR THE RESEND COUNT
	$CALL	.SAVE3			;GET SOME SCRATCH ACS
	MOVE	S1,G$RSDL		;GET RESEND LIST NUMBER
	$CALL	L%FIRST			;POSITION TO THE FIRST ENTRY
	SKIPT				;SKIP IF THERE
	$STOP(RCO,G$RSDC off .. does not match list data)
	MOVE	P1,S2			;SAVE ADDRESS IN S2
RSDM.1:	MOVE	P2,RSD.CT(P1)		;GET COUNT OF PIDS
	MOVE	P3,RSD.PD(P1)		;GET PID OFFSET
	ADDI	P3,(P1)			;COMPUTE MESSAGE ADDRESS
RSDM.2:	SKIPN	S1,(P3)			;GET THE FIRST PID
	JRST	RSDM.4			;ZERO..GET NEXT ENTRY
	$CALL	CHKSFL			;CHECK FOR SEND FAILURE ON PID
	JUMPT	RSDM.4			;CHECK NEXT ONE
	MOVE	MO,RSD.MS(P1)		;GET MESSAGE ADDRESS
	ADDI	MO,(P1)			;GET ACTUAL ADDRESS
	LOAD	S2,.MSTYP(MO),MS.CNT	;GET MESSAGE LENGTH
	$CALL	SNDMSG			;SEND THE MESSAGE
	JUMPF	RSDM.7			;SEND FAILURE..UP COUNTS
	MOVX	S1,R.NSNT		;CLEAR THE NOT SENT FLAG
	ANDCAM	S1,RSD.FL(P1)		;CLEAR IT IN BLOCK
RSDM.3:	SETZM	(P3)			;CLEAR THE PID ENTRY
	SOSG	RSD.CT(P1)		;ANY MORE PIDS LEFT
	JRST	RSDM.5			;NO..REMOVE ENTRY
RSDM.4:	AOS	P3			;NEXT PID
	SOJG	P2,RSDM.2		;CHECK IF MORE
	JRST	RSDM.6			;GET NEXT ENTRY
RSDM.5:	MOVX	S1,R.NSNT		;GET THE NOT SENT FLAG
	TDNE	S1,RSD.FL(P1)		;WAS IT EVER SENT
	$CALL	REQNST			;REQUEUE FOR NOT SENT
	MOVE	S1,G$RSDL		;GET THE RESEND LIST
	$CALL	L%DENT			;DELETE THE ENTRY
	SOSGE	G$RSDC			;DECREMENT RESEND COUNT
	$STOP(RCN,G$RSDC is negative database confused)
RSDM.6:	MOVE	S1,G$RSDL		;GET THE LIST NUMBER
	$CALL	L%NEXT			;GET THE NEXT ENTRY
	JUMPF	.RETT			;DONE..RETURN
	SETZM	RSDCNT			;CLEAR THE RESEND COUNT
	MOVE	P1,S2			;SAVE THE MESSAGE ADDRESS
	JRST	RSDM.1			;TRY THIS ONE
RSDM.7:	AOS	G$SNDF			;BUMP SEND FAILURE COUNT
	AOS	RSD.RT(P1)		;BUMP THE RETRY COUNT...****
	CAXE	S1,ERNSP$		;NO SUCH PID??
	JRST	RSDM.8			;NO..RETRY LATER
	MOVE	S1,RSD.FL(P1)		;GET THE FLAGS
	TXNN	S1,R.SOPR		;WAS IT OPR RESEND
	JRST	RSDM.3			;DELETE PID FROM ENTRY
	MOVE	S1,(P3)			;GET THE PID
	$CALL	DELOPR			;DELETE THE OPR
	JRST	RSDM.3			;TRY NEXT ONE
RSDM.8:	MOVE	S1,(P3)			;GET THE PID
	$CALL	ADDSFL			;ADD THE SEND FAILURE
	JRST	RSDM.4			;FINISH OFF ENTRY
SUBTTL	REQNST	Reque unsent messages

;THIS ROUTINE WILL MOVE A RESEND BACK TO THE NEVER SENT QUEUE IF MESSAGE
;NOT SENT AND OPR INVALID

REQNST:	MOVE	S1,G$SNDL		;NOT SENT LIST
	$CALL	L%LAST			;POSITION TO LAST
	AOS	G$NSNT			;BUMP NOT SENT COUNT
	MOVE	S1,G$SNDL		;GET LIST NUMBER AGAIN
	LOAD	S2,RSD.HD(P1),RS.LEN	;GET LENGTH OF BLOCK
	$CALL	L%CENT			;CREATE AN ENTRY
	SKIPT				;Skip this if true
	PUSHJ	P,S..CCE		;Can't create entry, go STOP
	MOVE	S1,P1			;ADDRESS OF OLD ONE
	PJRST	MOVBLK			;MOVE THE BLOCK AND RETURN
SUBTTL	ADDSFL	Add a send failure to table
;
;S1/	PID TO ADD

ADDSFL:	MOVEM	S1,G$SFPD		;SAVE THE PID
	SKIPN	SFLFRE			;ANY AVAILABLE ENTRIES
	$CALL	ADDP.3			;NO...GET SOME MORE
	$CALL	.SAVE2			;GET A SCRATCH AC
	MOVE	S1,G$SFPD		;GET THE PID
	$CALL	CHKS.0			;CHECK IF IN LIST
	JUMPT	ADDP.5			;BUMP THE COUNT AND RETURN
	MOVE	S2,SFLADR		;GET ADDRESS OF TABLE
ADDP.1:	SKIPN	SFL.PD(S2)		;IS THE ENTRY AVAILABLE
	JRST	ADDP.2			;YES..USE IT
	ADDI	S2,SFL.SZ		;BUMP TO NEXT ONE
	JRST	ADDP.1			;TRY AGAIN
ADDP.2:	MOVE	S1,G$SFPD		;GET THE PID
	MOVEM	S1,SFL.PD(S2)		;SAVE PID IN TABLE
	AOS	SFL.CT(S2)		;BUMP COUNT OF MESSAGES
	SOS	SFLFRE			;DECREMENT FREE LOCATIONS
ADDRTY:	AOS	S2,RSDCNT		;BUMP RESEND COUNT AND PLACE IN S2
	ADD	S2,OPRRSL		;GET ADDRESS FOR ENTRY
	MOVEM	S1,-1(S2)		;SAVE THE PID
	$RETT				;RETURN
ADDP.3:	$CALL	.SAVE2			;SAVE P1
	MOVE	S1,SFLCNT		;GET NUMBER OF ENTRIES
	ADDI	S1,^D10			;INCREMENT COUNT
	IMULI	S1,SFL.SZ		;GET SIZE NEEDED FOR TABLE
	$CALL	M%GMEM			;GET THE MEMORY
	MOVE	P1,S2			;SAVE THE ADDRESS
	SKIPN	SFLCNT			;ZERO COUNT
	JRST	ADDP.4			;YES..UPDATE AND RETURN
	MOVE	P2,SFLCNT		;GET COUNT OF ENTRIES
	IMULI	P2,SFL.SZ		;COMPUTE LENGTH OF TABLE
	ADD	P2,S2			;GET ENDING ADDRESS OF NEW TABLE
	HRL	S1,SFLADR		;GET ADDRESS OF OLD TABLE
	HRR	S1,S2			;AND ADDRESS OF NEW TABLE
	BLT	S1,-1(P2)		;MOVE THE TABLE
	MOVE	S1,SFLCNT		;GET OLD COUNT
	IMULI	S1,SFL.SZ		;MULTIPLY BY ENTRY SIZE
	MOVE	S2,SFLADR		;GET OLD ADDRESS
	$CALL	M%RMEM			;RETURN THE MEMORY
ADDP.4:	MOVEM	P1,SFLADR		;SAVE NEW ADDRESS
	MOVEI	S1,^D10			;GET INCREMENT
	ADDM	S1,SFLCNT		;SAVE NEW COUNT
	ADDM	S1,SFLFRE		;SAVE NEW FREE COUNT
	$RETT				;RETURN
ADDP.5:	AOS	SFL.CT(P2)		;INCREMENT THE COUNT
	MOVE	S1,G$SFPD		;GET THE BAD PID
	PJRST	ADDRTY			;ADD TO RETRY LIST
	$RETT				;RETURN
					;P2 SET FROM CHKSFL(CHKS.0)
SUBTTL	DELSPL	Delete a send failure entry

;THIS ROUTINE WILL REMOVE ENTRY FROM SEND FAILURE PID TABLE

DELSPL:	$CALL	.SAVE2			;SAVE TWO ACS
	$CALL	CHKS.0			;CHECK AND GET ACS RETURNED
	SKIPT				;O.K. ENTRY ADDRESS IN T2
	$STOP(DSP,Delete send Failure pid table entry inconsistency)
	SETZM	SFL.PD(P2)		;CLEAR PID ENTRY
	SETZM	SFL.CT(P2)		;CLEAR THE COUNT ENTRY
	AOS	SFLFRE			;BUMP FREE COUNT
	$RETT				;RETURN



SUBTTL	CHKSFL	Check send failure entries

;THIS ROUTINE WILL CHECK FOR PID IN TABLE


;CALL	S1/	PID TO CHECK
;
;RETURN	 TRUE:	FOUND ENTRY
;RETURN FALSE: DIDN'T FIND ENTRY

CHKSFL:	$CALL	.SAVE2			;GET TWO SCRATCH ACS
CHKS.0:	MOVE	P1,SFLCNT		;GET NUMBER OF ENTRIES
	CAMN	P1,SFLFRE		;ARE ANY ENTRIES USED
	$RETF				;NO..RETURN FALSE
	MOVN	P1,P1			;SETUP AOBJN POINTER
	HRLZS	P1			;MAKE AOBJN POINTER
	MOVE	P2,SFLADR		;GET THE ADDRESS
CHKS.1:	CAMN	S1,SFL.PD(P2)		;CHECK FOR PID
	$RETT				;RETURN TRUE
	ADDI	P2,SFL.SZ		;GET TO NEXT ENTRY
	AOBJN	P1,CHKS.1		;TRY NEXT ONE
	$RETF				;COULDN'T FIND

SUBTTL	CLRSFL	Clear send failure list

;THIS ROUTINE WILL CLEAR TABLE SO WE CAN RECONSTRUCT IT

CLRSFL:	SKIPN	S1,SFLCNT		;ANY ENTRIES
	$STOP(SFI,Send failure table inconsistent)
	MOVEM	S1,SFLFRE		;RESET FREE COUNT
	IMULI	S1,SFL.SZ		;COMPUTE SIZE
	MOVE	S2,SFLADR		;GET THE ADDRESS
	PJRST	.ZCHNK			;CLEAR AND RETURN
SUBTTL	SNDQSR	Send a message to QUASAR

;THIS ROUTINE WILL SEND THE APPROPRIATE MESSAGE TO QUASAR


SNDQSR::MOVE	S1,G$SND		;GET THE SENDERS PID
	STORE	S1,.MSCOD(MO)		;SAVE IN MESSAGE
	MOVX	S1,SP.QSR+SI.FLG	;INDICATE TO QUASAR
	STORE	S1,SNDBLK+SAB.SI	;IN SAB
	SETZM	SNDBLK+SAB.PD		;CLEAR PID WORD
	MOVEI	S2,PAGSIZ		;GET SIZE OF THE MESSAGE
	$CALL	SNDM.1			;SEND THE MESSAGE
	$RETIT				;OK..RETURN
	MOVEI	S1,[ASCIZ/QUASAR/]	;GET QUASARS NAME
	MOVEM	S1,G$ARG1		;SAVE STRING
	PJRST	TAKABT			;DO TAKE ABORT


SUBTTL	SNDACT	Send a message to ACTDAE

TOPS10 <

SNDACT::MOVX	S1,SP.ACT+SI.FLG	;SEND TO ACCOUNT DAEMON
	STORE	S1,SNDBLK+SAB.SI
	SETZM	SNDBLK+SAB.PD
	MOVE	S1,G$SND		;GET SENDERS PID
	MOVEM	S1,.MSCOD(MO)		;STORE AS ACK CODE
	MOVEI	S2,PAGSIZ		;GET SIZE OF MESSAGE
	PJRST	SNDM.1			;SEND IT OFF

>;END TOPS10

SUBTTL	SQSD60	Send a message to QUASAR about DN60

IFN FTDN60,<
;This routine sends a DN60 message to QUASAR.  It differs from SNDQSR
;only because it sends a message size of 777.  This is because a message size
;of 1000 causes the page to be released twice since the main loop thinks
;it is sending messages to multiple operators.  UNDERSTAND?

SQSD60::MOVE	S1,G$SND		;GET THE SENDERS PID
	STORE	S1,.MSCOD(MO)		;SAVE IN MESSAGE
	MOVX	S1,SP.QSR+SI.FLG	;INDICATE TO QUASAR
	STORE	S1,SNDBLK+SAB.SI	;IN SAB
	SETZM	SNDBLK+SAB.PD		;CLEAR PID WORD
	MOVEI	S2,777			;Size that forces retention of page
	$CALL	SNDM.1			;SEND THE MESSAGE
	$RETIT				;OK..RETURN
	MOVEI	S1,[ASCIZ/QUASAR/]	;GET QUASARS NAME
	MOVEM	S1,G$ARG1		;SAVE STRING
	PJRST	TAKABT			;DO TAKE ABORT
>;end FTDN60
SUBTTL	SNDMSG	Send a message to a specific PID

;ON ENTRY S1=PID TO SEND TO
;	S2 = LENGTH OF MESSAGE (1000 IMPLIES A PAGE MODE SEND)
;	MO=ADDRESS OF MESSAGE BLOCK

SNDMSG:	STORE	S1,SNDBLK+SAB.PD	;SAVE IN ARG BLOCK
	SETZM	SNDBLK+SAB.SI		;NOT TO SPECIAL PID
SNDM.1:	STORE	S2,SNDBLK+SAB.LN	;SAVE LENGTH IN SAB
	STORE	MO,SNDBLK+SAB.MS	;SAVE ADDRESS IN ARG BLOCK

IFN	FTDN60,<
	HLRZ	T1,SNDBLK+SAB.PD	;GET THE PID
	CAIE	T1,-1			;CHECK FOR -1
	JRST	SNDM.2			;DN60 ACK/WTO
	MOVE	T1,G$OPRA		;GET THE OPR ADDRESS
	MOVX	S1,OP.D60		;GET D60 FLAG
	TDNN	S1,OPR.FL(T1)		;IS IT A DN60 MESSAGE?
	JRST	SNDM.2			;NO.. DO NORMAL IPCF SENDING
	MOVE	S1,OPR.ND(T1)		;GET NODE ADDRESS
	MOVE	S1,NOD.NM(S1)		;GET NODE NAME
;	MOVE	S1,OPR.PL(T1)		;GET THE PORT LINE WORD
	MOVEM	S1,G$SND		;SAVE AS RETURN CODE
	MOVEI	S1,.OMDSP		;MAKE SURE DISPLAY TYPE
	STORE	S1,.MSTYP(MO),MS.TYP	;SAVE THE TYPE
	PJRST	SQSD60			;SEND IT TO QUASAR
>;END FTDN60

SNDM.2:	SETZM	PAGFLG			;CLEAR A FLAG
	MOVE	T1,SNDBLK+SAB.LN	;GET THE LENGTH
	CAIE	T1,PAGSIZ		;GET THE PAGE SIZE
	JRST	SNDM.3			;NO..SEND AS IS
	LOAD	T1,.MSTYP(MO),MS.CNT	;GET MESSAGE LENGTH
	CAMLE	T1,G$MAXP		;CAN WE SEND A PACKET
	JRST	SNDM.3			;NO..
	SETOM	PAGFLG			;SET THE FLAG
	MOVEM	T1,SNDBLK+SAB.LN	;RESET THE LENGTH
SNDM.3:	MOVX	S1,SAB.SZ		;GET LENGTH IN S1
	MOVEI	S2,SNDBLK		;AND ADDRESS IN S2
	$CALL	C%SEND			;SEND THE MESSAGE
	 $RETIF				;ERROR..RETURN
	SKIPE	PAGFLG			;WAS IT A PAGE?
	$CALL	RELPAG			;YES..RELEASE THE PAGE
	$RETT

SUBTTL	SPDOPR	Send a message to an OPR

;THIS ROUTINE WILL SEND MESSAGE TO AN OPR AND REQUEUE ON A
;FAILURE

SPDOPR:	SETZM	RSDCNT			;CLEAR RESEND COUNT
	$CALL	CHKSFL			;CHECK SEND FAILURES
	JUMPT	SPDO.0			;REQUEUE MESSAGE
	$CALL	SNDMSG			;SEND THE MESSAGE
	$RETIT				;O.K..JUST RETURN
	CAXN	S1,ERNSP$		;NO SUCH PID?
	JRST	SPDO.3			;YES..DELETE OPR AND RELEASE MESSAGE
	MOVE	S1,SNDBLK+SAB.PD	;GET THE PID
SPDO.0:	$CALL	ADDSFL			;ADD PID TO SEND FAILURE LIST
SPDO.1:	MOVX	S1,R.SOPR		;SETUP AS OPR RESEND
SPDO.2:	SKIPN	G$RSDC			;FIRST MESSAGE TO BE RESENT?
	JRST	[PUSH P,S1		;YES..PRESERVE S1
		 $CALL REQRSD		;REQUEST RESEND
		 POP P,S1
		 JRST .+1]
	AOS	G$RSDC			;BUMP THE RESEND COUNT
	MOVE	S2,G$RSDL		;GET THE RESEND LIST
	$CALL	REQMSG			;REQUEUE THE MESSAGE
	PJRST	RELPAG			;RELEASE THE PAGE AND RETURN
SPDO.3:	MOVE	S1,SNDBLK+SAB.PD	;GET THE PID
	$CALL	VALOPR			;VALIDATE THE OPR
	SKIPT				;CONTINUE
	$STOP(ODI,OPR database inconsistent)
	MOVE	S1,SNDBLK+SAB.PD	;GET THE PID
	$CALL	DELOPR			;DELETE THE OPR
	$CALL	RELPAG			;RELEASE THE PAGE
	$RETF				;AND RETURN FALSE
SUBTTL	SNDPID	Send a message to any PID (not OPR)

;THIS ROUTINE WILL SEND MESSAGE TO ANY PID AND REQUEUE ON FAILURE

SNDPID:	SETZM	RSDCNT			;CLEAR RSDCNT
	$CALL	CHKSFL			;CHECK SEND FAILURE TABLE
	JUMPT	SNDP.1			;REQUEUE THE MESSAGE
	$CALL	SNDMSG			;SEND THE MESSAGE
	$RETIT				;OK..RETURN
	CAXN	S1,ERNSP$		;NO SUCH PID
	$RETF				;RETURN FALSE..NO SUCH PID
	MOVE	S1,SNDBLK+SAB.PD	;GET THE PID
SNDP.1:	$CALL	ADDSFL			;ADD SEND FAILURE LIST
SNDP.2:	SETZ	S1,			;NO FLAGS
	PJRST	SPDO.2			;REQUEUE MESSAGE AND RETURN
SUBTTL	Interrupt Handler

INT:	$BGINT	IPCLEV
	$CALL	C%INTR			;SIGNAL THE INTERRUPT
	$DEBRK
SUBTTL	Default PDBs for OPRCMD

IFN	FTDN60,<

TXTLIN::MOVEI	S2,[ASCIZ/Multiple line text not allowed for remote operators/]
	$RETF
WAITAC:: MOVEI	S2,[ASCIZ/Wait command not allowed for remote operators/]
	$RETF
TAKOPR::
ENTFDB::
WAIOPR::
EXTFDB::$CRLF(<$PREFILL(BADFDB)>)

SETTRM::
SETRTN::
PUSHRT::
BADFDB:	MOVEI	S2,[ASCIZ/Command invalid for remote operators/]
	$RETF

CMDACT::$RETT

>;END FTDN60

SUBTTL	SETOUT	Setup output of data

;THIS ROUTINE WILL SETUP A DISPLAY MESSAGE FOR A DN60 OPERATOR

IFN	FTDN60,<
SETOUT:: $CALL	SETPTR			;SETUP THE POINTER
	MOVEM	S1,WTOPTR		;SAVE THE POINTER
	$TEXT	(,<^M^J^N/G$HOST/::^A>)	;OPR HEADER LINE
	$RET				;RETURN

SUBTTL	SNDOUT	Output routines for DN60

;THIS ROUTINE WILL SEND DATA TO QUASAR FOR OUTPUT TO DN60

SNDOUT:: MOVX	S1,0			;GET A NULL
	IDPB	S1,WTOPTR		;END WITH A NULL
	HRRZ	S1,WTOPTR		;GET END ADDRESS
	ADDI	S1,1			;BUMP IT BY 1
	ANDI	S1,777			;GET MESSAGE LENGTH
	STORE	S1,.MSTYP(MO),MS.CNT	;SAVE THE COUNT
	SUBI	S1,.OHDRS		;GET THE BLOCK SIZE
	STORE	S1,.OHDRS+ARG.HD(MO),AR.LEN	;SAVE THE BLOCK LENGTH
	MOVX	S1,.CMTXT		;GET TEXT TYPE
	STORE	S1,.OHDRS+ARG.HD(MO),AR.TYP	;SAVE THE TYPE
	MOVE	S1,G$SND		;PID TO SEND TO
	MOVEI	S2,PAGSIZ		;GET PAGE SIZE
	PJRST	SNDPID			;SEND TO QUASAR VIA PID
SUBTTL	OUTRTN	Output routine for links

;THIS IS THE TEXT DEFAULT OUTPUT ROUTINE AND WILL SETUP DATA FOR THE
;LINKS

OUTRTN:	SOSG	WTOCNT			;ROOM LEFT
	JRST	OUTR.1			;NO..SEND AND MAKE ROOM
	IDPB	S1,WTOPTR		;SAVE THE BYTE
	$RETT				;RETURN TRUE
OUTR.1:	PUSH	P,S1			;SAVE THE BYTE
	$CALL	SNDOUT			;SEND THE OUTPUT
	$CALL	SETPTR			;RESET THE POINTERS
	MOVEM	S1,WTOPTR		;SAVE THE POINTER
	POP	P,S1			;RESTORE THE VALUE
	JRST	OUTRTN			;SAVE THE CHARACTER NOW
SUBTTL	SETPTR	Setup pointers for output

;THIS ROUTINE WILL SETUP THE POINTERS AND RETURN WITH S1 CONTAINING
;THE NEW BYTE POINTER

SETPTR:	$CALL	GETPAG			;GET A PAGE
	MOVX	S1,.OMDSP		;GET MESSAGE TYPE
	STORE	S1,.MSTYP(MO),MS.TYP	;SAVE THE MESSAGE TYPE
	MOVEI	S1,<PAGSIZ-<.OHDRS+ARG.DA+1>>*5 ;GET ROOM FOR DATA
	MOVEM	S1,WTOCNT		;SAVE THE COUNT
	MOVE	S1,G$OPRA		;GET OPR ADDRESS
	MOVE	S1,OPR.ND(S1)		;GET THE PORT LINE DATA
	MOVE	S1,NOD.NM(S1)		;GET THE NODE NAME
	MOVEM	S1,.MSCOD(MO)		;SAVE THE CODE IN THE MESSAGE
	MOVSI	S1,(POINT 7,)		;SETUP THE BYTE POINTER
	HRRI	S1,.OHDRS+ARG.DA(MO)	;GET BUFFER ADDRESS
	$RET				;RETURN S1 BYTE POINTER

SHWDAY:: $CALL	SETOUT			;SETUP THE OUTPUT
	$TEXT	(,<^H/[-1]/>)
	$CALL	SNDOUT			;SEND THE OUTPUT
	PJRST	P$NPRO##		;NO PROCESSING REQUIRED

>;END FTDN60
	$STOP(DBC,DeBug Crash - Keep this crash)
	END	ORION
