;[SRI-NIC]SRC:<5-GALAXY>IMGSPL.MAC.39, 30-Mar-90 18:14:20, Edit by ZZZ
; kludge to compensate for quasar's not setting fp.spl in spooled files'
; file block -- look for '}' in front of last-writer string. (see LPD.MAC)
; now spooled files get deleted like they should.
;[SRI-NIC]SRC:<5-GALAXY>IMGSPL.MAC.31, 24-Mar-88 15:29:17, Edit by MKL
; decide if impress iff extension is IMP
;[SRI-NIC]SRC:<5-GALAXY>IMGSPL.MAC.27, 24-Mar-88 14:32:42, Edit by MKL
; assume all 8 bit files need quoting.  set lfiscrlf for diablo
; mode for unix losers
;[SRI-NIC]SRC:<5-GALAXY>IMGSPL.MAC.2, 22-Mar-88 00:07:07, Edit by MKL
; Rename to be IMGSPL.  Dump C subroutines that do serial packet
; protocol, and use normal un-error corrected serial line protocol.
; STILL USES LSRGLX ROUTINE

;XS:<5-GALAXY>LSRSPL.MAC.49, 18-Feb-87 10:01:56, Edit by KNIGHT
;  Flush call to CHKFMT
;XS:<5-GALAXY>LSRSPL.MAC.48, 22-Jan-87 11:13:49, Edit by KNIGHT
; Check for CR's before LF's, supply them if not there
;XS:<5-GALAXY>LSRSPL.MAC.47, 21-Jan-87 16:51:27, Edit by KNIGHT
; Where practical, use .EQOWN instead of .EQOID
;[SRI-NIC]XS:<5-GALAXY>LSRSPL.MAC.39,  4-Nov-86 20:05:50, Edit by MKL
; Do /LANDSCAPE and /BOOK
;[SRI-NIC]XS:<5-GALAXY>LSRSPL.MAC.39,  4-Nov-86 20:04:13, Edit by MKL
; Add call to setup TTY stuff
;[SRI-NIC]SRC:<5-GALAXY>LSRSPL.MAC.31, 23-Oct-86 15:47:03, Edit by MKL
; set HDRSEN at CHKHD1+n if found @DOCUMENT in file
;SRC:<5-GALAXY>LSRSPL.MAC.29, 23-Oct-86 15:28:29, Edit by KNIGHT
; Fix bogus ASCIZ in CHKHDR
;SRC:<5-GALAXY>LSRSPL.MAC.28, 23-Oct-86 15:08:01, Edit by KNIGHT
; Reinstate check of HDRSEN in FIXHDR
;SRC:<5-GALAXY>LSRSPL.MAC.19, 20-Jun-86 13:00:21, Edit by KNIGHT
;SIN to SIN%
;SRC:<5-GALAXY>LSRSPL.MAC.18, 20-Jun-86 12:59:56, Edit by KNIGHT
;GETDEV to .GTDEV
;XS:<DEC-5-1.GALAXY-SOURCES>LSRSPL.MAC.17, 20-Jun-86 12:35:06, Edit by KNIGHT
;Make this hack accept 8 bit ASCII

	TITLE IMGSPL - TOPS20 GALAXY/IS INTERFACE
	SUBTTL DEFINITIONS

; BILLY BROWN
; UNIVERSITY OF TEXAS AT AUSTIN
; JUNE, 1983


	SEARCH MACSYM
	SEARCH MONSYM
	SEARCH QSRMAC
	SEARCH ORNMAC
	SEARCH GLXMAC
	SEARCH ACTSYM
	SEARCH LSRMAC
	.TEXT '/RUNAME:IMGSPL'
	.REQUIRE LSRGLX.REL
	SALL


; INTERNALS

	INTERN ONLINE, OFFLIN
	INTERN DOJOB, DOACT, .GTDEV, RELDEV
	INTERN PCNTX

;EXTERNALS

	EXTERN .SPOL.
	EXTERN JOBINF, SNOOZE, CHKMSG
	EXTERN CHKPNT, DEVSTS, SPLSTS
	EXTERN TEXT., .WTO., .ACK.
	EXTERN .WTOJ., .LOG.


;IMAGEN CONTROL CHARS
%EOF=.CHCND			;EOF CHAR
%QUO=.CHCNB			;QUOTING CHAR

%LSR==2				;VERSION NUMBER
TTYNO==41			;TERMINAL NUMBER TO USE
TTYSPD==^d9600			;SPEED TO SET TTY TO
ACCTSW==0			;0= NO ACCOUNTING, -1= ACCOUNTING

F%ASC==1B35			;FILE IS ASCII FORMAT
F%IMP==1B34			;FILE IS IMPRESS FORMAT
IFN NICSW,<
F%8ASC==1B33			;FILE IS 8 BIT ASCII FORMAT
>;IFN NICSW

	SUBTTL STORAGE

FSAVE:	BLOCK 1			;SAVED GALAXY INTERFACE FLAGS
FILPTR:	BLOCK 1			;POINTER TO CURRENT FILE BLOCK
PAGCNT:	BLOCK 1			;COUNT OF PAGES
NCOPY:	BLOCK 1			;NUMBER OF COPIES FOR CURRENT FILE
NFILES:	BLOCK 1			;COUNT OF FILES TO PRINT
FILCNT:	BLOCK 1			;FILES PRINTED SO FAR

INNAM:	BLOCK 40
INJFN:	BLOCK 1			;INPUT JFN
OUTJFN:	BLOCK 1			;OUTPUT JFN

SPOOLP:	BLOCK 1			;FILE-WAS-SPOOLED FLAG
FILWRT:	BLOCK 20		;BUFFER FOR FILE'S LAST-WRITER STRING

CURLIN:	BLOCK 1			;CURRENT LINE FOR PAGE COUNTING
PCNTX:	BLOCK 1			;PAGE COUNT FOR ASCII FILES
LINES:	BLOCK 1			;LINES PER PAGE

ARGBLK:	BLOCK 5			;CHKAC ARGUMENT BLOCK
DEVNAM:	BLOCK 5			;DEVICE NAME BUFFER

BUFFER:	BLOCK 5			;BUFFER FOR ANYTHING (ACCOUTING)
JOBPRI:	BLOCK 1			;CURRENT JOBS PRIORITY (ACCOUNTING)
RUNTIM:	BLOCK 1			;SPOOLER RUNIME (ACCOUNTING)
TIMNOW:	BLOCK 1			;TIME REQUESTED STARTED (ACCOUNTING)
HDRSEN:	BLOCK 1			;SAY HEADER WAS SEEN

PDLEN==40
PDList:	-PDLen,,.
	Block PDLen

INSIZ==^D10000			;10K CHARS (8 BIT)
INBUF:	BLOCK <INSIZ/4>+10
OUTBUF:	BLOCK INSIZ		;at least inbuf*3 (for quoted chars)


START:	RESET%
	MOVE P,PDLIST

	CALL GLXINI

	JRST DONE

	SUBTTL GET DEVICES ON STARTUP

.GTDEV:	MOVEI A,.TTDES		;GET TTY DESIGNATOR
	IORI A,TTYNO		;FILL IN TERMINAL NUMBER
	ASND			;ASSIGN THE DEVICE
	 RET			;CAN'T RETURN ERROR CODE
	AOS (P)			;GIVE SKIP RETURN
	SETZM DEVNAM		;ZERO THE BUFFER
	MOVE B,A		;GET THE DESIGNATOR
	HRROI A,DEVNAM		;POINT TO THE BUFFER
	DEVST			;WRITE THE NAME
	 RET
	MOVEI B,":"
	IDPB B,A
	SETZ B,			;ASCIZ IT
	IDPB B,A
	MOVX A,GJ%SHT
	HRROI B,DEVNAM
	GTJFN%
	 ERJMP LOSE
	MOVEM A,OUTJFN
	MOVE B,[FLD(^D8,OF%BSZ)!OF%WR]
	OPENF%
	 ERJMP LOSE
	CALL TTYSET		;SETUP TTY STUFF
	RET			;DONE

TTYSET:	MOVEI A,.TTDES		;GET TTY DESIGNATOR
	IORI A,TTYNO		;FILL IN TERMINAL NUMBER
	RFMOD%			; get current mode for this line
	 Erjmp	.+1
	Txz B,TT%LEN!TT%WID!TT%ECO!TT%DAM
	Txo B,TT%PGM
	SFMOD%
	 Erjmp	.+1
	STPAR%
	 Erjmp	.+1
	Movei B,.MOSPD
	Move C,[TTYSPD,,TTYSPD]
	MTOPR%
	Movei B,.MOSTF
	Movx C,MO%NUM!MO%NTM
	MTOPR%			;refuse user messages
	Movei B,.MOSNT
	Movei C,.MOSMN
	MTOPR%			;refuse system messages
	Ret

	SUBTTL RELEASE DEVICES ON STUTDOWN

RELDEV:	MOVE A,OUTJFN
	CLOSF%
	 ERJMP .+1
	MOVEI A,.TTDES		;GET TTY DESIGNAOTR
	IORI A,TTYNO
	RELD%			;RELEASE IT
	 WTO (<Can't release printer line>,<%E1: Shutting down anyway>)
	RET			;ALL DONE

	SUBTTL PROCESS A JOB

DOJOB:	MOVEI A,.FHSLF		;GET OUR RUN TIME
	RUNTM%			;"RUNTM" IS DEFINED IN IS, USE "RUNTM%"
	MOVNM A,RUNTIM		;SAVE FOR LATER
	GTAD			;GET CURRENT DATE AND TIME
	MOVEM A,TIMNOW		;SAVE FOR LATER
	SETZM PAGCNT		;NO PAGES PRINTED YET
	SETZM FILCNT		;NO FILES PRINTED YET
	HRRZ A,JOBINF+.EQSPC	;GET NUMBER OF FILES IN REQUEST
	MOVEM A,NFILES		;SAVE IT
	HRRZ A,JOBINF+.EQLEN	;GET LENGTH OF THE EQ HEADER
	ADDI A,JOBINF		;GET ADDRESS OF FIRST FILE
	MOVEM A,FILPTR		;SAVE IT
	LDB B,[POINT 9,.FPINF(A),35]	;GET THE COPY COUNT
	MOVEM B,NCOPY		;SAVE IT
IFE NICSW,<	
	MOVE A,JOBINF+.EQOID	;GET THE USER NUMBER
>;IFE NICSW
IFN NICSW,<
	MOVEI A,JOBINF+.EQOWN	;USE EXTERNAL OWNER
>;IFN NICSW
	MOVE B,JOBINF+.EQJBB	;GET THE JOB NAME
	MOVE C,JOBINF+.EQRID	;GET THE REQUEST ID
IFE NICSW,<
	WTOJ (<Begin>,<job %62, Req #%N3 for %U1>)
>;IFE NICSW
IFN NICSW,<
	WTOJ (<Begin>,<job %62, Req #%N3 for %S1>)
>;IFN NICSW

DOJOB1:	AOS FILCNT		;BUMP THE FILE COUNT
	CALL DOFILE		;PRINT THIS FILE
	MOVE A,FILCNT		;GET THE NUMBER OF FILES PRINTED
	CAML A,NFILES		;DONE THEM ALL?
	 JRST DOJOB2		;YES, QUIT
	MOVE A,FILPTR		;GET POINTER TO LAST FILE
	HLRZ B,.FPLEN(A)	;GET THE LENGTH OF THE FP
	ADD A,B			;MOVE TO THE FD
	HLRZ B,.FDLEN(A)	;GET LENGTH OF THE FD
	ADD A,B			;MOVE TO NEXT FILE
	MOVEM A,FILPTR
	JRST DOJOB1		;LOOP BACK

DOJOB2:	RET			;DONE


	SUBTTL OUTPUT A FILE

DOFILE:	SETZM PCNTX		;RESET THIS
	CALL GETFIL		;GET THE FILE TO BE PRINTED
	 RET			;CAN'T
	CALL CHKACC		;CHECK USER ACCESS TO THIS FILE
	 JRST [	MOVE A,INJFN	;NO ACCESS, GET THE JFN
		LOG (<Can't print file>,<%F1: Read access required>)
		RLJFN		;RELEASE THE JFN
		 JFCL
		RET ]		;DONE

	MOVE A,INJFN		;GET THE JFN
	MOVE B,[FLD(8,OF%BSZ)!OF%RD]
	TXNE F,F%ASC		;ASCII FILE
	 MOVE B,[FLD(7,OF%BSZ)!OF%RD]
	OPENF%			;OPEN IT
	 JRST [	MOVE B,INJFN	;CAN'T GET THE JFN
		LOG (<Can't print file>,<%F2: %E1>)
		RLJFN%		;RELEASE THE FILE
		 JFCL
		RET ]		;DONE
IFE NICSW,<
	CALL CHKFMT		;CHECK THE FORMAT OF THE FILE
	 JRST [	MOVE A,INJFN	;WRONG FORMAT, GET THE JFN
		LOG (<Can't print file>,<%F1: Bad file format>)
		CLOSF		;RELEASE IT
		 JFCL
		RET ]		;DONE
>;IFE NICSW
	CALL ISPOOL		;FLAG WHETHER IT'S A SPOOLED FILE
	CALL DOHDR		;DO THE FILE HEADER
	MOVEM F,FSAVE		;SAVE GALAXY INTERFACE FLAGS
	CALL MAINX		;PRINT THE FILE
	MOVE F,FSAVE

	CALL CLSINF		;CLOSE INPUT FILE
	RET			;DONE

ISPOOL:	SETZM SPOOLP		;DEFAULT TO NOT-SPOOLED
	HRR A,INJFN		;A/ INPUT JFN
	HRLI A,.GFLWR		;A/ .GFLWR,,JFN (GET LAST-WRITER)
	HRROI B,FILWRT		;B/ BP TO BUFFER
	GFUST%			;GET THE STRING
	MOVE A,[440700,,FILWRT]	;A/ PROPER BP TO LAST-WRITER STRING
	ILDB B,A		;B/ FIRST CHAR OF LAST-WRITER STRING
	CAIN B,175		;IF IT'S A CLOSE-BRACE (**KLUDGE**)
	  SETOM SPOOLP		;  THEN IT'S A SPOOLED FILE
	RET			;DONE

	SUBTTL CHECK USER ACCESS TO THE PRINT FILE

CHKACC:	MOVE A,INJFN		;SET THE JFN
	TXO A,CK%JFN		;SAY IT IS A JFN
	MOVEM A,ARGBLK+.CKAUD
	MOVE A,JOBINF+.EQSEQ	;GET EXTERNAL VALUES
	TXNE A,QE.PRV		;USER ENABLED?
	 JRST CHKAC1		;YES
	SETZM A,ARGBLK+.CKAEC	;NO
	MOVE A,JOBINF+.EQOID	;SET THE USER NUMBER
	MOVEM A,ARGBLK+.CKALD
	HRROI A,JOBINF+.EQCON	;SET DIRECTORY POINTER
	MOVEM A,ARGBLK+.CKACD
	MOVX A,.CKARD		;WANT READ ACCESS
	MOVEM A,ARGBLK+.CKAAC
	MOVEI A,5		;LENGTH OF ARGUMENT BLOCK
	MOVEI B,ARGBLK		;ADDRESS OF ARGUMENT BLOCK
	CHKAC
	 JRST CHKAC1		;FAILED, ASSUME OK
	SKIPE A			;ACCESS ALLOWED?
CHKAC1:	 AOS (P)		;YES, SKIP RETURN
	RET			;DONE


	SUBTTL CHECK THE FORMAT OF THE FILE

CHKFMT:	MOVE A,INJFN		;GET JFN OF INPUT FILE
	MOVE B,[1,,.FBBYV]	;WANT FILE I/O INFO
	MOVEI C,E		;SAVE IN REGISTER 5
	GTFDB%			;GET FDB INFO
	 ERJMP CHKFM2		;ERROR -- RETURN
	LDB B,[POINT 5,E,11]	;WANT FILE BYTE SIZE
	CAIN B,^D8		;IS BYTE SIZE IS 8
	 TXNN F,F%ASC		;AND ASCII
	  CAIA
	   JRST CHKFM2		;THEN WE SHOULD ERROR
	SETZM HDRSEN		;NO HEADER YET
	TXNN F,F%IMP		;IMPRESS FILE?
	 JRST CHKHDR		;NO, CHECK FOR A HEADER
	MOVE A,INJFN		;GET THE JFN
	BIN			;READ THE FIRST BYTE
	CAIN B,"@"		;IS IT MARKER CHARACTER?
	 JRST [ BKJFN%		;BACKUP OVER IT
		 JFCL		;IGNORE ERRORS
		SETOM HDRSEN	;REMEMBER HEADER SEEN
		JRST FMTOK]	;AND RETURN OK
	CAIL B,"0"		;MUST BE A DIGIT
	CAILE B,"9"
	SKIPA			;NOT A DIGIT
FMTOK:	 AOS (P)		;IS ONE, SKIP RETURN
CHKFM2:	RET


CHKHDR:	MOVE A,INJFN		;LOOK FOR A JOB HEADER
	RFPTR			;GET THE POINTER
	 RET			;OOPS
	PUSH P,B		;SAVE IT
	BIN			;GET THE FIRST BYTE
	CAIE B,"@"		;DOES IT START OUT RIGHT?
	 JRST CHKHD2		;NO, USE DEFAULT VALUES
	HRROI B,BUFFER		;POINT TO THE BUFFER
	MOVNI C,8		;GET EIGHT CHARACTERS
	SIN%
	SETZ C,			;ASCIZ IT
	IDPB C,B
	HRROI A,BUFFER		;CHECK FOR A VALID HEADER
	HRROI B,[ASCIZ /DOCUMENT/]
	STCMP			;COMPARE
	JUMPN A,CHKHD2		;NOT A HEADER
	MOVE A,INJFN		;GET THE FILE AGAIN
CHKHD1:	BIN			;GET THE NEXT CHARACTER
	 ERJMP CHKHD2		;NOT A VALID HEADER
	CAIE B,")"		;END OF THE HEADER?
	 JRST CHKHD1		;YES
;	ADJSP P,-1		;BALANCE THE STACK
	setom hdrsen		;saw a valid header
;	JRST CHKHDR		;LOOK FOR ANOTHER ONE

CHKHD2:	MOVE A,INJFN		;GET THE JFN
	POP P,B			;GET THE POINTER
	SFPTR			;SET IT
	 JFCL
	AOS (P)			;ASCII FILES ARE ALWAYS OK
	RET			;DONE

	SUBTTL PRE-PROCESS THE FILE

DOHDR:
;	SKIPE HDRSEN		;HEADER ALREADY PERSENT
;	 JRST FIXHD1		;THEN SKIP MOST OF THIS
	GTAD%			;GET TIME AND DATE
	TEXT (HDRTXT,<@DOCUMENT(Spooldate "%D1 %T1",>)
IFE NICSW,<
	MOVE A,JOBINF+.EQOID	;GET THE USER NUMBER
>;IFE NICSW
IFN NICSW,<
	MOVEI A,JOBINF+.EQOWN	;GET POINTER TO THE USER STRING
>;IFN NICSW
	MOVE B,INJFN		;GET THE FILE NAME
	MOVE C,FILPTR		;POINT TO THE FP
IFE NICSW,<
	TEXT (HDRTXT,<Name "%F2",Owner "%U1",>)
>;IFE NICSW
IFN NICSW,<
	TEXT (HDRTXT,<Name "%F2",Owner "%S1",>)
>;IFN NICSW
	TEXT (HDRTXT,< Language >)
	
;lfiscrlf on is for unix losers who send us files with lpr
	HRROI A,[ASCIZ /Diablo, hmi 11, htabs on, lfiscrlf on, at (0.75 0.25 cc), bottommargin 480/]	;default to Diablo
	MOVE B,.FPINF(C)	;GET FLAGS
	TXNE B,FP.2PG		;IF 2 PAGE THEN DO BOOK
	 HRROI A,[ASCIZ /Printer, formsperpage 2, formwidth 80/]	
	HLRZ B,.FPFR1(C)	;GET FORMWIDTH
	CAIN B,^d132		;IF 132 THEN DO LANDSCAPE
	 HRROI A,[ASCIZ /Printer, formwidth 132/]	
	TXNE F,F%IMP		;IS IT IMPRESS?
	 HRROI A,[ASCIZ /Impress/]

	TEXT (HDRTXT,<%S1>)
	MOVE B,NCOPY		;GET COPY COUNT
	CAILE B,1		;WANT MORE THAN ONE?
	  JRST [TEXT (HDRTXT,<, Copies %N2>)
		MOVE A,.FPINF(C)
		TXNE A,FP.COL	;WANT PAGE COLLATION?
		 TEXT (HDRTXT,<,Pagecollation Yes>)
		JRST .+1 ]

	MOVE A,JOBINF+.EQLIM	;GET THE FORMS TYPE
	CAME A,[SIXBIT/NORMAL/]	;IS IT THE DEFAULT?
	 TEXT (HDRTXT,<, Paper %61>)	;NO, OUTPUT IT

	MOVE A,.FPINF(C)	;GET THE FILE INFO BITS
	TXNE A,FP.REV		;WANT PAGE REVERSAL
	 TEXT (HDRTXT,<, Pagereversal Yes>)
	TXNN A,FP.REV		;WANT PAGE REVERSAL
	 TEXT (HDRTXT,<, Pagereversal No>)
	MOVE A,FILCNT		;SEE WHICH FILE THIS IS
	CAMN A,NFILES		;LAST ONE?
	 TEXT (HDRTXT,<, Jobheader Yes>)

	SETZM CURLIN		;RESET THE LINE COUNTER
	TXNE F,F%IMP		;THIS AN IMPRESS FILE?
	  JRST [TEXT (HDRTXT,<)>)
		 JRST FIXHD1]	;NO, END HEADER AND SKIP THIS

	MOVE A,FILPTR		;POINT TO THE FP
	HRRZ B,.FPFR1(A)	;GET THE LINES PER PAGE
	SKIPN B			;DEFAULT?
	 MOVEI B,^D60		;NOT THERE, MUST BE
	MOVEM B,LINES		;SAVE THIS
	CAIE B,^D60		;USING THE DEFAULT?
	 TEXT (HDRTXT,<, Formlength %N2>)
	HLRZ B,.FPFR1(A)	;GET FORMWIDTH
	SKIPE B			;DEFAULT?
	 TEXT (HDRTXT,<, Formwidth %N2>)
	HLRZ B,.FPFR2(A)	;GET TOP MARGIN
	SKIPE B			;DEFAULT?
	 JRST [	TEXT (HDRTXT,<, Topmargin %N2>)
		CAML B,LINES	;VALID NUMBER?
		 JRST .+1	;NO
		MOVNS B		;NEGATE IT
		ADDM B,LINES
		JRST .+1 ]
	HRRZ B,.FPFR2(A)	;GET LEFT MARGIN
	SKIPE B			;DEFAULT?
	 TEXT (HDRTXT,<, Leftmargin %N2>)
	MOVE B,.FPINF(A)	;GET THE FLAGS
	TXNE B,FP.2PG		;WANT TWO FORMS?
	 TEXT (HDRTXT,<, Formsperpage 2>)
	TEXT (HDRTXT,<)>)	;END THE HEADER
;;;	JRST FIXHD1		;SKIP NEXT PART

FIXHD1:	RET


;CLOSE INPUT FILE

CLSINF:	MOVE B,FILPTR		;GET THE FILE POINTER
	MOVE B,.FPINF(B)	;GET FILE INFO BITS
	MOVE A,INJFN		;CLOSE THE FILES
;;	TXNE B,FP.SPL		;IF A SPOOLED FILE
	SKIPE SPOOLP		;IF A SPOOLED FILE
	 TXO A,CO%NRJ		;DON'T RETURN JFN
	CLOSF%
	 JFCL
;;	TXNE B,FP.SPL		;WAS IT A SPOOLED FILE?
	SKIPE SPOOLP		;WAS IT A SPOOLED FILE?
	 JRST [ MOVE A,INJFN	;GET THE FILE JFN
		TXO A,DF%EXP	;EXPUNGE THE FILE
		DELF%		;DELETE IT
		 JFCL		;IGNORE
		JRST .+1]
	TXNN F,F%IMP		;IS IT AN IMP FILE?
	 AOS PCNTX		;NO, CHARGE FOR PARTIAL PAGE
	RET			;SKIP RETURN


HDRTXT:	MOVE B,A		;GET THE BYTE
	MOVE A,OUTJFN		;GET THE OUTPUT FILE
	BOUT%			;OUTPUT IT
	 ERJMP .+1		;LET IT BARF LATER
	RET			;DONE

	SUBTTL GETFIL - GET THE INPUT FILE

GETFIL:	MOVE D,FILPTR		;POINT TO THE FILE PARAMETER BLOCK
	HLRZ B,.FPLEN(D)	;GET LENGTH OF THE FP
	ADD B,D			;MOVE TO THE FD
	AOS B			;MOVE TO THE FILE NAME
	MOVE C,B		;SAVE IT IN CASE OF ERROR
	HRROS B			;MAKE IT A POINTER
	MOVX A,GJ%SHT!GJ%OLD	;GET A JFN ON IT
	GTJFN%
	 JRST [	LOG (<Can't print file>,<%S3: %E1>)
		RET ]		;THAT WAS EASY
	MOVEM A,INJFN		;SAVE THE JFN

	TXZ F,F%IMP!F%ASC!F%8ASC	;RESET THESE

	Move 1,injfn
	MOVE B,[1,,.FBBYV]	;WANT FILE I/O INFO
	MOVEI C,E		;SAVE IN REGISTER 5
	GTFDB%			;GET FDB INFO
	 ERJMP CHKFM2		;ERROR -- RETURN
	LDB B,[POINT 6,E,11]	;WANT FILE BYTE SIZE
	cain b,^d36
	 movei b,7		;if 36 assume it was really 7
	cain b,7		;7 bit???
	 jrst [txo f,F%ASC	;then it MUST be ascii
	       jrst getfi1]
	
	Setzm innam
	Hrroi 1,innam
	Move 2,injfn
	Move 3,[FLD(.JSAOF,JS%TYP)]
	JFNS%
	 Erjmp .+1
	Move 1,[ASCIZ /IMP/]
	Camn 1,innam
	 Txo F,F%IMP		;set impress format

IFN 0,<
	LDB A,[POINT 6,.FPINF(D),5]
	CAIN A,.FPFAS		;ASCII FORMAT?
	 TXO F,F%ASC
	CAIN A,.FPFIM		;BINARY?
	 TXO F,F%IMP
IFE NICSW,<
	TXNN F,F%IMP!F%ASC
>;IFE NICSW
IFN NICSW,<
	CAIN A,.FPF8B		;8-BIT ASCII?
	 TXO F,F%8ASC		; YES
	TXNN F,F%IMP!F%ASC!F%8ASC
>;IFN NICSW
IFE NICSW,<
	TXNN F,F%IMP!F%ASC
>;IFE NICSW
	 TXO F,F%IMP		;DEFAULT TO IMPRESS
>;IFN 0
getfi1:
REPEAT 0,<
	tmsg <[IMGSPL] Printing file >
	Movei 1,.PRIOU
	Move 2,injfn
	Setz 3,
	JFNS%
	 erjmp .+1
	Tmsg <: >
	Hrroi 1,[Asciz /dunno/]
	Txne f,f%asc
	 Hrroi 1,[Asciz /ascii/]
	Txne f,f%imp
	 Hrroi 1,[Asciz /impress/]
	PSOUT%
	Tmsg <.
>
>;REPEAT 0
	AOS (P)
	RET			;DONE


;SEND FILE TO PRINTER.  IF IMPRESS MUST USE QUOTING SCHEME.
MAINX:	TXNE F,F%IMP		;IF IMPRESS,
	 JRST MAINQ		;  THEN MUST DO QUOTING

SndFi1:	Move 1,InJFN
	Move 2,[POINT 8,INBUF]
	Movni 3,INSIZ
	SIN%
	 Erjmp .+1
	Move 5,3
	Move 1,OUTJFN
	Move 2,[POINT 8,INBUF]
	Movni 3,INSIZ
	Sub 3,5
	SOUT%
	Jumpe 5,SndFi1

	JRST MAINZ		;FINISH OFF

;SEND IMPRESS FILE
MAINQ:	Move 1,InJfn
	Move 2,[Point 8,INBUF]
	Movni 3,INSIZ
	SIN%
	 Erjmp .+1
	Move 5,3
	Move 1,[Point 8,OUTBUF]
	Move 2,[Point 8,INBUF]
	Movni 4,INSIZ
	Sub 4,5			;input count
	Setz 6,			;count chars out
MAINQ1:	Ildb 3,2
	Caie 3,%EOF
	 Cain 3,%QUO
	  Jrst MAINQ5		;have to quote it
	Idpb 3,1
	Addi 6,1
MAINQ8:	Aojl 4,MAINQ1

MAINQ9:	Move 1,OUTJFN
	Move 2,[Point 8,OUTBUF]
	Movn 3,6
	SOUT%
	 Erjmp .+1
	Jumpe 5,MAINQ
	Jrst MAINZ		;done
	
MAINQ5:	Movei 3,%QUO		;start quoting
	Idpb 3,1

	Ldb 3,2			;char to quote
	Lsh 3,-4		;get high nibble
	Adjbp 3,[POINT 7,[ASCIZ /0123456789ABCDEF/]]	;to hex
	Ildb 3,3
	Idpb 3,1

	Ldb 3,2			;char to quote
	Trz 3,777760		;get low nibble
	Adjbp 3,[POINT 7,[ASCIZ /0123456789ABCDEF/]]	;to hex
	Ildb 3,3
	Idpb 3,1

	Addi 6,3
	Jrst MAINQ8

MAINZ:	MOVE A,OUTJFN
	MOVEI B,%EOF
	BOUT%
	RET

	SUBTTL ROUTINES CALLED BY IS

ONLINE:	MOVE F,FSAVE		;GET GALAXY FLAGS
	TXZN F,F%OFF		;WAS IT OFF LINE?
	 RET			;NO
	CALL DEVSTS		;UPDATE THE STATUS
	MOVEM F,FSAVE		;SAVE FLAGS AGAIN
	RET



OFFLIN:	MOVE F,FSAVE		;SAME AS ABOVE
	TXOE F,F%OFF
	 RET
	CALL DEVSTS
	WTO <Offline>
	MOVEM F,FSAVE
	RET


GLXINI:	JRST .SPOL.		;SWITCH ENTRY TO SPOOL MODULE


	SUBTTL ACCOUNTING

DOACT:
IFE NICSW,<	
	MOVE A,JOBINF+.EQOID	;GET THE USER NUMBER
>;IFE NICSW
IFN NICSW,<
	MOVEI A,JOBINF+.EQOWN	;USE EXTERNAL OWNER
>;IFN NICSW
	MOVE B,JOBINF+.EQJBB	;GET THE JOB NAME
	MOVE C,JOBINF+.EQRID	;GET THE REQUEST ID
	AOS D,PAGCNT		;GET THE PAGE COUNT
IFE NICSW,<
	WTOJ (<End>,<job %62, Req #%N3 for %U1 (%N4 pages)>)
>;IFE NICSW
IFN NICSW,<
	WTOJ (<End>,<job %62, Req #%N3 for %S1 (%N4 pages)>)
>;IFN NICSW

	MOVX A,.FHSLF		;THIS FORK
	RUNTM%			;GET OUR RUNTIME
	ADDM A,RUNTIM		;GET TIME USED
	MOVX A,.USENT		;WRITE AN ENTRY
	MOVEI B,ACTLST		;POINT TO THE LIST
IFN ACCTSW,<
	USAGE			;DO IT
	 ERJMP ACTERR		;RATS
>;IFN ACCTSW
	RET			;DONE

ACTERR:	SETO A,			;TELL ORION WHAT WENT WRONG
	WTO (<Accounting Error>,<USAGE%% failed: %E1>)
	RET			;DONE

ACTLST:	USENT.	(.UTOUT,1,1,0)
	USTAD.	(-1)			;CURRENT DATE/TIME
	USPNM.	(<SIXBIT/LSRSPL/>,US%IMM) ;PROGRAM NAME
	USPVR.	(%LSR,US%IMM)		;PROGRAM VERSION
	USAMV.	(-1)			;ACCOUNTING MODULE VERSION
	USNOD.	(JOBINF+.EQROB+.ROBND)	;NODE NAME
	USSRT.	(RUNTIM)		;RUN TIME
	USSDR.	(0,US%IMM)		;DISK READS
	USSDW.	(0,US%IMM)		;DISK WRITES
	USJNM.	(JOBINF+.EQJOB)		;JOB NAME
	USQNM.	(<SIXBIT /LSR/>,US%IMM)	;QUEUE NAME
	USSDV.	(DEVNAM)		;DEVICE NAME
	USSSN.	(JOBINF+.EQRID)		;JOB SEQUENCE NUMBER
	USSUN.	(PAGCNT)		;TOTAL PAGES PRINTED
	USSNF.	(NFILES)		;TOTAL FILES PROCESSED
	USCRT.	(JOBINF+.EQAFT)		;CREATION DATE/TIME OF REQUEST
	USSCD.	(TIMNOW)		;SCHEDULED DATE/TIME
	USFRM.	(<SIXBIT /LETTER/>,US%IMM) ;FORMS TYPE
	USDSP.	(<SIXBIT/NORMAL/>,US%IMM)  ;DISPOSITION
	USPRI.	(JOBPRI)		;JOB PRIORITY
	USJNO.	(-1)			;JOB NUMBER
	USTRM.	(-1)			;TERMINAL DESIGNATOR
	USLNO.	(-1)			;TTY LINE NUMBER
	USTXT.	(<-1,,[ASCIZ / /]>)	;SYSTEM TEXT
	USNM2.	(<POINT 7,JOBINF+.EQOWN>) ;USER NAME
	USACT.	(<POINT 7,JOBINF+.EQACT>) ;ACCOUNT STRING POINTER
	0				;END OF LIST



LOSE:	TMSG <?IMGSPL LOST
>
DONE:	HALTF%
	JRST .-1

	END START
