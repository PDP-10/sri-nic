;<EXEC.CMU>EXECCE.MAC.4, 25-Apr-84 13:58:58, Edit by VAF
; CS117	Put an ERJMP after the STIW at CEDITU+x.
;	Do STIW before screwing up terminal modes in case failure occurs.
; EM124	Use RSCAN's instead of STI's in CEEXIT, because of STI bogosity
; EM116	Don't overrun the temp buffer when editing a really long command.
; EM93	Fix more command editing bugs (like, too many yanks no longer
; 	overrun the buffer and crash the exec)
; EM92	Fix a few bugs which caused the exec to crash
; EM83	Make M-^C and M-^G exit from command editor, for those who set
;	'terminal meta-key' when they don't mean to
; EM80	Add a kill buffer and yank command
; EM74	Make the emacs style editing more efficient, and make words be 
;	delimited by all non alpha-numerics.
; EM73	Fix the clear to end of line sequences to match those of the monitor
; EM69	Fix CSAVE so we can't save a command twice.
; EM68	Don't do a case conversion on history printout (use %\ rather than %M)
; EM66	Instal this in CMEXEC. Remove ^D from the available interrupt chars.
;	Record PCL commands, but not the commands executed within. Don't
;	record commands executed inside of take files. Add bogus 'Set History'
;	command so peoples .cmd files don't blow up.
;	Note: many of the terminal sequences may be wrong. We'll have to fix
;	them as we come to them.

;TOPS20 'EXECUTIVE' COMMAND LANGUAGE

; UTEXAS-20 COMMAND EDITOR
; BILLY BROWN
; JULY, 1982
; GO HORNS

	SEARCH EXECDE
	TTITLE EXECCE

;Based on the Yale Exec Command Editor

;THIS FILE CONTAINS
;COMMAND EDITOR, AGAIN COMMAND, COMMAND SAVE ROUTINE


.SHIST::NOISE <of commands with length>
	DECX <number of commands to remember>
	 CMERRX
	ETYPE <%%'Set History' is no longer necessary%_>
	RET

;Routine to save contents of command buffer for later CEDIT command

CSAVE::	PUSH P,A		;SAVE THE REGISTERS
	PUSH P,B
	PUSH P,C
	PUSH P,D
	SKIPE CEBPTR		;THIS ONE NOT TO BE SAVED?
	 JRST CSAVE5		;QUIT NOW

	MOVE A,SBLOCK+.CMIOJ	;EM66 Get primary jfns
	CAME A,[.PRIIN,,.PRIOU]	;EM66 A real, typed command?
	 JRST CSAVE5		;EM66 Nope - don't save it
	SKIPE PCCIPF		;EM66 If not PCL command, save it
	 JRST [	SKIPE PCLMID	;EM66
		 JRST CSAVE5	;EM66 If not the calling command, don't save
		SETOM PCLMID	;EM66 Don't save any more PCL commands
		JRST .+2 ]	;EM66 But do save this one
	SETZM PCLMID		;EM66
	LDB A,[POINT 7,CBUF,6]	;CHECK IT OUT FIRST
	JUMPE A,CSAVE5		;DON'T SAVE EMPTY COMMANDS
	CAIN A,"^"		;EM66
	 JRST CSAVE5		;EM66 Don't save the editing command
	CAIN A,CR		;CR?
	 JRST CSAVE5		;YES, PCL STUFF, DON'T SAVE IT EITHER
	CAIN A,LF		;LF?
	 JRST CSAVE5		;YES, EMPTY COMMAND, DON'T SAVE

	MOVE A,[POINT 7,CBUF]	;POINT TO THE SOURCE
	MOVE B,CEFFL		;GET ADDRESS OF FIRST FREE LOCATION
	CAME B,CE1ST		;ABOUT TO STOMP SOMEONE?
	 JRST CSAVE0		;NO

	HRRZ D,(B)		;GET ADDRESS OF NEXT ONE
	HRRZS (D)		;TIE IT OFF
	MOVEM D,CE1ST		;SAVE NEW ADDRESS
	SOS CECNT		;DECREMENT THE COUNT
CSAVE0:	HLL B,[POINT 7,0]	;POINT TO FIRST FREE SPOT
	AOS B			;LEAVE ROOM FOR THE HEADER

CSAVE1:	ILDB C,A		;GET NEXT BYTE
	CAIN C,CR		;END ON CR
	 SETZ C,
	CAIN C,LF		;END ON LINE FEED
	 SETZ C,

;	Continued on next page

CSAVE2:	IDPB C,B		;STORE THE BYTE
	HRRZ D,B		;GET ADDRESS WE JUST STORED IN
	CAME D,CE1ST		;GOING OVER THE FIRST COMMAND?
	 JRST CSAVE3

	HRRZ D,(D)		;GET ADDRESS OF NEXT ONE
	HRRZS (D)		;TIE IT OFF
	MOVEM D,CE1ST		;SAVE NEW ADDRESS
	SOS CECNT		;DECREMENT THE COUNT
CSAVE3:	HRRZ D,B		;GET ADDRESS AGAIN
	CAIE D,CEBFEN		;PAST THE BUFFER?
	 JRST CSAVE4		;NO
	MOVE B,[POINT 7,CESAVE]	;YES, RESET TO THE TOP
	JRST CSAVE2		;AND TRY AGAIN

CSAVE4:	JUMPN C,CSAVE1		;GET NEXT CHARACTER IF NOT THE END
	HRRZ A,B		;GET ADDRESS OF LAST BYTE
	AOS A			;BECOMES FIRST FREE LOCATION
	CAIL A,CEBFEN		;STILL IN THE BUFFER?
	 MOVEI A,CESAVE		;NO, WRAP AROUND
	EXCH A,CEFFL		;SAVE IT, A POINTS TO THE NEW BLOCK
	HRRM A,@CELAST		;LINK THIS ONE IN
	MOVE B,CELAST		;GET ADDRESS OF LAST ONE
	HRLZM B,(A)		;LINK FROM NEW ONE TO OLD ONE
	MOVEM A,CELAST		;UPDATE LAST COMMAND POINTER
	AOS CECNT		;INCREMENT COUNT

CSAVE5:	SETOM CEBPTR		;EM69 MARK COMMAND AS SAVED
	POP P,D			;RESTORE EVERYTHING
	POP P,C
	POP P,B
	POP P,A
        RET


; HISTORY COMMAND
.HISTO::NOISE <about most recent exec commands>
	MOVEI B,[FLDDB. .CMCFM,CM%SDH,,<Confirm for entire command history>,,
		[FLDDB. .CMNUM,CM%SDH,^D10,<integer "n" for last "n" commands>]]
	CALL	FLDSKP		;CONFIRMATION OR NEW COMMAND
	 CMERRX			;SOME TYPE OF ERROR
	STKVAR <HSTNUM,CELPOS,CELPTR>
	LDB D,[331100,,(C)]	;SEE WHAT WE GOT
	CAIN D,.CMCFM		;CONFIRM?
	 JRST [SETOM HSTNUM	;EFFECTIVELY INFINITY
	       JRST HIST1]	       
	MOVEM B,HSTNUM		;SAVE AMOUNT OF HISTORY
	CONFIRM
HIST1:	SETZM CELPOS		;ENTRY ZERO
	SKIPN C,CELAST		;CURRENT MOST RECENT ENTRY
	 RET			;NOTHING THERE
	MOVEM C,CELPTR
HIST2:	MOVE D,CELPOS		;GET LINE COUNT
	MOVEI B,1(C)		;GET PAST HEADER
	HLL B,[POINT 7]		;MAKE INTO BYTE POINTER
	ETYPE < -%4Q: %2\ %_>	;EM68
	SOSN HSTNUM		;DECREMENT COUNTER
	 RET			;NO MORE WANTED
; GO TO PREVIOUS LINE
	HLRZ C,@CELPTR		;TAKE THE LEFT HAND LINK
	SKIPN C			;CHECK FOR END OF LIST
	 RET
	MOVEM C,CELPTR		;UPDATE POINTER
	AOS CELPOS		;INCREMENT THE LINE NUMBER
	JRST HIST2		;PROCESS THIS LINE


; AGAIN COMMAND

.AGAIN::
	MOVEI B,[FLDDB. .CMCFM,CM%SDH,,<Confirm to redo last command>,,
		[FLDDB. .CMTXT,CM%SDH,,<Command to be executed first>]]
	CALL FLDSKP		;CONFIRMATION OR NEW COMMAND
	 CMERRX			;SOME TYPE OF ERROR
	LDB D,[331100,,(C)]	;SEE WHAT WE GOT
	CAIN D,.CMCFM		;CONFIRM?
	 JRST AGINOK		;YES, SKIP NEW STUFF

	MOVE C,[POINT 7,ATMBUF]	;POINT TO THE NEW COMMAND
	MOVEI A,.CTTRM		;AND TO THE TERMINAL
OAGAIN:	ILDB B,C		;GET NEXT CHAR
	JUMPE B,OAGIN1		;CHECK FOR END
	CAIN B,.CHCNN		;^N?
	 MOVEI B,CR		;YES, MULTI LINE STUFF
	STI			;STUFF IT
	JRST OAGAIN		;DO THE REST
OAGIN1:	MOVEI B,CR		;END WITH CR
	STI
AGINOK:	MOVE C,CELAST		;GET ADDRESS OF LAST COMMAND STRING
	HLRZ C,(C)		;EM66 Then previous one
	AOS C			;SKIP PAST THE HEADER
	HLL C,[POINT 7,0]	;MAKE IT A POINTER
	MOVEI A,.CTTRM
AGAIN1:	IBP C			;POINT TO NEXT BYTE
	HRRZ D,C		;CHECK FOR WRAP AROUND
	CAIL D,CEBFEN		;STILL IN THE BUFFER?
	 MOVE C,[POINT 7,CESAVE,6] ;NO, RESET
	LDB B,C			;GET NEXT CHAR
	JUMPE B,AGAIN2		;CHECK FOR END
	STI			;STUFF IT
	JRST AGAIN1		;DO THE REST
AGAIN2:	MOVEI B,CR		;ADD CR TO THE END
	STI

	MOVE A,CELAST		;EM66 Get pointer to redo command
	HLRZ A,(A)		;EM66 Now pointer to previous command
	MOVEM A,CELAST		;EM66 "Forget" the 'redo' from history

	RET			;ALL DONE


;	UTEXAS-20 COMMAND LINE EDITOR

CEDIT::	MOVEI B,[FLDDB. .CMCFM,CM%SDH,,<Confirm to enter command editor>,,
		[FLDDB. .CMNUM,CM%SDH,^D10,<Number of previous command>,,
		[FLDDB. .CMTXT,CM%SDH,,<Prefix of previous command>]]]
	CALL FLDSKP		;CONFIRM OR NEW COMMAND
	 CMERRX			;SOME TYPE OF ERROR
	TRVAR <CADLFG,CEDUMB,CABKFG,CELPOS,CECPOS,CELPTR,CEDSEA,CENUMR,CEKBC> ;EM80 Add CEKBC
	SETZM CEDSEA		;ASSUME NORMAL MODE
	LDB D,[331100,,(C)]	;SEE WHAT WE GOT
	CAIN D,.CMCFM		;CONFIRM?
	 JRST CEDITU		;YES, EDIT LAST COMMAND
	AOS CEDSEA		;NO, ASSUME SEARCH MODE; ATMBUF CONTAINS STRING
	CAIN D,.CMTXT		;TEXT?
	 SETOM CEDSEA		;YES
	SOS B			;EM92 If number, make it right
	MOVEM B,CENUMR		;SAVE IN CASE OF NUMBER
	CONFIRM

CEDITU::
;CS117 Moved from below
	MOVEI A,.FHJOB
	SETZ B,			;NO TERMINAL INTERRUPTS
	STIW
	 ERJMP CJERRE		;CS117 Trap this...
	MOVEI A,.CTTRM		;GET OLD MODE WORD
	RFMOD
	PUSH P,B		;SAVE THIS FOR LATER
	TXZ B,TT%IGN		;MAKE SURE IT SEES TT%WAK BITS
	TXO B,TT%WAK		;WAKE ON EVERYTHING
	TXZ B,TT%ECO		;TURN OFF ECHOING
	TXZ B,TT%PGM		;TURN OFF PAGING (^S, ^Q)
	TXZ B,TT%TAB		;SPACES INSTEAD OF TAB
	SFMOD
	STPAR
	MOVE B,[052525,,553125]	;PASS CR, ^I, FORMAT LF, NO NULLS
	MOVE C,[252525,,652400]	;FORMAT ESCAPE
	SFCOC
;CS117 4 lines moved up
	SETZM CELPOS		;INITIALIZE LINE NUMBER
	MOVE A,CELAST		;GET THE FIRST COMMAND POINTER
	MOVEM A,CELPTR		;INITIALIZE FOR CETOP
	SKIPE CEDSEA		;SEARCH MODE?
	 CALL CESRCH		;YES, SO BEGIN DEFFERENTLY
	SETZM CEDUMB		;ASSUME SMART TERMINAL
	SKIPN CEFLAG		;EMACS MODE?
	 JRST CETOP		;YES, SIMULATE UP CURSOR
	MOVE A,COJFN		;ALTER MODE, GET TERMINAL TYPE
	GTTYP
	SKIPN EEOLTB(B)		;IS IT SMART?
	 SETOM CEDUMB		;NO
	SETZM CADLFG		;INITIALIZE STUFF
	SETZM CABKFG
	JRST CETOP		;SIMULATE INITIAL UP CURSOR


; SEARCH FOR INITIAL STRING - 
;   CELPTR AND A CONTAINS POINTER TO FIRST COMMAND
;   CELPOS AND CELPTR UPDATED ON RETURN
CESRCH:	SKIPL CEDSEA		;SEARCH MODE OR NUMBER MODE
	 JRST CENUMM		;NUMBER MODE
	MOVE C,A		;BASE STRING HEADER
	MOVE B,[POINT 7,1(C)]	;BASE STRING BYTE POINTER
	MOVE A,[POINT 7,ATMBUF]	;POINT TO THE PREFIX STRING
	STCMP
	SKIPN A			;STRING ARE EQUAL?
	 RET			;YES, SO RETURN
	TXNE A,SC%SUB		;SUBSTRING?
	 RET			;YES, SO RETURN
; GO TO PREVIOUS LINE
	HLRZ A,@CELPTR		;TAKE THE LEFT HAND LINK
	SKIPN A			;CHECK FOR END OF LIST
	 JRST CESRCL		;END OF LIST
	AOS CELPOS		;INCREMENT THE LINE NUMBER
	MOVEM A,CELPTR		;UPDATE POINTER
	JRST CESRCH		;PROCESS THIS LINE

CESRCL:	TYPE <%Prefix not found>
CESRCF:	TYPE < - editing last command> ;EM92
	MOVE A,CELAST		;END OF LIST, GO BACK TO THE FIRST LINE
	MOVEM A,CELPTR		;RESET THE POINTER
	SETZM CELPOS		;RESET LINE NUMBER
	RET

; NUMBER MODE
CENUMM:	SKIPGE C,CENUMR		;ONLY ALLOW POSITIVE NUMBERS
	 RET			;RETURN OTHERWISE POINTING AT CURRENT	
CENUMA:	HLRZ A,@CELPTR		;TAKE THE LEFT HAND LINK
	SKIPN A			;CHECK FOR END OF LIST
	 JRST CENUML		;END OF LIST
	AOS CELPOS		;INCREMENT THE LINE NUMBER
	MOVEM A,CELPTR		;UPDATE POINTER
	SOJGE C,CENUMA		;CONTINUE IF MORE TO GO
	RET			;RETURN POINTING TO CURRENT LINE

CENUML:	TYPE <%Requested command line lost>
	JRST CESRCF		;EM92 Really position at first command



CETOP:	TYPE <
>				;CR
	CALL EEOLN		;ERRASE TO END OF LINE
	MOVE A,CELPTR		;POINT TO THE CURRENT LINE
	AOS A			;SKIP PAST THE HEADER
	HLL A,[POINT 7,0]	;MAKE IT A POINTER
	MOVE B,[POINT 7,CETSAV]	;POINT TO THE TEMP BUFFER
CETOP0:	ILDB C,A		;GET NEXT BYTE
	HRRZ D,A		;CHECK FOR WRAP AROUND
	CAIE D,CEBFEN		;TOO FAR?
	 JRST CETOP1		;NO
	MOVE A,[POINT 7,CESAVE]	;YES, RESET THE POINTER
	JRST CETOP0		;AND START OVER

CETOP1:	IDPB C,B		;MOVE IT
	SKIPE C			;END ON NULL BYTE
	 JRST [ HRRZ D,B	;EM116 Check for CETSAV overrun
		CAIGE D,CETSAV+50 ;EM116 Used up CETSAV yet?
		 JRST CETOP0	;EM116 Nope, do another character
		SETO A,		;EM116
		ADJBP A,B	;EM116 Decrement pointer
		SETZ D,		;EM116
		DPB D,A		;EM116 Put a null at the end
		JRST .+1 ]	;EM116

	SETZM CECPOS		;INITIALIZE POSITION
	MOVE A,[POINT 7,CETSAV]	;GET A POINTER TO IT
	MOVEM A,CEBPTR		;SAVE IT
	SKIPN CEDUMB		;WRITE LINE FOR DUMB TERMINALS
	 JRST CETOP2
	CALL CENUMB
	MOVE A,CEBPTR
	PSOUT
	TYPE <
>
CETOP2:	TYPE <    >		;MAKE ROOM FOR THE LINE NUMBER
	MOVE A,CEBPTR
	SKIPN CEDUMB		;EMACS OR SMART ALTER MODE?
	 PSOUT			;YES, WRITE IT OUT
	MOVEI A,CR
	PBOUT			;BACK TO THE BEGINNING
	CALL CENUMB		;WRITE THE NUMBER
	JRST CEINC		;GET COMMAND INPUT CHARACTER




CENUMB: MOVEI A,.CTTRM		;OUTPUT LINE# AS "DD:"
	MOVN B,CELPOS		;GET (NEGATIVE) LINE NUMBER
	JUMPE B,CENUM1		;DO CURRENT LINE DIFFERENT
	MOVE C,[NO%LFL!NO%OOV!NO%AST!FLD(3,NO%COL)!FLD(12,NO%RDX)]
        NOUT
	 JFCL
        ETYPE <:>
	RET			;ALL DONE

CENUM1:	ETYPE < **:>		;FOR CURRENT LINE
	RET



; Get the next input character

CEINC:	SKIPN CEFLAG		;EMACS MODE?
	 JRST ECEINC		;YES, DIFFERENT COMMANDS

	SETZ P3,		;ASSUME NO NUMERIC ARGUMENT
ACEINC:	PBIN			;GET ALTER MODE COMMAND
	CAIL A,"0"		;BIGGER THAN 0?
	 CAILE A,"9"		;SMALLER THAT 9?
	  JRST ACEIN1		;NOT A NUMBER, KEEP LOOKING
	IMULI P3,^D10		;NUMBER, UPDATE THE COUNT
	ADD P3,A		;ADD THIS ONE IN
	SUBI P3,"0"		;CONVERT TO BINARY
	JRST ACEINC		;GET THE REST OF THE COMMAND

ACEIN1:	CAIN A,CR		;^M - EXIT AND DO COMMAND
	 JRST CEEXIT
	CAIE A,"E"		;E - EXIT AND DO COMMAND
	 CAIN A,"e"
	  JRST CEEXIT
	CAIN A,.CHCNU		;^U - START OVER
	 JRST CETOP
	CAIN A,.CHLFD		;FL - NEXT LINE
	 JRST CEDOWN
	CAIN A,.CHESC		;ESC - PREVIOUS LINE
	 JRST CEUP
	CAIN A,.CHCNR		;^R - RETYPE LINE
	 JRST CATYPE
	CAIE A,"L"		;^L - TYPE LINE AND START OVER
	 CAIN A,"l"
	  JRST CARTYP
	CAIE A,"P"		;P - RETYPE LINE
	 CAIN A,"p"
	  JRST CATYPE
	CAIE A,"Q"		;Q - ABORT
	 CAIN A,"q"
	  JRST CEQUIT
	CAIN A,.CHCNC		;^C - ABORT
	 JRST CEQUIT
	CAIE A,"D"		;D - DELETE CHARACTERS
	 CAIN A,"d"
	  JRST CADEL
	CAIE A,"H"		;"H" - DELETE TO END, THEN INSERT
	 CAIN A,"h"
	  JRST CAHACK
	CAIE A,"I"		;"I" - ENTER INSERT MODE
	 CAIN A,"i"
	  JRST CAINST
	CAIE A,"R"		;"R" - DELETE THEN INSERT
	 CAIN A,"r"
	  JRST CADEIN
	CAIE A,"W"		;"W" - MOVE OVER WORDS
	 CAIN A,"w"
	  JRST CAFORW
	CAIE A,"X"		;"X" - EXTEND LINE
	 CAIN A,"x"
	  JRST CAEXTN
	CAIE A,"Z"		;"Z" - DELETE WORDS
	 CAIN A,"z"
	  JRST CADELZ
	CAIN A,":"		;":" - DELETE REST OF LINE
	 JRST CACOLN
	CAIN A,"\"		;"\" - TRANSPOSE PREVIOUS TWO CHARS
	 JRST CETRAN
	CAIN A,.CHDEL		;RUB - MOVE CURSOR LEFT
	 JRST CALEFT
	CAIN A," "		;SPACE - MOVE CURSOR RIGHT
	 JRST CARIGH
	CAIN A,.CHTAB		;TAB - MOVE TO END OF LINE
	 JRST CAEOLN
	CAIN A,"?"		;? - GIVE HELP MESSAGE
	 JRST CAHELP
	CALL CEBELL		;ERROR, RING THE BELL
	JRST CEINC		;TRY AGAIN


;	Here to enter insert mode

CAINST:	CALL CAFLSH		;FLUSH ANYTHING WE HAD GOING
CANST0:	PBIN			;GET NEXT CHARACTER
	CAIN A,.CHESC		;ESCAPE?
	 JRST CEINC		;YES, EXIT
	CAIN A,.CHTAB		;A TAB?
	 JRST CAINOK		;YES, LET IT PASS
	CAIL A," "		;SOME CONTROL CODE?
	 CAIN A,.CHDEL		;OR RUBOUT?
	  SKIPA			;YES, ERROR
	   JRST CAINOK		;ITS OK
	CALL CEBELL		;ERROR, RING BELL
	JRST CANST0		;AND TRY AGAIN

CAINOK:	MOVE C,CEBPTR		;GET THE POINTER
	SKIPE CEDUMB		;DUMP TERMINAL?
	 PBOUT			;YES, DISPLAY THE CHARACTER
CAINS1:	ILDB B,C		;GET ONE THAT WAS THERE
	SKIPN CEDUMB		;SMART TERMINAL?
	 PBOUT			;YES, OUTPUT IT
	DPB A,C			;REPLACE IT
	JUMPE A,CAINS2		;EXIT AFTER A NULL BYTE
	MOVE A,B		;SET UP TO REINSERT THE ONE
	JRST CAINS1
CAINS2:	AOS CECPOS		;UPDATE OUR POSITION
	IBP CEBPTR		;AND OUR POINTER
	SKIPE CEDUMB		;SMART TERMINAL
	 JRST CAINST		;NO, GET SOME MORE
	MOVEI A,CR
	PBOUT			;POSITION THE CURSOR
	CALL CENUMB		;MOVE PAST THE LINE NUMBER
	MOVE A,COJFN		;POINT TO THE TERMINAL
	HRROI B,CETSAV		;POINT TO THE STRING
	MOVN C,CECPOS		;GET COUNT
	SKIPE C			;DON'T GO FOREVER HERE
	 SOUT			;MOVE PAST THE OLD CHARACTERS
	JRST CAINST		;DONE, GET SOME MORE



;	Here to delete n characters

CADEL:	CALL ALTDEL		;DO ALTER MODE DELETE
	JRST CEINC		;DONE



;	Here to delete n characters then insert text

CADEIN:	CALL ALTDEL		;DO ALTER MODE DELETE
	CALL CAFLDE		;SIGNAL END OF DELETE
	JRST CAINST		;SO THE INSERT


;	Alter mode delete routine

ALTDEL:	MOVE A,CEBPTR
	ILDB B,A
	SKIPN B
	 RET
	CALL CAFLBK		;FLUSH BACKSPACE MARKER
	SKIPG P3		;ZERO OR BAD ARGUMENT?
	 MOVEI P3,1		;YES, MAKE IT THE DEFAULT
	SETZ C,			;NEW COUNTER
	SKIPE CEDUMB		;SMART TERMINAL
	 CALL CADELF		;NO, SIGNAL DELETE
	MOVE B,CEBPTR		;GET THE POINTER
ALTDL1:	ILDB A,B		;GET NEXT CHARACTER
	JUMPE A,ALTD1A		;END?
	AOS C			;NO, INCREMENT COUNT
	SKIPE CEDUMB		;SMART TERMINAL?
	 PBOUT			;NO, ECHO CHARACTER
	SOJG P3,ALTDL1
	JRST ALTDL2
ALTD1A:	SETO A,			;WENT TOO FAR, BACKUP POINTER
	ADJBP A,B
	MOVEM A,B
ALTDL2:	SKIPN C
	 RET
	MOVE A,CEBPTR
ALTDL3:	ILDB C,B		;GET FIRST CHARACTER
	IDPB C,A		;SAVE IN NEW POSITION
	JUMPN C,ALTDL3
	SKIPE CEDUMB		;SMART TERMINAL?
	 RET			;NO, DONE
ALTDL4:	MOVE A,CEBPTR		;REWRITE THE SCREEN
	PSOUT
	CALL EEOLN
	MOVEI A,CR
	PBOUT			;POSITION THE CURSOR
	CALL CENUMB		;MOVE PAST THE LINE NUMBER
	MOVE A,COJFN		;POINT TO THE TERMINAL
	HRROI B,CETSAV		;POINT TO THE STRING
	MOVN C,CECPOS		;GET COUNT
	SKIPE C			;DON'T GO FOREVER HERE
	 SOUT			;MOVE PAST THE OLD CHARACTERS
	RET


;	Here to retype the line

CATYPE:	CALL CAFLSH		;FLUSH EVERYTHING
	SKIPN CEDUMB		;SMART TERMINAL?
	 JRST CEDISP		;YES, THIS IS A JOB FOR EMACS
	MOVE A,CEBPTR		;FINISH THE LINE
	PSOUT
	ETYPE <
>				;GO TO NEW LINE
	JRST	CINST1		;WRITE IT OUT



;	Here to finish typing the line and start over

CARTYP:	CALL CAFLSH
	SETZM CECPOS		;RESET CHARACTER PSOITION
	SKIPN CEDUMB		;SMART TERMINAL?
	 JRST CARTP1		;YES
	MOVE A,CEBPTR		;FINISH THE LINE
	PSOUT
CARTP1:	MOVE A,[POINT 7,CETSAV]	;RESET POINTER
	MOVEM A,CEBPTR
	ETYPE <
>				;NEW LINE
	JRST CETOP2		;AND START OVER





;	Here to hack and insert

CAHACK:	CALL CAFLBK
	SKIPN CEDUMB		;SMART TERMINAL?
	JRST CAHAK1		;YES, DO IT THE EASY WAY
	CALL CADELF		;SIGNAL DELETE
	MOVE A,CEBPTR		;GET THE REST OF THE STRING
	PSOUT			;OUTPUT IT
	TYPE <\\>		;END OF DELETE
	SETZM CADLFG
CAHAK1:	SETZ A,			;CHOP OFF THE REST OF THE STRING
	MOVE B,CEBPTR		;GET COPY OF POINTER
	IDPB A,B		;CURSOR IS ONE POSITION PAST POINTER
	CALL EEOLN		;JUST IN CASE
	JRST CAINST		;START INSERTING



;	Here to move over words

CAFORW:	CALL CAFLSH
	SKIPG P3
	 MOVEI P3,1
CAFRW1:	CALL F.WORD		;GET COUNT TO NEXT WORD
	ADDM B,CECPOS		;UPDATE POSITION
	MOVN C,B		;GET NEGATIVE COUNT
	MOVE A,COJFN		;MOVE OVER
	MOVE B,CEBPTR
	SKIPE C
	 SOUT			;WRITE IT OUT
	MOVEM B,CEBPTR
	SOJG P3,CAFRW1
	JRST CEINC		;DONE


;	Here to delete n words

CADELZ:	CALL CAFLBK
	PUSH P,CEBPTR		;SAVE THE POINTER
	SKIPG P3		;ZERO OR NO ARGUMENT?
	 MOVEI P3,1		;YES, MAKE IT THE DEFAULT
	SETZ D,			;KEEP COUNT HERE
CADLZ1:	CALL F.WORD		;GET COUNT TO NEXT WORD
	SUB D,B			;KEEP NEGATIVE COUNT
	ADJBP B,CEBPTR		;UPDATE POINTER
	MOVEM B,CEBPTR
	SOJG P3,CADLZ1
	SKIPE A,CEDUMB		;SMART TERMINAL?
	JRST CADLZ2		;NO.
	MOVE A,CEBPTR		;DESTINATION POINTER
	POP P,CEBPTR		;SOURCE POINTER
	JRST M.FIX		;FIX IT UP
CADLZ2:	CALL CADELF		;SIGNAL DELETE
	MOVE A,COJFN		;WRITE OUT DELETED STUFF
	MOVE B,(P)		;POINT TO DELETED STUFF
	MOVE C,D		;NUMBER OF CHARACTERS
	SKIPE C			;SKIP IF NONE
	 SOUT
	POP P,CEBPTR		;FIX THE POINTER
	MOVE A,CEBPTR
CADLZ3:	ILDB C,B		;GET FIRST CHARACTER
	IDPB C,A		;SAVE IN NEW POSITION
	JUMPN C,CADLZ3
	JRST CEINC		;DONE



;	Here to extend the line

CAEXTN:	CALL CAFLSH
	MOVE A,CEBPTR		;GET THE POINTER
	PSOUT			;WRITE IT OUT
	SETO B,			;BACKUP THE POINTER
	ADJBP B,A
	SETZ A,			;GET COUNT TOO
CAXTN1:	ILDB A,CEBPTR		;GET NEXT CHARACTER
	JUMPE A,CAXTN2
	AOS CECPOS		;UPDATE POSITION
	JRST CAXTN1
CAXTN2:	MOVEM B,CEBPTR		;SAVE NEW POINTER
	JRST CAINST		;GO TO INSERT MODE



;	Here to jump to the end of a line

CAEOLN:	CALL CAFLSH
	MOVE A,CEBPTR		;GET POINTER
	PSOUT			;WRITE IT OUT
	SETO B,			;BACK IT UP
	ADJBP B,A
	SETZ A,			;GET COUNT TOO
CAEOL1:	ILDB A,CEBPTR		;GET NEXT CHARACTER
	JUMPE A,CAEOL2
	AOS CECPOS		;UPDATE POSITION
	JRST CAEOL1
CAEOL2:	MOVEM B,CEBPTR		;SAVE NEW POINTER
	JRST CEINC		;DONE



;	Here to delete the rest of the line

CACOLN:	CALL CAFLBK
	SKIPN CEDUMB		;SMART TERMINAL?
	JRST CACLN1		;YES, SKIP THIS
	CALL CADELF		;SIGNAL DELETE
	MOVE A,CEBPTR		;GET POINTER
	PSOUT			;WRITE THE RESTO OF THE STRING
	TYPE <\\>		;SIGNAL NO MORE DELETE
	SETZM CADLFG
CACLN1:	SETZ A,			;CHOP OFF THE REST OF THE STRING
	MOVE B,CEBPTR		;GET COPY OF POINTER
	IDPB A,B		;CURSOR IS ONE POSITION PAST POINTER
	CALL EEOLN		;JUST IN CASE
	JRST CEINC		;ALL DONE


;	Here to move to right

CARIGH:	CALL CAFLSH
	SKIPG P3		;ARGUMENT OK?
	 MOVEI P3,1		;FIX IT UP
CARIG1:	ILDB A,CEBPTR		;GET NEXT CHARACTER
	JUMPE A,CARIG2		;END OF LINE
	AOS CECPOS		;UPDATE POSITION
	PBOUT			;MOVE OVER
	SOJG P3,CARIG1		;DO THE REST
	JRST CEINC		;DONE

CARIG2:	SETO A,			;WENT TOO FAR
	ADJBP A,CEBPTR		;BACK UP
	MOVEM A,CEBPTR
	JRST CEINC		;DONE




;	Here to move to the left

CALEFT:	CALL CAFLDE
	SKIPN CECPOS		;BEGINNING OF LINE?
	 JRST CEINC		;YES, SKIP
	SKIPN P3		;NO ARGUMENT?
	 MOVEI P3,1		;MAKE IT A 1
	CAML P3,CECPOS		;ARGUMENT TOO BIG?
	 MOVE P3,CECPOS		;YES, TRIM IT DOWN
	SKIPE CEDUMB		;SMART TERMINAL
	 JRST CALFT1		;NO
	MOVN C,P3		;FIX THE POINTER
	ADJBP C,CEBPTR
	MOVEM C,CEBPTR
	MOVN A,P3		;FIX POSITION
	ADDM A,CECPOS
	JRST CINST1		;POSITION CURSOR

CALFT1:	CALL CABAKF		;SIGNAL BACK MOVEMENT
CALFT2:	LDB A,CEBPTR		;GET THIS CHARACTER
	PBOUT			;OUTPUT IT
	SETO B,			;MOVE THE POINTER BACK
	ADJBP B,CEBPTR		;BACK UP THE POINTER
	MOVEM B,CEBPTR
	SOS CECPOS
	SOJG P3,CALFT2		;DO THE REST
	JRST CEINC		;GET NEXT COMMAND


;	ROUTINES TO PRINT \ AND \\ FOR DUMB TERMINAL ALTER MODE


CAFLSH:	CALL CAFLBK		;FLUSH OUT BACKSPACE CHARACTER
	CALL CAFLDE		;FLUSH OUT DELETE CHARACTER
	RET


CAFLBK:	SKIPN CEDUMB
	 RET
	SKIPN CABKFG		;WERE WE BACKSPACING?
	 RET			;NO, NOTHING TO DO
	SETZM CABKFG		;RESET THE FLAG
	TYPE <\>		;SIGNAL END OF BACKSPACE
	RET


CAFLDE:	SKIPN CEDUMB		;DUMB TERMINAL?
	 RET			;YES, RETURN
	SKIPN CADLFG		;WERE WE IN A DELETE?
	 RET			;NO
	SETZM CADLFG		;RESET FLAG
	TYPE <\\>		;SIGNAL END OF DELETE
	RET

CABAKF:	SKIPN CEDUMB
	 RET
	SKIPN CABKFG		;SET?
	ETYPE <\>		;NO, SIGNAL
	SETOM CABKFG		;SET BACKSPACE FLAG
	RET


CADELF:	SKIPN CEDUMB
	 RET
	SKIPN CADLFG		;SET?
	ETYPE <\\>		;NO, SIGNAL
	SETOM CADLFG		;SET DELETE FLAG
	RET


;	EMACS MODE BEGINS HERE

ECEINC:	MOVEI A,.CTTRM		;ALLOW 8 BIT INPUT
	RFMOD			;GET THE MODE WORD
	PUSH P,B		;SAVE IT
	TXZ B,TT%DAM		;BINARY MODE
	SFMOD
	PBIN			;GET EDIT CHARACTER
	POP P,B			;RESTORE MODE WORD
	PUSH P,A		;SAVE CHARACTER
	MOVEI A,.CTTRM
	SFMOD
	POP P,A			;RESTORE CHARACTER
	SKIPN CEMETA		;META KEY IN USE?
	 TRZ A,200		;NO, TRIM PARITY BIT
	TRZE A,200		;META KEY USED?
	 JRST METAN1		;YES, PROCESS IT
	CAIN A,CR		;^M - EXIT AND DO EDITED COMMAND
	 JRST CEEXIT
	CAIN A,.CHCNP		;^P - EDIT PREVIOUS COMMAND
	JRST CEUP
	CAIE A,.CHBEL		;^G - ABORT
	 CAIN A,.CHCNC		;^C - ABORT
	  JRST    CEQUIT
	CAIN A,.CHDEL		;RUBOUT - DELETE CHAR AT LEFT OF CURSOR
	 JRST CERUB		;EM74
	CAIN A,.CHCNB		;^B - CURSOR LEFT
	 JRST CELEFT
	CAIN A,.CHCNF		;^F - CURSOR RIGHT
	 JRST CERIGH
	CAIN A,.CHCNN		;^N - CURSOR DOWN
	 JRST CEDOWN
	CAIN A,.CHCND		;^D - DELETE CHARACTER AT CURSOR
	 JRST CERMSP
	CAIN A,.CHCNE		;^E - MOVE TO END OF LINE
	 JRST CEMEND
	CAIN	A,.CHCNA	;^A - MOVE TO BEGINNING OF LINE
	 JRST CEBEGN
	CAIN A,.CHVTB		;^K - KILL TO END OF LINE
	 JRST CEKILL
	CAIN A,.CHCNT		;^T - TRANSPOSE CHARACTERS
	 JRST CETRAN
	CAIN A,.CHCNW		;^W - SAME AS M-RUB
	 JRST METARB
	CAIN A,.CHCNY		;EM80 ^Y - Yank kill buffer
	 JRST CEYANK		;EM80
	CAIN A,.CHCUN		;^_ - HELP MESSAGE
	 JRST CEHELP
	CAIE A,.CHFFD		;^L - REDISPLAY LINE
	 CAIN A,.CHCNR		;^R - REDISPLAY LINE
	  JRST CEDISP
	CAIN A,.CHTAB		;TAB - INSERT WITHOUT V
	 JRST CINSRT
	CAIN A,.CHESC		;<ESC> - META PREFIX
	 JRST METAIN
	CAIE A,.CHCNQ		;^Q - TAKE NEXT CHAR LITERALLY
	 CAIN A,.CHCNV		;^V - TAKE NEXT CHAR LITERALLY
	  JRST CRTLV
	CAIGE A," "		;SOME OTHER CONTROL CHARACTER?
	 JRST CEINC		;YES, IGNORE IT
	JRST CINSRT		;INSERT THIS CHARACTER

CRTLV:	PBIN			;GET THE CHARACTER
	JRST CINSRT		;PROCESS IT


; An escape has been entered, get the next command character

METAIN:	PBIN			;GET THE NEXT WORD
METAN1:	CAIE A,.CHBEL		;EM83 M-^G
	 CAIN A,.CHCNC		;EM83 M-^C
	  JRST CEQUIT		;EM83 Abort
	CAIE A,"F"		;M-F - FORWARD TO END OF WORD
	 CAIN A,"f"
	  JRST METAF
	CAIE A,"B"		;M-B - BACK TO BEGINNING OF WORD
	 CAIN A,"b"
	  JRST METAB
	CAIE A,"D"		;M-D - DELETE TO END OF WORD
	 CAIN A,"d"
	  JRST METAD
	CAIN A,.CHDEL		;M-RUB - DELETE BACK TO START OF WORD
	 JRST METARB
	CAIN A,.CHESC		;M-ESC - STUFF COMMAND WITH <ESC>
	 JRST METAES
	CAIN A,"?"		;M-? - STUFF COMMAND WITH ?
	 JRST METAQU
	CALL CEBELL		;ERROR, RING BELL
	JRST CEINC		;TRY AGAIN


; Here to insert a character into the command line

CINSRT:	MOVE C,CEBPTR		;GET THE POINTER
CINST:	ILDB B,C		;GET ONE THAT WAS THERE
	DPB A,C			;REPLACE IT
	JUMPE A,CINST0		;EXIT AFTER A NULL BYTE
	PBOUT			;OUTPUT IT
	MOVE A,B		;SET UP TO REINSERT THE ONE
	JRST CINST
CINST0:	AOS A,CECPOS		;UPDATE EVERYTHING
	IBP CEBPTR

CINST1:	MOVE B,CEBPTR		;EM74 See what we're supposed to point to
	ILDB A,B		;EM74 If we're supposed to be at the end
	JUMPE A,CEINC		;EM74 of the line, we're already there!
	MOVEI A,CR
	PBOUT			;POSITION THE CURSOR
	CALL CENUMB		;MOVE PAST THE LINE NUMBER
	MOVE A,COJFN		;POINT TO THE TERMINAL
	HRROI B,CETSAV		;POINT TO THE STRING
	MOVN C,CECPOS		;GET COUNT
	SKIPE C			;DON'T GO FOREVER HERE
	 SOUT			;MOVE PAST THE OLD CHARACTERS
	JRST CEINC		;DONE


; Move the cursor to the left

CELEFT:	SKIPN CECPOS		;AT BEGINNING OF BUFFER?
	JRST CEINC		;YES, DO NOTHING
	LDB C,CEBPTR		;GET CHARACTER WE ARE GOING TO
	SETO B,
	ADJBP B,CEBPTR		;DECR BYTE PTR
	MOVEM B,CEBPTR
	SOS CECPOS		;DECR CHARACTER POSITION
	CAIGE C," "		;SOME CONTROL CHARACTER?
	 JRST CINST1		;YES, DON'T MESS UP
	CALL CEBACK		;BACK UP
	JRST CEINC

;EM74 **** Begin ****
; Erase last character

CERUB:	SKIPN CECPOS		;At beginning of buffer?
	 JRST CEINC		;Yep, don't do anything
	MOVE A,CEBPTR
	ILDB C,A		;Get character to see if we're at EOL
	SETO A,
	ADJBP A,CEBPTR		;Decrement byte pointer
	MOVEM A,CEBPTR
	SOS CECPOS		;And decrement character position
	JUMPN C,CERMSP		;If not at end of line, retype whole line
	CALL CEBACK		;Back up some
	JRST CEKILL		;And nuke end of line
;EM74 **** End ****

; Move the cursor to the end of the line

CEMEND:	MOVE B,CEBPTR		;SEE IF WE'RE POINTING AT ZERO BYTE
	ILDB A,B
	JUMPE A,CEMND1		;AT END OF LINE, QUIT
	AOS CECPOS
	PBOUT			;MOVE OVER
	JRST CEMEND+1
CEMND1:	MOVNI C,1
	ADJBP C,B
	MOVEM C,CEBPTR		;MAKE BYTE POINTER AGREE WITH CURSOR
	JRST CEINC


; Move the cursor to the right

CERIGH:	MOVE B,CEBPTR		;SEE IF WE'RE POINTING AT ZERO BYTE
	ILDB A,B
	JUMPE A,CEINC		;AT END OF BUFFER, DO NOTHING
	PBOUT			;MOVE OVER
	AOS CECPOS		;INCR CHARACTER POSITION
	IBP CEBPTR		;INCREMENT POINTER
	JRST CEINC



; Move to the next command line

CEDOWN:	HRRZ A,@CELPTR		;TAKE THE RIGHT HAND LINK
	SKIPN A			;CHECK FOR END OF LIST
	 JRST CEDWN1		;NOT AT END, SKIP THIS
	SOS CELPOS		;DECREMENT THE LINE NUMBER
	MOVEM A,CELPTR		;UPDATE POINTER
	JRST CETOP		;PROCESS THIS LINE

CEDWN1:	MOVE A,CE1ST		;END OF LIST, GO BACK TO THE FIRST LINE
	MOVEM A,CELPTR		;RESET THE POINTER
	MOVE A,CECNT		;GET RIGHT LINE NUMBER
	SOS A
	MOVEM A,CELPOS		;SET IT
	JRST CETOP		;PROCESS THIS LINE




; Move to the previous command line

CEUP:	HLRZ A,@CELPTR		;TAKE THE LEFT HAND LINK
	SKIPN A			;CHECK FOR END OF LIST
	 JRST CEUP1		;NOT AT END
	AOS CELPOS		;INCREMENT THE LINE NUMBER
	MOVEM A,CELPTR		;UPDATE POINTER
	JRST CETOP		;PROCESS THIS LINE

CEUP1:	MOVE A,CELAST		;END OF LIST, GO BACK TO THE FIRST LINE
	MOVEM A,CELPTR		;RESET THE POINTER
	SETZM CELPOS		;RESET LINE NUMBER
	JRST CETOP		;PROCESS THIS LINE


; Here to delete the character at the cursor

CERMSP: MOVE B,CEBPTR		;GET DESTINATION POINTER
	MOVEI A,1
	ADJBP A,CEBPTR		;POINTER TO SOURCE
	LDB C,A			;ZERO BYTE?
	JUMPE C,CEINC		;EM74 (Fix bug (check C, not A)) YES, QUIT
	SETZ C,			;NO, MOVE THE TEXT
	SIN
	MOVEI A,CR
	PBOUT			;START OVER
	CALL CENUMB		;WRITE THE LINE NUMBER
	HRROI A,CETSAV		;AND THE LINE
	PSOUT
	CALL EEOLN
	JRST CINST1		;POSITION THE CURSOR



; Here to move the cursor to the beginning of the line

CEBEGN:	MOVEI A,CETSAV		;FIX POINTER
	HLL A,[POINT 7,0]
	MOVEM A,CEBPTR
	SETZM CECPOS		;RESET POINTER TO BEGINNING OF LINE
	MOVEI A,CR
	PBOUT			;MOVE CURSOR TO BEGINNING
	CALL CENUMB		;WRITE THE LINE NUMBER
	JRST CEINC		;GET NEXT COMMAND



; Here to kill everything to the right of the cursor

CEKILL:	MOVE A, [POINT 7,CEKBUF] ;EM80
	MOVE B,CEBPTR		;EM80
	MOVEI C,^D80		;EM92 At most save only 80 chars in kill buffer
	SETZ D,			;EM92
	SOUT			;EM80 Put killed string in kill buffer
	SETZ A,			;CHOP OFF THE REST OF THE STRING
	IDPB A,B		;EM80 Add a null to end of kill buffer
	MOVE B,CEBPTR		;GET COPY OF POINTER
	IDPB A,B		;CURSOR IS ONE POSITION PAST POINTER
	CALL EEOLN		;ERRASE IT FROM THE SCREEN
	JRST CEINC		;GET NEXT COMMAND



;EM80 **** Begin ****

CEYANK:	MOVE A,[POINT 7,CEKBUF]
	CALL BCOUNT		;Count number of chars in kill buffer
	MOVEM B,CEKBC		;Save it
	PUSH P,A		;EM93 Save number of words in kill buffer
	MOVE A,[POINT 7,CETSAV]	;EM93 Now look at working buffer
	CALL BCOUNT		;EM93
	POP P,B			;EM93 Get back length of kill buffer
	ADD A,B			;EM93 Add it to length of working buffer
	CAILE A,50		;EM93 See if we'll exceed buffer...
	 JRST CEINC		;EM93 Yoiks! We will, better not do it
	MOVE A,CEBPTR
	CALL BUFFS		;Save the end of the line
	MOVE B,A
	MOVE A,CEKBC
	ADJBP A,CEBPTR
	SETZ C,
	SOUT			;Open up space for kill buffer
	MOVE A,CEBPTR
	MOVE B,[POINT 7,CEKBUF]
CEYNK1:	ILDB C,B
	SKIPE C
	 JRST [	IDPB C,A
		JRST CEYNK1 ]
	MOVE B,CEBPTR
	MOVE A,COJFN
	SOUT			;Print out new end of line
	MOVE A,CEKBC		;Get length of text added
	ADDM A,CECPOS
	ADJBP A,CEBPTR		;Add it so we move to end of what we inserted
	MOVEM A,CEBPTR
	JRST CINST1		;All done, finish updating the line

;EM80 **** End ****


; Here to swap the character at the cursor and the one before it

CETRAN:	SKIPN CECPOS		;BEGINNING OF LINE?
	 JRST CEINC		;YES, SKIP
	MOVE B,CEBPTR
	ILDB A,B		;END OF LINE?
	JUMPE A,CEINC
	MOVE B,CEBPTR		;GET LOCAL POINTER
	MOVEI A,1		;SCOOT OVER ONE
	ADJBP A,B
	LDB C,A			;CHANGE THE CHARACTERS IN THE BUFFER
	LDB D,B
	DPB D,A
	DPB C,B
	MOVEI A,CR
	PBOUT			;REWRITE THE LINE
	CALL CENUMB
	HRROI A,CETSAV
	PSOUT
	JRST CINST1		;POSITION CURSOR



; Here to move to the beginning of the next word

METAF:	CALL F.WORD		;GET DESTINATION
	ADDM B,CECPOS		;UPDATE POSITION
	JUMPE B,CEINC		;NO MOVEMENT, STOP
	MOVE C,B		;EM74 Number of characters to move
	ADJBP B,CEBPTR		;UPDATE POINTER
	PUSH P,B		;EM74 And save it
	MOVE B,CEBPTR		;EM74 Start of what we want to type
	MOVE A,COJFN		;EM74
	SOUT			;EM74 Print over one word
	POP P,CEBPTR		;EM74 Update pointer
	JRST CEINC		;EM74


; Here to move to the beginning of the previous word

METAB:	CALL B.WORD		;GET DESTINATION
	JUMPE B,CEINC		;SKIP IF NO MOVEMENT
	MOVNS B			;MAKE IT NEGATIVE
	MOVE C,B		;GET A COPY OF IT
	ADJBP C,CEBPTR		;UPDATE THE POINTER
	MOVEM C,CEBPTR
	ADDM B,CECPOS		;UPDATE POSITION
METAB1:	PUSH P,B		;EM74 Save number of chars to back up
	CALL CEBACK		;EM74 Back up one
	POP P,B			;EM74
	AOJN B,METAB1		;EM74
	JRST CEINC		;EM74

; Here to delete up to the beginning of the next word

METAD:	MOVE B,CEBPTR		;EM92
	ILDB A,B		;EM92
	JUMPE A,CEINC		;EM92 If at end of line, punt
	CALL F.WORD		;GET DESTINATION
	MOVE A,B		;GET COPY OF OFFSET
	ADJBP A,CEBPTR		;POINTER TO DESTINATION
	JRST M.FIX		;MOVE EVERYTHING


; Here to delete back to the beginning of the previous (or this) word

METARB:	MOVE A,CECPOS		;EM92
	JUMPE A,CEINC		;EM92 If at beginning of line, punt
	MOVE A,CEBPTR		;EM74
	ILDB B,A		;EM74 See if next char is end of line
	PUSH P,B		;EM74 Save it
	CALL B.WORD		;GET DESTINATION
	MOVN D,B		;MAKE IT NEGATIVE
	MOVE A,D
	ADDM A,CECPOS		;FIX UP POSITION
	ADJBP A,CEBPTR		;GET DESTINATION POINTER
	EXCH A,CEBPTR		;FOOL M.FIX - WE ARE NOW A M-D
	POP P,B			;EM74 Get char we saved
METAR1:	JUMPE D,METAR2		;NEED TO MOVE THE CURSOR OVER
	PUSH P,A		;SAVE THE POINTER
	CALL CEBACK		;BACK UP
	POP P,A			;RESTORE THE POINTER
	AOJA D,METAR1
METAR2:	JUMPE B,CEKILL		;EM74 If we were at EOL, just kill it


; Here to fix things up after Metad, Metarb, or Alter mode delete

M.FIX:	PUSH P,A		;EM80 A has end of word to stuff in kill buffer
	MOVE B,CEBPTR		;EM80 B has start of it
	MOVE D,[POINT 7,CEKBUF]	;EM80
M.FIX2:	ILDB C,B		;EM80 Get a character of deleted string
	IDPB C,D		;EM80 And save it in the kill buffer
	CAME A,B		;EM80 Saved all of word yet?
	 JRST M.FIX2		;EM80 No, on to next character
	SETZ C,			;EM80
	IDPB C,D		;EM80 Terminating null
	POP P,B			;EM80 Get copy of destination pointer
	SKIPN CEDUMB		;EMACS OR SMART ALTER?
	 PSOUT			;YES, OVERWRITE THE SCREEN
	CALL EEOLN		;CLEAN THINGS UP
	MOVE A,CEBPTR		;GET CURRENT POINTER
M.FIX1:	ILDB C,B		;GET FIRST CHARACTER
	IDPB C,A		;SAVE IN NEW POSITION
	JUMPN C,M.FIX1		;DONE?
	JRST CINST1		;POSITION THE CURSOR



; Subroutine to return number of spaces until start of next word

F.WORD:	SETZ B,			;INITIALIZE COUNT
	MOVE C,CEBPTR		;GET LOCAL COPY OF POINTER
	ILDB A,C		;GET THIS CHARACTER
	JUMPE A,[RET]		;END OF LINE, QUIT
	CAIL A,"0"		;EM74
	 CAILE A,"9"		;EM74
	  SKIPA			;EM74
	   JRST F.WRD2		;EM74
	CAIL A,"A"		;EM74
	 CAILE A,"Z"		;EM74
	   SKIPA		;EM74
	    JRST F.WRD2		;EM74
	CAIL A,"a"		;EM74
	 CAILE A,"z"		;EM74
	  SKIPA			;EM74
	    JRST F.WRD2		;EM74
F.WRD1:	ILDB A,C		;GET NEXT CHARACTER
	AOS B			;UPDATE COUNT
	JUMPE A,[RET]		;END OF LINE
	CAIL A,"0"		;EM74
	 CAILE A,"9"		;EM74
	  SKIPA			;EM74
	   JRST F.WRD2		;EM74
	CAIL A,"A"		;EM74
	 CAILE A,"Z"		;EM74
	   SKIPA		;EM74
	    JRST F.WRD2		;EM74
	CAIL A,"a"		;EM74
	 CAILE A,"z"		;EM74
	  SKIPA			;EM74
	    JRST F.WRD2		;EM74
	JRST F.WRD1		;EM74
F.WRD2:	ILDB A,C		;GET NEXT CHARACTER
	AOS B			;INCREMENT COUNT
	JUMPE A,[RET]		;END OF LINE
	CAIL A,"0"		;EM74
	 CAILE A,"9"		;EM74
	  SKIPA			;EM74
	   JRST F.WRD2		;EM74
	CAIL A,"A"		;EM74
	 CAILE A,"Z"		;EM74
	   SKIPA		;EM74
	    JRST F.WRD2		;EM74
	CAIL A,"a"		;EM74
	 CAILE A,"z"		;EM74
	  SKIPA			;EM74
	    JRST F.WRD2		;EM74
	RET			;YES, DONE.


; Subroutine to return number of spaces until start of previous word

B.WORD:	SETZ B,			;INITIALIZE COUNT
	MOVE C,CEBPTR		;GET LOCAL COPY OF POINTER
	MOVE D,CECPOS		;LOCAL COPY OF POSITION
	JUMPE D,[RET]		;BEGINNING OF LINE, EXIT
	ILDB A,C		;GET THIS CHARACTER
	CAIL A,"0"		;EM74
	 CAILE A,"9"		;EM74
	  SKIPA			;EM74
	   JRST B.WRD0		;EM74
	CAIL A,"A"		;EM74
	 CAILE A,"Z"		;EM74
	   SKIPA		;EM74
	    JRST B.WRD0		;EM74
	CAIL A,"a"		;EM74
	 CAILE A,"z"		;EM74
	  SKIPA			;EM74
	    JRST B.WRD0		;EM74
	JRST B.WRD1
B.WRD0:	LDB A,CEBPTR		;GET CHARACTER BEFORE THIS ONE
	CAIL A,"0"		;EM74
	 CAILE A,"9"		;EM74
	  SKIPA			;EM74
	   JRST B.WRD2		;EM74
	CAIL A,"A"		;EM74
	 CAILE A,"Z"		;EM74
	   SKIPA		;EM74
	    JRST B.WRD2		;EM74
	CAIL A,"a"		;EM74
	 CAILE A,"z"		;EM74
	  SKIPA			;EM74
	    JRST B.WRD2		;EM74
B.WRD1:	SETO A,			;BACKUP THE POINTER
	ADJBP A,C
	MOVE C,A
	LDB A,C			;GET NEXT ONE
	SOS D			;UPDATE COUNT
	AOS B			;UPDATE THIS TOO
	JUMPE D,[RET]		;CHECK FOR BEGINNING OF LINE
	CAIL A,"0"		;EM74
	 CAILE A,"9"		;EM74
	  SKIPA			;EM74
	   JRST B.WRD2		;EM74
	CAIL A,"A"		;EM74
	 CAILE A,"Z"		;EM74
	   SKIPA		;EM74
	    JRST B.WRD2		;EM74
	CAIL A,"a"		;EM74
	 CAILE A,"z"		;EM74
	  SKIPA			;EM74
	    JRST B.WRD2		;EM74
	JRST B.WRD1		;EM74
B.WRD2:	SETO A,			;BACKUP THE POINTER
	ADJBP A,C
	MOVE C,A
	LDB A,C			;GET NEXT CHARACTER
	SOS D			;UPDATE EVERYTHING
	AOS B
	JUMPE D,[RET]		;CHECK FOR BEGINNING OF LINE
	CAIL A,"0"		;EM74
	 CAILE A,"9"		;EM74
	  SKIPA			;EM74
	   JRST B.WRD2		;EM74
	CAIL A,"A"		;EM74
	 CAILE A,"Z"		;EM74
	   SKIPA		;EM74
	    JRST B.WRD2		;EM74
	CAIL A,"a"		;EM74
	 CAILE A,"z"		;EM74
	  SKIPA			;EM74
	    JRST B.WRD2		;EM74
	SOS B			;ADJUST IF NOT BEGINNING OF LINE
	RET			;ALL DONE



; Here to stick an Escape or question mark on the end of the command

METAES:	SKIPA B,[.CHESC]	;STUFF ESCAPE WITH THE COMMAND
METAQU:	MOVEI B,"?"		;STUFF ? WITH THE COMMAND
METAEQ:	ILDB A,CEBPTR		;LOOK FOR THE END OF THE LINE
	JUMPE A,METEQ1
	JRST METAEQ		;TRY AGAIN
METEQ1:	MOVEI C,.CHCNR		;EM124 Put a ^R in first so everything
	DPB C,CEBPTR		;EM124 is echoed by FIELD
	IDPB B,CEBPTR		;EM124 Now stuff the new character
	IDPB A,CEBPTR		;ADD A ZERO BYTE
	JRST CEEX2		;EM124

;EM124 *** Begin ***

; Here when done. Pass the edited command to the Exec to use
; Note that for a normal return (i.e. just CR) we can't just stuff a ^R
; at the end of the buffer and let FIELD do all the dirty work of echoing
; the command, because there is no way to make it print out a carriage return
; at the end!!! Sigh, thus this hack...

CEEXIT:	ILDB A,CEBPTR		;First find last character in line
	JUMPN A,CEEXIT
	SETO A,
	ADJBP A,CEBPTR		;Point to last character
	LDB B,A
	CAIN B,.CHESC		;Is the last char an Escape?
	 JRST [	MOVEM A,CEBPTR	;If so, then use METAES to exit
		SETZ A,		;Put a null in A
		JRST METEQ1 ]
	SETOM NOPRMT		;Don't let READY print out a prompt
	MOVE A,SVPRMT		;Get the prompt for ourself
	ETYPE <%_%%1\>		;Print it out
	HRROI A,CETSAV		;Get the command we're going to execute
	ETYPE <%1\>		;And print it too
	MOVEI B,LF		;Put a LF at the end of the buffer
	DPB B,CEBPTR
	SETZ A,			;And a null
	IDPB A,CEBPTR

CEEX2:	MOVEI A,.CTTRM
	CFIBF			;Clear the input buffer
	MOVE A,[POINT 7,CETSAV]	;Point to edited command
	RSCAN			;Put stuff in RSCAN buffer
	 ERROR <RSCAN failed stuffing buffer>
	MOVEI A,.RSINI		;Now give to the exec to use
	RSCAN
	 ERROR <RSCAN failed passing buffer to exec>

;EM124 *** End ***

CEQUIT: MOVEI Q1,ETTYMD		;LOAD EXEC TTY MODES
	CALL LTTYMD
	MOVEI A,.CTTRM		;RESTORE PAGE MODE IF WE NEED TO
	POP P,B
	STPAR
	SETOM CEBPTR		;DON'T SAVE THIS
	ETYPE <
>
	RET



; Routine to redisplay the line

CEDISP:	ETYPE <
>				;GO TO A NEW LINE
	CALL EEOLN		;JUST TO BE SURE
	CALL CENUMB		;DO THE LINE NUMBER
	HRROI A,CETSAV		;POINT TO COMMAND LINE
	PSOUT			;WRITE IT OUT
	JRST CINST1		;POSITION THE CURSOR



; Routine to send a bell to the terminal

CEBELL:	MOVE A,COJFN		;REDO THE CCOC
	RFCOC
	PUSH P,B		;SAVE MODE
	TLC B,1B32!1B33		;SEND ACTUAL CODE
	SFCOC
	MOVEI B,.CHBEL		;SEND THE BELL
	BOUT
	POP P,B			;RESTORE
	SFCOC
	RET


; Routine to back the cursor up one place

CEBACK:	MOVE A,COJFN		;GET THE TERMINAL TYPE
	RFMOD			;GET MODE WORD
	PUSH P,B		;SAVE IT
	TXZ B,TT%DAM		;NO TRANSLATION
	SFMOD
	GTTYP
	HRROI A,[ASCIZ //]	;ASSUME NORMAL TERMINAL
	CAIE B,.TT100		;GET THE VT100 TYPES OUT OF THE WAY
	 CAIN B,.TT125
	  HRROI A,[ASCIZ /[D/]
	CAIE B,.TTK10
	 CAIN B,.TTANS
	  HRROI A,[ASCIZ /[D/]
	CAIN B,.TTAMB
	 HRROI A,[ASCIZ /[D/]
	CAIN B,.TTB10		;BEEHIVES
	 HRROI A,[ASCIZ /D/]
	PSOUT
	MOVE A,COJFN		;RESTORE MODE WORD
	POP P,B			;GET OLD MODE
	SFMOD			;DO IT
	RET



; Routine to errase all characters to the end of line

EEOLN:	PUSH P,A		;SAVE THIS
	PUSH P,B		;THIS TOO
	MOVE A,COJFN		;CURRENT OUTPUT JFN
	RFMOD			;GET MODE WORD
	PUSH P,B		;SAVE IT
	TXZ B,TT%DAM		;NO TRANSLATION
	SFMOD
	GTTYP			;GET TERMINAL TYPE
	CAIG B,EOLNMX		;ALL WE KNOW ABOUT NOW
	SKIPN A,EEOLTB(B)	;GET STRING TO DUMP
	 JRST EEOLN2		;NONE - DO NOTHING
	TLNN A,-1		;STRING OR PNTR?
	 TLOA A,-1		;PNTR TO TEXT
	  HRROI A,EEOLTB(B)	;STRING - POINT TO IT INSTEAD
	PSOUT			;DUMP IT
EEOLN2:	MOVE A,COJFN		;RESTORE MODE WORD
	POP P,B			;GET OLD MODE
	SFMOD			;DO IT
	POP	P,B		;RESTORE THIS
	POP	P,A		;THIS TOO
	RET

; ERRASE TO END OF LINE TABLE

EEOLTB:	0			;(0) Tty 33
	0			;(1) Tty 35
	0			;(2) Tty 37
	0			;(3) TI
	0			;(4)
	0			;(5)
	0			;(6)
	0			;(7)
	0			;(8) System default
	0			;(9) Ideal
	BYTE(7) 36,0		;(10) VT05
	BYTE(7) .CHESC,"K",0	;(11) VT50
	0			;(12) LA30
	0			;(13) GT40
	0			;(14) LA36
	BYTE(7) .CHESC,"K",0	;(15) VT52
	BYTE(7) .CHESC,"[","K",0 ;(16) VT100
	0			;(17) LA38
	0			;(18) LA120
	BYTE(7) .CHESC,"K",0	;(19) Regent-20
	BYTE(7) .CHESC,"I",0	;(20) IBM 3101
	0			;(21)
	0			;(22)
	[BYTE(7) .CHESC,"I",.CHDEL,.CHDEL,.CHDEL,.CHDEL,.CHDEL,0] ;(23) Bantam
	BYTE(7) .CHESC,"K",0	;(24) Telray
	0			;(25) ADM3A
	BYTE(7) .CHESC,"K",0	;(26) Beehive 100
	0			;(27) Hazeltine 1200
	BYTE(7) .CHESC,"K",0	;(28) HP 26xx
	0			;(29) Tektronix 4006
	0			;(30) Glass
	BYTE(7) .CHESC,"I",0	;(31) Fox
	BYTE(7) 33,"U",33,"U"-"@",0 ;(32) Concept-100
	BYTE(7) 13,0		;(33) Infoton-Vista
	BYTE(7) .CHESC,"K",0	;(34) Heath-19
	BYTE(7) .CHESC,"[","K",0 ;(35) VT125
	BYTE(7) .CHESC,"[","K",0 ;(36) VK100
	0			;(37) Diablo 1620
	BYTE(7) .CHESC,"K",0	;(38) Minibee 4
	BYTE(7) 6,0		;(39) CT82
	BYTE(7) .CHCRB,0	;(40) Datamedia 1520A
	BYTE(7) .CHESC,"t",0	;(41) Televideo 912C
	BYTE(7) .CHESC,"K",0	;(42) Super Bee
	BYTE(7)	.CHESC,"T",0	;(43) ADM31
	BYTE(7) .CHESC,"K",0	;(44) OSIC4
	0			;(45) Hazeltine 2000
	BYTE(7) .CHESC,"[","K",0 ;(46) ANSI
	BYTE(7) .CHESC,"t",0	;(47) Dialogue-81
	BYTE(7) 33,"U",33,"U"-"@",0 ;(48) Concept-108
	BYTE(7) "K"-100,0	;(49) DG Dasher D200
	BYTE(7) .CHESC,"[","K",0 ;(50) Ann Arbor Ambassador
	BYTE(7) .CHESC,"I",0	;(51) Owl
	BYTE(7) .CHESC,"O"-100,0 ;(52) Hazeltine 1420
	BYTE(7) .CHESC,"K",0	;(53) Micro Bee
	BYTE(7) 33,"U",33,"U"-"@",0 ;(54) PERQ
	BYTE(7) .CHESC,"T",0	;(55) ADM 21
	0			;(56) Tektronix 4025
	BYTE(7) 33,"U",33,"U"-"@",0 ;(57) Concept-LNZ (like a C-100)
	BYTE(7) .CHESC,"T",0	;(58) Dialogue-81
	BYTE(7) "K"-100,0	;(59) D400
	BYTE(7) .CHESC,"O"-100,0 ;(60) Hazeltine 1410
	BYTE(7) .CHESC,"K",0	;(61) ADDS Viewpoint
	BYTE(7).CHESC,"K",0	;(62) ZT-1
	0			;(63) Netronics
EOLNMX== .-EEOLTB-1

;	Routine to type a help message for Emacs mode


CEHELP:	CALL	BLANK1		;CLEAR THE SCREEN
	HRROI	A,[ASCIZ /
This is the Emacs mode command editor.  To exit, type a Control-G.

Return		Execute edited command
Control-N	Edit the next command line
Control-P	Edit the previous command line
Control-F	Move forward one character
Control-B	Move back one character
Control-L	Redisplay the command line
Control-E	Move to the end of the line/]
	PSOUT					;AVOID LITERAL TOO LONG
	HRROI	A,[ASCIZ /
Control-A	Move to the beginning of the line
Control-T	Swap the character at the cursor with the one before it
Control-D	Delete the character at the cursor
Control-K	Delete everything to the right of the cursor
Control-Y	Yank text from kill buffer
Control-Q	Quote the next character for insert
Rubout		Delete the character to the left of the cursor
Escape  F	Move to the beginning of the next word/]
	PSOUT
	HRROI	A,[ASCIZ /
Esc B	(M-B)	Move to the beginning of the previous word
Esc D	(M-D)	Delete up to the beginning of the next word
Esc Rub	(M-Rub)	Delete back to the beginning of the previous word
Esc Esc	(M-Esc)	Add an Escape to the end of the command and exit
Esc ?	(M-?)	Add a question mark to the end of the command and exit
others		Insert this character at the cursor  /]

	PSOUT
	JRST	CEDISP			;REDISPLAY THE LINE




; Routine to type help message for Alter mode

CAHELP:	CALL	BLANK1		;TRY TO BLANK THE SCREEN
	HRROI	A,[ASCIZ /This is the Alter mode command editor.

Return		Execute edited command
E		Execute edited command
Q		Return to command level
Line Feed	Edit the next command line
Escape		Edit the previous command line
Control-U	Ignore editing up to now and start over
I		Enter insert mode (exit with an escape)
nSPACE		Move forward n characters/]
	PSOUT					;AVOID LITERAL TOO LONG
	HRROI	A,[ASCIZ /
nRUB		Move back n characters
nW		Move forward n words
Tab		Move to the end of the line
X		Move to the end of the line and enter insert mode
Control-L	Redisplay the command line, move cursor to beginning
Control-R	Redisplay the command line, stay at current cursor position
P		Redisplay the command line, stay at current cursor position/]
	PSOUT
	HRROI	A,[ASCIZ /
\		Swap the character at the cursor with the one before it
nD		Delete n characters at the cursor
nR		Delete n characters then enter insert mode
:		Delete everything to the right of the cursor
H		Delete the rest of the line and enter insert mode/]

	PSOUT
	JRST	CETOP			;RETYPE THE LINE



;	COMMAND EDIT INTERRUPT ROUTINE

.CEPSI::SKIPN CLF		;AT COMMAND LEVEL?
	 DEBRK			;NO, DON'T DO THIS
	SKIPE .P		;DO WE HAVE A SAVED STACK POINTER?
	 MOVE P,.P		;YES, RESTORE IT
	CALL RLJFNS		;RELEASE PARSED JFN'S
	MOVE A,[POINT 7,CBUF]	;LOOK AT THE COMMAND BUFFER
	ILDB B,A		;GET THE NEXT CHARACTER
	JUMPN B,.-1		;KEEP LOOKING FOR A NULL
	SETO C,			;FOUND IT
	ADJBP C,A		;BACK UP ONE CHARACTER
	MOVEI A,.PRIIN		;LOOK AT THE TERMINAL
	SIBE			;ANYTHING THERE?
	 JRST [	MOVE A,C	;YES, ADD IT TO THE BUFFER
		MOVE B,[RD%RIE+^D80]
		SETZ C,		;NO PROMPT, QUIT WHEN TTY BUFFER IS EMPTY
		RDTTY		;GET IT
		 ETYPE <%_%%Can not find rest of command, Continuing>
		IDPB C,A	;ASCIZ THE STRING
		JRST .+1 ]	;READY TO GO NOW
	CALL CSAVE		;SAVE THE COMMAND IN PROGRESS
	PUSH P,P		;SAVE THE STACK POINTER
	TRVAR <CADLFG,CEDUMB,CABKFG,CELPOS,CECPOS,CELPTR,CEDSEA,CENUMR,CEKBC>	;SYNC ;EM80 Add CEKBC
	SETZM CEDSEA		;INITIALIZE STUFF
	CALL CEDITU		;GO TO THE EDITOR
	POP P,P			;FLUSH THE TRVARS
	MOVE A,LEV1PC		;GET THE RETURN ADDRESS
	HRRI A,CMDIN4		;CHANGE IT
	TXO A,PC%USR		;RETURN TO USER CODE
	MOVEM A,LEV1PC		;RESTORE FIXED PC
	DEBRK			;PARSE EDITED COMMAND


;	"SET INTERRUPT-CHARACTER (FOR COMMAND EDITOR TO) CHAR" COMMAND

.SCEIC::NOISE (for command editor to)
	STKVAR <ICHAR>		;CHARACTER TO INTERRUPT ON
	MOVEI B,CEICLS		;POINT TO THE LIST
	CALL FLDSKP		;GET THE CHARACTER
	 JRST [ ETYPE <%@?Character not available%_>
		RET ]
	HRRZ C,1(C)		;POINT TO THE STRING
	LDB B,[POINT 7,(C),13]	;GET THE CHARACTER
	TXZ B,1B29!1B30		;MAKE IT A CONTROL CHARACTER
	MOVEM B,ICHAR		;SAVE IT
	NOISE (for command editor)
	CONFIRM			;CONFIRM THE COMMAND
	SKIPL A,CEPSIC		;GET THE OLD CHARACTER
	 DTI			;IF ONE WAS ASSIGNED THEN DEASSIGN IT
	HRLZ A,ICHAR		;GET THE NEW ONE
	HLRZM A,CEPSIC		;SAVE IT
	HRRI A,^D31		;SET THINGS UP
	ATI			;ASSIGN NEW INTERRUPT CHARACTER
	RET			;DONE

.SNCEI::NOISE (for command editor)
	CONFIRM			;COMFIRM "SET NO INTERRUPT-CHARACTER"
	SKIPGE A,CEPSIC		;DO WE HAVE ONE?
	 RET			;NO, QUIT
	DTI			;WE HAD ONE, DEASSIGN IT
	SETOM CEPSIC		;SAY WE DON'T HAVE ONE
	RET			;DONE


;	COMMAND EDIT INTERRUPT CHARACTER LIST

CEICLS:	FLDDB. .CMTOK,CM%SDH,<POINT 7,[ASCIZ .^@.]>,,,Z1
Z1:!	FLDDB. .CMTOK,CM%SDH,<POINT 7,[ASCIZ .^A.]>,,,Z2
Z2:!	FLDDB. .CMTOK,CM%SDH,<POINT 7,[ASCIZ .^a.]>,,,Z3
Z3:!	FLDDB. .CMTOK,CM%SDH,<POINT 7,[ASCIZ .^B.]>,,,Z4
Z4:!	FLDDB. .CMTOK,CM%SDH,<POINT 7,[ASCIZ .^b.]>,,,Z7
Z7:!	FLDDB. .CMTOK,CM%SDH,<POINT 7,[ASCIZ .^G.]>,,,Z8
Z8:!	FLDDB. .CMTOK,CM%SDH,<POINT 7,[ASCIZ .^g.]>,,,Z9
Z9:!	FLDDB. .CMTOK,CM%SDH,<POINT 7,[ASCIZ .^H.]>,,,Z10
Z10:!	FLDDB. .CMTOK,CM%SDH,<POINT 7,[ASCIZ .^h.]>,,,Z11
Z11:!	FLDDB. .CMTOK,CM%SDH,<POINT 7,[ASCIZ .^K.]>,,,Z12
Z12:!	FLDDB. .CMTOK,CM%SDH,<POINT 7,[ASCIZ .^k.]>,,,Z13
Z13:!	FLDDB. .CMTOK,CM%SDH,<POINT 7,[ASCIZ .^N.]>,,,Z14
Z14:!	FLDDB. .CMTOK,CM%SDH,<POINT 7,[ASCIZ .^n.]>,,,Z15
Z15:!	FLDDB. .CMTOK,CM%SDH,<POINT 7,[ASCIZ .^P.]>,,,Z16
Z16:!	FLDDB. .CMTOK,CM%SDH,<POINT 7,[ASCIZ .^p.]>,,,Z17
Z17:!	FLDDB. .CMTOK,CM%SDH,<POINT 7,[ASCIZ .^Q.]>,,,Z18
Z18:!	FLDDB. .CMTOK,CM%SDH,<POINT 7,[ASCIZ .^q.]>,,,Z19
Z19:!	FLDDB. .CMTOK,CM%SDH,<POINT 7,[ASCIZ .^S.]>,,,Z20
Z20:!	FLDDB. .CMTOK,CM%SDH,<POINT 7,[ASCIZ .^s.]>,,,Z21
Z21:!	FLDDB. .CMTOK,CM%SDH,<POINT 7,[ASCIZ .^X.]>,,,Z22
Z22:!	FLDDB. .CMTOK,CM%SDH,<POINT 7,[ASCIZ .^x.]>,,,Z23
Z23:!	FLDDB. .CMTOK,CM%SDH,<POINT 7,[ASCIZ .^Y.]>,,,Z24
Z24:!	FLDDB. .CMTOK,CM%SDH,<POINT 7,[ASCIZ .^y.]>,<Control character,
	Written as ^X>

	END
