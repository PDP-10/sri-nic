;<EXEC.CMU>EXECIN.MAC.10, 15-Feb-85 14:26:35, Edit by VAF
;Merge CC/CS: deconditionalize MKDIR & a few other things.
;CM390 Add MICOM-debugging check in INFO SYSTEM.
;<EXEC.CMU>EXECIN.MAC.9,  7-Feb-85 14:33:41, Edit by VAF
;CM356 At CS, don't care if HLP:DECNET-DESCRIPTION file does not exist...
;<EXEC.CMU>EXECIN.MAC.8,  3-Jan-85 16:37:29, Edit by VAF
;CS138(CM290) Hack to prevent recomputing directory group allocation for every
;      subdir.
;<EXEC.CMU>EXECIN.MAC.6, 19-Dec-84 18:09:30, Edit by VAF
;CS128 Know about creation date & sponsor in accounts aux data file. Don't
;      print scheduler class info, since it is pretty useless to most users.
;<EXEC.CMU>EXECIN.MAC.5, 31-Oct-84 16:51:58, Edit by VAF
;CS136 Print local internet host name in Information Job
;<EXEC.CMU>EXECIN.MAC.4, 16-Apr-84 13:44:19, Edit by VAF
;CS119 Report status of ENAFLG in INFO COMMAND-LEVEL
;<EXEC.CMU>EXECIN.MAC.3,  9-Mar-84 14:30:56, Edit by VAF
;CS115 Information Default MKDIR
;<EXEC.CMU>EXECIN.MAC.2,  1-Mar-84 21:23:00, Edit by VAF
; CS112 Show status of .SFMCB, too.
; CS112 (CS) Remove DEC edit [729] to break help abbrev. because it is bogus
; EM135 Use new capitalizing macro when generating TTYPE table
; EM66 Command editor
; EM44 Don't print warnings when 'info term' fails for some options
; EM34 User IPCF
; EM33 Casification in 'info file-status'
; EM24 De-conditionalize sends
; EM13 Casification in SIXPRT
; EM6 Verbose ^T
; CS90 Use alternate command tables for NLI info commands.
;      HELP LOGIN is only possibility if NLI restricted.
;<5.EXEC>EXECIN.MAC.6, 22-Aug-83 19:31:12, Edit by PA0B
;CM236 Fix message from "I psi" for no program, Remove most of previous
;changes for PDV printing (they seem to be unnecessary now), Change
;"Info coke" change number, CS85 Add "Information Dover".
;<5.EXEC>EXECIN.MAC.5, 17-May-83 11:03:42, Edit by PA0B
;CM6 Put disclaimer from "Logout" message at end of "Information
; usage" output
;CM236 Make "Information DECnet" properly sort nodes which have
; 6-character names
;CM363 Use mapped keyword table scheme for "Help".  Don't dirty the
; mapped pages in "Help" and "News", but unmap them after use instead.
; Don't preload pages of Hlp:News-Index.Nws, since (hopefully) COMND%
; won't use them if the user doesn't type a "?".  Set GJ%PHY and try
; again if we look for a help file and can't find it.
;CM236 Remove NEWNX (added by CM201) because we're now Exec0 detects
; that the user has typed something like "New:hgfhgf" and gives an
; appropriate error without ever calling us.
;CM113 Look for Accounts.Sys on ACCOUNT:
;CS51 Add "Information Coke-status" at CS
;<5.EXEC>EXECIN.MAC.4, 18-Jan-83 03:56:46, Edit by PA0B
;CM156 "Info version" prints PCL version number
;CM156 Redo "TERMINAL type" code in "Information terminal" to
; allow PCL to also access the terminal type names
;CM236 Clean up PDV crap in "Info version"
;<5.EXEC>EXECIN.MAC.3,  3-Jan-83 14:01:03, Edit by PA0B
;CM356 Add "Information DECnet description"
;CM236 Replace GNJFN's with calls to $GNJFN to avoid problems
; when the Exec tries to delete a stacked JFN that GNJFN has
; already killed
;<5.EXEC>EXECIN.MAC.2,  4-Dec-82 04:58:38, Edit by PA0B
;CM236 Fix "Info term" for line halfduplex terminals
;Merge CMU v5:
; CM6   "Information usage"
; CM14  No terminal speeds at CC
; CM113 "Information accounts"
; CM114 Remove "Information mail system" hack (security hole at CMU)
; CM142 Allow "Information disk" not logged in
; CM156 PCL
; CM187 "Terminal [no] translate" (note: "Info term n" is wrong in
;	regards to translate status if n is not the terminal of the
;	user issuing the command)
; CM201 "News"
; CM201 Give slightly better message from "Help ?"
; CM224 Efficiency changes,
; CM224 Remove "Information downtime"
; CM236 Handle RFSTS% failure in FSTAT
; CM236 Remove silly check for net mail in .MALST
; CM236 REPEAT 0 more unreachable code in "Help"
; CM236 Use ERROR instead of CMERRX for "Invalid HELP request" error
; CM236 Make "Info PSI" and "Info memory" handle execute-only (this fix
;	only necessary at sites which have made xct-only work)
; CM238 Don't show FE devices as available
; CM242 don't show defaults for cards or paper tape in "Information
;	default all"
; CM266 Real names
; CM290 CS disk quota scheme
; CM317 Handle non-existent or unreadable last writer string in
;	"Information mail"
; CM318 "Set [no] privileges"
; CS15  "Receive/Refuse sends"
; CS44  Scheduler and pager info on ^T and "Information memory"
; CS47  "Terminal [no] backspace-means-delete"
; CM47+CM228+CM256+CM264+CM155+CM251 Gobs of terminal types
; UPD ID= 78, FARK:<5-WORKING-SOURCES.EXEC>EXECIN.MAC.4,  17-Aug-82 13:58:54 by DONAHUE
;Edit 744 - Add VK100 and VT125 to TTYPTB
; UPD ID= 52, FARK:<5-WORKING-SOURCES.EXEC>EXECIN.MAC.3,  17-May-82 17:59:04 by KROSENBLUH
;Edit 735 - Set flag for ETYPE'ing last error message for INFO PROG
; UPD ID= 40, FARK:<4-1-WORKING-SOURCES.EXEC>EXECIN.MAC.4,  29-Apr-82 15:22:25 by KROSENBLUH
;Edit 730 - Reinsert edit 612
; UPD ID= 38, FARK:<4-1-WORKING-SOURCES.EXEC>EXECIN.MAC.3,  29-Apr-82 15:16:59 by KROSENBLUH
;EDIT 729 - Reinsert edit 604.
; UPD ID= 14, FARK:<4-1-WORKING-SOURCES.EXEC>EXECIN.MAC.2,   1-Apr-82 11:41:00 by MOSER
;EDIT 719 - Don't type pause characters unless rel 5 or after.
; UPD ID= 137, SNARK:<5.EXEC>EXECIN.MAC.22,   6-Feb-82 16:37:43 by LEACHE
;TCO 5.1722 CHANGE JSYS-TRAPPING PARAMETER
; UPD ID= 120, SNARK:<5.EXEC>EXECIN.MAC.21,  28-Dec-81 11:14:01 by CHALL
;TCO 5.1644 - UPDATE COPYRIGHT NOTICE
; UPD ID= 101, SNARK:<5.EXEC>EXECIN.MAC.19,  22-Oct-81 14:34:32 by CHALL
;TCO 5.1583 MOVE $DEF- KEYWORDS FOR "INFO DEFAULTS" TO EXECCA
; UPD ID= 79, SNARK:<5.EXEC>EXECIN.MAC.18,   2-Oct-81 10:35:18 by CHALL
;TCO 5.1550 BEFORE- LOOK AT F2 FLAG IN Z; ON==OUTPUT TAB; OFF==SPACE
;  .DNTOP- LIGHT F2 FLAG IN AC Z FOR BEFORE ROUTINE
;TCO 5.1532 .DNTOP: RE-DO CODE; OUTPUT DECNET NODE LIST SORTED
; UPD ID= 75, SNARK:<5.EXEC>EXECIN.MAC.17,  21-Sep-81 14:55:46 by CHALL
;TCO 5.1525 BEFORE- MAKE LAST ITEM ON A LINE END WITH COMMA<CR> (NOT JUST <CR>)
;  ALSO, KICK OUT A NEW LINE WHEN 9 AWAY FROM THE END (", XXX-XXX," HAS TO FIT)
;TCO 5.1524 .FILST- CHANGE blank TO carriage return IN HELP TEXT
; UPD ID= 26, SNARK:<5.EXEC>EXECIN.MAC.14,  14-Aug-81 18:34:16 by CHALL
;TCO 5.1454 CHANGE NAME FROM XDEF TO EXECDE
; UPD ID= 16, SNARK:<5.EXEC>EXECIN.MAC.10,  17-Jul-81 15:43:09 by CHALL
;TCO 5.1421 .INDEF- ADD "INFO DEFAULTS ALL"; MAKE IT THE DEFAULT
; UPD ID= 14, SNARK:<5.EXEC>EXECIN.MAC.8,  16-Jul-81 09:03:22 by CHALL
;TCO 5.1417 .PISTA- IF RIR FAILS TRY AN XRIR%
; UPD ID= 2258, SNARK:<5.EXEC>EXECIN.MAC.7,  26-Jun-81 16:56:45 by CHALL
;TCO 5.1389 .ALRST- INFO ALERT SAYS IF ALERTS ARE AUTOMATIC OR NOT
;TCO 5.1387 - NPINFO: ADD LINE TO INFO TERM SAYING WHAT THE PAUSE-EOP CHARS ARE
;<HELLIWELL.EXEC.5>EXECIN.MAC.2, 12-Jun-81 14:17:04, EDIT BY HELLIWELL
;MAKE .DOWNT INTERNAL (::)
;<HELLIWELL.EXEC.5>EXECIN.MAC.1, 14-May-81 08:19:15, EDIT BY HELLIWELL
;REMOVE "GT40" TERMINAL TYPE
; UPD ID= 1957, SNARK:<5.EXEC>EXECIN.MAC.4,   7-May-81 09:19:36 by GRANT
;TCO 5.1316 - Make @INF VER be able to handle an entry vector in a non-0 section
; UPD ID= 1953, SNARK:<5.EXEC>EXECIN.MAC.3,   6-May-81 15:04:48 by MURPHY
;SEARCH GALAXY UNV'S
;REMOVE MFRK CONDITIONALS
;PCL ASSEMBLY SWITCH
;<4.EXEC>EXECIN.MAC.1, 11-Apr-80 06:19:07, Edit by DK32
;Programmable Command Language
; UPD ID= 1542, SNARK:<5.EXEC>EXECIN.MAC.35,   9-Feb-81 13:26:11 by OSMAN
;More 5.1223 - try to print as much as possible for inactive line
; UPD ID= 1541, SNARK:<5.EXEC>EXECIN.MAC.34,   9-Feb-81 13:19:10 by OSMAN
;More 5.1223 - try to print as much as possible for inactive line
; UPD ID= 1440, SNARK:<5.EXEC>EXECIN.MAC.33,  15-Jan-81 10:52:33 by OSMAN
;Tco 5.1233 - Make FILE-OPENINGS and JSYS OPENF independent
; UPD ID= 1429, SNARK:<5.EXEC>EXECIN.MAC.32,   9-Jan-81 15:02:31 by OSMAN
;5.1129 - Clear SYMOKF in INFO PROG and INFO FORK to make symbols come out right
; UPD ID= 1424, SNARK:<5.EXEC>EXECIN.MAC.31,   8-Jan-81 15:37:22 by OSMAN
;Fix "INFO PROG" to type correct error message of inferior fork
; UPD ID= 1406, SNARK:<5.EXEC>EXECIN.MAC.30,   6-Jan-81 14:40:49 by OSMAN
;More 5.1225 - Fix handling of "FORK" at FSTAT8
; UPD ID= 1399, SNARK:<5.EXEC>EXECIN.MAC.29,   6-Jan-81 10:27:50 by OSMAN
;tco 5.1225 - Implement jsys trapping and file-opening trapping!
; UPD ID= 1395, SNARK:<5.EXEC>EXECIN.MAC.28,  31-Dec-80 17:03:37 by LYONS
;TCO 5.1224 - Type a * in front of our node in I DECNET
; UPD ID= 1393, SNARK:<5.EXEC>EXECIN.MAC.27,  31-Dec-80 16:04:59 by OSMAN
;tco 5.1223 - Allow "INFO TERMINAL n"
; UPD ID= 1323, SNARK:<5.EXEC>EXECIN.MAC.26,   1-Dec-80 16:00:57 by OSMAN
;Use GETENT and SETENT instead of GEVEC and SEVEC
; UPD ID= 1241, SNARK:<5.EXEC>EXECIN.MAC.25,   6-Nov-80 15:21:04 by OSMAN
;Use HIGHPN as highest possible page number
; UPD ID= 1129, SNARK:<5.EXEC>EXECIN.MAC.24,   6-Oct-80 10:16:43 by OSMAN
;tco 5.1167 - Remove FDB autokeep feature
; UPD ID= 1042, SNARK:<5.EXEC>EXECIN.MAC.23,  25-Sep-80 14:14:10 by OSMAN
;TCO 5.1156 - Add INFO DEF PROGRAM
; UPD ID= 1032, SNARK:<5.EXEC>EXECIN.MAC.22,  23-Sep-80 09:48:30 by OSMAN
;More 5.1150 - Call DGFRKS after printing non-tree info, since (C) is needed
; UPD ID= 1028, SNARK:<5.EXEC>EXECIN.MAC.21,  22-Sep-80 10:38:10 by OSMAN
;tco 5.1150 - Add SET PROGRAM
; UPD ID= 1010, SNARK:<5.EXEC>EXECIN.MAC.20,  12-Sep-80 09:30:10 by OSMAN
;More 5.1113 - Print directory name before doing GTDAL
; UPD ID= 999, SNARK:<5.EXEC>EXECIN.MAC.19,  11-Sep-80 16:13:44 by OSMAN
;More 5.1113 - Print directory names
; UPD ID= 996, SNARK:<5.EXEC>EXECIN.MAC.18,  10-Sep-80 11:09:23 by OSMAN
;More 5.1113 - Do GTDAL in right place
; UPD ID= 919, SNARK:<5.EXEC>EXECIN.MAC.17,  19-Aug-80 15:06:33 by HESS
; UPD ID= 873, SNARK:<5.EXEC>EXECIN.MAC.16,  11-Aug-80 13:07:30 by OSMAN
;More 5.1113
; UPD ID= 856, SNARK:<5.EXEC>EXECIN.MAC.15,  10-Aug-80 15:20:12 by OSMAN
;tco 5.1129 - Add symbolic address and expression support
; UPD ID= 851, SNARK:<5.EXEC>EXECIN.MAC.14,   7-Aug-80 16:52:52 by OSMAN
;More 5.1113 - Fix INFO DIS; DSKSTL was assuming RLJFNS preserved temps
; UPD ID= 842, SNARK:<5.EXEC>EXECIN.MAC.13,   5-Aug-80 16:26:20 by OSMAN
;More 5.1120
; UPD ID= 834, SNARK:<5.EXEC>EXECIN.MAC.12,   5-Aug-80 08:58:50 by OSMAN
;More 5.1120
; UPD ID= 823, SNARK:<5.EXEC>EXECIN.MAC.11,   4-Aug-80 09:48:24 by OSMAN
;tco 5.1120 - Make INFO VERSION show names and versions of pdvs
; UPD ID= 733, SNARK:<5.EXEC>EXECIN.MAC.10,   6-Jul-80 20:32:24 by LYONS
;FIX SOME BUGS IN READ AFTER WRITE OPTIONS
; UPD ID= 717, SNARK:<5.EXEC>EXECIN.MAC.8,   1-Jul-80 10:43:46 by OSMAN
;tco 5.1086 - Show offline-expiration-default under INFO SYSTEM-STATUS
; UPD ID= 620, SNARK:<5.EXEC>EXECIN.MAC.7,   9-Jun-80 18:12:36 by LYONS
;tco 5.1062 add information about read after write options
;<5.EXEC>EXECIN.MAC.6, 30-May-80 16:53:53, EDIT BY MURPHY
;NEW MAIL WATCH AND ALERTS UNDER NEWF
; UPD ID= 534, SNARK:<5.EXEC>EXECIN.MAC.5,  20-May-80 15:36:03 by MURPHY
;CHANGE SOME XTND TO NEWF OR MFRK
; UPD ID= 497, SNARK:<5.EXEC>EXECIN.MAC.4,  30-Apr-80 14:55:15 by OSMAN
;tco 5.1029 - Make INFO DECNET work right with small terminal widths
; UPD ID= 494, SNARK:<5.EXEC>EXECIN.MAC.3,  30-Apr-80 14:34:50 by OSMAN
;More confirmation fixups
; UPD ID= 475, SNARK:<4.1.EXEC>EXECIN.MAC.17,  24-Apr-80 16:05:26 by TOMCZAK
;Replace references to T1 with A to avoid confusion with GALAXY
;<4.1.EXEC>EXECIN.MAC.15, 24-Apr-80 15:22:52, EDIT BY OSMAN
;Don't require double confirmation on certain INFO DEFAULT commands
; UPD ID= 441, SNARK:<4.1.EXEC>EXECIN.MAC.14,  14-Apr-80 10:23:46 by OSMAN
;More 4.1.1111 - Don't loop if structure 2136: mounted!
;<4.1.EXEC>EXECIN.MAC.13, 17-Mar-80 14:09:35, EDIT BY OSMAN
;Get rid of ONEWRD checks
;<4.1.EXEC>EXECIN.MAC.8, 14-Mar-80 11:43:21, EDIT BY OSMAN
;tco 4.1.1111 - Handle plotters correctly under INFO AVAIL DEV
; UPD ID= 163, SNARK:<4.1.EXEC>EXECIN.MAC.7,  19-Dec-79 16:49:30 by OSMAN
;tco 4.1.1055 - Add working set preloading info under INFO SYSTEM
;<4.1.EXEC>EXECIN.MAC.6, 17-Dec-79 16:48:15, Edit by HESS
;TCO #4.2594 - Fix symbol conflict in HELP command
;<4.1.EXEC>EXECIN.MAC.3, 20-Nov-79 14:10:03, EDIT BY OSMAN
;TCO 4.1.1023 - TAKE stuff
;<4.1.EXEC>EXECIN.MAC.2,  2-Nov-79 15:32:25, EDIT BY OSMAN
;tco 4.1.1006 - Use CMERRX for HELP command error instead of ERROR
;<4.EXEC>EXECIN.MAC.145, 26-Oct-79 11:23:03, EDIT BY TOMCZAK
;TCO#4.2554 - ILLEGAL TERMINAL TYPES NOT HANDLED RIGHT AT ILTTYP+1
;<4.EXEC>EXECIN.MAC.143, 22-Oct-79 13:44:36, EDIT BY OSMAN
;tco 4.2541 - Handle errors in INFO FILS better, where the jfn disappears
;<4.EXEC>EXECIN.MAC.142,  9-Oct-79 12:00:03, EDIT BY OSMAN
;tco 4.2521 - Fix up listing of I STR to not break up user names
;<4.EXEC>EXECIN.MAC.141, 24-Sep-79 12:01:50, Edit by HESS
;<4.EXEC>EXECIN.MAC.140, 20-Sep-79 14:20:35, Edit by HESS
; Use perm free space for FRKTBL
;<4.EXEC>EXECIN.MAC.139, 19-Sep-79 14:14:48, EDIT BY TOMCZAK
;TCO# 4.2475 - Remove parsing for * in HELP command (? does same thing>
;<4.EXEC>EXECIN.MAC.138, 17-Sep-79 14:55:07, Edit by HESS
; Cosmetic change to INFO PROGRAM-STATUS, add more data to INFO COMMAND
;<4.EXEC>EXECIN.MAC.137, 22-Aug-79 00:30:41, Edit by HESS
;<HESS.E>EXECIN.MAC.17, 20-Aug-79 16:33:39, Edit by HESS
; Add extended features
;<4.EXEC>EXECIN.MAC.133,  8-Aug-79 09:53:24, EDIT BY OSMAN
;tco 4.2378 - Expand INFO SYSTEM to include retrieval-wait info
;<4.EXEC>EXECIN.MAC.131,  1-Aug-79 14:59:28, EDIT BY OSMAN
;tco 4.2363 - add INFO DEFAULT TAKE
;<4.EXEC>EXECIN.MAC.128,  1-Aug-79 13:58:12, EDIT BY OSMAN
;tco 4.2362 - Don't list connected structure twice if LPT defined as DSK.
;<4.EXEC>EXECIN.MAC.127, 27-Jul-79 12:32:44, EDIT BY TOMCZAK
;STRST1 - Don't stop executing I STR command so can see subsequent structures
;<4.EXEC>EXECIN.MAC.126, 21-Jun-79 13:38:03, EDIT BY OSMAN
;REMOVE EXTRANEOUS REFS TO RLJFNS
;<4.EXEC>EXECIN.MAC.125, 19-Jun-79 13:03:14, EDIT BY OSMAN
;tco 4.2294 - Don't say "batch class -1"
;<4.EXEC>EXECIN.MAC.124,  5-Jun-79 11:24:26, EDIT BY OSMAN
;tco 4.2272 - Fix ADDRESS-BREAK error on 2020
;<4.EXEC>EXECIN.MAC.123,  1-May-79 11:19:12, EDIT BY OSMAN
;CHANGE GTJFN'S TO CALL GTJFS SO THAT ^C IN MIDDLE WON'T LEAVE JFN AROUND
;<4.EXEC>EXECIN.MAC.122, 27-Apr-79 14:44:24, EDIT BY OSMAN
;Catch error on ADBRK for 2020
;<4.EXEC>EXECIN.MAC.121,  5-Apr-79 06:59:58, EDIT BY R.ACE
;FIX INFO VOLUMES TO DISPLAY SCRATCH TAPES CORRECTLY
;<4.EXEC>EXECIN.MAC.120, 29-Mar-79 15:19:25, EDIT BY OSMAN
;DON'T BOMB ON LARGE MEMORY MAPS.  PRINT WARNING AND PARTIAL MAP
;<4.EXEC>EXECIN.MAC.119, 21-Mar-79 10:22:59, EDIT BY OSMAN
;TCO 4.2220 - DON'T KEEL OVER ON INFO MEM IF PAGE IS MAPPED TO RESTRICTED JFN
;<4.EXEC>EXECIN.MAC.118, 14-Mar-79 07:39:58, EDIT BY R.ACE
;CHANGE NOISE ON INFO VOLUMES
;<4.EXEC>EXECIN.MAC.117, 12-Mar-79 17:59:38, EDIT BY KONEN
;UPDATE COPYRIGHT FOR RELEASE 4
;<4.EXEC>EXECIN.MAC.116,  7-Mar-79 13:27:35, EDIT BY OSMAN
;ADD DREGS REPORT IF CLASS SCHEDULING IS OFF
;<4.EXEC>EXECIN.MAC.115,  7-Mar-79 12:47:26, EDIT BY R.ACE
;ADD TAPE-DRIVE ALLOCATION TO INFO SYSTEM-STATUS COMMAND
;<4.EXEC>EXECIN.MAC.114,  5-Mar-79 15:25:49, EDIT BY HURLEY.CALVIN
; Fix INFO ARC NUL: bug
;<4.EXEC>EXECIN.MAC.110,  2-Mar-79 15:30:44, EDIT BY OSMAN
;TYPE CLASS SCHEDULER STUFF UNDER "INFO SYSTEM-STATUS"
;<4.EXEC>EXECIN.MAC.109, 28-Feb-79 10:32:28, EDIT BY OSMAN
;REMOVE REFS TO CTYPE (USE ETYPE INSTEAD)
;<4.EXEC>EXECIN.MAC.108, 27-Feb-79 15:56:13, EDIT BY OSMAN
;CHANGE CCHRO TO COUTC
;<4.EXEC>EXECIN.MAC.107, 12-Feb-79 14:08:46, EDIT BY HURLEY.CALVIN
; CHANGE BITS FOR SPECFN IN .ARSTS SO TRAILING "," DOESN'T SCREWUP
;<4.EXEC>EXECIN.MAC.106,  8-Feb-79 16:36:51, EDIT BY OSMAN
;ADD INFO DEF PLOT
;<4.EXEC>EXECIN.MAC.105,  7-Feb-79 10:42:06, EDIT BY OSMAN
;HANDLE FAILURE FROM GETNOD
;<HURLEY.CALVIN>EXECIN.MAC.1,  1-Feb-79 13:22:16, EDIT BY HURLEY.CALVIN
; Cause INFO ARCHIVE-STATUS to not print "None" files, find invisible
; ones, and default to * for extension
;<4.EXEC>EXECIN.MAC.101, 30-Jan-79 16:35:19, EDIT BY OSMAN
;ADD LA38, LA120
;<4.EXEC>EXECIN.MAC.100, 26-Jan-79 15:32:00, EDIT BY OSMAN
;keep all guide words UPPERCASE
;<4.EXEC>EXECIN.MAC.98, 26-Jan-79 13:46:30, EDIT BY OSMAN
;CHANGE INFO STR TO REFER TO MOUNT INSTEAD OF SMOUNT
;<4.EXEC>EXECIN.MAC.96, 26-Jan-79 13:41:43, EDIT BY OSMAN
;don't let INFO MEM buffer overflow
;<4.EXEC>EXECIN.MAC.95, 25-Jan-79 17:03:42, EDIT BY R.ACE
;MAKE INFO VOLUMES CONFORM TO NEW GALAXY TEXT MESSAGE FORMAT
;<4.EXEC>EXECIN.MAC.90, 25-Jan-79 14:12:53, EDIT BY OSMAN
;tco 4.2172 - speed up INFO MEM
;<4.EXEC>EXECIN.MAC.89, 23-Jan-79 09:42:18, EDIT BY OSMAN
;CHANGE NODE OUTPUT FORMAT "INFO JOB"
;<4.EXEC>EXECIN.MAC.88, 15-Jan-79 02:42:30, EDIT BY HEMPHILL
;MAKE EXEC UNDERSTAND USER EXTENDED ADDRESSING FOR "SET ADDRESS-BREAK",
; "INFORMATION PROGRAM", ^T, "INFORMATION MEMORY-USAGE"

;<4.EXEC>EXECIN.MAC.87, 14-Jan-79 13:40:41, EDIT BY KIRSCHEN
;USE SYMBOL .NDBK1 IN INFO DECNET
;<4.EXEC>EXECIN.MAC.86,  3-Jan-79 10:40:38, EDIT BY OSMAN
;try another flavor of "info job"
;<4.EXEC>EXECIN.MAC.85, 20-Dec-78 15:47:27, EDIT BY HURLEY.CALVIN
; Add 1B17 to SPECFN bits in .ARSTS
;<4.EXEC>EXECIN.MAC.84, 20-Dec-78 07:16:02, EDIT BY R.ACE
;ADD INFORMATION (ABOUT) VOLUMES
;<4.EXEC>EXECIN.MAC.83, 18-Dec-78 16:43:25, EDIT BY OSMAN
;ONLY DISPLAY NODE ON INFO JOB IF DIFFERENT FROM HOST NODE NAME
;<4.EXEC>EXECIN.MAC.80,  5-Dec-78 13:05:33, EDIT BY OSMAN
;Make INFO SYSTEM-STATUS display scheduler bias-control
;<4.EXEC>EXECIN.MAC.79, 22-Nov-78 12:54:39, EDIT BY KIRSCHEN
;REMOVE INFO DECNET STATUS, MAKE INFO DECNET NODES DEFAULT
;<4.EXEC>EXECIN.MAC.78,  8-Nov-78 16:06:08, EDIT BY HEMPHILL
;ALLOW WILDCARDS IN HLP: DEFINITION TO WORK BY ADDING GJ%IFG AT
; HLP3
;<4.EXEC>EXECIN.MAC.77, 26-Oct-78 16:03:38, EDIT BY OSMAN
;REMOVE REFS TO GSSBLK (USE LOCAL ISBLK INSTEAD)
;<4.EXEC>EXECIN.MAC.76, 25-Oct-78 16:29:32, EDIT BY OSMAN
;PRINT OUT LOGICAL LOCATION IN JOBSTAT (.JOBST)
;<ARC-DEC>EXECIN.MAC.6, 11-Oct-78 12:31:07, EDIT BY CALVIN
; Add INFO RETRIEVE-REQUESTS
;[BBN-TENEXD]<CALVIN>EXECIN.MAC.1,  8-Aug-78 11:20:29, Ed: CALVIN
; Install code for INFO ARCHIVE-STATUS command
;<3-ARC-EXEC>EXECIN.MAC.2, 14-May-78 20:38:35, Edit by MTRAVERS
;<3-ARC-EXEC>EXECIN.MAC.1, 14-May-78 15:40:28, Edit by MTRAVERS
; Added INFO ARCHIVE-STATUS to command table
;<4.EXEC>EXECIN.MAC.74, 13-Oct-78 10:55:15, EDIT BY OSMAN
;ADD INFO MOUNT-REQUESTS
;<4.EXEC>EXECIN.MAC.73, 10-Oct-78 09:56:15, EDIT BY R.ACE
;FIX BUG IN MT DEVICE DISPLAY FIX
;<4.EXEC>EXECIN.MAC.72, 29-Sep-78 15:39:33, EDIT BY R.ACE
;Make INF AVAIL DEV ;<4.EXEC>EXECIN.MAC.71, 28-Sep-78 15:21:48, EDIT BY KIRSCHEN
;ADD TEST FOR ILLEGAL FUNCTION AT DNTOPE, ALSO MERELY RETURN
;<4.EXEC>EXECIN.MAC.70, 28-Sep-78 15:05:29, EDIT BY KIRSCHEN
;AVOID !DISABLED! IN INFO TERM AT WRONG TIME
;<4.EXEC>EXECIN.MAC.69, 28-Sep-78 14:54:11, EDIT BY KIRSCHEN
;REMOVE IFN CONDITIONAL FROM .DNSTS
;<4.EXEC>EXECIN.MAC.68, 27-Sep-78 20:19:51, EDIT BY OSMAN
;GET RID OF Bn SYMBOLS
;<4.EXEC>EXECIN.MAC.64, 16-Sep-78 00:01:02, EDIT BY OSMAN
;GET RID OF REFS TO CSBUFP
;<4.EXEC>EXECIN.MAC.60, 14-Sep-78 14:14:00, EDIT BY OSMAN
;ONLY SEARCH XDEF, TTITLE DOES REST
;<4.EXEC>EXECIN.MAC.59,  7-Sep-78 15:21:37, EDIT BY HELLIWELL
;<4.EXEC>EXECIN.MAC.58,  7-Sep-78 15:19:15, EDIT BY HELLIWELL
;<4.EXEC>EXECIN.MAC.57,  7-Sep-78 15:18:00, EDIT BY HELLIWELL
;ADD " !DISABLED!" AFTER "TERMINAL PAUSE (ON) END-OF-PAGE" IF "TERMINAL NO PAUSE (ON) COMMAND"
;<4.EXEC>EXECIN.MAC.56,  1-Sep-78 22:17:05, EDIT BY OSMAN
;PUT IN VT100 STUFF
;<4.EXEC>EXECIN.MAC.55, 28-Aug-78 19:12:24, EDIT BY HELLIWELL
;<4.EXEC>EXECIN.MAC.54, 28-Aug-78 19:04:19, EDIT BY HELLIWELL
;<4.EXEC>EXECIN.MAC.53, 28-Aug-78 18:55:49, EDIT BY HELLIWELL
;<4.EXEC>EXECIN.MAC.52, 28-Aug-78 18:53:07, EDIT BY HELLIWELL
;CHANGE "INFO TERMINAL" TO REFLECT "TERMINAL PAUSE"
;<4.EXEC>EXECIN.MAC.51, 25-Aug-78 17:05:05, EDIT BY HELLIWELL
;<4.EXEC>EXECIN.MAC.50, 24-Aug-78 16:22:38, EDIT BY HELLIWELL
;REFORMAT "INFO  DECNET NODES" TYPEOUT
;<4.EXEC>EXECIN.MAC.49, 23-Aug-78 11:48:32, EDIT BY HELLIWELL
;PLACE MANY NODE NAMES ON SAME LINE IN "INFO DECNET NODES"
;<4.EXEC>EXECIN.MAC.48, 23-Aug-78 08:12:26, EDIT BY KIRSCHEN
;FIX INFO DECNET NODES
;<4.EXEC>EXECIN.MAC.47, 21-Aug-78 16:47:56, EDIT BY HELLIWELL
;REMOVE "INFO EDITOR"
;<4.EXEC>EXECIN.MAC.46, 16-Aug-78 17:16:46, EDIT BY HELLIWELL
;<4.EXEC>EXECIN.MAC.45, 16-Aug-78 17:12:10, EDIT BY HELLIWELL
;<4.EXEC>EXECIN.MAC.44, 16-Aug-78 17:02:26, EDIT BY HELLIWELL
;<4.EXEC>EXECIN.MAC.43, 16-Aug-78 17:01:18, EDIT BY HELLIWELL
;<4.EXEC>EXECIN.MAC.42, 16-Aug-78 14:16:38, Edit by HELLIWELL
;<4.EXEC>EXECIN.MAC.41, 16-Aug-78 14:10:19, Edit by HELLIWELL
;<4.EXEC>EXECIN.MAC.40, 16-Aug-78 13:43:26, Edit by HELLIWELL
;CHANGE "INFO NETWORK-STATUS" TO "INFO ARPANET" AND "INFO DECNET"
;<4.EXEC>EXECIN.MAC.39, 16-Aug-78 11:34:43, EDIT BY OSMAN
;FIX "INFO LOG" (GETTER CLOBBERS B)
;<4.EXEC>EXECIN.MAC.38, 16-Aug-78 11:24:09, Edit by HELLIWELL
;<4.EXEC>EXECIN.MAC.37, 16-Aug-78 11:13:47, Edit by HELLIWELL
;<4.EXEC>EXECIN.MAC.36, 13-Aug-78 15:42:42, Edit by HELLIWELL
;<4.EXEC>EXECIN.MAC.35, 13-Aug-78 15:36:26, Edit by HELLIWELL
;<4.EXEC>EXECIN.MAC.34, 13-Aug-78 14:55:02, Edit by HELLIWELL
;<4.EXEC>EXECIN.MAC.33, 13-Aug-78 14:50:48, Edit by HELLIWELL
;ADD "INFO EDITOR"
;<4.EXEC>EXECIN.MAC.32, 10-Aug-78 11:28:39, EDIT BY OSMAN
;ALLOW WILDCARDING ON INFO DISK
;<4.EXEC>EXECIN.MAC.25, 28-Jul-78 13:50:21, EDIT BY OSMAN
;CHANGE "COMPILER-SWITCHES" TO "COMPILE-SWITCHES"
;<4.EXEC>EXECIN.MAC.22, 27-Jul-78 15:39:08, EDIT BY OSMAN
;<4.EXEC>EXECIN.MAC.21, 27-Jul-78 14:41:37, EDIT BY OSMAN
;allow "info logical-name foo:"
;<4.EXEC>EXECIN.MAC.20, 18-Jul-78 17:18:36, EDIT BY OSMAN
;MAKE HELP COMMAND SET UP Q1, AND CALL GTJFS
;<4.EXEC>EXECIN.MAC.19, 13-Jul-78 14:44:44, EDIT BY OSMAN
;CHANGE TAG DSKCN1 TO 0
;<4.EXEC>EXECIN.MAC.18, 13-Jul-78 14:33:48, EDIT BY OSMAN
;MAKE SIZCN1, SIZCN2, PAGFL1, PAGFL2 BE LOCAL (DSKCN1, ...)
;<4.EXEC>EXECIN.MAC.17, 11-Jul-78 16:21:40, EDIT BY OSMAN
;MAKE INFO LOGICAL NAMES AND INFO MAIL USE LOCAL VARIABLES
;<4.EXEC>EXECIN.MAC.16, 29-Jun-78 15:29:39, EDIT BY OSMAN
;make "alias" part of trvar
;<4.EXEC>EXECIN.MAC.15, 27-Jun-78 16:09:57, EDIT BY OSMAN
;CHANGE ALL THE GTB'S TO BE IMMEDIATE
;<4.EXEC>EXECIN.MAC.14, 23-Jun-78 21:26:42, EDIT BY OSMAN
;REMOVE UNREFERENCED SYMBOLS: CHKDLX, MMAP, .TE
;<4.EXEC>EXECIN.MAC.13, 14-Jun-78 14:53:19, EDIT BY OSMAN
;ADD INFO DEFAULTS
;<4.EXEC>EXECIN.MAC.11,  9-Jun-78 18:08:15, EDIT BY OSMAN
;CHANGE CALLS TO FIELD TO FLDSKP
;<3-EXEC-SNARK>EXECIN.MAC.50, 20-Apr-78 11:22:28, Edit by FORTMILLER
;<4.EXEC>EXECIN.MAC.9, 17-Jan-78 10:13:30, EDIT BY HELLIWELL
;RELEASE JFNS AFTER DSKCNT IN INFO DISK COMMAND
;<4.EXEC>EXECIN.MAC.8,  6-Jan-78 17:06:56, EDIT BY HELLIWELL
;<4.EXEC>EXECIN.MAC.7,  6-Jan-78 17:04:15, EDIT BY HELLIWELL
;<4.EXEC>EXECIN.MAC.6,  6-Jan-78 17:02:00, EDIT BY HELLIWELL
;<4.EXEC>EXECIN.MAC.5,  6-Jan-78 16:53:38, EDIT BY HELLIWELL
;<4.EXEC>EXECIN.MAC.4,  6-Jan-78 16:48:02, EDIT BY HELLIWELL
;<4.EXEC>EXECIN.MAC.3,  6-Jan-78 16:47:19, EDIT BY HELLIWELL
;<4.EXEC>EXECIN.MAC.2,  6-Jan-78 16:30:23, EDIT BY HELLIWELL
;<4.EXEC>EXECIN.MAC.1,  6-Jan-78 16:15:43, EDIT BY HELLIWELL
;MAKE INFO DISK DO * & %

;TOPS20 'EXECUTIVE' COMMAND LANGUAGE

;THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY ONLY BE USED
;  OR COPIED IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
;COPYRIGHT (C) 1980,1981,1982 BY DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.

	SEARCH EXECDE
	TTITLE EXECIN
	GLXSCH			;SEARCH GALAXY UNV'S
CC,<	SEARCH FNGUNV>		;CM113 Get "I account" definitions
	SEARCH HKTBLD		;CM363 Get "Help" keyword table definitions

;THIS FILE CONTAINS
;INFORMATION COMMANDS
;EXCEPT INFORMATION (ABOUT) BATCH-REQUESTS AND
;INFORMATION (ABOUT) OUTPUT-REQUESTS, WHICH ARE IN EXECQU.MAC

;PRINT STATUS (IN TERMS OF THE ARCHIVE) OF FILES

.ARSTS::NOISE <OF FILES>
	TXO Z,IGINV		;FIND INVISIBLE ONES TO BOOT
	MOVE A,[XWD [ASCIZ /*/],[ASCIZ /*/]] ;DEFAULT NAME & EXT IS *
	HRLI B,-3		;DEFAULT VERSION IS *
	HRRI B,(GJ%OLD+GJ%IFG+GJ%NS+1B15+1B16+CF%NS)
	CALL SPECFN
	 JRST CERR		;NO "STUFF,"
	SETOM TYPGRP		;ALWAYS TYPE NAME
	MOVE A,COJFN
	MOVEM A,OUTDSG
	MOVE A,JBUFP
	MOVEM A,.JBUFP
ARSTS3:	CALL RLJFNS
	CALL NXFILE
	 JRST ARSTS4
	CALL MFINP		;GET 2ND JFN
	 JRST ARSTS4		;FAILED
	CALL ARSTS		;PRINT STATUS
ARSTS4:	SKIPE INIFH1		;DONE THEM ALL?
	JRST ARSTS3		;NO, LOOP
	RET

ARSTS::	TLZ Z,F2		;COMMA FLAG
	MOVE B,[1,,.FBCTL]
	MOVEI C,D
	GTFDB
	 ERJMP [HRROI B,[ASCIZ / Tape information not available/]
		CALL ARPNT
		RET]
	MOVE B,[1,,.FBBBT]
	MOVEI C,C
	GTFDB
	EXCH C,D		;SWAP 'EM
	TXNN C,FB%ARC		;FILE HAVE ARCHIVE STATUS?
	JRST ARSTS1		;NO
	HRROI B,[ASCIZ / Archive status is not valid/]
	TXNE D,AR%1ST
	CALL ARPNT
	HRROI B,[ASCIZ / Archived/]
	TXNE D,AR%RAR		;REQUEST TOO? (ARCHIVE IN PROGRESS?)
	HRROI B,[ASCIZ / Archive in progress/]
	TXNN D,AR%1ST
	CALL ARPNT
	HRROI B,[ASCIZ / Migration requested/]
	TXNE D,AR%RIV
	CALL ARPNT
NONE:	TLOE Z,F2		;PRINT ANYTHING?
	TYPE <
>				;YES, END WITH CRLF
	RET

ARSTS1:	TXNN D,AR%RAR+AR%EXM+AR%RIV ;ANYTHING WE'VE AN INTEREST IN?
	JRST NONE		;NO
	HRROI B,[ASCIZ / Archive requested/]
	TXNE D,AR%RAR
	CALL ARPNT
	HRROI B,[ASCIZ / Retain contents/]
	TXNE D,AR%NDL
	CALL ARPNT
	HRROI B,[ASCIZ / Migration prohibited/]
	TXNE D,AR%EXM
	CALL ARPNT
	HRROI B,[ASCIZ / Migration requested/]
	TXNE D,AR%RIV
	CALL ARPNT
	JRST NONE

ARPNT:	TLON Z,F2		;NEED <COMMA><SPACE>?
	JRST [	ETYPE < %1S>	;PRINT THE FILE NAME
		JRST .+2]	;AND DON'T DO THE COMMA
	TYPE <, >
	UTYPE 0(B)		;TYPE THE STRING
	RET

.AVAIL::KEYWD $AVAIL
	 T DEVICES,		;[TAH] CHANGE DEFAULT TO DEVICES
	 JRST CERR
				;CAN'T CONFIRM HERE BECAUSE OF FUDGE-ENTRIES IN TABLE
	JRST (P3)

$AVAIL:	TABLE
	T DEVICES,
	T LINES,,..TERM
	TA T			;"T" = "TERMINALS"
	T TELETYPES,,..TERM,CM%INV
.T:
.TE:
	T TERMINALS,,..TERM,CM%INV
	T TTYS,,..TERM,CM%INV
	TEND

;AVAILABLE TERMINALS

..TERM::CONFIRM
	HLLZ D,TTYJOB		;SET UP NUMBER OF TERMINAL LINES
TERMI1:	HRRZI A,.TTDES(D)	;TERMINAL DESIGNATOR
	DVCHR			;GET ITS STATUS
	TXNN B,DV%AV		;IS IT AVAILABLE
	JRST TERMI9		;NO - TRY NEXT
	CALL BEFORE		;TYPE COMMA OR MAYBE EOL
	HRRZ B,D
	CALL TOCT		;TYPE LINE NUMBER

;SEE IF SEVERAL CONSECUTIVE LINES TO BE GROUPED, E.G. 21-26

	PUSH P,D		;SAVE ONE JUST TYPED
	AOBJN D,TERMI7		;PEEK AT NEXT ONE
	POP P,D			;NO MORE, WRAP UP
	JRST TERMI9

TERMI7:	HRRZI A,.TTDES(D)	;FORM TERM DESIGNATOR
	DVCHR			;GET CHARACTERISTICS
	TXNE B,DV%AV		;AVAILABLE?
	AOBJN D,TERMI7		;YES, KEEP LOOKING
	POP P,C			;FOUND NOT AVAIL OR AND OF LIST
	SUB D,[1,,1]		;GET BACK TO LAST AVAIL ONE FOUND
	CAMN D,C		;SAME AS LAST ONE PRINTED?
	JRST TERMI9		;YES, NO GROUPING TO BE DONE
	PRINT "-"		;FIRST OF GROUP HAS BEEN PRINTED, NOW
	HRRZ B,D		; PRINT DASH AND LAST OF GROUP
	CALL TOCT
TERMI9:	AOBJN D,TERMI1
	TLNN Z,F1
	TYPE < All lines in use>
EOLRET::ETYPE <%_>		;COME HERE TO TYPE CRLF AND POPJ.
	RET

;AVAILABLE DEVICES
;DOES NOT LIST TTYS
;ALSO LISTS SEPERATELY DEVICES ALREADY ASSIGNED TO THIS JOB.

.DEVIC::CONFIRM
	TLZ Z,F1+F2		;SAY NOTHING TYPED YET
	MOVEI P3,-3		;SAY NO PREVIOUS GROUP ITEM
	MOVEI Q1,0		;LAST DEVICE NAME PRINTED

;"DEVLUP" EXECUTES CALLER+1 FOR EACH DEVICE, WITH NAME IN A,
;DVCHR WORD IN B.

	CALL DEVLUP
	 CALL DEVIC1		;DO THIS FOR EACH DEVICE
	TLZE Z,F2		;GROUP STARTED?
	CALL AVD1		;YES, FINISH IT
	TLNN Z,F1
	TYPE <No devices currently available to this job>
	ETYPE <%_>
	JRST ASTTJ		;LIST DEVS ASSIGNED TO THIS JOB. WITH FILSTAT.

DEVIC1:	STKVAR <DEISO,DENAME,DECHR>
	MOVEM A,DENAME		;SAVE NAME
	MOVEM B,DECHR		;SAVE CHARACTERISTICS
	TXNN B,DV%AV		;SKIP IF DEVICE AVAILABLE TO THIS JOB
	RET
	LDB C,[POINT 9,B,17]	;GET DEVICE TYPE
	CAIN C,.DVTTY		;SKIP TTYS
	RET
	CAIN C,.DVFE		;CM238 FE device?
	RET			;CM238 The flag is misleading
	AND B,[DV%TYP!777777]	;MASK TO JUST DEVICE TYPE AND UNIT #
	CAIN C,.DVDSK		;A MOUNTABLE STRUCTURE (DISK)?
	JRST DEVIC9		;YES, ALWAYS SEPERATE
	CALL ISONAM		;ISOLATE THE NAME OF THIS DEVICE
	MOVEM A,DEISO		;REMEMBER ISOLATED NAME
	MOVE A,Q1		;GET PREVIOUS DEVICE NAME
	CALL ISONAM		;ISOLATE ITS NAME TOO
	CAME A,DEISO		;ARE WE ON SUBSEQUENT UNIT OF SAME DEVICE?
	JRST DEVIC9		;NO, CAN'T POSSIBLY BE IN SEQUENCE
				;WHY ALL THE BRUHAHA, YOU MUST ASK!
				;WELL AT THIS TIME (10/26/76), PPLT0:
				;AND PLT0: ETC. YIELD EXACT SAME
				;DEVICE DESIGNATOR
	MOVE C,P3		;SEE IF DEVICE IS NEXT IN SEQUENCE
	HRRI C,1(C)		;18BIT ADD
	CAMN C,DECHR		;NEXT UNIT OF SAME DEVICE?
	JRST [	TLO Z,F2	;YES, NOTE GROUP BEING PROCESSED
		MOVE P3,DECHR	;UPDATE UNIT NUMBER
		MOVE Q1,DENAME	;REMEMBER NEW LAST NAME
		RET]
DEVIC9:	TLZE Z,F2		;NOT IN SEQUENCE, PREVIOUS SEQUENCE?
	CALL AVD1		;YES, FINISH IT
	MOVE P3,DECHR		;REMEMBER LAST DEVICE PRINTED
	MOVE Q1,DENAME		;REMEMBER NAME PRINTED
	TLNN Z,F1		;FIRST ONE?
	TYPE <Devices available to this job:
>
	CALL BEFORE		;DO SEPARATING CHARACTER
	MOVE A,DENAME
	CALLRET SIXPRT		;PRINT NAME AND RETURN

;ISONAM takes a SIXBIT device name, and right-justifies it without its
;unit number.
;
;Accepts:	A/	SIXBIT name, like LPT34
;
;Returns+1:	A/	name only, like LPT

ISONAM:	LDB B,[360600,,A]	;GET FIRST CHARACTER
	CAIL B,'0'		;DOES NAME START WITH A DIGIT?
	CAILE B,'7'
	CAIA			;NO
	RET			;YES, SO ASSUME NO UNIT NUMBER
ISO1:	LSHC A,-6		;GET RIGHTMOST CHARACTER INTO B
	LSH B,-<44-6>		;ISOLATE THE CHARACTER
	JUMPE B,ISO1		;IF SPACE, WE'RE ON TRAILING SPACES OF SHORT NAME
	CAIL B,'0'		;ON UNIT NUMBER?
	CAILE B,'7'
	CAIA			;NO
	JRST ISO1		;YES, KEEP SHIFTING
	LSH A,6			;WE WENT ONE CHARACTER TOO FAR, FIX IT
	IOR A,B
	RET

AVD1:	PUSH P,B
	MOVEI B,"-"		;FINISH UP GROUP
	CALL COUTC
	MOVE B,P3		;GET LAST DEVICE DESIGNATOR
	TLC B,.DVMTA
	TLZN B,777777		;MAGTAPE DEVICE?
	TRZ B,400000		;YES, CLEAR B18 IN CASE IT'S AN MT
	CALL TOCT		;PRINT IT
	POP P,B
	RET

;SUBROUTINE FOR FORMATTING A LIST OF ITEMS SEVERAL TO A LINE.
;USED FOR AVAILABLE TERMINALS, AVAILABLE DEVICES, AND FILSTAT.
;BEFORE EACH ITEM: COMMA EXCEPT CRLF IF TOO FAR TO RIGHT.

;CALL WITH F2 ON IN AC Z TO GET A TAB BETWEEN ITEMS, OFF TO GET A SPACE

BEFORE::ATSAVE
	MOVE A,COJFN
	MOVEI B,.MORLW
	MOVEI C,^D72		;USE 72 COLUMNS IF NOT A TERMINAL
	MTOPR			;GET LINE WIDTH
	 ERJMP .+1		;IF NOT, USE 72 (PRESUMABLY NOT A TERMINAL)
	RFPOS
	MOVEI B,(B)		;MASK COLUMN POSITION
	CAIL B,-11(C)		;WITHIN 9 CHARS OF END OF LINE?
	JRST BEFOR1		;YES, START NEW LINE AND RETURN
	TLNE Z,F2		;WANT A TAB BETWEEN ENTRIES?
	JRST BEFOR0		;YES - GO DO IT
	TLOE Z,F1		;NO - FOR FIRST ENTRY JUST OUTPUT A SPACE
	PRINT ","		;ELSE OUTPUT A COMMA AND SPACE
	PRINT " "
	RET

BEFOR0:	PRINT 11		;PRINT A TAB BETWEEN ENTRIES
	RET

BEFOR1:	TLNN Z,F2		;PUTTING A TAB BETWEEN ENTRIES?
	PRINT ","		;NO - END LINE WITH A COMMA
	ETYPE <%_ >		;EITHER WAY, START A NEW LINE
	RET

;SUBROUTINE TO LOOP OVER ALL DEVICES FOR "AVAIL DEVICES" AND "FILSTAT".
;FOR EACH DEVICE, EXECUTES LOCATION AFTER CALL WITH SIXBIT NAME IN A
;    DEVICE CHARACTERISTICS WORD IN LH B
;    UNIT NUMBER IN RH OF B
;    -1 OR JOB # ASSIGNED TO IN C.
;	DEVICE DESIGNATOR IN D
;RETURNS +2.
;DESTROYS A, B, C, D.

DEVLUP::SETO D,
	GTB .DEVNA		;GET # DEVICES FROM TABLE 6
	HRLZ D,A		;XWD AOBJN COUNT, TABLE INDEX
DEVL1:	PUSH P,D
	CALL .DVCHR		;GET DEVICE CHARACTERISTICS
	 JRST DEVL2		;SKIP THIS ONE IF UNKNOWN DEVICE
	MOVE D,A		;GIVE GUY DEVICE DESIGNATOR IN D
	HRR B,C			;GET UNIT NUMBER
	HLRE C,C
	EXCH D,(P)		;SAVE DESIGNATOR, GET INDEX INTO DEVICE TABLE
	GTB .DEVNA		;GET DEVICE NAME IN SIXBIT FROM TABLE 6
	EXCH D,(P)		;SAVE INDEX, GET DESIGNATOR
	JUMPE A,DEVL2		;SKIP NULL ENTRIES
	XCT @-1(P)
DEVL2:	POP P,D
	AOBJN D,DEVL1
	RETSKP

;TYPE SIXBIT SYMBOL FROM A.
;USED IN "AVAILABLE DEVICES", "SYSTAT", "STATISTICS", AND "FILSTAT".

;TYPE SIXBIT SYMBOL FROM A.
;USED IN "AVAILABLE DEVICES", "SYSTAT", "STATISTICS", AND "FILSTAT".

;EM13 *** Begin *** Redo to support casification

SIXPRT::ATSAVE
	MOVE C,A
	MOVE D,[TRNA]		;If not casifying
	SKIPN CASFLG
	 MOVE D,[CAIL B,"A"]	;If casifying
	SETZ B,
	LSHC B,6		;Do first character specially
	ADDI B,40
	CALL COUTC
	DO.
	  JUMPE C,ENDLP.	;If at end...
	  SETZ B,
	  LSHC B,6		;Next character
	  ADDI B,40		;Make ASCII
	  XCT D			;Check bounds (or skip always, if no casify) 
	  CAILE B,"Z"
	  TRNA
	  ADDI B,"a"-"A"	;Shift to lower case
	  CALL COUTC		;Print it
	  LOOP.			;Go back for more
	ENDDO.
	RET

;EM13 *** End ***

;THIS ROUTINE TAKES DEVICE INDEX IN D AND DOES DVCHR, RETURNING
;DVCHR'S INFO IN A,B,C.  NOTHING ELSE IS CHANGED.
;RETURNS:
;	+1:	NO SUCH DEVICE
;	+2:	SUCCESS

.DVCHR:	PUSH P,P1		;WE'LL NEED THESE, BUT DON'T HURT THEM
	PUSH P,P2
	GTB .DEVNA		;GET SIXBIT NAME INTO A
	MOVE B,[440600,,A]	;PREPARE TO READ THE SIXBIT NAME FROM A
DV1:	TLNN B,770000		;ARE WE DONE?
	JRST DV2		;YES, GO LEFT-JUSTIFY
	ILDB C,B		;GET SIXBIT CHARACTER FROM NAME
	CAIE C,0		;LEAVE 0'S AS 0'S!
	ADDI C,"A"-'A'		;CHANGE TO ASCII
	LSHC P1,7		;MAKE ROOM FOR THE CHARACTER
	IOR P2,C		;PUT IN THE CHARACTER
	JRST DV1		;GO DO NEXT CHARACTER
DV2:	LSHC P1,2*^D36-6*7-1	;LEFT JUSTIFY
	LSH P1,1		;^D36=1(MOD 5*7)
	HRROI A,P1		;POINT TO THE ASCII NAME OF THE DEVICE
	STDEV			;GET A DEVICE DESIGNATOR FOR THIS DEVICE
	 ERJMP DEVOUT		;JUST RETURN IF CAN'T
	MOVE A,B		;PUT DESIGNATOR IN A
	DVCHR			;GET CHARACTERISTICS
	AOS -2(P)		;WE WANT TO SKIP RETURN
DEVOUT:	POP P,P2
	POP P,P1
	RET

;HELP *, HELP <CR>, HELP FOO

.HELP::	STKVAR <<HLPBUF,FILWDS>,HITEM,<NFLDDB,.CMBRK+1>> ;CM201
	NOISE (ON SUBJECT)
	CALL MAKLST		;MAKE LIST OF THINGS THERE'S HELP ON
	MOVEI B,[FLDDB. .CMKEY,,$HELP.,<
To learn about a particular topic, type "HELP topic".  The topic
may be any one of:
>,,[
		 FLDDB. .CMCFM,,,,,]] ;CM201 Improve help message
	SETZ Q2,		;CM201 Flag from "Help"
	JRST HLPNWS		;CM201
.NEWS::	STKVAR <<HLPBUF,FILWDS>,HITEM,<NFLDDB,.CMBRK+1>> ;CM201
	SETO Q2,		;CM201 News
	NOISE (ARTICLE NUMBER)	;CM201
	CALL NWSLST		;CM201 Get news help
	MOVSI B,[FLDDB. .CMNUM,CM%SDH!CM%HPP,^D10,,,[
		 FLDDB. .CMCFM,CM%SDH,,,,]] ;CM201
	HRRI B,NFLDDB		;CM201
	BLT B,.CMBRK+NFLDDB	;CM201 Copy FLDDB into writeable storage
	MOVEM A,.CMHLP+NFLDDB	;CM201 Store help text pointer
	MOVEI B,NFLDDB		;CM201 Get pointer to FLDDB
HLPNWS:				;CM201 "Help" joins here
	CALL FLDSKP		;GET SOME INPUT
;**;[729]	Insert label at .HELP+6L	KR	29-APR-82
HLPERR:				;CM201 [729]INSERT LABEL
	 JRST [	SKIPE Q2	;CM201 Select message
		ERROR <Invalid NEWS request, try "NEWS<RET>"> ;CM201
		ERROR <Invalid HELP request, try "HELP<RET>">] ;CM236
	LDB C,[331100,,.CMFNP(C)]	;SEE WHAT GOT TYPED
	CAIN C,.CMCFM		;CR?
	JRST BLURB		;YES, GO TYPE GENERAL HELP BLURB
;**;[729]	Change 1 line at .HELP:+9L	KR	29-APR-82
	CONFIRM			;CS112 [729]DELAY CONFIRMATION TILL AFTER FIX

NOCMU,<				;TCO#4.2475
	CAIN C,.CMTOK		;*?
	JRST TYPLST		;YES, TYPE OUT THE LIST
>

	MOVEM B,HITEM		;SAVE POINTER TO ITEM HELP DESIRED ABOUT
NOCMU,<				;CS112 CS thinks this is bogus...
	SKIPE Q2		;CM201 "Help"?
	 JRST HLPCNF		;CM201 No, so skip this stuff
;**;[729]	Insert 9 lines at .HELP:+20L	KR	29-APR-82
	TXNE A,CM%ESC		;[729]WAS KEYWORD EXPLICITLY COMPLETED?
	JRST HLPCNF		;[729]YES, SKIP CHECK
	HLRZ B,(B)		;[729]CONSTRUCT BYTE POINTER TO KEYWORD NAME
	HRLI B,440700		;[729]
	MOVE A,SBLOCK+.CMABP	;[729]LOAD BYTE POINTER TO KEYWORD INPUT
	STCMP			;[729]COMPARE STRINGS
	TXNE A,SC%SUB		;[729]WAS A SUBSTRING INPUT?
	JRST HLPERR		;[729]YES, GIVE ERROR MESSAGE
HLPCNF:	CONFIRM			;[729]MOVE CONFIRM TO HERE
>;NOCMU				;CS112
	HRROI A,HLPBUF		;PREPARE TO CREATE FILENAME STRING
	HRROI B,[ASCIZ /HLP:/]
	MOVEI C,0		;WE WANT NULL AFTER FILENAME
	SOUT			;PUT IN DEVICE NAME
	JUMPE Q2,HLP6		;CM201 Take the easy way for HELP
	HRROI B,[ASCIZ/NEW/]	;CM201 Put in file name
	SOUT%			;CM201
	MOVE B,HITEM		;CM201 Get back number
	MOVX C,NO%LFL!NO%ZRO!NO%OOV!FLD(3,NO%COL)!FLD(^D10,NO%RDX) ;CM201
	NOUT%			;CM201 Output in three columns
	 ERJMP .+1		;CM201
	HRROI B,[ASCIZ/.NWS/]	;CM201 Get proper extension
	JRST HLP4		;CM201
HLP6:				;CM201 "Help" continues here
	MOVE B,HITEM		;GET POINTER TO FILENAME STRING
	HLRO B,(B)		;MAKE BYTE POINTER
	SOUT			;PUT IN FILENAME
	HRROI B,[ASCIZ /.HLP/]	;NOW WE'LL HAVE HLP:MUMBLE.HLP
HLP4:				;CM201 "News" rejoins "Help" here
	SOUT
	HRROI B,HLPBUF		;POINTER TO FILENAME
HLP3:	MOVX A,GJ%OLD+GJ%SHT+GJ%IFG ;OLD FILE ONLY, SHORT FORM
	CALL GTJFS		;GET HANDLE ON HELP FILE
	IFSKP.			;CM363
	  JRST HLP2		;CM363 If succeeded, go on
	ENDIF.			;CM363
	MOVX A,GJ%OLD+GJ%SHT+GJ%IFG+GJ%PHY ;CM363 Try system defn of "HLP:"
	HRROI B,HLPBUF		;CM363 ...
	CALL GTJFS		;CM363 ...
	IFSKP.			;CM363
	  JRST HLP2		;CM363 If succeeded, go on
	ENDIF.			;CM363
	SKIPE Q2		;CM201 Which was it?
	 ERROR <No such news item> ;CM201
	ERROR <No help available on that subject> ;CM201

HLP2:	SETO A,			;CM363 Unmap any mapped files
	MOVE B,[.FHSLF,,TABBUF/1000] ;CM363
	MOVX C,PM%CNT+TABSIZ	;CM363
	PMAP%			;CM363
HLPTYP:				;CM356 "Info DECnet description" enters here
	MOVEI Q1,CP%HEL		;SO "TYPE" LOGIC WILL KNOW IT'S US
	MOVE A,JBUFP		;GET POINTER TO JFN CELL
	HRRZM A,INIFH1
	HRRZM A,INIFH2		;COPY CODE NEEDS THIS
	JRST TYPE1		;FINISH COMMAND BY COPYING HELP FILE TO TERMINAL

;HELP<CR> JUST TYPES OUT "HLP:HELP.HLP"

BLURB:	HRROI B,[ASCIZ /HLP:HELP.HLP/]
	SKIPE Q2		;CM201 "Help"?
	 HRROI B,[ASCIZ /HLP:NEWS.HLP/]	;CM201 No, "News"
	JRST HLP3		;GO TYPE OUT CONTENTS OF FILE

;HELP * LISTS ALL SUBJECTS FOR WHICH HELP IS AVAILABLE

REPEAT 0,<			;TCO#4.2475
TYPLST:	HLRZ Q1,$HELP.		;GET NUMBER OF ENTRIES FOR WHICH THERE'S HELP
	JUMPE Q1,NOHELP		;SPECIAL CASE IF NONE
	TYPE <Help is available on these subjects:
>
	MOVEI Q2,0		;KEEPS TRACK OF HOW MANY ITEMS WE'VE PRINTED ON THIS LINE
	MOVN Q1,Q1
	HRLZ Q1,Q1		;MAKE AOBJN POINTER
LST1:	TRNN Q2,7		;ENOUGH ITEMS BEEN PRINTED YET?
	ETYPE <%_>		;YES, START NEW LINE
	HLRO A, $HELP.+1(Q1)	;GET ASCII POINTER TO ENTRY
	ETYPE <%1M	>	;TYPE ENTRY WITH TAB AFTER IT
	AOJ Q2,			;COUNT ITEMS ON LINE
	AOBJN Q1,LST1		;LOOP FOR REST OF ITEMS
	ETYPE <%_>		;FINISH WITH CARRIAGE RETURN
	JRST ENDHLP		;DONE
				;CM236 Move end of repeat 0 further down
NOHELP:	TYPE <No help available
>
	JRST ENDHLP

;DONE DOING HELP COMMAND, CLEAN UP AND RETURN

ENDHLP:	RET			;RETURN

> ;CM236 end REPEAT 0

;SPECIAL BUFFER ASSIGNMENTS FOR HELP COMMAND

$HELP.==BUF0			;TABLE OF HELP CATEGORIES
HLPLEN==BUF1-BUF0-1		;MAXIMUM NUMBER OF SUBJECTS AVAILABLE
TABBUF==MAPBUF			;CM363 Buffer for mapping keyword table file
TABSIZ==MAPSIZ			;CM363 Size of that buffer

;*** CM363 Begin modification ***

;ROUTINE TO MAKE LIST OF SUBJECTS THERE'S HELP ON.  THE LIST IS
;GENERATED BY THE FILENAMES OF ALL THE .HLP FILES ON THE HLP:
;DEVICE.

DEFINE HERROR(MSG) <
   CS,<ERROR <MSG - please report this error to GRIPE>>
   CC,<ERROR <MSG - please report this error to Remarks>>
   >

DEFINE HETYPE(MSG) <
   CS,<ETYPE <MSG - please report this to GRIPE%_>>
   CC,<ETYPE <MSG - please report this to Remarks%_>>
   >

MAKLST:	SKIPN CUSRNO		;CS90 Not logged in?
	SKIPN NLIACC		;CS90 And restricted?
	IFSKP.			;CS90 Use special table...
	  MOVX A,<2,,2>		;CS90 HKT header
	  MOVX B,<TABBUF,,0>	;CS90 EXPIRE entry
	  DMOVEM A,$HELP.	;CS90 Set up simple TBLUK table
	  MOVX B,<TABBUF+2,,0>	;CS90 LOGIN entry
	  MOVEM B,$HELP.+2	;CS90
	  DMOVE A,[ASCIZ/Expire/] ;CS90 Essential commands...
	  DMOVEM A,TABBUF	;CS90 Put string into expected address
	  DMOVE A,[ASCIZ/Login/] ;CS90
	  DMOVEM A,TABBUF+2	;CS90
	  RET			;CS90 Done.
	ENDIF.
	HRROI B,[HKTFIL]
	CALL TRYGTJ		;Get a JFN on the help keyword tables
	 HERROR <Help keywords not found>
	MOVX B,OF%RD
	OPENF%			;Open it
	 HERROR <Can't open help keywords>
	MOVE B,[1,,.FBBYV]	;Read the size of the file in pages
	MOVX C,C		;Place result in AC3
	GTFDB%			;Read the info
	LOAD C,FB%PGC,C		;Get the size in pages
	SKIPG C			;Size is positive?
	 HERROR <Help keywords are empty>
	CAILE C,TABSIZ		;Size small enough to fit in our buffer?
	 HERROR <Help keywords too big>
	HRLZS A			;Make JFN,,0
	MOVE B,[.FHSLF,,TABBUF/1000] ;Map into TABBUF
	TXO C,PM%CNT!PM%RD!PM%CPY!PM%PLD	
	PMAP%			;Read in the file
	MOVE A,TABBUF+.HTOFF	;Get (relative) address of mapped "Help" table
	ADDI A,TABBUF		;Make address absolute
	HLRZ D,0(A)		;Get number of topics
	CAIG D,HLPLEN		;Small enough?
	IFSKP.			;No
	  HETYPE <%@%%Help topic buffer exceeded>
	  MOVX D,HLPLEN		;Warn and fit in as many as we can
	ENDIF.
	HRRM D,$HELP.		;Set table max size
	HRLM D,$HELP.		;Set table actual size
	JUMPE D,MAKLS2		;If no entries, we're done
	MOVNS D			;Get -number of entries
	HRLZ D,D		;Put it in left half
	HRRI D,$HELP.+1		;Make AOBJN pointer to table we're building
	DO.
	  AOS A			;Point at next entry
	  MOVE B,(A)		;Get entry
	  ADD B,[TABBUF,,0]	;Convert relative string address to absolute
	  MOVEM B,(D)		;Put it where "Help" will find it
	  AOBJN D,TOP.		;Loop if more to do
	OD.
MAKLS2:	RET			;Done

;*** CM363 end modification ***

;*** CM201 begin addition ***

NWSLST:	HRROI B,[ASCIZ /HLP:NEWS-INDEX.NWS.0/]
	CALL TRYGTJ		;Get a JFN on the news index
	 HERROR <News index not found>
	MOVX B,OF%RD!FLD(7,OF%BSZ)
	OPENF%			;Open it
	 HERROR <Can't open news index>
	MOVE B,[1,,.FBBYV]	;Read the size of the file in pages
	MOVX C,C		;Place result in AC3
	GTFDB%			;Read the info
	AND C,[FB%PGC]		;Isolate the size in pages
	SKIPG C			;Size is positive?
	 HERROR <News index is empty>
	CAILE C,TABSIZ		;Size small enough to fit in our buffer?
	 HERROR <News index too big>
	HRLZ A,A		;Make JFN,,0
	MOVE B,[.FHSLF,,TABBUF/1000] ;Use same mapping buffer as "Help" does
	TXO C,PM%CNT!PM%RD
	PMAP%			;Read in the file
	HRROI A,TABBUF		;Get pointer to mapped file
	RET			;Done

;*** CM201 end addition ***

;INFO (ON)

.INFOR::NOISE <ABOUT>
	TRVAR <TERMNL,TRAPC,RFERR,RFINFO>
	SKIPE CUSRNO		;CS90 Logged in?
	IFSKP.			;CS90 Nope
	  KEYWD $INFNL		;CS90 Use NLI table, then
	   0			;CS90
	   JRST CERR		;CS90
	ELSE.			;CS90
	  KEYWD $INFO		;CS90
	   0			;CS90
	   JRST CERR		;CS90
	ENDIF.			;CS90
;CS90 The following shouldn't ever happen, but it never hurts to make sure...
	TXNN P3,NOLG		;NEED TO BE LOGGED IN?
	SKIPE CUSRNO		;YES, ARE WE?
	JRST (P3)		;OK
	ERROR <LOGIN please>
	JRST (P3)

;INFO DEFAULTS

.INDEF::NOISE (FOR)
	KEYWD $DEF		;SEE WHAT TO PRINT DEFAULTS ABOUT
	 T ALL,ONEWRD,.IDALL	;DEFAULT TO "ALL"
	 CMERRX
	JRST (P3)		;GO DO IT

;INFO DEFAULTS (FOR) ALL

.IDALL::
;CM242	CALL .IDC		;OUTPUT DEFAULTS FOR CARDS
	CALL .IDCS		;OUTPUT DEFAULTS FOR COMPILE-SWITCHES
	CALL .IDDCL		;CM156 Defaults for "Declare"
;CM242	CALL .IDP		;OUTPUT DEFAULTS FOR PAPER-TAPE
	CALL .IDPL		;OUTPUT DEFAULTS FOR PLOT
	CALL .IDPRT		;OUTPUT DEFAULTS FOR PRINT
	CALL IDPRG1		;OUTPUT DEFAULTS FOR PROGRAM
	CALL .IDS		;OUTPUT DEFAULTS FOR SUBMIT
	CALL .IDMKD		;CS115 Defaults for "MKDIR"
	CALLRET .IDTAK		;OUTPUT DEFAULTS FOR TAKE, AND RETURN

;INFO DEFAULTS (FOR) PROGRAM (ATTRIBUTES)

.IDPRG::NOISE (ATTRIBUTES)
	CONFIRM
IDPRG1:	MOVE A,FRKDEF		;GET ADDRESS OF DEFAULT FORK BLOCK
	CALLRET IPROG		;PRINT CONTENTS AND RETURN

;INFO DEFAULT TAKE

.IDTAK::HRROI A,[0]		;FIRST ASSUME NO NO
	MOVE B,TAKDEF
	TXNN B,TKECOF		;NO?
	HRROI A,[ASCIZ /No /]	;YES, NO
	HRRO C,ECHNOI		;POINTER TO NOISE STRING
	ETYPE < Set Default Take %1MEcho (%3M)%_>
	HRROI A,[0]
	TXNN B,TKALEF		;SAME SCHTUCK FOR ALLOW / DISALLOW
	HRROI A,[ASCIZ /Dis/]
	HRRO B,ALONOI
	ETYPE < Set Default Take %1MAllow (%2M)%_>
	RET

;INFORMATION (ABOUT) ADDRESS-BREAK

ALLFLG==AB%RED!AB%WRT!AB%XCT	;ALL ADDR BREAK BITS

.ADBRK::SKIPG A,FORK		;GET FORK HANDLE
	JRST [	TYPE < No program>
		RET]
	HRLI A,.ABRED		;FUNCTION TO READ ADDRESS BREAK INFO
	ADBRK			;GET IT
	 ERJMP [CALL DGETER	;GET REASON FOR FAILURE
		CAIE A,ABRKX1	;NOT AVAILABLE ON THIS SYSTEM?
		CALL CJERR	;OTHER ERROR, DO ERROR MESSAGE
		ETYPE <%%%%1?%%_>;YES, THAT'S THE "INFORMATION"!
		RET]		;DONE
	SKIPE C			;ANYTHING THERE?
	TXNN C,ALLFLG		;ANY BITS SET?
	JRST [	TYPE <Address break not set.>
		RET]		;NO
	ETYPE <Address break at %2Y on>
	TXC C,ALLFLG		;FIRST CHECK FOR COMMON CASE OF
	TXCN C,ALLFLG		;ALL BITS BEING SET
	JRST [	TYPE < all types of references.>
		RET]		;THAT WAS EASY!
	TXNE C,AB%RED		;READ
	TYPE < read>
	TXNE C,AB%WRT		;WRITE
	TYPE < write>
	TXNE C,AB%XCT		;EXECUTE
	TYPE < execute>
	TYPE <.>
	RET			;AND RETURN

;INFORMATION (ABOUT) DIRECTORY (NAME)
;SAME AS ^EPRINT

.INDIR::JRST EPRINT		;USE SAME CODE

;GET HERE ON "INFORMATION (ABOUT) COMMAND-LEVEL"

.EXECM::
	TYPE < Set >
	SKIPN CIDLYF
	TYPE <No >
	TYPE <Late-Clear-Typeahead
>
NEWF,<
	TYPE < Set >
	SKIPN IITSET		;TIMER ENABLED?
	TYPE <No >
	TYPE <Automatic (mail and alert checks)
>
>
;CS119 *** Begin ***
	TYPE < Set >
	SKIPN ENAFLG		;Flag set?
	TYPE <No >
	TYPE <Enable (during connect and access)
>
;CS119 *** End ***
;EM66 *** Begin ***
	TYPE < Set Command-Edit-Mode >
	SKIPE CEFLAG		;Get mode word
	 JRST [	TYPE <Alter>	;Alter mode
		JRST .+2 ]
	TYPE <Emacs>		;Emacs mode
	TYPE <
>
	TYPE < Set >		;Report the interrupt stuff
	SKIPG A,CEPSIC		;Got a character?
	 JRST [	TYPE <No Interrupt-Character (for command editor)
>
		RET ]
	TYPE <Interrupt Character (to) ^>
	ADDI A,100		;Make it a real character
	PBOUT			;Write it out
	TYPE < (for command editor)
>
;EM66 *** End ***
	RET

;"INFORMATION (ABOUT) SYSTEM-STATUS"

SYSINF::MOVEI A,.SFOPR
	TMON
	TYPE < Operator is >
	SKIPN B
	TYPE <not >
	TYPE <in attendance
>
	MOVEI A,.SFRMT
	HRROI B,[ASCIZ / Remote logins /]
	CALL TYPALO
	MOVEI A,.SFLCL
	HRROI B,[ASCIZ / Local logins /]
	CALL TYPALO
	MOVEI A,.SFPTY
	HRROI B,[ASCIZ / Pseudo-terminal logins /]
	CALL TYPALO
	MOVEI A,.SFNVT
	HRROI B,[ASCIZ / ARPANET terminal logins /]
	CALL TYPALO
	MOVEI A,.SFMCB		;CS112
	HRROI B,[ASCIZ / DECnet terminal logins /] ;CS112
	CALL TYPALO		;CS112
	MOVEI A,.SFCTY
	TMON
	TYPE < Console terminal login >
	SKIPN B
	TYPE <is not >
	TYPE <allowed
>
;;	MOVEI A,.SFMCD		;C390
;;	HRROI B,[ASCIZ / Micom-Debuging is /] ;C390
;;	CALL TYPALO		;C390
	MOVEI A,.SFFAC
	TMON
	TYPE < Accounting is >
	SKIPN B
	TYPE <not >
	TYPE <being done
>
	MOVEI A,.SFCDE
	TMON
	SKIPE B
	TYPE < CHECKD found errors
>
	MOVEI A,.SFCDR
	SKIPE B
	TYPE < CHECKD is running
>
	MOVEI A,.SFAVR		;SEE IF ACCOUNT VALIDATION IN EFFECT
	TMON
	TYPE < Account validation is >
	CALL INSYED		;TYPE "ENABLED" OR "DISABLED"
	MOVEI A,.SFWSP		;SEE IF WORKING SET PRELOADING BEING DONE
	TMON
	TYPE < Working set preloading is >
	CALL INSYED
	MOVEI A,.SFMTA		;DISPLAY STATE OF TAPE-DRIVE ALLOCATION
	TMON
	TYPE < Tape-drive allocation is >
	CALL INSYED
	MOVEI A,.SFRTW		;SEE IF RETRIEVAL-WAITS ALLOWED
	HRROI B,[ASCIZ / Automatic file-retrieval-waits /]
	CALL TYPALO		;TYPE WHETHER ALLOWED OR NOT
	MOVEI A,.SFMCY		;GET TAPE RECYCLE PERIOD
	TMON
	ETYPE < Maximum offline-expiration is %2q day>
	CAIE B,1
	PRINT "s"
	ETYPE <%_>
	MOVEI A,.SKRBC		;SAY WE WANT CONTROL SETTING
	MOVEI B,C		;ARG BLOCK ADDRESS
	MOVEI C,2		;LENGTH OF ARG BLOCK
	SKED%			;GET VALUE OF BIAS SETTING
	ETYPE < Scheduler bias-control setting is %4Q%%_>
	CALL CLSON		;SEE WHAT'S WITH CLASS SCHEDULING
	 JRST [	ETYPE < Class scheduling is disabled>
		TXNE A,SK%DRG	;BATCH ON DREGS
		ETYPE <, batch jobs being run on dregs queue>
		JRST NOCLS]
	ETYPE < Class scheduling>
	TXNE A,SK%ACT		;SEE IF BY ACCOUNTS
	ETYPE < by accounts>
	ETYPE < enabled, windfall >
	TXNE A,SK%WDF
	ETYPE <withheld>
	TXNN A,SK%WDF
	ETYPE <allocated>
	MOVEI A,.SKBCR		;READ BATCH CLASS
	MOVEI B,C		;BLOCK IS IN C
	MOVEI C,2		;ALLOCATE ROOM
	SKED%			;GET BATCH CLASS
	JUMPL D,NOCLS		;IF NEGATIVE, NO BATCH CLASS
	ETYPE <, batch class %4Q>
NOCLS:	ETYPE <%_>
	CALLRET SYSDWN		;PRINT INFO AND EXIT

;ROUTINE TO DO COMMON WORK FOR INFO SYSTEM-STATUS
;A/	CODE FOR ASKING MONITOR FOR INFO
;B/	POINTER TO STRING TO PRINT OUT

TYPALO:	ETYPE <%2M>		;TYPE TITLE STRING
	TMON			;ASK MONITOR FOR STATUS
	CAIN A,.SFRTW		;FILE RETRIEVAL?
	TRC B,1			;YES, SENSE IS DIFFERENT THAN ALL OTHERS!
	SKIPN B
	TYPE <are not >
	ETYPE <allowed%_>
	RET

;ROUTINE TO REPORT DISABLED IF B/ 0 AND ENABLED IF B/ 1

INSYED:	SKIPE B
	TYPE <enabled
>
	SKIPN B
	TYPE <disabled
>
	RET

;INFORMATION (ABOUT) VOLUMES (NAME) tapesetname:

IVOL::	STKVAR <QID>
	NOISE <OF TAPE>
	DEVX <tape set name, terminated with a colon>
	 CMERRX
	MOVEM B,IPCFP+.MATDV	;PUT DEVICE DESIGNATOR IN MESSAGE
	CONFIRM
	MOVE A,[.MATUS,,.QOMAT]
	MOVEM A,IPCFP+.MSTYP	;SET UP MESSAGE LENGTH AND CODE
	CALL QUASND		;SEND TO QUASAR
	MOVEM A,QID		;SAVE IDENTIFIER
	CALL GQPID		;GET QUASAR'S PID
	MOVE B,QID		;GET IDENTIFIER
	CALL IPCRCV		;RECEIVE RESPONSE
	MOVX A,MF.FAT
	TDNE A,IPCFP+.MSFLG	;FATAL ERROR?
	UERR IPCFP+.OHDRS+1	;YES, GIVE ERROR MESSAGE
	MOVEI A,.TMSET
	CALL FNDATR		;FIND SETNAME
	MOVE A,1(A)		;GET SETNAME
	ETYPE <Volumes of tape set %1': >
	MOVEI A,.TMVOL
	CALL FNDATR		;FIND VOLID LIST
	LOAD P1,AR.LEN,(A)	;GET LENGTH OF ENTRY
	MOVNI P1,-1(P1)		;GET NEGATIVE NUMBER OF VOLIDS
	MOVSS P1		;OVER TO LEFT HALF FOR AOBJN PTR
	HRRI P1,1(A)		;POINT RIGHT HALF AT FIRST VOLID
	SKIPA
IVOL1:	TYPE <,>
	SKIPN A,(P1)		;GET SIXBIT VOLID
	JRST [	ETYPE <scratch>	;IF VOLID = 0, IT'S A SCRATCH TAPE
		JRST .+2]
	ETYPE <%1'>		;TYPE VOLID
	AOBJN P1,IVOL1
	ETYPE <%_>
	RET

;FNDATR - FIND ENTRY FOR SPECIFIED ATTRIBUTE TYPE
; A/ ATTRIBUTE TYPE
;RETURNS +1, A/ ADDRESS OF ENTRY HEADER

FNDATR:	MOVE C,A
	MOVE B,IPCFP+.OARGC	;GET # OF ENTRIES IN LIST
	MOVEI A,IPCFP+.OHDRS	;GET ADDRESS OF HEADER OF 1ST ENTRY
FNDAT1:	LOAD D,AR.TYP,(A)	;GET TYPE OF ENTRY
	CAMN C,D		;MATCH WHAT I WANT?
	RET			;YES
	LOAD D,AR.LEN,(A)	;NO, GET LENGTH
	ADD A,D			;COMPUTE ADDRESS OF NEXT ENTRY
	SOJG B,FNDAT1		;LOOP THRU ENTRY LIST
	ERROR <Error in response from QUASAR>

TAPINF::MOVNI A,1
	MOVE B,[-1,,C]
	MOVEI C,.JIDEN
	GETJI
	 CALL JERR
	SETZ B,
	CAMN C,[.SJDN2]
	MOVEI B,[ASCIZ /200/]
	CAMN C,[.SJDN5]
	MOVEI B,[ASCIZ /556/]
	CAMN C,[.SJDN8]
	MOVEI B,[ASCIZ /800/]
	CAMN C,[.SJD16]
	MOVEI B,[ASCIZ /1600/]
	CAMN C,[.SJD62]		;IS IT 6250 BPI?
	MOVEI B,[ASCIZ /6250/]	;YES, 6250
	JUMPE B,[ETYPE < Unknown default tape density, value = %3O
>
		JRST ILLDEN]
	TYPE < Set Tape Density >
	UTYPE (B)
	TYPE <
>
ILLDEN:	MOVNI A,1
	MOVE B,[-1,,C]
	MOVEI C,.JIPAR
	GETJI
	 CALL JERR
	SETZ B,
	CAMN C,[.SJPRE]
	MOVEI B,[ASCIZ /Even/]
	CAMN C,[.SJPRO]
	MOVEI B,[ASCIZ /Odd/]
	JUMPE B,[ETYPE < Unknown default tape parity, value = %3O
>
		JRST ILLPAR]
	TYPE < Set Tape Parity >
	UTYPE (B)
	TYPE <
>
ILLPAR:	MOVNI A,1
	MOVE B,[-1,,C]
	MOVEI C,.JIDM
	GETJI
	 CALL JERR
	SETZ B,
	CAMN C,[.SJDMC]
	MOVEI B,[ASCIZ /Core-dump/]
	CAMN C,[.SJDMA]
	MOVEI B,[ASCIZ /Ansi-ascii/]
	CAMN C,[.SJDM8]
	MOVEI B,[ASCIZ /Industry-compatible/]
	CAMN C,[.SJDM6]
	MOVEI B,[ASCIZ /Sixbit/]
	CAMN C,[.SJDMH]		;IT IT HIGH DENSITY MODE?
	MOVEI B,[ASCIZ /High-density/]
	JUMPE B,[ETYPE < Unknown default tape format, value = %3O
>
		JRST ILLFMT]
	TYPE < Set Tape Format >
	UTYPE (B)
	TYPE <
>
ILLFMT:	MOVNI A,1
	MOVE B,[-1,,C]
	MOVEI C,.JIRS
	GETJI
	 CALL JERR
	ETYPE < Set Tape Record-length %3Q
>
	RET

SPLINF::MOVNI A,1
	MOVE B,[-1,,C]
	MOVEI C,.JIDFS
	GETJI
	 CALL JERR
	SETZ B,
	CAMN C,[.SJSPD]
	MOVEI B,[ASCIZ /Deferred/]
	CAMN C,[.SJSPI]
	MOVEI B,[ASCIZ /Immediate/]
	JUMPE B,[ETYPE < Unknown spooled-output-action, value = %3O
>
		RET]
;**;[730]	Change 1 line at SPLINF:+13L	KR	29-APR-82
	TYPE < Set Spooled-output >	;[730]CORRECT RESPONSE TO "I SPOOL"
	UTYPE (B)
	TYPE <
>
	RET

;TYPE CURRENT TERMINAL MODES

TRMPNT::NOISE (FOR TERMINAL)
	MOVEI A,.CTTRM		;DEFAULT TO CONTROLLING TERMINAL
	MOVEM A,TERMNL
	MOVEI B,[FLDDB. .CMCFM,,,,,[
		 FLDDB. .CMNUM,CM%SDH,8,<Terminal number>]]
	CALL FLDSKP		;SEE WHAT'S BEING TYPED
	 CMERRX <Carriage return or terminal number required>
	LOAD D,CM%FNC,.CMFNP(C)
	CAIE D,.CMCFM		;SPECIAL NUMBER?
	JRST [	ADDI B,.TTDES	;MAKE TERMINAL DESIGNATOR
		MOVEM B,TERMNL	;YES, REMEMBER IT
		MOVE A,CSBUFP	;POINT TO SOME FREE SPACE
		HRROI B,[ASCIZ /TTY/]
		MOVEI C,0
		SOUT		;BUILD STRING TTYnnn
		MOVE B,TERMNL
		SUBI B,.TTDES	;MAKE REAL NUMBER AGAIN
		MOVEI C,8	;SAY OCTAL
		NOUT		;PUT NUMBER ON STRING
		 ERCAL JERR	;THIS SHOULDN'T FAIL
		HRROI B,[ASCIZ /:/]
		MOVEI C,0
		SOUT
		MOVX A,GJ%SHT
		MOVE B,CSBUFP
		CALL GTJFS	;GET A JFN TO CHECK LEGALITY
		 ERROR <%?>	;GIVE ERROR IF BAD TERMINAL
		CONFIRM		;GET FINAL CONFIRMATION
		JRST .+1]

;CHECK TERMINAL TYPE AND INTERPRET SOME CODES

	MOVE A,TERMNL
	CALL TTYNAM		;CM156 Get string for terminal type name
	IFSKP.			;CM156 If succeeded
	  ETYPE< Terminal %1\%%_> ;CM156 Type the string
	ELSE.			;CM156
	  ETYPE <%% Can't read terminal type - %?%%_> ;CM156
	ENDIF.			;CM156
	JRST ILTTY1		;CM156 Go print speed info

;CM156 Routine to return the English name for a terminal type.  Used both
;by PCL and "Information terminal".  The English name is a string like
;"VT52" if the terminal name is known, or "TYPE n" if no name is known.
;
;Takes:
;	A/ terminal designator
;Returns:
;	+1/ error (GTTYP% failed)
;	+2/ success
;with:
;	A/ -1,,addr byte pointer to an ETYPE'able string
;	B/ terminal type number (may be needed by ETYPE!)
;
TTYNAM::			;CM156
	GTTYP
	 ERJMP R		;CM156
	JUMPL B,ILTTYP
	CAIGE B,TTYPLN
	SKIPA A,B
ILTTYP:	MOVEI A,TTYPLN		;THIS INDEX DOES "ETYPE < TERMINAL TYPE %2Q>"
	SKIPN A,TTYPTB(A)	;CM156 Get pointer to string
	 MOVE A,NOTYPE		;CM156 If none, use "TERMINAL TYPE n"
	RETSKP			;CM156

;PRINT SPEED INFO

ILTTY1:
	MOVE A,TERMNL
	MOVEI B,.MORSP		;SPEED INFO
	MTOPR
CS,<	 ERJMP NOSPD>		;EM44
CC,<	 ERJMP [ETYPE <%% Can't get speeds - %?%%_> ;CM44
		JRST NOSPD]>	;EM44
	CAME C,[-1]		;SPEEDS RECEIVED?
	JRST TISP1		;YES
	TYPE < !Terminal speed indeterminate!>
	JRST TISP2
TISP1:	HLRZ A,C		;INPUT SPEED
	HRRZS C
	ETYPE < Terminal Speed %1Q>
	CAME A,C		;INPUT = OUTPUT
	ETYPE < %3Q>
TISP2:	ETYPE<%_>		;TERMINATE LINE
NOSPD:

	SETZM RFERR		;NO RFMOD ERROR YET
	MOVE A,TERMNL
	RFMOD			;GET TERMINAL MODES

;CHECK LINKS BIT

	 ERJMP [CALL DGETER	;GET REASON FOR FAILURE
		MOVEM A,RFERR	;REMEMBER
CC,<		ETYPE <%% Can't get link or advice status - %?%%_>> ;EM44
		JRST NOLNK]

	MOVEM B,RFINFO		;REMEMBER RFMOD INFORMATION
	TXNE B,TT%ALK
	TYPE < Receive Links
>
	TXNN B,TT%ALK
	TYPE < Refuse Links
>
;CHECK ADVICE BIT

	TXNE B,TT%AAD
	TYPE < Receive Advice
>
	TXNN B,TT%AAD
	TYPE < Refuse Advice
>
NOLNK:				;CS15 *** Begin ***
	MOVE A,TERMNL
	MOVEI B,.MOSNP
	MTOPR%
CS,<	 ERJMP NOSND>		;EM44
CC,<	 ERJMP [ETYPE <%% Can't get send status - %?%%_> ;EM44
		JRST NOSND]>	;EM44
	CAIN C,0
	TYPE < Receive Sends
>
	CAIE C,0
	TYPE < Refuse Sends
>
NOSND:
;*** EM34 Begin ***
	MOVEI D,[ASCIZ/ Receive IPCF-messages
/]
	MOVE A,TERMNL		;Which terminal
	CALL GUSPID		;Do PID lookup on it
	 MOVEI D,[ASCIZ/ Refuse IPCF-messages
/]
	UTYPE (D)		;Print out which one
NOIPC:
;*** EM34 End ***
;*** CS47 Begin ***
CS,<
	MOVE A,TERMNL
	MOVEI B,.MORBD
	MTOPR%
	 ERJMP [ETYPE <%% Can't get backspace status - %?%%_>
		JRST NOBMD]
	CAIN C,0
	TYPE < Terminal No Backspace-means-delete
>
	CAIE C,0
	TYPE < Terminal Backspace-means-delete
>
NOBMD:
>;CS
;*** CS47 End ***
	MOVE A,TERMNL		;CS15 *** End ***
	MOVEI B,.MORNT
	MTOPR
CS,<	 ERJMP N0STAT>		;EM44
CC,<	 ERJMP [ETYPE <%% Can't get system-message status - %?%%_> ;EM44
		JRST N0STAT]>	;EM44
	CAIN C,0
	ETYPE < Receive System-messages%_>
	CAIE C,0
	ETYPE < Refuse System-messages%_>
N0STAT:

;CHECK PAUSE (ON) COMMAND

	SKIPE A,RFERR		;DON'T GIVE PAUSE INFO IF GOT ERROR
CS,<	 JRST NPINFO>		;EM44
CC,<	JRST [	ETYPE <%% Can't get pause-on-command setting - %1?%%_> ;EM44
		JRST NPINFO]>	;EM44
	MOVE B,RFINFO		;GET INFO FROM RFMOD JSYS
	TYPE < Terminal >
	TXNN B,TT%PGM
	TYPE <No >
	TYPE <Pause (on) Command
>
;CHECK PAUSE (ON) END-OF-PAGE

NPINFO:	MOVE A,TERMNL
	MOVEI B,.MORXO
	MTOPR
CS,<	 ERJMP NOEOPS>		;EM44
CC,<	 ERJMP [ETYPE <%% Can't get end-of-page status - %?%%_>	;EM44
		JRST NOEOPS]>	;EM44
	TYPE < Terminal >
	CAIN C,.MOOFF
	TYPE <No >
	TYPE <Pause (on) End-of-page>
	SKIPN RFERR		;CAN'T TELL IF DISABLED UNLESS RFMOD SUCCEEDED
	CAIN C,.MOOFF
	JRST NPEOPD
	MOVE B,RFINFO		;GET RFMOD BITS
	TXNN B,TT%PGM
	TYPE < !disabled!>
NPEOPD:	TYPE <
>
;IF PAUSE EOP IS ON SAY WHAT THE PAUSE CHARACTERS ARE

;**;[719] ADD 2 LINES AT NPEOPD:+4L	TAM	1-APR-82
	SKIPE MONVER		;[719] RELEASE 5 OR LATER
	JRST NOEOPS		;[719] NO, THIS DOSEN'T EXIST
	CAIE C,.MOOFF		;IS NO-PAUSE-EOP SET,
	TXNN B,TT%PGM		;  OR IS IT DISABLED?
	JRST NOEOPS		;EITHER - DON'T TYPE THE CHARACTERS
	MOVE A,TERMNL		;READ PAUSE,,UNPAUSE CHARS INTO T3
	MOVEI B,.MOPCR
	MTOPR
CS,<	 ERJMP NOEOPS>		;EM44
CC,<	 ERJMP [ETYPE <%% Can't get pause characters - %?%%_> ;EM44
		JRST NOEOPS]>	;EM44
	CAMN C,[23,,21]		;GOT THE USUAL CHARACTERS?
	JRST NOEOPS		;YES - SKIP THE LINE
	TYPE < Terminal Pause (on) Character>
	HLRZ B,C		;GET THE TURN-OFF CHARACTER
	PUSHJ P,POUTCH		;TYPE IT OUT
	HLRZ B,C		;GET THE TURN-OFF CHARACTER
	CAIN B,(C)		;ARE THE PAUSE AND UNPAUSE CHARACTERS THE SAME?
	JRST PAUSC0		;YES - DON'T SAY IT TWICE
	TYPE < (and unpause on)>
	HRRZ B,C		;GET THE TURN-ON CHARACTER
	PUSHJ P,POUTCH		;OUTPUT IT
PAUSC0:	TYPE <
>
;PAGE LENGTH

NOEOPS:	MOVE A,TERMNL
	MOVEI B,.MORLL		;PREPARE TO READ LENGTH
	MTOPR			;DO IT
CS,<	 ERJMP NODIM>		;EM44
CC,<	 ERJMP [ETYPE <%% Can't get length and width - %?%%_> ;EM44
		JRST NODIM]>	;EM44
	ETYPE < Terminal Length %3Q
>
;PAGE WIDTH

	MOVEI B,.MORLW		;READ WIDTH
	MTOPR
	ETYPE < Terminal Width %3Q
>
NODIM:	SKIPE A,RFERR		;DON'T PRINT INFO FROM FAILED RFMOD
CS,<	 JRST DPLXDN>		;EM44
CC,<	JRST [	ETYPE <%% Can't get lowercase, raise, flagging,
 formfeed, tab, echo, or duplex status - %1?%%_> ;EM44
		JRST DPLXDN]>	;EM44

;CHECK LOWER CASE

	MOVE B,RFINFO		;GET INFO FROM RFMOD
	TYPE < Terminal >
	TXNN B,TT%LCA
	TYPE <No >
	TYPE <Lowercase
>
;CHECK RAISE

	TYPE < Terminal >
	TXNN B,TT%LIC
	TYPE <No >
	TYPE <Raise
>
;CHECK OUTPUT FLAGGING

	TYPE < Terminal >
	TXNN B,TT%UOC
	TYPE <No >
	TYPE <Flag
>
;CHECK INDICATE FORMFEED FLAG

	TYPE < Terminal >
	MOVE A,TERMNL
	RFCOC
	LDB A,[POINT 2,B,25]
	CAIE A,1
	TYPE <No >
	TYPE <Indicate
>

CC,<				;CM187
;CM187 Check binary output mode.  Note: this code does NOT WORK
; if the user is requesting information about any terminal other
; than his/her own...
BT.DAM==^L<TT%DAM&-TT%DAM>
SZ.DAM==BT.DAM-^L<TT%DAM>+1
	TYPE < Terminal >
	LDB A,[POINT SZ.DAM,ITTYMD+TTWMOD,BT.DAM]
	CAIE A,.TTASC
	TYPE <No >
	TYPE <Translate
>>				;CM187

;CHECK MECHANICAL FORMFEED

	TYPE < Terminal >
	MOVE B,RFINFO
	TXNN B,TT%MFF
	TYPE <No >
	TYPE <Formfeed
>
;CHECK MECHANICAL TAB

	TYPE < Terminal >
	TXNN B,TT%TAB
	TYPE <No >
	TYPE <Tabs
>
;ECHO MODE

	TYPE < Terminal >
	TXNN B,TT%ECM
	TYPE <No >
	TYPE <Immediate
>
;CHECK DUPLEX CONTROL

BT.DUM==^L<TT%DUM&-TT%DUM>
SZ.DUM==BT.DUM-^L<TT%DUM>+1
	LDB A,[POINT SZ.DUM,B,BT.DUM]
	CAIN A,.TT0DX
	JRST [	TYPE < Duplexing in reserved state
>
		JRST DPLXDN]
	TYPE < Terminal >
	CAIN A,.TTFDX
	TYPE <Fullduplex
>
	CAIN A,.TTHDX
	TYPE <Halfduplex
>
	CAIN A,.TTLDX
	TYPE <Line Halfduplex
>				;CM236
DPLXDN:	RET			;ALL DONE

;SUBROUTINE TO OUTPUT THE CHARACTER IN T2 AS "CHAR"
;SAYS "ESCAPE", "SPACE" OR "CONTROL " IN THE APPROPRIATE CASES

POUTCH:	CAILE B," "		;GOT A PRINTING CHARACTER?
	JRST POUTCC		;YES - JUST OUTPUT IT
	CAIN B," "		;NO - GOT A SPACE
	JRST POUTCS		;YES - OUTPUT "SPACE"
	CAIN B,33		;GOT AN ESCAPE?
	JRST POUTCE		;YES - OUTPUT "ESCAPE"
	TYPE < Control>
	ADDI B,"@"		;MAKE THE CHARACTER PRINT
				;AND FALL INTO:
POUTCC:	ROT B,-^D21
	OR B,[BYTE (7) " ","""",0,""""]
	EXCH B,TRAPC
	UTYPE TRAPC		;OUTPUT THE PRINTING CHARACTER IN QUOTES
	EXCH B,TRAPC
	RET			;DONE

POUTCS:	TYPE < Space>
	RET
POUTCE:	TYPE < Escape>
	RET

;*** CM156 Begin modification ***

DEFINE TTYPE(NAME),<
	-1,,[XCAP <NAME>]	;EM135
	>

DEFINE TTYNTY,< 0 >

TTYPTB:	TTYPE <33>		;0
	TTYPE <35>		;1
	TTYPE <37>		;2
	TTYPE <TI>		;3
	TTYPE <PRINTRONIX>	;4-CM112
	TTYPE <TERMINET-1200>	;5-CM155
REPEAT 2,<TTYNTY>		;6-7
	TTYPE <SYSTEM-DEFAULT>	;8
	TTYNTY			;9
	TTYPE <VT05>		;10
	TTYPE <VT50>		;11
	TTYPE <LA30>		;12
	TTYNTY			;13 (NOT SUPPORTED)
	TTYPE <LA36>		;14
	TTYPE <VT52>		;15
	TTYPE <VT100>		;16
	TTYPE <LA38>		;17
	TTYPE <LA120>		;18
	TTYPE <REGENT-20>	;19
	TTYPE <IBM-3101>	;20
REPEAT 2,<TTYNTY>		;21-22 Not used
	TTYPE <BANTAM>		;CM256 23
	TTYPE <TELERAY-1061>	;CM251 24
	TTYPE <ADM3A>		;25
	TTYPE <BEEHIVE-100>	;26
	TTYPE <HAZELTINE-1200>	;27
	TTYPE <HP2645>		;28
	TTYPE <TEKTRONIX-4006>	;29
	TTYPE <GLASS-TTY>	;30
	TTYPE <FOX>		;31
	TTYPE <CONCEPT-100>	;32
	TTYPE <INFOTON-VISTA>	;33
	TTYPE <ZENITH-19>	;34
	TTYPE <VT125>		;[744] 35
	TTYPE <VK100>		;[744] 36
	TTYPE <DIABLO-1620>	;37
	TTYPE <MINIBEE-4>	;38
	TTYPE <CT82>		;39
	TTYPE <DATAMEDIA-1520A> ;40
	TTYPE <TELEVIDEO-912C>	;41
	TTYPE <SUPER-BEE>	;42
	TTYPE <ADM-31>		;43
	TTYPE <OSI-C4>		;44
	TTYPE <HAZELTINE-2000>	;45
	TTYPE <ANSI>		;46
	TTYPE <DIALOGUE-80>	;47
	TTYPE <CONCEPT-108>	;48
	TTYPE <D200>		;49
	TTYPE <AMBASSADOR>	;50
	TTYPE <OWL>		;51
	TTYPE <HAZELTINE-1420>	;52
	TTYPE <MICROBEE-2>	;53
	TTYPE <PERQ>		;54
	TTYPE <ADM-21>		;55
	TTYPE <TEKTRONIX-4025>	;56
	TTYPE <CONCEPT-LNZ>	;57
	TTYPE <DIALOGUE-81>	;58
	TTYPE <D400>		;59
	TTYPE <HAZELTINE-1410>	;60
	TTYPE <VIEWPOINT>	;61
	TTYPE <ZT-1>		;62
	TTYPE <NETRONICS>	;63

TTYPLN==.-TTYPTB
NOTYPE:	TTYPE <TYPE %2Q>

;***  CM156 End modification  ***

;CS51 *** Start ***
;"Information Coke-status" command

CS,<

$COKSW:	TABLE
	T VERBOSE,,0
	TEND

.ICOKE::MOVEI B,[FLDDB. .CMCFM,,,,,[ ;Maybe get switch
		 FLDDB. .CMSWI,,$COKSW]]
	CALL FLDSKP
	 CMERRX
	SETZ B,			;No rescan yet
	LDB C,[POINT 9,0(C),8]
	CAIN C,.CMCFM		;Confirm?
	IFSKP.
	  CONFIRM		;Confirm it
	  HRROI B,[ASCIZ "COKE /VERBOSE
"] ;Set up rescan
	ENDIF.
	MOVEM B,RSPTR		;Setup rescan pointer
	HRROI B,[ASCIZ/SYS:COKE.EXE/]
	CALL TRYGTJ		;Find program
	 ERROR <Couldn't find Sys:Coke.Exe>
	SETZ B,
	CALLRET REPH1		;Go run the program
>;CS

;CS51 *** End ***

;CS85 *** Start ***

CS,<

.IDOVR::CONFIRM			;Confirm it
	HRROI B,[GETSAVE (SYS:DOVERQ.)]
	CALL TRYGTJ		;Find DOVERQ program
	 ERROR <Couldn't find SYS:DOVERQ.EXE>
	HRROI B,[ASCIZ "DOVERQ /STATUS
"] ;Rescan for it
	MOVEM B,RSPTR		;Set up rescan pointer
	SETZ B,
	CALLRET REPH1		;Go run the program
>;CS

;CS85 *** End ***

CC,<				;CM6
; Report billable usage for session (;CM6)

.USAGE::STKVAR <<USGRAT,RATLEN>,<USGBFR,40>,USGDSG>
	MOVEI 1,.BILRA		;Get rates table
	MOVEI 2,USGRAT
	HRLI 2,-RATLEN
	GTBLT%

	MOVE 1,LIDNO		;Logged-in directory number
	GTDAL%			;Find out what he is using
	JUMPE 2,USAGE1		;Nothing, fine
	ETYPE <Disk usage %2Q% pages (>
	MOVE 1,COJFN
	MOVE 3,RATDSK+USGRAT	;Get cents per page-day
	CALL USGDOL		;And report it
	ETYPE < per day)%_>

USAGE1:	SETZ P5,		;Zero the total charge
	MOVEI 1,.JOBRT		;Get runtime
	HRL 1,JOBNO		;For this job
	GETAB%
	 ERJMP CJERR
	MOVE P1,1		;Save it
	HRROI 1,USGBFR		;Make up CPU time line
	HRROI 2,[ASCIZ/CPU Time      /]
	CALL USGMES
	MOVE 2,P1
	CALL USGTIM		;Print it
	MOVE 2,P1		;Get it again
	IDIVI 2,^D1000		;Make it seconds
	MOVE 3,RATCPU+USGRAT	;Get rate
	CALL USGDOL		;Print dollar amount
	UTYPE USGBFR		;Put to the terminal

	SETO 1,			;Get more on my job
	MOVE 2,[-3,,P2]		;Into here
	MOVEI 3,.JICON		;Starting here
	SETZ P3,		;No pointer here
	GETJI%
	 ERJMP CJERR

	HRROI 1,USGBFR		;Report connect time
	HRROI 2,[ASCIZ/
Connect Time  /]
	CALL USGMES
	MOVE 2,P2
	CALL USGTIM
	MOVEM 1,USGDSG		;Save output pointer
	GJINF%			;Get terminal number in 4
	MOVE 3,RATCON+USGRAT	;Assume base charge
	JUMPL 4,USAGE2
	MOVEI 1,.TTDES(4)	;Make designator
	MOVEI 2,.MORTP		;Retrieve static type and data
	MTOPR%
	 JWARN			;Shouldn't fail
	TXNE B,MO%RTI		;Dialup line?
	MOVE 3,RATRMT+USGRAT
	TXNE B,MO%RTU		;Terminal room?
	MOVE 3,RATPBL+USGRAT
	TXNE B,MO%RTT		;CM255 Telenet?
	MOVE C,RATTNT+USGRAT	;CM255
	TXNE B,MO%RTM		;CM324 Micom?
	MOVE C,RATMIC+USGRAT	;CM324
USAGE2:	MOVE 1,P2
	IDIVI 1,^D1000
	MOVE 2,1
	MOVE 1,USGDSG		;Recover output pointer
	CALL USGDOL
	UTYPE USGBFR

	HRROI 1,USGBFR
	HRROI 2,[ASCIZ/
Working Set   /]
	CALL USGMES
	MOVE 2,P4		;WS Page-seconds
	MOVE 3,P1		;CPU time
	IDIVI 3,^D1000		;Turn to seconds
	IDIV 2,3		;Get average working set size
	MOVX 3,<NO%LFL+NO%OOV+NO%AST+FLD(^D10,NO%COL)+FLD(^D10,NO%RDX)>
	NOUT%
	 TRN
	HRROI 2,[ASCIZ/   /]
	CALL USGMES
	MOVE 2,P4
	MOVE 3,RATWSS+USGRAT
	CALL USGDOL		;Now do dollar figure
	UTYPE USGBFR

	HRROI 1,USGBFR
	HRROI 2,[ASCIZ/
Total Charge               /]
	CALL USGMES
	MOVE 2,P5		;Get total dollar amount
	MOVE 3,[1.0]
	CALL USGDOL
	HRROI B,[ASCIZ/
These charges were computed at prime time internal rates.
Charges for other resources are not included here.
/]
	CALL USGMES
	UTYPE USGBFR		;Put it to the terminal
	RET			;All done

;CM6 *** Entire page ***

USGMES:	SETZ 3,
	SOUT%			;This isn't really here
	RET

USGTIM:	IDIVI 2,^D1000		;Convert msec to sec
	IDIVI 2,^D60		;Peel off seconds
	PUSH P,3		;Save for later
	IDIVI 2,^D60		;Peel off minutes
	PUSH P,3
	MOVX 3,<NO%LFL+NO%OOV+FLD(4,NO%COL)+FLD(^D10,NO%RDX)>
	NOUT%			;Print hours
	 TRN
	MOVEI 2,":"
	IDPB 2,1
	POP P,2
	MOVX 3,<NO%LFL+NO%ZRO+FLD(2,NO%COL)+FLD(^D10,NO%RDX)>
	NOUT%			;Print minutes
	 TRN
	MOVEI 2,":"
	IDPB 2,1
	POP P,2
	MOVX 3,<NO%LFL+NO%ZRO+FLD(2,NO%COL)+FLD(^D10,NO%RDX)>
	NOUT%			;Print seconds
	 TRN
	MOVEI 2," "
	IDPB 2,1
	IDPB 2,1
	IDPB 2,1
	RET

USGDOL:	FLTR 2,2		;Convert units to floating point
	FMPR 2,3		;Multiply by rate
	FIXR 2,2		;Get cents charged
	ADD P5,2		;Accumulate it
	IDIVI 2,^D100		;Make dollars
	PUSH P,3		;Save cents
	PUSH P,2
	MOVEI 2,"$"
	BOUT%
	POP P,2
	MOVX 3,<NO%LFL+NO%OOV+FLD(4,NO%COL)+FLD(^D10,NO%RDX)>
	NOUT%			;Print dollars
	 TRN
	MOVEI 2,"."
	BOUT%
	POP P,2
	MOVX 3,<NO%LFL+NO%ZRO+FLD(2,NO%COL)+FLD(^D10,NO%RDX)>
	NOUT%			;Print cents
	 TRN
	RET

;CM113 *** Entire page ***

;Entry for "Information accounts" command:

.IACCO::TRVAR <<USER,^D8>,ACCT,USRNUM,IAFUNC>
	NOISE <OF USER>
	SKIPN B,CUSRNO		;Logged in?
	 JRST NLIIAC		;No, do old style "I account"
	HRROI A,USER		;Destination is our local buffer
	DIRST%			;Make default directory string
	 ERJMP NLIIAC		;Strange, treat as not logged in
	SETZM USRNUM		;Assume all users
	SETZM ACCT		;  and all accounts

;I hate myself for the following gruesome code, but I haven't figured out
;a better way to do it.  I take a literal chain of FLDDB's and BLT the first
;one in the chain into AC's P1-P5 so I can set up a default string for it.
;I have to do it this way because the literal area isn't writeable and the
;FLDDB macro is too stupid to let me say that it should find the default
;string in a TRVAR variable.  Note: this code assumes that FLDDB's are 5
;words long:

	MOVEI B,P1		;FLDDB will start in P1
	HRLI B,[FLDDB. .CMUSR,CM%DPP,,,,[
		FLDDB. .CMSWI,,$IACSW,,,[
		FLDDB.	.CMCFM]]]
	BLT B,P5		;Store .CMUSR FLDDB in Ac's (so it's writeable)
	HRROI A,USER		;Get back address of default
	MOVEM A,.CMDEF+P1	;Store it in the FLDDB
	MOVEI B,P1		;Get address of FLDDB to use
	CALL FLDSKP		;See what user typed
	 ERROR <No such user>
	LDB C,[POINT 9,0(C),8]	;Figure out what was typed
	CAIN C,.CMCFM		;Confirm?
	 JRST IAC3		;Yes, use all defaults
	CAIN C,.CMUSR		;User name?
	 JRST	[MOVEM B,USRNUM	;Save the user number
		JRST IAC2]	;Parse confirm or "/account:????"
	CALL IACSWI		;Process the switch

;Here after "I account /account:mumble".  If we parse a username here, do
;a long-form "I account" on that user and that account.  If we parse a
;confirm then do long-form "I account" on all users of that account (if
;Fngdat decides the user has the right to the information):

	MOVEI B,[FLDDB. .CMUSR,,,,,[
		 FLDDB.	.CMCFM]]
	CALL FLDSKP
	 ERROR <Not confirmed>
	LDB C,[POINT 9,0(C),8]	;Figure out what was typed
	CAIN C,.CMCFM		;Confirm?
	 JRST IAC3		;Yes, print all users for this account
	MOVEM B,USRNUM		;No, must be user number.  Save it,
	CONFIRM			;Get confirmation,
	JRST IAC3		;And go do it
	
;Here after "I account user".  If we parse "/acount:mumble" here then
;give a long-form "I account" for that user and that account (identical
;to "I account /account:mumble user").  If we parse a confirm here we
;give a long form "I account" for the user (all accounts) if Fngdat is
;willing; if Fngdat is unwilling we give a short-form (old-style)
;"I accounts" listing:

IAC2:	MOVEI B,[FLDDB. .CMSWI,,$IACSW,,,[
		 FLDDB.	.CMCFM]]
	CALL FLDSKP
	 ERROR <Not confirmed>
	LDB C,[POINT 9,0(C),8]	;Figure out what was typed
	CAIN C,.CMCFM		;Confirm?
	 JRST IAC3		;Yes, print all accounts for this user
	CALL IACSWI		;No, switch.  Handle it
	CONFIRM

;Here when the command has been confirmed.  Generate the correct function
;code to be sent to Fngdat:

IAC3:	SKIPN ACCT		;Account specified?
	 JRST IAC4		;No
	MOVX A,F%USEA		;Yes, get that function code
	SKIPE USRNUM		;User also specified?
	 MOVX A,F%USEB		;Yes, slightly different function
	MOVEM A,IAFUNC		;Save the function we're doing
	JRST IAC5		;Go talk to Fngdat
IAC4:	SKIPN USRNUM		;User specified
	 JRST	[MOVE A,CUSRNO	;No, default to current user
		MOVEM A,USRNUM	;...
		JRST .+1]	;...
	MOVX A,F%USEU		;Get correct function code
	MOVEM A,IAFUNC		;Remember what we're doing

;If user didn't specify "/Account:" we do an old-style "I account"
;first:

	MOVE B,USRNUM		;Get the user number
	CALL NLIIA2		;Do the old-style "I account"

;Here to do long-form "I account"'s.  Builds the argument block for Fngdat
;in the AC's and then calls Execsu to do the IPCF stuff:

IAC5:	MOVE A,IAFUNC		;Get function code
	MOVE B,USRNUM		;Get the user number
	MOVE C,ACCT		;Get the account number
	CAMN A,[F%USEA]		;Account function?
	MOVE B,C		;Yes, then acct number goes in first word
				; of the argument block
	CALL IACSND		;Get EXECSU to type out extended info
	RET			;And we're done

;Routine which gets called whenever a switch (currently only "/Account:")
;is parsed.  Handles the arguments to the switch:

IACSWI:	HELPX <Account name>
	ACCTX			;Now parse the account number
	 CMERRX			;Failed, give error
	MOVE A,ATMBUF		;Get account string
	TRNE A,377		;Check only 4 characters
	 ERROR <Invalid account> ;More than 4, can't possibly be valid
				;  according to the Finger server
	MOVEM A,ACCT		;Save it away
	RET

;Switches legal in the "I account" command:

$IACSW:	TABLE
	TV ACCOUNT,,0
	TEND

;Here if not logged in.  Does the traditional (short-form) "I account"
;listing:

NLIIAC:	CALL USRNAM		;Get user name
	 ERROR <Invalid username>
	MOVE B,C		;User number
	CONFIRM

;Enter here from above or if Fngdat isn't cooperative.  Takes a user number
;in B (the user on which we are seeking account info):

NLIIA2:	HRROI A,P2		;Write name in P2
	SETZ P2,
	DIRST%
	 CALL CJERR		;Should never fail
	CALL ACOPEN		;Get data base
	 CALL CJERR
	MOVE A,P2		;Get key again
	CALL ACLOOK		;Find it
	 ERROR <No such user in account file>
	MOVE P1,A		;Keep a pointer to record

;Print the list of valid accounts

	LOAD P2,ACTNUM,(P1)	;Get count of accounts
	JUMPLE P2,[TYPE < [No valid accounts] >
		   RET]		;None valid, but let him try anyway
	MOVEI P3,ACTHDR(P1)	;Point to first account entry
	TYPE < [>

ACTLP:	LOAD D,ACTACT,(P3)	;Get an account string 
	MOVE A,COJFN		;Print it onto output JFN
	HRROI B,D
	SETZ C,			;It is terminated with a null
	SOUT
	JE ACTCFL,(P3),ACTLP1	;Is account closed?
	HRROI B,[ASCIZ/(Closed)/]
	SOUT			;Append qualification
ACTLP1:	ADDI P3,ACTLEN		;Step to next entry
	SOJG P2,[TYPE <, >	;If more accounts, put out a separator
		JRST ACTLP]	;And go print them
	TYPE <] >		;Else put out final part of text
	RET

;CM266 *** Entire page ***

;Open accounting data base, return +2 on success, +1 on failure

ACOPEN::MOVX A,GJ%SHT!GJ%OLD	;Get to accounting data base
	HRROI B,ACTNAM
	CALL GTJFS		;Get and stack JFN
	 RET
	MOVEM A,ACCJFN		;Remember it
	MOVX B,<FLD(44,OF%BSZ)!OF%RD>
	OPENF%			;Open it
	 RET
	CALL PIOFF		;No interrupts for a moment
	HRLZ A,ACCJFN		;Map directory
	MOVE B,[.FHSLF,,BUF2/1000] ;Into reasonable place
	MOVX C,<PM%CNT!PM%RD!PM%CPY!PM%PLD+DRPAG>
	PMAP%
	MOVEI A,BUF2		;Change each share pointer
	MOVEI B,DRPAG		;Into an immediate pointer
	SETMM (A)
	 ERJMP ACOPNP		;Forget extra pages
	ADDI A,1000
	SOJG B,.-3
ACOPXT:	CALL PION		;Allow interrupts now
	SETOM ACCMAP		;Nothing mapped yet
	MOVEI A,BUF2+DRKEY	;Next record's key
	MOVEM A,ACCPTR		;Is here
	RETSKP

ACOPNP:	LSH A,^D-9
	HRLI A,.FHSLF
	MOVE C,B
	MOVE B,A
	SETO A,
	TXO C,PM%CNT
	PMAP%			;Forget extra pages
	JRST ACOPXT

ACTNAM:	ASCIZ /ACCOUNT:ACCOUNTS.SYS/ ;Name of data base file

;CM266 *** Entire page ***

;Locate user entry in data base
;R1 contains key.  Returns +1 on failure, +2 on success, R1 points to entry

ACLOOK::CALL ACLKUP		;Find key entry
	 RET			;Not there
	LOAD A,KEPTR,(A)	;Point to record
	CALL ACMAPE		;Read it
	MOVEI A,DATHDL(A)	;Skip header
	RETSKP			;And deliver it

ACLKUP:	SAVEAC <P1,P2>
	MOVEI B,1		;B = Low search limit
	MOVEI C,BUF2
	LOAD C,DRCNT,(C)	;C = High limit
	SETZ D,			;D = Current index

ACLKSC:	CAMGE C,B		;If high limit LSS limit then search fails
	RET
	MOVE D,B		;Compute index = (high + low) / 2
	ADD D,C
	LSH D,-1
	MOVE P1,D		;Make that into address of key entry
	SOJ P1,
	IMULI P1,KELEN		;Address = DIRBUF + DRKEY + (Index - 1) * KELEN
	ADDI P1,BUF2+DRKEY
	LOAD P2,KEKEY,(P1)	;Fetch key out of this entry
	CAMGE A,P2		;Is search key less than this key?
	JRST [	SOJ D,		;Yes--high limit := index - 1
		MOVE C,D
		JRST ACLKSC]
	CAMLE A,P2		;Is search key GTR this key?
	JRST [	MOVE B,D	;Yes--low limit := index + 1
		AOJ B,
		JRST ACLKSC]
	MOVE A,P1		;Found the key--return its address in A
	RETSKP

;Get next record from database.
;R1 contains key desired, under mask in R2
;Returns +1 if no more records
;	 +2 with R1 = address of record, R3 = key

ACGET::	ASUBR <KEY,MASK>
	MOVEI C,BUF2		;Point to directory
	MOVE A,ACCPTR		;Next record's key
	LOAD B,DRCNT,(C)	;Find last key
	IMULI B,KELEN
	MOVEI B,BUF2+DRKEY(B)
ACGET1:	CAML A,B		;Past the last one?
	RET			;Yes
	LOAD C,KEKEY,(A)	;Get key
	AND C,MASK		;Select bits
	CAMN C,KEY		;Target?
	JRST ACGET2
	ADDI A,KELEN		;Next key
	JRST ACGET1
ACGET2:	MOVEM A,ACCPTR
	LOAD A,KEPTR,(A)	;Get pointer to record
	CALL ACMAPE		;Map pages containing record
	MOVE B,ACCPTR
	LOAD C,KEKEY,(B)	;Return the key
	MOVEI A,DATHDL(A)	;Return the record address
	ADDI B,KELEN
	MOVEM B,ACCPTR		;Set to next key
	RETSKP

;Read a record, R1=relative address; returns +1 with R1=absolute address

ACMAPE:	CAIGE A,DRDAT		;Is address in directory area?
	JRST [	MOVEI A,BUF2(A) ;Yes, always mapped
		RET]
	PUSH P,A		;Save relative address
	LSH A,^D-9		;Round down to nearest page
	MOVE D,A		;Save page number
	CAMN A,ACCMAP		;Page already mapped?
	JRST ACMPRT		;Yes
	MOVEM A,ACCMAP		;Remember it now
	CALL PIOFF
	HRL A,ACCJFN		;Get it in
	PUSH P,A		;Save jfn,,page #
	AOS A			;Get jfn,,page # of second page
	RPACS%			;Find out about that second page
	MOVX C,<PM%CNT!PM%RD!PM%CPY+2>	;Assume we want to map it
	TXNN B,PA%PEX		;Page exists?
	 TXZ C,<PM%CNT+777777>	;No, better map only one page (if it doesn't
				; exist we can't make it private so it won't
				; go away when we want it to.  Bad news...
	POP P,A			;Get back jfn,,page #
	MOVE B,[.FHSLF,,BUF0/1000]
	PMAP%
	SETMM BUF0		;Make them private
	 ERJMP .+1
	SETMM BUF1
	 ERJMP .+1
	CALL PION
ACMPRT:	POP P,A			;Get back relative address
	LSH D,^D9		;Figure out displacement into page
	SUB D,A
	MOVN D,D
	MOVEI A,BUF0(D)		;Get real address
	RET
>;CC
;*** BEGIN CS6 ***
CS,<

;Entry for "Information accounts" command:

;STRPTR Given a struture defined with DEFSTR return
; the address of the begining of the word
;
; STR - Structure name
; Y   - (optional) additional specification of data location
DEFINE STRPTR(STR,Y)<..STR0 (MAKPTR,0,STR,Y)>

   DEFINE MAKPTR(AC,LOC,MSK)<LOC>


;GENERAL PARAMETERS
; ALL BLOCKS HAVE THESE FIELDS - NULL BLOCK DOES NOT HAVE
; AN EXPIRATION DATE

DEFSTR (BKTYP,0,17,18)		;BLOCK TYPE
DEFSTR (BKLEN,0,35,18)		;BLOCK LENGTH
DEFSTR (XPDAT,1,35,36)		;EXPIRATION DATE


;HASH TABLE

;ACCOUNT HEADER

DEFSTR (ACCLS,2,8,9)		;JOB CLASS
DEFSTR (DATASZ,2,35,27)		;TOTAL LENGTH OF ACCOUNT DATA BLOCK
DEFSTR (ACPTR,3,35,36)		;POINTER TO NEXT ACCOUNT DATA BLOCK
DEFSTR (ACNAM,4,35,36)		;START OF ASCIZ ACCOUNT STRING NAME

;USER NAME 

DEFSTR (AXPTR,2,35,36)		;CS128 Auxiliary data record pointer
DEFSTR (USRNM,3,35,36)		;CS128 START OF USER NAME STRING

;CS128 *** Begin ***
;Definitions for aux data records

DEFSTR (AXLEN,0,35,36)		;Length of entry, including this word
DEFSTR (AXCRD,1,35,36)		;Creation date
$AXSPN==2			;Sponsor name offset
DEFSTR (AXSPN,$AXSPN,35,36)	;Sponsor name, 1st word
AUXMAX==$AXSPN+8		;Max length of aux record

;CS128 *** End ***

;SXSTR - SIXBIT STRUCTURE NAME - IS COMMON TO ALL DIRECTORY ENTRIES

DEFSTR (SXSTR,2,35,36)		;SIXBIT STRUCTURE NAME

;DIRECTORY NAME

DEFSTR (DIRNM,3,35,36)		;START OF DIRECTORY NAME STRING

;USER GROUP

DEFSTR (USRGP,2,35,36)		;GROUP NUMBER

;DIRECTORY GROUP

DEFSTR (DIRGP,3,35,36)		;GROUP NUMBER

;BLOCK TYPES

	.TYHSH==:577001		;BLOCK TYPE OF HASH TABLE
	.TYACC==:577002		;BLOCK TYPE OF ACCOUNT STRING
	.TYUNM==:577003		;BLOCK TYPE OF USER NAME
	.TYUGP==:577004		;BLOCK TYPE OF USER GROUP
	.TYALU==:577005		;BLOCK TYPE OF "ALL USERS"
	.TYDNM==:577006		;BLOCK TYPE OF DIRECTORY NAME
	.TYDGP==:577007		;BLOCK TYPE OF DIRECTORY GROUP
	.TYALD==:577010		;BLOCK TYPE OF "ALL DIRECTORIES"
	.TYNUL==:577011		;BLOCK TYPE OF NULLS
	.TYWUS==:577012		;BLOCK TYPE OF WILD CARD USER NAME STRING

.IACCO::TRVAR <USRNUM,<USER,^D8>,<CRUSER,^D8>,<ACCT,FBLLEN>,DOIFIR,DOISTR,DOACFL,CURACC,DOIOK,AUXJFN,<AUXREC,AUXMAX>> ;CS128
	NOISE <OF USER>
	SETOM DOIFIR		;-1 No account groups printed yet
	SETZM ACCT		;Assume all accounts
	SETZM USRNUM		; and users
	SETZM DOISTR		;Zero= no expired accounts found
	SKIPN B,CUSRNO		;Logged in?
	 JRST NLIIAC		;No, must give user name
	HRRI A,USER		;Destination is our local buffer
	HRLI A,(POINT 7,)	;Make a real byte pointer
	MOVEM A,CMDEF		;Set default
	DIRST%			;Make default directory string
	 ERJMP NLIIAC		;Strange, treat as not logged in

;I hate myself for the following gruesome code, but I haven't figured out
;a better way to do it.  I take a literal chain of FLDDB's and BLT the first
;one in the chain into AC's P1-P5 so I can set up a default string for it.
;I have to do it this way because the literal area isn't writeable and the
;FLDDB macro is too stupid to let me say that it should find the default
;string in a TRVAR variable.  Note: this code assumes that FLDDB's are 5
;words long:

	MOVEI B,P1		;FLDDB will start in P1
	HRLI B,[FLDDB. .CMUSR,CM%DPP,CM%DWC,,,[
		FLDDB. .CMSWI,,$IACSW]]
	BLT B,P5		;Store .CMUSR FLDDB in Ac's (so it's writeable)
	HRROI A,USER		;Get back address of default
	MOVEM A,.CMDEF+P1	;Store it in the FLDDB
	MOVEI B,P1		;Get address of FLDDB to use
	CALL FLDSKP		;See what user typed
	 ERROR <No such user>
	LDB C,[POINT 9,0(C),8]	;Figure out what was typed
	MOVEM B,USRNUM		;assume a user number to save
	CAIN C,.CMUSR		;parse a user a user name?
	 JRST CONIAC		;yes, confirm and go

	HELPX <Account name>
	DEFX <*>		;default string
	ACCTX			;now parse the account number
	 CMERRX			;failed, give error
	HRRI A,ACCT		;save account here
	HRLI A,ATMBUF		;from here
	MOVE B,A
	BLT A,<FBLLEN-1>(B)	;make the copy
	CONFIRM
	JRST DOIACC

;Switches legal in the "I account" command:

$IACSW:	TABLE
	TV ACCOUNT,,0
	TEND

;Here if not logged in.
NLIIAC:	CALL USRNAM		;get user name
	 ERROR <Invalid username>
	MOVEM C,USRNUM		;save it
CONIAC:	HRRI A,USER		;save user string here
	HRLI A,ATMBUF		;from here
	MOVE B,A
	BLT A,7(B)		;make the copy
	CONFIRM			;confirm and go
	JRST DOPUSR

;CM266 *** Entire page ***
DOIACC:	CALL ACOPEN		;open ACCOUNTS-TABLE.BIN
	 CALL CJERR		;Should never fail

;Loop to process of each block in 
DOIACL:	CALL GETACB		;get next accounting block
	 JRST DOIEND		;none left
	CALL DOIBLK		;handle this block
	JRST DOIACL		;go get the next

DOIEND:	SKIPE DOISTR		;any expired accounts?
	ETYPE <%_* Means account is expired%_>
	CALL DOICLS		;close ACCOUNTS-TABLE.BIN
	RET

DOICLS:	SETO A,
	MOVE B,[.FHSLF,,BUF2/1000] ;into reasonable place
	MOVX C,<PM%CNT+DRPAG>
	PMAP%
	CALL RJFN
	RET

;process an entry
DOIBLK:	HLRZ B,(P1)		;get the block type
	CAIN B,.TYACC		;new account header?
	 JRST DOINAC		;yes go record where it is
	CAIE B,.TYWUS		;wild user?
	CAIN B,.TYUNM		;user entry?
	 JRST DOIUSR		;yes go process
	JRST DOIAE		;go check for illegal block types

;process a new account block
DOINAC:	MOVX A,<0,,.WLSTR>	;match a wildcarded string
	HRROI B,ACCT		;and account we are looking for
	HRROI C,@[STRPTR<ACNAM,(P1)>] ;point to the start of the name
	WILD%			;compare
	MOVEM A,DOACFL		;flag for this accounts users
	JUMPN A,R		;no match don't print this info

DOINP:	AOSE DOIFIR		;don't print a crlf the first time
	ETYPE <%_>
	CALL DOIEXP		;print a * if expired else a space, set B
	SKIPE B			;Main accounts don't usualy expire
	 CALL DOIPT
DOIN0:	HRROI A,@[STRPTR<ACNAM,(P1)>] ;point to the start of the name	
	ETYPE < Account:%1M%%_>	;CS128
	RET

;Handle a user entry
DOIUSR:	SKIPE DOACFL		;print this user?
	 RET			;nope
	CALL DOIEXP		;print a * if expired else a space
	TYPE <  >
	CALL DOIPT		;print out the date
	CALL DOXPT		;CS128 Print out creation & sponsor info
	HRROI A,@[STRPTR<USRNM,(P1)>] ;user name
	ETYPE < User:%1M%%_>
	RET

;CS128 *** Begin ***
;Print out creation date & sponsor info, if it exists.

DOXPT:	LOAD C,AXPTR,(P1)	;Get aux file pointer
	JUMPE C,R		;No record. Punt.
	SKIPN A,AUXJFN		;Point at aux file
	RET			;No aux file. Punt.
	RIN%			;Read length & set file pointer
	JUMPE B,R		;None. Punt.
	MOVE D,B		;Copy it away...
	MOVNI C,-1(B)		;Make length of record remaining
	MOVEI B,1+AUXREC	;Point at record space
	HRLI B,(POINT 36,)	;Make byte pointer
	SIN%			;Read in the rest of the record
	LOAD B,AXCRD,+AUXREC	;Get creation date
	IFN. B			;Is there one?
	  ETYPE < Created:>
	  MOVE A,COJFN		;print the date
	  MOVX C,OT%NTM		;but not the time
	  ODTIM%
	  ETYPE <,>
	ENDIF.
	HRROI B,$AXSPN+AUXREC	;Point at the sponsor string
	CAILE D,$AXSPN		;Is record big enough to have sponsor info?
	 ETYPE < Sponsor:%2M,> ;Yes - print it
	RET

;CS128 *** End ***

;Print out a date
DOIPT:	ETYPE <Expire:>
	SKIPN B
	 JRST [ETYPE <  Never   > ;done with this
		RET]
	MOVE A,COJFN		;print the date
	MOVX C,OT%NTM		;but not the time
	ODTIM%
	TYPE <,>
	RET

;Returns+1:Always, A-Current TAD, B-Expire TAD
DOIEXP:	GTAD%
	LOAD B,XPDAT,(P1)	;expiration date
	SKIPE B			;is there an expiration date?
	CAML B,A		;or expired
	 JRST [	ETYPE < >	;not expired
		RET ]
	AOS DOISTR
	ETYPE <*>		;expired
	RET


;Do an I ACC of a bunch of users
DOPUSR:	CALL ACOPEN		;open ACCOUNTS-TABLE.BIN
	 CALL CJERR		;Should never fail
DOPU00:	HRROI A,CRUSER		;get current user string
	MOVE B,USRNUM
	DIRST%
	 CALL CJERR
	AOSE DOIFIR		;don't print a crlf the first time
	ETYPE <%_>
	ETYPE <User %2N:%_>
	SETZM DOIOK		;record number of accounts this user has
	CALL DOIA01		;scan the file for the current user
	MOVE C,USRNUM
	SKIPN DOIOK		;any valid accounts?
	 ETYPE <%%No valid accounts for user %3N%%_>

;reset the file
	HLRZ A,ACCMAP		;get file size
	HRLZM A,ACCMAP		;file size,,next page to map
	HRRZM A,ACCPTR		;number of pages left
	SETZ P1,		;no current record
	CAIG A,DRPAG		;bigger than one buffer?
	 CALL FILBU1		;no, just reset the pointers
	 JFCL			;always succedes

	MOVX A,RC%STP!RC%AWL	;get the next user
	HRROI B,USER		;from this string
	RCUSR%
	MOVEM C,USRNUM
	TXC A,RC%WLD		;if not wild then done
	TXNN A,RC%NOM!RC%NMD!RC%WLD ;done?
	 JRST DOPU00		;no, get the next one

	JRST DOIEND		;print closing info

;Loop to process of each block in 
DOIA01:	CALL GETACB		;get next accounting block
	 RET			;done
	CALL DOIA02		;handle this block
	JRST DOIA01		;go get the next

;process an entry
DOIA02:	HLRZ B,(P1)		;get the block type
	CAIN B,.TYACC		;new account header?
	 JRST [ MOVEM P1,CURACC	;address of account header
		RET]
	CAIE B,.TYWUS		;wild user
	CAIN B,.TYUNM		;user entry?
	 JRST DO2USR		;yes go process
DOIAE:	CAIE B,.TYNUL		;a null block?
	CAIN B,.TYHSH		;a hash table
	 RET			;that is fine, just ignore it
	JUMPE B,R		;filler and end of the file
	ETYPE <%%Ilegal block type %2O at %10P in ACCOUNTS-TABLE.BIN%_>
	RET


; process a user entry
DO2USR:	MOVX A,<0,,.WLSTR>	;match a wildcarded string
	HRROI B,@[STRPTR<USRNM,(P1)>] ;point to the start of the name
	HRROI C,CRUSER		;does this user match
	WILD%
	JUMPN A,R		;no
	TYPE < >
	CALL DOIEXP		;print expire space or *
	MOVE C,CURACC		;get account main expire date
	LOAD C,XPDAT,(C)	;expiration date
	SKIPN B			;is there an individual expire date?
	 MOVE B,C		;no use main
	SKIPN C			;is there a main expire date
	 MOVE C,B		;no use individual
	CAMLE B,C		;is main less than regular
	 MOVE B,C		;no, use main
	SKIPE B			;is there an expire date
	CAML B,A		;or expired?
	AOS DOIOK		;no, this is a valid account
	CALL DOIPT		;print out expire date
	CALL DOXPT		;CS128 Print creation date, sponsor
	PUSH P,P1		;save current buffer position
	MOVE P1,CURACC		;print info about account header
	CALL DOIN0	
	POP P,P1
	RET

;CM266 *** Entire page ***

;Get the next accounting data block
GETACB:	JUMPGE P1,FILBUF	;go get a buffer
	HRRZ A,(P1)		;get the length of this block
	HRL A,A
	ADD P1,A		;point to the next block
	JUMPL P1,[SKIPN (P1)
		   RET		;done, at last block
		  RETSKP]	;success

FILBUF:	SKIPN ACCPTR		;any pages left to map?
	 RET			;no
	HRL A,ACCJFN		;map next page of accounts-table.bin
	HRR A,ACCMAP
	MOVE B,[.FHSLF,,BUF2/1000] ;Into reasonable place
	MOVX C,<PM%CNT!PM%RD!PM%CPY!PM%PLD+DRPAG>
	PMAP%
FILBU1:	MOVEI A,DRPAG		;adjust next page to map
	CAMLE A,ACCPTR		;are there that many?
	 MOVE A,ACCPTR		;no use what there is
	ADDM A,ACCMAP
	MOVE B,ACCPTR		;number of pages left
	SUB B,A			;adjust
	MOVEM B,ACCPTR
	LSH A,^D9		;*512 = number of words in buffer
	MOVN P1,A		;negate
	HRL P1,P1
	HRRI P1,BUF2
	RETSKP


;Open accounting data base, return +2 on success, +1 on failure

ACOPEN::MOVX A,GJ%SHT!GJ%OLD	;Get to accounting data base
	HRROI B,ACTNAM
	CALL GTJFS		;Get and stack JFN
	 RET
	MOVEM A,ACCJFN		;Remember it
	MOVX B,<FLD(44,OF%BSZ)!OF%RD>
	OPENF%			;Open it
	 RET
	HRRZ A,ACCJFN		;find the end of the file
	FFFFP%
	HRRZM A,ACCPTR		;number of pages left
	HRLZM A,ACCMAP		;file size, next page to map
	SETZ P1,		;no current record
	SETZM AUXJFN		;CS128 Assume no aux file yet
	MOVX A,GJ%SHT!GJ%OLD	;CS128
	HRROI B,AUXNAM		;CS128
	CALL GTJFS		;CS128 Get & stack jfn
	IFSKP.			;CS128 Success
	  MOVEM A,AUXJFN	;CS128 Stash jfn
	  MOVX B,<FLD(^D36,OF%BSZ)!OF%RD> ;CS128
	  OPENF%		;CS128 Open it
	   SETZM AUXJFN		;CS128 Failed - flush JFN
	ENDIF.			;CS128
	RETSKP			;success

ACTNAM:	ASCIZ /SYSTEM:ACCOUNTS-TABLE.BIN/ ;Name of data base file
AUXNAM:	ASCIZ /SYSTEM:ACCOUNTS-TABLE.AUX/ ;Additional data file

> ;CS *** END CS6

;CM133 *** Entire page ***

;List current greeting

.GRELS::STKVAR <<GRTSTR,100>>
	MOVEI A,.SYSGR		;Read greeting
	MOVEI B,GRTSTR		;Into here
	HRLI B,-100		;This many words
	GTBLT%
	 ERJMP R		;Give up if error
	MOVEI A,GRTSTR
	UTYPE (A)		;Type it out
	RET

;LIST LOGICAL NAMES

.LNLIS::TLZ Z,F2+F3		;EVERYTHING OFF SO WE CAN DEFAULT LATER
	NOISE <OF>
	TRVAR <SPNAM,LNDIR,LNTNM,LNJNM,LNDAT>
	MOVEI B,[FLDDB. .CMKEY,,$LNLIS,,<Job>,[
		 FLDDB. .CMDEV,CM%PO!CM%SDH,,<specific logical name>]]
	CALL FLDSKP
	 CMERRX <"Job", "System", "All", or specific logical name required>
	LDB C,[331100,,(C)]	;GET FIELD FLAVOR
	MOVEM C,LNDAT		;REMEMBER FIELD FLAVOR
	HRLM B,LNDAT		;AND KEYWORD POINTER
	CALL BUFFF		;GET LOGICAL NAME OR KEYWORD
	MOVEM A,SPNAM		;REMEMBER POINTER TO NAME
	HRRZ C,LNDAT		;GET COMND DATA AGAIN
	CAIN C,.CMDEV		;SPECIFIC LOGICAL NAME?
	JRST LNSPEC		;YES
	HLRZ B,LNDAT		;GET KEYWORD POINTER
	CALL GETKEY		;GET THE KEYWORD DATA
	CALL GETTER		;KEYWORD, BUT IS THERE A COLON AFTER IT?
	CAIN A,":"
	JRST [	COLONX <Colon to terminate logical name>
		 CMERRX
		JRST LNSPEC]
	CONFIRM			;CONFIRM THE KEYWORD
	JRST (P3)		;DISPATCH

.LNALL:	TLOA Z,F2!F3
.LNJB:	TLOA Z,F3
.LNSYS:	TLO Z,F2
	TLNN Z,F3		;JOB-WIDE?
	JRST .LNSY1
	TLNE Z,F2
	TYPE <Job-wide logical names:

>
	MOVE A,[.INLJB,,.LNSJB]
	CALL .LNTYL
	TLNE Z,F2
	TYPE <
System-wide logical names:

>
.LNSY1:	TLNN Z,F2
	RET
	MOVE A,[.INLSY,,.LNSSY]

;FALL INTO .LNTYL

.LNTYL:	HRRZM A,LNJNM
	HLLZS A
.LNTY1:	MOVEM A,LNDIR
	MOVE B,CSBUFP		;PUT IN UNUSED PORTION OF STRING BUFFER
	INLNM
	 JRST [	CAIE A,INLNX1
		 CALL JERR
		RET]		;ALL DONE
	IBP B
	MOVEM B,LNTNM
	MOVE B,CSBUFP
	MOVE C,LNTNM
	MOVE A,LNJNM
	LNMST
	JRST [	CAIE A,LNSTX1
		 CALL JERR
		JRST .LNTY2]
	MOVE A,CSBUFP		;GET POINTER TO NAME
	MOVE B,LNTNM		;GET POINTER TO DEFINITION
	CALL LNTYPE		;TYPE THE GOODIES
.LNTY2:	MOVE A,LNDIR
	AOJA A,.LNTY1

;GET HERE WHEN SPECIFIC LOGICAL NAME REQUESTED

LNSPEC:	CONFIRM			;CONFIRM THE SPECIFIC LOGICAL NAME
	MOVE B,SPNAM		;POINTER TO NAME IN B
	MOVE C,CSBUFP		;WRITE DEFINITION INTO STRING AREA
	MOVEI A,.LNSJB		;SPECIFY JOB
	LNMST			;GET JOB DEFINITION
	 ERJMP LNS1		;NO JOB DEFINITION
	TYPE <Job-wide:

>
	MOVE A,SPNAM
	MOVE B,CSBUFP
	CALL LNTYPE		;TYPE THE DEFINITION
	TYPE <
>
LNS1:	MOVEI A,.LNSSY		;GET SYSTEM DEFINITION
	MOVE B,SPNAM		;POINTER TO NAME AGAIN
	MOVE C,CSBUFP		;STRING SPACE
	LNMST			;GET SYSTEM VERSION
	 RET			;NONE
	TYPE <System-wide:

>
	MOVE A,SPNAM
	MOVE B,CSBUFP
	CALLRET LNTYPE		;TYPE SYSTEM VERSION AND RETURN

;ROUTINE TO TYPE A LOGICAL NAME DEFINITION.  GIVE IT POINTERS TO
;NAME AND DEFINITION IN A, B RESPECTIVELY

LNTYPE:	UETYPE [ASCIZ /%1M: => %2M%%_/]
	RET

$LNLIS:	TABLE
	T ALL,,.LNALL
	T JOB,,.LNJB
	T SYSTEM,,.LNSYS
	TEND

;INFORMATION (ABOUT) STRUCTURE <NAME>

GSUBLK==BUF0+<BUFL-BUF0+1>/2	;USE DEEP HALF OF AVAILABLE AREA
				;FOR JOB LIST.  THIS ALLOWS STARTING
				;USER LIST AT BEGINNING OF AREA WITHOUT
				;FEAR OF COLLISION, DESPITE FACT THAT
				;EACH USER ENTRY REQUIRES TWO WORDS
GSUALS==GSUBLK+.MSUAL		;ALIAS FOR GETTING USERS OF STRUCTURE
GSUFLG==GSUBLK+.MSUFL		;FLAGS,,LENGTH OF RESULTANT LIST
GSULST==GSUBLK+.MSUJ1		;BEGINNING OF JOB LIST
GSULEN==BUFL-GSUBLK+1		;TOTAL DATA BLOCK SIZE
GSUJLN==GSULEN-.MSUJ1+1	;MAXIMUM NUMBER OF USERS WE CAN LIST

.STRST::TRVAR <SIXALS,<ASCALS,2>,<ISBLK,GSSLEN>,ALIAS,DEFNAM>		;CELL TO HOLD POINTER TO DEFAULT NAME
	NOISE <NAME>
	MOVE A,[POINT 7,[ASCIZ/PS/]] ;CM224 Use this structure name
	MOVEM A,CMDEF		;SET UP POINTER TO DEFAULT VALUE FOR FIELD
	MOVEM A,DEFNAM		;REMEMBER POINTER TO DEFAULT
	STARX <Name of structure or * for all>
	 CAIA			;"*" NOT TYPED
	JRST STRSTR		;"*" TYPED
	MOVE A,DEFNAM
	MOVEM A,CMDEF		;SET UP DEFAULT AGAIN
	DEVX <Name of structure or * for all>
	 CMERRX <"*" or mounted structure name required>
	CONFIRM			;WAIT FOR CONFIRMATION
	MOVEM B,ALIAS		;STORE DEVICE DESIGNATOR
	CALLRET STRST1		;DO THE WORK AND RETURN

;ROUTINE THAT DOES THE REAL WORK OF PRINTING STRUCTURE STATUS

STRST1:	MOVE A,ALIAS		;GET DEVICE DESIGNATOR
	MOVEM A,.MSGSN+ISBLK	;STORE FOR GETTING STRUCTURE STATUS
	SETZM .MSGSI+ISBLK	;DON'T GET PHYSICAL NAME
	MOVE A,[GSSLEN,,.MSGSS]	;LENGTH,,FUNCTION
	MOVEI B,ISBLK		;GET ANSWERS INTO ISBLK
	MSTR			;ASK MONITOR FOR INFO ABOUT STRUCTURE
	 ERJMP [MOVE A,.MSGSN+ISBLK ;DESIGNATOR THAT CAUSED PROBLEMS
		CALLRET STRST2]	;PRINT A WARNING AND RETURN
	MOVE A,.MSGMC+ISBLK	;GET MOUNT COUNT
	MOVE B,.MSGFC+ISBLK	;AND OPEN FILE COUNT
	MOVE C,.MSGNU+ISBLK	;NUMBER OF UNITS IN STRUCTURE
	MOVE D,ALIAS		;GET POINTER TO NAME
ETYPE <Status of structure %4H:
Mount count: %1Q, open file count: %2Q, units in structure: %3Q
>
	MOVE A,.MSGST+ISBLK	;GET STATUS BITS
	TXNE A,MS%PPS		;SKIP IF NOT THE PRIMARY PUBLIC STRUCTURE
	TYPE <Public >
	TXNE A,MS%DOM		;SKIP IF NOT DOMESTIC
	TYPE <Domestic >
	TXNN A,MS%DOM		;SKIP IF DOMESTIC
	TYPE <Foreign >
	TXNN A,MS%INI		;SKIP IF NOT "BEING INITIALIZED"
	TXNE A,MS%DIS		;SKIP IF "BEING DISMOUNTED"
	TYPE <Unavailable for mounting >
	TXNE A,MS%RWD!MS%RWS	;SKIP IF WE DONT NEED ANOTHER LINE
	ETYPE <%_>
	TXNE A,MS%RWD		;READ AFTER WRITE FOR DATA
	TYPE <Write verification for data >
	TXNE A,MS%RWS		;READ AFTER WRITE FOR SWAP SPACE
	TYPE <Write verification for swapping >
	ETYPE<%_>
	LDF A,MS%GTM+MS%GTA+MS%GTC	;REQUEST CONNECTORS, ACCESSORS, AND MOUNTERS
	MOVEM A,GSUFLG
	MOVE A,.MSGSN+ISBLK	;GET ALIAS
	MOVEM A,GSUALS		;STORE FOR GETTING STRUCTURE USERS
	DMOVE A,[EXP <GSULEN>B17+.MSGSU,GSUBLK]
	MSTR			;GET LIST OF USERS FOR THIS STRUCTURE
	 ERJMP [MOVE A,GSUALS	;GET THE TROUBLE MAKER
		CALLRET STRST2]	;PRINT A WARNING ON THIS DEVICE AND RETURN
	HRRZ A,GSUFLG		;GET LENGTH OF USER LIST
	JUMPN A,STRSTU		;NON-ZERO MEANS THERE'S A LIST TO PRINT
	TYPE <There are no jobs currently using this structure
>
	RET

STRST2:	PUSH P,A		;SAVE THE DEVICE DESIGNATOR
	TYPE <%>		;GET READY TO PRINT WARNING
	CALL %GETER		;GET LAST ERROR WE RECIEVED
	MOVE A,ERCOD		;SET IT UP FOR PRINTING
	CALL $ERSTR		;TELL THEM WHAT HAPPENED
	POP P,A			;NOW GET THE DESIGNATOR BACK
	ETYPE < - %1H:%_>	;AND PRINT IT
	RET			;RETURN TO WHEREVER WE CAME FROM

STRSTU:	CAIL A,GSUJLN		;ARE WE SURE WE GOT THE WHOLE LIST?
	TYPE <%Couldn't get entire user list for structure
>
	PUSH P,P1
	PUSH P,P2
	PUSH P,P3
	PUSH P,P4		;GET SOME AC'S
	PUSH P,P5
	PUSH P,Q1
	MOVN P1,A		;GET NEG OF NUMBER OF JOBS IN LIST
	HRLZ P1,P1		;MAKE AOBJN POINTER
	MOVEI P2,0		;LENGTH OF USER LIST
	MOVEI C,.JIUNO		;SPECIFY WE WANT USER NUMBER
STR1:	HRRZ A,GSULST(P1)	;PICK UP A JOB NUMBER
	HRROI B,P3		;WE'LL READ USER NUMBER INTO P3
	GETJI			;GET IT'S USER NUMBER INTO P3
	 JRST STRX1		;COULDN'T, CHECK WHY
	MOVE P4,P2		;GET LENGTH OF USER LIST
STR3:	SOJL P4,STR2		;JUMP IF WE'VE SCANNED THE WHOLE LIST
	SOJ P4,			;SECOND WORD IS INFO BITS
	CAME P3,BUF0(P4)	;FOUND IT IN LIST YET?
	JRST STR3		;NO, KEEP LOOKING
	HLLZ A,GSULST(P1)	;FOUND IT, GET INFO BITS
	IORM A,BUF0+1(P4)	;PERHAPS MORE BITS ON FOR THIS JOB
STR4:	AOBJN P1,STR1		;LOOP FOR REST OF JOBS
	MOVE D,P2		;SAVE FINAL LENGTH OF USER LIST
	LDF P3,MS%GTM		;FIRST WE'LL LIST MOUNTERS
	MOVEI P4,[ASCIZ /Users who have MOUNTed %2H: /]
	MOVEI P5,[ASCIZ /No users have %2H: MOUNTed/]
	CALL REPORT		;PRINT THE MOUNTERS OF THE STRUCTURE
	LDF P3,MS%GTA		;LIST ACCESSERS
	MOVEI P4,[ASCIZ /Users ACCESSing %2H: /]
	MOVEI P5,[ASCIZ /No users are ACCESSing %2H:/]
	CALL REPORT
	LDF P3,MS%GTC		;NOW LIST CONNECTERS
	MOVEI P4,[ASCIZ /Users CONNECTed to %2H: /]
	MOVEI P5,[ASCIZ /No users CONNECTed to %2H:/]
	CALL REPORT
	POP P,Q1
	POP P,P5
	POP P,P4
	POP P,P3
	POP P,P2
	POP P,P1		;RESTORE THESE LITTLE DEVILS
	ret

;GET TO HERE ON "INFO STR *" OR "INFO STR *:"

STRSTR:	CONFIRM
	CALL DEVLUP		;LOOP THROUGH ALL DEVICES
	 CALL STRWRK		;DO THE WORK FOR EACH ONE
	RET			;DONE

STRWRK:	CAMN A,[SIXBIT /DSK/]	;IS IT STRUCTURE "DSK"?
	RET			;YES, FORGET IT, SINCE IT'LL COME UP AGAIN AS SPECIFIC STRUCTURE
	MOVEM D,ALIAS		;STORE DESIGNATOR FOR STRUCTURE ALIAS
	MOVEM A,SIXALS		;REMEMBER SIXBIT ALIAS
	LDB C,[221100,,B]	;GET DEVICE TYPE
	CAIE C,.DVDSK		;MAKE SURE IT'S A DISK
	RET
	HRROI A,ASCALS		;POINT TO AREA FOR ASCII ALIAS
	MOVE B,D		;GET DESIGNATOR
	DEVST			;GET ASCII
	 ERCAL JERRE		;SHOULDN'T FAIL, SINCE MONITOR SUPPLIED INPUT!
	HRROI A,ASCALS		;POINT TO THE ASCII
	CALL GETSIX		;GET SIXBIT
	 NOP			;WON'T EVER FAIL
	CAME A,SIXALS		;DID WE GET BACK WHAT WE STARTED WITH?
	RET			;NO, SKIP "DSK" OR "LPT" DEFINED AS A STRUCTURE
	CALL STRST1		;PRINT THE GOODS ON THIS STRUCTURE
	ETYPE<%_>
	RET

;ROUTINE TO LIST ELEMENTS FROM LIST STARTING IN BUF0.

REPORT:	STKVAR <<TBUFF,10>>	;EM31 Some buffer space for a user name
	MOVEI P1,0		;TELLS HOW MANY NAMES HAVE BEEN PRINTED ON THIS LINE
	SETOM Q1		;FLAG SAYING NO NAMES IN THIS LIST YET
	MOVE A,COJFN		;GET OUTPUT JFN
	MOVEI B,.MORLW
	MOVEI C,^D72		;FOR NON-TERMINAL ASSUME 72 COLUMNS
	MTOPR			;GET LINE WIDTH
	 ERJMP .+1		;PROBABLY NOT A TERMINAL
	MOVE P2,C		;REMEMBER IN P2
	MOVN D,D		;GET NEGATIVE OF NUMBER OF ELEMENTS
	HRLZ D,D		;MAKE AOBJN POINTER
	MOVE B,ALIAS		;GET POINTER TO STRUCTURE NAME
STR5:	TDNN P3,BUF0+1(D)	;THIS USER HAVE CORRECT ATTRIBUTES?
	JRST STR7		;NO
	AOSN Q1			;FIRST NAME BEING PRINTED?
	UETYPE @P4		;YES, PUT IN HEADING
	CAIE Q1,0		;FIRST NAME BEING PRINTED?
	TYPE <, >		;SEPARATE NAMES(NOT BEFORE FIRST ONE THOUGH!)
	MOVE B,BUF0(D)		;GET USER NAME
	CALL DIRRUM		;MAKE SURE THERE'S ENOUGH ROOM ON THIS LINE FOR ANOTHER NAME
	HRROI A,TBUFF		;EM31 Temp buffer
	DIRST			;EM31 Get username
	 ERJMP STR6		;GO CHECK ERROR CODE
	MOVEI A,TBUFF		;EM31 The temp buffer
	HRLI A,(POINT 7,)	;EM31 Make a byte pointer
	ETYPE <%1M>		;EM31 Type w/lowercasing the username
	MOVE A,COJFN		;EM31 Restore output jfn into AC1
	AOJ P1,			;COUNT NAMES ON THIS LINE
STR7:	AOBJN D,.+1
	AOBJN D,STR5		;LOOP FOR REST OF NAMES
	CAIGE Q1,0		;ANY NAMES PRINTED?
	UETYPE @P5		;NO, SO GIVE REMARK ABOUT LIST BEING EMPTY
	ETYPE<%_>		;PUT CR AFTER LIST
	RET

STR6:	MOVE A,COJFN		;EM31 Restore output jfn into AC1
	CALL %GETER		;GET REASON FOR FAILING DIRST
	MOVE B,ERCOD
	CAIE B,DIRX1		;USER GO AWAY?
	CALL CJERRE		;NO, SO BOMB OUT
	JRST STR7		;YES, IGNORE AND GO ON
STR2:	MOVEM P3,BUF0(P2)	;USER NOT FOUND, ADD TO LIST
	HLL A,GSULST(P1)	;GET CONTROL BITS
	HLLM A,BUF0+1(P2)	;SAVE BITS
	AOJ P2,			;2 WORDS PER ENTRY IN USER LIST
	AOJA P2,STR4		;EXPAND LIST AND CHECK REST OF JOBS
STRX1:	CAIE A,GTJIX4		;MAKE SURE ERROR IS "NO SUCH JOB"
	CALL CJERRE		;NO, SO BOMB OUT
	JRST STR4		;YES, JOB LOGGED OFF, SO SKIP IT

;ROUTINE USED WHEN PRINTING A LIST OF USER NAMES TO DECIDE WHETHER
;THE NEXT NAME WILL FIT ON THIS LINE.  IF NOT, A CRLF AND TAB IS PRINTED.
;THE ROUTINE ALWAYS ASSUMES THE NAME FITS, IF IT'S THE FIRST ONE ON THE
;LINE, NO MATTER HOW LONG IT IS.
;ACCEPTS:	B/	USER OR DIRECTORY NUMBER
;		P1/	NUMBER OF NAMES SO FAR ON THIS LINE
;		P2/	TERMINAL WIDTH
;RETURNS:	+1 ALWAYS, WITH P1 RESET TO 0 IF THERE WAS NO ROOM

DIRRUM:	SAVEAC <A,B,C,D>	;CLOBBER NOTHING
	STKVAR <<DRRBUF,FILWDS>>
	JUMPE P1,DIRUMX		;THERE'S ALWAYS ROOM FOR AT LEAST ONE NAME!
	JUMPE P2,DIRUMX		;IF 0 WIDTH, ASSUME INFINITE AND HENCE THERE'S ROOM!
	HRROI A,DRRBUF		;GET SOME FREE SPACE
	DIRST			;GENERATE THE STRING
	 ERJMP DIRUMX		;FAILED, SO JUST EXIT
	MOVEI B,0		;PUT NULL IN TO MARK END OF STRING
	IDPB B,A
	MOVEI A,DRRBUF		;LOOK AT STRING
	HRLI A,440700		;MAKE CORRECT BYTE POINTER
	MOVEI D,0		;D HOLDS LENGTH OF STRING
DUM1:	ILDB C,A		;MORE CHARACTERS?
	CAIE C,0		;NO
	AOJA D,DUM1		;YES, COUNT 'EM
	ADDI D,2		;LEAVE ROOM FOR COMMA AND SPACE
	MOVE A,COJFN		;GET POINTER TO OUTPUT DEVICE
	RFPOS			;WHERE ARE WE ON LINE?
	ADD B,D			;WHERE WILL WE BE AFTER PRINTING THIS NAME?
	CAIGE P2,(B)		;OVER RIGHT MARGIN?
	JRST DUMNO		;YES, NO ROOM ON THIS LINE
DIRUMX:	RET

DUMNO:	TYPE <
	>
	MOVEI P1,0		;NOTE THAT WE'RE ON NEW LINE
	JRST DIRUMX

;JOBSTAT

.PJ::	CONFIRM			;CS136 Alternate entry
.JOBST::STKVAR <LLPTR>
	ETYPE	< %$, Job %J, User %N> ;CS136
	GJINF
	CAME	B,LIDNO		;SKIP IF CONNECTED TO LOGGED-IN DIR
	UETYPE	[ASCIZ /, %G/]
	TYPE	<, Account >
	CALL	PRACCT		;PRINT ACCOUNT INFO
	ETYPE	<, %L%%_>
	HRROI A,-1		;OURSELF
	HRROI B,CSBUFP		;POINT TO BYTE POINTER
	MOVEI C,.JILLO		;SAY WE WANT LOGICAL LOCATION
	MOVE D,CSBUFP		;GET POINTER TO BEGINNING OF STRING
	GETJI			;GET IT
	 ERCAL CJERRE		;SHOULDN'T FAIL
	MOVE A,D		;GET POINTER TO LOGICAL LOCATION
	CALL BUFFS		;SAVE THE LOCATION
	MOVEM A,LLPTR		;REMEMBER POINTER TO IT
	CALL GETNOD		;GET HOST NODE NAME
	 MOVE A,LLPTR		;ON NONDECNET, GUARANTEE THAT THEY MATCH
	MOVE B,LLPTR		;COMPARE WITH OUR JOB'S NODE
	STCMP
	JUMPE A,NOLOC		;DON'T PRINT NAME IF THEY'RE THE SAME
	MOVE A,LLPTR
	ETYPE <Located at %1m%%_>
NOLOC:	HRROI A,-1		;CURRENT JOB
	MOVE D,CSBUFP		;USE FREE SPACE POINTER
	HRROI B,D		;SAY ONE ENTRY, POINTER IN D
	MOVEI C,.JISRM		;SPECIFY WE WANT SESSION REMARK
	GETJI			;GET SESSION REMARK
	 ERJMP NOS		;IF FAILS, THERE'S NO REMARK
	MOVE A,CSBUFP		;GET POINTER TO REMARK
	ILDB A,A		;GET FIRST CHARACTER
	MOVE D,CSBUFP
	CAIE A,0		;PRINT NOTHING IF NO SESSION REMARK
	ETYPE <Session remark: %4M%%_>
NOS:	RET

;RUNSTAT - INFO PROGRAM-STATUS

.RUNST::STKVAR <FRKSNW>
ETYPE < Used %B% in %C%
>
	TLOA Z,F1		;SET FLAG FOR JOB STATUS
.FRKST::TLZ Z,F1		;CLEAR FLAG FOR FORK STATUS ONLY
	TLNN Z,F1		;WANT ALL INFO?
	 JRST .FKST2		;NO - PRINT FORKS ONLY
	MOVEI A,.FHSLF		;REPORT ON CURRENT FORK FIRST
	ETYPE < Tops-20: %1V
>
	TYPE < Set >
	SKIPE PAXLFL
	TYPE <No >
	TYPE <Uuo-simulation (for program)
>
	TYPE < Set >
	SKIPE CCFLAG
	TYPE <No >
	TYPE <Control-C-capability (of program)
>
	TYPE < Set >		;CM318
	HRRZ A,C2PASS		;CM318 Isolate user capabilities
	SKIPN A			;CM318 Any passed?
	TYPE <No >		;CM318 No
	TYPE <Privileges (for program)
>				;CM318
XTND,<
	TYPE < Set >
	SKIPN CCKEEP
	TYPE <No >
	TYPE <Keep-fork (on <ctrl-C>)
>
>
	SETZM TRAPC		;CLEAR NUMBER BEING TRAPPED
	MOVEI A,[CAIE A,0	;COUNT ONES BEING TRAPPED
		 AOS TRAPC
		 RET]
	CALL SCNJBK
	SKIPE TFILEF		;SEE IF TRAPPING FILE-OPENINGS
	ETYPE < Set Trap File-openings%_>
	SKIPN A,TRAPC
	JRST [	SKIPN TFILEF	;NO JSYS TRAPPED.  TRAPPING FILE-OPENINGS?
		JRST NJTRAP	;NOTHING BEING TRAPPED SO SAY NOTHING.
		JRST JMORE]	;TRAPPING ONLY FILE-OPENINGS SO GIVE OTHER STATUS
	CAIN A,777		;PERHAPS EVERYTHING IS BEING TRAPPED
	JRST [	ETYPE < Set Trap Jsys /All%_>
		JRST JMORE]
	MOVEI Q2,0		;Q2 IS 0 OR 1 DEPENDING ON WHICH SET IS LARGER
	CAIG A,223		;MORE THAN HALF OF ALL JSYS'S BEING TRAPPED?
	MOVEI Q2,1
	CAIN Q2,0
	TYPE < All JSYS's being trapped except: >
	CAIE Q2,0
	TYPE < Set Trap on these JSYS's: >
	MOVEI Q1,0		;COUNTER FOR KNOWING WHEN TO BREAK LINE
	MOVEI A,[CAME A,Q2
		 RET		;DON'T LIST JSYS NOT IN CORRECT CLASS
		 CAIL Q1,5
		 TYPE <	>
		 CAIL Q1,5
		 MOVEI Q1,0	 ;START NEW LINE IF NECESSARY
		 CAIE Q1,0
		 TYPE <, >
		 ETYPE <%2M>
		 CAIL Q1,5
		 TYPE <%_>
		 AOJ Q1,	;KEEP TRACK OF NUMBER ON LINE
		 RET]
	CALL SCNJBK		;PRINT APPROPRIATE LIST
JMORE:	CALL LM			;FINISH LIST
	SKIPE TSTOPF		;SAY WHETHER PROCEEDING AFTER TRAPS OR NOT
	ETYPE < Set Trap No Proceed%_>
	SKIPN TSTOPF
	ETYPE < Set Trap Proceed%_>
NJTRAP:	TYPE < Set Typeout Mode >
	SKIPN SYMF
	ETYPE <Numeric%_>
	SKIPE SYMF
	ETYPE <Symbolic%_>
	TYPE < Set >		;EM15
	SKIPN CTTFLG		;EM15
	TYPE <No >		;EM15
	ETYPE <Verbose-Control-T (display)%_> ;EM15
	CALL IDPRG1		;SHOW DEFAULT PROGRAM SETTINGS
	HLRZ A,FRKNMS		;SEE HOW MANY FORK NAME BLOCKS EXIST
	MOVEM A,FRKSNW		;STORE IN FORK SCAN WORD
FKS1:	SOSGE B,FRKSNW		;DON'T ASSUME IPROG PRESERVES TEMPS
	JRST .FKST2		;DONE IF NO MORE
	HRRZ A,FRKNMS+1(B)	;GET ADDRESS OF FORK BLOCK
	LOAD C,FKFLAG,(A)	;GET FLAGS
	HLRO B,FRKNMS+1(B)	;GET POINTER TO NAME
	TXNE C,FN%NAT		;DON'T PRINT UNLESS NAME HAS SPECIFIC ATTRIBUTES
	CALL IPROG		;PRINT INFO ABOUT THIS PROGRAM
	JRST FKS1		;LOOP FOR REST OF ENTRIES

.FKST2:	CALL DGFRKS		;DO THE GFRKS TO GET FORK HANDLES
	 CALL [	CAIE A,GFKSX1	;RAN OUT OF SPACE?
		CAIN A,FRKHX6	;RAN OUT OF HANDLES?
		SKIPA		;YES - CONTINUE
		JRST CJERR	;NO, STRANGE
		TYPE <% >
		CALL $ERSTR	;PRINT SYSTEM MESSAGE
		ETYPE<%_>	;ADD CRLF
		TYPE <% Partial structure will be printed.
>
		RET]
	SETZ Q1,
	HRRZ D,(C)
;**;[735] Insert 1 line at .FKST2:+13L	KR	17-MAY-82
	SETOM INDQUS		;[735]FLAG %ETYPE TO INDENT WHEN REPORTING ERR MESS FOR FORK
	CALL FSTRUC		;PRINT FORK TREE
;**;[735] Insert 1 line at .FKST2:+14L	KR	17-MAY-82
	SETZM INDQUS		;[735]DON'T NEED FLAG ANYMORE
	CALLRET UNMDIR		;UNMAP SPECIAL PAGES

;SCNJBK is used to scan through the jsyses for trap-handling
;
;Accepts:	A/	routine to call for each jsys
;
;The routine in A is called with the following set up:
;
;	A/	0 or 1 showing notrap/trap for this jsys
;	B/	pointer to ASCIZ jsys name
;	C/	the jsys

SCNJBK:	STKVAR <RNAME,JIDX>
	MOVEM A,RNAME		;REMEMBER ROUTINE TO CALL
	SETZM JIDX		;START WITH JSYS 1
	AOS D,JIDX
SCNJ1:	HRRO B,JTAB(D)		;GET POINTER TO NAME
	MOVX C,JSYS		;GIVE THE JSYS IN C
	HRR C,D			;GET THE JSYS'S Y FIELD
	ADJBP D,[430100,,JSBDEF];GET BYTE POINTER INTO BIT MASK
	LDB A,D			;TELL CALLER VALUE OF BIT
	CAMN C,[OPENF]		;NO NEED TO BE CAREFUL IF JSYS ISN'T OPENF
	CAIN A,0		;NO NEED TO BE CAREFUL IF JSYS ISN'T BEING TRAPPED
	CAIA			;NOT OPENF OR NOT BEING TRAPPED
	AND A,TOPENF		;DON'T CONFUSE FILE-OPENINGS WITH JSYS OPENF
	CALL @RNAME		;CALL THE ROUTINE
	AOS D,JIDX		;STEP TO NEXT JSYS
	CAIGE D,1000		;DONE THROUGH JSYS 777?
	JRST SCNJ1		;NO, DO THE REST
	RET

;IPROG prints the SET PROGRAM or SET DEFAULT PROGRAM values.
;
;Accepts:	A/	address of fork block
;		B/	pointer to name (ignored if c(a) = c(FRKDEF))

IPROG:	LOAD C,FKFLAG,(A)	;GET FLAGS
	HRROI D,[ASCIZ /Program /]
	CAMN A,FRKDEF		;DOING DEFAULT DISPLAY?
	JRST [	HRROI D,[ASCIZ /Default Program/]	;YES, SAY SO
		HRROI B,[0]	;NO SPECIFIC PROGRAM NAME
		JRST .+1]
	TXNE C,FN%EPH		;CHECK FOR "SET PROG" ATTRIBUTES
	ETYPE < Set %4M%%2M Ephemeral%_> ;
	TXNE C,FN%NEF
	ETYPE < Set %4M%%2M No-ephemeral%_>
	LOAD A,FKRESP,(A)	;GET POINTER TO METHOD OF RESTARTING
	TXNE C,FN%KEP
	ETYPE < Set %4M%%2M Keep (and) %1M (when invoked as a command)%_>
	RET

;FSTRUC
;RECURSIVE SUBR TO TYPE FORK STRUCTURE OF JOB.
;FOR EACH FORK, TYPES HANDLE AND STATUS.
;  FILE NAME OR "PROGRAM" WOULD ALSO BE DESIRABLE IF IT WERE AVAILABLE.
;STRUCTURE INDICATED BY PUTTING A FORK'S INFERIORS RIGHT AFTER IT,
;  INDENTING 3 COLUMNS PER LEVEL.
;THUS PARELLEL FORKS ARE THOSE WHICH APPEAR AT SAME INDENTATION WITH
;  NO LESS-INDENTED ENTRIES BETWEEN THEM.
;TAKES: D: POINTER TO GFRKS TABLE, SET UP BY CALLER.
;	Q1: LEVEL COUNTER, ZEROED BY TOP LEVEL CALLER.

;ENTRY POINT IS AT END BUT COMES RIGHT HERE.
;TYPE STUFF FOR THIS FORK.

FSTR1:	PRINT " "
	HRRZ B,1(D)
	CAMN B,FORK		;< TO MATCH FOLLOWING
	UTYPE [ASCIZ /=> /]
	CAME B,FORK
	TYPE <   >
	SKIPA A,Q1
	TYPE <   >		;INDENT 3 SPACES PER LEVEL BELOW FIRST.
	SOJGE A,.-1
	HRRZ B,1(D)		;GET THIS FORK'S HANDLE FROM TABLE
	JUMPE B,[UTYPE [ASCIZ /**: /]
		MOVE A,2(D)		;GET STATUS FROM TABLE
		MOVEM A,LRFSTS+.RFPSW	;SINCE WE DON'T HAVE A HANDLE
		SETZB A,LRFSTS+.RFPFL	;SIMULATE A LONG RFSTS WITH
		SETZM LRFSTS+.RFPPC	;AS MUCH INFORMATION AS WE KNOW
		CALL FSTAT		;PRINT STATUS WITH 0 PC
		JRST FSTR2]
	TXZ B,1B18		;PRINT IN FORM ## NOT 4000##
	SKIPN A,FRKTAB(B)	;KNOW ABOUT THIS FORK?
	 JRST FSTR2N		;NO - MAKE A DUMMY ENTRY
	TXNN A,FK%NAM		;FORK HAVE NAME?
	 JRST FSTR2B
	HRRO A,.FKNAM(A)	;GET POINTER TO NAME STRING
	ETYPE <%1\ (%2O)>
	JRST FSTR2C		;COMMON CODE

FSTR2N:	MOVEI A,.FKSZE		;SIZE OF ENTRY
	MOVE Q2,B		;SAVE FORK #
	MOVEI B,XDICT
	CALL GETMEM		;GET BLOCK OF STORAGE
	 JRST [	MOVE B,Q2
		MOVE D,SAVHD	;RESTORE POINTER
		JRST FSTR2B]	;NO SLOTS - JUST GIVE STATUS
	EXCH Q2,B		;PNTR TO Q2, FORK # TO B
	MOVE D,SAVHD		;RESTORE POINTER
	HLRZ A,1(D)		;GET SUPERIOR PNTR
	JUMPE A,FSTR2B		;NONE - MUST BE US
	HRLZ A,1(A)		;GET HANDLE
	MOVEM A,.FKOWN(Q2)	;STORE SUPERIOR HANDLE
	SETOM .FKEDL(Q2)	;NO E/D DONE
	HRRZM Q2,FRKTAB(B)	;STORE PNTR TO ENTRY
	HRRZI A,.FKPTM+1(Q2)	;CLEAR FORK MODES
	HRLI A,-1(A)
	SETZM .FKPTM(Q2)
	BLT A,.FKPTM+NTTYMD+1(Q2)
				;FORK HAS NO NAME , BUT WE KNOW ABOUT IT NOW
FSTR2B:	TYPE <Fork >
	MOVE A,COJFN
	MOVEI C,10
	NOUT			;FORK HANDLE, OCTAL
	 CALL JERRC		;JSYS ERROR ROUTINE FOR ERROR NUM IN C
FSTR2C:	TYPE <: >
	HRRZ A,1(D)		;HANDLE AGAIN
	CAIN A,.FHSLF		;SELF?
	JRST [	TYPE <EXEC>
		JRST FSTR2A]
	CAMN A,EDFORK		;EDITOR?
	 TYPE <Editor, >
	MOVE C,SLFTAB(A)
	TXNE C,FK%KPT		;THIS ONE KEPT?
	 TYPE <Kept, >
	TXNE C,FK%BKG		;BACKGROUND?
	 TYPE <Background, >
	TXNE C,FK%INV		;CM156 INVOKE'd?
	 TYPE <Invoked, >	;CM156
	TXNE C,FK%DBG		;DEBUGGER?
	 TYPE <Debugger, >
	CALL FSTAT		;TYPE ITS STATUS
FSTR2A:	MOVE D,SAVHD		;DON'T ASSUME FSTAT PRESERVES TEMPS
	HRRZ A,1(D)		;AND AGAIN
	ETYPE <, %1V>		;RUNTIME OF FORK
FSTR2:	ETYPE<%_>

;NOW DO ALL OF THE FORK'S INFERIORS, BY RECURSION.

	HRRZ D,(D)		;INFERIOR PTR FROM GFRKS TABLE.
	AOS Q1			;DOWN LEVEL
	CALL FSTRUC		;RECURSIVE CALL TO DO ENTIRE SUBTREE
	SOS Q1			;UP LEVEL
	MOVE D,SAVHD		;RESTORE HANDLE
	HLRZ D,(D)		;PARALLEL PTR FROM GFRKS TABLE
	JRST FSTR3		;DON'T REALLOCATE LOCAL STORAGE

;ENTRY POINT.  NOP IF 0 PTR GIVEN.

FSTRUC:	STKVAR <SAVHD>
FSTR3:	MOVEM D,SAVHD		;SAVE POINTER
	JUMPN D,FSTR1
	RET

;FORK STATUS TYPEOUT SUBROUTINE FOR INFORMATION PROGRAM, ^T, ETC.
;TAKES A FORK HANDLE OR 0 IN A.  IF 0, A LONG RFSTS HAS BEEN SIMULATED
;CONTAINING ALL AVAILABLE INFORMATION (AS WHEN THERE ARE TOO MANY FORKS).

FSTAT::	STKVAR <FHAN,OFORK>
	MOVEM A,FHAN		;REMEMBER HANDLE
	JUMPE A,FSTAT0		;ZERO HANDLE MEANS USE WHAT'S IN LRFSTS
CC,<	MOVEI B,.RFSFL+1>	;CS44 Set up LRFSTS for a long RFSTS
CS,<	MOVEI B,.RFSTA+1>	;CS44 Set up LRFSTS for a long RFSTS
	MOVEM B,LRFSTS+.RFCNT
	HRLI A,(RF%LNG)		;DON'T DESTROY FORK HANDLE IN A
	MOVEI B,LRFSTS
	RFSTS			;GET STATUS IN A, PC IN B
	 ERJMP FSTAT9		;CM236 Program disappeared
CS,<	MOVE A,FHAN		;CS44 Get handle
	MOVEI D,[ASCIZ /at %2Y/] ;CS44 %2Y TYPES PC FROM B
	CAIN A,.FHSLF		;CS44 Is it us?
	 JRST FSTAT8 >		;CS44 We know we are running
FSTAT0:	MOVE B,LRFSTS+.RFPSW	;LOAD STATUS TO DETERMINE MESSAGE
	HLRZ C,B		;B1-17 = STATUS
	CAIN C,-1		;-1 = UNASSIGNED HANDLE. MAYBE A SUPERIOR
	 JRST FSTAT9		;CS44 Program disappeared
	TXZ C,<(RF%FRZ)>	;FLUSH FROZEN BIT
	CAIE C,.RFHLT		;HALT OR FORCED TERM?
	CAIN C,.RFFPT
	TXZ B,RF%FRZ		;YES, WASN'T RESULT OF ^C
	CAIE C,.RFTTY		;TTY I/O WAIT?
	CAIN C,.RFTRP		;JSYS TRAPPED?
	TXZ B,RF%FRZ		;YES, NOT RESULT OF ^C
	TMNE FK%INV,SLFTAB(A)	;CM156 Controlled program
	 CAIE C,.RFIO		;CM156  and waiting for I/O?
	  TRNA			;CM156 No, go on
	  TXZ B,RF%FRZ		;CM156 Yes, probably waiting for typein
	SKIPGE B
	UTYPE [ASCIZ /^C from /] ;"FROZEN" BIT ON
	UTYPE @[[ASCIZ /Running/]
		[ASCIZ \I/O wait\]
		[ASCIZ /Halt/]	;INCLUDES NEVER STARTED
		[ASCIZ /Halt: /]
		[ASCIZ /Fork wait/]
		[ASCIZ /Sleep/]
		[ASCIZ \JSYS/UUO trap\]
		[ASCIZ /Address break/]
		[ASCIZ \TTY I/O wait\] ] (C) ;NOTE INDEX!
	MOVEI D,[ASCIZ / at %2Y/] ;%2Y TYPES PC FROM B
	CAIE C,.RFFPT
	JRST FSTAT8		;GO OUTPUT "AT <PC>"
				;AFTER ERROR STOP, TYPE REASON AS GIVEN
				;BY PSI CHAN # IN RH OF A.  USE TEXT
				;FROM "START" COMMAND'S ERROR MSG TAB.
	HRRZ C,LRFSTS+.RFPSW	;INSTR AT WHY INDEXES BY CHAN THRU C
	MOVE D,@WHY		;WHY TABLE HAS %1X, %2Y AND/OR %3Q
FSTAT8:	MOVE B,LRFSTS+.RFPPC	;LOAD ADDRESS PART OF PC FOR POSSIBLE %Y
	CALL PIOFF		;NO ^C WHILE FORK CELL IS AMUK
	MOVE A,FORK		;GET OFFICIAL CONTENTS OF FORK CELL
	MOVEM A,OFORK		;REMEMBER IT
	MOVE A,FHAN		;GET BACK HANDLE FOR POSSIBLE %X
	MOVEM A,FORK		;PUT IN FORK FOR POSSIBLE %Y
	SETZM SYMOKF		;FORCE REEVALUATION OF SYMBOL TABLE
	UETYPE (D)		;TYPE MSG. INCLUDES PC FROM B.
	MOVE A,OFORK		;GET BACK CORRECT CONTENTS OF FORK CELL
	MOVEM A,FORK		;RESTORE REAL FORK CELL
CC,<	CALLRET PION>		;CS44 ALLOW ^C AGAIN AND RETURN
CS,<				;CS44
	MOVX A,.FHSLF		;EM6 
	RWM%			;EM6 Get waiting/in progress channels
	TXNE B,<1b3>		;EM6 Level 3 (^T) active?
	 SKIPE CTTFLG		;EM6 Verbose flag set?
	  SKIPA			;EM6 Do the verbose mode
	 CALLRET PION		;EM6 No mem/queue status
	CALL PION		;CS44
	HRRZ B,LRFSTS+.RFWSS	;CS44 Current
	MOVE C,LRFSTS+.RFSTA	;CS44 Queue
	ETYPE < Mem=%2Q>	;CS44
	TXNN C,RF%WSL		;CS44 Is working set loaded?
	 ETYPE <*>		;CS44 Print a * if no
	TXNN C,RF%IBS		;CS44 In balance set?
	 ETYPE <#>		;CS44 Print a # if no
	ANDI C,RF%QN		;CS44
	ETYPE < Q=%3Q>		;CS44
	RET
> ;CS44 end CS

FSTAT9:	ETYPE <Program disappeared> ;CS44
	RET			;CS44

;PISTAT
;PSI IS OFF, LEVTAB=NNNNNN, CHNTAB=NNNNNN, CHN MASK=NNNNNNNNNNNN, BIP=N

.PISTA::SKIPGE 1,FORK		;CM236
	JRST [	UTYPE [ASCIZ / No program/] ;CM236
		JRST EOLRET]
;*** CM236 5 lines deleted (more or less moved down to PISTA1) ***
	RIR
	 ERJMP [MOVEI 3,3	;FAILED - TRY IT EXTENDED - GET ARG LENGTH
		MOVEI B,3	;READ LEVTAB INTO AC 4, CHNTAB INTO AC 5
		XRIR%
		 ERJMP CJERRE	;CM236 May be XCT-only
		JRST PISTA1]
	HLRZ 4,2		;GET ADDRESS OF LEVTAB
	HRRZ 5,2		;GET ADDRESS OF CHNTAB
PISTA1:	UTYPE [ASCIZ / PSI is /] ;CM236
	MOVEI 3,[ASCIZ /on/]	;CM236
	SKPIR%			;CM236 Information available?
	MOVEI 3,[ASCIZ /off/]	;CM236
	UTYPE 0(3)		;CM236
	RCM
	MOVE 6,1		;GET CHANNEL MASK
	MOVE 1,FORK
	RWM
	HLLZ 2,2
	ETYPE <, LEVTAB=%4y, CHNTAB=%5y
 Levels in progress = %2U
 Channels enabled = %6U
 Channels Waiting = %1U>
	JRST EOLRET

;DSKSTAT

.DSKST::TRVAR <<DSCBUF,FILWDS>,DSKCN1,DSKCN2,DSKFL1,DSKFL2,EPFLG,EPDIR,EPWLS,ODSANM,<ODSPM,2>> ;CS138
	SKIPN CUSRNO		;CM142 Logged in?
	JRST DSKSTS		;CM142 No, make it simple
	NOISE <OF DIRECTORY>
	CALL CURNMS		;INPUT DIRECTORY NAME, GET # AND BITS IN A
	 ERROR <No such directory>
	MOVEM A,EPFLG		;SAVE THE FLAGS FROM RCDIR
	MOVEM B,EPWLS		;SAVE THE POINTER TO THE STRING
	MOVEM C,EPDIR		;SAVE THE DIR #
	CONFIRM
	SETZM ODSANM		;CS138 Clear group number
	SETZM DSKFL1		;CLEAR IN USE
	SETZM DSKFL2		;CLEAR DELETED
	SETZM DSKCN1		;CLEAR ASSIGNED
	SETOM DSKCN2		;FLAG FOR .GT. 1 DIR
DSKSTL:;CM290 CS Subdirectories don't have quota, add up disk space used
;         in subdirectories
CS,<	SKIPL DSKCN2		;OTHER THAN FIRST DIR?
	ETYPE <%_>		;YES, BLANK LINE
	MOVE A,EPDIR		;GET DIR NUMBER
	ETYPE < %1R
>				;PRINT IT
	CALL DSKSPC		;compute space used in subdirs
	ETYPE < %2Q Pages assigned>
	CAME A,[377777,,0]	;give working quota if there is one
	ETYPE <, %1Q Pages working quota>
	ETYPE <%_ %4Q Pages used in allocation group, %3Q allowed%_>
	AOS DSKCN2		;COUNT 1 DIR
	ADDM B,DSKCN1		;total assigned

> ;CS CM290
CC,<				;CM290
	MOVE A,EPDIR		;DIR TO COUNT PAGES FROM
	CALL DSKCNT		;COUNT PAGES
	SKIPL DSKCN2		;OTHER THAN FIRST DIR?
	ETYPE <%_>		;YES, BLANK LINE
	MOVE A,EPDIR		;GET DIR NUMBER
	ETYPE < %1R
>				;PRINT IT
	GTDAL			;GET WHAT SYSTEM THINKS
	ADDM B,DSKCN1		;TOTAL ASSIGNED
	ADDM D,DSKFL1		;TOTAL IN USE
	AOS DSKCN2		;COUNT 1 DIR
	ADDM Q2,DSKFL2		;TOTAL DELETED
	ETYPE < %2Q Pages assigned>
	SKIPE Q2		;DON'T PRINT IF 0 DELETED
	ETYPE <, %4Q in use, %6Q deleted>
	TLNE Z,F3
	ETYPE <
 Excluding file(s) that are list protected from you>
	ETYPE <
 %1Q Working pages, %3Q Permanent pages allowed
>
	JUMPE B,DSKSOK		;CAN'T BE OVER IF 0 USAGE
	MOVE D,B
	SUB B,A
	SUB D,C
	MOVE A,EPDIR		;DIRECTORY FOR PRINTOUT
	SKIPLE D
	ETYPE < Over permanent storage allocation by %4Q page(s).
>
	SKIPLE B
	ETYPE < Over working storage allocation by %2Q page(s).
>
> ;CC CM90
DSKSOK:	CALL RLJFNS		;RELEASE JFNS FROM DSKCNT
	MOVE A,EPDIR		;NOW STEP TO THE NEXT DIR (IF ANY)
	MOVE B,EPWLS		;GET POINTER TO ORIGINAL STRING
	MOVE C,EPFLG		;GET FLAGS
	TXNE C,RC%WLD		;ANY WILD CARD CHARACTERS IN STRING?
	CALL STPDIR		;YES, GO STEP THE DIR NUMBER
	 JRST SYSFRE		;NO MORE DIRS, PRINT SYSTEM
	MOVEM A,EPDIR		;SAVE THE NEW DIR NUMBER
	JRST DSKSTL		;LOOP BACK FOR THE OTHER DIRS

SYSFRE:	SKIPG DSKCN2		;.GT. 1 DIR PRINTED?
	JRST SYSFR1		;NO, NO SUMMARY
	MOVE A,DSKCN1		;GET ASSIGNED
	ETYPE <
 Total of %1Q Pages assigned>
CC,<				;CM290
	MOVE A,DSKFL1		;GET IN USE
	SKIPE B,DSKFL2		;GET DELETED
	ETYPE <, %1Q in use, %2Q deleted>
> ;CC CM290
	AOS A,DSKCN2		;MAKE # OF DIRS AND LOAD
	ETYPE <, in %1Q directories.
>
SYSFR1:	HRROI A,DSCBUF		;POINTER TO FREE SPACE
	MOVE B,EPDIR		;DIRECTORY NUMBER ASKED ABOUT
	DIRST			;GET DIRECTORY NAME WRITTEN INTO FREE SPACE
	 ERCAL JERRE		;THIS SHOULD NOT FAIL
	HRROI B,[ASCIZ /GET.NAM/]	;PUT IN A RANDOM FILE SPEC
	MOVEI C,0		;END ON NULL
	SOUT			;NOW WE'VE GOT COMPLETE FILESPEC
	LDF A,GJ%OFG+GJ%SHT	;SHORT FORM GTJFN, NAME ONLY( NO REAL FILE)
	HRROI B,DSCBUF		;POINTER TO FILESPEC
	CALL GTJFS		;PARSE THE FILESPEC( FOR STRUCTURE NAME)
	 CALL JERR		;SHOULDN'T FAIL FOR JUST A PARSE!
	MOVE B,A		;PUT JFN IN B
	HRROI A,DSCBUF		;POINTER TO FREE SPACE
	LDF C,1B2		;SPECIFY DEVICE FIELD, NO PUNCUATION
	JFNS			;ISOLATE THE STRUCTURE NAME
	MOVEI B,0		;END WITH NULL
	IDPB B,A
DSKSTD:				;CM142
	HRROI A,DSCBUF		;POINT AT STRUCTURE NAME
	STDEV			;GET THE DEVICE DESIGNATOR FOR STRUCTURE
	 CALL JERRE		;ERROR CODE IN B, UNEXPECTED ERROR
	MOVE A,B		;PUT DESIGNATOR IN A
	GDSKC
	HRROI C,DSCBUF		;GET POINTER TO STR NAME
NONEWF,<
	ETYPE < %2Q Pages free on %3M:%_>
>
NEWF,<
	ETYPE < %2Q Pages free on %3M:, %1Q pages used.%_>
>
	RET
;CM290 *** Begin ***
; DSKPSC - compute disk space used by inferior directories
; A/ Directory number
; CALL DSKSPC
; Returns+1:Always, prints a warning message if over quota
;  A/ Working quota limit of directory
;  B/ Number of pages used in directory
;  C/ Permenant allocation of allocation group
;  D/ Number of pages used by allocation group

CS,<
DSKSPC:	STKVAR <DSNM,DSANM,DSSS,DSPM,<DSQT,2>,<DSNAM,FILWDS>>
	MOVEM A,DSNM		;save directory number
	MOVEM A,DSANM		;directory number of allocation center
	GTDAL%			;get disk allocation
	DMOVEM A,DSQT		;directory quota info
	MOVEM B,DSSS		;disk space in allocation group
	MOVEM C,DSPM		;permenant quota
	HRROI A,DSNAM		;put the directory name here
	MOVE B,DSNM		;from this directory
	DIRST%
	 CALL JERRC
	SKIPN DSPM		;is this directory an allocation center?
	IFSKP.			;yes
	   EXCH B,ODSANM	;update last group checked
	   CAME B,ODSANM	;same group as last one done?
	   JRST DSKSP1		;yes but no...start from here
DSKSPZ:	   DMOVE A,DSQT		;get usage/quota numbers
	   DMOVE C,ODSPM	;get previously computed quota & usage
	   JRST DSKS90		;and done...
	ENDIF.
	MOVE A,[POINT 7,DSNAM]	;look though the directory name
DSKSP0:	ILDB B,A		;to find the top level
	CAIE B,"."		;a .
	CAIN B,76		;or the closing bracket?
	SKIPA			;yes
	JRST DSKSP0

;get allocation info from top level
	MOVE D,A		;save pointer for groveling around subdirs
	MOVEI B,76		;get allocation info from top level
	DPB B,A
	SETZ B,
	IDPB B,A
	MOVX A,RC%EMO		;get top level directory number
	MOVE B,[POINT 7,DSNAM]	;from this name
	RCDIR%
	MOVE A,C		;directory number
	CAMN A,ODSANM		;same as last one done?
	JRST DSKSPZ		;yes - don't recompute...
	MOVEM A,ODSANM		;update last group computed
	MOVEM A,DSANM		;save directory number of allocation group
	GTDAL%
	MOVEM B,DSSS		;save initial space used for group
	MOVEM C,DSPM		;save perminant aloc for group
	MOVE A,D		;get byte pointer for subdir hacking

DSKSP1:	MOVEI B,"."		;put on the .*)
	DPB B,A
	MOVEI B,"*"
	IDPB B,A
	MOVEI B,76
	IDPB B,A
	SETZ B,
	IDPB B,A
	
	MOVX A,RC%AWL		;find the first directory
	MOVE B,[POINT 7,DSNAM]	;point to wild names of subdirs
	RCDIR%			;get the first directory number
	TXNE A,RC%NOM		;where there any?
	 JRST DSKSP9		;no, no space used then
	MOVE A,C		;current number

;loop to get disk space used of subdirectories
DSKSP2:	MOVEM A,DSNM		;save the directoy number
	GTDAL%			;get its disk usage
	ADDM B,DSSS		;record space used
	MOVE A,DSNM		;get directory number
	HRLI B,(POINT 7,)	;point to wild names of subdirs
	HRRI B,DSNAM
	CALL STPDIR		;step to the next dir
	SKIPA			;no more
	JRST DSKSP2		;more, go process them

DSKSP9:	DMOVE A,DSQT		;info for current directory
	MOVE C,DSPM		;permenant quota
	MOVE D,DSSS		;usage
	DMOVEM C,ODSPM		;stash for cache usage later...
DSKS90:	CAMG D,C		;under quota?
	 RET			;yes
	MOVE A,C		;print a warning
	SUB A,D
	MOVN A,A
	MOVE B,DSANM		;allocation group directory number
	MOVEM B,ODSANM		;save for caching purposes...
	ETYPE <%%Allocation group %2R is %1Q pages over quota%_>
	DMOVE A,DSQT
	RET
> ;CS
;CM290 *** End ***

DSKSTS:	CONFIRM			;CM142
	HRROI A,DSCBUF		;CM142 Use usual structure
	HRROI B,[ASCIZ/PS/]	;CM142
	SETZ C,			;CM142
	SOUT%			;CM142
	JRST DSKSTD		;CM142 Go rejoin normal code

DSKCNT:	SETZB D,Q2		;FOR SUMS OF TOTAL AND DELETED PAGES
	MOVE B,A		;DIR NUMBER TO B
	HRROI A,DSCBUF		;GET STRING SPACE POINTER
	CAMN B,[-1]		;DEFAULT DIRECTORY?
	JRST DSKCN0		;YES
	DIRST			;STORE DIR STRING
	 CALL CJERR		;WE JUST SCANNED IT?!
DSKCN0:	MOVE B,A
	HRROI A,[ASCIZ /*.*/]
	SETZ C,			;READ TO NULL
	SIN			;APPEND TO STRING
	MOVX A,GJ%OLD!GJ%DEL!GJ%IFG!GJ%PHY!GJ%SHT	;OLD, *'S, SHORT CALL, INCL. DELETED, PHYSICAL DEVICE ONLY
	HRRI A,.GJALL		;* VERSION
	HRROI B,DSCBUF		;GET STRING POINTER
	CALL GTJFS		;GET JFN
	CALL [	CAIE A,GJFX20
		CAIN A,GJFX32
		JRST [	SUB P,[XWD 1,1]	;FOR NO FILES IN DIRECTORY,
			SETZ Q3,	;CLEAR TOTAL
			RET]		;TYPE "0 PAGES"
		JRST CJERR]
	MOVE Q1,A

;LOOP OVER FILES WITH GNJFN

DSKST1:	TLZ Z,F1		;RESET DELETED BIT
	HRRZ A,Q1		;JFN ONLY
	MOVE B,[XWD 1,.FBCTL]	;CONTROL BITS WORD OF FDB
	MOVEI C,C		;TO BE PUT IN C
	CALL $GTFDB		;GET IT
	JRST DSKST2		;COULDN'T
	TLNE C,(FB%DEL)		;DELETED?
	TLO Z,F1		;YES, SAY SO
	MOVE B,[XWD 1,.FBBYV]	;# PAGES IN RH
	MOVEI C,C
	CALL $GTFDB		;DO GTFDB JSYS, NO SKIP IF NO ACCESS
DSKST2:	TLOA Z,F3		;SAY ACCESS ERROR AND SKIP ADD
	 JRST DSKST4		;GO ADD UP PAGES
DSKST3:	MOVE A,Q1		;JFN AND FLAGS
	CALL $GNJFN		;CM236 STEP TO NEXT FILE
	 JRST .+2		;NO MORE FILES
	JRST DSKST1
	MOVE Q3,D		;FORM SUM
	ADDI Q3,(Q2)		;OF DELETED AND UNDELETED
	RET			;PRINT RELEVANT NUMS, RELEASE JFN

DSKST4:	TLNE Z,F1		;SUM DELETED OR UNDELETED
	JRST .+3
	ADDI D,(C)		;UNDELETED TOTAL
	JRST DSKST3
	ADDI Q2,(C)		;DELETED TOTAL
	JRST DSKST3

;CHECK CONNECTED DIRECTORY FOR EXCEEDING DISK ALLOCATION
;USED BY LOGIN, LOGOUT, CONNECT

CHKDAL::GJINF
CHKDL3::			;CM290
CS,<	MOVE A,B		;CM290
	JRST DSKSPC >		;CM290 check alloction group
CC,<				;CM290
	MOVE D,B		;SAVE CONNECTED DIR
	MOVE A,B		;PUT DIR NUM IN A
	GTDAL			;GET QUOTA AND CURRENT ALLOC
	 ERJMP R		;DON'T TRY TO PRINT OVER QUOTA IF THIS FAILS
	JUMPE B,R		;NO MESSAGE IF 0 USAGE
	CAME D,LIDNO		;IS THIS LOGGED IN DIR?
	JRST CHKDA1		;NO, CHECK PERM STORAGE
	SUB B,A			;GET AMOUNT OVER WORKING QUOTA
	SKIPLE B		;SKIP IF NOT OVER
	ETYPE < %4R Over working storage allocation by %2Q page(s).
>
	RET

CHKDA1:	SUB B,C			;GET AMOUNT OVER PERMANENT QUOTA
	SKIPLE B		;SKIP IF NOT OVER
	ETYPE < %4R Over permanent storage allocation by %2Q page(s).
>
	RET
> ;CS CM290

;INFORMATION ABOUT MAIL
;TELLS IF THERE IS NEW MAIL FOR A USER
;DEFAULTS TO SELF

.MALST::NOISE <FOR USER>
;CM114 NONEWF,<
REPEAT 1,<			;CM114 Disallow "I mail system" at CMU
	CALL USRNAM		;CS92 GET USER NAME. DEFAULT TO SELF
	 ERROR <No such USER>
>
;CM114 NEWF,<
REPEAT 0,<			;CM114 Disallow "I mail system" at CMU
	CALL USRNAM		;GET USER NAME. DEFAULT TO SELF
	 JRST [	MOVEI B,[FLDDB. .CMKEY,,[1,,1
					 [ASCIZ "SYSTEM"],,0]]
		CALL FLDSKP
		 ERROR <No such USER>
		CONFIRM
		HRROI B,[GETSAVE <SYS:MS.>]
		CALL TRYGTJ
		 RET
		PUSH P,[CMDIN2]	;RETURN HERE
		MOVEI B,1	;OFFSET 1
		CALLRET REPH1]	;RUN MS AS EPHEMERON
>
	MOVE B,C		;USER NUMBER IN B
	CONFIRM
	CALL MALCHK		;SEE IF THAT USER HAS ANY NEW MAIL
	 JRST MALSTF		;MAIL.TXT NOT READABLE OR NO MAIL
NEWF,<				;STRING PNTR IN A
	JUMPE A,[UTYPE [ASCIZ / New mail exists/] ;CM317
		 JRST EOLRET]	;CM317
;CM236	TLNN B,77		;CHECK NET-MAIL
;CM236	 JRST [	ETYPE < Netmail %1\>
;CM236		JRST EOLRET]
	ETYPE < New mail %1\>	;CM317
	JRST EOLRET
>
NONEWF,<
	UTYPE [ASCIZ / New mail exists/]
	JRST EOLRET
>
MALSTF:	JUMPE A,MALSTN		;IF ZERO NO MAIL
	UTYPE [ASCIZ / Mailbox protected/]
	JRST EOLRET

MALSTN:	UTYPE [ASCIZ / No new mail exists/]
	JRST EOLRET

NEWF,<
;INFORMATION ABOUT ALERTS

.ALRST::NOISE <PENDING>
	CONFIRM
	SKIPG A,ALRTIM		;ANY PENDING?
	 JRST ALRST4		;NO
	ETYPE < Next alert at %1D %1E>
	SKIPE B,REASON		;USER MESSAGE
	 TYPE < - >
	ETYPE <%2\%%_>
	MOVSI D,-NALTS		;CHECK FOR MORE
ALRST2:	SKIPG A,ALRTMS(D)	;ANY?
	 JRST ALRST3		;EMPTY SLOT - GO ON
	TLON Z,F1		;FIRST TIME FLAG
	 TYPE < Other alerts set for:
>
	ETYPE <   %1D %1E>
	SKIPE B,REASON+1(D)	;MESSAGE TABLE
	 TYPE < - >
	ETYPE <%2\%%_>
ALRST3:	AOBJN D,ALRST2		;LOOP OVER ALL
ALRST5:	TYPE <
 Alerts are >
	SKIPN IITSET		;IF THE ALERT TIMER IS SET THER'RE AUTOMATIC
	TYPE <not >
	TYPE <automatic
>
	RET			;DONE

ALRST4:	TYPE < No alerts set
>
	JRST	ALRST5		;TELL IF THEY'RE AUTOMATIC AND RETURN

;INFORMATION (ABOUT) DOWNTIME

REPEAT 0,<			;CM224 None such

.DOWNT::SETOM TYPING		;SAY OUTPUT IN PROGRESS
	HRROI B,[GETSAVE <SYS:MHALT.>]
	CALL TRYGTJ
	 RET
	MOVEI B,2		;START AT OFFSET 2
	CALLRET REPH1

>;REPEAT 0			;CM224 (the close bracket on the next line
				; is supposed to be there - it matches a
				; NEWF above...)
>

;MEMSTAT
;TYPES, FOR CURRENT FORK, # PAGES, ENTRY VECTOR,
;AND A TABLE GIVING IDENTITY OF EACH PAGE IN FORK.

.MEMST::SKIPGE A,FORK		;CM236
	JRST [	UTYPE [ASCIZ / No program/]
		JRST EOLRET]
	RCM%			;CM236 Will fail if XCT-only
	 ERJMP CJERR		;CM236

	TRVAR <LPC,NPGS>
	SETOM LPC		;LAST PAGE COUNTED
	SETZM NPGS		;NO PAGES YET
	MOVEI A,BUF0		;MAKE BYTE POINTER FOR BUILDING MESSAGE
	HRLI A,440700
	MOVEM A,COJFN

;SUBROUTINE TO TYPE MEMORY MAP FOR CURRENT FORK, FOR MEMSTAT.
;ACS:	D: PAGE #
;	Q1 & Q2: IDENTITY OF CURRENT PAGE, A LA RMAP A & B.
;	P3, P4: SAVED IDENTITY OF 1ST PAGE OF GROUP.
;	Q3: INCREMENT FOR PAGE # IN GROUP OF CONSECUTIVE PAGE IDENTITIES.

MEMMXL==FILCRS+^D80		;MAXIMUM NUMBER OF CHARACTERS IN AN OUTPUT LINE OF INFO MEM
	SETZ D,

;FIND EXISTING PAGE (TREAT INDIRECT POINTERS AS EXISTING)

MMAP1:	HRL A,FORK
MMAP2:	HRRZ B,COJFN		;SEE WHAT WORD WE'RE WRITING INTO
	CAIL B,BUFEND-MEMMXL/5	;AT END OF BUFFER?
	JRST [	CALL FIXIO	;REVERT IO TO REAL OUTPUT, SO WARNING GETS SEEN
		ETYPE <%%Memory map too fragmented for internal buffer - partial map being displayed...%_>
		JRST MMD1]
	CAIL D,HIGHPN+1
	JRST MMAPDN		;NO MORE PAGES, DONE
	HRR A,D
	RPACS
	 ERJMP [SETZ B,		;CURRENTLY FAILS IF NO SUCH SECTION
		ADDI D,777	;FAKE NON-EXISTANT PAGE AND SKIP
		JRST .+1]	; TO NEXT SECTION FOR SPEED
	TXNN B,PA%PEX!PA%IND
	AOJA D,MMAP2		;DOESN'T EXIST, TRY NEXT

;FOUND ONE, PRINT NUMBER

	CALL PAGID		;GET FULL IDENTITY
	 JRST .+1		;3-RETURN SUBR, BUT IRRELEVANT HERE.
	 SKIPA P3,Q1
	MOVE P3,Q1		;SAVE IDENTITY FOR LATER COMPARISONS
	MOVE P4,Q2		;...AND PRINTING
	SETZ Q3,		;INIT # CONSECUTIVE IDENTITIES
	HRRZ B,D
	CALL TOCT		;PRINT PAGE NUMBER IN OCTAL

;LOOK AT IDENTITY OF NEXT PAGE

	CALL NPAGID		;STEPS D AND GETS IDENTITY
	 SOJA Q3,MMAP10		;DIFFERENT, GO TYPE IDENTITY
	 JRST MMAP6		;NEXT HIGHER IN SAME FILE OR FORK

;IDENTICAL, SEE HOW MANY MORE ARE

	CALL NPAGID
	 JRST .+1		;DIFFERENT
	 TDZA Q3,Q3		;NEXT HIGHER - SAY IDENTICAL NOT CONSEC GROUP
	JRST .-3		;IDENTICAL, KEEP LOOKING
	JRST MMAP7		;GO PRINT "-# <FILE OR FORK> #

;GET HERE WHEN DONE MAKING TEXT

MMAPDN:	CALL FIXIO		;REVERT TO REAL OUTPUT STREAM
MMD1:	MOVE A,NPGS		;GET NUMBER OF PAGES
	ETYPE <%_%%1Q. pages>

;PRINT ENTRY VECTOR

	MOVE A,FORK
	CALL GETENT		;GET ENTRY VECTOR
	JUMPE B,MEMS3		;NONE
	ETYPE <, Entry vector loc %3y len %2O>
MEMS3:	ETYPE<%_>
	SKIPN NPGS		;ANY PAGES?
	RET			;NO, DONE!
	ETYPE<%_>
	UETYPE BUF0		;TYPE REST OF MESSAGE
	CALLRET UNMAP		;UNMAP BUFFER PAGES USED FOR TEXT

;NEXT HIGHER OF SAME FILE OR FORK, SEE HOW MANY MORE ARE CONSECUTIVE

MMAP6:	CALL NPAGID
	 JRST .+2		;DIFFERENT
	 JRST .-2		;CONSECUTIVE, KEEP LOOKING

;PRINT "-#" FOR GROUP OF IDENTICAL OR CONSECUTIVE PAGES

MMAP7:	PRINT "-"
	MOVEI B,-1(D)		;LAST IN GROUP WAS THE PREVIOUS PAGE
	CALL TOCT		;TYPE IN OCTAL

;MMAP...
;PRINT IDENTITY OF PAGES WHOSE #'S WE HAVE JUST PRINTED:
;TYPICALLY FORK OR FILE NAME, # FOR A SINGLE PAGE OR IDENTICAL GROUP,
; #-# FOR CONSECUTIVE GROUP. ALL PRECEDED BY @ IF INDIRECT.

MMAP10:	PRINT TAB
	PRINT " "
	TXNE P4,PA%IND
	UTYPE [ASCIZ /@ /]	;INDICATE INDIRECT POINTER
	TXNN P4,PA%PEX		;DOES PAGE EXIST?
	JRST [	UTYPE [ASCIZ /No page/] ;CAN HAPPEN WITH INDIRECT.
		JRST MMAP13]
	TXNE P4,PA%PRV
	JRST [	UTYPE [ASCIZ /Private/]
		JRST MMAP13]
	CAMN P3,[-1]		;RMAP RETURNS -1 IF NO JFN FOR FILE
	JRST [	UTYPE [ASCIZ /Forgotten file/]
		JRST MMAP13]
	LDB B,[POINT 9,P3,17]	;JFN OR FORK #
	TXNE P3,1B0		;ON IF FORK
	JRST [	UETYPE [ASCIZ /Fork %2O/]
		JRST MMAP11]
	ETYPE <%2S>		;PRINT FILNAME
MMAP11:	TYPE <  >
	HRRZ B,P3
	CALL TOCT		;PAGE # IN FILE OR FORK
	JUMPLE Q3,MMAP13	;0 INDICATES ONE PAGE ONLY
	PRINT "-"
	ADDI B,-1(Q3)		;DON'T COUNT LAST PAGE TESTED!
	CALL TOCT		;PAGE # OF LAST PAGE OF CONSECUTIVE GROUP
MMAP13:	TYPE (  )
	TLZ Z,F1		;USED BY "BEFORE"
	TXNN P4,PA%RD
	JRST .+3
	CALL BEFORE		;TYPE COMMA OR EOL BETWEEN ITEMS
	PRINT "R"
	TLNN P4,F3
	JRST .+3
	CALL BEFORE		;SUBR WITH "AVAIL DEVICES"
	PRINT "W"
	TXNN P4,PA%CPY
	JRST .+3
	CALL BEFORE
	TYPE <CW>		;COPY-ON-WRITE
	TXNN P4,PA%EX
	JRST .+3
	CALL BEFORE
	PRINT "E"
	ETYPE<%_>
	JRST MMAP1		;GO BACK FOR ANOTHER PAGE OR GROUP

;SUBROUTINE FOR MMAP TO GET AND COMPARE IDENTITY OF PAGE
;TAKES IN D: PAGE #, IN P3, P4: IDENTITY OF FIRST PAGE IN GROUP,
; IN Q3: PAGE # INCREMENT FOR CONSECUTIVE GROUP.
;RETURNS: Q1, Q2: IDENTITY OF PAGE, A LA RMAP.
;	+1: DIFFERENT IDENTITY FROM FIRST PAGE OF GROUP
;	+2: NEXT HIGHER PAGE # (THAN P4+Q3, Q3), Q3 INDEXED
;	+3: IDENTICAL
;IF D > 37777, BEHAVES AS THOUGH CURRENT PAGE IS NON-EXISTENT.
;CLOBBERS A,B.

NPAGID:	AOJ Q3,			;ENTRY FOR NEXT PAGE
	AOSA A,D
PAGID:	MOVE A,D		;ENTRY TO NOT INDEX PAGE #
	SETZ Q1,		;FOR NON-EXISTENT OR PRIVATE PAGE
	CAIL A,HIGHPN+1
	JRST [	MOVX Q2,PA%PEX	;PAGES OVER HIGHPN DON'T EXIST
		JRST PAGID8]
	HRL A,FORK
	MOVE C,A		;GET COPY OF HANDLE TO CHECK FOR PRIVATENESS
	RMAP			;GET PAGE INFORMATION
	 ERJMP [SETZ B,		;CURRENTLY FAILS IF NO SUCH SECTION
		JRST .+1]	;FAKE NO SUCH PAGE FOR NOW
	CAMN A,C		;DID RMAP RETURN SAME HANDLE AS GIVEN?
	TXO B,PA%PRV		;YES, SO PAGE IS PRIVATE
	HLLZ Q2,B		;RETURN RPACS INFO IN Q2
	MOVE Q1,A		;REMEMBER IDENTIFIER
	TXNN Q2,RM%PEX		;DOES PAGE EXIST?
	JRST PAGID8		;NO - SKIP THIS
	HRRZ C,C		;YES - SEE WHAT PAGE THIS IS
	CAMG C,LPC		;LARGER THAN ONE ALREADY COUNTED?
	JRST PAGID8		;NO - DON'T COUNT IT AGAIN
	MOVEM C,LPC		;YES - REMEMBER LARGEST COUNTED
	AOS NPGS		;COUNT NUMBER OF EXISTENT PAGES

;COMPARISON TO DETERMINE WHETHER SAME AS PREVIOUS PAGE
;COMPARE THAT INFO WHICH IS PRINTED:
; ALL Q1, Q2 BITS 2-6, 9, 10.

PAGID8:	MOVE A,Q1
	XOR A,P3
	TLNE A,-1
	RET			;DIFFERENT FILES OR FORKS - NORMAL RETURN
	MOVE B,Q2		;RMAP'S ACCESS IS WRONG
	XOR B,P4
	TLNE B,<37B6+3B10>B53
	RET			;DIFFERENT ACCESS - NORMAL RETURN
	TRNE A,-1
	JRST PAGI81
	AOS (P)			;SAME IDENTITY INCLUDING PAGE # - 2-SKIP RETURN
	AOS (P)
	RET

PAGI81:	MOVE A,Q3
	ADD A,P3
	SUB A,Q1
	TRNN A,-1
	AOS (P)			;NEXT HIGHER PAGE # - SKIP RETURN
	RET			;REALLY DIFFERENT PAGE - NORMAL RETURN

;INFORMATION (ABOUT) ARPANET

.IARPA::KEYWD $IARPA
	 T STATUS,ONEWRD,.ANSTS
	 JRST CERR
	JRST (P3)

$IARPA:	TABLE
	T STATUS,ONEWRD,.ANSTS
	TEND

;INFORMATION (ABOUT) APRANET STATUS

.ANSTS:	MOVE A,[SIXBIT /NETRDY/]
	SYSGT			;GET NETWORK STATUS TABLE
	MOVEM B,NETRDY		;SET UP FOR GTB
	HRR A,B			;GET TABLE NUMBER
	HRLI A,1		;MUST DO THIS GETAB HERE TO SEE IF THE
	GETAB			; TABLE EXISTS
	 JRST [	ETYPE <%%No ARPANET%_>
		RET]
	TYPE < ARPANET service is >
	JUMPN A,[TYPE <enabled
>
		JRST NTST01]
	TYPE <disabled
>
NTST01:	TYPE < The IMP interface is >
	MOVEI D,0		;SEE IF IMP IS UP
	GTB .NETRD
	JUMPE A,[TYPE <down
>				;IF ZERO, IMP IS DOWN
		JRST NTST02]
	JUMPG A,[TYPE <initializing
>				;IF POSITVE, IMP IS INITIALIZING
		JRST NTST02]
	TYPE <up
>				;IF NEGATIVE, IMP IS UP
NTST02:	MOVEI D,6		;GET TIME OF LAST IMP UP TIME
	GTB .NETRD
	SKIPLE A
	ETYPE < Most recent IMP ready line on-transition: %1W
>
	MOVEI D,5		;AND LAST DOWN TIME
	GTB .NETRD
	SKIPLE A
	ETYPE < Most recent IMP ready line off-transition: %1W
>
	RET			;END OF STATUS PRINTING

;INFORMATION (ABOUT) DECNET

.IDECN::KEYWD $IDECN
	 T NODES,ONEWRD,.DNTOP
	 JRST CERR
	JRST (P3)

$IDECN:	TABLE
	T DESCRIPTION,ONEWRD,.DNDES ;CM356
	T NODES,ONEWRD,.DNTOP
	TEND

REPEAT 0,<
;INFORMATION (ABOUT) DECNET STATUS

.DNSTS:	MOVEI A,BUFL-BUF0-.NDNLN-1	;WORDS AVAILABLE FOR LINE TABLE
	MOVEM A,BUF0+.NDNLN	;TO COUNT WORD
	MOVEI A,.NDGLI		;FUNCTION
	MOVEI B,BUF0
	NODE
	 ERCAL DNTOPE
	HLRZ A,BUF0+.NDNLN	;GET COUNT OF RETURNED NODES
	JUMPE A,DNSTSX
	MOVN A,A
	HRLZ A,A
	HRRI A,BUF0+.NDNLN+1	;WE NOW HAVE AOBJN POINTER
DNSTS3:	MOVE B,(A)		;GET POINTER TO NODE BLOCK
	MOVE C,.NDLST(B)	;GET LINE STATE
	HRROI D,[ASCIZ /unknown/]
	CAIN C,.NDLON
	HRROI D,[ASCIZ /on line/]
	CAIN C,.NDLOF
	HRROI D,[ASCIZ /off line/]
	CAIN C,.NDLCN
	HRROI D,[ASCIZ /controller loopback/]
	CAIN C,.NDLCB
	HRROI D,[ASCIZ /cable loopback/]
	MOVE C,.NDLNM(B)	;GET PORT NUMBER
	MOVE B,.NDLND(B)	;POINTER TO NODE NAME
	ETYPE < Line %3O, Node %2M, State is %4M%%_>
	AOBJN A,DNSTS3
	RET

DNSTSX:	ETYPE <%%No DECNET status%_>
	RET
>	;END OF REPEAT 0

;INFORMATION (ABOUT) DECNET NODES

.DNTOP:	TRVAR <NDTYP>
	MOVEI B,BUF0		;READ THE LOCAL NODE NAME INTO
	HRROI A,BUF0+1		; THE FIRST 10 WORDS OF BUF0
	MOVEM A,BUF0+.NDNOD
	MOVEI A,.NDGLN		;GET THE LOCAL NODE NAME
	NODE
	 ERCAL DNTOPE
	MOVEI A,BUFL-BUF0-10-.NDNND-1
	MOVEM A,BUF0+10+.NDNND	;SAVE NUMBER OF WORDS AVAILABLE FOR THE TABLE
	MOVEI A,.NDGNT		;READ THE NODE TABLE
	MOVEI B,BUF0+10
	NODE
	 ERCAL DNTOPE
	HLRZ A,BUF0+10+.NDNND	;GET COUNT OF RETURNED NODES
	JUMPE A,DNTOPX		;IF NONE, SAY SO
	HRROI B,BUF0+1		;SAY WHAT THE LOCAL NODE IS
	ETYPE < Local DECNET node: %2M%%_>
	MOVN A,BUF0+10+.NDNND	;MAKE AN AOBJN POINTER TO THE LIST
	HRRI A,BUF0+10+.NDBK1
	ADD A,[1,,0]
	PUSH P,A
	TLO Z,F2		;INDICATE A TAB IS WANTED BETWEEN ITEMS

;MOVE ALL THE STRING POINTERS INTO THE TABLE; SKIP THOSE WHICH ARE OFF-LINE

	MOVEI C,.NDSON		;GET NODE ON-LINE FLAG
DNTOP0:	MOVE B,(A)		;GET POINTER TO NODE BLOCK
	CAME C,.NDSTA(B)	;IS THE NODE ON-LINE?
	JRST DNTOP1		;NO - SKIP IT
	MOVE B,.NDNAM(B)	;YES - GET NODE NAME POINTER
	MOVEM B,(A)		;SAVE IT IN NODE TABLE
	AOBJN A,DNTOP0		;LOOP THROUGH TABLE

;NOW LOOP THROUGH THE STRINGS - OUTPUT THE LOWEST ALPHABETICALLY,
;ELIMINATE IT, AND LOOP

DNTOP2:	POP P,A			;GET THE AOBJN POINTER AGAIN
	SETOM NDTYP		;SAY NO NODES HAVE BEEN PRINTED YET
DNTOP3:	SKIPN D,(A)		;GET FIRST STRING POINTER - ANY?
	JRST DNTOP7		;NO - SKIP THIS ITERATION
	PUSH P,A		;YES - SAVE AOBJN POINTER
	PUSH P,Q1		;CM236 Save a couple of registers for
	PUSH P,Q2		;CM236  temp stuff (name string of node
				; we're currently considering)
	JRST DNTOP5		;SET UP THE FIRST STRING

DNTOP4:	SKIPE D,(A)		;GET A STRING POINTER - ANY?
	CAMGE Q1,(D)		;CM236 YES - IS THIS STRING SMALLER?
	JRST DNTOP6		;NO - SKIP IT
	CAME Q1,(D)		;CM236 First five characters identical?
	IFSKP.			;CM236 Yes
	  CAMG Q2,1(D)		;CM236 Compare second words
	   JRST DNTOP6		;CM236 Larger, skip this node
	ENDIF.			;CM236
DNTOP5:	DMOVE Q1,(D)		;CM236 First or second word smaller, set this
				; node up instead
	MOVE C,A		;GET ITS INDEX, TOO
DNTOP6:	AOBJN A,DNTOP4		;LOOP THROUGH ALL STRINGS

	POP P,Q2		;CM236 Restore permanent AC's
	POP P,Q1		;CM236 ...
	AOSN NDTYP		;DO HEADER ONLY AT BEGINNING OF LIST
	TYPE < Accessible DECNET nodes are:>
	CALL BEFORE
	MOVE A,(C)		;OUTPUT THE WINNING STRING
	ETYPE <%1M>
	POP P,A			;GET THE AOBJN POINTER BACK
	MOVE B,(A)		;STORE THE FIRST ITEM WHERE THIS ONE WAS
	MOVEM B,(C)
DNTOP7:	AOBJN A,DNTOP3		;DO THE OUTER LOOP
	SKIPGE NDTYP		;GIVE MESSAGE ONLY IF NONE PRINTED
DNTOPX:	TYPE <%No DECNET nodes accessible>
	ETYPE <%_>		;END IT ALL WITH A CARRIAGE RETURN; DONE
	TLZ Z,F2		;CLEAR TAB FLAG
	RET

DNTOP1: SETZM (A)		;OFF-LINE - CLEAR POINTER
	AOBJN A,DNTOP0		;LOOP THROUGH TABLE
	JRST DNTOP2		;THEN JOIN THE AFTER-LOOP FLOW

DNTOPE:	CALL %GETER
	MOVE A,ERCOD		;GET FAILURE REASON
	CAIN A,ARGX04		;NOT ENOUGH SPACE?
	JRST DNTPE1		;YES, PRINT WARNING
	CAIE A,ILINS2		;NO NODE JSYS?
	CAIN A,ARGX02		;OR ILLEGAL FUNCTION?
	RET			;YES, RETURN AS IF EMPTY TABLE
	JRST CJERR		;OTHERWISE THE ERROR IS REAL FLAKY

DNTPE1:	ETYPE <%%Not enough storage, incomplete data will be printed%_>
	RET

;*** CM356 Begin addition ***

;"Information DECnet description":

.DNDES:	HRROI B,[ASCIZ "HLP:DECNET-DESCRIPTION.TXT"]
	CALL TRYGTJ		;Go look up the file
CC,<	 ERROR<DECnet description file not found - please report this problem to Remarks>>
CS,<	IFNSK.			;We don't really care
	  TYPE <%No DECNET description
>
	  RET
	ENDIF. >
	CALLRET HLPTYP		;Finish up in "Help" code

;***  CM356 End addition  ***

;FILSTAT

.FILST::NOISE <OF JFN>
	OCTX <Octal JFN number or carriage return for all>
	 JRST FILST1		;NON-OCTAL NUMBER TYPED, CHECK FOR BLANK
	CONFIRM			;CONFIRM THE NUMBER
	CAIG B,MAXJFN		;LEGAL JFN NUMBER?
	SKIPG B
	ERROR <Illegal JFN number>
	MOVE D,B		;SAVE JFN FOR JSTAT
	MOVE A,B		;PUT JFN IN A
	GTSTS
	TXNN B,GS%NAM		;JFN ACTIVE?
	ERROR <JFN not in use>
	CALLRET JSTAT		;PRINT INFO FOR JFN

FILST1:	CONFIRM
	GJINF
	ETYPE < Connected to %G%. >

;JFNS

	TYPE < JFNS:
>
	MOVEI D,MAXJFN		;JFN AND COUNTER
	CALL JSTAT		;TYPE INFO IF JFN ASSIGNED
	SOJGE D,.-1
	ETYPE<%_>

;DEVICES ASSIGNED TO THIS JOB

	PUSH P,[[TLNE Z,F1	;SET RETURN FOR ASTTJ
		ETYPE<%_>
		RET]]

;"AVAILABLE DEVICES" ALSO COMES HERE TO TYPE DEVS ASS TO THIS JOB.

ASTTJ::	GJINF			;GET JOB # IN C
	MOVE Q1,C
	TLZ Z,F1
	CALL DEVLUP		;GET NAME & CHARACTERISTICS FOR EACH
				;DEVICE AND EXECUTES THE NEXT LOCATION.
	 CALL [	CAME C,Q1	;ASSIGNED TO THIS JOB?
		RET		;NO.
		TLNN Z,F1	;FIRST ONE? ("BEFORE" SETS F1)
		TYPE <Devices assigned to/opened by this job:>
		CALL BEFORE	;COMMA OR CR OR NIL. AFTER "AVAIL DEV".
		JRST SIXPRT]	;PRINT SIXBIT NAME FROM A.
	TLNE Z,F1
	ETYPE<%_>
	RET

;TYPE STATUS OF JFN IN RH OF D.
;NOP IF UNASSIGNED.
;IF ASSIGNED, TYPE <JFN> <NAME>
;AND WHAT OPEN FOR AND "NOT OPEN" OR "DATA ERROR" OR "EOF" IF PERTINENT.
;DESTROYS A, B, C, E.  USED IN "FILSTAT".

JSTAT:	TRVAR <<FLBUF,20>>	;EM33
	HRRZ A,D
	GTSTS
	TLNN B,200
	RET			;UNASSIGNED, RETURN.
	MOVE Q1,B		;STATUS FOR USE BELOW
	PRINT " "
	MOVE A,COJFN
	HRRZ B,D
	MOVE C,[XWD 4,10]
	NOUT			;JFN, LEFT ADJ IN 4 COLS
	 CALL JERRC
	MOVEI A,FLBUF		;EM33 Buffer location
	HRLI A,(POINT 7,)	;EM33 make a pointer
	HRRZ B,D
	SETZ C,			;DEFAULT FORMAT
	JFNS			;PRINT NAME
	 ERJMP [CALL JFNSIL	;ANALYZE ERROR
		 JRST JFNGON	;JFN PROBABLY WENT AWAY
		JRST .+1]	;MESSAGE PRINTED, LIKE "RESTRICTED JFN"
	MOVEI A,FLBUF		;EM33
	HRLI A,(POINT 7,)	;EM33
	ETYPE <%1M>		;EM33

;JSTAT...
;TYPE "NOT OPEN" OR LIST OF "READ", "EXECUTE", ETC.
;IF B0 ON AND B1-3 & 5-6 OFF, TYPES NOTHING. CAN THIS HAPPEN? ______

	PRINT TAB
	TLZ Z,F1		;TELL "BEFORE" NOTHING HAS BEEN PRINTED
	TXNN Q1,GS%OPN
	TYPE < Not opened>
	TXNN Q1,GS%RDF
	JRST JSTAT3
	CALL BEFORE		;TYPE SPACE OR COMMA-SPACE OR EOL-SPACE
	TYPE <Read>
JSTAT3:	TXNN Q1,GS%WRF		;OK TO WRITE
	JRST JSTAT4
	CALL BEFORE
	TXNN Q1,GS%RND		;ALSO OK TO CHANGE POINTER?
	TYPE <Append>		;NO
	TXNE Q1,GS%RND
	TYPE <Write>		;YES
JSTAT4:	TXNN Q1,GS%XCF		;EXECUTE
	JRST JSTAT5
	CALL BEFORE
	TYPE <Execute>
JSTAT5:	TXNN Q1,GS%APT		;AS SPECIFIED BY PAGE TABLE
	JRST JSTAT6
	CALL BEFORE
	TYPE <New file>
JSTAT6:	TXNN Q1,GS%CAL		;CALL AS PROCEDURE
	JRST JSTAT7
	CALL BEFORE
	TYPE <Overlapped dump I/O>
JSTAT7:	TXNN Q1,GS%ERR
	JRST JSTAT8
	CALL BEFORE
	TYPE <Data error>
JSTAT8:	TXNN Q1,GS%EOF
	JRST JSTAT9
	CALL BEFORE
	TYPE <EOF>
JSTAT9:	TXNE Q1,GS%RDF!GS%WRF
	TXNN Q1,GS%OPN
	 JRST JSTA10
	TXNE Q1,GS%XCF
	JRST JSTA10
	HRRZ A,D
	RFPTR
	 ERJMP [TXNN Q1,GS%FRK	;RESTRICTED?
		JRST JFNGON	;NO, PRINT LOSE MESSAGE
		JRST JSTA10]	;SKIP POSITION
	CALL BEFORE
	MOVE A,COJFN
	MOVEI C,12
	NOUT
	 CALL JERRC
	TYPE <.(>
	HRRZ A,D
	RFBSZ
	 ERJMP JFNGON		;JFN DISAPPEARED
	MOVE A,COJFN
	NOUT			;PRINT BYTE SIZE (C STILL SET FROM LAST NOUT)
	 CALL JERRC
	MOVEI B,")"
	CALL TBOUT
JSTA10:	JRST EOLRET

;COME HERE IF A JSYS FAILS WHICH IS TRYING TO INTERROGATE THE JFN BEING
;PRINTED.  THE USUAL FAILURE IS IF THE JFN GETS CLOSED WHILE THE INTERROGATION
;IS GOING ON.

JFNGON:	CALL DGETER		;GET THE REASON FOR THE FAILURE
	CAIE A,DESX3		;MAKE SURE IT'S "JFN IS NOT ASSIGNED"
	CALL JERR		;STRANGE ERROR, SO FAIL
	ETYPE < ...[JFN has just been released]%_>
	RET			;CONTINUE WITH REST OF JFNS

;SUBROUTINE TO TYPE SYSTEM AND EXEC VERSIONS.
;USED AT STARTUP TO PRINT SIGN-ON MESSAGE; THIS IS ALSO THE
; EXECUTION ROUTINE FOR "VERSION" COMMAND.

MAXNAM==50			;ROOM FOR LONG NAME
MAXPVS==2			;ROOM FOR THIS MANY PDVAS IN ONE GULP

.VERSI::STKVAR <PMF,PDVLFT,<PDATA,MAXPVS>,NAMADR,<PDVARG,1+.POADE>,NUMPDV,NEXPDV>
	CALL %VERSI		;PRINT MONITOR VERSION
	CALL EXECV		;PRINT EXEC VERSION
	CALL PCLV		;CM156 Print PCL version number(s), if any
	SKIPG A,FORK		;ANY INFERIOR FORK?
	RET			;NO
	CALL GETENT		;GET ENTRY VECTOR
	CAIE B,(<JRST>)		;COMPATIBLE?
	JRST [	CAIGE B,3	;NO, DOES +2 EXIST?
		JRST NOVERS	;NO, NO VERSION
		MOVE A,C	;GET ADDRESS OF ENTRY VECTOR
		ADDI A,2	;OFFSET TO VERSION NUMBER
		JRST ISVER1]
	MOVEI A,.JBVER##	;READ VERSION WORD
ISVER1:	CALL VERGET
NOVERS:	 SETZ Q1,		;NO VERSION
	MOVE A,FORK
	SKIPE A,SLFTAB(A)	;GET FRKTBL PNTR
	 SKIPN A,.FKPTM+TTWPNM(A) ;NAME ENTRY
	  JRST [JUMPE Q1,VERSI2
		TYPE < Version is >
		JRST VERSI0]
	TYPE < Program is >
	PUSHJ P,SIXPRT
	JUMPE Q1,[ETYPE <%_>
		  JRST VERSIX]
	TYPE <, version is >
VERSI0:	CALL VERPNT		;PRINT VERSION
VERSIX:	MOVE A,FORK
	GCVEC			;GET COMPATIBILITY ENTRY VECTOR
	JUMPLE B,VN		;MAYBE COMPATIBILITY DISABLED OR NOT THERE
	HLRZ A,B
	CAIGE A,2		;DOES VERSION ENTRY EXIST?
	JRST VN			;NO
	MOVEI A,2(B)		;GET ADDR
	CALL VERGET		;GET VERSION
	 JRST VN		;LEAVE IF NONE
	TYPE < UUO simulation in use, version is >
	CALL VERPNT		;PRINT VERSION AND LEAVE
VN:	MOVE A,FORK		;GET CURRENT FORK HANDLE
	MOVEM A,.POPHD+PDVARG	;TELL MONITOR WHAT FORK TO LOOK AT
	MOVEI A,MAXNAM		;GET ROOM FOR LONG NAME
	CALL GETBUF
	MOVEM A,NAMADR		;REMEMBER ADDRESS OF NAME BUFFER
	SETZM .POADR+PDVARG	;FIRST TIME THROUGH, RANGE IS EVERYTHING
	SETOM PMF		;CAUSE TITLE FIRST TIME THROUGH
VN3:	MOVEI A,MAXPVS		;TELL MONITOR MAXIMUM PDVS WE CAN LIST
	MOVEM A,.POCT2+PDVARG
	MOVEI A,PDATA		;GET ADDRESS OF DATA
	MOVEM A,.PODAT+PDVARG	;TELL MONITOR WHERE TO PUT LIST OF PDVS
	MOVEI A,1+.POADR	;SAY LENGTH OF ARGUMENT BLOCK
	MOVEM A,.POCT1+PDVARG
	MOVEI A,.POGET		;TELL MONITOR WE WANT TO GET THE PDVAS
	MOVEI B,PDVARG		;SAY WHERE ARG BLOCK IS
	PDVOP%			;GET LIST OF PDVAS
	 ERJMP [CALL DGETER	;FAILED, GET REASON
		CAIN A,ILINS2	;NO SUCH JSYS?
		RET		;RIGHT, SO O.K.
		CALL JERR]	;NO, SO UNEXPECTED ERROR
	SETZM NEXPDV		;START WITH INDEX 0
	HRRZ A,.POCT2+PDVARG	;GET NUMBER OF PDVS TO DEAL WITH
	MOVEM A,NUMPDV		;REMEMBER HOW MANY
	HLRZ B,.POCT2+PDVARG	;GET NUMBER THAT WERE AVAILABLE
	SUB B,A			;GET NUMBER LEFT TO READ
	MOVEM B,PDVLFT		;REMEMBER HOW MANY LEFT TO READ
VN1:	MOVE A,NEXPDV		;SEE WHICH ONE IS NEXT TO BE EXAMINED
	CAML A,NUMPDV		;HAVE WE EXAMINED THEM ALL YET?
	JRST [	SKIPG A,PDVLFT	;YES, SEE IF MORE IN MONITOR
		RET		;NO
		MOVE A,MAXPVS-1+PDATA	;GET LARGEST PDVA WE'VE SEEN
		AOJ A,		;SAY TO START WITH NEXT
		MOVEM A,.POADR+PDVARG	;TELL MONITOR TO START WITH NEXT
		JRST VN3]	;GO READ NEXT GROUP
	ADDI A,PDATA		;NO, GET ADDRESS HOLDING NEXT PDVA
	MOVE A,(A)		;GET THE PDVA
	MOVEM A,.POADR+PDVARG	;TELL MONITOR WHICH ONE TO READ
	MOVEI A,1		;VERSION IS ONLY ONE WORD
	MOVEM A,.POCT2+PDVARG
	MOVEI A,1+.POADR	;SET UP NUMBER OF WORDS IN ARGUMENT BLOCK
	MOVEM A,.POCT1+PDVARG
	MOVEI A,Q1		;WRITE VERSION INTO Q1
	MOVEM A,.PODAT+PDVARG
	MOVEI A,.POVER		;NOW READ VERSION OF THIS PROGRAM
	MOVEI B,PDVARG
	PDVOP%
	 ERJMP [CALL DGETER
		MOVE B,.POADR+PDVARG
		LERROR <Can't read version for PDV at %2o - %1?>
		JRST VN2]
	MOVEI A,MAXNAM		;GET MAXIMUM NAME LENGTH
	MOVEM A,.POCT2+PDVARG
	MOVE A,NAMADR		;GET ADDRESS OF NAME BUFFER
	MOVEM A,.PODAT+PDVARG
	MOVEI A,.PONAM		;SAY WE WANT TO READ NAME
	MOVEI B,PDVARG		;SAY WHERE ARG BLOCK IS
	PDVOP%			;READ NAME OF THIS PDV
	 ERJMP [CALL DGETER	;CAN'T GET IT.  GET WHY NOT
		MOVE B,.POADR+PDVARG	;GET ADDRESS
		LERROR <Can't read program name for PDV at %2o - %1?>
		JRST VN2]	;PROGRAM IS PROBABLY RUNNING AND CHANGING ITS PDV STATUS OUT FROM UNDER US
REPEAT 0,<			;Seems this is no longer necessary (new Link?)
	HRRO A,NAMADR		;CM236 Get address of program name
	HRLI A,440700		;CM236 Make it a byte pointer
	ILDB A,A		;CM236 Get first byte of name
	SKIPN A			;CM236 A null?
	JUMPE Q1,VN2		;CM236 Yes.  If version also 0 then assume
				; this PDV is not interesting enoughh to print
>;REPEAT 0
	HRRO A,NAMADR		;POINT TO THE NAME
	AOSN PMF		;IS THIS THE FIRST?
	TYPE < PDVs:>		;CM236
	ETYPE <	Program name %1m, version >
	CALL VERPNT		;PRINT VERSION OF THIS ONE
VN2:	AOS NEXPDV		;STEP TO NEXT ONE
	JRST VN1		;LOOP FOR REST

VERGET:	PUSH P,A
	CALL MAPPF
	 JRST [	POP P,A		;FAILED TO MAP-- NO
		RET]		; VERSION-- RETURN +1 FROM VERGET
	POP P,Q1
	TXNN B,PA%PEX
	RET			;NO PAGE
	TXNN B,PA%RD
	RET			;CAN'T READ IT
	ANDI Q1,777
	MOVE Q1,PAGEN(Q1)	;LOAD VERSION INTO Q1
	JUMPE Q1,[RET]
	RETSKP

VERPNT::LDB A,[POINT 9,Q1,11]	;GET MAJOR VERSION
	SKIPE A
	ETYPE <%1O>		;PRINT IF NON-ZERO
	LDB A,[POINT 6,Q1,17]	;GET MINOR VERSION
	JUMPE A,VERSI1		;SKIP IF 0
	ETYPE <.%1O>		;PUT DOT AND OCTAL MINOR NON-ZERO VALUE
VERSI1:	HRRZ A,Q1		;GET EDIT NUMBER
	SKIPE A
	ETYPE <(%1O)>		;PRINT IF NON-ZERO
	LDB A,[POINT 3,Q1,2]	;GET GROUP CODE
	SKIPE A
	ETYPE <-%1O>		;PRINT IF NON-ZERO
VERSI2:	ETYPE<%_>
	RET

END
