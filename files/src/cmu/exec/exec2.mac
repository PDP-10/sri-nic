;<EXEC.CMU>EXEC2.MAC.4, 29-Aug-84 11:53:18, Edit by EC0N
;CM290	Changed the Holes in file message so that it directs the
;	user towards a help command.
;<EXEC.CMU>EXEC2.MAC.3,  1-Mar-84 22:59:51, Edit by VAF
; EM135	Case of "binary" switch.
;<5.1.EXEC>EXEC2.MAC.6, 22-Aug-83 20:04:05, Edit by PA0B
;CM236 At CBYEF1 don't call FFUFP routine on file open for append because
; it ITRAP's and causes internal illegal instruction, Change CS994 => CS56
;<5.1.EXEC>EXEC2.MAC.5, 17-May-83 13:03:41, Edit by PA0B
;CM133 Redo greet code (yet again) to try to make both CC and CS happy:
; add /NOSEND-ALL, /SEND-ALL (CS only), /SAVE (CC only), and /NOSAVE (CC
; only).  Allow ^EGREET filename at CC.
;<5.1.EXEC>EXEC2.MAC.4, 15-May-83 17:30:17, Edit by PA0B
;CM133 Strip leading whitespace off of greet (CC operators %$^%^...).
;CS56 Don't update access dates of source if destination is NUL:
;<5.1.EXEC>EXEC2.MAC.3, 27-Jan-83 07:15:38, Edit by PA0B
;CM133 Don't broadcast new greet at CS
;<5.1.EXEC>EXEC2.MAC.2,  3-Dec-82 00:45:47, Edit by PA0B
;Merge CMU version 5:
; CM133 ^EGreet command
; CM189 Handle failure from DTACH% (due to over permanent quota)
; CM236 Give better error message than "Foo: is already assigned
;	by job -1"
; CM278 Add "Bulletin" but REPEAT 0 it out
; CM298 Have "Copy tty: ..." use a normal TEXTI%
; CM299 "Type /binary"
; UPD ID= 85, FARK:<5-WORKING-SOURCES.EXEC>EXEC2.MAC.6,  23-Aug-82 09:01:36 by TSANG
;Edit 748 - Remove edit 742 temporary.
; UPD ID= 75, FARK:<5-WORKING-SOURCES.EXEC>EXEC2.MAC.5,   5-Aug-82 16:12:07 by TSANG
;Edit 743 - create a warning message instead of a error message
; UPD ID= 74, FARK:<5-WORKING-SOURCES.EXEC>EXEC2.MAC.4,  30-Jul-82 10:46:50 by TSANG
;Edit 742 - force to output a CR/LF before reissuing prompt
; UPD ID= 62, FARK:<5-WORKING-SOURCES.EXEC>EXEC2.MAC.3,   2-Jun-82 14:07:56 by KROSENBLUH
;Edit 738 - get system-wide logical SYSTEM: for writing SYSJOB.COMMANDS
; UPD ID= 34, FARK:<4-1-WORKING-SOURCES.EXEC>EXEC2.MAC.2,  29-Apr-82 13:34:50 by KROSENBLUH
;REINSERT EDIT 587		[727]
; UPD ID= 131, SNARK:<5.EXEC>EXEC2.MAC.8,  13-Jan-82 16:15:37 by TILLSON
;TCO 5.1671 Copy user settable word
; UPD ID= 120, SNARK:<5.EXEC>EXECIN.MAC.21,  28-Dec-81 11:14:01 by CHALL
;TCO 5.1644 - UPDATE COPYRIGHT NOTICE
; UPD ID= 33, SNARK:<5.EXEC>EXEC2.MAC.5,  14-Aug-81 19:12:18 by CHALL
;TCO 5.1454 CHANGE NAME FROM XDEF TO EXECDE
; UPD ID= 1816, SNARK:<5.EXEC>EXEC2.MAC.4,  16-Apr-81 18:20:36 by TILLSON
;TCO 5.1286 - Pass LBLSKP a JFN, not a device type
; UPD ID= 1808, SNARK:<5.EXEC>EXEC2.MAC.3,  15-Apr-81 11:12:56 by TILLSON
;TCO 5.1282 - Stop 512-page COPY from going long
; UPD ID= 1725, SNARK:<5.EXEC>EXEC2.MAC.2,  17-Mar-81 13:14:38 by SCHMITT
;TCO 5.1274 - Fix COPY from labelled EBCDIC tapes to use bytesize 7
;REMOVE MFRK CONDITIONALS
; UPD ID= 1190, SNARK:<5.EXEC>EXEC2.MAC.6,  23-Oct-80 14:08:40 by TILLSON
;tco 5.1178 - Fix COPY from labelled ANSI-ASCII tapes to use bytesize 7
; UPD ID= 803, SNARK:<5.EXEC>EXEC2.MAC.5,  28-Jul-80 09:53:36 by OSMAN
;tco 5.1113 - Don't type [OK] until after CLOSF
; UPD ID= 532, SNARK:<5.EXEC>EXEC2.MAC.4,  20-May-80 14:55:27 by MURPHY
;CHANGE SOME XTND TO NEWF OR MFRK
; UPD ID= 490, SNARK:<4.1.EXEC>EXEC2.MAC.6,  29-Apr-80 16:20:51 by TOMCZAK
;TCO 4.1.1152 - Add ERJMP after XCT in COPNCR, change SKIPE to JUMPE
;more 4.1.1099 - Handle files with page 777777
; UPD ID= 303, SNARK:<4.1.EXEC>EXEC2.MAC.2,   5-Mar-80 11:24:23 by OSMAN
;tco 4.1.1099 - Fix COPY to not go forever on files exactly one section long
;<4.EXEC>EXEC2.MAC.76,  8-Oct-79 15:32:41, EDIT BY OSMAN
;tco 4.2518 - Remove LIST
;<4.EXEC>EXEC2.MAC.75, 14-Sep-79 16:00:14, EDIT BY TOMCZAK
;TCO 4.2470  - Checking for nonexistent sections in long files at PREFLT
;TCO 4.2448 - Remove ERJMPs, so DATPSI can do its fancy analysis
;<4.EXEC>EXEC2.MAC.73,  6-Sep-79 11:08:51, Edit by HESS
; Fix DETACH (AND) CONTINUE (XTND only)
;<HESS.TEMP.E>EXEC2.MAC.2, 27-Jul-79 12:36:31, Edit by HESS
; Add extended features
;<4.EXEC>EXEC2.MAC.71, 10-Aug-79 15:12:28, EDIT BY OSMAN
;USE TYPFLS IN TYPE COMMAND
;<4.EXEC>EXEC2.MAC.69, 19-Jul-79 08:32:11, EDIT BY OSMAN
;tco 4.2335 - Use SYSTEM: instead of PS:[SYSTEM] in ^ESPEAK
;<4.EXEC>EXEC2.MAC.68, 21-Jun-79 13:34:46, EDIT BY OSMAN
;REMOVE EXTRANEOUS RLJFNS REF
;<4.EXEC>EXEC2.MAC.67, 19-Jun-79 14:19:35, EDIT BY OSMAN
;tco 4.2295 - fix BYTE-SIZE (TXO was wrong)
;<4.EXEC>EXEC2.MAC.66,  4-Jun-79 09:39:47, EDIT BY OSMAN
;CORRECTLY POSITION THE "MOVE D,DESTYP"
;<4.EXEC>EXEC2.MAC.59, 29-May-79 16:05:11, EDIT BY OSMAN
;WHEN WRITING IN ASCII TO STANDARD TAPE, PUT ONE TEXT LINE PER RECORD
;<4.EXEC>EXEC2.MAC.54,  2-May-79 10:24:33, EDIT BY OSMAN
;GET RID OF REFERENCES TO CJFN1 AND CJFN2
;<4.EXEC>EXEC2.MAC.53, 12-Mar-79 17:49:03, EDIT BY KONEN
;UPDATE COPYRIGHT FOR RELEASE 4
;<4.EXEC>EXEC2.MAC.52,  2-Feb-79 15:33:27, EDIT BY HEMPHILL
;TCO 4.2183 -- MAKE "BYTE" SUBCOMMAND VISIBLE
;<4.EXEC>EXEC2.MAC.48, 15-Sep-78 22:58:51, EDIT BY OSMAN
;REMOVE ALL REFS TO CSBUFP
;<4.EXEC>EXEC2.MAC.47, 14-Sep-78 11:57:45, EDIT BY OSMAN
;ONLY SEARCH XDEF, TTITLE NOW SEARCHES ALL ELSE
;<4.EXEC>EXEC2.MAC.45, 12-Aug-78 16:33:46, EDIT BY OSMAN
;TCO 4.1982 DON'T BOMB OUT ENTIRE COPY IF OPENF FAILS ON INPUT FILE
;<4.EXEC>EXEC2.MAC.43, 12-Aug-78 16:14:58, EDIT BY OSMAN
;CHANGE OPNERR TO RETURN AFTER PRINTING ERROR.
;<4.EXEC>EXEC2.MAC.30, 12-Aug-78 13:19:01, EDIT BY OSMAN
;TCO 4.1981 - PUT IN FASTER DISK-TO-DISK COPY
;<4.EXEC>EXEC2.MAC.24, 10-Aug-78 08:41:35, EDIT BY OSMAN
;<4.EXEC>EXEC2.MAC.23,  9-Aug-78 17:10:35, EDIT BY OSMAN
;TCO 1976 - DON'T ADVERTISE NONX SUBCOMMANDS IN TYPE COMMAND
;<4.EXEC>EXEC2.MAC.20, 18-Jul-78 17:03:03, EDIT BY OSMAN
;REMOVE ALL LIST COMMAND SUBCOMMANDS (THE COMMAND WILL BE REMOVED TOO
;WHEN /DISP:RENAME IS ADDED TO PRINT)
;<4.EXEC>EXEC2.MAC.12, 13-Jul-78 14:26:39, EDIT BY OSMAN
;MAKE POJFLG BE LOCAL
;<4.EXEC>EXEC2.MAC.11, 11-Jul-78 14:40:56, EDIT BY OSMAN
;MAKE TADBLK BE LOCAL
;<4.EXEC>EXEC2.MAC.9, 11-Jul-78 10:37:07, EDIT BY OSMAN
;MAKE PREPAG BE LOCAL VARIABLE
;<4.EXEC>EXEC2.MAC.8, 10-Jul-78 20:58:58, EDIT BY OSMAN
;MAKE TTY COPY USE LOCAL STORAGE, AND RENAME FROM TEXTIB TO TTBLK
;<4.EXEC>EXEC2.MAC.6, 28-Jun-78 16:20:06, EDIT BY OSMAN
;PUT ALL LIST COM VARIABLES IN TRVAR
;<4.EXEC>EXEC2.MAC.5, 26-Jun-78 11:14:39, EDIT BY OSMAN
;CHANGE "LIST"'S USE OF P6 TO CCOUNT TO FREE UP P6 FOR TRVAR
;(P.S.  LET'S THROW OUT LIST COMPLETELY! [MAYBE SOMEONE WOULD YELL])
;<4.EXEC>EXEC2.MAC.4, 23-Jun-78 21:06:01, EDIT BY OSMAN
;REMOVE ASCII1, LSTH2D (UNREFERENCED SYMS)
;<4.EXEC>EXEC2.MAC.3,  9-Jun-78 18:04:37, EDIT BY OSMAN
;CHANGE CALLS TO FIELD TO FLDSKP
;<4.EXEC>EXEC2.MAC.2, 31-Jan-78 16:23:37, Edit by PORCHER
;<4.EXEC>EXEC2.MAC.1,  9-Jan-78 16:55:32, EDIT BY HELLIWELL
;FIX IMAGE SUBCOMMAND AND MAKE IMAGE MODE TO/FROM PAPER TAPE
;USE LEAST SIGNIFICANT 8 BITS OF EACH 36 BIT WORD.

;TOPS20 'EXECUTIVE' COMMAND LANGUAGE

;THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY ONLY BE USED
;  OR COPIED IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
;COPYRIGHT (C) 1980,1981,1982 BY DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.

	SEARCH EXECDE
	TTITLE EXEC2

;THIS FILE CONTAINS CODE TO EXECUTE SOME OF THE LONGER COMMANDS:
; COPY/APPEND
; TYPE
; REDIRECT/DETACH

;TYPE.  CAUSE SOURCE FILE(S) TO BE COPIED TO TTY.
;SETUP ARGS AND JOIN COPY.

.TYPE::	MOVEI Q1,CP%TYP		;IDENTIFY
TYPE1::	STKVAR <TYPBIN>		;CM299
	SETZM TYPBIN		;CM299
	MOVE A,COJFN		;CM299 USE COMMAND OUTPUT JFN
	MOVEM A,OUTDSG
	TLO Z,F1		;SIGNAL THAT THIS IS A COPY COMMAND
	CAIE Q1,CP%HEL		;NO NOISE IF ENTERING FROM HELP COMMAND
	NOISE (FILE)
	SETZ Q2,
	TLZ Z,F2		;NOT APPEND
	CAIN Q1,CP%HEL		;CM299
	JRST TYPE2		;CM299 Help already provided the JFN
	MOVEI B,[FLDDB. .CMSWI,,[1,,1
				 [ASCIZ/Binary/],,0],<file name
 or>]				;CM299;EM135
	CALL FLDSKP		;CM299 See if switch provided
	 TRNA			;CM299 It wasn't
	SETOM TYPBIN		;CM299 Remember that binary was used
	CALL TYPFLS		;GET LIST OF FILESPECS
TYPE2:				;CM299
	SETZM TYPGRP		;DON'T PRINT NAME UNLESS GROUPF ON
	SETZM MCOJFN		;SAY NOT MULTI FILE OUTPUT
	SETOM TYPING		; SAY TYPING ON TERMINAL
	SKIPN TYPBIN		;CM299 *** Start ***
	JRST TYPE3		;Not binary mode
BT.DAM==^L<TT%DAM&-TT%DAM>	;Make names for the fields
SZ.DAM=BT.DAM-^L<TT%DAM>+1
	MOVEI A,.CTTRM		;Adjust the terminal modes
	MOVE B,ETTYMD+TTWMOD	;Take the current modes
	MOVEI C,.TTBIN		;And switch to binary
	DPB C,[POINT SZ.DAM,B,BT.DAM]
	SFMOD%
TYPE3:	CALL COP1A		;Go do copy
	MOVEI A,.CTTRM		;Ready to switch back to ASCII
	MOVE B,ETTYMD+TTWMOD
	SKIPE TYPBIN		;Was mode switched?
	SFMOD%			;Yes, reset it
	RET			;CM299 *** End ***

;COPY COMMAND:  COPY <FILE GROUP> (TO) <FILE>
;AND
;APPEND COMMAND:  APPEND <FILE GROUP> TO <FILE>

;TAKE SUBCOMMANDS.

;MODE SUBCOMMAND --   LEGAL FOR--	MODE-BYTESIZE USED--
;ASCII		ANY DEVICES		1-7 WHERE LEGAL, ELSE 0-7
;IMAGE		ONE DEVICE MUST ACCEPT	10-8 WHERE LEGAL, ELSE 0-8
;		MODE 10, OTHER MUST
;		NOT BE LPT:.
;IMAGE BINARY	NEITHER DEVICE CAN	13-36 WHERE LEGAL, ELSE 0-36
;		BE TTY: OR LPT:
;BINARY		NEITHER DEVICE CAN	14-36 WHERE LEGAL, ELSE 0-36
;		BE TTY: OR LPT:.
;ASCII PARITY	PAPER TAPE SOURCE	SEE ASCII	NOT IMPLEMENTED
;DUMP		NON-DIRECTORY DTA OR MTA		NOT IMPLEMENTED

;FLAGS IN LH Z
;F1 ON FOR PAGES COPY, OTHERWISE OFF
;F2 ON FOR APPEND, OFF FOR COPY
;F3 ON IF OUTFILE WAS ALREADY OPEN (GROUP SOURCE CASE)
;F4 ON IF NOT DISK TO DISK XFER

;FLAGS IN RH Z
;BITS FOR MODES SPECIFIED BY SUBCOMMANDS
; B35-N ON FOR MODE N, AS IN DVCHR WORD. THAT IS:
NRMF==1			;1	NORMAL - SET IF BYTE SIZE SPECIFIED
ASCF==2			;2	ASCII
			;400	IMAGE
			;4000	IMAGE BINARY
			;10000	BINARY
			;100000 DUMP

;AC USE
;P1  -1 OR BYTE SIZE AND MODE OF PREVIOUS COPY IN GROUP TO SAME DEST
;P2  - # BYTES PER PAGE WHEN COPYING BY BYTES
;P3  BYTE # OF EOF OF DISK SOURCE, # BYTES COPIED TO DSK DEST
;Q1, Q2   SEE 2 PAGES HENCE
;A, B, AND Q3 ALSO USED LOCALLY

;SPEAK COMMAND = COPY (FILE) TTY: (TO) SYSTEM:SYSJOB.COMMANDS

.SPEAK::NOISE <TO SYSJOB>
	CONFIRM
	SETZM MCOJFN		;SETUP SOME THINGS FOR COPY CODE
	SETZM TYPGRP
	HRROI B,[ASCIZ /SYSTEM:SYSJOB.COMMANDS/]
;**;[738] Change 1 line at .SPEAK:+5L	KR	2-JUN-82
	CALL TRYGTS		;[738]GET OUTPUT JFN
	 ERROR < Can't get JFN on SYSTEM:SYSJOB.COMMANDS>
	MOVEM A,OUTDSG
	HRROI B,[ASCIZ /TTY:/]
	CALL TRYGTJ		;INPUT FROM TTY
	 ERROR <Can't get JFN on TTY:>
	HRRZ A,JBUFP		;GET POINTER TO JFN JUST STACKED
	MOVEM A,INIFH1		;MAKE SINGLE JFN IN LIST
	MOVEM A,INIFH2
	TYPE < [Please type SYSJOB commands - end with ^Z]
>
	MOVEI Q1,CP%SPE		;IDENTIFY COMMAND
	CALL COP1A		;GO PERFORM COPY
	MOVEI A,0		;SET TO WAKE JOB 0
	TWAKE			;...
	  ERJMP CJERRE		;JSYS LOSAGE
	RET			;RETURN

;CM133 Greet command

.GREET::TRVAR <SNDPT,GRESPC,GREJFN,<TXTBLK,5>,GRESAF,GRESVF,GRESVS>
CC,<	NOISE (MESSAGE) >
CS,<	NOISE (FROM FILE) >
	SETZM GREJFN		;No Greet.Txt JFN yet
	SETOM GRESAF		;Default is /Send-all
CC,<	SETOM GRESVF >		;Default is /Save at CC
CS,<	SETZM GRESVF >		;Default is /Nosave at CS
	SETZM GRESVS		;No explicit "/Save" or "/Nosave" specified
	MOVX A,^D512		;Allocate a page worth of work space
	CALL GETBUF		;...
	HRLI A,440700		;Make a byte pointer to it
	MOVEM A,GRESPC		;Save pointer to space
	SETZM @A		;Zero (nulls) first word of buffer
	MOVX A,GJ%OLD		;Only old files
	MOVEM A,CJFNBK+.GJGEN	;Put in the GTJFN% block
	MOVX A,<GREJF$,,CJFNBK+.GJDEV> ;Pointer to defaults
	BLT A,CJFNBK+.GJEXT	;Stuff the GTJFN% block

GREPRS:

;First, assume we have not parsed either a file or a switch:

CC,<
	MOVEI B,[FLDDB. .CMFIL,CM%SDH,,<Greet file name>,,[
		 FLDDB. .CMSWI,CM%SDH,GREET$,</LOAD to load greet from standard file>,,[
		 FLDDB. .CMSWI,,GRESW$,,,[
		 FLDDB. .CMCFM,CM%SDH,,<confirm to read greet from terminal>,,]]]]
>;CC
CS,<
	MOVEI B,[FLDDB. .CMFIL,CM%SDH,,<Greet file name>,,]
>;CS

;Now, check for and handle case where we've already parsed a filespec or /LOAD:

	SKIPLE GREJFN		;Have a JFN?
	 MOVEI B,[FLDDB. .CMSWI,,GRESW$,,,[ ;;Yes, want switch or CRLF
		  FLDDB. .CMCFM,,,,,]]
	  
;Parse and dispatch:

	CALL FLDSKP		;Parse
	 CMERRX			;Bogus
	LDB D,[331100,,(C)]	;Good parse, see what got typed
	CAIE D,.CMFIL		;Filespec?
	IFSKP.
	  HRRZM B,GREJFN	;Yes, save JFN
	  JRST GREPRS		;Parse more of command
	ENDIF.
	CAIE D,.CMSWI		;Switch?
	IFSKP.
	  CALL GETKEY		;Yes, get dispatch address
	  CALL (P3)		;Call routine for switch
	  JRST GREPRS		;Get more input
	ENDIF.
	CAIE D,.CMCFM		;CRLF?
	 JRST SCREWUP		;No, we fucked up some
	SKIPN A,GREJFN		;Greet from file?
	 JRST GRETTY		;No, get greet from tty
	DVCHR			;Get device characteristics
	LDB C,[POINTR B,DV%TYP]	;Device type
	CAIN C,.DVTTY		;A TTY?
	 JRST GRETTY		;Call routine to get greet from TTY
	CAIE C,.DVDSK		;Disk file?
	 ERROR <Greet file must be on disk>
	JRST GREDSK		;Yes, read greet from disk file

;Name of the standard greet file:

GREFIL:	ASCIZ /PS:<OPERATOR>GREET.TXT.0/

;GTJFN% block defaults

CC,<
GREJF$:	-1,,[ASCIZ/PS/]
	-1,,[ASCIZ/OPERATOR/]
	0
	-1,,[ASCIZ/TXT/]
>;CC

CS,<
GREJF$:	-1,,[ASCIZ/PS/]
	-1,,[ASCIZ/OPERATOR/]
	-1,,[ASCIZ/GREET/]
	-1,,[ASCIZ/TXT/]
>;CS

;Tables of switches for ^EGreet:

GREET$:	TABLE
	T LOAD-FROM-FILE,,GRELOD
	TEND

GRESW$:	TABLE
CC,<	T NOSAVE,,GRENSV>
	T NOSEND-ALL,,GRENSN
CC,<	T SAVE,,GRESV>
CS,<	T SEND-ALL,,GRESN>
	TEND

GRELOD:	MOVX A,GJ%OLD!GJ%SHT!GJ%PHY ;/Load
	HRROI B,GREFIL		;Get name of greet file
	CALL GTJFS		;Try to find it
	 ERROR <There is no stored greet>
	HRRZM A,GREJFN		;Save JFN
CC,<
	SKIPN GRESVS		;User specified "/Save" or "/Nosave"?
	 SETZM GRESVF		;No, assume /Nosave for greet from standard
				; file
>;CC
	RET

GRENSN:	SKIPA A,[0]		;/Nosend-all
GRESN:	MOVX A,1		;/Send-all
	MOVEM A,GRESAF		;Save flag
	RET

GRENSV:	SKIPA A,[0]		;/NoSave
GRESV:	MOVX A,1		;/Save
	MOVEM A,GRESVF		;Save flag
	SETOM GRESVS		;Remember explicit switch seen
	RET

;Routine to read a new greet from the terminal.  Puts the text of the greet
;in the buffer pointed to by GRESPC:

GRETTY:	ETYPE <[Type greet message (terminate with ^Z), or type ^Z to clear greet]%_%%_>
	MOVX A,4		;Get TEXTI% arg count
	MOVEM A,.RDCWB+TXTBLK	;Store in arg block
	MOVX A,RD%BRK!RD%JFN	;Break on ESC or ^Z
	MOVEM A,.RDFLG+TXTBLK	;Store in arg block
	HRR A,COJFN		;Get Exec output designator
	HRL A,CIJFN		;Get Exec input designator
	MOVEM A,.RDIOJ+TXTBLK	;Store I/I JFN's in arg block
	MOVE A,GRESPC		;Get address of greet work area
	MOVEM A,.RDDBP+TXTBLK	;Store as place to put input
	MOVX A,<<^D512*5>-1>	;Get size of work space
	MOVEM A,.RDDBC+TXTBLK	;Store in arg block
	MOVEI A,TXTBLK		;Get address of arg block
	TEXTI%			;Read the new greet
	 CMERRX
	MOVE A,.RDFLG+TXTBLK	;Get flags
	TXNN A,RD%BTM		;Break character seen?
	 ERROR <Greet too long>	;No, foon typed much text
	SETZ A,			;Yes, get a null
	DPB A,.RDDBP+TXTBLK	;Overwrite the ESC or ^Z
	JRST GRESAV		;Join common code

;Routine to load greeting from a file:

GREDSK:	MOVE A,GREJFN		;Get JFN on greet file
	MOVX B,<FLD(7,OF%BSZ)!OF%RD>
	MOVE D,A		;Get copy of JFN
	OPENF%			;Open the greet file
	 ERJMP [ERROR <Couldn't open greet file - %4S - %?>]
	SIZEF%			;Get size of the greet file
	 ERCAL JERRE
	CAILE C,1		;One page or less?
	 ERROR <Greet file is too large - %4S>
	MOVE B,GRESPC		;Get pointer to temporary space for greet
	SETZ C,			;Read entire greet
	SIN%
	 ERJMP .+1		;Error (EOF hit) is expected in this case
	CALL RJFN		;Close greet file, release JFN

;Save the greet in the standard greet file if desired:

GRESAV:	SKIPN GRESVF		;Want it saved?
	 JRST GRESV2		;No, just do greet
	MOVX A,<GJ%SHT!GJ%FOU!GJ%PHY>
	HRROI B,GREFIL		;Get name of greet file
	CALL GTJFS		;Get a JFN on the greet file
	 JRST [ HRROI A,[ASCIZ /Couldn't get a JFN on %2M/]
		CALL GRFWRN	;Report error
		JRST GRESV2]	;Skip rest of Greet.Txt stuff
	HRRZM A,GREJFN		;Save JFN
	MOVX B,<FLD(7,OF%BSZ)!OF%WR>
	OPENF%
	 JRST [ HRROI A,[ASCIZ /Couldn't open %2M/]
		CALL GRFWRN	;Report error
		JRST GRESV2]	;Skip rest of Greet.Txt stuff
	MOVE B,GRESPC		;Get byte pointer to new greet
	SETZ C,			;Terminate on null
	SOUT%			;Write new greet to Greet.Txt
	MOVE D,GRESPC		;Get back pointer to new greet
	ILDB D,D		;Get first character of new greet
	SKIPE D			;Null?
	 JRST [ HRROI B,[ASCIZ /
/]				;No, append a free CRLF to make sure Edit
		SOUT%		; will be happy
		JRST .+1 ]	;...
	CALL RJFN		;Close the file
GRESV2:	JRST GRECOM		;Go do greet

;Routine to handle errors writing Greet.Txt.  Takes address of error string
;in A, prints a warning on the terminal, and returns +1 always:

GRFWRN:	HRROI B,GREFIL		;Get filename in case needed for error message
	ETYPE <%_%%%%%1\ - %?%%_%%%proceeding anyway...%_>
	SKIPE A,GREJFN		;Have a JFN?
	 CALL RJFN		;Yes, get rid of it
	RET

;Common code for greet.  Expects a byte pointer to a "raw" greet in GRESPC.
;This code massages the greet and then actually does the greet (SMON%,
;TMSG%, etc).

GRECOM:	DO.			;First, strip leading whitespace
	  ILDB C,GRESPC		;Get a character
	  CAIE C,.CHCRT		;CR?
	   CAIN C,.CHLFD	; or LF?
	    JRST TOP.		;Yes, loop some more
	  CAIE C,.CHSPC		;Space?
	   CAIN C,.CHTAB	; or tab?
	    JRST TOP.		;Yes, loop some more
	OD.
	SETO C,			;-1
	ADJBP C,GRESPC		;Unread non-whitespace character
	MOVEM C,GRESPC		;Store updated pointer
	MOVE A,CSBUFP		;Get pointer to string buffer
	MOVEI C,.CHCRT		;Get a CR
	IDPB C,A		;Put it in the buffer
	MOVEI C,.CHLFD		;Get a LF
	IDPB C,A		;Put it in the buffer, too
	MOVEM A,SNDPT		;This is destination for "massaged" greet
	MOVEI C,"["		;At CC, add beginning delimiter
	IDPB C,A		;...
	MOVE B,GRESPC		;Get pointer to raw greet
	SETZ D,			;Line length of current line is zero
	AOS D			;Account for "["
	DO.
	  ILDB C,B		;Get a character from "raw" greet
	  CAIN C,.CHCRT		;CR?
	   JRST TOP.		;Yes, flush it
	  CAIN C,.CHLFD		;LF?
	   JRST [ MOVX C,.CHCRT	;Yes, put out a
		  IDPB C,A	;CR
		  MOVX C,.CHLFD	;and then a
		  IDPB C,A	;LF
		  SETZ D,	;Reset column to zero
		  MOVX C,.CHSPC	;and then a
		  JRST .+1 ]	;space
	  CAIL C,.CHSPC		;Printing character?
	   AOS D		;Assume it takes one column
	  CAIN C,.CHTAB		;Tab?
	   JRST [MOVE Q1,D	;Yes, wierd.  Convert it to spaces
		 SOS Q1		;Fudge for leading " " or "["
		 IDIVI Q1,^D8	;Compute distance to the right of the previous
				; tab stop
		 SUBI Q2,^D8	;Compute (negative) distance to the left of
				; the next tab stop
		 MOVX C,.CHSPC	;Get a space character
		 DO.
		   AOS D	;Account for one space
		   AOSL Q2	;More than one left to do?
		    EXIT.	;No, one left
		   IDPB C,A	;Yes, do it
		   JRST TOP.	;Loop again
		 OD.
		 JRST .+1 ]	;Done (whew!!!) The IDPB below will deposit
				; the final space
	  IDPB C,A		;Store character in "massaged" greet
	  CAIL D,^D80		;Greet too wide?
	   ERROR <Greet is more than 79 characters wide>
	  JUMPN C,TOP.		;Loop again unless character was a null
	OD.
	MOVE A,SNDPT		;clean up the end of the string
	IBP A			;Skip opening "["
	SETZ B,			;Pointer to last non-null char
	DO.
	  ILDB C,A		;Get a char
	  CAILE C,.CHSPC	;A printing char?
	   MOVE B,A		;Have a real char here, keep pointer to it
	  JUMPN C,TOP.		;Stop looking at the null
	OD.
	IFN. B			;If setting the greet...
	  MOVE A,B		;Put pretty terminator on this
	  FMSG <]
>				;Terminate the greet nicely
	  MOVE B,SNDPT		;Get back pointer to greet
	ENDIF.
	MOVEI A,.SFGRT		;Set (or clear, depending on contents of B)
	SMON%			; the greet
	 ERJMP CJERRE
	SKIPN GRESAF		;User specified "/Nobroadcast"?
	 RET			;Yes, done
	JUMPE B,R		;Done if nullifying
	MOVE C,B		;Copy byte pointer
	HRREI B,-2		;Back up two bytes (there's a CRLF before
	ADJBP B,C		; the greet - see GRECOM+1
	SETO A,			;Now broadcast to all lines
	TTMSG%
	 ERJMP CJERRE
	RET			;Done

;COPY/APPEND

.COPY::	SETOM TYPGRP		;TYPE ALL FILES
	NOISE <FROM>
	TLZ	Z,F2!F1		;NOT APPEND, AND NOT TYPE
	CALL .INFG		;GET INPUT FILE GROUP DESCRIPTOR
				;ALLOWS *'S, AND COMMAS IF THEY ARE
				;IMMEDIATE FILE NAME TERMINATOR.
	NOISE <TO>
	CALL MFOUT		;MULTI FILE OUTPUT TERM
	SETOM TYPING		; MAYBE TYPING
	MOVEI Q1,CP%COP		;IDENTIFY FLAVOR
	JRST COP1A

.APPEN::SETOM TYPGRP		;TYPE ALL FILES
	NOISE <SOURCE FILE>
	TLO	Z,F2		;SAY APPEND, NOT COPY
	CALL .INFG		;GET INPUT FILE GROUP DESCRIPTOR
				;ALLOWS *'S, AND COMMAS IF THEY ARE
				;IMMEDIATE FILE NAME TERMINATOR.
	NOISE <TO>
	MOVSI A,-1		;NO DEFAULTS FOR OUTPUT
	MOVEI B,(GJ%MSG)	;PRINT NEW FILE, ETC.
	CALL SPECFN
	 JRST CERR
	MOVEM A,OUTDSG
	HRRZ A,OUTDSG
	DVCHR
	LDB D,[POINT 9,B,17]
				;NO OTHER DEVICES WORK 12/3/70
	CAIE D,.DVNUL		;DEVICE NULL IS OK
	JUMPN D,[ERROR <Destination file must be on disk>]
	SETZM MCOJFN		;SAY NOT MULTI FILE OUTPUT
	MOVEI Q1,CP%APP		;SAY IT'S AN APPEND COMMAND
COP1A:	TRVAR <CERRF,<CFBUF,EXTSIZ>,POJFLG,<TADBLK,TADLEN>,<TTBLK,10>,SAVPN,SRCTYP,DESTYP,PREPAG,SCRF>
	CAIE Q1,CP%APP		;APPEND?
	CAIN Q1,CP%COP		;OR COPY?
	CAIA			;YES
	JRST COPFL		;NO, CONFIRMATION DONE
	CALL SPRTR		;ANALYZE TERMINATOR, READING MORE IF NEC.
	 SUBCOM $COPY		;READ SUBCOMMANDS
COPFL:	SETO P1,		;SAY NO PREVIOUS COPY IN GROUP
	MOVE A,JBUFP
	MOVEM A,.JBUFP		;SAVE ALL JFNS SO FAR

;TOP OF LOOP OVER INPUT FILE NAMES

COPFLN:	CALL RLJFNS		;RELEASE ANY TEMPORARY JFNS
	IORM A,CERRF		;ACCUMULATE ERRORS DURING THIS FILE
	CALL CTPOK		;TYPE OK IF APPROPRIATE
	SETZM CERRF		;NO ERROR YET
	TLZ Z,F4		;OK SO FAR
	CALL NXFILE		;CHECK FOR NON-EX FILE TERM
	 JRST [	SKIPE INIFH1	;ALL TERMS DONE?
		JRST COPFLN	;NO, NEXT
		JRST COPFLE]	;YES, DONE
	CALL TYPIF		;TYPE INPUT FILE NAME IF PROCESSING GROUP

;WHEN OUTPUT FILE GROUP DESCRIPTORS IMPLEMENTED, DETERMINE HERE
;THE DESTINATION, AND SETO P1, UNLESS THE SAME AS BEFORE.

	CALL MFSET		;SETUP JFN FOR MULTI FILE COPY
	 JRST MCOERR		;ERROR DETECTED, MESSAGE ALREADY PRINTED
	SETZM POJFLG		;ASSUME NOT OUTPUTTING TO PRIMARY JFN
	MOVE A,OUTDSG
	CAMN A,COJFN		;QUICK CHECK HERE
	JRST ISPOJ		;WIN
	DVCHR
	LDB D,[POINT 9,B,17]
	HLL D,C
	MOVE A,COJFN
	DVCHR
	LDB B,[POINT 9,B,17]
	HLL B,C
	CAMN B,D		;SAME DEVICE?
ISPOJ:	SETOM POJFLG		;YES, OUTPUTTING TO PRIMARY JFN

;COPY/APPEND...
;CHOOSE MODE AND BYTE SIZE FOR COPY/APPEND AS A FUNCTION OF
;DEVICES AND SUBCOMMANDS GIVEN.

;AC USE
; RH Q1: BYTE(6) READ MODE,WRITE MODE,BYTE SIZE
; Q2: DISC SOURCE BYTE SIZE

;SET UP Q1 PER SUBCOMMAND, IGNORING FOR THE MOMENT WHETHER MODE
; IS LEGAL FOR DEVICES.

	TRNN Z,1		;BYTE SIZE GIVEN MEANS MODE 0
	SETZ Q1,		;FOR NO SUBCOMMAND, BYTE SIZE IS DEFAULTED LATER
	TXNE Z,ASCF
	MOVEI Q1,010107
	TRNE Z,400
	MOVEI Q1,101044
	TRNE Z,4000
	MOVEI Q1,131344
	TRNE Z,10000
	MOVEI Q1,141444

;COPY/APPEND...
;DETERMINING MODE-BYTESIZE...
;FOR EACH FILE, DO A "DVCHR" TO GET TYPE NUMBER AND TO SEE IF MODE
; IS LEGAL FOR DEVICE.  CHANGE MODE TO 0 IF NOT LEGAL.
;DESTINATION

	HRRZ A,OUTDSG
	DVCHR
	TXNN B,DV%OUT
	ERROR <%1H: Can't do output>
	LDB D,[POINTR B,DV%TYP]
	MOVEM D,DESTYP		;REMEMBER DEVICE TYPE
	CAIE D,.DVDSK		;IS IT A DISK?
	TLO Z,F4		;NO - SET FLAG
	TRZ B,.DVDES
	TRNN Z,(B)		;SKIP IF MODE SUBCOM GIVEN & OK FOR THIS DEVICE
	JRST [	TRZ Q1,007700	;WRITE IN MODE 0
		TRNN B,DV%M0	;CAN DEVICE USE MODE 0 ?
		ERROR <%1H: Can't do normal mode output>
		JRST .+1]

;SOURCE

	HRRZ A,@INIFH1
	DVCHR
	TXNN B,DV%IN
	ERROR <%1H: Can't do input>
	LDB C,[POINTR B,DV%TYP]
	MOVEM C,SRCTYP		;REMEMBER DEVICE TYPE
	CAIE C,.DVDSK		;OUTPUT A DISK?
	TLO Z,F4		;NO - SET FLAG
	CAIN C,.DVTTY		;INPUT A TERMINAL?
	SETOM POJFLG		;YES - SET FLAG
	TRZ B,.DVDES
	TRNN Z,(B)		;SUBCOMMAND GIVEN & OK ?
	JRST [	TRZ Q1,770000	;READ IN MODE 0
		TRNN B,DV%M0	;CAN DEVICE USE MODE 0?
		ERROR <%1H: Can't do normal mode input>
		JRST .+1]
				;ALSO FOR DISK SOURCE GET BYTE SIZE IN Q2
	JUMPN C,COP2A
	HRRZ A,@INIFH1
	MOVE B,[XWD 1,.FBBYV]	;BYTE SIZE IN B6-11
	MOVEI C,Q2
	CALL $GTFDB		;DO GTFDB, NO SKIP ON NO ACCESS
	ERROR <Access to source not allowed>
	LDB Q2,[POINTR Q2,FB%BSZ]
COP2A:

;COPY/APPEND...
;DETERMINING MODE-BYTESIZE...

;IF MODE SUBCOMMAND IS ACCEPTABLE TO ONE DEVICE,
;IT IS ACCEPTED AND MODE 0 USED FOR OTHER DEVICE, PROVIDED OTHER
; DEVICE WILL ACCEPT THE BYTE SIZE (ONLY TTY AND LPT ARE RESTRICTED).
;IF MODE IS ACCEPTABLE TO NEITHER, ACTION DEPENDS ON SUBCOMMAND;
; IF UNACCEPTABLE A WARNING MESSAGE IS TYPED AND DEFAULT EXECUTION
; PROCEEDS, SO THAT A WHOLE GROUP COPY DOESN'T GET ABORTED.

	TRNN Z,177777		;ANY MODE SUBCOMMANDS GIVEN?
	JRST COPDEF		;NO, GO DEFAULT MODE AND BYTE SIZE
	TXNN Z,NRMF		;MODE 0 REQUESTED, OR
	TRNE Q1,777700		;EITHER MODE NON-0?
	JRST COP3		;YES, SUBCOMMAND ACCEPTABLE TO ONE DEVICE

;SUBCOMMAND-DEPENDENT ACTION FOR SBCMD WHOSE MODE IS LEGAL FOR
;NEITHER SOURCE NOR DESTINATION DEVICE

	TXNE Z,ASCF
	JRST [	MOVEI Q1,7	;ASCII ALWAYS LEGAL, USE 0-7.
		JRST COP3]
	TRNN Z,4000		;TREAT "IMAGE BINARY" AS "BINARY"
	TRNE Z,10000
	JRST [	MOVEI Q1,44	;"BINARY", USE 0-36, LEGAL EXCEPT FOR
		JRST COP3]	;TTY OR LPT, DETECTED AT COP3.
				;ONLY IMAGE GETS THRU TO HERE
	JRST COPDF1		;GO TYPE MESSAGE AND DEFAULT
				;IMAGE IS NOT INTERPRETED FOR DEVICES OTHER THAN PAPER
				;TAPE BECAUSE ITS BYTE SIZE WILL PRESUMABLY BE
				;DIFFERENT WHEN IT IS DEFINED FOR OTHER DEVICES.

;IF HERE, ALL SET EXCEPT SUBCOMMAND MAY HAVE SPECIFIED A BYTE SIZE
;ILLEGAL FOR DEVICE. CHECK FOR THAT.

COP3:	LDB B,[POINT 6,Q1,35]	;CHOSEN BYTE SIZE
	MOVE C,SRCTYP
	CAIE C,12
	MOVEM D,DESTYP		;GET DEVICE TYPE OF DESTINATION
	CAIN D,12
	JRST [	CAIE B,7	;TTY TAKES 7 OR 8 ONLY
		CAIN B,10
		JRST .+1
		JRST COPDF1]	;TYPE MESSAGE AND DEFAULT
	CAIN D,7		;LPT TAKES 7 ONLY
	CAIN B,7
	JRST COP4		;ALL IS OK
				;JRST COPDF1

;COPY/APPEND...
;DETERMINING MODE-BYTESIZE...   DEFAULT CASE...
;NO ACCEPTABLE SUBCOMMAND GIVEN.
;DEFAULT MODE AND BYTE SIZE AS A FUNCTION OF DEVICES USED.
;MODE ALWAYS 0 AT PRESENT.

COPDF1:	TYPE < [Illegal mode subcommand being ignored]
>
COPDEF:	JUMPN D,.+3
	SKIPN SRCTYP
				;DISK TO DISK USES SOURCE BYTE SIZE
	SKIPA Q1,Q2		;DISK SOURCE BYTE SIZE IS IN Q2
				;MOST OTHER CASES USE 0-36
	MOVEI Q1,^D36
				;IF TTY: OR LPT: INVOLVED, USE 0-7
	MOVE C,SRCTYP
	CAIN C,.DVCDR		;READING FROM CARD READER?
	MOVEI Q1,7		;YES, USE BYTE SIZE OF 7
	CAIE C,12
	CAIN D,12
	JRST .+2
	CAIN D,7
	JRST [	MOVEI Q1,7
		JRST COP4]

;COPY/APPEND...
;DETERMINING MODE-BYTESIZE...   DEFAULT CASE...
;SPECIAL CASES FOR PAPER TAPE

	CAIE C,4		;PTR
	JRST [	CAIE C,.DVMTA	;MAGTAPE?
		JRST COPDF3
		MOVE A,@INIFH1
		CALL LBLSKP	;LABELLED?
		JRST COPDF3
		CAIE A,.LTANS	;ANSI-ASCII?
		CAIN A,.LTEBC	;EBCDIC?
		SKIPA		;YES, ASCII OR EBCDIC
		JRST COPDF3
		MOVEI Q1,7	;YES, SAY BYTESIZE 7
		JRST COPDF3]
	CAIN D,5		;PTP
	JRST [	MOVEI Q1,^D8	;USES 0-8 TO DUPLICATE PAPER TAPE
		JRST COP4]
	HRRZ B,OUTDSG		;PTR TO OTHER DEVICES DEPENDS ON DEST EXT
	JRST COPDF4
COPDF3:	CAIE D,5		;PTP
	JRST COPDF6
	JUMPE C,[MOVE Q1,Q2	;DSK TO PTP
		CAIN Q2,7	;IF SC BYTE SIZE 7, USE IT, NO MESSAGE.
		JRST COP4
		CAIE Q2,10	;IF 8, USE IT, TYPE MESSAGE
		MOVEI Q1,^D36	;OTHERWISE ASSUME 36 AND TYPE MESSAGE
		JRST COPDF5]	;NOTE THAT CAN'T TRUST SIZE OF 36 IN
				;FILE BECAUSE OTHER SIZES CAN BECOME
				;36 IF FILE IS COPIED TO DTA AND BACK.
	HRRZ B,@INIFH1		;OTHER DEVICES TO PTP, DEPENDS ON SC EXT
COPDF4:				;ONE IS PAPER TAPE, OTHER ISN'T. USE 0-36 FOR FILES
				;WITH EXTENSION OF .REL OR .SAV, 0-7 FOR OTHERS.
				;TYPE MESSAGE.  JFN OF NON-PAPERTAPE DEVICE NOW IN B.
	HRROI A,CFBUF		;SOME STRING SPACE
	SETZM CFBUF		;MAKE SURE NULLS AFTER EXTENSION
	MOVX C,FLD(.JSAOF,JS%TYP)	;GET FILE TYPE
	JFNS
	 ERCAL JERRE
	MOVE A,CFBUF
	CAME A,[ASCIZ /REL/]
	CAMN A,[GETSAVE()]
	JRST .+2		;REL OR SAV, USE 36 (ALREADY IN Q1)
	MOVEI Q1,7		;OTHER EXT OR NON-DIR DEVICE, USE 0-7
				;A MARGINAL ASSUMPTION HAS BEEN MADE ABOUT PAPER TAPE,
				;TYPE EXPLANATORY MESSAGE.
COPDF5:	TYPE < [>
	CAIN Q1,7
	TYPE <ASCII>
	CAIN Q1,10
	TYPE <IMAGE>
	CAIN Q1,44
	TYPE <BINARY>
	TYPE < mode assumed.]
>
				;JRST COP4
COPDF6:				;ADD CASES TO THE DEFAULTING STUFF HEHE
COP4:				;NOW HAVE MODES AND BYTE SIZE IN Q1

;COPY/APPEND...
;HAVE FINISHED CHOOSING MODE-BYTESIZE.
;OPEN FILES NOW, SO FFUFP WILL WORK.

				;SOURCE
	LDF B,OF%RD		;OPEN FOR READ
	LDB A,[POINT 6,Q1,23]	;GET READ MODE FROM Q1
	DPB A,[POINT 4,B,9]
	MOVE C,SRCTYP
	CAIN C,.DVPTR		;PAPER TAPE READER?
	CAIE A,10		;YES, MODE 10?
	CAIA			;NO, USE SPECIFIED BYTE SIZE
	SKIPA A,[8]		;YES, USE 8 BIT BYTES FOR IMAGE MODE
	LDB A,[POINT 6,Q1,35]	;BYTE SIZE
	DPB A,[POINT 6,B,5]
	HRRZ A,@INIFH1		;JFN
	TXO B,OF%PLN		;PASS LINE SEQUENCE NUMBERS
	CAIN C,.DVTTY		;OPEN TERMINAL FOR WRITE ALSO, SO TEXTI WILL WORK
	TXO	B,OF%WR
	MOVE D,DESTYP		;CS56 Get device type of destination
	CAIN D,.DVNUL		;CS56 NUL:?
	 TXO B,OF%PDT		;CS56 Don't update dates (foil users who avoid
				; old file migration by "Copy *.* Nul:")
	CALL OPENX		;OPENF WITH CHECK FOR PRI IO FILES
				;AND FANCY ERROR MESSAGES
				;DESTINATION
	 JRST MCOERR		;FAILED, ERROR PRINTED, GO TO NEXT FILE
	HRRZ A,OUTDSG
	GTSTS
	JUMPGE B,COP5A
				;DEST ALREADY OPEN, ITS ANOTHER COPY IN GROUP, SEE IF
				;MODE-BYTESIZE CONSISTENT, CHANGE WHERE POSSIBLE
	TLO Z,F3		;SAY IT WAS ALREADY OPEN
	MOVE B,Q1		;MODES-BYTESIZE CHOSEN FOR THIS COPY
	XOR B,P1		;COMPARE TO THOSE USED FOR LAST COPY
	CAME P1,[EXP -1]	;First time, always OK.
	TRNN B,7777		;OUTPUT MODE & SIZE THE SAME?
	JRST COP5B		;YES, ALL IS OK
	MOVE D,DESTYP
	JUMPN D,.+2		;IF DEST NOT DSK, CHANGE ILLEGAL
	TRNE B,7700		;FOR DSK SIZE CAN CHANGE BUT MODE CAN'T
	ERROR <Illegal mode or byte size change,
 multiple source copy cannot procede>
	LDB B,[POINT 6,Q1,35]
	JUMPE B,[TYPE < [Byte size = 0, will use 36]>
		MOVEI B,^D36
		JRST .+1]
	SFBSZ
	 CALL JERR
	JRST COP5B

COP5A:				;DEST WASN'T OPEN (NORMAL CASE), OPEN IT
	TLZ Z,F3		;SAY JUST OPENED (HENCE PAGE COPY OK)
	LDF B,OF%WR		;"WRITE" BIT FOR OPENF
	TLNE Z,F2		;SKIP IF "COPY" NOT "APPEND"
	LDF B,OF%APP		;"APPEND" BIT FOR OPENF
	LDB A,[POINT 6,Q1,29]	;GET WRITE MODE FROM Q1
	DPB A,[POINT 4,B,9]
	MOVE C,DESTYP
	CAIN C,.DVPTP		;PAPER TAPE PUNCH?
	CAIE A,10		;YES, MODE 10?
	CAIA			;NO, USE SPECIFIED BYTE SIZE
	SKIPA A,[8]		;YES, USE 8 BIT BYTES FOR IMAGE MODE
	LDB A,[POINT 6,Q1,35]	;BYTE SIZE
	DPB A,[POINT 6,B,5]
	HRRZ A,OUTDSG		;JFN
	CALL OPENX		;OPEN THE OUTPUT FILE
	 JRST MCOERR		;FAILED, DON'T BOMB ENTIRE COPY JUST FOR THIS ONE FILE!
	SETZM SCRF		;NOT STRIPPING CARRIAGE RETURNS
	MOVE D,DESTYP		;GET DEVICE TYPE
	CAIN D,.DVMTA		;MAGTAPE?
	JRST [	MOVE A,OUTDSG	;YES, SEE IF LABELED
		CALL LBLSKP
		 JRST .+1	;NOT
		TXNN Z,ASCF	;WRITING IN ASCII?
		JRST .+1	;NO
		MOVE A,OUTDSG	;PREPARE TO SET MODE OF TAPE
		MOVEI B,.MOSMV	;SAY WE'RE SETTING MODE
		MOVEI C,.TPFNC	;SAY THERE ARE NO FORMATTERS (ONE LINE OF TEXT
				;ASSUMED PER TAPE RECORD)
		MTOPR
		SETOM SCRF	;REMEMBER TO STRIP CRLF'S AND USE SOUTR
		JRST .+1]
COP5B:	MOVE P1,Q1		;SAVE MODE AND BYTE SIZE (NEEDED IF ANOTHER
				;COPY TO SAME FILE OCCURS IN GROUP)

;COPY/APPEND...
;HAVE ESTABLISHED MODE-BYTESIZE AND OPENED FILES.
;NOW DECIDE WHETHER A COPY WITH DISK SOURCE IS TO BE DONE BY BYTES
;OR PAGES (SET F1 FOR PAGES), BECAUSE BYTES CASE REQUIRES SPECIAL
;CHECKS BELOW.

	TLZ Z,F1		;SAY BYTES FOR NOW
	SKIPE SRCTYP
	JRST COP6Z		;NON-DISC SOURCE, NO SPECIAL CHECK
	MOVE D,DESTYP
	TLNN Z,F2+F3		;"APPEND" COMMAND AND OUTFILE ALREADY OPEN
				;(GROUP CASE) CAUSE BYTE COPYING
	JUMPE D,[		;NON-DISK DEST ALWAYS REQUIRES BYTE COPY.
				;BUT IF HERE, DEST IS ALSO DISK, CAN COPY BY
				;PAGES.
		TRNN Z,177777	;DON'T CPY BY PAGES IF MODES SPECIFIED
		TLO Z,F1	;SAY COPY BY PAGES
		JRST COP6Z]	;SKIP SPECIAL CHECK

;COPY/APPEND...
;SPECIAL WARNING CHECKS FOR COPYING/APPENDING FROM DSK BY BYTES.
;(OTHER CASES BRANCHED AROUND THIS CODE ABOVE.)
;CHECK FOR HOLES NOT BEYOND EOF AND ANY PAGES BEYOND EOF IN SOURCE FILE
; AND TYPE WARNING MESSAGES IF FOUND.

				;GET PAGE # OF LAST DATA BYTE INTO B
	HRRZ A,@INIFH1
	SIZEF			;BYTE # OF EOF INTO B
	 CALL JERR
	SUBI B,1		;CONVERT BYTE # OF EOF TO BYTE # LAST DATA BYTE
	JUMPL B,COP6C		;IF IT WAS 0, ITS NOW -1, WHICH IS PAGE #.
	MOVEI C,^D36
	IDIV C,Q2		;36 / BYTESIZE = # BYTES PER WORD
	IDIV B,C		;BYTE # / THAT   MAKES IT WORD #
	IDIVI B,1000		;MAKE IT PAGE # OF LAST DATA BYTE

;TEST FOR FIRST FREE PAGE NOT BEING AFTER LAST DATA BYTE'S PAGE

COP6C:	HRRZ A,@INIFH1
	FFFFP			;FIND FIRST FREE FILE PAGE
	CAMN A,[-1]
	JRST .+3		;NO FREE PAGES IN FILE
	CAIL B,(A)
CS,<	TYPE < [Holes in file]
>>				;CM290
CC,<	TYPE < [Holes in file, See HELP HOLES-IN-FILE for more informatio]
>>				;CM290
				;CHECK FOR USED PAGES AFTER LAST DATA BYTE PAGE
	HRL A,@INIFH1
	HRR A,B			;LAST DATA BYTE'S PAGE
	CALL $FNUFP		;INCREMENT A AND FIND NEXT USED PAGE
	JUMPE A,.+2		;0 RETURNED MEANS NO USED PAGE
	TYPE < [Pages after EOF will not be copied]
>
COP6Z:

;COPY/APPEND...
;IF WE WISH TO CONFIRM EACH COPY IN GROUP, HERE IS WHERE TO DO IT.

;HERE WE TYPE <CRLF> IF OUTPUTTING TO PRIMARY JFN
;THIS IS TO END FILE NAME PREVIOUSLY TYPED OUT

	SKIPN POJFLG
	JRST COP6Y		;SKIP IF TTY NOT INVOLVED
	SKIPN TYPGRP		;PRINT IF FORCED
	TLNE Z,GROUPF		;BUT ONLY IF NAME TYPED BEFORE
	TYPE <

>
COP6Y:

;NOW, AT LAST, WE ARE READY TO COPY. WELL, ALMOST.
;THERE ARE SEVERAL CASES:
; DISK TO DISK,
;	DONE BY PAGES, REPRODUCING "HOLES" AND PAGES AFTER BYTE EOF
; TTY TO ANYTHING, TERMINATED BY ^Z
; DISK TO OTHER DEVICE OR DISK-DISK FOR APPEND OR OUTFILE ALREADY OPEN,
;	PAGE READ AND BYTE WRITE.
; OTHER DEVICE TO DISK, USUALLY BYTE READ AND PAGE WRITE.
; ANY OTHER COMBINATION, DONE ENTIRELY BY BYTES.

				;COMPUTE NEGATIVE NUMBER OF BYTES PER PAGE INTO P2
				;(DONE NOW CAUSE CAN CLOBBER P3)
	MOVEI P2,^D36		;# BITS PER WORD
	LDB P3,[POINT 6,Q1,35]	;# BITS PER BYTE
	IDIV P2,P3		;FORM # BYTES PER WORD
	IMUL P2,[-1000]		;FORM - # BYTES PER PAGE
				;GET DISK SOURCE BYTE EOF IN P3
	HRRZ A,@INIFH1
	MOVE C,SRCTYP
	JUMPN C,COP7A
	SIZEF			;GETS BYTE # OF EOF IN FILE'S BYTESIZE INTO B
	 CALL JERR

;TRANSLATE FROM BYTE SIZE OF FILE TO BYTE SIZE OF COPY.
;NEW PTR = (OLD PTR*(36/NEW BYTE SIZE))/(36/OLD BYTE SIZE)
; WITH ALL DIVISIONS INTEGER AND OUTERMOST ONE ROUNDED UP

	MOVEI C,^D36
	IDIV C,Q2		;Q2: SOURCE FILE (OLD) BYTE SIZE
	MOVE P3,C
	MOVEI C,^D36
	LDB D,[POINT 6,Q1,35]	;COPY (NEW) BYTE SIZE
	IDIV C,D
	MUL B,C
	DIV B,P3
	JUMPE C,.+2		;REMAINDER 0 ?
	ADDI B,1		;NO, ROUND UP.
	MOVE P3,B		;BYTE # OF EOF IN COPY BYTE SIZE
COP7A:
	TLNE Z,F1		;COPY BY PAGES FLAG ON?
	JRST PAGES		;YES, GO COPY BY PAGES

;COPY/APPEND...  DISPATCHING TO VARIOUS EXECUTION CASES...
;COPY BY BYTES OR A COMBINATION OF BYTES AND PAGES.

				;HRRZ A,@INIFH1	;ONE JFN IN A
	HRRZ Q2,OUTDSG		;OTHER ALWAYS IN Q2
				;GENERATE POINTER TO BUFFER W PROPER BYTE SIZE IN Q3
	MOVE Q3,[XWD 440000,BUF1] ;P FIELD AND ADDRESS
	DPB Q1,[POINT 6,Q3,11]	;BYTE SIZE = S FIELD
				;NOW DISPATCH TO THE VARIOUS CASES
	MOVE C,SRCTYP
	MOVE D,DESTYP
	CAIN C,.DVTTY		;SOURCE TTY: ?
	JRST COPTTY		;YES, SPECIAL CODE TO END ON ^Z.
	SKIPE SCRF		;STRIPPING CRLF'S?
	JRST COPBY		;YES, SO DO BY BYTES
	JUMPE C,CPGBYT		;JUMP IF SOURCE DISK
	JUMPN D,COPBY		;JUMP IF DEST NOT DISK
	TLNE Z,F2+F3		;PG OUTPUT OK IF NOT "APPEND" AND
	JRST COPBY		;OUTFILE WASN'T ALREADY OPEN (GROUP)
	JRST CBYTPG		;USE PAGES TO WRITE ON DISK

;COPY BY BYTES WITH TELETYPE SOURCE
;DO BYTE BY BYTE, WATCHING FOR ^Z TERMINATOR

COPTTY:	MOVEI B,CTTEOF		;WHERE TO GO ON EOF PSI
	MOVEM B,EOFDSP		;(DON'T THINK IT CAN OCCUR 11/20/70)
	MOVEI B,4		;ONLY 4 WORD TEXTI HERE
	MOVEM B,TTBLK
	MOVE B,[RD%BRK+RD%BEL+RD%JFN]
	SKIPN SCRF		;CM298 Need to strip CRLF's?
	MOVX B,RD%BRK+RD%JFN	;CM298 No, do it all in one JSYS
	MOVEM B,1+TTBLK
	MOVEM A,2+TTBLK
	HRLM A,2+TTBLK
	SETZM 5+TTBLK
	SETZM 6+TTBLK
COPTT0:	MOVE B,[POINT 7,BUF0]	;INPUT TO FREE PAGE
	MOVEM B,3+TTBLK
	MOVEI B,1000*5		;MAX NUMBER OF CHRS
	MOVEM B,4+TTBLK
COPTT1:	MOVEI A,TTBLK
	TEXTI
	 CALL JERR
	MOVE A,.RDFLG+TTBLK	;CM298 Get termination flags
	TXNN A,RD%BTM		;CM298 Break character?
	JRST [	CALL COPTTS	;CM298 No, dump string
		JRST COPTT0]	;CM298 And read more
	LDB B,3+TTBLK		;GET LAST BYTE STORED
	CAIN B,CTRLZ
	JRST COPTT2
	SKIPN SCRF		;CM298 If not stripping CRLF's
	CAIE B,.CHESC		;CM298 Done on Escape
	TRNA			;CM298 Not done
	JRST COPTT2		;CM298 Done
	CAIE B,.CHLFD		;END OF LINE?
	JRST COPTT1		;NO, READ MORE BEFORE DUMPING (IN CASE SCRF)
	CALL COPTTS		;DUMP STRING
	JRST COPTT0		;GET MORE

COPTTS:	SKIPN SCRF		;STRIPPING CRLF'S?
	JRST COPNCR		;NO
	MOVNI A,1		;REMOVE LINEFEED
	ADJBP A,.RDDBP+TTBLK
	MOVEM A,.RDDBP+TTBLK
	AOS .RDDBC+TTBLK	;SAY THERE'S ROOM FOR ONE MORE CHAR NOW
	LDB A,.RDDBP+TTBLK	;GET CHARACTER BEFORE LINEFEED
	CAIE A,.CHCRT		;CARRIAGE RETURN BEFORE LINEFEED?
	JRST COPNCR		;NO
	MOVNI A,1		;YES, REMOVE IT.
	ADJBP A,.RDDBP+TTBLK	;FIX BYTE POINTER TO NO LONGER INCLUDE CR.
	MOVEM A,.RDDBP+TTBLK	;STORE NEW BYTE POINTER
	AOS .RDDBC+TTBLK	;SAY THERE'S ROOM FOR ANOTHER CHAR NOW
COPNCR:	MOVE A,Q2
	MOVE B,[POINT 7,BUF0]
	MOVNI C,1000*5
	ADD C,4+TTBLK		;NUMBER OF BYTES TO SEND
	MOVE D,[SOUT]		;FIRST ASSUME STANDARD OUTPUT
	SKIPE SCRF		;STRIPPING CRLF'S?
	MOVE D,[SOUTR]		;YES, OUTPUT TO INDIVIDUAL RECORD
	JUMPE C,R		;JUST IN CASE NO BYTES
	XCT D
	ERJMP CJERRE		;To catch problems
	RET

COPTT2:	AOS 4+TTBLK		;FUDGE CHAR COUNT TO NOT SEND ^Z
	CALL COPNCR		;NO CRLF TO REMOVE IF JUST TYPED ^Z
CTTEOF:	HRRZ A,2+TTBLK
	HRROI B,[ASCIZ /
/]
	SETZ C,
	SOUT			;CRLF AFTER ^Z
	JRST CBYEF1		;GO DELETE EXTRA PAGES IF DEST IS DSK

;COPY/APPEND...
;COPY/APPEND BY BYTES, NON-TTY-SOURCE CASE
;USE FULL PAGE SINS AND SOUTS FOR SPEED.

COPBY:	MOVEI B,CBYEOF
	MOVEM B,EOFDSP		;WHERE TO GO ON EOF PSI
	SKIPE SCRF		;STRIPPING CRLF'S?
	JRST COPSCR		;YES, USE DIFFERENT LOOP
COPB1:	MOVE B,Q3		;BYTE PTR
	MOVE C,P2		;BYTE COUNT, NEG FOR NO SPECIAL TERM CHARACTER
	SIN			;INPUT A STRING (JFN ALL SET IN A)
				;SIN CAUSES EOF PSI AFTER READING WHATEVER CHARACTERS
				;THERE ARE IF NOT A WHOLE "COUNT"'S WORTH LEFT IN FILE
	EXCH A,Q2		;GET DESTINATION JFN, SAVE SOURCE JFN
	MOVE B,Q3		;BYTE PTR AGAIN
	MOVE C,P2		;SAME COUNT
	SOUT			;OUTPUT STRING
	EXCH A,Q2		;BACK TO SOURCE JFN
	JRST COPB1		;LOOP TILL EOF PSI

;EOF PSI WHILE COPYING BY BYTES (NON-TTY CASE)
;OUTPUT PARTIAL STRING INPUT BEFORE EOF OCCURRED
; (NOTE THAT C IS UPDATED TO REFLECT THOSE BYTES WHICH WERE READ)

CBYEOF:	EXCH A,Q2		;GET DEST JFN
	MOVE B,Q3		;THAT GOOD OLD BYTE PTR
	SKIPN SCRF		;COUNT IS POSITIVE IF STRIPPING CRLF'S
	SUBM P2,C		;CREATE COUNT IN C OF CHARS THAT WERE INPUT
	SKIPE SCRF
	ADD C,P2		;C HAS POSITIVE NUMBER IF STRIPPING CRLF'S
	JUMPE C,.+2		;0 COUNT, NO SOUT!
	SOUT			;OUTPUT THE LAST PART

;IF DESTINATION WAS DISK, DELETE ANY ADDITIONAL PAGES
; (CLOSF DOES NOT DO THIS, BUT WILL LATER ZERO REST OF LAST PAGE).
;TTY CASE JOINS HERE.

CBYEF1:	HRRZ A,OUTDSG
	DVCHR
	LDB A,[POINT 9,B,17]	;DEVICE TYPE 0 IS DSK
	JUMPN A,COPEOF		;IF NOT DISK, DONE HERE
	TXNE Z,F2		;CM236 Appending?
	 JRST COPEOF		;CM236 Yes, don't try to delete pages of file
				; open for append access
	LDB D,[POINT 6,Q1,35]	;GET BYTE SIZE USED IN COPYING
	HRRZ A,OUTDSG
	RFPTR			;GETS BYTE # OF LAST DATA BYTE IN B
	 CALL JERR
	MOVEI C,^D36
	IDIV C,D		;36/BYTESIZE = # BYTES PER WORD
	IDIV B,C		;BYTE # /THAT = WORD # OF LAST DATA BYTE
	IDIVI B,1000		;MAKE IT PAGE #
	HRR A,B
	HRL A,OUTDSG
CBYEF2:	CALL $FNUFP		;FIND A PAGE
	JUMPE A,COPEOF		;NO MORE PAGES IN FILE, DONE
	MOVE B,A
	SETO A,
	HRLZI C,1
	PMAP			;DELETE THE PAGE
	MOVE A,B
	JRST CBYEF2

;COPY INDIVIDUAL LINES OF TEXT TO INDIVIDUAL OUTPUT RECORDS
;A & Q2/ JFNS, P2/ NEGATIVE COUNT OF BUFFER SPACE, Q3/ POINTER TO BUFFER SPACE

COPSCR:	MOVE B,Q3		;READ DATA INTO BUFFER SPACE
	MOVN C,P2		;USE POSITIVE COUNT SO WE CAN FIND END OF LINE
	MOVEI D,.CHLFD		;SEARCH FOR END OF LINE
	SIN			;READ NEXT LINE (TRAP TO CBYEOF IF END OF FILE)
	ADD C,P2		;CALCULATE NEGATIVE NUMBER OF BYTES TO OUTPUT
	MOVEI D,.CHNUL		;PUT NULL ON LINEFEED IN CASE BUFFER NOW NULL
	DPB D,B
	MOVNI D,1
	ADJBP D,B		;FIX POINTER TO POINT AT POSSIBLE CR
	AOJE C,COPSC1		;IF ONLY LINEFEED, THERE'S NO CR BEFORE IT!
	LDB B,D			;NOW GET CHARACTER BEFORE LINEFEED
	CAIE B,.CHCRT		;CARRIAGE RETURN?
	JRST COPSC1		;NO
	MOVEI B,.CHNUL		;YES, NULLIFY IT IN CASE BUFFER NOW NULL
	DPB B,D
	AOJ C,			;SHRINK BUFFER DUE TO CR (MIGHT BE 0 LENGTH NOW!)
COPSC1:	EXCH A,Q2		;GET OUTPUT JFN, SAVE INPUT JFN
	MOVE B,Q3		;POINT AT BUFFER
	SOUTR			;WRITE A RECORD WITHOUT THE END-OF-LINE (MIGHT BE 0 IN C)
	EXCH A,Q2		;GET INPUT JFN AGAIN
	JRST COPSCR		;LOOP FOR REST OF DATA

;COPY/APPEND...
;COPY FROM DISK, READING BY PAGES AND WRITING BY BYTES.
;TRANSFERS ZEROS FOR HOLES OR BEYOND BYTE EOF.
;ADDED TO SPEED UP DISK TO LPT COPY.
;AT ENTRY: A,Q2: JFNS
;	Q3: BYTE PTR TO BUFFER PAGE
;	P2: - # BYTES / PAGE
;	P3: BYTE # OF EOF
;ALSO:	A: SOURCE JFN,,PAGE #

CPGBYT:	SETOM PREPAG		;INITIALIZE PREFAULTED PAGE WORD
	HRLZ A,@INIFH1
CPGBY2:	MOVEM A,SAVPN		;SAVE PAGE NUMBER
	CALL PREFLT		;PERHAPS IT'S TIME FOR PREFAULTING
	MOVE A,SAVPN		;RESTORE PAGE NUMBER
	RPACS
	TLNN 2,(1B5)		;PAGE EXISTS?
	JRST .+4		;NO, DON'T MAP IT
	MOVE B,[XWD .FHSLF,<BUF1>B44]
	LDF C,PM%RD
	PMAP			;MAP IN THE PAGE

;HAVE A PAGE IN SOURCE FILE, DECIDE WHAT TO DO WITH IT BY
;COMPARING PAGE # AND FILE'S BYTE EOF

	HRRZ C,A		;PAGE #
	IMUL C,P2		; - BYTE # OF FIRST BYTE IN PAGE
	ADD C,P3		;P3: BYTE # OF EOF
	MOVN C,C		;FORM - # BYTES IN OR BEYOND THIS PAGE
	JUMPGE C,CPBEOF		;NONE, DONE.

;TRANSFER PARTIAL PAGE IF THIS IS EOF PAGE, ELSE WHOLE PAGE.

	CAMGE C,P2		;- # BYTES/PAGE
	MOVE C,P2		;MAXIMUM TRANSFER
	RPACS
	TLNN 2,(1B5)		;PAGE EXISTS?
	JRST CPGBY4		;NO, USE ZEROS

;OUTPUT # BYTES IN C

	EXCH A,Q2		;GET DEST JFN
	MOVE B,Q3		;STRING PTR TO BUFFER
	SOUT			;STRING OUTPUT
CPGBY3:	EXCH A,Q2
	AOJA A,CPGBY2		;DO NEXT PAGE

CPGBY4:	EXCH A,Q2
	SETZ 2,
	BOUT			;DO PAGE WORTH OF ZEROS
	AOJL C,.-1
	JRST CPGBY3

;COPY BY PAGES-BYTES EOF. CLEAR BUFFER.

;**;[748]	Remove edit 742 temporary	YKT	AUG-20-82
;**;[742]	Add 4 lines in CPBEOF		YKT	JUL-30-82
;CPBEOF:	MOVE A,Q2		;[742] RESTORE JFN 
;	HRROI B,[15B6+12B13]	;[742] CR AND LF
;	SETZ C,			;[742] 
;	SOUT			;[742] OUTPUT CR/LF
CPBEOF:	SETO A,
	MOVE B,[XWD .FHSLF,<BUF1>B44]
	SETZ C,
	PMAP
	HRRI B,<BUFPRE>_-9	;GET RID OF PREFAULT PAGES
	MOVE C,[PM%CNT+NPRE]	;COUNT BIT+THE COUNT
	PMAP
	JRST COPEOF

;COPY/APPEND...
;COPY NON-DISK TO DISK IN NON-APPEND, NON MULTIPLE SOURCE CASE.
;USES BYTES FOR INPUT, PAGES FOR OUTPUT.
;ADDL ACS: Q2: DEST JFN,,PAGE #
;	P3: # BYTES TRANSFERRED+1, USED TO SET DEST EOF PTR.

CBYTPG:	HRLZ Q2,OUTDSG
	MOVEI B,CBPGEF
	MOVEM B,EOFDSP		;WHERE TO GO ON EOF
	SETZ P3,
CBYPG2:	SETO A,			;CLEAR BUFFER AT TOP OF LOOP TO MAKE SURE
	MOVE B,[XWD .FHSLF,<BUF1>B44] ;...OF EOF PAGE IS 0
	SETZ C,
	PMAP
	HRRZ A,@INIFH1
	MOVE B,Q3
	MOVE C,P2		;NEG # BYTES/PAGE
	SUB P3,C		;COUNT BYTES TRANSFERRED
	SIN			;READ A PAGE'S WORTH OF BYTES
	MOVE B,Q2
	MOVE A,[XWD .FHSLF,<BUF1>B44]
	LDF C,PM%WT
	PMAP			;MAP OUT THE PAGE
	AOJA Q2,CBYPG2		;NEXT PAGE AND LOOP

;BYTES-PAGES END OF FILE

CBPGEF:	ADD P3,C		;ADJUST FOR UNUSED PART OF BYTE COUNT
	CAMN C,P2		;WHOLE PAGE UNUSED?
	SKIPA A,[-1]		;YES, PUT NO PAGE IN DESTINATION
	MOVE A,[XWD .FHSLF,<BUF1>B44]
	MOVE B,Q2
	LDF C,PM%WT
	PMAP			;MAP OUT LAST PAGE OR DELETE PAGE

;FAKE THINGS UP AND ENTER PAGES-PAGES ROUTINE TO DELETE RESET OF DEST
;AND SET EOF AND BYTE SIZE

	SETZ D,			;SAYS NO MORE SOURCE "PAGES"
	JRST PAGE5A

;COPY/APPEND...
;COPY DISK TO DISK BY PAGES
;NOTE THAT BYTE SIZE IN Q1 MUST BE PRESERVED

NPAGES:	^D25			;MOUTH SIZE (LOOK HOW MUCH I GOT IN ONE BITE, MA!)
PAGES:	MOVE A,@INIFH1		;GET SOURCE JFN
	MOVE B,OUTDSG		;AND DESTINATION JFN
	CALL DSKCPY		;COPY THE DATA
	MOVE C,NPAGES		;GET SIZE OF BUFFER
	LSH C,1			;THERE ARE TWO OF THEM
	IORX C,PM%CNT		;REPEATE COUNT
	HRROI A,-1		;SAY REMOVING PAGES
	MOVE B,[.FHSLF,,BUF0PN]	;START FROM BEGINNING OF BUFFER
	PMAP			;REMOVE (ONLY SO CLOSF WILL SUCCEED)
				;POSSIBLE SPEEDUP WOULD BE TO NOT DO
				;CLOSF UNTIL JFN'S WERE USED UP.  THAT
				;WOULD MEAN ONLY HAVING TO DO THIS
				;PMAP ABOUT ONCE PER 100 FILES (BUT
				;AT LEAST ONCE PER COPY COMMAND)
	JRST PAGES1		;GO PUT ON FINISHING TOUCHES

;DISK TO DISK COPY LOOP.  CALL WITH SOURCE JFN IN A AND DESTINATION
;JFN IN B.
;THIS LOOP DOES NOTHING EXCEPT COPY THE DATA, I.E. DOES NO CLOSF OR
;CHFDB'S.

DSKCPY:	STKVAR <NXTBEG,DESBFR,DESPN,BLTPTR,ENDPTR,SAVBLT,SRCJFN,DESJFN,ENDPT0>
	MOVEM A,SRCJFN
	MOVEM B,DESJFN		;REMEMBER JFN'S
	SETZM NXTBEG		;INITIALIZE NEXT PAGE TO BEGIN BUFFER WITH
	MOVE A,NPAGES		;GET NUMBER OF PAGES
	LSH A,9			;MAKE RELATIVE ADDRESS OF DESTINATION BUFFER
	ADDI A,BUF0		;MAKE ACTUAL ADDRESS
	MOVEM A,DESBFR		;REMEMBER WHERE DESTINATION BUFFER STARTS
	LSH A,-9		;CALCULATE DESTINATION PAGE NUMBER
	MOVEM A,DESPN		;REMEMBER THAT TOO
	ADD A,NPAGES		;CALCULATE FIRST PAGE NUMBER BEYOND DESTINATION BUFFER
	LSH A,9			;MAKE ADDRESS
	SOJ A,			;GET LAST ADDRESS IN DESTINATION
	MOVEM A,ENDPTR		;REMEMBER END OF DESTINATION
	MOVEM A,ENDPT0		;REMEMBER VERSION FOR NORMAL FULL FILE CHUNKS
DSKLUP:	HRL A,SRCJFN		;MAP FROM SOURCE JFN
	HRR A,NXTBEG		;STARTING WITH FIRST PAGE OF NEW GROUP
	MOVE B,[.FHSLF,,BUF0PN]	;MAP INTO OUR BUFFER AREA
	MOVX C,PM%RD!PM%PLD!PM%CNT	;READ, PRELOAD, REPEAT COUNT GIVEN
	HRR C,NPAGES		;DO AS MANY AS OUR BUFFER SIZE
	PMAP			;MAP SOME SOURCE PAGES IN
	 ERJMP [	CALL DGETER	;PMAP FAILED, SEE WHY
			CAIE A,LNGFX1	;OFF INTO NONEXISTENT SECTION
			CAIN A,ARGX06	;OR OFF THE END OF ALL POSSIBLE PAGES?
			JRST DSKNEW	;YES, EXPECTED
			CALL JERR]	;NO, UNEXPECTED
DSKLP1:	HRL A,DESJFN		;MAP FROM DESTINATION
	HRR A,NXTBEG		;CORRESPONDING PAGES OF SOURCE
	MOVE B,DESPN		;MAP INTO DESTINATION BUFFER
	HRLI B,.FHSLF		;OURSELF
	MOVX C,PM%WR!PM%CNT	;WRITE, REPEAT COUNT
	HRR C,NPAGES
	MOVE D,ENDPTR		;GET END POINTER
	CAMN D,ENDPT0		;WAS IT CHANGED
	JRST DSKLP2		;NO, PROCEED WITH PMAP
	AOS D			;YES, HOW MUCH DO WE REALLY NEED TO MAP?
	SUB D,DESBFR		;NUMBER OF WORDS
	LSH D,-9		;MAKE IT PAGES
	HRR C,D			;MAP THAT MANY FROM THE DESTINATION FILE
DSKLP2:	PMAP			;SET UP DESTINATION PAGES
	 ERJMP [	CALL DGETER	;FAILED, PRESUMABLY BECAUSE TRYING TO GO OFF END OF WORLD
			CAIE A,ARGX06	;MAKE SURE THAT'S THE PROBLEM
			CALL JERR	;NO, SO UNEXPECTED ERROR
			JRST .+1]	;ENDPTR HAS ALREADY ACCOUNTED FOR THIS
	HRLI A,BUF0		;COPY FROM SOURCE
	HRR A,DESBFR		;TO DESTINATION
	MOVEM A,BLTPTR		;REMEMBER BLT POINTER
DSKBLT:	MOVE B,ENDPTR		;GET ADDRESS OF LAST WORD OF DESTINATION BUFFER
	BLT A,(B)		;COPY THE DATA
	 ERJMP DSKDIS		;DISCONTINUITY, PROBABLY END OF FILE, HOLE, OR QUOTA EXCEEDED
	MOVEM A,SAVBLT		;SAVE HOW FAR WE GOT BEFORE ERROR
	MOVE B,ENDPTR		;GET POINTER TO END OF DESTINATION WE JUST SET UP
	CAME B,ENDPT0		;IS IT A FULL BUFFERFUL?
	JRST DSKDS1		;NO, WE'VE HIT HOLE OR END.
	MOVE A,NPAGES		;GET NUMBER OF PAGES PER BUFFER
	ADDM A,NXTBEG		;UPDATE PAGE TO START WITH
	JRST DSKLUP		;LOOP FOR NEXT PAGE GROUP

DSKDIS:	MOVEM A,SAVBLT		;SAVE HOW FAR WE GOT BEFORE ERROR
	MOVEI A,.FHSLF
	GETER			;GET TYPE OF ERROR
	CAMN B,[.FHSLF,,IOX11]	;NO ROOM?
	CALL CJERRE		;YES
	CAME B,[.FHSLF,,ILLX01]	;NOT ROOM PROBLEM, HIT HOLE OR END?
	CALL JERRE		;NO, UNEXPECTED PROBLEM
DSKDS1:	MOVE A,ENDPT0		;RESTORE BLT POINTER FOR FULL CHUNKS
	MOVEM A,ENDPTR
	LDB A,[331100,,SAVBLT]	;GET MEMORY PAGE NUMBER ASSOCIATED WITH NONX SOURCE PAGE
	SUBI A,BUF0PN-1		;GET RELATIVE POSITION IN BUFFER
	ADD A,NXTBEG		;GET ACTUAL FILE PAGE NUMBER
DSKDS2:	TLNE A,-1		;ARE WE OFF THE END OF THE WORLD?
	RET			;YES, SO WE MUST BE DONE
	HRL A,SRCJFN		;SET UP FOR FFUFP
	FFUFP			;FIND NEXT USED PAGE
	 ERJMP DSKMEF		;FAILED, PROBABLY END OF FILE
	HRRZ C,A		;COPY PAGE NUMBER
	SUB C,NXTBEG		;SEE WHERE IN BUFFER PAGE IS
	CAML C,NPAGES		;IN SUBSEQUENT BUFFER?
	JRST DSKNXT		;YES
	LSH C,9			;NO, IN THIS BUFFER.  MAKE MEMORY OFFSET
	MOVE A,BLTPTR		;GET ORIGINAL BLT POINTER
	ADJSP A,(C)		;ADJUST FOR CONTINUATION
	JRST DSKBLT		;CONTINUE THIS BUFFER

DSKNXT:	HRRZM A,NXTBEG		;REMEMBER NEXT PAGE TO START WITH
	JRST DSKLUP		;GO START NEW BUFFER

DSKMEF:	MOVEI A,.FHSLF
	GETER			;GET REASON FOR FFUFP FAILING
	CAME B,[.FHSLF,,FFUFX3]	;NO MORE USED PAGES?
	CALL JERRE		;NO, UNEXPECTED ERROR
	RET			;YES, DONE!

;COME HERE WHEN PMAP FAILS SOMEWHERE IN THE MIDDLE OF A SOURCE CHUNK.
;THIS IS BECAUSE WE HAVE HIT A NONEXISTENT FILE SECTION.
;WE NOW ASSUME THAT SOME PORTION OF THE SOURCE BUFFER HAS BEEN MAPPED, AND THE
;REST OF THE SOURCE BUFFER IS STILL MAPPED TO PART OF THE PREVIOUS CHUNK.
;HENCE WE CAN'T RELY ON THE BLT TO STOP AT THE END OF THE CURRENT CHUNK!

DSKNEW:	LDB A,[001100,,NXTBEG]	;SEE WHERE IN SECTION WE STARTED
	JUMPE A,[	MOVE A,NXTBEG	;ABORTED CHUNK HAD NONE, START IN VOID.
			JRST DSKDS2]	;GO FIND NEXT EXISTING CHUNK
	MOVN A,A		;NEGATE TO PREPARE TO SUBTRACT
	ADDI A,1000		;SEE HOW MANY PAGES WE MAPPED IN IN ABORTED CHUNK
	LSH A,9			;GET NUMBER OF WORDS MAPPED IN
	ADD A,DESBFR		;GET FIRST WORD OUT OF BOUNDS IN DESTINATION BUFFER
	SOJ A,			;GET LAST WORD TO BE USED IN DESTINATION BUFFER
	MOVEM A,ENDPTR		;SET UP SHORTENED BLT POINTER
	JRST DSKLP1		;GO DO SHORTENED VERSION

;COPY BY BYTES-PAGES COMES HERE AFTER EOF WITH D 0 AND P2,P3,Q2 CORRECT
;TO DELETE REST OF DEST FILE AND SET ITS PTR AND BYTE SIZE.

PAGE5A:	MOVE A,Q2
	CALL $FNUFP		;NEXT PAGE IN DEST
	MOVE Q2,A
PAGES6:	MOVE A,D
	CALL $FNUFP		;ALWAYS NEXT PAGE IN SOURCE
	MOVE D,A
	;...

;HAVE A PAGE IN EACH FILE. DECIDE WHAT TO DO WITH THEM.

PAGES3:	JUMPE Q2,[		;NO MORE PAGES IN DEST
		JUMPE D,PAGES9	;ALSO NO MORE IN SOURCE, DONE.
		JRST PAGES5]	;GO COPY PAGE
	JUMPE D,PAGES4		;NO MORE PAGES IN SOURCE, DELETE REST OF DEST
	MOVEI A,(D)
	CAIG A,(Q2)		;COMPARE SOURCE PAGE # TO DEST PAGE #
	JRST PAGES5

;DELETE DEST PAGES CORRESPONDING TO "HOLE" IN SOURCE

PAGES4:	SETO A,
	MOVE B,Q2
	HRLZI C,1		;PMAP DISPOSAL INFO
	PMAP
	MOVE A,Q2
	CALL $FNUFP		;NEXT PAGE IN DEST
	MOVE Q2,A
	JRST PAGES3		;GO DECIDE AGAIN

;COPY/APPEND...
;COPY BY PAGES...
;COPY A PAGE

PAGES5:	MOVE A,D		;SOURCE JFN AND PAGE NUMBER
	CALL PREFLT		;PERHAPS IT'S TIME FOR PREFAULTING
	MOVE A,D		;SOURCE JFN AND PAGE NUMBER
	MOVE B,[XWD .FHSLF,<BUF1>B44]
	LDF C,PM%RD
	PMAP			;MAP SOURCE PAGE INTO BUFFER
	HRL A,OUTDSG		;DON'T USE Q2 HERE, MAY BE 0!
	HRRI B,<BUF2>B44
	LDF C,PM%WT
	PMAP			;MAP DESTINATION PAGE INTO ANOTHER BUFFER
	 ERJMP CJERRE		;REPORT FAILURE (PROBABLY OVER QUOTA)
	MOVE A,[XWD BUF1,BUF2]
	BLT A,BUF2+777		;COPY DATA
	MOVEI A,(D)		;MASK PAGE # OF PAGE JUST COPIED
	CAIGE A,(Q2)		;COMPARE TO DEST PAGE #
	JRST PAGES6		;PAGE WAS COPIED INTO A HOLE IN DEST

;COPY/APPEND...
;FINISH UP COPY BY PAGES.
;ALSO USED FOR BYTES-PAGES, SO NOTHING DISK-DEPENDENT CAN BE DONE HERE.

PAGES9:	SETO A,			;CLEAR BUFFERS
	MOVE B,[XWD .FHSLF,<BUF1>B44]
	SETZ C,
	PMAP
	HRRI B,<BUF2>B44
	PMAP
	HRRI B,<BUFPRE>_-9	;CLEAR PREFAULT PAGES
	MOVE C,[PM%CNT+NPRE]	;DESIGNATE HOW MANY PAGES TO CLEAR
	PMAP			;CLEAR 'EM

;SET END POINTER OF DESTINATION FILE

PAGES1:	MOVE B,P3		;BYTE COUNT OF SOURCE EOF
	HRRZ A,OUTDSG		;SET POINTER FOR THIS OPENING OF FILE, IN CASE
	SFPTR			;SEQUENTIAL I/O FOLLOWS (GROUP SOURCE CASE)
	 CALL JERR
	HRLI A,.FBSIZ		;SET EOF PTR IN FILE (CLOSF DOES NOT WHEN
	MOVE C,B		;NO SEQUENTIAL OUTPUT HAS BEEN DONE)
	SETO B,
	CALL $CHFDB		;SET FILE DESCRIPTOR BLOCK
	 CALL JERR

;SET BYTE SIZE OF DESTINATION FILE
;(CLOSF DOES NOT SET IT WHEN NO SEQUENTIAL OUTPUT HAS BEEN DONE)

	HRLI A,.FBBYV
	SETZ C,
	DPB Q1,[POINTR C,FB%BSZ] ;BYTE SIZE STILL IN Q1
	HRLZI B,<77B11>B53
	CALL $CHFDB
	 CALL JERR

;COPY OR APPEND COMPLETE.
;PAGE-COPY FALLS IN, ALL OTHER CASES BRANCH HERE.

COPEOF:	TDNE Z,[F2,,-1]		;APPEND/LIST OR ANY SUBCOMMANDS?
	JRST COPDON		;YES, LEAVE NEW DATES
	TLNE Z,F4		;DISK DEVICE?
	JRST COPEF1		;NO - SKIP THIS
	HRRZ	A,@INIFH1	;INPUT JFN
	MOVE	B,[1,,.FBCTL]	;GET CTL WORD FROM FDB
	MOVEI	C,C		;WHERE TO PUT IT
	CALL	$GTFDB		;GET IT
	  CALL	JERR		;SHOULDN'T
	HRRZ	A,OUTDSG	;OUTPUT JFN
	HRLI	A,.FBCTL	;WORD TO CHANGE
	AND	C,[FB%FCF]	;BITS TO SET
	LDF	B,FB%FCF	;MAKE A MASK
	CALL	$CHFDB		;SET IN OUTPUT FILE
	  CALL	JERR		;CHFDB DIED
	HRRZ	A,@INIFH1	;INPUT JFN
	HRLI	B,1
	HRRI	B,.FBUSW	;USER SETTABLE WORD
	MOVEI	C,C		;WHERE TO PUT IT
	CALL	$GTFDB		;GET IT
	  CALL 	JERR		;LOSAGE
	HRRZ 	A,OUTDSG	;OUTPUT JFN
	HRLI	A,.FBUSW	;USER SETTABLE WORD
	SETO	B,
	CALL	$CHFDB		;PUT USER WORD INTO NEW FDB
	  CALL	JERR		;LOSAGE
COPEF1:	HRRZ A,@INIFH1		;INPUT JFN
	MOVEI B,TADBLK		;WHERE TO PUT DATES
	MOVEI C,TADLEN		;HOW MUCH TO GET
	RFTAD			;READ DATES
	 ERJMP [CALL %MESS
		TYPE <Failed to read dates from source file - >
		JRST TDERR]	;MESSAGE AND WRAPUP
	MOVE C,.RSWRT+TADBLK	;GET WRITE DATE
	CAMN C,[-1]		;IF NO WRITE DATE,
	JRST COPDON		;THEN ASSUME NO DATES AVAILABLE
	MOVE D,.RSCRV+TADBLK	;GET CREATION DATE
	CAMN D,[-1]		;IF NO CREATE DATE,
	MOVE D,C		;USE WRITE DATE
	SETOM TADBLK		;CLEAR BLOCK FOR SFTAD
	HRLI A,TADBLK
	HRRI A,1+TADBLK		;MAKE BLT POINTER
	BLT A,TADLEN-1+TADBLK
	MOVEM C,.RSWRT+TADBLK
	MOVEM D,.RSCRV+TADBLK	;STORE DATES TO SET
	MOVE A,OUTDSG
	MOVEI C,TADLEN
	SFTAD
	 ERJMP [CALL %MESS
		TYPE <Failed to set dates for destination file - >
		JRST TDERR]	;MESSAGE AND WRAPUP
COPDON:	SETZM EOFDSP		;(REDUNDANT EXCEPT IN ^Z ON TTY CASE)
	CALL GNFIL		;GET NEXT FILE IN INPUT GROUP
	 JRST COPFLE
	SKIPE POJFLG		;IF OUTPUT TO COJFN
	ETYPE<%_>		;THEN SEPARATE FILENAMES
	JRST COPFLN

MCOERR:	SETOM CERRF		;REMEMBER THAT THIS FILE HAD ERROR
	JRST COPDON

COPFLE:	CALLRET CTPOK		;TYPE OK ON LAST FILE IF APPROPRIATE

;CTPOK TYPES [OK] IF APPROPRIATE.

CTPOK:	SKIPE CERRF		;ERRORS?
	RET			;YES, SO NOT OK.
	SKIPN POJFLG		;IF NOT OUTPUTTING TO PRIMARY JFN, TYPE [OK] HERE
	CALL TYPOK
	RET

TDERR:	CALL	%GETER		;GET ERROR CODE
	MOVE	A,ERCOD		;...
	CALL	$ERSTR		;PRINT MSG
	ETYPE<%_>		;CRLF
	JRST	COPDON		;FINISH UP

;COPY/APPEND...
;SUBROUTINE TO GET NEXT USED PAGE # OF DISK FILE.
;TAKES IN A:  JFN,,CURRENT PAGE #.  RETURNS A 0 IF NO MORE PAGES.
;MUST BE NEAR COPY TO MINIMIZE PAGE FAULTS

$FNUFP:	JUMPE A,[RET]		;ALREADY AT END, NOP.
	ADDI A,1		;NEXT PAGE NUMBER
	TRNN A,-1
	JRST [	SETZ A,		;WRAP-AROUND FROM MAX PAGE NUMBER
		RET]

;ENTRY TO GET FIRST USED PAGE NUMBER. DOESN'T INCREMENT FIRST.

$FFUFP:	FFUFP
	 CALL [	CAIE A,FFUFX3	;"NO MORE PAGES" ERROR?
		JRST JERR
		SETZ A,
		RET]
	RET

;ROUTINE TO PREFAULT DISK PAGES IN.  CALL IT WITH PAGE NUMBER IN RIGHT
;HALF OF "A".  IT RETURNS +1 ALWAYS.  THIS ROUTINE LOOKS IN VARIABLE
;"PREPAG" TO DETERMINE WHICH PAGE NUMBER STARTS THE LAST GROUP OF
;PAGES THAT WAS PREFAULTED IN.  IF THE PAGE NUMBER IN R.H. OF A ISN'T
;IN THIS GROUP, THIS ROUTINE PREFAULTS IN THE GROUP OF WHICH R.H. A
;IS A MEMBER.  THE PAGES ARE PREFAULTED IN TO MEMORY STARTING AT
;LOCATION "BUFPRE", ASSUMED TO BE ON A PAGE BOUNDARY.  "NPRE" (DEFINED
;IN XDEF) DEFINES HOW MANY PAGES TO PREFAULT IN.
;ALSO ASSUMES INIFH1 POINTS TO WORD CONTAINING JFN OF
;FILE OPEN AS SOURCE

PREFLT:	HRRZ A,A		;KEEP ONLY PAGE NUMBER
	IDIVI A,NPRE
	IMULI A,NPRE		;CALCULATE FIRST PAGE OF THE GROUP
	CAMN A,PREPAG		;IS THIS GROUP ALREADY IN?
	JRST PREOUT		;YES, WE'RE DONE

;THE FOLLOWING WAS ADDED TO CORRECTLY HANDLE LONG FILES.
;IF AN ATTEMPT IS MADE TO PRELOAD A PAGE FROM A NONEXISTENT
;SECTION, A FILE OPENED FOR READ-ONLY ACCESS (OF%RD IN OPENF)
;PMAP WILL BARF SINCE IT CAN'T CREATE A PAGE TABLE WITHOUT WRITE
;ACCESS TO THE FILE. ALL THIS CODE DOES IS ELIMINATE THE ANNOYING
;ERROR MESSAGE GENERATED BY JWARN WHEN THIS OCCURS.
;					B.TOMCZAK 9/14/79

	HRRZ A,A		;NO - CLEAR OUT ANY OTHER TRASH
	CAIG A,777		;SEC GREATER THAN 0?
	JRST PREMAP		;NO, SEC 0 ALWAYS EXISTS

	PUSH P,A		;SAVE THE PAGE NUMBER DESIRED
	SKIPGE B,PREPAG		;HAVE WE ALREADY DONE A MAPPING?
	JRST CHKSEC		;NO, SO JUST CHECK CURRENT

	ADDI B,NPRE-1		;GET LAST PG# OF LAST GROUP
	XOR B,A			;CHECK SEC#'S
	TRNE B,777000		;CURR IN SAME SEC AS PREVIOUS?
CHKSEC:	 JRST [	ANDI A,777000	;NO, GET 1ST PG IN CURRENT SEC
		MOVEM A,B	;AND SAVE IT
		HRL A,@INIFH1	;A/   JFN,,PG#
		CALL $FFUFP	;FIND NEXT USED PAGE
		JUMPE A,[POP P,A ;ZERO MEANS NOTHING IN USE AFTER THIS
			  RET]

		XOR B,A
		TRNN B,777000	;NEXT USED PAGE IN SAME SEC?
		JRST .+1	;YES, MAPPING WILL BE OKAY
		POP P,A		;NO, NONEXISTENT SEC
		RET]		;MAPPING WILL FAIL
	POP P,A			;RESTORE T1 TO PREVIOUS GLORY

PREMAP:	MOVEM A,PREPAG		;READ IN THIS GROUP
	HRL A,@INIFH1		;GET HANDLE ON FIRST PAGE OF GROUP TO BE READ IN
	MOVE B,[.FHSLF,,<BUFPRE>_-9]	;GET HANDLE ON AREA WE'RE READING INTO
	MOVE C,[PM%CNT+PM%PLD+NPRE]	;COUNT GIVEN, PREFAULT, HOW MANY PAGES]
	PMAP			;START THE PAGES IN
	 JWARN			;GIVE WARNING IF THIS PMAP FAILS
PREOUT:	RET

;COPY/APPEND SUBCOMMAND TABLE AND ROUTINES

$COPY:	TABLE
	T ASCII
	T BCD,ONEWRD,NIYE,CM%INVIS
	T BINARY,ONEWRD
	T BYTE
	T DUMP,ONEWRD,NIYE,CM%INV
	T IMAGE
	T RECORD,,,CM%INVIS
	TEND

PARF==1B18			;PARITY CHECK

.ASCII::KEYWD $ASCII
	 T NOPARITY,,ASCF
	 JRST CERR
	CONFIRM
ASCII2:	TXNE P3,PARF
	TYPE < ["ASCII PARITY" not implemented yet, will treat as "ASCII"]
>
	HRR Z,P3		;NEW FLAGS FROM TABLE ENTRY
	RET

$ASCII:	TABLE
	T NOPARITY,,ASCF
	T PARITY,,PARF+ASCF	;PARF: PARITY CHECK. ASCF: ASCII MODE
	TEND

.BINAR::HRRI Z,10000		;"BINARY" MODE BIT (MODE 14)
	RET

.BYTE:	NOISE (SIZE)
	DECX <Byte size in decimal>
	 CMERRX
	CONFIRM
	MOVEI Q1,0(B)		;BYTE SIZE GOES IN Q1 WITH MODES 0
	TXO Z,NRMF		;SAY NORMAL MODE
	RET

.IMAGE::MOVEI B,[FLDDB. .CMCFM,,,,,[FLDDB. .CMKEY,,$IMAGE]]
	CALL FLDSKP		;CONFIRMATION OR KEYWORD
	 CMERRX <"BINARY" or nothing>
	LDB C,[POINT 9,(C),8]	;PICK UP FUNCTION CODE
	CAIN C,.CMCFM		;NO ARG TO "DETACH"?
	MOVEI B,[T ,,400]	;DUMMY ARG FOR NOTHING TYPED
	CAIE C,.CMCFM
	CONFIRM			;IF NO CONFIRMATION YET, DO IT NOW
	MOVE P3,(B)		;GET TABLE ENTRY
	MOVE P3,(P3)		;GET CONTENTS OF WORD POINTED TO BY TABLE ENTRY
	JRST ASCII2		;GO PROCESS MODE

$IMAGE:	TABLE
	T BINARY,,4000
	TEND

.RECOR::NOISE (LENGTH)
	JRST NIYE

;OPEN FILE SUBROUTINE
;DOES OPENF, RETURNS ON SUCCESS, GIVES MESSAGE ON FAILURE
;CALL WITH A & B SET UP FOR "OPENF" JSYS.
;CHECKS FOR AND DOES NOT RE-OPEN PRI I/O FILES
; (PRI FILES ARE SOMETIMES DEFAULT ARG VALUES).

$OPEN7::HRLI B,<7B5+0B9>B53	;ENTER HERE FOR 7 BIT BYTES NORMAL MODE
$OPENF::CALL OPENX		;TRY TO OPEN FILE
	 JRST ERRFIN		;GO BACK TO TOP LEVEL IF FAILS
	RET			;SUCCEEDED

;ROUTINE LIKE ABOVE, BUT SKIPS IFF SUCCESS.

OPENX:	STKVAR <OFJFN>
	MOVEM A,OFJFN
	CALL $IOCHK		;SPECIAL CHECK FOR PRIMARIES AND EXEC IO
	RETSKP			;SPECIAL (ALREADY OPEN)
	OPENF			;OPEN FILE
	 CAIA			;FAILED
	RETSKP
	MOVE C,OFJFN		;RETRIEVE JFN FOR %S

;ENTER HERE WITH ERROR CODE IN A AND JFN IN C
;SHOULD BE CALLED WITH "CALL OPNERR" SO JERR PRINTS CORRECT PC

OPNERR::MOVEI D,0		;SO WE'LL KNOW IF WE CATCH A FISH
	CAIN A,OPNX2		;NONX FILE?
	MOVE D,[LERROR <File is empty: %3S>]
	CAIN A,OPNX3
	MOVE D,[LERROR <Read protection violation for: %3S>]
	CAIN A,OPNX4
	MOVE D,[LERROR <Write protection violation for: %3S>]
	CAIN A,OPNX6
	MOVE D,[LERROR <Append protection violation for: %3S>]
	CAIN A,OPNX7
	JRST [	MOVE A,C
		DVCHR
		HLRZ C,C
		MOVE D,[LERROR <%1H: is assigned to job %3Q>]
		CAIN C,777777	;CM236 Is it real job number?
		MOVE D,[LERROR <%1H: can not be assigned>] ;CM236
		JRST OPNE1]
	CAIN A,OPNX8
	MOVE D,[LERROR <%3H: is not on-line>]
	CAIN A,OPNX9
	MOVE D,[LERROR <File is busy: %3S>]
;**;[743]	Add 2 lines at OPNERR+16	YKT	04-JUL-82
	CAIN A,OPNX9+4						;[743] 
	MOVE D,[ETYPE <%_ %%Invalid access requested: %3S %_>]	;[743]
	CAIN D,0		;IF OTHER ERROR, USE SYSTEM'S VERSION
	MOVE D,[LERROR <%?: %3S>]
OPNE1:	XCT D			;PRINT ERROR MESSAGE
	RET			;SINGLE SKIP RETURN

;ENTER HERE TO CHECK FOR PRIMARY OR EXEC IO ALREADY OPEN
;IF PRIMARY OR EXEC IO, CHECK MODE AND BYTE SIZE

$IOCHK:	CAIE A,.PRIIN		;DON'T OPEN PRIMARY IO
	CAIN A,.PRIOU
	RET
	CAME A,CIJFN		;DON'T OPEN EXEC IO FILES
	CAMN A,COJFN
	RET
	RETSKP			;TELL CALLER NOT SPECIAL

;"REDIRECT" AND "DETACH" COMMANDS

;REDIRECT (INFILE) <NAME>/* (OUTFILE) <NAME>/* (AND) START/REENTER/CONT

;DETACH IS SAME SYNTAX AND HAS SAME MEANING EXCEPT IT DETACHES
; TERMINAL AFTER REDIRECTING IO.
;ALL ARGUMENTS CAN BE OMITTED AND DEFAULT TO NULL

.DETAC::TLO Z,DTACHF		;SET "DETACH" FLAG

;START/REENTER/CONTINUE ARGUMENT

	NOISE <AND>
	MOVEI B,[FLDDB. .CMCFM,,,,,[FLDDB. .CMKEY,,$REDIR]]
	CALL FLDSKP		;CONFIRMATION OR KEYWORD
	 CMERRX <"START", "REENTER", "CONTINUE", or nothing>
	LDB C,[331100,,(C)]	;PICK UP FUNCTION CODE
	CAIN C,.CMCFM		;NO ARG TO "DETACH"?
	MOVEI B,[T NOTHING,,<[XWD ..DTCH,[RET]]>]	;DUMMY ARG FOR NOTHING TYPED
	CAIE C,.CMCFM
	CONFIRM			;IF NO CONFIRMATION YET, DO IT NOW
	MOVE P3,(B)		;GET TABLE ENTRY
	MOVE P3,(P3)		;GET CONTENTS OF WORD POINTED TO BY TABLE ENTRY

;P3 POINTS TO A WD WHOSE RH POINTS TO A SUBR TO FINISH DECODING
;  AND CHECK THE ARGUMENT.

	MOVE A,FORK		; SET FORK HANDLE OF CURRENT FORK
	MOVE B,(P3)
	CALL (B)		;CALL ARGUMENT-DEPENDENT DECODE & CHECK SUBR
	TLNE Z,DTACHF
	ETYPE < Detaching job # %J
>
;**;[727]	Delete 2 lines at .DETAC:+25L	KR	29-APR-82
	HLRZ A,(P3)
	JRST (A)		;DISPATCH TO
				;FINAL-ARGUMENT-DEPENDENT EXECUTION ROUTINE

;TABLE FOR THIRD ARGUMENT
;VALUE POINTS TO A WORD --
;	RH: DECODE-AND-CHECK SUBR ADDRESS
;	LH: EXECUTION DISPATCH ADDRESS

$REDIR:	TABLE
	T CONTINUE,,<[XWD ..CONT,$CONTI]>
	T REENTER,,<[XWD ..REEN,$REENT]>
	T START,,<[XWD ..STRT,$START]>
	TEND

;EXECUTION ROUTINE FOR NULL THIRD ARGUMENT

..DTCH::TLNE Z,DTACHF
	DTACH
	 ERCAL CJERRE		;CM189 Handle failure
;**;[727]	Insert 2 lines at ..DTCH:+2L	KR	29-APR-82
	MOVEI Q1,ETTYMD		;TTY MODES FOR USE WHEN EXEC IS RUNNING
	CALL LTTYMD		;PUT SAME INTO EFFECT NOW.
	JRST CMDIN4

;..CONT, ..REEN, ..STRT ARE WITH THE CORRESPONDING COMMANDS.


REPEAT 0,<			;CM278

;CM278 Bulletin command

.BULLE::NOISE <to Campus Information>
	CONFIRM
	MOVX A,RC%EMO		;Find me the directory number
	HRROI B,[ASCIZ/PS:<CI00>/] ;For this name
	RCDIR%
	TXNE A,RC%NOM		;No match?
	ERROR <Unable to find Campus Information's directory>
	MOVE A,C		;Check out the directory
	GTDAL%
	CAMLE B,C		;Usage gtr Permanent quota?
	ERROR <Campus Information's directory is over permanent quota>
	PROMPT <Your name? >	;Initialize for new line with this prompt
	LINEX <Your name>	;Get sender's name
	 CMERRX
	CONFIRM
	MOVE A,CSBUFP		;Start building the message
	HRROI B,[ASCIZ/
/]
	SETZ C,
	SOUT%
	SETO B,			;Timestamp the message
	ODTIM%
	HRROI B,[ASCIZ/
From: /]
	SOUT%
	MOVE B,CMABP		;Insert name
	SOUT%
	HRROI B,[ASCIZ/
Subject: /]
	SOUT%
	MOVE P1,A		;Save pointer so far
	PROMPT <Subject? >
	LINEX <One line subject of message>
	 CMERRX
	CONFIRM
	MOVE A,P1
	MOVE B,CMABP
	SETZ C,
	SOUT%
	HRROI B,[ASCIZ/
/]
	SOUT%
	MOVE P1,A
	TYPE <Enter message (Terminate by pressing ESC key):

>
	PROMPT <>
	MOVEI B,[FLDDB. .CMUQS,,[EXP 1B<"">,0,0,0]]
	CALL FLDSKP
	 CMERRX
	MOVE A,CMPTR
	SETZ B,
	IDPB B,A
	MOVE A,P1
	MOVE B,CMBFP
	SETZ C,
	SOUT%
	HRROI B,[ASCIZ/
/]
	SOUT%
	HRROI B,[ASCIZ/PS:<CI00>BULLETIN.FILE/]
	CALL TRYGTJ		;Get file for output
	 JRST [ERROR <Unable to access Campus Information file>]
	MOVX B,OF%APP+FLD(7,OF%BSZ)
	OPENF%
	 JRST [ERROR <Unable to access Campus Information file>]
	MOVE B,CSBUFP		;Give it the message
	SETZ C,
	SOUT%
	CLOSF%			;Done with it
	 TRN
	TMSG <Message sent to Campus Information>
	RET

> ;CM278 end REPEAT 0

END
