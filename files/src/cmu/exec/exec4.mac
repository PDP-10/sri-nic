;<EXEC.CMU>EXEC4.MAC.14,  4-Apr-85 21:55:27, Edit by VAF
;CS146 Changes for new fascist password policy
;<EXEC.CMU>EXEC4.MAC.13, 15-Feb-85 14:11:13, Edit by VAF
;Remerge CC/CS:
;CM391 CC: System group numbers are less than 550 octal now.
;CS115 Remove CS conditionals around MKDIR/RMDIR.
;<EXEC.CMU>EXEC4.MAC.12, 15-Feb-85 13:04:25, Edit by VAF
;CS115 Allow MKDIR to specify directory number.
;CM290 Allow MAIL-ONLY at CC. Make REPEAT-LOGIN-MESSAGES invisible.
;<EXEC.CMU>EXEC4.MAC.11,  8-Feb-85 16:26:58, Edit by VAF
;CS117 Minor bugfixes to ^EMOUNT and ^EDISMOUNT.
;<EXEC.CMU>EXEC4.MAC.10,  3-Jan-85 16:09:40, Edit by VAF
;CS115 Only confirm RMDIR if directory is not empty.
;      Clear /NOT: before each MKDIR switch.
;<EXEC.CMU>EXEC4.MAC.9, 17-Jul-84 10:14:28, Edit by VAF
;CS115 BLT in .SDMKD wasn't restartable... Fix it.
;<EXEC.CMU>EXEC4.MAC.8,  2-Jul-84 13:43:36, Edit by VAF
;CS115 Properly setup default dir/user/subdir group blocks in MKDIR.
;<EXEC.CMU>EXEC4.MAC.7, 30-Jun-84 14:43:11, Edit by VAF
;CS115 Allow wildcards in RMDIR.
;<EXEC.CMU>EXEC4.MAC.6, 27-Jun-84 12:54:08, Edit by VAF
;CS115 Setup TRVAR's in SET DEFAULT MKDIR...sigh.
;<EXEC.CMU>EXEC4.MAC.4,  9-Mar-84 13:57:15, Edit by VAF
; CS115 Reorganize to be cleaner. Add MKDIR defaults & switches support.
;<EXEC.CMU>EXEC4.MAC.3,  1-Mar-84 20:38:35, Edit by VAF
; CM46	At CC, print either man-number or octal group, not both.
; CS117 Add ^EMOUNT and ^EDISMOUNT commands.
; CS115 Major revision of BUILD code. Make it "do the right thing" for new
;	directories, when possible. Add MKDIR variation on BUILD command.
;	Add RMDIR command. Allow userids as groups in BUILD at Comp Center.
; EM139 Fix EM135 below & kluge it...
; EM135 Don't case fold MRA
; EM20	Casify directory group names
; CM369	Make CM369 be CC-only.
;<5.1.EXEC>EXEC4.MAC.3, 10-Aug-83 17:03:23, Edit by GM0W
;{C369}	Add TERMINAL-MAINTENANCE capability
;CM229	Replace IOOPERATOR with GALAXY-OPERATOR
;<5.1.EXEC>EXEC4.MAC.2,  3-Dec-82 01:04:46, Edit by PA0B
;Merge CMU v5:
; CM9   Octal group numbers
; CM16  Never print passwords
; CM17  Adminitrator caps
; CM46  Group numbers hashed from userid's
; CM229 Iooperator caps
; CM290 CS has preserve
; CM290 At CS, default is files-only unless directory is being created
;	by an enabled administrator
; CM290 Add owner groups to build
; CM290 Translate groups to user names
; CM290 Default to not seting CD%LOQ for new directories
; CM290 Subdirs at CS don't have perminant quota
; CM290 Mail-only
; CM301 Mail-routing addresses
; UPD ID= 120, SNARK:<5.EXEC>EXECIN.MAC.21,  28-Dec-81 11:14:01 by CHALL
;TCO 5.1644 - UPDATE COPYRIGHT NOTICE
; UPD ID= 35, SNARK:<5.EXEC>EXEC4.MAC.3,  14-Aug-81 19:12:47 by CHALL
;TCO 5.1454 CHANGE NAME FROM XDEF TO EXECDE
;<HELLIWELL.EXEC.5>EXEC4.MAC.1, 14-May-81 13:08:54, EDIT BY HELLIWELL
; UPD ID= 591, SNARK:<5.EXEC>EXEC4.MAC.5,   3-Jun-80 09:33:13 by OSMAN
;<5.EXEC>EXEC4.MAC.4,  2-Jun-80 16:41:52, EDIT BY OSMAN
;tco 5.1057 - Allow ENABLE, DISABLE, and PUSH under BUILD
;<5.EXEC>EXEC4.MAC.3,  8-May-80 14:03:45, EDIT BY OSMAN
;Remove R.L.5 and R.GE.5 macro calls and contents
; UPD ID= 424, SNARK:<4.1.EXEC>EXEC4.MAC.6,   9-Apr-80 14:02:16 by OSMAN
;tco 4.1.1141 - Fix ACCOUNT handling
; UPD ID= 413, SNARK:<4.1.EXEC>EXEC4.MAC.5,   4-Apr-80 17:42:29 by LYONS
;ADD CODE FOR ARPANET ACCESS AND DECNET ACCESS
; UPD ID= 200, SNARK:<4.1.EXEC>EXEC4.MAC.4,  10-Jan-80 14:44:43 by OSMAN
;tco 4.1.1064 - Ask for password after BUILD subcommands if needed.
; UPD ID= 194, SNARK:<4.1.EXEC>EXEC4.MAC.3,   8-Jan-80 14:28:44 by OSMAN
; UPD ID= 191, SNARK:<4.1.EXEC>EXEC4.MAC.2,   8-Jan-80 14:06:56 by OSMAN
;tco 4.1.1060 - Warn about non-accessed directories under INFO DIR
;<4.EXEC>EXEC4.MAC.49, 14-Sep-79 16:06:41, Edit by LCAMPBELL
; Account for DTIVX skip returning
;<4.EXEC>EXEC4.MAC.48, 12-Sep-79 10:36:05, EDIT BY OSMAN
;Use LERROR at NODIR instead of ERSTR
;<4.EXEC>EXEC4.MAC.44, 13-Jul-79 15:46:33, EDIT BY OSMAN
;TCO 4.2327 - PREVENT ?EXEC FREE SPACE EXHAUSTED - INFO DIR PS:[*]
;<4.EXEC>EXEC4.MAC.43, 21-Jun-79 13:36:15, EDIT BY OSMAN
;REMOVE EXTRANEOUS REF TO RLJFNS
;<4.EXEC>EXEC4.MAC.42,  7-Jun-79 14:15:20, EDIT BY EKLUND
;tco 4.2277 - add repeat-login-messages subcommand to build (again!)
;<4.EXEC>EXEC4.MAC.41,  6-Jun-79 10:40:14, EDIT BY HELLIWELL
;CHANGE WHLUO & OPRUO TO WHLU & OPRU IN "PRESERVE" SUBCOMMAND (NOSHIP)
;<4.EXEC>EXEC4.MAC.39,  1-May-79 11:20:10, EDIT BY OSMAN
;CHANGE GTJFN TO CALL GTJFS SO THAT ^C CAN'T LEAVE JFN AROUND
;<4.EXEC>EXEC4.MAC.38, 12-Mar-79 17:51:10, EDIT BY KONEN
;UPDATE COPYRIGHT FOR RELEASE 4
;<4.EXEC>EXEC4.MAC.37, 28-Feb-79 11:05:02, EDIT BY OSMAN
;REMOVE REFS TO CTYPE (USE ETYPE INSTEAD)
;<4.EXEC>EXEC4.MAC.36,  7-Feb-79 13:51:39, EDIT BY OSMAN
;FIX PRINTOUT (GET RID OF _)
;<4.EXEC>EXEC4.MAC.34, 23-Jan-79 10:36:21, EDIT BY OSMAN
;CLEAR F1 ("NOT") BEFORE EACH "BUILD" SUBCOMMAND
;<4.EXEC>EXEC4.MAC.30, 18-Jan-79 18:08:55, EDIT BY OSMAN
;CHANGE THOSE SEMIS TO XARC
;<4.EXEC>EXEC4.MAC.27, 22-Dec-78 09:38:02, EDIT BY OSMAN
;put semicolons in front of all offline-exp/online-exp/archive-online stuff
;because we're not doing that stuff for r4
;<4.EXEC>EXEC4.MAC.26,  9-Nov-78 14:44:12, EDIT BY OSMAN
;TCO 4.2086 - FIX GRPCHK
;GET RID OF REFS TO UGBUF ETC.  (MAKE THEM LOCAL REFS)
;<4.EXEC>EXEC4.MAC.17, 27-Sep-78 14:00:47, EDIT BY OSMAN
;CHANGE "B5" REFS TO 1B5 (VIA SYMBOL "NOTF")
;<4.EXEC>EXEC4.MAC.13, 15-Sep-78 23:21:51, EDIT BY OSMAN
;REMOVE ALL REFS TO CSBUFP
;<4.EXEC>EXEC4.MAC.12, 14-Sep-78 14:10:08, EDIT BY OSMAN
;ONLY SEARCH XDEF, TTITLE DOES REST
;<4.EXEC>EXEC4.MAC.11, 13-Aug-78 14:00:27, Edit by HELLIWELL
;MAKE PRESERVE SUBCOMMAND CALL PRVCK
;<4.EXEC>EXEC4.MAC.10, 29-Jul-78 14:49:17, Edit by HELLIWELL
;ALWAYS CONVERT DIRECTORY NAME TO CONONICAL FORM AT CRET1
;<4.EXEC>EXEC4.MAC.7, 17-Jul-78 10:55:52, EDIT BY OSMAN
;GET RID OF GTBUF (USE LOCAL BLOCK IN PLACES WHERE ITS REFERENCED)
;<4.EXEC;MAKE DFBUF BE LOCAL
;<4.EXEC>EXEC4.MAC.4, 11-Jul-78 16:39:41, EDIT BY OSMAN
;MAKE ^EPRINT AND ^ECREATE USE LOCAL STORAGE
;<4.EXEC>EXEC4.MAC.3,  9-Jun-78 18:05:29, EDIT BY OSMAN
;CHANGE CALLS TO FIELD TO FLDSKP
;<4.EXEC>EXEC4.MAC.2,  6-Jan-78 12:18:11, EDIT BY HELLIWELL
;<4.EXEC>EXEC4.MAC.1,  6-Jan-78 12:08:14, EDIT BY HELLIWELL
;ADD "PRESERVE (SUPERIOR QUOTAS)" SUBCOMMAND TO CREATE/BUILD

;TOPS20 'EXECUTIVE' COMMAND LANGUAGE

;THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY ONLY BE USED
;  OR COPIED IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
;COPYRIGHT (C) 1980,1981,1982 BY DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.

	SEARCH EXECDE
	TTITLE EXEC4

;THIS FILE CONTAINS THE PRIVILEGED COMMANDS '^EPRINT' AND '^ECREATE'

;^E PRINT (NAME) <DIRECTORY NAME> [VERBOSE]
;"VERBOSE" MAY ONLY BE ENTERED AS A SUBCOMMAND.  4/21/77 EO

;PRINTS ALL OF THE CHARACTERISTICS ASSOCIATED WITH A DIRECTORY:
; PASSWORD, PRIVILEGES, MODE, SPECIAL RESOURCE INFO, DIRECTORY NUMBER,
;     DEFAULT FILE PROT, DIREC PROT, FILE RETENTION SPECS,
;     DIRECTORY & USER GROUPS.
;ADD'L KEYWORD "VERBOSE" OR SUBCOMMAND "VERBOSE" CAUSES ALL TO
;BE PRINTED, OTHERWISE ONLY NON-DEFAULT FIELDS.

EPRINT::TRVAR <<EPBLK,GTDLN>,EPFLG,EPDIR,EPWLS>
	SETZM EPBLK		;NO BLOCK TO RELEASE YET
	NOISE <DIRECTORY NAME>
	TLZ Z,F1		;ALLOW CURRENT DIR AS DEFAULT
	CALL CURNMS		;INPUT DIRECTORY NAME, GET # AND BITS IN A
	 ERROR <No such directory>
	MOVEM A,EPFLG		;SAVE THE FLAGS FROM RCDIR
	MOVEM B,EPWLS		;SAVE THE POINTER TO THE STRING
	MOVEM C,EPDIR		;SAVE THE DIR #
	TLZ Z,F3!F4		;INITIALIZE FLAGS
	CALL SPRTR		;ANALYZE & CHECK TERMINATOR
	 SUBCOM $PRINT		;READ SUBCOMMANDS
EPR1:	MOVEI A,EPBLK
	SKIPE EPBLK		;IS THERE A PREVIOUS BLOCK?
	CALL RELDIR		;YES, RELEASE FREE SPACE USED
	MOVE A,EPDIR		;GET THE DIR NUMBER
	TLNE Z,F4		;NAME-ONLY?
	JRST EPR3		;YES, DONT DO THE GETDIR
	MOVEI C,EPBLK		;BLOCK INTO WHICH TO READ THE INFO
	CALL GETDIR		;DO THE GTDIR JSYS
	 JRST [	MOVE A,EPDIR	;GET DIRECTORY NUMBER THAT FAILED
		ETYPE <%%%%? - %1R%%_>	;SAY WHY THE FAILURE
		JRST EPR2]	;DO REST IN SET
	MOVEI A,EPBLK		;GET ADDRESS OF BLOCK
	CALL GRPCHK		;CHECK FOR GROUP OVERFLOWS
EPR3:	MOVE A,EPDIR		;GET THE DIR NUMBER FOR DIRPNT
	MOVEI B,EPBLK		;GET BLOCK ADDRESS
	CALL DIRPNT
EPR2:	MOVE A,EPDIR		;NOW STEP TO THE NEXT DIR (IF ANY)
	MOVE B,EPWLS		;GET POINTER TO ORIGINAL STRING
	MOVE C,EPFLG		;GET FLAGS
	TXNE C,RC%WLD		;ANY WILD CARD CHARACTERS IN STRING?
	CALL STPDIR		;YES, GO STEP THE DIR NUMBER
	 JRST UNMDIR		;NO MORE DIRS, UNMAP DIR PAGES
	MOVEM A,EPDIR		;SAVE THE NEW DIR NUMBER
	JRST EPR1		;LOOP BACK FOR THE OTHER DIRS

;DIRPNT
;PRINT DIRECTORY DESCRIPTION FROM GTDIR-FORMAT BLOCK THAT Q1 POINTS TO.
;OMITS DEFAULT VALUES UNLESS BIT F3 IN LH Z IS ON.
;PRINTS THE DIR NAME ONLY IF F4 IN LH Z IS ON.
;FOR "PRINT" COMMAND AND FOR "LIST" SUBCOMMAND OF "CREATE".
;ACCEPTS IN A/	DIR NUMBER OR POINTER TO DIR NAME STRING
;ACCEPTS IN B/ ADDRESS OF CRDIR-FORMAT BLOCK CONTAINING INFO

DIRPNT:	SAVEAC <P1>		;GET A PERMANENT AC TO USE FOR ADDRESS
	STKVAR <DACTPR,<DFBUF,GTDLN>,DMRAPR> ;CM301
	MOVE C,.CDDAC(B)	;GET ACCOUNT POINTER
	MOVEM C,DACTPR		;REMEMBER POINTER TO ACCOUNT
	MOVE C,.CDMRA(B)	;CM301 Same for mail routing address
	MOVEM C,DMRAPR		;CM301
	MOVE P1,B		;SAVE ADDRESS OF BLOCK
	SKIPE A			;NAME IS NOT IN BLOCK FOR "PRINT".
	ETYPE < Name %1R%%_>
	TLNE Z,F4		;PRINT NAME ONLY?
	RET			;YES, EXIT
;CM16 *** 10 lines deleted ***
	SETZB A,C		;GET DEFAULT INFO
	MOVEI B,GTDLN		;SET UP LENGTH OF BUFFER
	MOVEM B,.CDLEN+DFBUF	;IN FIRST WORD OF BUFFER
	MOVEI B,DFBUF
	GTDIR
	 ERCAL JERRE
	MOVSI B,(<7B2>)		;CLEAR EXTRA BITS
	ANDCAM B,.CDFPT+DFBUF
	ANDCAM B,.CDDPT+DFBUF
	MOVE B,.CDLIQ(P1)	;LOGGED IN QUOTA
CS,<	CAME B,[377777,,0] >	;CM290 +INF not worth talking about
	ETYPE < Working disk storage page limit %2Q%%_>
	MOVE B,.CDLOQ(P1)	;LOGGED OUT QUOTA
CS,<	SKIPE B >		;CM290 Zero means doesn't have
	ETYPE < Permanent disk storage page limit %2Q%%_>

;PRIVILEGES

	MOVE B,.CDPRV(P1)
	TXNN B,SC%WHL
	CALL F3NOT
	TXZE B,SC%WHL
	ETYPE < Wheel%_>
	TXNN B,SC%OPR
	CALL F3NOT
	TXZE B,SC%OPR
	ETYPE < Operator%_>
	TXNN B,SC%ADM		;CM17
	CALL F3NOT		;CM17
	TXZE B,SC%ADM		;CM17
	ETYPE < Administrator%_> ;CM17
	TXNN B,SC%GOP		;CM229
	CALL F3NOT		;CM229
	TXZE B,SC%GOP		;CM229
	ETYPE < Galaxy-operator%_> ;CM229
	TXNN B,SC%CNF
	CALL F3NOT
	TXZE B,SC%CNF
	ETYPE < Confidential information access%_>
	TXNN B,SC%MNT
	CALL F3NOT
	TXZE B,SC%MNT
	ETYPE < Maintenance%_>
CC,<	TXNN B,SC%TTY		;{C369}
	CALL F3NOT		;{C369}
	TXZE B,SC%TTY		;{C369}
	ETYPE < Terminal-maintenance%_>	;{C369}
>
	TXNN B,SC%IPC
	CALL F3NOT
	TXZE B,SC%IPC
	ETYPE < IPCF%_>
	TXNN B,SC%ENQ
	CALL F3NOT
	TXZE B,SC%ENQ
	ETYPE < ENQ-DEQ%_>
	TXZE B,SC%NWZ		;ARPANET WIZARD?
	ETYPE < Arpanet-wizard%_>
	TXZE B,SC%NAS		;ABSOLUTE ARPANET SOCKETS?
	ETYPE < Absolute-arpanet-sockets%_>
	TXZE B,SC%DNA
	ETYPE < Decnet-access%_>
	TXZE B,SC%ANA
	ETYPE < Arpanet-access%_>
	JUMPE B,.+2		;NO MORE PRIVILEGES
	ETYPE < Other capabilities %2O%%_>

;DIRPNT
;MODE

	MOVE B,.CDMOD(P1)
	TXNN B,CD%DIR
	CALL F3NOT
	TXZE B,CD%DIR
	ETYPE < Files-only%_>
	TXZ B,CD%ANA		;IGNORE ALPHA NUMERIC BIT
	TXZE B,CD%RLM
CC,<	ETYPE < Repeat LOGIN messages%_>> ;CM290
CS,<	ETYPE < Mail-only%_>>	;CM290
XARC <
	TXZE B,CD%DAR		; Default archive online-expired?
	ETYPE < Archive online expired files%_>
   >
	JUMPE B,.+2		;TEST FOR ADDITIONAL MODE BITS
	ETYPE < Other mode bits %2O%%_>

	SKIPN B,.CDNUM(P1)
	JRST [	TLNE Z,F3
		ETYPE < No directory number%_>
				;0: NOT ASSIGNED YET ("CREATE" CASE)
		JRST .+2]
	ETYPE < Number of directory %2O%%_>
	MOVE B,.CDFPT(P1)
	TLZ B,(<7B2>)
	TLNN Z,F3
	CAME B,.CDFPT+DFBUF	;DON'T PRINT IF STANDARD
	ETYPE < Default file protection %2O%%_>
	MOVE B,DACTPR		;GET POINTER TO ACCOUNT STRING
	ILDB B,B		;GET FIRST CHARACTER
	SKIPN B			;IS THERE AN ACCOUNT DEFAULT?
	SKIPA B,[-1,,[ASCIZ /- none set/]]
	MOVE B,DACTPR		;YES, GET POINTER TO ACCOUNT STRING
	ETYPE < Account default for LOGIN %2m%%_>
	MOVE B,.CDDPT(P1)
	TLZ B,(<7B2>)
	TLNN Z,F3
	CAME B,.CDDPT+DFBUF
	ETYPE < Protection of directory %2O%%_>

;DIRPNT

	MOVE B,.CDRET(P1)		;DEFAULT # VERSIONS TO KEEP
	MOVE A,.CDRET+DFBUF		;DEFAULT VALUE
	TLNN Z,F3
	CAME B,A
	ETYPE < Generations to keep %2Q%%_>
	MOVE B,.CDSDQ(P1)		;NUMBER OF SUBDIRECTORIES
	MOVE A,.CDSDQ+DFBUF		;DEFAULT VALUE
	TLNN Z,F3
	CAME B,A
	ETYPE < Maximum subdirectories allowed %2Q%%_>
	SKIPN A,.CDLLD(P1)
	JRST [	TLNE Z,F3
		ETYPE < Never logged in%_>
				;CAN'T USE REG CASE CAUSE %D TYPES CURRENT
				;DATE FOR 0
		JRST .+2]
	ETYPE < Last LOGIN %1D %1E%%_>
	MOVE A,.CDUGP(P1)
	MOVEI B,[ASCIZ /User groups/]
CS,<	MOVX C,<SKIPA>>		;CM290 Skip to print an entry
	CALL GRPPNT
CS,<				;CM290 Owner groups
	MOVE A,.CDDGP(P1)	;CM290
	MOVEI B,[ASCIZ/Owners/] ;CM290
	MOVX C,<TRZN B,400000>	;CM290 Skip to print
	CALL GRPPNT		;CM290
       >			;CM290
	MOVE A,.CDDGP(P1)
	MOVEI B,[ASCIZ /Directory groups/]
CS,<	MOVX C,<TRZE B,400000>>	;CM290
	CALL GRPPNT
	MOVE A,.CDCUG(P1)	;POINTER TO ALLOWABLE SUBDIRECTORY USER GROUPS
	MOVEI B,[ASCIZ /Subdirectory user groups allowed/]
CS,<	MOVX C,<SKIPA>>		;CM290 Skip to print an entry
	CALL GRPPNT
	MOVE A,.CDDNE+DFBUF
	MOVE B,.CDDNE(P1)
	MOVEI C,[ASCIZ / Online expiration default /]
XARC <
	CALL EXPPNT
   >
	MOVE A,.CDDFE+DFBUF
	MOVE B,.CDDFE(P1)
	MOVEI C,[ASCIZ / Offline expiration default /]
XARC <
	CALL EXPPNT
   >
	MOVE B,DMRAPR		;CM301 Get pointer to mail routing address
	MOVE A,B		;CM301
	ILDB A,A		;CM301 Get first character
	CALL PIOFF		;EM139 !^%^&@% hack
	PUSH P,CASFLG		;EM139 Save case flag
	SETOM CASFLG		;EM139 Suppress case-folding
	SKIPE A			;CM301 Is there one?
	ETYPE < Mail routing address %2M%%_> ;CM301;EM139
	POP P,CASFLG		;EM139 Restore case-folding state
	CALL PION		;EM139
	ETYPE<%_>
	RET

;CS115 Make a routine out of this hack

GRPPNM:	
CS,<	CALL [	SAVEAC <A,B,C,D> ;CM290 Print it as a user name
		STKVAR <<DBUF,8>> ;EM20 Space for directory name
;EM20		MOVE A,COJFN	;CM290 Print it onto output JFN
		HRROI A,DBUF	;EM20 Point at buffer
		HRLI B,500000	;CM290 User number left half
		DIRST%		;CM290 print it
		 RET		;CM290 Oh well, use the number then
		HRROI A,DBUF	;EM20 Point at buffer
		ETYPE <%1M>	;EM20 Print as user
		RETSKP]		;CM290 Success, no nasty octal numbers!
	 ETYPE <%2O>		;CM9 Print group number in octal
   >;CS
CC,<				;CM46 *** Start ***
	CAILE B,550		;System group?
	IFSKP.			;Yup - no man-number for it, then
	  ETYPE <%2O>		;Print it as octal number
	ELSE.			;Print as man-number
	  IDIVI B,^D36		;Break the number into letters
	  CAIL C,12
	  ADDI C,7
	  PUSH P,C
	  IDIVI B,^D10
	  PUSH P,C
	  IDIVI B,^D27
	  PRINT 101(B)		;Print man number
	  PRINT 100(C)
	  POP P,B
	  PRINT 60(B)
	  POP P,B
	  PRINT 60(B)
	ENDIF.
   >;CC				;*** CM46 ***
	RET			;CS115

GRPPNT:	PUSH P,B
	JUMPE A,GRPPN0
	MOVN B,(A)		;GET COUNT
	AOJGE B,GRPPN0		;COUNT = 1 IS NO GROUPS
	HRL A,B
	SETZ D,			;CM290 No groups printed yet
	AOS A			;CM290 NOW WE HAVE AN AOBJN POINTER
GRPPN1:	MOVE B,(A)		;CM290
CS,<	XCT C 			;CM290
	 JRST GRPPN2 >		;CM290
	SKIPN D			;CM290 About to print first?
	 JRST [ PRINT " "	;CM290 Yes
		POP P,D		;CM290 Print name of the list
		UTYPE (D)	;CM290
		PRINT " "	;CM290
		JRST .+2]	;CM290
	TYPE <, >
	SETO D,			;CM290 We are printing one item now
	CALL GRPPNM		;CS115 Go print group name
GRPPN2:	AOBJN A,GRPPN1		;CM290
	JUMPE D,GRPPN0		;CM290 Jump none set
	ETYPE<%_>
	RET

GRPPN0:	POP P,B
	TLNN Z,F3
	RET
	PRINT " "
	UTYPE (B)
	TYPE < - none set
>
	RET

;ROUTINE TO CHECK FOR LOST INFO DUE TO RESTRICTED SUBBLOCK LENGTHS.  PASS
;THIS ROUTINE ADDRESS OF GTDIR/CRDIR BLOCK IN A.

GRPCHK:	MOVE B,@.CDUGP(A)		;GET NUMBER OF WORDS RETURNED
	CAIN B,UGBUFL			;CHECK FOR *POSSIBLE* OVERFLOW
	TYPE < User group buffer overflow
>
	MOVE B,@.CDDGP(A)		;SAME FOR OTHER GROUP BUFFERS
	CAIN B,DGBUFL
	TYPE < Directory group buffer overflow
>
	MOVE B,@.CDCUG(A)
	CAIN B,SGBUFL
	TYPE < Subdirectory user group buffer overflow
>
	RET

;SUBROUTINE TO TYPE " NOT" AND SKIP IF F3 ON

F3NOT:	TLNN Z,F3
	RET
	TYPE < not>
	RETSKP

EXPPNT:	TLNN Z,F3		;VERBOSE?
	CAME A,B		;SAME AS DEFAULT?
	CAIA			;EITHER VERBOSE OR NOT DEFAULT VALUE
	RET			;YES, DON'T PRINT IT
	UTYPE (C)		;WHAT IT IS
	TLNN B,-1		;INTERVAL OR DATE & TIME?
	JRST EXPPN1
	ETYPE <%2D
>				;PRINT DATE & TIME
	RET

EXPPN1:	CAIN B,1
	ETYPE <%2Q Day
>
	CAIE B,1
	ETYPE <%2Q Days
>
	RET

;"PRINT" SUBCOMMAND TABLE AND ROUTINES

$PRINT:	TABLE
	T FAST,ONEWRD,..FAST
	T NAME-ONLY,ONEWRD,..NAME
	T VERBOSE,ONEWRD,..VERB
	TEND

..FAST:	TLZA Z,F3
..VERB:	TLO Z,F3
	TLZ Z,F4		;GET WHOLE LISTING
	RET

..NAME:	TLO Z,F4		;NAME ONLY
	RET

CMU,<
;CS115 *** Entire page ***
;RMDIR (NAME) <DIRECTORY NAME>
;Delete the specified directory.

.RMDIR::TRVAR <NAMPTR,DIRNUM,DIRFLG,<CPRMPT,40>,<DELNAM,12>>
	NOISE <DIRECTORY NAME>
	TLO Z,F1		;No defaulting allowed
	CALL CURNMS		;Get a directory spec
	 ERROR <Invalid directory name>
	MOVEM A,DIRFLG		;Save flags
	MOVEM B,NAMPTR		;Save pointer away
	MOVEM C,DIRNUM		;Save directory number, too
	CONFIRM			;Confirm it
	DO.
	  HRROI A,DELNAM	;Name of directory to delete
	  MOVE B,DIRNUM
	  DIRST%		;Translate it
	   ERJMP CJERRE
	  MOVE A,B		;Get directory number in right place
	  GTDAL%		;Get its allocation
	  IFN. B		;Anything in it?
	    HRROI A,CPRMPT	;Point at prompt area
	    HRROI B,[ASCIZ/[Directory /]
	    SETZ C,
	    SOUT%
	    HRROI B,DELNAM
	    SOUT%
	    HRROI B,[ASCIZ/ is not empty -- confirm to delete]/]
	    SOUT%
	    UPROMP CPRMPT	;Prompt user
	    CALL FCONFA		;And confirm it
	  ENDIF.
	  MOVE A,DIRNUM		;Get directory number we're about to do...
	  MOVE B,NAMPTR		;Name string
	  MOVE C,DIRFLG		;Get flags
	  TXNE C,RC%WLD		;Wildcards?
	  CALL STPDIR		;Step to next directory number
	  SETZ A,		;No more directories...
	  MOVEM A,DIRNUM	;Save directory number returned
	  HRROI A,DELNAM	;Point at name to delete
	  MOVX B,<CD%DEL>	;We want to delete the directory
	  SETZ C,		;No password should be required...
	  CRDIR%		;Do the jsys...
	   ERJMP CJERRE		;Punt...
	  SKIPE DIRNUM		;Any more directories?
	  LOOP.			;Yes - do next
	ENDDO.
	RET			;Succeded

;MKDIR {directory-name} {switches}
;Create a directory

DEFINE CRDSTG <
	TRVAR <<CRBLK,GTDLN>,MKFLG,CRPASS,<CSTING,FILWDS>,<LIDNAM,10>,KREDIR>
   >

;Special noise macro...

DEFINE CNOISE(ARG) <
	SKIPN MKFLG
	 NOISE <ARG>>

DEFINE CCONFIRM <
	SKIPN MKFLG
	 CONFIRM>

.MKDIR::CRDSTG
	MOVEI A,CRBLK		;Directory block 
	CALL DIRINI		;Initialize directory block
	CALL GTDNNM		;Parse directory name, etc.
	 ERROR <Directory already exists> ;Fail for old directory
	PUSH P,.CDUGP+CRBLK	;Save addresses of group blocks
	PUSH P,.CDDGP+CRBLK
	PUSH P,.CDCUG+CRBLK
	MOVSI A,MKDDFS		;Point at defaults
	HRRI A,CRBLK		;And our block
	MOVE CX,A
	BLT A,GTDLN-1(CX)	;Copy it
	POP P,.CDCUG+CRBLK	;Restore freespace pointers
	POP P,.CDDGP+CRBLK
	POP P,.CDUGP+CRBLK
	MOVSI B,MKDUGP		;Default user groups
	HRR B,.CDUGP+CRBLK
	MOVE CX,B
	BLT B,UGBUFL-1(CX)
	MOVSI B,MKDDGP		;Default directory groups
	HRR B,.CDDGP+CRBLK
	MOVE CX,B
	BLT B,DGBUFL-1(CX)
	MOVSI B,MKDCUG		;Default subdirectory groups
	HRR B,.CDUGP+CRBLK
	MOVE CX,B
	BLT B,SGBUFL-1(CX)
	MOVE Q1,MKDDFL		;Get default flags
CS,<	TLNN Z,F5		;Is this an owned subdirectory?
	IFSKP.
	  MOVEI A,CRBLK		;Point at CRDIR block
	  MOVE B,.CDDGP(A)	;Get address of directory groups
 	  MOVE D,(B)		;Get count
	  HRRZ C,CUSRNO		;Get my user number
	  TXO C,400000		;Flag an owner
	  DO.
	    CAMN C,(B)		;Is it this user?
	    EXIT.		;Yes. Don't add again
	    ADDI B,1		;Advance
	    SOJG D,TOP.		;Subtract one from count
	    AOS @.CDDGP(A)	;Increment count of groups
	    MOVEM C,(B)		;And add this to end
	    TXO Q1,CD%DGP	;Flag that we are setting directory groups
	  ENDDO.
	ENDIF.
>;CS
	CALL PRSMKS		;Parse switches
	MOVE A,KREDIR		;Get pointer to name string
	MOVEI B,CRBLK
	HLL B,Q1		;XWD flags, parameter block address
	SETZ C,			;Assume no password required
	CRDIR			;Create directory
	 ERJMP CJERRE		;Failed. Handle as standard error
	RET			;Done

;MKDIR switches parsing

$MKDIR:	TABLE
	T DEFAULT-FILE-PROTECTION:,,..PFIL
	T DIRECTORY-GROUP:,NOTF,..DIRE
	T GENERATIONS:,,..GENR
	T MAXIMUM-SUBDIRECTORIES:,,.MAXIM
	T NOT:,,.MKNOT
	T NUMBER:,,.NUMBE
CS,<	T OWNER-GROUP:,NOTF,..OWNR> ;CM290 Set groups which get owner access
	T PERMANENT:,,..LOQ
	T PRESERVE,,...PRE
	T PROTECTION:,,...PRO
	T SUBDIRECTORY-USER-GROUP:,,.SUSER
	T USER-GROUP:,NOTF,.USER
	T WORKING:,,..LIQ
	TEND

$$MKDI:	TABLE
	T DIRECTORY-GROUP:,NOTF,..DIRE
CS,<	T OWNER-GROUP:,NOTF,..OWNR> ;CM290 Set groups which get owner access
	T PRESERVE,,...PRE
	T SUBDIRECTORY-USER-GROUP:,,.SUSER
	T USER-GROUP:,NOTF,.USER
	TEND

.MKNOT:	MOVEI B,[FLDDB. .CMKEY,,$$MKDI]
	CALL FLDSKP
	 CMERRX
	HRRZ P3,(B)		;Get dispatch
	HRRZ P3,(P3)
	MOVE P4,P3		;Copy it
	TLO Z,F1
	JRST (P3)

;Main routine for parsing MKDIR switches. Called from .MKDIR and from
;SET DEFAULT code

PRSMKS:	SETOM MKFLG		;Say doing MKDIR switch parsing
	DO.
	  TLZ Z,F1		;No /NOT: yet
	  MOVEI B,[FLDDB. .CMSWI,,$MKDIR,,,<[
		   FLDDB. .CMCFM]>]
	  CALL FLDSKP		;Parse it
	   CMERRX
	  LOAD D,CM%FNC,.CMFNP(C) ;Find out what parsed...
	  CAIN D,.CMCFM		;Confirm?
	   EXIT.		;Yes - done
	  HRRZ B,(B)		;Get dispatch
	  CALL @(B)		;And go process it
	  LOOP.			;Loop until confirmed
	ENDDO.
	RET

;SET DEFAULT (FOR) MKDIR

.SDMKD::CRDSTG			;Allocate storage
	MOVSI A,MKDDFS		;Point at default block
	HRRI A,CRBLK		;Our block
	BLT A,GTDLN-1+CRBLK	;Initialize it
	MOVE Q1,MKDDFL		;Get flags
	CALL PRSMKS		;Parse switches
	MOVSI A,CRBLK		;Our block again....
	HRRI A,MKDDFS		;Back to default block
	BLT A,MKDDFS+GTDLN-1	;Update defaults
	MOVEM Q1,MKDDFL		;And flags
	RET			;Done

;SET NO DEFAULT (FOR) MKDIR

.SNMKD::CONFIRM
INIMKD::SETZM MKDDFS		;Clear first word
	MOVE A,[MKDDFS,,MKDDFS+1] ;Setup BLT
	BLT A,GTDLN-1(A)	;Clear out MKDIR block
	MOVEI A,GTDLN		;Length of argblk
	MOVEM A,MKDDFS+.CDLEN	;Set first word
CS,<	MOVX A,<CD%LEN!CD%LIQ!CD%MOD>>	;Flag defaults
CC,<	MOVX A,<CD%LEN!CD%MOD>>
	MOVEM A,MKDDFL		;Save default flags
	MOVX A,<377777,,0>	;+INF (only used in CS case)
	MOVEM A,MKDDFS+.CDLIQ	;.CDLIQ working quota
	MOVX A,CD%DIR		;FILES-ONLY
	MOVEM A,MKDDFS+.CDMOD	;.CDMOD directory mode
	MOVEI B,1		;Need a 1
	MOVEI A,MKDUGP		;Always want UGP pointer
	MOVEM A,MKDDFS+.CDUGP
	MOVEM B,MKDUGP		;Make empty group block
	MOVEI A,MKDDGP		;Directory group ptr
	MOVEM A,MKDDFS+.CDDGP	;...
	MOVEM B,MKDDGP
	MOVEI A,MKDCUG		;Subdirectory group block
	MOVEM A,MKDDFS+.CDCUG
	MOVEM B,MKDCUG
	RET

;INFORMATION DEFAULT MKDIR

DEFINE PSWITCH (TEXT) <
	UETYPE [XCAP < /TEXT>]>

.IDMKD::SETZ D,			;Didn't print message yet
	MOVE Q1,MKDDFL		;Get flags
	MOVE C,MKDDFS+.CDLEN	;Get flags word
	TXNE C,CD%NSQ		;Preserve set?
	JRST IDMKD1		;Yes
	MOVE B,MKDDFS+.CDLIQ	;Get working
	TXNN Q1,CD%RET!CD%SDQ!CD%LOQ!CD%FPT!CD%DPT
	CAME B,[377777,,0]	;Non-infinite working quota?
	TRNA			;Something interesting
	JRST IDMKD2
IDMKD1:	ETYPE < Set Default Mkdir>
	MOVE B,.CDLEN+MKDDFS	;Get length/flags word
	TXNE B,CD%NSQ		;No subtract quota?
	 PSWITCH <Preserve>
	MOVE B,.CDLOQ+MKDDFS	;Get value
	TXNE Q1,CD%LOQ		;Have perm quota?
	 PSWITCH <Permanent:%2Q>
	MOVE B,.CDLIQ+MKDDFS
	TXNE Q1,CD%LIQ		;Want to print it?
	CAMN B,[377777,,0]	;Is it +INF?
	TRNA			;Not interesting, then
	PSWITCH <Working:%2Q>
	HRRZ B,.CDDPT+MKDDFS	;Get protection
	TXNE Q1,CD%DPT
	 PSWITCH <Protection:%2O>
	HRRZ B,.CDFPT+MKDDFS	;Default file protection
	TXNE Q1,CD%FPT
	 PSWITCH <Default-File-Protection:%2O>
	MOVE B,.CDRET+MKDDFS
	TXNE Q1,CD%RET
	 PSWITCH <Generations:%2Q>
	MOVE B,.CDSDQ+MKDDFS
	TXNE Q1,CD%SDQ
	 PSWITCH <Maximum-subdirectories:%2Q>
	ETYPE <%_>
IDMKD2:
CS,<	MOVEI A,MKDDGP
	HRROI B,[ASCIZ/Owner-group/]
	MOVX C,<TRZN B,400000>	;Skip print if set
	CALL IDMKGP		;Print list
   >;CS
	MOVEI A,MKDDGP
	HRROI B,[ASCIZ/Directory-group/]
	MOVX C,<TRZE B,400000>
	CALL IDMKGP
	MOVEI A,MKDUGP
	HRROI B,[ASCIZ/User-group/]
	MOVX C,<SKIPA>		;Always print
	CALL IDMKGP
	MOVEI A,MKDCUG
	HRROI B,[ASCIZ/Subdirectory-user-group/]
	MOVX C,<SKIPA>
	CALL IDMKGP
	RET

IDMKGP:	PUSH P,B		;Save string to print
	SETZ D,			;No groups printed yet
	JUMPE A,IDMKG0		;Nothing setup...
	MOVN B,(A)		;Get count
	AOJGE B,IDMKG0		;Count = 1 means no groups
	HRL A,B			;Copy count
	ADDI A,1		;Make AOBJN ptr
	DO.
	  MOVE B,(A)		;Get this group entry
CS,<	  XCT C			;Make sure we want to print it
	   JRST IDMKG2>		;Nope
	  SKIPN D		;About to print first?
	   ETYPE < Set Default Mkdir> ;Start it off
	  MOVE D,(P)		;Get switch name
	  PSWITCH <%4M:>	;Print switch name
	  SETO D,		;Make sure set
	  CALL GRPPNM		;Print group name/number
IDMKG2:	  AOBJN A,TOP.		;Loop for all entries
	ENDDO.
IDMKG0:	POP P,B			;Restore string ptr
	SKIPE D			;Printed any?
	 ETYPE <%_>		;Print CRLF
	RET
>;CMU

;Routine to parse directory name for BUILD/MKDIR and setup all TRVARs
;Returns +1: Old directory
;	 +2: New directory

GTDNNM:	CALL DIRNEW		;Get directory name
	 ERROR <Invalid directory name>
	TLZ Z,F2!F5!F6		;Assume old name, clear subdir, owner flags
	IFXE. A,RC%NOM!RC%AMB!RC%NMD ;Is this an existant directory?
	  MOVE B,C		;Copy directory number to right place
	  RET			;And done
	ENDIF.
	MOVEM B,KREDIR		;Save pointer to directory name string
	TLO Z,F2		;Indicate new directory
	MOVEI A,LIDNAM		;Place to put name
	HRLI A,(POINT 7,)	;Make a pointer
	MOVEI B,74		;Open bracket
	IDPB B,A		;Start the string
	MOVE B,CUSRNO		;Get logged-in directory number
	DIRST%			;We will need this later...
	 TRN
	MOVEI B,"."		;Want a dot...
	IDPB B,A		;Look like subdirectory
	SETZ B,			;A null
	IDPB B,A		;To terminate the string
	HRROI A,LIDNAM		;Point at "test string"
	MOVE B,KREDIR		;Get pointer to new name
	HRLI B,(POINT 7,)	;Make BP
	DO.
	  ILDB C,B		;Get char
	  CAIN C,":"		;Hit structure delim yet?
	  EXIT.			;Yes
	  JUMPN C,TOP.		;At end of name?
	  MOVE B,KREDIR		;Yes - no structure name
	ENDDO.
	STCMP%			;Compare with name of "new" directory
	IFXN. A,SC%SUB		;Home directory a subset of this directory?
	  TLO Z,F5!F6		;Indicate this is a owned subdirectory
	ELSE.			;See if this is a subdirectoy at all...
	  MOVE A,KREDIR		;Get back pointer
	  DO.
	    ILDB B,A		;Get a char
	    JUMPE B,ENDLP.	;Exit, if null
	    CAIE B,"."		;Hit a dot?
	     LOOP.		;Nope. Keep going
	    TLO Z,F6		;Indicate that this is a new subdirectory
	  ENDDO.
	ENDIF.
	DEXTX <>		;Clear GTJFN block
	HRROI A,[ASCIZ /FOO/]	;Name is arbitrary
	MOVEM A,CJFNBK+.GJNAM	;store name to use
	MOVE A,[.NULIO,,.NULIO]	;don't let GTJFN read any more input
	MOVEM A,CJFNBK+.GJSRC	;store non-jfn'S
	MOVX A,GJ%OFG		;we want parse only
	MOVEM A,CJFNBK+.GJGEN	;store flags
	MOVEI A,CJFNBK		;point gtjfn at arg block
	MOVE B,KREDIR		;get pointer to structure and directory
	CALL GTJFS		;get device name
	 CALL JERR		;shouldn't ever fail
	MOVE B,A		;put in B for getting device name
	HRROI A,CSTING		;area into which to write device name
	MOVX C,FLD(.JSAOF,JS%DEV) ;we only want device field
	JFNS			;get device name
	HRROI A,CSTING		;Note that we couldn't just do STDEV
				;because in common case, user will
				;type "^ECREATE [FOO]", and hence device
				;name will be null.  Unfortunately,
				;STDEV doesn't have a special error code
				;saying "device name was not specified",
				;nor does it return updated string pointer
				;in AC1.  Otherwise the GTJFN,JFNS would
				;have been unnecessary.  Note that leaving
				;out all this code is bad too, because
				;user might say "^ECREATE ABC:[FOO]"
				;where ABC: is not mounted, and exec would
				;just wait for all the subcommands, and
				;then bomb out, a very frustrating
				;situation.
	MOVE C,A		;leave pointer in 3 for error message
	STDEV 			;make sure structure is mounted
	 ERCAL [ERROR <Structure %3m: not mounted>]
	RETSKP			;Return +2, new directory

;^E CREATE (NAME) <DIRECTORY NAME> (PASSWORD) --
;EITHER FIELD CAN BE TERMINATED WITH COMMA TO INITIATE SUBCOMMANDS.
;CAN CREATE NEW DIRECTORIES OR MODIFY INFO ASSOCIATED WITH OLD ONES.
;Q1 HOLDS FLAGS AND BLOCK POINTER WHICH WILL BE IN B FOR CRDIR.
;FLAGS IN LH Q1 ARE SET ONLY FOR FIELDS EXPLICITLY INPUT BY USER,
;  BUT ALL INFO IS IN BLOCK FOR "LIST" SUBCOMMAND.

.CREAT::NOISE <DIRECTORY NAME>
	CRDSTG			;CS115 Allocate storage
	SETZM CRPASS		;NO PASSWORD YET
	SETZM MKFLG		;CS115 Not doing MKDIR
	MOVX Q1,CD%LEN		;ALWAYS ENABLE .CDLEN ENTRY
	MOVEI A,CRBLK		;ADDRESS OF BLOCK TO INITIALIZE
	CALL DIRINI		;INIT BUFFER FOR GTDIR

;CREATE
;INPUT NAME AND TYPE [OLD/NEW] AND GET CURRENT INFO FOR OLD.

;CS115 Mucho code moved into GTDNNM, reorganized
	CALL GTDNNM		;CS115 Parse directory name, etc.
	 JRST CRET1		;CS115 Existant directory
	SETZB A,C		;USE DIRECTORY 0
	MOVEI B,GTDLN		;SET UP LENGTH OF BUFFER
	MOVEM B,.CDLEN+CRBLK	;IN FIRST WORD OF BUFFER
	MOVEI B,CRBLK		;POINT TO BUFFER
	GTDIR			;GET DEFAULTS
	MOVEI A,CRBLK		;GET ADRESS OF ENTIRE CRDIR BLOCK
	MOVEI B,1		;MAKE EMPTY GROUP BUFFERS
	MOVEM B,@.CDUGP(A)
	MOVEM B,@.CDCUG(A)	;CS115 *** Begin ***
CC,<	MOVEM B,@.CDDGP(A)>
CS,<	TLNN Z,F5		;Is this an owned subdirectory?
	IFSKP.
	  MOVEI B,2		;Force one group
	  HRRZ C,CUSRNO		;Get my user number
	  TXO C,400000		;Flag an owner
	  DMOVEM B,@.CDDGP(A)	;Set it
	  TXO Q1,CD%DGP		;Flag that we are setting directory groups
	ELSE.			;Not an owned subdirectory
	  MOVEM B,@.CDDGP(A)	;So, use normal case
	ENDIF.
	MOVX B,<377777,,0>	;Also, setup +INF
	MOVEM B,.CDLIQ(A)	;For working quota, always
>;CS				;CS115 *** End ***
CC,<	TXO Q1,CD%LIQ!CD%LOQ!CD%FPT!CD%DPT!CD%RET > ;CM290
CS,<				;CM290 *** Start ***
	TXO Q1,CD%LIQ!CD%FPT!CD%DPT!CD%RET ;CM290
	MOVE A,EXECAP+1		;Get capabilities
	TXNE A,SC%ADM		;Enabled administrator?
	JRST CRET1A		;Yes, leave original defaults
	TXO Q1,CD%MOD		;Changing mode
	MOVX A,CD%DIR		;Files-only directory
	IORM A,.CDMOD+CRBLK	;By default
>;CS				;CM290 *** End ***
	JRST CRET1A

CRET1:	MOVEM B,KREDIR		;REMEMBER DIRECTORY NUMBER
	HRROI A,CSTING		;GET STRING STORAGE POINTER
	DIRST
	 ERCAL CJERRE
	HRROI A,CSTING		;GET TO BEGINNING OF STRING AGAIN
	CALL BUFFS		;SAVE STRING
	EXCH A,KREDIR		;RESTORE DIR # AND SAVE STR
				;GET CURRENT INFORMATION FOR OLD DIRECTORY
	MOVEI B,GTDLN		;SET UP LENGTH OF BUFFER
	MOVEM B,.CDLEN+CRBLK	;IN FIRST WORD OF BUFFER
	MOVEI B,CRBLK
	HRROI C,CSTING		;PASSWORD GOES HERE (POINTER STORED IN BUFFER BY GTDIR)
	PUSH P,.CDMRA(B)	;CM301 Save mail routing address
	MOVE D,.CDDAC(B)	;GET POINTER TO WHERE ACCOUNT WILL GO
	GTDIR
	  ERCAL CJERRE
	MOVEM D,.CDDAC(B)	;RESTORE ACCOUNT POINTER TO POINT AT BEGINNING
	POP P,.CDMRA(B)		;CM301 Restore mail routing address
	HRROI A,CSTING		;POINT TO PASSWORD
	CALL BUFFS		;ISOLATE IT
	SKIPE .CDPSW+CRBLK	;NO POINTER STORED MEANS PASSWORD NOT AVAILABLE
	MOVEM A,.CDPSW+CRBLK	;STORE POINTER TO ISOLATED PASSWORD
	MOVEI A,CRBLK		;GET ADDRESS OF BLOCK
	CALL GRPCHK		;CHECK FOR GROUP OVERFLOW
CRET1A:

;CREATE
;INPUT PASSWORD.
;FOR OLD DIRECTORY, THIS PASSWORD REPLACES OLD ONE - IS THAT GOOD?

NOCMU,<				;CS115 This is bogus
	NOISE <PASSWORD>
	WORDX <Password>
	 CMERRX
	CALL BUFFF
	LDB B,[350700,,ATMBUF]	;SEE IF ANY PASSWORD TYPED
	JUMPE B,CREAT3		;JUMP IF NONE
	MOVEM A,.CDPSW+CRBLK	;PASSWD STRING PTR TO PARAMETER BLOCK
	TXO Q1,CD%PSW		;TELL CRDIR TO SET PASSWORD
>;NOCMU				;CS115
CREAT3:	COMMAX <Optional comma, then carriage return to go into subcommand mode>
	 JFCL			;NO COMMA REQUIRED
	CONFIRM			;GET LINE CONFIRMATION
	CALL NORO		;TYPE NEW OR OLD

;CHECK, CONFIRM, EXECUTE

	SETZM .CDLEN+CRBLK	;CLEAR CRDIR BITS
CRSUB:	SUBCOM $CREAT,[TLZ Z,F1
		       RET]	;GET SUBCOMMANDS, CLEAR "NOT" BEFORE EACH ONE
CRSUB1:	MOVE A,KREDIR		;GET POINTER TO NAME STRING
	MOVEI B,CRBLK
	HLL B,Q1		;XWD FLAGS, PARAMETER BLOCK ADDRESS
	MOVE C,CRPASS		;GET 0 OR POINTER TO PASSWORD
	CRDIR			;CREATE DIRECTORY !
	 ERJMP NODIR		;FAILED, LET USER FIX SUBCOMMANDS AND TRY AGAIN
	CALLRET UNMDIR

;GET TO HERE IF CRDIR FAILED.  TELL USER, LET HIM FIX SUBCOMMANDS AND
;TRY AGAIN.

NODIR:	CALL DGETER		;SEE WHY IT FAILED
	CAIN A,ACESX3		;PASSWORD REQUIRED?
	JRST CRSUB2		;GET PASSWORD AND TRY AGAIN
	CAIN A,CNDIX1		;WRONG PASSWORD?
	JRST [	LERROR <%?%%_>	;YES, TELL HIM
		JRST CRSUB2]	;GET  ANOTHER PASSWORD AND TRY AGAIN
	LERROR <%?.%_Please fix incorrect subcommands.%_>
	JRST CRSUB		;GO BACK INTO SUBCOMMAND MODE

;GET TO HERE IF CRDIR FAILS DUE TO PASSWORD MISSING OR WRONG.  INPUT THE
;PASSWORD AND TRY CRDIR AGAIN.  THIS IS DONE RATHER THAN BOMBING OUT, TO TRY
;TO SAVE THE USER FROM HAVING TO DO ANOTHER BUILD WITH ALL THE PARAMETERS.

CRSUB2:	CALL PASLIN		;YES, GET ONE
	MOVEM A,CRPASS		;REMEMBER IT
	JRST CRSUB1		;GO TRY AGAIN

;TYPE "[NEW]" OR "[OLD]" DEPENDING ON WHETHER DIRECTORY IS NEW OR OLD

NORO:	TLNE Z,F2
	TYPE <[New]
>
	TLNN Z,F2
	TYPE <[Old]
>
	RET

;CREATE
;SUBCOMMAND DISPATCH TABLE
;FLAG B5 INDICATES "NOT" MAY PRECEDE THE SUBCOMMAND.

NOTF==1B5

$CREAT:	TABLE
	T ABORT,ONEWRD
	T ABSOLUTE-ARPANET-SOCKETS,NOTF,..AAS
	T ACCOUNT-DEFAULT,,.AD
	T ADMINISTRATOR,NOTF		;CM17
   XARC <
	T ARCHIVE-ONLINE-EXPIRED-FILES,NOTF,..ARCH
   >
	T ARPANET-ACCESS,NOTF,..ANA
	T ARPANET-WIZARD,NOTF,..ANW
	T CONFIDENTIAL,NOTF
	T DECNET-ACCESS,NOTF,..DNA
	T DEFAULT-FILE-PROTECTION,,..PFIL
	T DIRECTORY-GROUP,NOTF,..DIRE
	T DISABLE
	T ENABLE
	T ENQ-DEQ,NOTF,..ENQ
	T FILES-ONLY,NOTF,.FILES
	T GALAXY-OPERATOR,NOTF,..GOPR ;CM229
	T GENERATIONS,,..GENR
	T IPCF,NOTF
	T KILL,NOTF
	T LIST,,..LIST
	T MAIL-ONLY,NOTF,..RLM	;CM290
	T MAINTENANCE,NOTF
	T MAXIMUM-SUBDIRECTORIES,,.MAXIM
	T NOT
	T NUMBER
   XARC <
	T OFFLINE-EXPIRATION-DEFAULT,,.OFFLI
	T ONLINE-EXPIRATION-DEFAULT,,.ONLIN
   >
	T OPERATOR,NOTF
CS,<	T OWNER-GROUP,NOTF,..OWNR > ;CM290 Set groups which get owner access
	T PASSWORD
	T PERMANENT,,..LOQ
	T PRESERVE,,...PRE
	T PROTECTION,,...PRO
	T PUSH,,...PUS
CC,<	IT REPEAT-LOGIN-MESSAGES,NOTF,..RLM > ;CM290
	T SUBDIRECTORY-USER-GROUP,,.SUSER
CC,<	T TERMINAL-MAINTENANCE,NOTF,..TTYM> ;{C369}
	T USER-GROUP,NOTF,.USER
	T WHEEL,NOTF
	T WORKING,,..LIQ
	TEND

;CREATE
;"NOT" CAN PRECEDE THOSE SUBCOMMANDS WHICH HAVE B5 SET IN TABLE.
;DISPATCH IS TO SAME ROUTINE BUT WITH "F1" SET TO REVERSE EFFECT.

.NOT:	KEYWD $$CREA
	 0
	 JRST CERR
	MOVE P4,P3
	TLO Z,F1
	JRST (P3)

$$CREA:	TABLE
	T ABSOLUTE-ARPANET-SOCKETS,NOTF,..AAS
	T ADMINISTRATOR,NOTF		;CM17
   XARC <
	T ARCHIVE-ONLINE-EXPIRED-FILES,NOTF,..ARCH
   >
	T ARPANET-ACCESS,NOTF,..ANA
	T ARPANET-WIZARD,NOTF,..ANW
	T CONFIDENTIAL,NOTF
	T DECNET-ACCESS,NOTF,..DNA
	T DIRECTORY-GROUP,NOTF,..DIRE
	T ENQ-DEQ,NOTF,..ENQ
	T FILES-ONLY,NOTF,.FILES
	T GALAXY-OPERATOR,NOTF,..GOPR ;CM229
	T IPCF,NOTF
	T KILL,NOTF
	T MAIL-ONLY,NOTF,..RLM	;CM290
	T MAINTENANCE,NOTF
	T OPERATOR,NOTF
CS,<	T OWNER-GROUP,NOTF,..OWNR > ;CM290 Set groups which get owner access
CC,<	IT REPEAT-LOGIN-MESSAGES,NOTF,..RLM >
	T SUBDIRECTORY-USER-GROUP,,.SUSER
CC,<	T TERMINAL-MAINTENANCE,NOTF,..TTYM> ;{C369}
	T USER-GROUP,NOTF,.USER
	T WHEEL,NOTF
	TEND

;ROUTINES FOR THE INDIVIDUAL SUBCOMMANDS

;PASSWORD
;CURRENTLY REDUNDANT EXCEPT THAT IT ALLOWS TYPIN IN A FORMAT MORE LIKE
; WHAT "PRINT" PUTS OUT AND ALLOWS GIVING A NULL STRING (USEFUL?).

.PASSW:	WORDX <1 to 39 alphanumeric characters or hyphens>
	 CMERRX
	CONFIRM
CS,<				;CS146
	MOVE A,[POINT 7,ATMBUF]	;CS146 Point at word just parsed
	CALL CHKPSW		;CS146 See if a valid password
	 ERROR <Password is insecure - %1M> ;CS146
   >;CS				;CS146
	CALL BUFFF
	MOVEM A,.CDPSW+CRBLK
	TXO Q1,CD%PSW
	RET

;"CREATE" SUBCOMMANDS

;LOGGED-IN (STORAGE LIMIT) <DECIMAL>

..LIQ:	CALL ..DISK
	MOVEM B,.CDLIQ+CRBLK
	TXO Q1,CD%LIQ
	RET

;LOGGED-OUT (STORAGE LIMIT) <DECIMAL>

..LOQ:	CALL ..DISK
	MOVEM B,.CDLOQ+CRBLK
	TXO Q1,CD%LOQ
	RET

..DISK:	CNOISE <DISK STORAGE PAGE LIMIT> ;CS115
	DECX <Decimal number of pages>
	 CMERRX
	CCONFIRM		;CS115
	CAML B,[^D1000000]	;LESS THAN A MILLION?
	HRLZI B,377777		;NO - GIVE INFINITE QUOTA
	RET

;SUBCOMMANDS FOR SPECIFIC PRIVILEGES AND MODES.
;F1 ON AT ENTRY IF PRECEDED BY "NOT".

;AC USE: A: MASK INDICATING BITS TO SET (F1 OFF), OR CLEAR (F1 ON).

..AAS:	SKIPA A,[SC%NAS]	;ABSOLUTE ARPANET SOCKETS
..ANW:	MOVEI A,SC%NWZ		;ARPANET WIZARD
	JRST CPRIV

..GOPR:	SKIPA A,[SC%GOP]	;CM229
.ADMIN:	MOVEI A,SC%ADM		;CM17
	JRST CPRIV		;CM17

..ANA:	SKIPA A,[SC%ANA]
..DNA:	MOVEI A,SC%DNA
	JRST CPRIV

CC,<
..TTYM:	SKIPA A,[SC%TTY]	;{C369}
>
..ENQ:	MOVEI A,SC%ENQ
	JRST CPRIV

.IPCF:	SKIPA A,[SC%IPC]
.MAINT:	MOVEI A,SC%MNT
	JRST CPRIV

.WHEEL:	SKIPA A,[SC%WHL]
.OPERA:	MOVEI A,SC%OPR
	JRST CPRIV

.CONFI:	NOISE <INFORMATION ACCESS CAPABILITY>
	MOVEI A,1B20
	JRST CPRIV1
CPRIV:	NOISE <CAPABILITY>
CPRIV1:	CONFIRM
	IORM A,.CDPRV+CRBLK	;SET BITS IN QUESTION
	TLNE Z,F1		;BUT IF SUBCOMMAND PRECEDED BY "NOT",
	ANDCAM A,.CDPRV+CRBLK	;CLEAR THE BITS.
	TXO Q1,CD%PRV
	RET

..RLM:	MOVX A,CD%RLM		;CHANGE REPEAT LOGIN MESSAGE BIT
	JRST CCMODE

..ARCH:	SKIPA A,[CD%DAR]
.FILES:	MOVX A,CD%DIR
;	JRST CCMODE		;(FALL INTO CCMODE)

CCMODE:	CONFIRM
	IORM A,.CDMOD+CRBLK	;SET BIT
	TLNE Z,F1		;PRECEDED BY "NOT"?
	ANDCAM A,.CDMOD+CRBLK	;YES, CLEAR BIT.
	TXO Q1,CD%MOD
	RET

;"CREATE" SUBCOMMANDS

;NUMBER <OCTAL>. SPECIFIES DIRECTORY NUMBER

.NUMBE:	CNOISE <OF DIRECTORY>	;CS115
	OCTX <Octal directory number>
	 CMERRX
	TLNN Z,F2
	JRST [	CAME B,.CDNUM+CRBLK
		ERROR <You can't change the number of an old directory>
		JRST NUMBE1]

;CHECK THAT THE NUMBER ISN'T IN USE BY TRYING TO CONVERT IT TO STRING.

	HRROI A,CSTING
	DIRST
	 CAIA			;NOT IN USE
	ERROR <Number already in use>
NUMBE1:	CCONFIRM		;CS115
	MOVEM B,.CDNUM+CRBLK
	SKIPE B
	TXO Q1,CD%NUM
	RET

.OFFLI:	NOISE <IS>
	DTIVX <Expiration date>
	 CMERRX
	CONFIRM
	MOVEM B,.CDDFE+CRBLK	;SAVE OFFLINE FLAG
	MOVX B,CD%FED		;CHANGE OFFLINE FLAG
	IORM B,.CDLEN+CRBLK
	TXO Q1,CD%LEN		;INDICATE LENGTH & OFF/ON EXP TO BE CONSIDERED
	RET

.ONLIN:	NOISE <IS>
	DTIVX <Expiration date>
	 CMERRX
	CONFIRM
	MOVEM B,.CDDNE+CRBLK	;SAVE ONLINE FLAG
	MOVX B,CD%NED		;CHANGE ONLINE FLAG
	IORM B,.CDLEN+CRBLK
	TXO Q1,CD%LEN		;INDICATE LENGTH & OFF/ON EXP TO BE CONSIDERED
	RET

;"CREATE" SUBCOMMANDS

;PROTECTION (OF DIRECTORY) <OCTAL>. LATER ALSO ALLOW NAMED PROT?

...PRO:	CNOISE <OF DIRECTORY>	;CS115
	OCTX <6-digit octal number>
	 CMERRX
	CCONFIRM		;CS115
	TLNE B,777777		;ALLOW TALT+TSPC+TEOL
	ERROR <6-digit value only>
	TLO B,500000
	MOVEM B,.CDDPT+CRBLK
	TXO Q1,CD%DPT
	RET

;PRESERVE (SUPERIOR QUOTAS)

...PRE:	CNOISE <SUPERIOR QUOTAS> ;CS115
	MOVX B,WHLU+OPRU
	CALL PRVCK		;MUST HAVE PRIVS FOR THIS FCN
	 ERROR <WHEEL or OPERATOR capability required>
	CCONFIRM		;CS115
	MOVX B,CD%NSQ		;NO SUBTRACT QUOTAS BIT
	IORM B,.CDLEN+CRBLK	;ASSUME ON
	TLNE Z,F1		;"NOT" ?
	ANDCAM B,.CDLEN+CRBLK	;YES
	RET

;ACCOUNT-DEFAULT

.AD:	NOISE <FOR LOGIN>
	LINEX <Default account for users logging into this directory>
	 CMERRX
	CONFIRM
	CALL BUFFF
	MOVEM A,.CDDAC+CRBLK	;REMEMBER NEW ACCOUNT
	TXO Q1,CD%DAC		;SAY TO SET STRING
	RET

..PFIL:	CNOISE <NUMBER>		;CS115
	OCTX <6-digit octal number>
	 CMERRX
	CCONFIRM		;CS115
	TLNE B,777777		;ALLOW TALT+TSPC+TEOL
	ERROR <6-digit value only>
	TLO B,500000
	MOVEM B,.CDFPT+CRBLK
	TXO Q1,CD%FPT
	RET

..GENR:	CNOISE <TO KEEP>	;CS115
	DECX <Decimal number of generations to retain per file>
	 CMERRX
	MOVE A,B		;LEAVE NUMBER IN A
	CCONFIRM		;CS115
	DMOVE B,[EXP 0,FB%RET]	;GET MASK FOR RETENTION COUNT FIELD
GENR1:	JUMPE C,GENR2		;IT'S RIGHT-JUSTIFIED WHEN C CONTAINS 0
	LSHC B,1		;DO A SHIFT
	JRST GENR1
GENR2:	JFFO B,.+1		;GET NUMBER OF BITS TO LEFT OF RIGHT-JUSTIFIED FIELD
	CAIL A,0
	CAMLE A,B		;MAKE SURE NUMBER IS IN RANGE
	ERROR <Must be 0-%2Q>
	MOVEM A,.CDRET+CRBLK	;STORE NEW GNERATION RET COUNT DEFAULT
	TXO Q1,CD%RET
	RET

;"CREATE" SUBCOMMANDS

;SUBDIRECTORY

;SUBDIRECTORY MAXIMUM

.MAXIM:	CNOISE <ALLOWED>	;CS115
	DECX <Decimal number of subdirectories allowed under this directory>
	 CMERRX			;INVALID NUMBER OF SUBDIRECTORIES
	CCONFIRM		;CS115
	MOVEM B,.CDSDQ+CRBLK	;REMEMBER NUMBER SPECIFIED
	TXO Q1,CD%SDQ		;REMEMBER TO SET THIS PARAMETER
	RET

;[NOT] SUBDIRECTORY USER

.SUSER:	CNOISE <ALLOWED>	;CS115
	MOVE A,.CDCUG+CRBLK	;ADDRESS OF SUBDIRECTORY USER GROUPS ALLOWED BUFFER
	HRLI A,SGBUFL		;SPECIFY LENGTH
	TXO Q1,CD%CUG
CS,<	SETZ C, >		;CM290 Not owner
	CALLRET .GROUP		;CALL GROUP AND RETURN

;[NOT] USER (GROUP) <DECIMAL GROUP NUMBER 1-2**18>
;F1 ON IF PRECEDED BY "NOT"

.USER:	NOISE <NUMBER>
	MOVE A,.CDUGP+CRBLK	;USER GROUP BUFFER ADDRESS
	HRLI A,UGBUFL		;SPECIFY LENGTH OF BLOCK
	TXO Q1,CD%UGP		;SET USER GROUP FLAG
CS,<	SETZ C, >		;CM290 Not owner
	CALLRET .GROUP		;CALL GROUP AND RETURN

;[NOT] DIRECTORY (GROUP) <DECIMAL GROUP NUMBER 1-2**18>

CS,<..OWNR: TROA C,-1 >		;CM290 Flag we are reading a owner group
..DIRE:				;CM290
CS,<	SETZ C, >		;CM290 Flag we are reading a group number
	CNOISE <NUMBER>		;CS115
	MOVE A,.CDDGP+CRBLK	;GET ADDRESS OF DIRECTORY GROUP BUFFER
	HRLI A,DGBUFL		;SPECIFY LENGTH
	TXO Q1,CD%DGP		;SET DIRECTORY GROUP FLAG; FALL INTO .GROUP
;	CALLRET .GROUP		;(FALL INTO .GROUP)

;SUBROUTINE TO ADD OR DELETE GROUP NUMBER FROM BUFFER IN A

.GROUP:	STKVAR <GRPLST,GRPBFR>	;CS115;CM290 *** Begin ***
	MOVEM C,GRPLST
	MOVEM A,GRPBFR		;Save buffer pointer
CS,<	MOVEI B,[FLDDB. .CMNUM,CM%SDH,5+3,<Special group number>,,[
		 FLDDB. .CMUSR]]> ;Get a number or user
CC,<	MOVEI B,[FLDDB. .CMNUM,CM%SDH,5+3,<Special group number>,,[
		 FLDDB. .CMUSR,CM%PO]]> ;Parse-only at CC...
	CALL FLDSKP		;parse it
	 CMERRX			;nope
	HRRZ B,B		;throw away the left half
CC,<	LOAD C,CM%FNC,.CMFNP(C)	;find out what parsed
	CAIN C,.CMUSR		;userid?
	 CALL BUFFF		;save the name away
   >
	CCONFIRM		;CS115
CC,<	CAIE C,.CMUSR		;was it a userid?
	IFSKP.			;yes
	  CALL HSHUSR		;hash it
	  JRST .GROU1		;And skip move
	ENDIF.
  >				;CS115;CS115 *** End ***
	MOVE A,B
.GROU1:	JUMPLE A,GRPER1		;CS115 OUT OF RANGE
CC,<	CAILE A,777777		;MUST FIT IN HALFWORD
GRPER1:	ERROR <Group numbers must be between 1 and 262143.>
   >
CS,<	CAILE A,377777		;CM290 Group range
GRPER1:	ERROR <Group numbers must be between 1 and 377777.>
	SKIPE GRPLST		;CM290 Owner
	 TRO A,400000 		;CM290
    > ;CS CM290
	MOVE B,GRPBFR		;CM290 GET BUFFER POINTER BACK
	MOVN C,(B)
	AOJGE C,GRPNX1		;JUMP IF EMPTY GROUP
	HRLZ C,C
	HRRI C,1(B)		;MAKE AOBJN PTR
GRPFN1:	CAMN A,(C)
	JRST GRPFN2
	AOBJN C,GRPFN1
GRPNX1:	TLNE Z,F1
	JRST [	ETYPE <%%No group to remove%_>
		RET]
	HLRZ C,B
	CAMG C,(B)		;BUFFER FULL YET?
	ERROR <Can't add new group; buffer full>
	AOS C,(B)		;COUNT ANOTHER ENTRY
	ADDI C,-1(B)		;POINT TO NEW ENTRY
	MOVEM A,(C)
	RET

GRPFN2:	TLNN Z,F1
	JRST [	ETYPE <%%Group already exists%_>
		RET]
	HRRI A,(C)		;DESTINATION
	HRLI A,1(C)		;SOURCE
	SOS C,(B)
	ADDI C,-1(B)		;LAST WORD TO STORE
	BLT A,(C)
	SETZM 1(C)		;CLEAR LAST WORD FOR CLEANLINESS
	RET

;"CREATE" SUBCOMMANDS

;KILL (THIS DIRECTORY)

.KILL:	NOISE <THIS DIRECTORY>
	CONFIRM
	TLNN Z,F1
	CALL FCONF		;FORCED CONFIRMATION IF KILL
	TXO Q1,CD%DEL
	TLNE Z,F1
	TXZ Q1,CD%DEL		;"NOT KILL" REVERSES EFFECT.
	RET

;ABORT: ABORT THIS CREATE. REDUNDANT FOR ^C.

.ABORT:	MOVEI A,RERET
	MOVEM A,CERET
	CALL UNMDIR
	JRST CMDIN4		;GO GET NEXT EXEC COMMAND

;LIST. PRINTS WHAT "PRINT" WILL PRINT IF THIS "CREATE" IS COMPLETED.
;"LIST VERBOSE" PRINTS AS "PRINT" WITH VERBOSE SUBCOMMAND

..LIST:	KEYWD $.LIST
	T FAST,,0		;DEFAULT IS "FAST"
	 JRST CERR
	TLZ Z,F3!F4
	CONFIRM
	TRNE P3,F4
	TLO Z,F4
	TRNE P3,F3
	TLO Z,F3
	MOVE A,KREDIR		;GET POINTER TO STRING FOR DIRPNT
	MOVEI B,CRBLK		;GET BLOCK ADDRESS
	TXNN Q1,CD%DEL
	JRST DIRPNT		;GO ACT LIKE "PRINT" COMMAND
	TYPE < Killed
>
	RET

;PUSH ALLOWS THE BUILDER TO PUSH OUT OF THE BUILD COMMAND, WHICH IS USEFUL
;IF ANOTHER BUILD COMMAND IS REQUIRED SUCCESSFULLY TO COMPLETE THE CURRENT
;ONE, OR IF ANOTHER COMMAND IS NECESSARY.

...PUS:	CALL .PUSH		;DO THE PUSH
	MOVE A,KREDIR		;GET POINTER TO DIRECTORY
	ETYPE <[Continuing BUILD of directory %1R]%_>
	RET

$.LIST:	TABLE
	T FAST,,0
	T NAME-ONLY,,F4
	T VERBOSE,,F3
	TEND

;CS117 *** Entire page ***
;Priviliged commands for structure control

MAXSTS==6			;Max number of units/structure we support
MAXSTB==.MSTUI+<MAXSTS*<.MSTUN+1>> ;Max 3-word structure/unit block
IFG MAXSTB-<.MSRSE+1>,<MSTSIZ=MAXSTB> ;Determine max MSTR% block size
IFLE MAXSTB-<.MSRSE+1>,<MSTSIZ=.MSRSE+1>
STRUSZ==.MSTNO*MAXSTS		;Size of unit info for max sized structure

EDSMNT::TRVAR <<MYNAM,2>,<MSTBLK,MAXSTB>,<USRBLK,10>,<MYID,2>>
	NOISE (STRUCTURE)
	HELPX <Structure name>
	STRX			;Parse it
	 CMERRX			;Failed
	MOVEI A,MYNAM		;Where to copy name
	CALL GETATM		;Copy atom buffer
	CONFIRM			;Confirm command
	MOVEI B,MSTBLK		;Address of MSTR block
	HRROI A,MYNAM		;Point at name again
	MOVEM A,.MSGSN(B)	;Save
	HRROI A,MYID		;Place to put physical ID
	MOVEM A,.MSGSI(B)
	MOVX A,<.MSGLN,,.MSGSS> ;Length, structure status function
	MSTR%			;Read structure status
	 ERJMP CJERRE		;Bogus name
	SKIPE .MSUFL(B)		;Any open files?
	IFSKP.			;No.
	  HRROI A,MYNAM		;Name (alias) of structure
	  MOVEM A,.MSUAL(B)	;Stash it
	  MOVX A,<MS%GTA!MS%GTM!MS%GTC> ;Want accessed,mounted,connected counts
	  MOVEM A,.MSUFL(B)	;Save it
	  MOVX A,<.MSUFL+1,.MSGSU> ;Length,,get users function
	  MSTR%			;Read users of structure
	   ERJMP CJERRE		;Bogus name...
	  HRRZ A,.MSUFL(B)	;Get number of users
	  IFE. A		;No users?
EDSMN1:	    MOVX A,<.MSDNM+1,,.MSDIS> ;Length,dismount function
	    MSTR%		;Do dismount
	     ERJMP CJERRE	;Failed
	    HRROI A,MYNAM
	    HRROI B,MYID
	    ETYPE <Structure %1M, ID %2M dismounted>
	    RET			;Done
	  ENDIF.
	ENDIF.
	PROMPT <[Structure in use, confirm]>
	CALL FCONFA		;Confirm it
	JRST EDSMN1		;And do it
	
$STR:	TABLE			;Table of flags for MSTR
	T EXCLUSIVE,ONEWRD,(MS%XCL)
	T IGNORE-ERR,ONEWRD,(MS%IGN)
	T NO-FIX-BAT,ONEWRD,(MS%NFB)
	T NO-FIX-HOME,ONEWRD,(MS%NFH)
	TEND

EMOUNT::TRVAR <<MSTBLK,MSTSIZ>,<STRUNS,STRUSZ>,<NAMBLK,2>,<MYNAM,2>,<MYAL,2>>
	NOISE (STRUCTURE)
	HELPX <Structure name>
	STRX			;Parse it
	 CMERRX			;Failed
	MOVEI A,MYNAM		;Point at name
	CALL GETATM		;Get atom buffer, case fold
	NOISE (AS)
	HELPX <Alias for structure>
	UDEF MYNAM		;Use this as default
	STRX			;Parse it
	 CMERRX			;Punt
	MOVEI A,MYAL		;Where to put
	CALL GETATM		;Copy from atom buffer
	SETZ Q2,		;Initialize flags
	DO.
	  MOVEI B,[FLDDB. .CMSWI,,$STR,,,<[
		   FLDDB. .CMCFM]>]
	  CALL FLDSKP		;Parse it
	   CMERRX
	  LOAD D,CM%FNC,.CMFNP(C) ;Find out what parsed...
	  CAIN D,.CMCFM		;Confirm?
	   EXIT.		;Yes - done
	  HRRZ B,(B)		;Get flag addr..
	  HRRZ B,(B)		;Get actual flag...
	  TLO Q2,(B)		;Turn on the bit...
	  LOOP.			;And loop until confirmed
	ENDDO.
	SETZ Q1,		;Init count of units
	SETZM .MSRCH+MSTBLK	;Init to channel 0
	SETOM .MSRCT+MSTBLK	;Controller -1
	SETZM .MSRUN+MSTBLK	;Unit 0
	SETZM .MSRSA+MSTBLK	;No alias pointer
	SKIPA A,[.MSRSE+1,,.MSRUS] ;Want unit status
	DO.
	  MOVX A,<.MSRSE+1,,.MSRNU> ;Want next unit status
	  MOVEI B,MSTBLK	;MSTR argument block
	  HRROI C,NAMBLK	;Place to put structure name
	  SETZM NAMBLK		;Clear it out
	  SETZM 1+NAMBLK	;...
	  MOVEM C,.MSRSN(B)	;Setup pointer in MSTR block
	  MSTR%			;Read it
	   ERJMP ENDLP.		;Exit loop
	  DMOVE C,NAMBLK	;Get structure name
	  CAMN C,MYNAM		;First word match?
	  CAME D,1+MYNAM	;Second word match?
	  LOOP.			;Nope - on to next unit
	  MOVE A,Q1		;Get index
	  IMULI A,.MSTNO	;Fix it
	  ADDI A,STRUNS		;And get beginning of block
	  DMOVE C,.MSRCH(B)	;Get channel & controller numbers
	  DMOVEM C,(A)		;Put into saved block
	  MOVE C,.MSRUN(B)	;Get unit number
	  MOVEM C,2(A)		;And save it, too
SMOUN1:	  AOJA Q1,TOP.		;Bump number of units & loop for next
	ENDDO.
	CALL %GETER		;Get last error
	MOVE A,ERCOD		;Get error code
	CAIE A,MSTX18		;Expected?
	 CALLRET CJERR		;Nope - punt
	MOVEI B,MSTBLK		;Point at MSTR block again
	HRROI C,MYNAM		;Name of structure
	MOVEM C,.MSTNM(B)	;Stash it
	HRROI C,MYAL		;Alias
	MOVEM C,.MSTAL(B)	;...
	HRRZM Q1,.MSTFL(B)	;Number of units
	IORM Q2,.MSTFL(B)	;Flags
	MOVSI C,STRUNS		;Unit info
	HRRI C,.MSTUI(B)	;Where it goes
	MOVE D,Q1		;Get number of units
	IMULI D,.MSTNO		;Number of words/unit
	PUSH P,D		;Save this...
	ADDI D,.MSTUI(B)	;Make end address
	BLT C,(D)		;Copy unit info
	POP P,D			;Get back #units*.MSTNO
	MOVSI A,.MSTUI(D)	;Make MSTR argblk size
	HRRI A,.MSMNT		;Mount structure function
	MSTR%			;Do it
	 ERJMP CJERRE		;Failed...
	HRROI A,MYNAM
	HRROI B,MYAL
	ETYPE <Structure %1M, alias %2M mounted>
	RET			;Done!!

GETATM:	SETZM (A)		;Clear out area
	SETZM 1(A)		;And second word
	HRLI A,(POINT 7,)
	MOVE B,[POINT 7,ATMBUF]	;Point at atom just parsed
	DO.
	  ILDB C,B		;Get a char
	  CAIL C,"a"		;In lower case bounds?
	  CAILE C,"z"		;??
	  TRNA			;Nope
	  SUBI C,"a"-"A"	;Yes - make upper case
	  IDPB C,A		;Copy
	  JUMPN C,TOP.		;Until a null
	ENDDO.
	RET

	END
