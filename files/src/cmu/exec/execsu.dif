1: NIC
2: CMU
---------------

LINE 7, PAGE 3
1)	;COPYRIGHT (C) 1980,1981,1982,1983 BY DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
1)	
LINE 7, PAGE 2
2)	;COPYRIGHT (C) 1980,1981,1982 BY DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
2)	


; SRC:<6-EXEC>EXECSU.MAC.19 & EXECSU.MAC.1 26-Jul-85 0102	PAGE 16



LINE 33, PAGE 3
1)	INTERN .INFG,$INFGX,DIRARG	;INPUT FILE GROUP DESCRIPTORS
LINE 33, PAGE 2
2)	INTERN CINFN			;EM85 Input file name
2)	INTERN .INFG,$INFGX,DIRARG	;INPUT FILE GROUP DESCRIPTORS


LINE 43, PAGE 3
1)	INTERN %GTB			;CONVENIENT GETAB JSYS CALL ROUTINE
1)	
LINE 44, PAGE 2
2)	INTERN %GTB			;CONVENIENT GETAB JSYS CALL UUO
2)	


LINE 51, PAGE 5
1)		MOVX A,CM%WKF!CM%XIF	;WAKE ON EVERY FIELD SO ECHO CAN BE TURNED OFF IN TIME FOR LOGIN
1)		SKIPN CUSRNO		;IS USER LOGGED IN?
1)		IORM A,CMFLG		;NO, SO DON'T ALLOW "@" AND WAKE PER FIELD
1)		MOVX A,CM%WKF
1)		SKIPE CUSRNO		;LOGGED IN?
1)		ANDCAM A,CMFLG		;YES, SO DON'T WAKE PER FIELD
1)		AOS CLZFFF		;SAY CLZFF BETTER BE DONE IF ^C HERE.
LINE 51, PAGE 4
2)		MOVX A,CM%XIF		;CM259 Don't allow indirect files bit
2)		SKIPN CUSRNO		;IS USER LOGGED IN?
2)		IORM A,CMFLG		;NO, SO DON'T ALLOW "@" AND WAKE PER FIELD
2)	;CM259 *** 3 lines deleted ***
2)		AOS CLZFFF		;SAY CLZFF BETTER BE DONE IF ^C HERE.


LINE 84, PAGE 5
1)	IFN STANSW,<
1)		SKIPLE PCCIPF		;CM156 Just confirmed top-level PCL command?
1)		SETOM PCCIPF		;CM156 Yes, remember it's in progress for ^T
1)	>;IFN STANSW
1)		SKIPE CIPF		;COMMAND ALREADY IN PROGRESS?
1)		JRST FIELD1		;YES
1)		MOVE A,COMAND		;GET ADDRESS OF TABLE ENTRY
1)	IFN STANSW,<
1)		TLNE A,-1		;CM156 Already been byte-pointer-ized?
1)		 JRST FIELD3		;CM156 Yes, don't trash COMAND
1)	>;IFN STANSW
1)		HLRZ A,(A)		;GET ADDRESS OF COMMAND NAME INFO
LINE 82, PAGE 4
2)		SKIPLE PCCIPF		;CM156 Just confirmed top-level PCL command?
2)		SETOM PCCIPF		;CM156 Yes, remember it's in progress for ^T
2)		SKIPE CIPF		;COMMAND ALREADY IN PROGRESS?
2)		JRST FIELD0		;CM236 YES

; SRC:<6-EXEC>EXECSU.MAC.19 & EXECSU.MAC.1 26-Jul-85 0102	PAGE 17


2)		MOVE A,COMAND		;GET ADDRESS OF TABLE ENTRY
2)		TLNE A,-1		;CM156 Already been byte-pointer-ized?
2)		 JRST FIELD3		;CM156 Yes, don't trash COMAND
2)		HLRZ A,(A)		;GET ADDRESS OF COMMAND NAME INFO


LINE 101, PAGE 5
1)	IFN STANSW,<
1)	FIELD3:	SKIPE PCCURC		;CM156 PCL command in progress?
1)		 MOVE A,PCLNAM		;CM156 Yes, so use its name
1)	>;IFN STANSW
1)		CALL GETSIX		;GET SIXBIT NAME FOR COMMAND
1)		 JFCL			;TRUNCATE IF COMMAND TOO LONG
1)		MOVEM A,COMSIX		;REMEMBER IT
1)		SKIPN PCCURC		;PCL No change if within stored command
1)		SETNM			;TELL SYSTEM, SO SYSTAT SHOWS IT
1)		SETOM CIPF		;SAY COMMAND IN PROGRESS
1)		CALL ECHCMD		;ECHO THE COMMAND IF NECESSARY
1)	IFN NICSW,<			;[NIC1017]
1)		SKIPN HCNT		;[NIC1017] DOING HISTORY?
1)		 JRST FIELD1		;[NIC1017] NO, SO SKIP IT
1)		LDB A,[POINT 7,CBUF,6]	;[NIC1017] GET FIRST CHARACTER IN COMMAND BUFFER
1)		CAIN A,"/"		;[NIC1017] IS IT THE EDIT CHARACTER?
1)		 JRST FIELD1		;[NIC1017] YES, SO IGNORE THIS COMMAND
1)		AOS CNUM		;[NIC1017] BUMP COMMAND COUNTER
1)		HRROI A,CBUF		;[NIC1017] GET PTR TO COMMAND INPUT
1)		CALL XBUFFS		;[NIC1017] COPY IT TO PRIV. PERM. SPACE
1)		HRRZ B,HPTR		;[NIC1017] LOOK AT CURRENT SLOT
1)		HLRZ C,HPTR		;[NIC1017] GET BASE SLOT
1)		ADD C,HCNT		;[NIC1017] POINT ONE PLACE PAST
1)		CAML B,C		;[NIC1017] WE PAST END?
1)		 HLR B,HPTR		;[NIC1017] GET ADDR OF BASE THEN
1)		HRRM B,HPTR		;[NIC1017] AND SAVE IT
1)		EXCH A,(B)		;[NIC1017] SAVE PTR TO COMMAND
1)		SKIPE A			;[NIC1017] WAS ANYTHING IN OLD PTR?
1)		 CALL STREM		;[NIC1017] YES, THEN RETURN IT
1)		HRRZ B,HPTR		;[NIC1017] GET PTR BACK TO NEW COMMAND
1)		MOVE A,(B)		;[NIC1017] GET BYTE PTR TO COMMAND
1)		AOS HPTR		;[NIC1017] POINT OT NEXT EMPTY SLOT
1)	FDHST1:	ILDB C,A		;[NIC1017] GET A BYTE
1)		JUMPE C,FIELD1		;[NIC1017] FOUND NULL BEFORE CRLF. FINE
1)		CAIE C,.CHCRT		;[NIC1017] LOOK FOR CR
1)		 CAIN C,.CHLFD		;[NIC1017] OR A LF
1)		  CAIA			;[NIC1017]
1)		   JRST FDHST1		;[NIC1017] TRY AGAIN
1)		SETO C,			;[NIC1017] BACK UP OVER IT
1)		ADJBP C,A		;[NIC1017]
1)		SETZ A,			;[NIC1017] AND DEPOSIT A NULL
1)		IDPB A,C		;[NIC1017] OVER TOP OF IT
1)	>;IFN NICSW
1)	FIELD1:	MOVX A,CM%XIF

; SRC:<6-EXEC>EXECSU.MAC.19 & EXECSU.MAC.1 26-Jul-85 0102	PAGE 18


LINE 95, PAGE 4
2)	FIELD3:	SKIPE PCCURC		;CM156 PCL command in progress?
2)		 MOVE A,PCLNAM		;CM156 Yes, so use its name
2)		CALL GETSIX		;GET SIXBIT NAME FOR COMMAND
2)		 JFCL			;TRUNCATE IF COMMAND TOO LONG
2)	CS,<				;CS45
2)		CAMN A,[SIXBIT "MDDT"]	;CS45 Are we going to scare Newcomer?
2)		  MOVE A,[OURNAM]	;CS45 Say we are doing something more innocent
2)	>				;CS45
2)		MOVEM A,COMSIX		;REMEMBER IT
2)		SETNM			;TELL SYSTEM, SO SYSTAT SHOWS IT
2)		SETOM CIPF		;SAY COMMAND IN PROGRESS
2)	FIELD0:				;CM236 Here if parsed confirm but a command was
2)					; already in progress (subcommand or else a
2)					; parse from within PCL).  Skip Systat name
2)					; stuff but echo it anyway
2)		CALL ECHCMD		;ECHO THE COMMAND IF NECESSARY
2)		CALL CSAVE		;EM66 Save the command
2)		SETZM PWDFLG		;CM236 No longer parsing password line
2)	FIELD1:	MOVX A,CM%XIF


LINE 9, PAGE 6
1)	;THESE ROUTINES ARE USED TO MANUALLY BACK UP THE COMND POINTERS
1)	;TO THE PREVIOUS ATOM.  THIS IS NECESSARY WHEN, FOR EXAMPLE,
1)	;COMND HAS CORRECTLY PARSED A NUMBER, BUT THE NUMBER FAILS
1)	;SOME RANGE CHECK THAT IS PERFORMED AFTER THE PARSE.
1)	
1)	SAVCM::	ATSAVE
1)		DMOVE A,SBLOCK+.CMPTR
1)		MOVE C,SBLOCK+.CMINC
1)		DMOVEM A,CBLOCK
1)		MOVEM C,CBLOCK+2
1)		RET
1)	
1)	RESCM::	ATSAVE
1)		DMOVE A,CBLOCK
1)		MOVE C,CBLOCK+2
1)		DMOVEM A,SBLOCK+.CMPTR
1)		MOVEM C,SBLOCK+.CMINC
1)		RET
1)	
1)	;ROUTINE TO ECHO THE CURRENT COMMAND STRING IF NEED BE
LINE 9, PAGE 5
2)	;ROUTINE TO ECHO THE CURRENT COMMAND STRING IF NEED BE


; SRC:<6-EXEC>EXECSU.MAC.19 & EXECSU.MAC.1 26-Jul-85 0102	PAGE 19



LINE 33, PAGE 6
1)		TXNN A,TKTERF		;YES, ARE WE READING FROM A TERMINAL?
LINE 14, PAGE 5
2)		MOVE B,CIJFN		;CM156 Get primary input JFN
2)		CAIN B,.NULIO		;CM156 From PCL?
2)		 JRST ECHCM1		;CM156 Yes, user can set command trace if s/he
2)					; wants to see the DOCOMMAND'd command
2)		TXNN A,TKTERF		;YES, ARE WE READING FROM A TERMINAL?


LINE 38, PAGE 6
1)		ETYPE <%1M>		;TYPE PROMPT STRING
1)		UTYPE CBUF		; AND COMMAND BUFFER
LINE 23, PAGE 5
2)		SKIPE PWDFLG		;CM236 Parsing a password?
2)		 JRST [ ETYPE <%@%%1M%%_> ;CM236 Echo prompt and CRLF only
2)			RET ]		;CM236
2)		ETYPE <%@%%1M>		;CM236 TYPE PROMPT STRING after calling LM
2)		UTYPE CBUF		; AND COMMAND BUFFER


LINE 45, PAGE 8
1)	GLNO:	MOVEI D,14		;FIRST SYSTEM LOAD AVERAGE IS WORD 14
1)		GTB .SYSTA
1)		MOVEM A,.SA1ML+GLBLK	;STORE THE LOAD AVERAGES
1)		MOVEI D,15
1)		GTB .SYSTA
1)		MOVEM A,.SA5ML+GLBLK
1)		MOVEI D,16
1)		GTB .SYSTA
1)		MOVEM A,.SA15L+GLBLK
1)		HRROI A,-1		;-1 MEANS CLASS SCHEDULING IS OFF
LINE 45, PAGE 7
2)	GLNO:	MOVE A,[14,,.SYSTA]	;CM224 Get load averages
2)		MOVE B,[-3,,.SA1ML]	;CM224 Into same place
2)		ADDI B,GLBLK		;CM224
2)		GTBLT%			;CM224 All at once
2)		 TRN			;CM224
2)		HRROI A,-1		;-1 MEANS CLASS SCHEDULING IS OFF


; SRC:<6-EXEC>EXECSU.MAC.19 & EXECSU.MAC.1 26-Jul-85 0102	PAGE 20



LINE 61, PAGE 8
1)	CLSON::	MOVEI B,C		;ARG BLOCK IN C
1)		MOVEI A,.SKRCV		;READ STATUS
LINE 57, PAGE 7
2)	CLSON::
2)	REPEAT 0,<			;Is this change a good idea???
2)		SKIPGE CLSACT		;CM224 Do we already know it isn't?
2)		RET			;CM224 Yes
2)		SKIPE CLSACT		;CM224 Do we already know it is?
2)		RETSKP			;CM224 Yes
2)	>;REPEAT 0
2)		MOVEI B,C		;ARG BLOCK IN C
2)		MOVEI A,.SKRCV		;READ STATUS


LINE 66, PAGE 8
1)		TXNN A,SK%STP		;CLASS SCHEDULER ON?
1)		RETSKP			;YES, SKIP
1)		RET			;NO, DON'T.
LINE 69, PAGE 7
2)	;;	AOS CLSACT		;CM224 Assume it is on
2)		TXNN A,SK%STP		;CLASS SCHEDULER ON?
2)		RETSKP			;YES, SKIP
2)	;;	SETOM CLSACT		;CM224 Remember it is off
2)		RET			;NO, DON'T.


LINE 122, PAGE 8
1)		MOVEI A,5		;PCL Precede prompt with space if batch
1)		SKIPN BATCHF		;THIS PREVENTS CONFUSION WITH OPERATOR MODE
1)		MOVEI A,4		;PCL Use a dollar sign
1)		SKIPN PRVENF		;USE @ IF NOT ENABLED
1)		MOVEI A,3		;PCL One prompt for regular command
1)		CALL SETPM2		;CM156 Get pointer to (subcommand) prompt
1)		JRST READ1		;CM156 Join common code
1)	
1)	SETPMT::MOVEM A,CMDACS		;DON'T CLOBBER ANY AC'S
1)		MOVEI A,2		;PCL Assume enabled batch
1)		SKIPN BATCHF		;THIS PREVENTS CONFUSION WITH OPERATOR MODE
1)		MOVEI A,1		;PCL Use a dollar sign
1)		SKIPN PRVENF		;USE @ IF NOT ENABLED
1)		SETZ A,			;PCL One prompt for regular command
1)	SETPM2:	MOVEM B,CMDACS+1	;PCL Get another register
1)		HRROI B,REDPMT(A)	;PCL Point to the standard prompt
1)		SKIPE PCLPMT(A)		;PCL Is one provided by PCL?
1)		HRRO B,PCLPMT(A)	;PCL Yes, point to that one
1)		MOVE A,B		;PCL
1)		MOVE B,CMDACS+1		;PCL
1)		RET

; SRC:<6-EXEC>EXECSU.MAC.19 & EXECSU.MAC.1 26-Jul-85 0102	PAGE 21


1)	
1)	;ENTER HERE FOR CUSTOM PROMPT CHARACTERS:
1)	
1)	READ1::	MOVEM A,CMRTY		;SET UP PROMPT BUFFER
1)		MOVEM A,SVPRMT		; AND REMEMBER THE POINTER FOR "TAKE, ECHO"
1)		POP P,REPARA		;REMEMBER WHERE TO REPRASE TO
1)		MOVE A,CMDACS		;GET SAVED AC1 (SEE %$TYPE:)
1)		MOVEM 17,CMDACS+17	;SAVE AC17 AWAY
1)		MOVEI 17,CMDACS		;MAKE BLT POINTER 0,,CMDACS
1)		BLT 17,CMDACS+16	;SAVE REST TO AC'S
1)		MOVE 17,CMDACS+17	;LEAVE AC17 INTACT
1)		MOVE A,JBUFP		;GET CURRENT LOCATION ON JFN STACK
LINE 127, PAGE 7
2)		MOVEI A,5		;CM156 Precede prompt with space if batch
2)		SKIPN BATCHF		;THIS PREVENTS CONFUSION WITH OPERATOR MODE
2)		MOVEI A,4		;CM156 Use a dollar sign
2)		SKIPN PRVENF		;USE @ IF NOT ENABLED
2)		MOVEI A,3		;CM156 One prompt for regular command
2)		CALL SETPM2		;CM156 Get pointer to (subcommand) prompt
2)		JRST READ1		;CM156 Join common code
2)	
2)	SETPMT:	MOVEM A,CMDACS		;CM156 DON'T CLOBBER ANY AC'S
2)		MOVEI A,2		;CM156 Assume enabled batch
2)		SKIPN BATCHF		;THIS PREVENTS CONFUSION WITH OPERATOR MODE
2)		MOVEI A,1		;CM156 Use a dollar sign
2)		SKIPN PRVENF		;USE @ IF NOT ENABLED
2)		SETZ A,			;CM156 One prompt for regular command
2)	SETPM2:	MOVEM B,CMDACS+1	;CM156 Get another register
2)		HRROI B,REDPMT(A)	;CM156 Point to the standard prompt
2)		SKIPE PCLPMT(A)		;CM156 Is one provided by PCL?
2)		HRRO B,PCLPMT(A)	;CM156 Yes, point to that one
2)		MOVE A,B		;CM156
2)		MOVE B,CMDACS+1		;CM156
2)		RET			;CM156
2)	
2)	;ENTER HERE FOR CUSTOM PROMPT CHARACTERS:
2)	
2)	READ1:	MOVEM A,CMRTY		;SET UP PROMPT BUFFER
2)		MOVEM A,SVPRMT		; AND REMEMBER THE POINTER FOR "TAKE, ECHO"
2)		POP P,REPARA		;REMEMBER WHERE TO REPRASE TO
2)		MOVE A,CMDACS		;GET SAVED AC1 (SEE %$TYPE:)
2)	;CS127	MOVEM 17,CMDACS+17	;SAVE AC17 AWAY
2)	;CS127	MOVEI 17,CMDACS		;MAKE BLT POINTER 0,,CMDACS
2)	;CS127	BLT 17,CMDACS+16	;SAVE REST TO AC'S
2)	;CS127	MOVE 17,CMDACS+17	;LEAVE AC17 INTACT
2)		MOVEM 0,CMDACS		;CS127 Save AC0 first
2)		MOVX 0,<1,,CMDACS+1>	;CS127 Point for BLT
2)		BLT 0,CMDACS+17		;CS127 Save rest of acs
2)		MOVE 0,CMDACS		;CS127 Restore AC0
2)		MOVE A,JBUFP		;GET CURRENT LOCATION ON JFN STACK


; SRC:<6-EXEC>EXECSU.MAC.19 & EXECSU.MAC.1 26-Jul-85 0102	PAGE 22



LINE 166, PAGE 8
1)		CALL FIELD		;TYPE THE PROMPT
1)		MOVE A,CIJFN		;PCL See if executing stored command
LINE 175, PAGE 7
2)		SKIPN NOPRMT		;CM307 Suppress prompt for Bboard or Finger?
2)		 JRST READ2A		;CM307 No, do prompt
2)		HRRZI A,.NULIO		;CM307 Yes, output to bit bucket
2)		HRRM A,CMIOJ		;CM307 Set block
2)	READ2A:
2)		CALL FIELD		;TYPE THE PROMPT
2)		SKIPN NOPRMT		;CM307 Prompt suppressed?
2)		 JRST READ2B		;CM307 No, continue
2)		HRRZ A,COJFN		;CM307 Yes, get the right jfn
2)		HRRM A,CMIOJ		;CM307 Set it
2)		SETZM NOPRMT		;CM307 Use prompt next time
2)	READ2B:				;CM307
2)		MOVE A,CIJFN		;PCL See if executing stored command


LINE 171, PAGE 8
1)		 JRST [	HRR A,COJFN	;PCL End of execution, fix up I/O JFNs
1)			HRL A,CIJFN	;PCL
1)			MOVEM A,CMIOJ	;PCL
1)			MOVX A,OURNAM	;PCL Fix the system name
1)			MOVE B,A	;PCL
1)			SETSN		;PCL Since we are going back to TI state
1)			 TRN		;CM156
1)			CALL SETPMT	;CM156 Get the correct prompt string
1)			MOVEM A,CMRTY	;CM156 Set it up
1)			JRST READ2]	;PCL And start again
1)	READ3:	MOVE A,CMDACS+A		;PCL
LINE 191, PAGE 7
2)		 JRST CMDIN4		;CM156 End of execution, get another command
2)	;;	 JRST [	HRR A,COJFN	;PCL End of execution, fix up I/O JFNs
2)	;;		HRL A,CIJFN	;PCL
2)	;;		MOVEM A,CMIOJ	;PCL
2)	;;		MOVX A,OURNAM	;PCL Fix the system name
2)	;;		MOVE B,A	;PCL
2)	;;		SETSN		;PCL Since we are going back to TI state
2)	;;		 TRN		;CM156
2)	;;		CALL SETPMT	;CM156 Get the correct prompt string
2)	;;		MOVEM A,CMRTY	;CM156 Set it up
2)	;;		JRST READ2]	;PCL And start again
2)	READ3:	MOVE A,CMDACS+A		;PCL


; SRC:<6-EXEC>EXECSU.MAC.19 & EXECSU.MAC.1 26-Jul-85 0102	PAGE 23



LINE 189, PAGE 8
1)	IFE STANSW,<
1)		ASCIZ /$/		;Enabled
1)	>;IFE STANSW
1)	IFN STANSW,<
1)		ASCIZ /!/		;Enabled
1)	>;IFN STANSW
1)		ASCIZ / $/		;Enabled batch needs space because of operator
1)		ASCIZ /@@/		;Disabled subcommand
1)	IFE STANSW,<
1)		ASCIZ /$$/		;Enabled subcommand
1)	>;IFE STANSW
1)	IFN STANSW,<
1)		ASCIZ /!!/		;Enabled subcommand
1)	>;IFN STANSW
1)		ASCIZ / $$/		;Enabled batch subcommand
LINE 210, PAGE 7
2)		ASCIZ /$/		;Enabled
2)		ASCIZ / $/		;Enabled batch needs space because of operator
2)		ASCIZ /@@/		;Disabled subcommand
2)		ASCIZ /$$/		;Enabled subcommand
2)		ASCIZ / $$/		;Enabled batch subcommand


LINE 42, PAGE 9
1)	PRVCK:	TXNN B,WHLU+OPRU+ERRU	;ANY PRIVILEGES WANTED?
1)		RETSKP			;NO - RETURN SUCCESS
LINE 42, PAGE 8
2)	PRVCK:	TXNN B,WHLU+OPRU+ERRU+ADMU+MNTU	;CM65 ANY PRIVILEGES WANTED?
2)		RETSKP			;NO - RETURN SUCCESS


LINE 48, PAGE 9
1)		MOVEI A,.FHSLF
1)		RPCAP			;READ CAPABILITIES ENABLED FOR THIS PROCESS
1)		TXNN D,WHLU		;CHECKING FOR WHEEL?
LINE 48, PAGE 8
2)		MOVE C,EXECAP+1		;CM224 get current capabilities
2)		TXNN D,WHLU		;CHECKING FOR WHEEL?


; SRC:<6-EXEC>EXECSU.MAC.19 & EXECSU.MAC.1 26-Jul-85 0102	PAGE 24



LINE 58, PAGE 9
1)	PRVCK2:	TXNE D,ERRU		;CHECKING FOR "CONFIDENTIAL INFORMATION"?
1)		TXNN	C,SC%CNF	;YES - HAS USER GOT IT?
LINE 57, PAGE 8
2)	PRVCK2:	TXNN D,ADMU		;CM17 CHECKING FOR ADMINISTRATOR?
2)		JRST PRVCK3		;CM17 NO - SKIP THIS
2)		TXNE	C,SC%ADM	;CM17 YES - HAS USER GOT ADMINISTRATOR?
2)		RETSKP			;CM17 YES - SUCCESS
2)	PRVCK3:	TXNN D,MNTU		;CM65 CHECKING FOR MAINTENANCE?
2)		JRST PRVCK4		;CM65 NO - SKIP THIS
2)	CC,<	TXNE	C,SC%MNT!SC%TTY> ;{C369};CM65 YES - HAS USER GOT MAINTENANCE?
2)	CS,<	TXNE	C,SC%MNT>	;CM65 YES - HAS USER GOT MAINTENANCE?
2)		RETSKP			;CM65 YES - SUCCESS
2)	PRVCK4:	TXNE D,ERRU		;CM65 CHECKING FOR "CONFIDENTIAL INFORMATION"?
2)		TXNN	C,SC%CNF	;YES - HAS USER GOT IT?


LINE 20, PAGE 10
1)		MOVEM .FP,.PP		;SAVED, IN CASE OF ERROR.
1)		MOVEM P,.P		;REMEMBER STACK POINTER IN CASE ERROR DURING SUBCOMMAND
LINE 20, PAGE 9
2)	;**;	[722]	Insert 1 line at %SBCOM: + 13	6-APR-82	KR
2)		MOVEM .FP,.PP		;[722]SAVE INN CASE OF ERROR
2)		MOVEM P,.P		;REMEMBER STACK POINTER IN CASE ERROR DURING SUBCOMMAND


LINE 35, PAGE 10
1)	IFN STANSW,<
1)		CALL ECHCMD		;ECHO THE SUBCOMMAND
1)	>;IFN STANSW
1)		SKIPE INITR		;IS THERE AN INITIALIZATION ROUTINE?
1)		CALL @INITR		;YES, EXECUTE IT
1)		CALL (P3)		;CALL CALLER'S ROUTINE FOR THIS SUBCOMMAND
1)		CALL ECHCMD		;NEED TO TURN ECHO ON FOR THE TAKE
1)		JRST SBCOM1		;GO GET ANOTHER
LINE 36, PAGE 9
2)		SKIPE INITR		;IS THERE AN INITIALIZATION ROUTINE?
2)		CALL @INITR		;YES, EXECUTE IT
2)		CALL (P3)		;CALL CALLER'S ROUTINE FOR THIS SUBCOMMAND
2)	;**;[726]	Insert 1 line at SBCOM1:+17	KR	29-APR-82
2)	;CM236 Remove this because it causes double-echoing in conjunction with
2)	; the FIELD0 CM236 change:
2)	;CM236	CALL ECHCMD		;[726]NEED TO TURN ON ECHO FOR TAKE?
2)		JRST SBCOM1		;GO GET ANOTHER


; SRC:<6-EXEC>EXECSU.MAC.19 & EXECSU.MAC.1 26-Jul-85 0102	PAGE 25



LINE 17, PAGE 11
1)	IFN STANSW,<
1)		PUSH P,A		;SAVE A
1)		MOVE A,CIJFN		;INPUT JFN 
1)		CFIBF			;CLEAR TYPEAHEAD
1)		POP P,A			;RESTORE A
1)	>;IFN STANSW
1)	
LINE 17, PAGE 10
2)	


LINE 24, PAGE 12
1)		MOVSI 17,CMDACS		;MAKE BLT POINTER CMDACS,,0
1)		BLT 17,17		;RESTORE AC'S TO HOW THEY WERE WHEN THIS PART OF COMMAND STARTED
1)	IFE STANSW,<
1)		SETZM PCLDCO		;PCL Clear original command flag
1)	>;IFE STANSW
1)		JRSTF @REPARA		;RETURN TO BEGINNING OF COMMAND LINE
LINE 24, PAGE 11
2)	;CS127	MOVSI 17,CMDACS		;MAKE BLT POINTER CMDACS,,0
2)	;CS127	BLT 17,17		;RESTORE AC'S TO HOW THEY WERE WHEN THIS PART OF COMMAND STARTED
2)	;CS127	TRN			;CS127
2)		MOVE 0,[CMDACS+1,,1]	;CS127 BLT pointer to restore
2)		BLT 0,17		;CS127 Restore 1-17
2)		MOVE 0,CMDACS		;CS127 Restore 0
2)	;CM156	SETZM PCLDCO		;PCL Clear original command flag
2)		JRSTF @REPARA		;RETURN TO BEGINNING OF COMMAND LINE


LINE 11, PAGE 13
1)	CCHEFN:	CALL CIOREL
1)		JFCL
1)		ETYPE < End of %1S
LINE 11, PAGE 12
2)	CCHEFN:	MOVE A,CMBFP		;CM236 Get pointer to COMND% text buffer
2)		CALL FIXPT		;CM236 Convert -1,,foo into 440700,,foo
2)	DO.				;CM236
2)		ILDB B,A		;CM236 Get a character
2)		CAIN B,.CHTAB		;CM236 Tab?
2)		 JRST TOP.		;CM236 Yes, look some more
2)		CAIN B,.CHSPC		;CM236 Space?
2)		 JRST TOP.		;CM236 Yes, get another character
2)	OD.				;CM236 Not white space, fall thru
2)		PUSH P,B		;CM236 Save it
2)		CALL CIOREL
2)		JFCL
2)		POP P,B			;CM236 Get back character
2)		SKIPE B			;CM236 Null?

; SRC:<6-EXEC>EXECSU.MAC.19 & EXECSU.MAC.1 26-Jul-85 0102	PAGE 26


2)		 ETYPE <%%%Missing CRLF at end of %1S - last line of the file skipped%_> ;CM236 No, warn user
2)		ETYPE < End of %1S


LINE 17, PAGE 13
1)	IFN STANSW,<
1)		SKIPE LGOFLG		;FROM LOGOUT.CMD?
1)		 JRST LOGOU2		;YES, GO LOGOUT THEN
1)	>;IFN STANSW
1)		JRST CMDIN4		;GO BACK FOR NEXT COMMAND
LINE 30, PAGE 12
2)	CS,<				;CM290 *** Start ***
2)		SKIPE LGOFLG		;From LOGOUT.CMD?
2)		JRST LOGOU2		;Yes, go logout now
2)	>				;CM290 *** End ***
2)		JRST CMDIN4		;GO BACK FOR NEXT COMMAND


LINE 43, PAGE 13
1)	IFN STANSW,<
1)		TXNE A,.TTDES		;CM156 Don't close if a terminal designator
1)		TRNA			;CM156 Either same or PTY designator
1)	>;IFN STANSW
1)		CLOSF			;CLOSE OUTPUT BUT NOT INPUT YET
LINE 56, PAGE 12
2)		TXNE A,.TTDES		;CM156 Don't close if a terminal designator
2)		TRNA			;CM156 Either same or PTY designator
2)		CLOSF			;CLOSE OUTPUT BUT NOT INPUT YET


LINE 6, PAGE 14
1)		EXP 0,%$ERR,%ETYPE,0
1)		EXP %PRINT,%TRAP,%.$ERR
LINE 6, PAGE 13
2)		EXP 0,%$ERR,%ETYPE,%GTB
2)		EXP %PRINT,%TRAP,%.$ERR


LINE 7, PAGE 16
1)	DT1:	TRVAR <RETBTS,TODAY,SENSE,DAYWEK,NOW,TOMORO,BTIME,<STRNG0,10>,DAYFLG>
1)		MOVEM A,SENSE		;REMEMBER WHETHER FUTURE OR PAST
LINE 7, PAGE 15
2)	DT1:	TRVAR <RETBTS,TODAY,SENSE,DAYWEK,NOW,TOMORO,BTIME,<STRNG0,10>>
2)		MOVEM A,SENSE		;REMEMBER WHETHER FUTURE OR PAST


; SRC:<6-EXEC>EXECSU.MAC.19 & EXECSU.MAC.1 26-Jul-85 0102	PAGE 27



LINE 13, PAGE 16
1)	IFE STANSW,<
1)		MOVSI B,1
1)		ADD B,A			;GET TOMORROW SAME TIME IN A
1)	>;IFE STANSW
1)	IFN STANSW,<
1)		MOVE B,A		;THIS IS REALLY TODAY 0000 NOW
1)	>;IFN STANSW
1)		CALL	TSTDST		;correct for DST
1)		HRROI A,STRNG0		;WRITE TO SCRATCH
LINE 13, PAGE 15
2)		MOVSI B,1
2)		ADD B,A			;GET TOMORROW SAME TIME IN A
2)		HRROI A,STRNG0		;WRITE TO SCRATCH


LINE 31, PAGE 16
1)	IFE STANSW,<
1)		MOVEM B,TOMORO		;REMEMBER VALUE FOR TOMORROW
1)		SUB B,[1B17]		;CREATE BEGINNING OF TODAY
1)	>;IFE STANSW
1)		MOVEM B,TODAY
1)	IFN STANSW,<
1)		SETZ D,			;DON'T SUPPLY ANY BITS
1)		ODCNV%			;BREAK INTO REAL "DAYS"
1)		HLRZS C			;DAY OF MONTH TO RIGHT HALF
1)		HRLZI C,1(C)		;ADD ONE AND RETURN TO LEFT HALF
1)		TXZ D,IC%DSA		;DON'T FORCE DAYLIGHT SAVINGS TIME
1)		IDCNV%			;GET INTERNAL DATE/TIME OF TOMORROW 0000
1)		IFJER.			;DAY IS AFTER LAST DAY OF MONTH.
1)		  SETZ C,		;OK, MAKE IT FIRST DAY OF MONTH
1)		  ADDI B,1		; AND BUMP MONTH
1)		  IDCNV%		;TRY AGAIN
1)		  IFJER.		;MONTH IS NOT LESS THAN 12
1)		    HLRZS B		;YEAR TO RIGHT HALF
1)		    HRLZI B,1(B)	;NEXT TRY FIRST MONTH OF NEXT YEAR
1)		    IDCNV%		;LAST TRY
1)		     ERCAL JERR		;PUNT
1)		  ENDIF.
1)		ENDIF.
1)		MOVEM B,TOMORO		;SAVE TOMORROW
1)	>;IFN STANSW
1)		MOVX A,CM%IDA+CM%ITM
LINE 25, PAGE 15
2)		MOVEM B,TOMORO		;REMEMBER VALUE FOR TOMORROW
2)		SUB B,[1B17]		;CREATE BEGINNING OF TODAY
2)		MOVEM B,TODAY
2)		MOVX A,CM%IDA+CM%ITM


; SRC:<6-EXEC>EXECSU.MAC.19 & EXECSU.MAC.1 26-Jul-85 0102	PAGE 28



LINE 81, PAGE 16
1)		MOVE	C,B		;save time
1)		CAMG B,NOW		;COMPUTE VALUE TO ADD
1)		addi	a,1		;make it next day
1)		HRLZS A			;PUT VALUE IN LEFT HALF
1)		ADD B,A			;FIX UP DATE-TIME
1)		move	a,c		;get DAT for today back
1)		call	tstdst		;correct for DST
1)		JRST DTEXIT		;TAKE STANDARD EXIT
LINE 53, PAGE 15
2)		CAMG B,NOW		;COMPUTE VALUE TO ADD
2)		ADDI A,1
2)		JUMPE A,DTEXIT		;DON'T BOTHER IF ZERO
2)		HRLZS A			;PUT VALUE IN LEFT HALF
2)		ADD B,A			;FIX UP DATE-TIME
2)		JRST DTEXIT		;TAKE STANDARD EXIT


LINE 96, PAGE 16
1)		MOVE	A,NOW		;get current DAT
1)		CALL	TSTDST		;correct for DST
1)		;...
LINE 66, PAGE 15
2)		;...


LINE 29, PAGE 18
1)		SETOM	DAYFLG		;note that day-of-week was specified
1)		JRST DAPLSQ		;MAYBE USER TYPING "+" AFTER THE DAY
1)	
1)	;	Daylight Saving Time correction subroutine
1)	;
1)	;	calling sequence:
1)	;	A/ current date and time
1)	;	B/ target date and time
1)	;	CALL	TSTDST
1)	;
1)	;	Returns:
1)	;	 +1 always with
1)	;	A/ current date and time
1)	;	B/ target date and time corrected for DST change over
1)	TSTDST:	STKVAR	<TDAT>		;make a storage spot
1)		MOVEM	B,TDAT		;save target date
1)		MOVE	B,A		;copy today's date and time to B
1)		SETZM	D		;clear D for ODCNV
1)		ODCNV			;do it
1)		TXNN	D,IC%ADS	;is DST applied (for current time)?
1)		JRST	[MOVE	B,TDAT	;no, get target date and time
1)			 SETZM	D	;clear ac D

; SRC:<6-EXEC>EXECSU.MAC.19 & EXECSU.MAC.1 26-Jul-85 0102	PAGE 29


1)			 ODCNV		;do it
1)			 MOVE	B,TDAT	;get target date back
1)			 TXNE	D,IC%ADS ;target date and time during DST?
1)			 SUBI	B,25253 ;yes, convert time to DST.
1)			 RET]		;return proper date and time
1)		MOVE	B,TDAT		;no, lets see if target date in in DST
1)		SETZM	D		;clear ac D
1)		ODCNV			;do it
1)		MOVE	B,TDAT		;get target date and time back
1)		TXNN	D,IC%ADS	;is target date in DST?
1)		ADDI	B,25253		;yes, correct for DST change over
1)		RET			;return proper date and time
1)	
1)	
1)	
1)	;USER HAS TYPED /AFTER:TODAY OR SINCE TODAY
1)	
1)	.TODAY:	SETZM	DAYFLG		;SAY WE DIDN'T DO A DAY OF THE WEEK
1)		MOVE A,TOMORO		;GET VALUE FOR TOMORROW
1)		SKIPE SENSE
LINE 29, PAGE 17
2)		JRST DAPLSQ		;MAYBE USER TYPING "+" AFTER THE DAY
2)	
2)	;USER HAS TYPED /AFTER:TODAY OR SINCE TODAY
2)	
2)	.TODAY:	MOVE A,TOMORO		;GET VALUE FOR TOMORROW
2)		SKIPE SENSE


LINE 78, PAGE 18
1)		ADD A,BTIME
1)		MOVE B,A		;RETURN INTERNAL DATE-AND-TIME IN B
1)	DAA1:	SKIPG SENSE		;RELATIVE TO NOW?
1)		 JRST DTEXIT		;NO - DONE
LINE 42, PAGE 17
2)	DAA1:	ADD A,BTIME
2)		MOVE B,A		;RETURN INTERNAL DATE-AND-TIME IN B
2)		SKIPG SENSE		;RELATIVE TO NOW?
2)		 JRST DTEXIT		;NO - DONE


LINE 86, PAGE 18
1)	NOPLUS:	MOVE	B,BTIME		;NO PLUS, SO NO MODIFICATION OF BASE TIME
1)		MOVE	A,DAYFLG	;GET FLAG THAT DAY-OF-WEEK WAS SPECIFIED
1)		JUMPGE	A,DAA1		;WAS FLAG SET? NO, CONTINUE
1)		MOVE	A,NOW		;YES, GET CURRENT DATE AND TIME
1)		CALL	TSTDST		;ADJUST IT FOR DST CROSS OVER
1)		JRST DAA1		;CONTINUE...
1)	^L
LINE 50, PAGE 17
2)	NOPLUS:	MOVEI A,0		;NO PLUS, SO NO MODIFICATION OF BASE TIME

; SRC:<6-EXEC>EXECSU.MAC.19 & EXECSU.MAC.1 26-Jul-85 0102	PAGE 30


2)		JRST DAA1
2)	^L


LINE 46, PAGE 19
1)		CALLRET $WORK
1)	
LINE 46, PAGE 18
2)		JRST $DEV1		;REST SAME AS DEVICE
2)	


LINE 52, PAGE 19
1)		CALLRET $WORK		;DO THE WORK AND SKIP OR NORMAL RETURN
1)	^L
1)	;FAKE NODE, SYNTAX CORRECT ONLY
1)	
1)	IFN STANSW,<
1)	IFN LOTSW,<
1)	LOCTAB:	TABLE
1)		[ASCIZ/CERAS/],,[ASCIZ/CERAS/]
1)		[ASCIZ/TERMAN/],,[ASCIZ/TERMAN/]
1)		TEND
1)	>;IFN LOTSW
1)	>;IFN STANSW
1)	
1)	FNODE$:	CALL GETHLP
1)		MOVX A,CMNOD!CM%PO!CM%NSF
1)		CALLRET $WORK
1)	
LINE 52, PAGE 18
2)	$DEV1:	CALLRET $WORK		;DO THE WORK AND SKIP OR NORMAL RETURN
2)	^L
2)	;FAKE NODE, SYNTAX CORRECT ONLY
2)	
2)	FNODE$:	CALL GETHLP
2)		MOVX A,CMNOD!CM%PO!CM%NSF ;CM288
2)		JRST $RNOD1		;REST SAME AS REAL NODE
2)	


LINE 20, PAGE 20
1)	IFE STANSW,<
1)		MOVX A,CMNOD!CM%NSF
1)		CALLRET $WORK
1)	>;IFE STANSW
1)	IFN STANSW,<
1)	IFE LOTSW,<
1)		MOVX A,CMNOD!CM%NSF
1)		CALLRET $WORK
1)	>;IFE LOTSW

; SRC:<6-EXEC>EXECSU.MAC.19 & EXECSU.MAC.1 26-Jul-85 0102	PAGE 31


1)	IFN LOTSW,<
1)		MOVEI A,LOCTAB
1)		MOVEM A,CMDAT		;SAVE DATA FOR THIS COMMAND
1)		MOVX A,CMKEY+[FLDDB. (.CMNOD,CM%SDH!CM%PO)]
1)		CALL $WORK
1)		 RET
1)		SAVEAC <A,B,C,D>	;NO, A KEYWORD.  USE VALUE INSTEAD
1)		LDB D,[331100,,(C)]	;GET FUNCTION CODE
1)		CAIE D,.CMKEY		;NODE NAME?
1)		IFSKP.			;NO...
1)		  HRROI A,ATMBUF	;FAKE COPY IN ATMBUF
1)		  HRRO B,(B)		;FROM KEYWORD VALUE
1)		  SETZ C,
1)		  SOUT%			;COPY STRING
1)		ENDIF.
1)		RETSKP
1)	>;IFN LOTSW
1)	>;IFN STANSW
1)	
LINE 11, PAGE 19
2)		MOVX A,CMNOD!CM%NSF	;CM288
2)	$RNOD1:	CALLRET $WORK		;DO THE WORK AND SKIP OR NORMAL RETURN
2)	


LINE 47, PAGE 21
1)		 JRST NC		;NO COMMAS, SO THERE'S ONLY ONE EXPRESSION
1)		CALL NESC		;USER TYPE ESCAPE?
1)		 JRST NC1		;YES - EXIT NOW SO GUIDE WORDS WILL BE SEEN
1)		CALL ADDPRT		;GET THE PART AFTER THE COMMAS
1)		 JRST NC1		;FAILED - ALLOW "FOO,,"
1)		HRR B,A			;PUT RIGHT HALF INTO B
LINE 47, PAGE 20
2)		 JRST [NC: MOVE B,LHVAL	;NO COMMAS, SO THERE'S ONLY ONE NUMBER
2)			   RETSKP]
2)		CALL NESC		;USER TYPE ESCAPE?
2)		 JRST NC1		;YES, EXIT NOW SO GUIDE WORDS WILL BE SEEN
2)		CALL ADDPRT		;GET THE PART AFTER THE COMMAS
2)		 JRST [NC1: HRLZ B,LHVAL ;ALLOW "FOO,,"
2)			    RETSKP]
2)		HRR B,A			;PUT RIGHT HALF INTO B


; SRC:<6-EXEC>EXECSU.MAC.19 & EXECSU.MAC.1 26-Jul-85 0102	PAGE 32



LINE 63, PAGE 21
1)		MOVE B,A		;GET COPY OF POINTER TO EXPRESSION
1)		ILDB B,B		;PEEK TO SEE IF NULL
1)		JUMPE B,ADDPR0		;NULL, SO RETURN 0
1)		CALLRET EVAL		;EVALUATE ADDRESS AND SKIP OR NORMAL RETURN
1)	
1)	ADDPR0:	TDZA A,A		;RETURN ZERO
1)	NC:	MOVE B,LHVAL		;NO COMMAS, SO THERE'S ONLY ONE EXPRESSION
1)		RETSKP
1)	
1)	NC1:	HRLZ B,LHVAL		;ALLOW "FOO,,"
1)		RETSKP
1)	
LINE 65, PAGE 20
2)		CALLRET EVAL		;EVALUATE ADDRESS AND SKIP OR NORMAL RETURN
2)	


LINE 88, PAGE 21
1)		CAME Q3,[ASCIZ /PSWD/]	;PARSING A PASSWORD ?
1)		JRST NOPSW		;NO
1)		MOVEI B,MSKLB		;YES, GET ADDR OF BREAK MASK
1)		MOVEM B,FBLOCK+4	;MOVE ADDR TO .CMBRK
1)		TXO A,CM%BRK		;SET CMBRK FLAG IN CMFNP
1)	NOPSW:	SETZM Q3		;RESTORE TEMP AC
1)		CALLRET $WORK
LINE 80, PAGE 20
2)		CALLRET $WORK


LINE 10, PAGE 22
1)		MOVEM A,CMFNP
LINE 10, PAGE 21
2)		SKIPN CMHLP		;CM236 Any help message supplied?
2)		TXZ A,CM%HPP!CM%DPP	;CM236 No, so use COMND%'s default
2)		MOVEM A,CMFNP


LINE 15, PAGE 22
1)					;FALL INTO HELP$ TO SET IT UP
1)	
LINE 17, PAGE 21
2)		HRRO A,40		;GET POINTER TO HELP STRING
2)		MOVEM A,CMHLP		;SET UP HELP TEXT POINTER
2)		RET
2)	


; SRC:<6-EXEC>EXECSU.MAC.19 & EXECSU.MAC.1 26-Jul-85 0102	PAGE 33



LINE 58, PAGE 23
1)		JFNS			;GET FIELD
1)		HRROI A,JFNSP		;POINT AT FIELD WE JUST WROTE
1)		HRROI B,[ASCIZ /*/]
1)		STCMP			;MAKE SURE ONLY "*" AND NOT "F*" ETC.
1)		JUMPN A,[ERROR <Invalid use of wildcard characters>]
1)		RET			;RETURN SUCCESFULLY
LINE 58, PAGE 22
2)		SETZM JFNSP		;CM224 Clear it first
2)		JFNS			;GET FIELD
2)		MOVE A,JFNSP		;CM224 Get field just extracted
2)		CAME A,[ASCIZ/*/]	;CM224 Make sure only "*" and not "F*", etc.
2)		ERROR <Invalid use of wildcard characters> ;CM224
2)		RET			;RETURN SUCCESFULLY


LINE 77, PAGE 23
1)	IFE STANSW,<		;;REMOVE JS%NOD FOR 5.X COMPATIBILITY
1)		MOVX C,<FLD(.JSAOF,JS%NOD)+JS%PAF> ;GET NODE
1)		CALL MCOSTO
1)	>;IFE STANSW
1)		MOVSI A,(GJ%DEV)	;FLAG BIT TO TEST
1)		MOVX C,<FLD(.JSAOF,JS%DEV)+JS%PAF> ;GET DEVICE
1)		CALL MCOSTR		;GET STRING
1)		MOVSI A,(GJ%DIR)
1)		MOVX C,<FLD(.JSAOF,JS%DIR)+JS%PAF> ;GET DIRECTORY
1)		CALL MCOSTR
1)		MOVSI A,(GJ%NAM)
1)		MOVX C,<FLD(.JSAOF,JS%NAM)+JS%PAF> ;NAME
1)		CALL MCOSTR
1)		SKIPN MFBUF		;NULL FILESPEC?
1)		JRST MFSET1		;YES
1)		MOVSI A,(GJ%EXT)
1)		MOVX C,<FLD(.JSAOF,JS%TYP)+JS%PAF> ;EXT
1)		MOVE D,MFPP		;SAVE THE CURRENT STRING POINTER
LINE 77, PAGE 22
2)		MOVSI A,(GJ%DEV)	;FLAG BIT TO TEST
2)		MOVE C,[1B2+1B35]	;GET DEVICE
2)		CALL MCOSTR		;GET STRING
2)		MOVSI A,(GJ%DIR)
2)		MOVE C,[1B5+1B35]	;GET DIRECTORY
2)		CALL MCOSTR
2)		MOVSI	A,(GJ%NAM)
2)		MOVE	C,[1B8+1B35]	;NAME
2)		CALL	MCOSTR
2)		SKIPN MFBUF		;NULL FILESPEC?
2)		JRST MFSET1		;YES
2)		MOVSI A,(GJ%EXT)
2)		MOVE C,[1B11+1B35]	;EXT

; SRC:<6-EXEC>EXECSU.MAC.19 & EXECSU.MAC.1 26-Jul-85 0102	PAGE 34


2)		MOVE D,MFPP		;SAVE THE CURRENT STRING POINTER


LINE 100, PAGE 23
1)		MOVX C,<FLD(.JSAOF,JS%GEN)+JS%PAF> ;VERSION
1)		CALL MCOSTR
1)		MOVX C,<FLD(.JSSSD,JS%PRO)+JS%PAF> ;PROTECTION
1)		CALL MCOSTO		;GET PROTECTION FROM OUTPUT
1)		MOVE C,MCOJFN		;GET OUTPUT NAME JFN
1)		TXNN C,GJ%TFS		;IS THIS A TEMPORARY FILESPEC?
1)		JRST MFSET0		;NO, SO DO NOT APPEND ;T TO FILENAME
1)		MOVE A,MFPP		;YES, GET STRING SPACE POINTER
1)		MOVEI C,";"		;APPEND A ;T TO THE FILENAME
1)		IDPB C,A
1)		MOVEI C,"T"
1)		IDPB C,A
1)		MOVEM A,MFPP		;REPLACE UPDATED STRING POINTER
1)	MFSET0:	MOVX C,<FLD(.JSSSD,JS%ACT)+JS%PAF> ;ACCOUNT
1)		CALL MCOSTO
1)		MOVX C,<JS%ATR+JS%PAF>	;GET ATTRIBUTES
1)		CALL MCOSTO
LINE 96, PAGE 22
2)		MOVE C,[1B14+1B35]	;VERSION
2)		CALL MCOSTR
2)		MOVE C,[2B17+1B35]	;PROTECTION
2)		CALL MCOSTO		;GET PROTECTION FROM OUTPUT
2)		MOVE C,MCOJFN		;CM288 Get output JFN
2)		TXNN C,GJ%TFS		;CM288 ;T?
2)		IFSKP.			;CM288
2)		  MOVE A,MFPP		;CM288 Yes, get pointer to name string
2)		  MOVX C,";"		;CM288
2)		  IDPB C,A		;CM288 Put out ";"
2)		  MOVX C,"T"		;CM288
2)		  IDPB C,A		;CM288 Put out "T"
2)		  MOVEM A,MFPP		;CM288
2)		ENDIF.			;CM288
2)		MOVE C,[2B20+1B35]	;ACCOUNT
2)		CALL MCOSTO
2)	;CM288	MOVE C,[1B21+1B35]	;";T"
2)	;CM288	CALL MCOSTO
2)		MOVE C,[JS%ATR!JS%PAF]	;GET ATTRIBUTES
2)		CALL MCOSTO


; SRC:<6-EXEC>EXECSU.MAC.19 & EXECSU.MAC.1 26-Jul-85 0102	PAGE 35



LINE 129, PAGE 23
1)		MOVE A,COJFN		;OUTPUT NAME TO HERE
1)		MOVE C,[JS%NOD+2B2+2B5+2B8+2B11+2B14+2B17+2B20+1B21+JS%ATR+1B35]
1)	IFN STANSW,<
1)		TXZ C,JS%NOD		;REMOVE JS%NOD BIT FOR 5.X COMPATIBILITY
1)	>;IFN STANSW
1)		SKIPN TYPGRP		;FORCED PRINT?
1)		TLNE Z,GROUPF		;NO, ONLY IF GROUP
1)		JFNS
1)		HRRZ A,OUTDSG
LINE 128, PAGE 22
2)	;EM29	MOVE A,COJFN		;OUTPUT NAME TO HERE
2)		MOVE A,[POINT 7,LBUFF]	;EM29
2)		MOVE C,[2B2+2B5+2B8+2B11+2B14+2B17+2B20+1B21+JS%ATR+1B35]
2)		SKIPN TYPGRP		;FORCED PRINT?
2)		TLNE Z,GROUPF		;NO, ONLY IF GROUP
2)		JFNS
2)		CALL FIXCAS		;EM29 Fix case
2)	;	UTYPE LBUFF		;EM29 Output the buffer
2)		HRRZ A,OUTDSG


LINE 145, PAGE 23
1)		CALL $GTFDB
1)		 SETZ A,		;MAKE SURE FB%NXF OFF IF ACCESS PREVENTED
1)		TXNN	A,FB%NXF	;NEW FILE?
LINE 144, PAGE 22
2)		GTFDB%			;CM224
2)		 ERJMP RSKP		;CM224 Protected, never mind
2)		TXNN	A,FB%NXF	;NEW FILE?


LINE 173, PAGE 23
1)		MOVX C,<JS%NOD+JS%DEV+JS%DIR+JS%NAM+JS%TYP+JS%GEN+JS%ATR+JS%PAF>
1)	IFN STANSW,<
1)		TXZ C,JS%NOD		;REMOVE JS%NOD FOR 5.X COMPATIBILITY
1)	>;IFN STANSW
1)		JFNS			;ASK FOR NODE::DEVICE:<DIR>NAME.EXT;GEN
1)		CALL GNFIL		;ADVANCE FIRST JFN BEFORE DELETE OR WE GET LOST
LINE 172, PAGE 22
2)		MOVE C,[1B2+1B5+1B8+1B11+1B14+JS%ATR+1B35] ;DEVICE:<DIR>NAME.EXT;GEN
2)		JFNS
2)		CALL GNFIL		;ADVANCE FIRST JFN BEFORE DELETE OR WE GET LOST


; SRC:<6-EXEC>EXECSU.MAC.19 & EXECSU.MAC.1 26-Jul-85 0102	PAGE 36



LINE 27, PAGE 24
1)	;	    B17: NO SUBCOMMANDS FOLLOW THE LIST.
1)	;
LINE 27, PAGE 23
2)	;CF%NS	    B17: NO SUBCOMMANDS FOLLOW THE LIST.
2)	;


LINE 7, PAGE 26
1)	;OUTPUT FILE NAME ENTRY (OLD OR NEW NAME).
LINE 7, PAGE 25
2)	;EM85 *** Begin ***
2)	;Input file name
2)	CINFN:	MOVEI B,(GJ%OLD)	;pa203 INPUT FILENAME  --  There may be an
2)					;  existing way to do this, but going through
2)					;  the (slow) CS front end I wasn't about to
2)					;  track it down...
2)		JRST SPECFN		;pa203
2)	;EM85 *** End ***
2)	
2)	;OUTPUT FILE NAME ENTRY (OLD OR NEW NAME).


LINE 15, PAGE 27
1)	IFE NICSW,<			;[NIC1043]
1)	INFGNS::MOVE B,[XWD -3,<GJ%OLD!GJ%IFG!GJ%NS!1B14!1B15>B53] ;* VERSION FOR RENAME
1)		JRST .INFG1
1)	>;IFE NICSW
1)	
1)	IFN NICSW,<			;[NIC1043]
1)	INFGNS::MOVEI B,(GJ%OLD!GJ%IFG!GJ%NS!1B14!1B15)	;[NIC1043] HIGHEST VERSION
1)		JRST .INFG1		;[NIC1043] JOIN COMMON CODE
1)	>;IFN NICSW
1)	
LINE 15, PAGE 26
2)	INFGNS::MOVE B,[XWD -3,<GJ%OLD!GJ%IFG!GJ%NS!1B14!1B15>B53] ;* VERSION FOR RENAME
2)		JRST .INFG1
2)	


LINE 48, PAGE 27
1)	
1)	
1)	IFN STANSW,<
1)	;TYPFLO - FLAVOR THAT READS LIST OF FILESPECS, JUST LIKE TYPFLS ABOVE, BUT DOES
1)	;*NOT* PARSE SUBCOMMANDS
1)	TYPFLO::DMOVE A,[EXP 0,<(GJ%OLD!GJ%IFG!1B15!1B17)>] ;NO SPECIAL, OLD FILE, STARS ALLOWED, LIST O.K., NO SUBCOMMANDS
1)	       CALL SPECFN     ;GATHER SPECS TO TYPE
1)	        RET	       ;NO SUBCOMMANDS

; SRC:<6-EXEC>EXECSU.MAC.19 & EXECSU.MAC.1 26-Jul-85 0102	PAGE 37


1)	       RET
1)	>;IFN STANSW
1)	
1)	
1)	;DIRARG
LINE 41, PAGE 26
2)	;DIRARG


LINE 45, PAGE 29
1)		FILEX <FILE NAME>	;TRY TO READ FILE NAME
1)		 JRST CFNE		;COULDN'T
1)		MOVE A,B		;PUT JFN INTO A
LINE 45, PAGE 28
2)		FILEX <file name>	;CM236 (fix case of help) TRY TO READ FILE NAME
2)		 JRST [	MOVE D,CFLAGS	;CM236 Couldn't, restore flags
2)			JRST CFNE]	;CM236
2)		MOVE A,B		;PUT JFN INTO A


LINE 14, PAGE 31
1)		TRNN Z,F4!F3!F2		;FOR DELETE, DIRECTORY OR DISCARD COMMAND?
1)		JRST CFNE2		;NO, NO CHECK
LINE 14, PAGE 30
2)		TRNN D,(1B14)		;NO SUCH FILE OK?
2)		JRST CFNE2		;NO, NO CHECK


LINE 40, PAGE 31
1)		IFNSK.
1)		  ETYPE <%_>
1)		  CALL %MESS
1)		  MOVE A,[440700,,ATMBUF]
1)		  ETYPE <%? - %1M %_>
1)		  JRST ERRFIN
1)		ENDIF.
1)		DEXTX <>		;CLEAR GTJFN BLOCK
LINE 40, PAGE 30
2)		 CMERRX			;LET MONITOR SAY WHAT'S WRONG WITH FILESPEC
2)		DEXTX <>		;CLEAR GTJFN BLOCK


LINE 21, PAGE 33
1)	IFE STANSW,<
1)		MOVE B,(B)		;PICK UP JFN AGAIN
1)	>;IFE STANSW
1)	IFN STANSW,<
1)		SKIPE B,(B)		;PICK UP JFN, ALLOW FOR PCL CLOBBERING IT
1)	>;IFN STANSW
1)		JFNS			;DO THE JFN TO STRING CONVERSION
LINE 21, PAGE 32

; SRC:<6-EXEC>EXECSU.MAC.19 & EXECSU.MAC.1 26-Jul-85 0102	PAGE 38


2)		MOVE B,(B)		;PICK UP JFN AGAIN
2)		JFNS			;DO THE JFN TO STRING CONVERSION


LINE 39, PAGE 35
1)		GNJFN			;STEP TO NEXT FILE IN *-GROUP
1)		 JRST GNFIL5		;NO MORE
LINE 39, PAGE 34
2)		CALL $GNJFN		;CM236 STEP TO NEXT FILE IN *-GROUP
2)		 JRST GNFIL5		;NO MORE


LINE 2, PAGE 36
1)	;THIS ROUTINE OBTAINS CONNECTED STRUCTURE.  RETURNS POINTER THERETO IN A.
LINE 2, PAGE 35
2)	;CM236 *** Begin addition ***
2)	
2)	;Routine to do a GNJFN%.  Behaves exactly like GNJFN% except that it
2)	;unstacks the JFN from the JFN stack if GNJFN% returns GNJFX1 (No more
2)	;files in this specification).  The reason for this is that GNJFN%
2)	;releases the JFN on GNJFX1 errors.  If the JFN were left on the stack,
2)	;RLJFNS would try to close and release it later.  If the JFN happened
2)	;to get reused by a background fork, the background fork would probably
2)	;get very confused and die horribly with a "JFN is not assigned" error.
2)	;
2)	$GNJFN::STKVAR <SAVJFN>
2)		MOVEM A,SAVJFN		;Save the JFN
2)		CALL PIOFF		;Don't allow ^C in the middle of this
2)		GNJFN%			;Do the JSYS
2)		 JRST GNFAIL		;Failed, go see why
2)		CALL PION		;Succeeded, allow ^C again
2)		RETSKP			;Return success
2)	
2)	GNFAIL:	CALL %GETER		;Get the error code
2)		EXCH A,ERCOD		;...
2)		CAIE A,GNJFX1		;No more files?
2)		IFSKP.
2)		  HRRZ A,SAVJFN		;Yes, get back JFN
2)		  CALL JUNSTK		;Remove it from JFN stack
2)		  MOVX A,GNJFX1		;Restore error code
2)		ENDIF.
2)		CALL PION		;Allow interrupts again
2)		EXCH A,ERCOD		;Get back saved AC1 (in case caller wants it)
2)		RET			;Return failure
2)	
2)	;CM236 *** End addition  ***	
2)	^L
2)	;THIS ROUTINE OBTAINS CONNECTED STRUCTURE.  RETURNS POINTER THERETO IN A.


; SRC:<6-EXEC>EXECSU.MAC.19 & EXECSU.MAC.1 26-Jul-85 0102	PAGE 39



LINE 8, PAGE 37
1)	
1)	GETDIR::MOVEI B,0		;NO PASSWORD GIVEN
1)	GETDRP::STKVAR <GACTPR,DNOO,DRADR,SAVPP,DRPASP>
1)		MOVEM A,DNOO		;REMEMBER DIRECTORY NUMBER
1)		MOVEM C,DRADR		;SAVE ADDRESS OF DIRECTORY BLOCK
1)		MOVEM B,DRPASP		;SAVE THE POINTER TO THE PASSWORD STRING
1)		MOVEI A,EXTSIZ		;ALLOCATE BLOCK FOR PASSWORD
1)		CALL GETBUF
1)		HRLI A,440700		;MAKE BYTE POINTER
1)		MOVEM A,SAVPP		;REMEMBER POINTER TO PASSWORD BLOCK
1)		MOVE A,DRADR		;GET ADDRESS OF BLOCK
LINE 8, PAGE 37
2)	;CM224 Since GETDRP is not used at CMU we can speed up GETDIR by
2)	; removing the password handling code.  I also removed the GETDRP
2)	; label so we will know if we ever need to put the code back.
2)	
2)	GETDIR::			;CM224
2)		STKVAR <GACTPR,DNOO,DRADR,SAVPP,DRPAS,GMRAPR> ;CM301
2)		MOVEM A,DNOO		;REMEMBER DIRECTORY NUMBER
2)		MOVEM C,DRADR		;SAVE ADDRESS OF DIRECTORY BLOCK
2)	;*** CM224 5 lines deleted ***
2)		MOVE A,DRADR		;GET ADDRESS OF BLOCK


LINE 23, PAGE 37
1)		MOVE A,SAVPP		;COPY PASSWORD INTO BLOCK FOR DIRECTORY
1)		MOVE B,DRPASP		;COPY FROM GIVEN PASSWORD (OR 0!)
1)		MOVEI C,0		;STOP COPYING ON NULL CHARACTER
1)		SOUT			;COPY THE PASSWORD
1)		MOVE A,DNOO		;GET DIRECTORY NUMBER
LINE 22, PAGE 37
2)		MOVE A,DRADR		;CM301 Do the same for mail routing address
2)		MOVE A,.CDMRA(A)	;CM301
2)		MOVEM A,GMRAPR		;CM301
2)	;*** CM224 4 lines deleted ***
2)		MOVE A,DNOO		;GET DIRECTORY NUMBER


LINE 31, PAGE 37
1)		MOVE C,SAVPP		;WHERE TO PUT PASSWORD (POINTER RETURNED IN BUFFER)
1)		AOS .CDDRN(B)		;FOR REMOTE ALIAS BLOCK, FIRST WORD NOT USED
1)					; BY GTDIR
1)		GTDIR			;GET ALL THE INFO INTO THAT BLOCK
1)		 ERJMP R		;IF FAILED, RETURN NO-SKIP
1)		HLRZ A,@.CDDRN(B)	;GET USED COUNT FOR GTDIR BLOCK
1)		SOS .CDDRN(B)		;REMOTE ALIAS BLOCK - RECOVER ENTIRE BLOCK
1)		CAIG A,1		;ANY ALIASES RETURNED ?
1)		JRST GETDR1		;NO.

; SRC:<6-EXEC>EXECSU.MAC.19 & EXECSU.MAC.1 26-Jul-85 0102	PAGE 40


1)		MOVE A,.CDDRN(B)	;YES. MAKE FIRST WORD OF REMOTE ALIAS BLOCK
1)		ADDI A,2		; TO POINT
1)		MOVEM A,@.CDDRN(B)	;  TO ALIAS LIST.
1)	GETDR1:	MOVE A,GACTPR		;GET ORIGINAL ACCOUNT POINTER
1)		MOVEM A,.CDDAC(B)	;MAKE POINTER TO BEGINNING OF ACCOUNT
LINE 30, PAGE 37
2)		SETZ C,			;CM224 Never return password
2)		GTDIR			;GET ALL THE INFO INTO THAT BLOCK
2)		 ERJMP R		;IF FAILED, RETURN NO-SKIP
2)		MOVE A,GMRAPR		;CM301 Restore mail routing address pointer
2)		MOVEM A,.CDMRA(B)	;CM301
2)		MOVE A,GACTPR		;GET ORIGINAL ACCOUNT POINTER
2)		MOVEM A,.CDDAC(B)	;MAKE POINTER TO BEGINNING OF ACCOUNT


LINE 82, PAGE 37
1)		MOVEI A,RNAUFL		;GET BLOCK FOR
1)		CALL GETBUF		; REMOTE ALIAS LIST
1)		MOVE B,BFA		;STORE
1)		MOVEM A,.CDDRN(B)	; IT
1)		MOVEI B,RNAUFL-1	;PUT LENGTH IN
1)		MOVEM B,1(A)		; IN SECOND WORD OF REMOTE ALIAS BLOCK
1)		SETZM (A)		;CLEAR FIRST WORD OF REMOTE ALIAS BLOCK
1)		MOVEI A,GTDLN		;SET UP LENGTH OF BUFFER
1)		MOVE B,BFA		; IN FIRST
1)		MOVEM A,.CDLEN(B)	;  WORD OF BUFFER
1)		RET
LINE 74, PAGE 37
2)		MOVEI A,MRASIZ		;CM301 Get room for mail routing address
2)		CALL GETBUF		;CM301
2)		MOVE B,BFA		;CM301
2)		HRLI A,440700		;CM301
2)		MOVEM A,.CDMRA(B)	;CM301
2)		SETZM (A)		;CM301
2)		MOVEI A,GTDLN		;SET UP LENGTH OF BUFFER
2)		MOVEM A,.CDLEN(B)	;IN FIRST WORD OF BUFFER
2)		RET


LINE 102, PAGE 37
1)	;	o	BLOCK FOR REMOTE ALIASES
1)	;
LINE 92, PAGE 37
2)	;	o	Mail-routing address (CM301)
2)	;


; SRC:<6-EXEC>EXECSU.MAC.19 & EXECSU.MAC.1 26-Jul-85 0102	PAGE 41



LINE 137, PAGE 37
1)		MOVEI A,RNAUFL		;PREPARE TO RELEASE REMOTE ALIAS STORAGE
1)		CAILE Q2,.CDDRN		;REMOTE ALIAS
1)		SKIPN B,.CDDRN(Q1)	; STORAGE ?
1)		CAIA			;NONE PRESENT.
1)		CALL RETBUF		;RELEASE STORAGE
1)		RET
1)	
1)	
LINE 127, PAGE 37
2)		MOVEI A,MRASIZ		;CM301 Prepare to release mail-routing address
2)		CAILE Q2,.CDMRA		;CM301 Is there one?
2)		SKIPN B,.CDMRA(Q1)	;CM301 ...
2)		CAIA			;CM301 No, skip it
2)		CALL RETBUF		;CM301 Yes, release it
2)		RET
2)	


LINE 159, PAGE 37
1)		SKIPE CUSRNO		;NO DEFAULTING ALLOWED IF NOT LOGGED IN
1)		TLNE Z,F1		;DEFAULTING ALLOWED?
1)		JRST NODDF1		;NO
1)		MOVEI A,USRDEF		;POINT AT TEMP STRING AREA
1)		CALL DFUSER		;GET DEFAULT USER STRING
1)	NODDF1:	TLNE Z,F5		;ALLOW WILDCARDS?
LINE 148, PAGE 37
2)		SKIPE B,CUSRNO		;CM224 NO DEFAULTING ALLOWED IF NOT LOGGED IN
2)		TLNE Z,F1		;DEFAULTING ALLOWED?
2)		JRST NODDF1		;NO
2)		HRROI A,USRDEF		;GET ROOM FOR STRING
2)		MOVEM A,CMDEF		;REMEMBER POINTER TO DEFAULT STRING
2)	;CM224 *** 7 lines deleted ***
2)		DIRST			;MAKE DEFAULT STRING
2)		 JFCL
2)	NODDF1:	TLNE Z,F5		;ALLOW WILDCARDS?


LINE 177, PAGE 37
1)	
1)	;HERE TO PICK UP THE USERS NAME AND BUILD THE STRING.
1)	;CALL WITH: A/ ADR TO PUT THE STRING
1)	
1)	DFUSER::MOVE D,A		;SAVE POINTER
1)		HRROI A,(D)   		;GET ROOM FOR STRING
1)		MOVEM A,CMDEF		;REMEMBER POINTER TO DEFAULT STRING
1)		MOVNI A,1		;PREPARE TO READ ONE JOB DATUM
1)		HRROI B,A		;WE'LL READ DATUM INTO A
1)		MOVEI C,.JIUNO		;DEFAULT TO CURRENT USER

; SRC:<6-EXEC>EXECSU.MAC.19 & EXECSU.MAC.1 26-Jul-85 0102	PAGE 42


1)		GETJI			;GET INTERNAL FORM OF DEFAULT
1)		 CALL JERR		;SHOULD NEVER FAIL
1)		MOVE B,A		;PUT DEFAULT INTO B
1)		MOVE A,CMDEF		;GET POINTER TO DEFAULT STRING AREA
1)		DIRST			;MAKE DEFAULT STRING
1)		 JFCL
1)		RET
1)	
1)	
1)	CURNMS::TLO Z,F5!F4		;ALLOW WILDCARDING, DEFAULTING ALLOWED
LINE 169, PAGE 37
2)	CURNMS::TLO Z,F5!F4		;ALLOW WILDCARDING, DEFAULTING ALLOWED


LINE 204, PAGE 37
1)	DIRNAM::TLZ Z,F4!F5!F6		;NO WILDCARDING, NO RETN IF AMBIGUOUS, NO DEF'T
1)	DIRNA0:	STKVAR <<DIRDF,EXTSIZ>>
1)		SKIPE CUSRNO		;NO DEFAULTING ALLOWED IF NOT LOGGED IN
1)		TLNE Z,F1		;DEFAULTING ALLOWED?
1)		JRST NODDF		;NO
1)		HRROI A,DIRDF		;GET BUFFER FOR DEFAULT
1)		MOVEM A,CMDEF		;DEFAULT WANTED, SET UP POINTER
1)		MOVNI A,1		;PREPARE TO READ ONE JOB DATUM
1)		HRROI B,A		;WE'LL READ DATUM INTO A
1)		MOVEI C,.JIDNO		;FIRST ASSUME DEFAULT TO CONNECTED DIRECTORY
1)		TLNN Z,F4		;DEFAULT TO LOGGED-IN?
1)		MOVEI C,.JILNO		;YES, GET LOGGED-IN DIRECTORY NUMBER
1)		GETJI			;GET INTERNAL FORM OF DEFAULT
LINE 177, PAGE 37
2)	;EM112 *** Begin ***
2)	
2)	DIRNEW::TLZ Z,F5!F4		;No wildcarding or default
2)		TLO Z,F6!F1		;No default allowed. Parse only allowed
2)		JRST DIRNA0
2)	
2)	$DIRBL:	FLD(.CMUSR,CM%FNC)!CM%PO!CM%HPP!CM%SDH
2)		0
2)		-1,,[ASCIZ/relative directory name/]
2)	
2)	$DIRBW:	FLD(.CMUSR,CM%FNC)!CM%PO!CM%HPP!CM%SDH
2)		CM%DWC
2)		-1,,[ASCIZ/relative directory name/]
2)	
2)	;EM112 *** End ***
2)	
2)	DIRNAM::TLZ Z,F4!F5!F6		;EM112 No wild, no parse-only,no default
2)	DIRNA0:	STKVAR <<DIRDF,EXTSIZ>,<DIRNBF,EXTSIZ>,<PRSBUF,EXTSIZ>,BUFADR> ;EM112
2)		MOVX A,FLD(.CMDIR,CM%FNC)!$DIRBL ;EM112 Function to use
2)		MOVEM A,CMFNP		;EM112 Set it up
2)		SETZM CMDAT		;EM112 Clear out data for function
2)		SKIPE CUSRNO		;NO DEFAULTING ALLOWED IF NOT LOGGED IN

; SRC:<6-EXEC>EXECSU.MAC.19 & EXECSU.MAC.1 26-Jul-85 0102	PAGE 43


2)		TLNE Z,F1		;DEFAULTING ALLOWED?
2)		JRST NODDF		;NO
2)		MOVX A,CM%DPP		;EM112 Have a default
2)		IORM A,CMFNP		;EM112 Set it
2)		HRROI A,DIRDF		;GET BUFFER FOR DEFAULT
2)		MOVEM A,CMDEF		;DEFAULT WANTED, SET UP POINTER
2)		MOVE B,LIDNO		;CM224 Get logged-in directory number
2)		TLNN Z,F4		;CM224 Is that good enough?
2)		JRST DIRNA2		;CM224 yes
2)		MOVNI A,1		;PREPARE TO READ ONE JOB DATUM
2)		HRROI B,A		;WE'LL READ DATUM INTO A
2)		MOVEI C,.JIDNO		;FIRST ASSUME DEFAULT TO CONNECTED DIRECTORY
2)	;CM224 *** 2 lines deleted ***
2)		GETJI			;GET INTERNAL FORM OF DEFAULT


LINE 220, PAGE 37
1)		DIRST			;MAKE DEFAULT STRING
1)		 JFCL
1)	NODDF:	TLNE Z,F5		;ALLOW WILDCARDING?
1)		JRST [	DIRSX <Directory name>
1)			 RET		;FAILED
1)			JRST DIRNA1]	;GOT ONE
1)		DIRX <Directory name>
1)		 RET			;SINGLE RETURN ON FAILURE
1)	DIRNA1:	CALL BUFFF		;MAKE A COPY OF THE STRING
1)		PUSH P,A		;SAVE THE POINTER TO THE STRING
1)		MOVE B,A		;GET POINTER TO DIR NAME AGAIN
1)		MOVX A,RC%EMO!RC%AWL	;EXACT MATCH AND ALLOW WILDCARDS
1)		RCDIR			;GET INFO ON THIS DIRECTORY
1)		 ERJMP [POP P,(P)
1)			RET]		;IF FAILS, NO SUCH DIR
1)		POP P,B			;RETURN THE STRING POINTER IN B
1)		TXNE A,RC%NOM!RC%AMB!RC%NMD
1)		RET			;NONE FOUND
1)		RETSKP			;TAKE SKIP RETURN ON SUCCESS
1)	
LINE 216, PAGE 37
2)	DIRNA2:				;CM224
2)		DIRST			;MAKE DEFAULT STRING
2)		 JFCL
2)	
2)	;EM112 *** Begin ***
2)	
2)	NODDF:	TLNN Z,F5		;Wildcard OK?
2)		IFSKP.			;Yes
2)		  MOVX A,<CM%DWC>	;The flag
2)		  IORM A,CMDAT		;Put in command flag word
2)		  MOVEI A,$DIRBW	;Use wild block
2)		  HRRM A,CMFNP		;Set it
2)		ENDIF.

; SRC:<6-EXEC>EXECSU.MAC.19 & EXECSU.MAC.1 26-Jul-85 0102	PAGE 44


2)		TLNN Z,F6		;Parse-only directory name ok?
2)		IFSKP.			;Yes
2)		  MOVX A,<CM%PO>	;Get flag
2)		  IORM A,CMDAT		;Set it up
2)		ENDIF.
2)		MOVEI B,FBLOCK
2)		CALL FLDSKP		;Parse something
2)		 CMERRX
2)		MOVSI A,ATMBUF		;Point at atom buffer
2)		HRRI A,PRSBUF		;Parse buffer...
2)		BLT A,EXTSIZ-1+PRSBUF	;Stash atom buffer away somewhere
2)		LDB C,[331100,,(C)]	;Get function parsed
2)		CAIE C,.CMUSR		;A user?
2)		IFSKP.
2)		  TLNN Z,F6		;Parse only?
2)		  IFSKP.		;Yes. Must check for device parsed as uname
2)		    MOVEI D,DIRNBF	;Point at name buffer
2)		    HRLI D,(POINT 7,)	;Make BP
2)		    LDB A,[POINT 7,ATMBUF,6] ;Get first character of atom buffer
2)		    JUMPE A,DIRNA7	;If a null, then must be a directory name
2)		    MOVE A,[POINT 7,ATMBUF] ;Point at atm buffer
2)		    DO.
2)		      ILDB B,A		;Get a char
2)		      JUMPE B,ENDLP.	;Until null
2)		      IDPB B,D		;Append
2)		      LOOP.
2)		    ENDDO.
2)		    MOVEI B,[FLDDB. .CMTOK,,<-1,,[ASCIZ/:/]>]
2)		    CALL FLDSKP		;Maybe really a directory name...
2)		  ANSKP.		;Found device field. Either logical name or dir
2)		    MOVEI A,":"		;Delimiter
2)		    IDPB A,D		;Append to current name string
2)	DIRNA7:	    MOVEI B,[FLDDB. .CMDIR,CM%PO]
2)		    CALL FLDSKP		;Try to parse a directory name
2)		    IFSKP.		;Succeded.
2)		      MOVE A,[POINT 7,ATMBUF] ;Point at atom buffer
2)		      DO.
2)		        ILDB B,A	;Get a char
2)		        IDPB B,D	;Copy it
2)		        JUMPN B,TOP.	;Until null.
2)		      ENDDO.
2)		      JRST DIRNA5	;And done
2)		    ELSE.
2)		      SETZ B,		;Null
2)		      DPB B,D		;Nuke ":" at end of name
2)		      MOVX A,.LNSJB	;Try for jobwide logical name
2)		      HRROI B,DIRNBF	;In directory buffer
2)		      HRROI C,DIRNBF	;To directory buffer
2)		      LNMST%		;Try...
2)		      IFNSK.		;Failed
2)			MOVX A,.LNSSY	;Try system logical name

; SRC:<6-EXEC>EXECSU.MAC.19 & EXECSU.MAC.1 26-Jul-85 0102	PAGE 45


2)		        LNMST%		;...
2)			RET		;Bogus logical name
2)		      ENDIF.
2)		      MOVEI A,DIRNBF	;Point at buffer again
2)		      HRLI A,(POINT 7,)	;Make BP
2)		      DO.
2)			ILDB B,A	;Get chars
2)	;		JUMPE B,ENDLP.	;Until null
2)			JUMPE B,DIRNA5	;If null, then done (don't jump to a jump)
2)			CAIE B,76	;Or directory name delimiter
2)			LOOP.
2)			SETZ B,		;Make sure a null
2)		 	IDPB B,A	;After name
2)		      ENDDO.
2)		      JRST DIRNA5	;Done with gross hack...
2)		    ENDIF.		;(not directory name case)
2)		  ENDIF.		;(colon after "user name" case)
2)		  GJINF%		;Get job info
2)		  HRROI A,DIRNBF	;Where to put name
2)		  DIRST%		;B already has connected dir.
2)		   TRN
2)		  MOVEI B,PRSBUF	;Point at parse item
2)		  HRLI B,(POINT 7,)	;Make a byte pointer to it
2)		  ILDB C,B		;Get first char
2)		  CAIE C,"."		;Is it a dot?
2)		  IFSKP.		;Yup
2)		    ILDB C,B		;Get get next character
2)		    JUMPE C,DIRNA5	;If just "." by itself, then done
2)		    CAIN C,"."		;Do we have ..?
2)		    IFSKP.		;Nope
2)		      MOVNI B,1
2)		      ADJBP B,A		;Backup one character in string
2)		      MOVE A,B		;Get back updated pointer
2)		      JRST DIRNA3	;And go append current string
2)		    ENDIF.
2)		    DO.			;Loop to find last dot in name
2)		      MOVNI B,1
2)		      ADJBP B,A		;Backup one character in string
2)		      MOVE A,B		;Put bp back
2)		      LDB B,A		;Get char
2)		      CAIE B,74		;Backed up to open bracket?
2)		      IFSKP.		;Yes
2)			MOVSI A,[ASCIZ/<ROOT-DIRECTORY>/]
2)			JRST DIRNA6	;Go for it...
2)		      ENDIF.
2)		      CAIE B,"."	;A dot?
2)		       LOOP.		;Nope - try next char
2)		    ENDDO.
2)		    MOVEI B,76		;Close it off
2)		    DPB B,A
2)		    JRST DIRNA4

; SRC:<6-EXEC>EXECSU.MAC.19 & EXECSU.MAC.1 26-Jul-85 0102	PAGE 46


2)		  ENDIF.		;(".username" case)
2)		  MOVEI C,"."		;Prepare another subdir...
2)		  DPB C,A		;Write over the close bracket
2)	DIRNA3:   HRROI B,PRSBUF	;Point at username or .username
2)		  SETZ C,
2)		  SOUT%			;Copy username into buffer
2)		  MOVEI B,76		;Close bracket
2)		  IDPB B,A
2)	DIRNA4:	  SETZ B,		;And a null
2)		  IDPB B,A
2)	DIRNA5:	  MOVSI A,DIRNBF	;Point at name buffer
2)		  TRNA
2)		ENDIF.
2)		MOVSI A,ATMBUF		;Have real directory. Point at atom buffer
2)	DIRNA6:	PUSH P,A		;Save LH string address
2)		MOVEI A,EXTSIZ		;Count of words
2)		CALL GETBUF		;Get some free space
2)		EXCH A,(P)		;Get our address off stack, put buffer addr on
2)		HRR A,(P)		;Get buffer address back
2)		MOVE CX,A		;EM112
2)		BLT A,EXTSIZ-1(CX)	;EM112 Copy local buffer to fresspace buffer
2)		HRRO B,(P)		;Get pointer to dir name again
2)	;EM112 *** End ***
2)		MOVX A,RC%EMO!RC%AWL	;EXACT MATCH AND ALLOW WILDCARDS
2)		RCDIR			;GET INFO ON THIS DIRECTORY
2)		 ERJMP DIRNAX		;EM112 Failed...
2)		IFXE. A,RC%NOM!RC%AMB!RC%NMD ;EM112 Did it succede
2)		  IFXE. A,RC%WLD	;EM112 Wildcard?
2)		    PUSH P,A		;EM112 Save RCDIR flags
2)		    HRRO A,-1(P)	;EM112 Get pointer
2)		    MOVE B,C		;EM112 Get directory number
2)		    DIRST%		;EM112 Translate back to string
2)		     TRN		;EM112
2)		    POP P,A		;EM112 Get back RCDIR flags
2)		  ENDIF.		;EM112
2)		  AOS -1(P)		;EM112 Setup skip return
2)		ELSE.			;EM112 Failed...
2)	DIRNAX:	  TLNE Z,F6		;EM112 Parse-only ok?
2)		   AOS -1(P)		;EM112 Allow skip return
2)		ENDIF.			;EM112
2)		POP P,B			;EM112 Restore pointer
2)		HRLI B,(POINT 7,)	;EM112 Make a string ptr
2)		RET			;EM112 Done
2)	


; SRC:<6-EXEC>EXECSU.MAC.19 & EXECSU.MAC.1 26-Jul-85 0102	PAGE 47



LINE 252, PAGE 37
1)		MOVX A,RC%AWL!RC%STP	;STEP THE DIR
1)		XCT D
LINE 387, PAGE 37
2)	STPUS1:	ILDB A,STPSTP		;GET NEXT CHAR OF STRING
2)		CAIE A,"*"		;IS IT A WILDCARD?
2)		CAIN A,"%"		;...
2)		JRST STPUS2		;YES, GO TRY TO STEP THIS STRING
2)		JUMPN A,STPUS1		;NO, KEEP LOOKING
2)		RET			;NONE FOUND, THEN DO NOT DO THE JSYS
2)	
2)	STPUS2:	MOVX A,RC%AWL!RC%STP	;STEP THE DIR
2)		XCT D


LINE 5, PAGE 38
1)	;ERROR OCCURRED.
1)	;USED IN DIRECTORY, UNDELETE, DSKSTAT, COPY/APPEND, LIST/TYPE.
LINE 5, PAGE 38
2)	;ERROR OCCURED.
2)	;USED IN DIRECTORY, UNDELETE, DSKSTAT, COPY/APPEND, LIST/TYPE.


LINE 18, PAGE 40
1)	
1)	;THIS ROUTINE RETURNS IF THE USER ENDS A RANGE WITH $.  THIS IS NECESSARY
LINE 18, PAGE 40
2)	;THIS ROUTINE RETURNS IF THE USER ENDS A RANGE WITH $.  THIS IS NECESSARY


LINE 27, PAGE 40
1)		 JRST NUMREP		;IT DID, SO DON'T INPUT MORE
1)		COLONX <":" to enter range, or "," for another number, or next field of command>
LINE 26, PAGE 40
2)		 CALLRET NUMREP		;IT DID, SO DON'T INPUT MORE
2)		COLONX <":" to enter range, or "," for another number, or next field of command>


LINE 17, PAGE 41
1)	DWNTYP::GJINF
1)		JUMPN A,R		;NO TYPE IF ALREADY LOGGED IN
1)	IFE STANSW,<
1)	DWNPNT::MOVEI D,0		;GET ITEM 0 FROM DWNTIM TABLE
1)		GTB .DWNTI
1)		JUMPE A,R		;DO NOTHING IF NOT SET
1)		CAMN A,[-1]		;IS SYSTEM SHUT DOWN?
1)		JRST [ETYPE < System is shut down>
1)		      JRST DWNTY2]
1)		ETYPE < System shutdown scheduled for %1W>

; SRC:<6-EXEC>EXECSU.MAC.19 & EXECSU.MAC.1 26-Jul-85 0102	PAGE 48


LINE 17, PAGE 41
2)	DWNTYP::MOVE A,CUSRNO		;CM224
2)		JUMPN A,R		;NO TYPE IF ALREADY LOGGED IN
2)	DWNPNT::MOVEI D,0		;GET ITEM 0 FROM DWNTIM TABLE
2)		GTB .DWNTI
2)		JUMPE A,R		;DO NOTHING IF NOT SET
2)		CAMN A,[-1]		;IS SYSTEM SHUTDOWN
2)		JRST [	ETYPE < System is shutdown>
2)			JRST DWNTY2]	;YES, SAY SO
2)		ETYPE < System shutdown scheduled for %1W>


LINE 34, PAGE 41
1)	>;IFE STANSW
1)	IFN STANSW,<
1)	DWNPNT::STKVAR <<DWNSTR,21>,DWNX>
1)		MOVEI D,0		;GET ITEM 0 FROM DWNTIM TABLE
1)		GTB .DWNTI
1)		IFN. A			;DOWNTIME SET IF NON-ZERO...
1)		  IFL. A		;SYSTEM DOWN IF .LT. 0...
1)		    TYPE <The system is down>
1)		  ELSE.
1)		    IFE NICSW,<		;[NIC1050] WANT ALL DOWNTIMES PRINTED
1)		    MOVE B,A		;MOVE DOWN DATE AND TIME TO 2
1)		    GTAD%		;GET TIME/DATE NOW IN A
1)		    SUBM B,A		;CHECK DIFFERENCE IN # OF DAYS
1)		    CAMLE A,[2,,0]	;DON'T PRINT IF MORE THAN 2 DAYS
1)		     RET
1)		    MOVE A,B		;GET DOWNTIME BACK
1)		    >; IFE NICSW
1)		    ODCNV%
1)		    LSH B,11		;SO EACH VALUE GETS A 9 BIT FIELD
1)		    ADD B,C		;UNIQUE FOR DATE
1)		    MOVE Q2,B		;SAVE DOWNTIME REP THIS WAY
1)		    SETO B,		;TODAY
1)		    SETZ D,
1)		    ODCNV%
1)		    LSH B,11		;SO EACH VALUE GETS A 9 BIT FIELD
1)		    ADD B,C		;UNIQUE FOR DATE
1)		    CAMN B,Q2
1)		    IFSKP.
1)		      ETYPE < The system will go down %1W>
1)		    ELSE.
1)		      ETYPE < The system will go down today at %1E>
1)		    ENDIF.
1)		  ENDIF.
1)		  MOVEI D,1		;GET ITEM 1
1)		  GTB .DWNTI
1)		  IFN. A		;IF UPTIME SET...
1)		    MOVE B,A		;MOVE UP DATE AND TIME TO 2
1)		    SETZ D,		;MUST BE 0

; SRC:<6-EXEC>EXECSU.MAC.19 & EXECSU.MAC.1 26-Jul-85 0102	PAGE 49


1)		    ODCNV%
1)		    LSH B,11		;SO EACH VALUE GETS A 9 BIT FIELD
1)		    ADD B,3		;UNIQUE FOR DATE
1)		    CAME B,Q2		;IF SAME DAY...
1)		    IFSKP.
1)		      ETYPE < until %1E>	;JUST DO TIME
1)		    ELSE.
1)		      ETYPE < until %1W>	;DO DAY, DATE AND TIME
1)		    ENDIF.
1)		  ENDIF.
1)		  ETYPE <%_ for >
1)		  MOVEI C,DWNSTR
1)		  MOVE D,[-20,,2]	;20 WORDS OF STRING STARTING AT WORD 2
1)		  DO.
1)		    GTB .DWNTI		;GET IT
1)		    MOVEM A,(C)		;STORE IT
1)		    ADDI C,1		;NEXT WORD IN TABLE
1)		    TRNE A,376		;IS RIGHTMOST BYTE = 0?
1)		     AOBJN D,TOP.	;NO -- LOOP
1)		  ENDDO.
1)		  UTYPE DWNSTR
1)		  ETYPE <%_>		;NEXT LINE
1)		ENDIF.
1)		RET
1)	>;IFN STANSW
1)	^L
LINE 1, PAGE 42
2)	^L


LINE 92, PAGE 42
1)		 ERROR <String space exhausted>
1)		RET
1)	
LINE 92, PAGE 43
2)		 SKIPA			;{C302}
2)		RET
2)		BUG			;{C302} take a dump before complaining
2)		 ERROR <String space exhausted>	;{C302}
2)	
2)	


; SRC:<6-EXEC>EXECSU.MAC.19 & EXECSU.MAC.1 26-Jul-85 0102	PAGE 50



LINE 102, PAGE 42
1)		MOVEM A,RPTR		;REMEMBER POINTER
LINE 105, PAGE 43
2)		CALL FIXPT		;CM224 Make real pointer
2)		MOVEM A,RPTR		;REMEMBER POINTER


LINE 112, PAGE 42
1)		MOVEI C,0		;STORE NULL AT END OF STRING
1)		SOUT			;COPY THE STRING
1)		MOVE A,NEWPTR		;GET ADDRESS WHERE STRING GOT PUT
LINE 116, PAGE 43
2)		ILDB C,B		;CM224 Copy string
2)		IDPB C,A		;CM244
2)		JUMPN C,.-2		;CM224
2)		MOVE A,NEWPTR		;GET ADDRESS WHERE STRING GOT PUT


LINE 142, PAGE 42
1)	GETM3:	CALL PIOFF		;TURN OFF CONTROL-C INTERRUPTS
1)		HRL B,0(B)		;GET LINK OF CURRENT BLOCK
LINE 147, PAGE 43
2)	GETM3:	CALL PIOFF		;TURN OFF CTRL/C INTERRUPTS
2)		HRL B,0(B)		;GET LINK OF CURRENT BLOCK


LINE 154, PAGE 42
1)	GETRSK:	CALL PION		;TURN CONTROL-C INTERRUPTS BACK ON
1)		RETSKP			;SUCCESS, SKIP RETURN
LINE 159, PAGE 43
2)	GETRSK:	CALL PION		;TURN CTRL/C INTERRUPTS BACK ON
2)		RETSKP			;SUCCESS, SKIP RETURN


LINE 193, PAGE 42
1)	RETM4:	CALL PIOFF		;TURN OFF CONTROL-C INTERRUPTS
1)		HRRM D,0(B)		;FORWARD PTR OF RETURNED BLOCK
LINE 198, PAGE 43
2)	RETM4:	CALL PIOFF		;TURN OFF CTRL/C INTERRUPTS
2)		HRRM D,0(B)		;FORWARD PTR OF RETURNED BLOCK


; SRC:<6-EXEC>EXECSU.MAC.19 & EXECSU.MAC.1 26-Jul-85 0102	PAGE 51



LINE 210, PAGE 42
1)		CALLRET PION		;NO, RETURN WITH NO COMBINATION
1)		HRRM D,0(C)		;MAKE PREV POINT TO OUR NEXT
LINE 215, PAGE 43
2)		CALLRE PION		;NO, RETURN WITH NO COMBINATION
2)		HRRM D,0(C)		;MAKE PREV POINT TO OUR NEXT


LINE 216, PAGE 42
1)		CALLRET PION		;RETURN
1)	
LINE 221, PAGE 43
2)		CALLRE PION		;RETURN
2)	


LINE 269, PAGE 42
1)		MOVE C,CSBUFP		;REMEMBER POINTER TO NAME
1)		NODE			;GET THE NAME
LINE 274, PAGE 43
2)		MOVE C,CSBUFP		;REMEMER POINTER TO NAME
2)		NODE			;GET THE NAME


LINE 6, PAGE 43
1)		MOVEI C,0		;SAY NO ECHOING NOHOW
LINE 6, PAGE 44
2)		SETOM PWDFLG		;CM236 Tell error routines not to echo this
2)					; line (probably contains a password!)
2)		MOVEI C,0		;SAY NO ECHOING NOHOW


LINE 23, PAGE 44
1)		GJINF			;GET JOB INFO
1)		JUMPL D,NOTTY1		;SEE IF WE ARE DETACHED
1)		MOVEI A,.CTTRM		;HAVE TERMINAL, USE CONTROLLING TTY
1)		DVCHR			;MTOPR WORKS ON TTY ONLY
LINE 23, PAGE 45
2)		DVCHR			;MTOPR WORKS ON TTY ONLY


; SRC:<6-EXEC>EXECSU.MAC.19 & EXECSU.MAC.1 26-Jul-85 0102	PAGE 52



LINE 42, PAGE 44
1)		MOVEI A,.FHSLF
1)		RPCAP
1)		TXON	C,SC%CTC	;CAN'T SET JOB TIW IF NO ^C PRIV
1)		JRST [	TXNN B,SC%CTC	;^C NOT ENABLED.  ENABLABLE?
1)			JRST NOSTIW	;NO, DON'T TRY THE STIW
1)			EPCAP		;ENABLABLE, SO DO IT
LINE 39, PAGE 45
2)		DMOVE B,EXECAP		;CM224 get current capabilities
2)		TXON	C,SC%CTC	;CAN'T SET JOB TIW IF NO ^C PRIV
2)		JRST [	TXNN B,SC%CTC	;^C NOT ENABLED.  ENABLABLE?
2)			JRST NOSTIW	;NO, DON'T TRY THE STIW
2)			MOVEM C,EXECAP+1 ;CM224
2)			MOVEI A,.FHSLF	;CM224
2)			EPCAP		;ENABLABLE, SO DO IT


LINE 68, PAGE 44
1)		GJINF			;GET JOB INFO
1)		JUMPL D,NOTTY2		;SEE IF WE ARE DETACHED
1)		MOVEI A,.CTTRM		;HAVE TERMINAL, USE CONTROLLING TTY
1)		DVCHR			;MTOPR WORKS ON TTY ONLY
LINE 66, PAGE 45
2)		DVCHR			;MTOPR WORKS ON TTY ONLY


LINE 32, PAGE 47
1)		JRST NOX		;NO, SAY PAGE NONEXISTENT
1)		TDNN A,[777776,,777760]	;SECTION 0 OR 1, ADDRS 0-17 ARE ACS
LINE 32, PAGE 48
2)		ERROR <No program>	;NO.
2)		TDNN A,[777776,,777760]	;SECTION 0 OR 1, ADDRS 0-17 ARE ACS


LINE 44, PAGE 47
1)		 ERJMP NOX		;CAN'T MAP-- JUST SAY DOESN'T EXIST
1)		MOVEM A,NPAGE		;SAY IT'S MAPPED
1)		CAMN A,[-1]
1)		JRST	MPPF8
1)		RPACS			;GET ACCESS/EXISTENCE OF MAPPED PAGE
1)		ERJMP NOX		;SECTION CONTAINING PAGE DOESN'T EXIST
1)		JUMPN B,MPPF8		;ANY BITS?
1)		TXO B,PA%WT		;NO - SET WRITE ACCESS (NEW PAGE)
1)		JRST MPPF8		;RESTORE AND RETURN +2
1)	
1)	NOX:	SETZ B,			;SECTION CONTAINING PAGE DOESN'T EXIST
1)		JRST MPPF8		;JUST SAY PAGE CAN'T BE USED
1)	
LINE 44, PAGE 48

; SRC:<6-EXEC>EXECSU.MAC.19 & EXECSU.MAC.1 26-Jul-85 0102	PAGE 53


2)		 ERJMP MAPPFF		;CAN'T MAP-- RETURN +1
2)		MOVEM A,NPAGE		;SAY ITS MAPPED
2)		CAMN A,[-1]
2)		JRST	MPPF8
2)		RPACS			;GET ACCESS/EXISTENCE OF MAPPED PAGE
2)		ERJMP [	SETZ B,		;SECTION CONTAINING PAGE DOESN'T EXIST
2)			JRST MPPF8]	;JUST SAY PAGE CAN'T BE USED
2)		SKIPN	B		;ANY BITS?
2)		TXO	B,PA%WT		;NO - SET WRITE ACCESS (NEW PAGE)
2)		JRST MPPF8		;RESTORE AND RETURN +2
2)	


LINE 3, PAGE 48
1)	;SUBROUTINE TO DO A "GETAB" JSYS WITH A REASONABLE CALLING SEQUENCE.
1)	;TABLE # IN AC A, INDEX IN RH OF D, RETURN +1 WITH WORD IN A.
1)	;TYPICAL USAGE: LH D CONTAINS AOBJN COUNTER, B AND C ARE FREE
1)	;	FOR USE IN OTHER JSYS CALLS INSIDE LOOP.
1)	
1)	%GTB:	HRL A,D			;PUT THE INDEX IN WITH THE TABLE NUMBER
1)		GETAB			;AS FOR THE VALUE
1)		 SETZ A,		;ERROR - RETURN ZERO AS THE VALUE
1)		RET
LINE 3, PAGE 49
2)	;UUO TO DO A "GETAB" JSYS WITH A REASONABLE CALLING SEQUENCE.
2)	;TABLE # IN C(Q1), INDEX IN RH OF D, ONE RETURN WITH WORD IN A.
2)	;TYPICAL USAGE: LH D CONTAINS AOBJN COUNTER, B AND C ARE FREE
2)	;	FOR USE IN OTHER JSYS CALLS INSIDE LOOP.
2)	
2)	%GTB:	HRL A,D
2)		HRR A,40
2)		GETAB
2)		 CALL JERR
2)		RET


LINE 18, PAGE 48
1)		CALL USEX		;DO THE WORK
LINE 19, PAGE 49
2)	CS,<	SKIPE FOOFLG		;CS118 this crud?
2)		 JRST USEPS1##>		;CS118 Yes...
2)		CALL USEX		;DO THE WORK


; SRC:<6-EXEC>EXECSU.MAC.19 & EXECSU.MAC.1 26-Jul-85 0102	PAGE 54



LINE 34, PAGE 48
1)	IFN STANSW,<
1)		SKIPL PCCIPF		;CM156 PCL command in progress or
1)	>;IFN STANSW
1)		SKIPE CIPF		;COMMAND IN PROGRESS?
1)		JRST USEPS9		;YES, DIFFERENT MESSAGE
1)		SKIPLE EFORK		;EPHERMERAL?
LINE 37, PAGE 49
2)	;EM64	SKIPL PCCIPF		;CM156 PCL command in progress or
2)	;EM64	SKIPE CIPF		;COMMAND IN PROGRESS?
2)	;EM64	JRST USEPS9		;YES, DIFFERENT MESSAGE
2)		SKIPLE EFORK		;EPHERMERAL?


LINE 45, PAGE 48
1)		JRST USEPS2		;NO INFERIOR
1)		SKIPN B,SLFTAB(A)	;LOAD B WITH FORK TABLE INDEX
1)		 JRST USEPS0		;IF 0, WE DON'T KNOW THIS PROGRAM
1)		GETNM
1)		CAMN A,['EXEC  ']	;IS CURRENT PROG NAME EXEC?
1)		MOVE A,.FKPTM+TTWPNM(B)	;YES, GET NAME FROM TABLE
1)		ETYPE < %1'>		;NO, JUST TYPE WHAT GETNM FOUND
1)		MOVE A,FORK
1)	USEPS0:	TYPE < >		;SEPARATE NAME AND STATUS
1)		CALL FSTAT		;PRINT STATUS & PC OF INFERIOR (HANDLE IN A)
1)		PRINT " "		;FSTAT IS IN EXECIN.MAC
1)	USEPS2:	HRROI A,-1		;GET LOAD AVERAGES FOR CURRENT JOB
1)		CALL GLOADS		;GET LOAD AVERAGES
1)		ETYPE < Used %V in %C, Load %2Q>
1)		CALL USEPSM		;IF MIC EXISTS, SAY A DO IS PROGRESS (EXECCA)
1)	
1)	USEOU1: TYPE <
LINE 46, PAGE 49
2)	;EM24 Remove conditionals
2)		IFNSK.			;CM290
2)		  ETYPE < Exec>		;CM290
2)		  MOVEI A,.FHSLF	;CM290 Talk about us
2)		  JRST USEPS0		;CM290
2)		ENDIF.			;CM290
2)	;**;[737] Insert 2 lines at USEX:+21L	KR	2-JUN-82
2)		SKIPN B,SLFTAB(A)	;[737]LOAD B WITH FORK TABLE INDEX
2)		JRST USEPS0		;[737]IF 0,WE DON'T KNOW THIS PROG
2)	;**;[734]	Replace 4 lines with 3 at USEX:+21L	KR	12-MAY-1982
2)		GETNM			;[734]
2)	;**;[737] Insert 2 lines at USEX:+22L	KR	2-JUN-82
2)		CAME A,['EXEC  ']	;EM127 [737]IS CURRENT PROG NAME EXEC?
2)		 CAMN A,['CMEXEC']	;EM127 Or maybe Cmexec?
2)		  MOVE A,.FKPTM+TTWPNM(B) ;EM127 [737]YES, GET LAST RUN PROG'S NAME 
2)		ETYPE < %1'>		;[734]NO, JUST TYPE WHAT GETNM FOUND

; SRC:<6-EXEC>EXECSU.MAC.19 & EXECSU.MAC.1 26-Jul-85 0102	PAGE 55


2)		MOVE A,FORK		;[734]
2)	USEPS0:	TYPE < >		;SEPARATE NAME AND STATUS
2)		CALL FSTAT		;PRINT STATUS & PC OF INFERIOR (HANDLE IN A)
2)	CC,<	PRINT " ">		;CS44 FSTAT IS IN EXECIN.MAC
2)	USEPS2:	HRROI A,-1		;GET LOAD AVERAGES FOR CURRENT JOB
2)		CALL GLOADS		;GET LOAD AVERAGES
2)		ETYPE < Used %V in %C, Load %2Q>
2)	MIC,<	CALL GETPAG		;MIC EXISTS?
2)		  JRST USEOU1		;NO
2)		TYPE < (DO in progress)>
2)	>
2)	USEOU1: TYPE <


LINE 76, PAGE 48
1)		JRST [	SKIPN B		;PCL Yes, is the command name gone?
1)			HRROI B,[ASCIZ/Stored/]	;PCL Yes, use generic name
1)			JRST .+1]	;PCL
1)		ETYPE < %2M command >
1)		JRST USEPS2		;JOIN COMMON CODE
1)	^L
LINE 88, PAGE 49
2)		JRST [	SKIPN B,PCLNAM	;PCL Yes, is the command name gone?
2)			HRROI B,[ASCIZ/Stored/]	;PCL Yes, use generic name
2)			JRST .+1]	;PCL
2)		ETYPE < %2M command >
2)		JRST USEPS2		;CS44 JOIN COMMON CODE
2)	^L


LINE 21, PAGE 49
1)		SKIPN CMCNT		;ROOM FOR ONE MORE CHARACTER?
1)		JRST CMERR2		;NO, FORGET IT
1)		MOVE A,CMINC		;GET NUMBER OF UNPARSED CHARACTERS
LINE 21, PAGE 50
2)		MOVE A,CMCNT		;CM236 Get count of space left
2)		SOSGE A			;CM236 Room for two more characters?
2)		JRST CMERR2		;NO, FORGET IT
2)		SKIPE PWDFLG		;CM236 Parsing a password line?
2)		JRST CMERR2		;CM236 Yes, don't type out token
2)		MOVE A,CMINC		;GET NUMBER OF UNPARSED CHARACTERS


; SRC:<6-EXEC>EXECSU.MAC.19 & EXECSU.MAC.1 26-Jul-85 0102	PAGE 56



LINE 27, PAGE 49
1)		SOS CMCNT		;REMEMBER THERE'S ROOM FOR ONE LESS CHARACTER
1)		AOS CMINC		;REMEMBER THERE'S ONE MORE UNPARSED CHARACTER
1)		MOVEI B,[FLDDB. .CMTXT]	;READ REST OF LINE INTO ATOM BUFFER
1)		CALL FLDSKP
1)		 JRST CMERR2		;IF THAT FAILS, HANG IT UP.
1)		MOVE D,[440700,,ATMBUF]	;POINT TO STRING WHICH IS REST OF LINE
LINE 30, PAGE 50
2)		SETZ B,			;CM236 Load a null
2)		IDPB B,A		;CM236 Make sure there's a null at the end
2)		MOVE B,[POINT 7,ATMBUF] ;CM236 Get pointer to atom buffer
2)		SKIPN D,CMINC		;CM236 Any unparsed characters?
2)		IFSKP.			;CM236 Yes
2)		  CAILE D,<<ATMLEN*5>-1> ;CM236 Will they all fit in atom buffer?
2)		   MOVX D,<<ATMLEN*5>-1> ;CM236 No, truncate rather than trashing Exec
2)		  MOVE A,CMPTR		;CM236 Get pointer to rest of command
2)		  DO.			;CM236
2)		    SOJL D,ENDLP.	;CM236 Done if count exceeded
2)		    ILDB C,A		;CM236 Copy unparsed characters to the atom
2)		    CAIE C,.CHCNV	;CM236 ^V?
2)		    IFSKP.		;CM236
2)		      SOJL D,ENDLP.	;CM236 Yes, decrement count
2)		      ILDB C,A		;CM236 Slurp quoted character
2)		      IDPB C,B		;CM236 Stick it in atom buffer
2)		      LOOP.		;CM236 Read another character
2)		    ENDIF.		;CM236
2)		    CAIE C,.CHCRT	;CM236 EOL?
2)		     CAIN C,.CHLFD	;CM236 ...
2)		      JRST ENDLP.	;CM236 Yes, we're done
2)		    CAIE C,.CHESC	;CM236 Recognition character?
2)		     CAIN C,.CHCNF	;CM236 ...
2)		      JRST ENDLP.	;CM236 Yes, we're done
2)		    CAIN C,"?"		;CM236 Help character?
2)		     JRST ENDLP.	;CM236 Yes, done
2)		    IDPB C,B		;CM236 No, regular character.  Stick in atom
2)					; buffer
2)		    JUMPN C,TOP.	;CM236 Terminate on null
2)		  OD.			;CM236
2)		ENDIF.			;CM236
2)		SETZ C,			;CM236 Null-terminate
2)		IDPB C,B		;CM236  the atom buffer
2)		MOVE D,[440700,,ATMBUF]	;POINT TO STRING WHICH IS REST OF LINE


; SRC:<6-EXEC>EXECSU.MAC.19 & EXECSU.MAC.1 26-Jul-85 0102	PAGE 57



LINE 57, PAGE 49
1)	;NOT IMPLEMENTED YET ERROR
LINE 88, PAGE 50
2)	
2)	;NOT IMPLEMENTED YET ERROR


LINE 68, PAGE 49
1)		ERROR <Internal error at %5P>
LINE 100, PAGE 50
2)		BUG			;CM302 Take a dump
2)		ERROR <Internal error at %5P>


LINE 86, PAGE 49
1)	IFE STANSW,<
1)		ETYPE <JSYS error at %6Y>
1)	>;IFE STANSW
1)	IFN STANSW,<
1)		MOVE A,Q2
1)		CALL LOADF		;GET CONTENTS OF PC
1)		 MOVSI A,(<JSYS>)	;FAILED FOR SOME REASON
1)		PUSH P,SYMF
1)		SETOM SYMF		;ALWAYS USE SYMBOLIC TYPEOUT FOR THIS ONE
1)		ETYPE <Internal EXEC %1/ error at %6Y>
1)		POP P,SYMF
1)	>;IFN STANSW
1)		EXCH A,FORK		;RESTORE FORK CELL
LINE 119, PAGE 50
2)		ETYPE <JSYS error at %6Y>
2)		EXCH A,FORK		;RESTORE FORK CELL


LINE 17, PAGE 51
1)	ILIPSI:	MOVE A,[CALL CUUO]	;RESET UUO DISPATCH TO PROTECT
1)		MOVEM A,41		; IT FROM MALICIOUS USERS (AND IF TRASHED)
1)		SKIPE ILIDSP		;IS THERE A SPECIAL DISPATCH?
1)		JRST ILIDO		;YES, DO IT
1)		STKVAR <ILCOD>
LINE 17, PAGE 52
2)	ILIPSI:	MOVEM A,BUGACS+A	;CM302 Don't trash A
2)		MOVE A,[CALL CUUO]	;RESET UUO DISPATCH TO PROTECT
2)		MOVEM A,41		;IT FROM MALICIOUS USERS (AND IF TRASHED)
2)		SKIPE ILIDSP		;IS THERE A SPECIAL DISPATCH?
2)		JRST ILIDO		;YES, DO IT
2)		MOVE A,BUGACS+A		;CM302 Get back saved A
2)		BUG			;CM302 Take a dump
2)		STKVAR <ILCOD>


; SRC:<6-EXEC>EXECSU.MAC.19 & EXECSU.MAC.1 26-Jul-85 0102	PAGE 58



LINE 25, PAGE 51
1)		HRRZ A,LV.ILI+PCTAB	;GET PC OF ERROR
LINE 28, PAGE 52
2)		MOVX A,.FHSLF		;CM224 Get true capabilities again
2)		RPCAP%			;CM224
2)		DMOVEM B,EXECAP		;CM224 Save them in case they were clobbered
2)		HRRZ A,LV.ILI+PCTAB	;GET PC OF ERROR


LINE 56, PAGE 51
1)		CAIE A,IOX4		;END OF FILE?
1)		CALL CJERRE		;NO, TREAT AS UNEXPECTED ERROR
1)	IFN STANSW,<
1)		SKIPN PCCURC		;CM156 Unless in a PCL
1)	>;IFN STANSW
1)		CALL CMDINI		;RE-INIT COMMAND, TO PROTECT OURSELF
1)		POP P,(P)		;THROW AWAY THE CALL TO THIS ROUTINE
LINE 62, PAGE 52
2)		CAIE A,COMX12		;CM236 Damaged CSB?
2)		CAIN A,COMX13		;CM236
2)		JRST [	BUG		;CM236 Take a dump
2)			PUSH P,A	;CM236 Save the error code
2)			CALL CMDINI	;CM236 Re-init COMND%
2)			POP P,A		;CM236 Restore error code
2)			JRST .+1]	;CM236
2)		CAIE A,IOX4		;END OF FILE?
2)	;** Why are the next two lines here??? - PA0B
2)		CAIN A,COMNX9		;CM224 Or EOF in COMND?
2)		TRNA			;CM224
2)		CALL CJERR		;CM236 NO, TREAT AS UNEXPECTED ERROR
2)		SKIPN PCCURC		;CM156 Unless in a PCL
2)		CALL CMDINI		;RE-INIT COMND, TO PROTECT OURSELF
2)		POP P,(P)		;THROW AWAY THE CALL TO THIS ROUTINE


LINE 67, PAGE 51
1)	EOFCHK:	SKIPN EOFDSP
1)		TRAP LV.EOF,<Unexpected end-of-file> ;NO SPEC DISPATCH, TREAT AS ERROR
LINE 81, PAGE 52
2)	EOFCHK:	MOVEI A,.PRIIN		;CM224 Check for EOF in primary input
2)		PUSH P,B		;CM224
2)		GTSTS%			;CM224
2)		TXNE B,GS%EOF		;CM224 EOF?
2)		JRST [	HALTF%		;CM224 Die
2)			JRST .-1]	;CM224 Forever
2)		POP P,B			;CM224
2)		SKIPN EOFDSP		;CM224
2)		TRAP LV.EOF,<Unexpected end-of-file> ;NO SPEC DISPATCH, TREAT AS ERROR


; SRC:<6-EXEC>EXECSU.MAC.19 & EXECSU.MAC.1 26-Jul-85 0102	PAGE 59



LINE 41, PAGE 53
1)		MOVEI A,.PRIOU
1)		RFMOD			;GET PRESENT TTY MODES
LINE 41, PAGE 54
2)		MOVX A,.PRIOU		;CM288 SPR #18606
2)		RFMOD			;GET PRESENT TTY MODES


LINE 10, PAGE 54
1)		TSO B,B			;IN EITHER USER OR MONITOR CONTEXT.
1)		JFFO B,GETL1		;FIGURE OUT HIGHEST LEVEL IN PROGRESS
LINE 10, PAGE 55
2)	;**;[723] Add 1 line at GETLPC:+2L	JRG	8-APR-82
2)		TSO B,B			;[723] IN EITHER USER OR MONITOR CONTEXT
2)		JFFO B,GETL1		;FIGURE OUT HIGHEST LEVEL IN PROGRESS


LINE 61, PAGE 54
1)	IFN STANSW,<
1)		  ERJMP .+1		; IGNORE ERRORS HERE
1)	>;IFN STANSW
1)		TLNN Z,RUNF		;PROGRAM RUNNING?
LINE 62, PAGE 55
2)		TLNN Z,RUNF		;PROGRAM RUNNING?


LINE 74, PAGE 54
1)	IFE STANSW,<
1)		ERCAL	[TYPE <% Process disappeared>
1)			 ETYPE<%_>
1)			 RET]
1)	>;IFE STANSW
1)	IFN STANSW,<
1)		ERJMP .+1		;FLUSH ANNOYING MESSAGE
1)	>;IFN STANSW
1)		MOVX Q1,FK%INT		;MARK INTERRUPTED
1)		SKIPE SLFTAB(A)
1)		IORM Q1,SLFTAB(A)
1)	IFE STANSW,<
1)		SKIPN PCPRGR		;PCL If not controlled by PCL
1)	>;IFE STANSW
1)	IFN STANSW,<
1)		TMNN FK%INV,SLFTAB(A)	;CM156 If not controlled by PCL
1)	>;IFN STANSW
1)		CALL RFTYMD		;READ FORK'S MODES
1)		TLZ Z,RUNF		;DON'T DO TTY MODES ON 2ND ^C!
1)	CCDB3:	MOVEI Q1,ETTYMD		;CM236 SPR 14601
1)	IFE STANSW,<
1)		SKIPN PCPRGR		;PCL If not controlled by PCL

; SRC:<6-EXEC>EXECSU.MAC.19 & EXECSU.MAC.1 26-Jul-85 0102	PAGE 60


1)	>;IFE STANSW
1)	IFN STANSW,<
1)		TMNN FK%INV,SLFTAB(A)	;CM156 If not controlled by PCL
1)	>;IFN STANSW
1)		CALL LTTYMD		;SET UP OUR MODES, PROGRAM MAY HAVE CAUSED STRANGE STATE.
1)		MOVE A,COJFN		;CM236 SPR 14601
LINE 72, PAGE 55
2)		ERCAL	[TYPE <% Process disappeared>
2)			 ETYPE<%_>
2)			 RET]
2)		MOVX Q1,FK%INT		;MARK INTERRUPTED
2)		SKIPE SLFTAB(A)
2)		IORM Q1,SLFTAB(A)
2)		TMNN FK%INV,SLFTAB(A)	;CM156 If not controlled by PCL
2)		CALL RFTYMD		;READ FORK'S MODES
2)		TLZ Z,RUNF		;DON'T DO TTY MODES ON 2ND ^C!
2)	CCDB3:	MOVEI Q1,ETTYMD		;CM236 SPR 14601
2)		SKIPG A,FORK		;CM156 Do we have a fork?
2)		IFSKP.			;CM156
2)		  TMNN FK%INV,SLFTAB(A)	;CM156 Yes.  Is it INVOKE'd?
2)		   CALL LTTYMD		;CM156 No, load tty modes
2)		ELSE.			;CM156
2)		  CALL LTTYMD		;CM156 If no fork, always load tty modes
2)		ENDIF.			;CM156
2)		MOVE A,COJFN		;CM236 SPR 14601


LINE 118, PAGE 54
1)	IFN STANSW,<
1)		SKIPE QTADSP		;CM156 Do we seem initialized?
1)		SETOM CINITF		;CM156 Yes, allow for ^C in Save/Exec
1)	>;IFN STANSW
1)		SKIPE MPENDF		;WARN IF ^C OUT OF MOUNT
LINE 106, PAGE 55
2)		SKIPE QTADSP		;CM156 Do we seem initialized?
2)		SETOM CINITF		;CM156 Yes, allow for ^C in Save/Exec
2)		SKIPE MPENDF		;WARN IF ^C OUT OF MOUNT


LINE 17, PAGE 55
1)	IFN STANSW,<
1)		 ERJMP .+1		;IGNORE ERROR HERE
1)	>;IFN STANSW
1)		MOVX Q1,FK%INT		;MARK INTERRUPTED
1)		SKIPE SLFTAB(A)
1)		IORM Q1,SLFTAB(A)
1)	IFE STANSW,<
1)		SKIPN PCPRGR		;PCL If not controlled by PCL
1)	>;IFE STANSW
1)	IFN STANSW,<
1)		TMNN FK%INV,SLFTAB(A)	;CM156 If not controlled by PCL

; SRC:<6-EXEC>EXECSU.MAC.19 & EXECSU.MAC.1 26-Jul-85 0102	PAGE 61


1)	>;IFN STANSW
1)		CALL RFTYMD		;READ FORK'S MODES
1)		TLZ Z,RUNF		;DON'T DO TTY MODES ON 2ND ^C!
1)	TLMPS1:	MOVEI Q1,ETTYMD		;PUT EXEC'S TTY MODES INTO EFFECT.
1)	IFE STANSW,<
1)		SKIPN PCPRGR		;PCL If not controlled by PCL
1)	>;IFE STANSW
1)	IFN STANSW,<
1)		TMNN FK%INV,SLFTAB(A)	;CM156 If not controlled by PCL
1)	>;IFN STANSW
1)		CALL LTTYMD		;MUST ALWAYS BE DONE: EG GTJFN LEAVES THEM BAD.
LINE 17, PAGE 56
2)		MOVX Q1,FK%INT		;MARK INTERRUPTED
2)		SKIPE SLFTAB(A)
2)		IORM Q1,SLFTAB(A)
2)	;	SKIPN PCPRGR		;PCL If not controlled by PCL
2)		TMNN FK%INV,SLFTAB(A)	;CM156 If not controlled by PCL
2)		CALL RFTYMD		;READ FORK'S MODES
2)		TLZ Z,RUNF		;DON'T DO TTY MODES ON 2ND ^C!
2)	TLMPS1:	MOVEI Q1,ETTYMD		;PUT EXEC'S TTY MODES INTO EFFECT.
2)	;	SKIPN PCPRGR		;PCL If not controlled by PCL
2)		TMNN FK%INV,SLFTAB(A)	;CM156 If not controlled by PCL
2)		CALL LTTYMD		;MUST ALWAYS BE DONE: EG GTJFN LEAVES THEM BAD.


LINE 6, PAGE 56
1)	ALOPSI:	PUSH P,[[DEBRK]]	;FAKE UP RETURN
1)		ATSAVE
LINE 6, PAGE 57
2)	ALOPSI:	PUSH P,CX		;CS127 Don't trash CX in interrupt routine
2)		PUSH P,[[POP P,CX	;CS127
2)			 DEBRK]]	;FAKE UP RETURN
2)		ATSAVE


LINE 43, PAGE 56
1)		MOVE A,COJFN
1)		DOBE			;MAKE SURE IT ALL TYPES (NEEDED?)
1)	AUTOL6:	SETO A,			;SAY SELF
LINE 45, PAGE 57
2)	;CM236	MOVE A,COJFN
2)	;CM236	DOBE			;MAKE SURE IT ALL TYPES (NEEDED?)
2)	AUTOL6:	SETO A,			;SAY SELF


; SRC:<6-EXEC>EXECSU.MAC.19 & EXECSU.MAC.1 26-Jul-85 0102	PAGE 62



LINE 9, PAGE 57
1)	IFN STANSW,<
1)		PUSH P,A		;CM156 Save an AC to play with
LINE 9, PAGE 58
2)		PUSH P,A		;CM156 Save an AC to play with


LINE 17, PAGE 57
1)	>;IFN STANSW
1)		CALL ERRX		;PRINT ERROR MESSAGE
LINE 16, PAGE 58
2)		CALL ERRX		;PRINT ERROR MESSAGE


LINE 25, PAGE 57
1)	IFN STANSW,<
1)		PUSH P,A		;CM156 Save an AC to play with
LINE 23, PAGE 58
2)		PUSH P,A		;CM156 Save an AC to play with


LINE 36, PAGE 57
1)	>;IFN STANSW
1)		CALL ERRX		;PRINT ERROR MESSAGE
LINE 33, PAGE 58
2)		CALL ERRX		;PRINT ERROR MESSAGE


LINE 20, PAGE 58
1)	IFE STANSW,<
1)		SKIPLE A,EFORK		;SPECIAL FORK?
1)		 KFORK			;YES - KILL IT
1)		SETOM EFORK		;NO MORE
1)	>;IFE STANSW
1)	IFN STANSW,<
1)		SKIPG A,EFORK		;EPHEMERAL FORK AROUND?
1)		IFSKP.			;YES.
1)		 SETOM EFORK		;MAKE SURE WE THINK IT IS GONE
1)		 KFORK
1)		ENDIF.
1)	>;IFN STANSW
1)		BTCHER			;SHOULD STOP NON-CONVERSATIONAL JOB
LINE 20, PAGE 59
2)		SKIPLE A,EFORK		;SPECIAL FORK?
2)		JRST [	CALL RELIO	;CM224 Yes, release primary JFN's if necessary
2)			KFORK%		;CM224 Kill it
2)			JRST .+1]	;CM224 And continue
2)		SETOM EFORK		;NO MORE
2)		BTCHER			;SHOULD STOP NON-CONVERSATIONAL JOB

; SRC:<6-EXEC>EXECSU.MAC.19 & EXECSU.MAC.1 26-Jul-85 0102	PAGE 63




LINE 38, PAGE 58
1)	
1)		SKIPE .PP		;DON'T RESET IF .PP NEVER SAVED
1)		MOVE .FP,.PP		;RESTORE .FP AS IT WAS BEFORE COMMAND.
1)		SKIPE .P		;DON'T RESET P IF NEVER SAVED!
1)		MOVE P,.P		;RESTORE P TO AS IT WAS BEFORE COMMAND
1)		SETZM ERRMF		;NO LONGER PROCESSING AN ERROR
LINE 31, PAGE 59
2)	;**;	[722]	Insert 2 lines at ERRFIN + 10	6-APR-82	KR
2)		SKIPE .PP		;[722]DON'T RESET IF .PP NEVER SAVED
2)		MOVE .FP,.PP		;[722]RESTORE .FP AS IT WAS BEFORE COMMAND
2)		SKIPE .P		;DON'T RESET P IF NEVER SAVED!
2)		MOVE P,.P		;RESTORE P TO AS IT WAS BEFORE COMMAND
2)		SKIPE PWDFLG		;CM236 Parsing sensitive data?
2)		 CALL CMDINI		;CM236 Yes, break ^H redisplay
2)		SETZM PWDFLG		;CM236 No longer parsing sensitive data
2)		SETZM ERRMF		;NO LONGER PROCESSING AN ERROR


LINE 8, PAGE 59
1)		MOVE A,[CZ%NIF+.FHSLF]
1)		SKIPE CLZFFF		;DO CLZFF IF POSSIBLE LOST JFN
LINE 8, PAGE 60
2)		MOVE A,[CZ%NIF+CZ%NCL+.FHSLF]
2)		SKIPE CLZFFF		;DO CLZFF IF POSSIBLE LOST JFN


LINE 31, PAGE 59
1)		CALL FIXIO		;MAKE SURE ERROR SEEN IN "REAL" OUTPUT STREAM
LINE 31, PAGE 60
2)		MOVE A,SBLOCK+.CMINC	;EM66
2)		ADJBP A,SBLOCK+.CMPTR	;EM66 Point to last character in buffer
2)		SETZ B,			;EM66
2)		IDPB B,A		;EM66 Make sure there's a null there
2)		CALL CSAVE		;EM66 Save the failed command
2)		CALL FIXIO		;MAKE SURE ERROR SEEN IN "REAL" OUTPUT STREAM


LINE 44, PAGE 59
1)			HALTF]
LINE 49, PAGE 60
2)			BUG		;CM302 Take a dump
2)			HALTF]


; SRC:<6-EXEC>EXECSU.MAC.19 & EXECSU.MAC.1 26-Jul-85 0102	PAGE 64



LINE 63, PAGE 59
1)		JRST [	CALL PCMPOP	;YES, ALWAYS FLUSH
1)			JRST ERFRS2]
1)		CALL UNTAKE		;UNWIND IF ERRORS NOT ALLOWED AT THIS LEVEL
1)	
1)	ERFRS2:	TLNN Z,F1		;DON'T CLEAR INBUF FOR ^U
1)		SKIPN CIDLYF		;REQUESTING DELAYED CFIBF?
1)		RET			;YES, DON'T DO IT NOW
LINE 69, PAGE 60
2)		JRST [	CALL LM		;CM156 Make sure we put error msg on new line
2)			CALL PCMPOP	;YES, ALWAYS FLUSH
2)			JRST ER2]
2)		CALL UNTAKE		;UNWIND IF ERRORS NOT ALLOWED AT THIS LEVEL
2)	ER2:
2)		TLNN Z,F1		;DON'T CLEAR INBUF FOR ^U
2)		SKIPE CIDLYF		;REQUESTING DELAYED CFIBF?
2)		RET			;YES, DON'T DO IT NOW


LINE 2, PAGE 60
1)	;BEGIN ERROR MESSAGE LINE.  DO CRLF IF NOT ALREADY AT LEFT MARGIN,
LINE 2, PAGE 61
2)	;CM302 *** Start ***
2)	; Create a dump if something terrible seems to have happened to the Exec.
2)	; Before doing the dump it save the Ac's in BUGACS and the interrupt
2)	; system's status in RWMSAV.  This routine does not (and should not) use
2)	; the stack or otherwise assume any sanity in the world around it!!!
2)	;
2)	; Call:
2)	;	(should only be called by the BUG macro)
2)	;	JRST CRSDMP
2)	; Returns:
2)	;	+1 Always
2)	;
2)	
2)	CRSDMP::MOVEM Z,DUMPPC		;save crash dump pc and flags
2)		SKIPE INDUMP		;Called recursively?
2)		HALTF%			;Yes, we must be in trouble
2)		SETOM INDUMP		;Say we are making a dump now
2)		MOVEM Z,BUGACS		;Save Z first
2)		MOVE Z,[1,,BUGACS+1]	;Set up to save the Ac's
2)		BLT Z,BUGACS+17		;Save them
2)		AOS A,DUMPCT		;One more dump
2)		CAILE A,4		;allow 4 dumps
2)		JRST [	DMOVE Z,BUGACS	;Yes, ignore it
2)			JRST @DUMPPC]
2)		MOVEI A,5		;set length of argument block
2)		MOVEM A,GTRLEN##
2)		MOVX A,.FHSLF		;get last page fail info

; SRC:<6-EXEC>EXECSU.MAC.19 & EXECSU.MAC.1 26-Jul-85 0102	PAGE 65


2)		MOVEI B,GTRLEN##
2)		XGTPW%
2)	
2)		MOVX A,.FHSLF
2)		RCM%			;see what channels are enabled
2)		MOVEM A,RCMWRD##
2)		MOVX A,.FHSLF		;make shure control-c is off
2)		MOVX B,1B1
2)		DIC%			;Turn off ^C channel (channel 1)
2)		 ERJMP .+1
2)		MOVX A,.FHSLF		;save last error
2)		GETER%			;Get the most recent jsys error
2)		 ERJMP [SETO B,		;Flag bad with impossible value
2)			JRST .+1]
2)		MOVEM B,LSTERR
2)	
2)		MOVX A,.FHSLF		;save state of interupt system
2)		SETZM PINTDF##		;assume interupts are on
2)		SKPIR%
2)		SOS PINTDF##		;they are off
2)		DIR%			;make shure dump process continues
2)	
2)		RWM%			;see what interupts are in progress
2)		 ERJMP	[SETOB A,B	;Flag that this happened with an unlikely value
2)			 JRST .+1]
2)		DMOVEM A,RWMMSK##	;save for reading in the dump
2)		MOVX A,.FHSLF		;Get current capabilities
2)		RPCAP%
2)		DMOVEM B,DMPCAP##	;Save them
2)		MOVX A,GJ%SHT!GJ%FOU!GJ%ACC
2)		HRROI B,DMPFIL		;Get a JFN on the file to write the crash
2)		GTJFN%			;  dump to
2)		 ERJMP DORET		;Failed, return
2)		MOVEM A,C		;Save the JFN
2)		HRLI A,.FHSLF		;Make .FHSLF,,jfn
2)		MOVE B,[-777,,SS%UCA]	;Save all assigned non-zero memory
2)		SSAVE%
2)		 ERJMP [MOVE A,C	;Get back the JFN
2)			RLJFN%		;Release it in case SAVE% didn't
2)			 JFCL
2)			JRST DORET ]	;And return
2)	DORET:	MOVX A,.FHSLF
2)		HRRZ B,LSTERR		;Get back last JSYS error code
2)		SETER%			;Restore it (in case failure in dump code
2)		 ERJMP .+1		; accidently changed it)
2)		EIR%			;Turn interrupts back on
2)		MOVX B,1B1		;control-c channel mask
2)		AND B,RCMWRD##		;turn back on if it was on
2)		SKIPE B
2)		AIC%			;Allow ^C's again
2)		DMOVE B,BUGACS+B

; SRC:<6-EXEC>EXECSU.MAC.19 & EXECSU.MAC.1 26-Jul-85 0102	PAGE 66


2)		DMOVE Z,BUGACS+Z
2)		MOVE 16,BUGACS+16	;restore cx
2)		JRST @DUMPPC		;Return to whence we came from
2)	;CM302 *** End ***
2)	^L
2)	;BEGIN ERROR MESSAGE LINE.  DO CRLF IF NOT ALREADY AT LEFT MARGIN,


LINE 28, PAGE 61
1)	;*** I haven't the foggiest idea why this change is here, but it has been
1)	;since time immemoriable - PA0B, 21-Nov-82 ***
1)		MOVE A,B		;PCL
1)		ADJSP A,1		;PCL See where it came from
1)		CAMN A,JBUFP		;PCL Was it the top of the stack?
1)		MOVEM B,JBUFP		;PCL Yes, just forget it
1)	DG2:	DMOVE A,GETARG		;NOW DO THE GET JSYS
LINE 28, PAGE 63
2)		MOVE A,B		;CM156
2)		ADJSP A,1		;CM156 See where it came from
2)		CAMN A,JBUFP		;CM156 Was it the top of the stack?
2)		MOVEM B,JBUFP		;CM156 Yes, just forget it
2)	DG2:	DMOVE A,GETARG		;NOW DO THE GET JSYS


LINE 134, PAGE 61
1)		KFORK			;KILL THE FORK
LINE 132, PAGE 63
2)		CALL RELIO		;CM224 Release primary JFN's if necessary
2)		KFORK			;KILL THE FORK


LINE 154, PAGE 61
1)	IFE STANSW,<
1)	RJFNSA:	SOJL B,RSKP		;LEAVE LOOP WHEN ALL ENTRIES HAVE BEEN SCANNED
1)	>;IFE STANSW
1)	IFN STANSW,<
1)	RJFNSA:	SOJL B,NPCLIO		;CM156 When all entries have been scanned, see
1)					; if JFN in use by PCL
1)	>;IFN STANSW
1)		HRRZ D,TAKJFN(B)	;GET OUTPUT JFN
LINE 153, PAGE 63
2)	RJFNSA:	SOJL B,NPCLIO		;CM156 LEAVE LOOP WHEN ALL ENTRIES SCANNED
2)		HRRZ D,TAKJFN(B)	;GET OUTPUT JFN


; SRC:<6-EXEC>EXECSU.MAC.19 & EXECSU.MAC.1 26-Jul-85 0102	PAGE 67



LINE 175, PAGE 61
1)		CALL GETERR		;GET THE ERROR CODE
1)		SETZM AERRF		;NO ERROR YET
LINE 168, PAGE 63
2)		SETZM AERRF		;NO ERROR YET


LINE 210, PAGE 61
1)	RFAIL:		ETYPE <%@%%%Couldn't close JFN %1O, status %2O - %?%%_>
1)		SETOM AERRF		;SAY ERROR
LINE 202, PAGE 63
2)	RFAIL:		ETYPE <%@%%%Couldn't close JFN %1O, status %2o - %?%%_>
2)		SETOM AERRF		;SAY ERROR


LINE 236, PAGE 61
1)	;PCL ROUTINE TO UNSTACK THE TOP JFN IN THE JFN STACK.
1)	;RETURNS THE JFN IN A.  DESTROYS NO REGISTERS.
1)	
1)	JUNSTK::PUSH P,B		;SAVE B
1)		MOVE B,JBUFP		;GET THE STACK POINTER
1)		POP B,A			;POP THE JFN INTO A
1)		MOVEM B,JBUFP		;SAVE THE STACK POINTER
1)		POP P,B			;RESTORE B
1)		RET			;AND RETURN
1)	
LINE 228, PAGE 63
2)	;PCL ROUTINE TO UNSTACK A JFN FROM THE JFN STACK.  TAKES
2)	;THE JFN TO UNSTACK IN A.  DESTROYS NO REGISTERS.
2)	
2)	JUNSTK::SAVEAC<A,B,C>		;CM224
2)		HRRZS A			;CM224 Make sure we have only important half
2)					; for making comparisons
2)		MOVE B,JBUFP		;GET THE STACK POINTER
2)		POP B,C			;CM224 POP THE JFN INTO C
2)		HRRZS C			;CM224 Compare only right half
2)		CAME A,C		;CM224 Is the one on top the right one?
2)		 JRST JUNST2		;CM224 No, find right one
2)		MOVEM B,JBUFP		;SAVE THE STACK POINTER
2)		RET			;AND RETURN
2)	
2)	JUNST2:	CAMN B,[IOWD JBUFL,JBUF] ;CM224 Gotten to the bottom of the stack?
2)		 JRST [ BUG		;CM224 Yep, we're screwed up
2)			RET ]		;CM224
2)		POP B,C			;CM224 Get next JFN on stack
2)		HRRZS C			;CM224 Compare only right half
2)		CAME A,C		;CM224 The right one?
2)		 JRST JUNST2		;CM224 No, keep looking
2)		SETZM 1(B)		;CM224 Yes, clear the entry

; SRC:<6-EXEC>EXECSU.MAC.19 & EXECSU.MAC.1 26-Jul-85 0102	PAGE 68


2)		RET			;CM224 Done
2)	


LINE 265, PAGE 61
1)	GTFAIL:	CALL GETERR		;GET THE ERROR CODE
1)		DMOVEM A,GTDATA		;SAVE WHAT FAILING GTJFN RETURNED
1)		SOS CLZFFF		;GTJFN FAILED, CLZFF NOT NEEDED
LINE 271, PAGE 63
2)	GTFAIL:	DMOVEM A,GTDATA		;SAVE WHAT FAILING GTJFN RETURNED
2)		SOS CLZFFF		;GTJFN FAILED, CLZFF NOT NEEDED


LINE 2, PAGE 62
1)	;ROUTINE TO PRINT JOBS ACCOUNTING STRING (OR NUMBER)
LINE 2, PAGE 64
2)	;CM224 *** Entire page ***
2)	
2)	;
2)	;	A/ Fork handle
2)	;	CALL RELIO 
2)	;	Returns +1
2)	;
2)	;If the fork is not .FHSLF and its primary JFN's have been set (via
2)	;SPJFN) then the fork's primary I/O files are closed and the JFN's
2)	;released.  Otherwise there is no effect.
2)	
2)	RELIO::	CAIN A,.FHSLF		;Is fork self?
2)		RET			;Yes, do nothing
2)		SAVEAC<A,B,C,D>		;Don't clobber any ac's
2)		MOVEM A,D		;Save the fork handle
2)		MOVX A,.FHSLF
2)		GPJFN%			;Get our primary jfn's
2)		MOVE A,D		;Get back inferior's handle
2)		HLRZM B,C		;Save Exec's primary input
2)		HRRZM B,D		;  and primary output
2)		GPJFN%			;Get inferior fork's primary jfn's
2)		 ERJMP R		;Bad fork handle?
2)		HLRZ A,B		;Isolate inferior's primary input jfn in A
2)		CAME A,C		;Default primary input?
2)		 CALL ACLOSE		;No, close it
2)		HRRZ A,B		;Now isolate inferior's primary output jfn in A
2)		CAME A,D		;Default?
2)		 CALL ACLOSE		;No, close it
2)		RET			;And we're done...
2)	
2)	;Routine to get rid of the jfn in A.  Closes the file if necessary and then
2)	;releases the jfn.
2)	
2)	ACLOSE:	CAIN A,.SIGIO		;Signal designator?
2)		RET			;Yes, leave it alone

; SRC:<6-EXEC>EXECSU.MAC.19 & EXECSU.MAC.1 26-Jul-85 0102	PAGE 69


2)		PUSH P,B		;Don't clobber any ac's
2)		HRRZ A,A		;No accidental flag bits, please
2)		HRRZ B,A		;Save jfn in case closf% fails
2)		CLOSF%			;Try and close jfn (might not be open)
2)		 CALL NOTOPN		;File not open?
2)		POP P,B		;Restore the saved ac
2)		RET
2)	
2)	NOTOPN:	CAIE A,CLSX1		;File not open?
2)		JRST CJERR		;Nope, some other error.
2)		MOVE A,B		;Yes, get jfn into a
2)		RLJFN%			;Release it
2)		 JRST CJERR
2)		RET
2)	^L
2)	;ROUTINE TO PRINT JOBS ACCOUNTING STRING (OR NUMBER)


LINE 14, PAGE 63
1)	;	NOTE:  STATF (BELOW) IS USED TO FORCE A REENTRY INTO THE PARSE
1)	;	CODE AFTER AN AC IS PARSED.
1)	
1)	%ETYPE:	TRVAR <<ETBFR,EBLN>,<RACS,5>,ETPTR,SRCPTR,ETYPF,EDAT,STATF,AC%B,AC%C,AC%D>
1)		SETZM STATF		;ZERO STATE FLAG
1)		MOVEM Z,RACS		;SAVE REAL AC'S AWAY
LINE 14, PAGE 66
2)	%ETYPE:	TRVAR <<ETBFR,EBLN>,<RACS,5>,ETPTR,SRCPTR,ETYPF,EDAT,<LBUFF,20>> ;EM31
2)		MOVEM Z,RACS		;SAVE REAL AC'S AWAY


LINE 5, PAGE 64
1)	ETYP3:	ILDB B,SRCPTR		;GET THE CHARACTER AFTER PERCENT
1)	
1)	ETYP4:	SKIPN STATF		;SKIP IF WE JUST PARSED AC #
1)		SETZM D			;D=NONZERO MEANS AC SPECIFIED
1)		SETZM STATF		;RESET STATE FLAG
1)		CAIGE B,040		;ASCII SPACE OR GREATER?
1)		CALL %ILOP		;NO, ILLEGAL OPERAND, CALL AND DON'T RETURN
1)		MOVEI A,-40(B)		;(1) SUBTRACT 40 TO ALLOW FOR MISSING CTL CHARS
1)					;(2) LEAVE THE CHAR INTACT IN AC-B
1)		HRRZ A,%LETS(A)		;GET ADDRESS OF ROUTINE
1)		CALL (A)		;DO THE WORK
1)	
1)	;RETURN FROM DISPATCH
1)		SKIPE STATF		;ARE WE IN NEXT STATE?
1)		JRST ETYP4		;YES
1)		MOVE C,SRCPTR		;SAVE COPY
1)		ILDB B,C		;NEXT CHARACTER
1)		CAIN B,"%"		;PASS FOLLOWING %
1)		MOVEM C,SRCPTR
1)		JRST ETYP2		;NO, CONTINUE TYPING

; SRC:<6-EXEC>EXECSU.MAC.19 & EXECSU.MAC.1 26-Jul-85 0102	PAGE 70


1)	
1)	
LINE 5, PAGE 67
2)		SETZB C,D		;C: IF NO NUMBER, USE 0 IN PLACE OF AC CONTENTS
2)					;D: INIT NUMBER TO 0.
2)	ETYP4:	ILDB B,SRCPTR		;CHARACTER AFTER %
2)		CAIG B,"9"
2)		CAIGE B,"0"
2)		JRST ETYP5
2)		IMULI D,10
2)		ADDI D,-"0"(B)		;ADD NEW DIGIT TO NUMBER
2)		MOVE C,D		;COMPUTE LOCATION TO GET AC FROM...
2)		CAIG C,D		;...AC'S 5-9 ARE PRESERVED,
2)		ADDI C,RACS		;...CONTENTS OF 0-4 ARE IN PUSHDOWN.
2)		MOVE C,(C)		;FETCH CONTENTS OF AC INDICATED BY NUMBER SO FAR
2)		JRST ETYP4		;GO CHECK FOR ADDITIONAL DIGIT(S)
2)	


LINE 1, PAGE 65
1)	^L
1)	;%ETYPE...
1)	;DISPATCH TABLE FOR LETTERS AFTER %
1)	;THIS IS AN ASCII DISPATCH TABLE MINUS THE CONTROL CHARACTERS
1)	
1)	%LETS:	%ILOP		;( ) PERMANENTLY UNASSIGNED
1)		%EXTND		;(!) EXTEND OPERATOR
1)		%UNAS		;(") UNASSIGNED
1)		%NUMS		;(#) OCTAL NUMBER AS N OR N,,N AS APPROPRIATE
1)		%UNAS		;($) UNASSIGNED
1)		%PER		;(%) %% JUST PRINTS A PERCENT
1)		%UNAS		;(&) UNASSIGNED
1)		%SIX		;(') PRINT CONTENTS OF AC IN SIXBIT
1)		%UNAS		;"(" UNASSIGNED
1)		%UNAS		;")" UNASSIGNED
1)		%UNAS		;(*) UNASSIGNED
1)		%UNAS		;(+) UNASSIGNED
1)		%UNAS		;(,) UNASSIGNED
1)		%UNAS		;(-) UNASSIGNED
1)		%UNAS		;(.) UNASSIGNED
1)		%EXPR		;(/) EXPRESSION IN AC
1)		%AC		;(0) DIGIT
1)		%AC		;(1) DIGIT
1)		%AC		;(2) DIGIT
1)		%AC		;(3) DIGIT
1)		%AC		;(4) DIGIT
1)		%AC		;(5) DIGIT
1)		%AC		;(6) DIGIT
1)		%AC		;(7) DIGIT
1)		%AC		;(8) DIGIT
1)		%AC		;(9) DIGIT

; SRC:<6-EXEC>EXECSU.MAC.19 & EXECSU.MAC.1 26-Jul-85 0102	PAGE 71


1)		%UNAS		;(:) UNASSIGNED
1)		%UNAS		;(;) UNASSIGNED
1)		%ILOP		;(<) PERMANENTLY UNASSIGNED
1)		%FLT		;(=) SIX-COLUMN FLOATING POINT NUMBER, NN.MM
1)		%ILOP		;(>) PERMANENTLY UNASSIGNED
1)		%SYSMS		;(?) ERROR MESSAGE (CONTENTS OF AC OR LATEST)
1)		%LM		;(@) GET TO LEFT MARGIN
1)		%A		;(A) CURRENT TIME
1)		%B		;(B) CPU TIME AS HH:MM:SS, OR SPECIFIC TIME
1)				;    IN MILLISECONDS
1)		%C		;(C) CONNECT TIME
1)		%D		;(D) CURRENT DATE(OR SPECIFIC DATE)
1)		%E		;(E) SAME TIME AS LAST %D(OR SPECIFIC TIME)
1)		%F		;(F) "FORK N " IF >1 INFERIOR
1)		%G		;(G) CONNECTED DIR NAME
1)		%H		;(H) DEVICE NAME FOR DESIGNATOR IN INDICATED AC
1)		%I		;(I) PRINT # OF USER JOBS + # OF OPR JOBS
1)		%J		;(J) TSS JOB #
1)		%K		;(K) UPTIME
1)		%L		;(L) "LINE N" OR "DETACHED"
1)		%M		;(M) NUMBER OR STRING (5B0+N OR BYTE POINTER)
1)		%N		;(N) NAME UNDER WHICH USER IS LOGGED IN
1)				;    (OR SPECIFIC USER NAME)
1)		%O		;(O) CONTENTS OF SPECIFIED AC IN OCTAL
1)		%P		;(P) CONTENTS OF RIGHT HALF OF SPECIFIED AC IN OCTAL
1)		%Q		;(Q) CONTENTS OF AC IN DECIMAL OR FLOATING!
1)		%R		;(R) DIRECTORY NAME FOR DIR # OR STRING POINTER IN AC
1)		%S		;(S) FILE NAME FOR JFN IN AC
1)		%T		;(T) CONTENTS OF AC AS PERCENTAGE OF UP TIME
1)		%U		;(U) DECIMAL BIT NUMBERS, SEPARATED BY COMMAS
1)		%V		;(V) CPU TIME WITH TENTHS OF SECONDS
1)				;    (FORK HANDLE IN AC IF NOT 0)
1)		%W		;(W) STD FORMAT DATE AND TIME IN AC
1)		%X		;(X) TYPE ILLEG INST ERROR MSG
1)		%Y		;(Y) MEMORY ADDRESS
1)		%Z		;(Z) TYPE "," <SPACE><SPACE>...
1)		%UNAS		;([) UNASSIGNED
1)		%STRNG		;(\) TYPE STRING OR CHAR IN AC
1)		%UNAS		;(]) UNASSIGNED
1)		%UNAS		;(^) UNASSIGNED
1)		%EOL		;(_) TYPE A CRLF
1)		%SIX		;(') PRINT CONTENTS OF AC IN SIXBIT
1)		%AA		;(a) TYPE OUT 3-DIGIT OCTAL NUMBER WITH LEADING ZEROES
1)		%BB		;(b) TYPE OUT CURRENT CONTENTS OF ATOM BUFFER
1)		%UNAS		;(c) UNASSIGNED
1)		%UNAS		;(d) UNASSIGNED
1)		%UNAS		;(e) UNASSIGNED
1)		%UNAS		;(f) UNASSIGNED
1)		%UNAS		;(g) UNASSIGNED
1)		%UNAS		;(h) UNASSIGNED
1)		%UNAS		;(i) UNASSIGNED

; SRC:<6-EXEC>EXECSU.MAC.19 & EXECSU.MAC.1 26-Jul-85 0102	PAGE 72


1)		%UNAS		;(j) UNASSIGNED
1)		%UNAS		;(k) UNASSIGNED
1)		%UNAS		;(l) UNASSIGNED
1)		%UNAS		;(m) UNASSIGNED
1)		%UNAS		;(n) UNASSIGNED
1)		%UNAS		;(o) UNASSIGNED
1)		%UNAS		;(p) UNASSIGNED
1)		%UNAS		;(q) UNASSIGNED
1)		%UNAS		;(r) UNASSIGNED
1)		%UNAS		;(s) UNASSIGNED
1)		%UNAS		;(t) UNASSIGNED
1)		%UNAS		;(u) UNASSIGNED
1)		%UNAS		;(v) UNASSIGNED
1)		%UNAS		;(w) UNASSIGNED
1)		%UNAS		;(x) UNASSIGNED
1)		%UNAS		;(y) UNASSIGNED
1)		%UNAS		;(z) UNASSIGNED
1)		%UNAS		;({) UNASSIGNED
1)		%UNAS		;(|) UNASSIGNED
1)		%UNAS		;(}) UNASSIGNED
1)		%UNAS		;(~) UNASSIGNED
1)		%ILOP		;(DEL) PERMANENTLY UNASSIGNED
1)	
1)	
1)	LETLEN==.-%LETS
LINE 39, PAGE 67
2)	ETYP5:	CAIL B,141
2)		CAILE B,172
2)		CAIA
2)		TRZ B,40		;MAKE THE CHARACTER UPPER CASE
2)		MOVEI A,LETLEN		;INDEX INTO TABLE OF CODES
2)		MOVEM C,EDAT		;DON'T CLOBBER DATA
2)	ETYP7:	SOJL A,LETNF		;COULDN'T FIND CHARACTER IN TABLE IF THIS JUMPS
2)		HLRZ C,%LETS(A)		;GET NAME OF ELEMENT FROM TABLE
2)		CAIL C,141
2)		CAILE C,172
2)		CAIA
2)		TRZ C,40		;MAKE THE CHARACTER UPPER CASE
2)		CAME B,C		;IS THIS THE CORRECT ENTRY?
2)		JRST ETYP7		;NOT YET...
2)		MOVE C,EDAT		;RESTORE DATA
2)		HRRZ A,%LETS(A)		;GET ADDRESS OF ROUTINE
2)		CALL (A)		;DO THE WORK
2)	
2)	;DONE INTERPRETING A % CODE.
2)	
2)		MOVE C,SRCPTR		;SAVE COPY
2)		ILDB B,C		;NEXT CHARACTER
2)		CAIN B,"%"		;PASS FOLLOWING %
2)		MOVEM C,SRCPTR
2)		JRST ETYP2		;CONTINUE TYPING

; SRC:<6-EXEC>EXECSU.MAC.19 & EXECSU.MAC.1 26-Jul-85 0102	PAGE 73


2)	^L
2)	;%ETYPE...
2)	;DISPATCH TABLE FOR LETTERS AFTER %
2)	;KEEP THIS TABLE IN ASCII ASCENDING ORDER SO IT REMAINS EASY TO SEE IF A
2)	;CHARACTER IS IMPLEMENTED OR NOT
2)	;(NOTE THAT EXEC DOESN'T ASSUME TABLE IS ORDERED THOUGH)
2)	
2)	%LETS:	"#",,%NUMS		;OCTAL NUMBER AS N OR N,,N AS APPROPRIATE
2)		"$",,%HSTNM		;CS136 Local Internet host or specific host
2)		"%",,%PER		;%% JUST PRINTS A PERCENT
2)		"=",,%FLT		;SIX-COLUMN FLOATING POINT NUMBER, NN.MM
2)		"@",,%LM		;GET TO LEFT MARGIN
2)		"A",,%A			;CURRENT TIME
2)		"B",,%B			;CPU TIME AS HH:MM:SS, OR SPECIFIC TIME IN MILLISECONDS
2)		"C",,%C			;CONNECT TIME
2)		"D",,%D			;CURRENT DATE(OR SPECIFIC DATE)
2)		"E",,%E			;SAME TIME AS LAST %D(OR SPECIFIC TIME)
2)		"F",,%F			;"FORK N " IF >1 INFERIOR
2)		"G",,%G			;CONNECTED DIR NAME
2)		"H",,%H			;DEVICE NAME FOR DESIGNATOR IN INDICATED AC
2)		"I",,%I			;PRINT # OF USER JOBS + # OF OPR JOBS
2)		"J",,%J			;TSS JOB #
2)		"K",,%K			;UPTIME
2)		"L",,%L			;"LINE N" OR "DETACHED"
2)		"M",,%M			;NUMBER OR STRING (5B0+N OR BYTE POINTER)
2)		"N",,%N			;NAME UNDER WHICH USER IS LOGGED IN (OR SPECIFIC USER NAME)
2)		"O",,%O			;CONTENTS OF SPECIFIED AC IN OCTAL
2)		"P",,%P			;CONTENTS OF RIGHT HALF OF SPECIFIED AC IN OCTAL
2)		"Q",,%Q			;CONTENTS OF AC IN DECIMAL OR FLOATING!
2)		"R",,%R			;DIRECTORY NAME FOR DIR # OR STRING POINTER IN AC
2)		"S",,%S			;FILE NAME FOR JFN IN AC
2)		"T",,%T			;CONTENTS OF AC AS PERCENTAGE OF UP TIME
2)		"U",,%U			;DECIMAL BIT NUMBERS, SEPARATED BY COMMAS
2)		"V",,%V			;CPU TIME WITH TENTHS OF SECONDS (FORK HANDLE IN AC IF NOT 0)
2)		"W",,%W			;STD FORMAT DATE AND TIME IN AC
2)		"X",,%X			;TYPE ILLEG INST ERROR MSG
2)		"Y",,%Y			;MEMORY ADDRESS
2)		"\",,%STRNG		;TYPE STRING OR CHAR IN AC
2)		"/",,%EXPR		;EXPRESSION IN AC
2)		"'",,%SIX		;PRINT CONTENTS OF AC IN SIXBIT
2)		"_",,%EOL		;TYPE A CRLF
2)		"?",,%SYSMS		;ERROR MESSAGE (CONTENTS OF AC OR LATEST)
2)	LETLEN==.-%LETS


; SRC:<6-EXEC>EXECSU.MAC.19 & EXECSU.MAC.1 26-Jul-85 0102	PAGE 74



LINE 111, PAGE 66
1)	%ILOP:
1)	%UNAS:	TYPE <%>		;DIGIT, IF ANY, IS LOST.
1)		POP P,A			;POP THE STACK AND DISCARD
1)		JRST ETYP2A		;CONTINUE TYPING, STARTING WITH CHAR AFTER %.
1)	
1)	
1)	;THIS ROUTINE IS LEFT FOR A POSSIBLE EXPANSION OF THE DISPATCH TABLE
1)	;IN WHICH THE LEFT HALF WOULD CONTAIN A NEW SERIES OF DISPATCH ADDRESSES
1)	%EXTND:	RET
1)	^L
LINE 47, PAGE 68
2)	LETNF:	TYPE <%>		;DIGIT, IF ANY, IS LOST.
2)		JRST ETYP2A		;CONTINUE TYPING, STARTING WITH CHAR AFTER %.
2)	^L


LINE 7, PAGE 67
1)	;%AC EXTRACTS AC VALUE IF AN AC WAS SPECIFIED
1)	;AND LEAVES CONTENTS OF AC IN C
1)	%AC:
1)		SETOM STATF		;INDICATE NEXT NON-NUMERIC IS A DISPATCH CHAR
1)		SETZB C,D		;C: IF NO NUMBER, USE 0 IN PLACE OF AC CONTENTS
1)					;D: INIT NUMBER TO 0.
1)	%AC1:	IMULI D,10
1)		ADDI D,-"0"(B)		;ADD NEW DIGIT TO NUMBER
1)		MOVE C,D		;COMPUTE LOCATION TO GET AC FROM...
1)		CAIG C,D		;...AC'S 5-9 ARE PRESERVED,
1)		ADDI C,RACS		;...CONTENTS OF 0-4 ARE IN PUSHDOWN.
1)		MOVE C,(C)		;FETCH CONTENTS OF AC INDICATED BY NUMBER SO FAR
1)		ILDB B,SRCPTR		;GET NEXT CHARACTER
1)		CAIG B,"9"
1)		CAIGE B,"0"
1)		RET
1)		JRST %AC1		;GO CHECK FOR ADDITIONAL DIGIT(S)
1)	
1)	;%% JUST PRINTS A %
LINE 7, PAGE 69
2)	;%% JUST PRINTS A %


; SRC:<6-EXEC>EXECSU.MAC.19 & EXECSU.MAC.1 26-Jul-85 0102	PAGE 75



LINE 32, PAGE 67
1)	%A:	GTAD			;GET CURRENT DATE & TIME
1)	A1:	MOVX C,OT%NDA		;TIME ONLY
1)	A2:	MOVE B,A
1)		MOVE A,COJFN
1)		CAMN B,[-1]		;DOES SYSTEM HAVE DATE & TIME?
1)		HRLZI B,1		;CHANGE TO CALL SCREWUP ________
1)		ODTIM
LINE 14, PAGE 69
2)	%A:	SETO A,			;CM224 Use current date and time
2)	A1:	MOVX C,OT%NDA		;TIME ONLY
2)	A2:	MOVE B,A
2)		MOVE A,COJFN
2)	;CM224 *** 2 lines deleted ***
2)		ODTIM


LINE 75, PAGE 67
1)	IFE STANSW,<
1)		JRST A1			;SEE %A
1)	>;IFE STANSW
1)	IFN STANSW,<
1)		MOVX C,<OT%NDA+OT%NSC!OT%12H>	;NO SECONDS, TIME ONLY
1)		JRST A2			;SEE %A
1)	>;IFN STANSW
1)	^L
LINE 56, PAGE 69
2)		JRST A1			;SEE %A
2)	^L


LINE 33, PAGE 68
1)		MOVE A,COJFN
1)		DEVST			;DEVICE TO STRING
1)		 CALL JERR
1)		MOVEM A,COJFN		;SAVE IN CASE POINTER
1)		RET
LINE 33, PAGE 70
2)	;EM31	MOVE A,COJFN
2)		MOVE A,[POINT 7,LBUFF]	;EM31 Send it to the case-routine buffer
2)		DEVST			;DEVICE TO STRING
2)		 CALL JERR
2)	;EM31	MOVEM A,COJFN		;SAVE IN CASE POINTER
2)		CALL FIXCAS		;EM31 And do the output, case fixed.
2)		RET


; SRC:<6-EXEC>EXECSU.MAC.19 & EXECSU.MAC.1 26-Jul-85 0102	PAGE 76



LINE 19, PAGE 69
1)	USRCNT::MOVSI A,(RC%EMO)	;EXACT MATCH ONLY
1)		HRROI B,[ASCIZ /OPERATOR/]
1)		RCUSR			;GET DIRNUM OF OPERATOR
1)		TLNE A,(RC%NOM+RC%AMB)	;COULDN'T?
1)		MOVEI C,-1		;NO, SO USE -1
1)		PUSH P,C		;SAVE IT FOR COMPARES BELOW
1)		SETZB B,C		;COUNTER
1)		HLLZ D,JOBRT		;SET UP AOBJN PTR
1)		GTB .JOBRT
1)		JUMPL A,%I1		;NO JOB 0
1)		GTB .JOBTT
1)		JUMPL A,%I3		;IGNORE DETACHED JOB 0
1)	%I1:	GTB .JOBRT		;TABLE 1 IS POSITIVE IF JOB EXISTS
1)		JUMPL A,%I3
1)		CALL USERNO		;GET USER NUMBER
1)		JUMPE A,%I3		;SKIP JOB IF NOT LOGGED IN
1)		CAMN A,0(P)		;LOGGED IN AS 'OPERATOR'?
1)		AOJA C,%I3		;YES, COUNT OPERATOR JOBS
1)		AOS B			;COUNT REGULAR JOBS
1)	%I3:	AOBJN D,%I1
1)		MOVE A,C
1)		POP P,(P)
1)		RET
1)	
LINE 19, PAGE 71
2)	USRCNT::STKVAR <<UCTTBL,^D128>>	;CM224
2)		CALL GTOPNM		;CM351 Make sure we have the user numbers of
2)					; Operator, Io00, etc.
2)		MOVEI A,.JOBRT		;CM224 Read runtime table
2)		HLLZ B,JOBRT		;CM224 This many words
2)		HRRI B,UCTTBL		;CM224 Into here
2)		GTBLT%			;CM224
2)		SETZB B,C		;COUNTER
2)		HLLZ D,JOBRT		;SETUP AOBJN PTR
2)		SKIPGE UCTTBL		;CM224 Is there a job 0?
2)		JRST %I1		;CM224 No
2)		GTB .JOBTT
2)		JUMPL A,%I3		;IGNORE DETACHED JOB 0
2)	%I1:	MOVEI A,UCTTBL		;CM224
2)		ADDI A,(D)		;CM224
2)		SKIPG (A)		;CM224 JOBRT is positive if job exists
2)		JRST %I3		;CM224
2)		CALL USERNO		;GET USER NUMBER
2)		JUMPE A,%I3		;SKIP JOB IF NOT LOGGED IN
2)		CALL CKOPNM		;CM351, CM224 LOGGED IN AS 'OPERATOR'?
2)		 AOSA B			;CM351 No, count as normal user job
2)		AOS C			;CM351 Yes, count as operator job
2)	%I3:	AOBJN D,%I1

; SRC:<6-EXEC>EXECSU.MAC.19 & EXECSU.MAC.1 26-Jul-85 0102	PAGE 77


2)		MOVE A,C
2)	;CM224 *** 1 line deleted ***
2)		RET
2)	
2)	;*** CM351 Begin addition ***
2)	
2)	;Routines used to determine whether a job is an Operator job.  An "Operator
2)	;job" is a job logged in as Operator, Sysjob, or Io00.  These routines are
2)	;used both by %I above and by "Systat".
2)	
2)	;Routine to find out the user numbers of the various operator userids.  Does
2)	;nothing if we already know them.  Takes no arguments and returns +1 always.
2)	
2)	GTOPNM::SKIPE OPRNUM		;Do we already know them?
2)		 RET			;Yes, do nothing
2)		MOVSI A,(RC%EMO)	;Exact match only
2)		HRROI B,[ASCIZ /IO00/]	;Get IO00's user number
2)		RCUSR%			;...
2)		TLNE A,(RC%NOM+RC%AMB)	;Got it?
2)		 MOVEI C,-1		;If no such, use -1
2)		MOVEM C,IOPNUM		;Remember it
2)		MOVSI A,(RC%EMO)	;Exact match only
2)		HRROI B,[ASCIZ /SYSJOB/] ;Get Sysjob's user number
2)		RCUSR%			;...
2)		TLNE A,(RC%NOM+RC%AMB)	;Got it?
2)		 MOVEI C,-1		;If no such, use -1
2)		MOVEM C,SYJNUM		;Remember it
2)		MOVSI A,(RC%EMO)	;Exact match only
2)		HRROI B,[ASCIZ /OPERATOR/] ;Get Operator's user number
2)		RCUSR%			;...
2)		TLNE A,(RC%NOM+RC%AMB)	;Got it?
2)		 MOVEI C,-1		;If no such, use -1
2)		MOVEM C,OPRNUM		;Remember it *** NOTE: this should be the last
2)					; line in this routine because otherwise we
2)					; would have to turn off ^C interrupts to make
2)					; the test at the beginning of the routine be
2)					; valid! ***
2)		RET
2)	
2)	;Routine to check if a user number is an operator user number (ie, it is
2)	;either OPERATOR or SYSJOB or IO00).
2)	;
2)	;Takes:
2)	;	A/ user number to be checked
2)	;Returns:
2)	;	+1/ user number is not an operator user number
2)	;	+2/ user number is an operator user number
2)	;Clobbers:
2)	;	No AC's
2)	;Warning:
2)	;	GTOPNM must be called before this routine is called  (The reason it

; SRC:<6-EXEC>EXECSU.MAC.19 & EXECSU.MAC.1 26-Jul-85 0102	PAGE 78


2)	;	is a separate routine is that GTOPNM need be called only once whereas
2)	;	this routine is called repeatedly in a loop).
2)	;
2)	CKOPNM::CAMN A,OPRNUM		;Operator?
2)		RETSKP			;Yes
2)		CAMN A,SYJNUM		;No, but how about Sysjob?
2)		RETSKP			;Yes, that's operator, too
2)		CAMN A,IOPNUM		;CM229 No.  Maybe Io00?
2)		RETSKP			;CM229 Yes, indicate this is operator
2)		RET			;No, so must be a normal user
2)	
2)	;***  CM351 End addition  ***
2)	


LINE 47, PAGE 69
1)		CALLRET TOUT		;PRINT AS HH:MM:SS AND RETURN
1)	^L
LINE 110, PAGE 71
2)	CS,<	CALL TOUT		;CS104
2)		DO.			;CS104
2)		  SUBI A,^D24*^D60*^D60	;CS104 #seconds in day
2)		  SKIPGE A		;CS104 Up another day?
2)		   RET			;CS104 Nope.
2)		  TYPE <!>		;CS104 Yup. Say so...
2)		  LOOP.			;CS104 And go for another one
2)		ENDDO.			;CS104
2)	   >;CS
2)	CC,<				;Begin C386
2)		IDIVI A,^D24*^D60*^D60	;C386 Number of seconds in a day
2)		PUSH P,B		;C386 Save the seconds past a full day
2)		SKIPN A			;C386 See if we have been up for atleast a day
2)		 JRST %K.1		;C386 Nope, just type the time
2)		MOVE B,A		;C386 Move the number of Days into B
2)		MOVE A,COJFN		;C386 Get the output JFN
2)		MOVEI C,^D10		;C386 We are talking Decimal here
2)		NOUT%			;C386 Write out the Number
2)		 CALL JERRC		;C386 If we should fail
2)		MOVE A,[POINT 7,[ASCIZ / days /]] ;Our string
2)		SOSN B			;C386 Only 1 day???
2)		 MOVE A,[POINT 7,[ASCIZ / day /]] ;Set our string up as such
2)		MOVE B,A		;C386 Move the pointer to B
2)		MOVE A,COJFN		;C386 Where to write it
2)		SETZ C			;C386 Terminate on a nul
2)		SOUT%
2)	%K.1:	POP P,A			;C386 Get the Seconds back in A
2)		CALL TOUT		;C386 Now write them out also
2)		RET			;C386 All done
2)	   >;CC
2)	
2)	^L

; SRC:<6-EXEC>EXECSU.MAC.19 & EXECSU.MAC.1 26-Jul-85 0102	PAGE 79




LINE 18, PAGE 70
1)		CAIE B,5
1)		JRST [	MOVE B,C
1)			SETZ C,
1)			SOUT
1)			MOVEM A,COJFN	;UPDATE, IN CASE BYTE POINTER
1)			RET]
1)		MOVE B,C
LINE 18, PAGE 72
2)		CAIN B,5
2)		IFSKP.			;EM62
2)		  MOVE A,C		;EM62
2)		  CALL BUFFS		;EM62 Copy the string into free space
2)		  PUSH P,A		;EM62 Save pointer to it
2)		  CALL LOWCAS		;EM62 Lower case it
2)		  MOVE A,COJFN		;EM62
2)		  POP P,B		;EM62
2)		  SETZ C,		;EM62
2)		  SOUT			;EM62 Print the string
2)		  MOVEM A,COJFN		;EM62
2)		  RET
2)		ENDIF.
2)		MOVE B,C


LINE 37, PAGE 70
1)	;USER (DIRECTORY) NAME LOGGED IN UNDER.
1)	
1)	%N:	SKIPN A,C		;USE SPECIFIC USER NAME IF GIVEN
1)		GJINF
1)		MOVE B,A		;LOGIN DIRECTORY NO
1)	%N1:	MOVE A,COJFN
1)		DIRST
1)		 ERJMP DIRSTB		;THE DIRST FAILED
1)		MOVEM A,COJFN		;UPDATE IN CASE BYTE POINTER
1)		RET
LINE 44, PAGE 72
2)	;CS136 *** Begin ***
2)	;Name of local Internet host, or specific host number
2)	
2)	%HSTNM:	SKIPN C			;Use specific host number if given
2)		 SETO C,		;Else, use local host number
2)		MOVX A,.GTHNS		;Want host name string
2)		HRROI B,LBUFF		;Point to convenient buffer
2)		GTHST%			;Translate it
2)		 ERJMP HSTERR		;Not an Internet host - print "?" & punt
2)		MOVE A,COJFN		;Point at output JFN
2)		HRROI B,LBUFF		;And generated buffer
2)		SETZ C,

; SRC:<6-EXEC>EXECSU.MAC.19 & EXECSU.MAC.1 26-Jul-85 0102	PAGE 80


2)		SOUT%			;Print the host name
2)		RET
2)	
2)	HSTERR:	PRINT "?"		;Print error
2)		RET			;And done
2)	
2)	;CS136 *** End ***
2)	
2)	;USER (DIRECTORY) NAME LOGGED IN UNDER.
2)	
2)	%N:	SKIPN A,C		;USE SPECIFIC USER NAME IF GIVEN
2)		MOVE A,CUSRNO		;CM224
2)		MOVE B,A		;LOGIN DIRECTORY NO
2)	%N1:	MOVE A,[POINT 7,LBUFF]	;EM9
2)	;EM9	MOVE A,COJFN
2)		DIRST
2)		 ERJMP DIRSTB		;THE DIRST FAILED
2)		CALL FIXCAS		;EM9
2)	;EM9	MOVEM A,COJFN		;UPDATE IN CASE BYTE POINTER
2)		RET


LINE 39, PAGE 71
1)		PRINT @B		;PRINT CHARACTER
LINE 39, PAGE 73
2)		SKIPN CASFLG		;EM134 Doing case conversions?
2)		CAMN A,[360600,,C]	;EM11 If this is first char, leave caped
2)		IFSKP.			;EM11
2)		  CAIL B,"A"		;EM11
2)		  CAILE B,"Z"		;EM11
2)		  CAIA			;EM11
2)		  ADDI B,"a"-"A"	;EM11
2)		ENDIF.			;EM11
2)		PRINT @B		;PRINT CHARACTER


LINE 54, PAGE 71
1)	%J:	GJINF			;GETS JOB # IN C
1)	
LINE 62, PAGE 73
2)	%J:	MOVE C,JOBNO		;CM224
2)	


; SRC:<6-EXEC>EXECSU.MAC.19 & EXECSU.MAC.1 26-Jul-85 0102	PAGE 81



LINE 111, PAGE 71
1)		CALL JERR		;NO, OTHER. UNEXPECTED
1)		MOVEI A,0		;YES, SO RETURN 0.
LINE 119, PAGE 73
2)		CALL JERR		;NO, OTHER.  UNEXPECTED...
2)		MOVEI A,0		;YES, SO RETURN 0.


LINE 14, PAGE 72
1)	%S:	MOVE A,COJFN
1)		MOVE B,C
1)		SETZ C,
1)	IFE STANSW,<
1)		JFNS
1)		 ERJMP %S1		;ERROR - CHECK IT OUT
1)		MOVEM A,COJFN		;UPDATE IN CASE BYTE POINTER
1)	>;IFE STANSW
1)	IFN STANSW,<
1)		SKIPN .P		;IN CASE P NEVER SET UP
1)		 MOVEM P,.P		;SAVE P FOR JERR TO RESTORE AS NECESSARY
1)		SKIPN .PP		;SAVE FRAME CONTEXT TOO
1)		 MOVEM .FP,.PP
1)		JFNS%
1)		IFJER.
1)		  CALL JFNSIL		;SPR 14203 ANALYZE ERROR
1)		   JRST JERR		;STRANGE ERROR
1)		ELSE.		
1)		  MOVEM A,COJFN		;UPDATE IN CASE BYTE POINTER
1)		ENDIF.
1)	>;IFN STANSW
1)		RET
1)	
1)	%S1:	CALL JFNSIL 		;ANALYZE THE ERROR
1)		 JRST JERR		;STRANGE ERROR
1)		RET			;"GOOD" ERROR
1)	
LINE 14, PAGE 74
2)	%S:	MOVE A,[POINT 7,LBUFF]	;EM9
2)	;EM9	MOVE A,COJFN
2)		MOVE B,C
2)		SETZ C,
2)		JFNS
2)		 ERJMP [CALL JFNSIL 	;SPR 14203 ANALYZE ERROR
2)			 JRST JERR	;STRANGE ERROR
2)			JRST %S1]	;"GOOD" ERROR
2)		CALL FIXCAS		;EM9
2)	;EM9	MOVEM A,COJFN		;UPDATE IN CASE BYTE POINTER
2)	%S1:	RET
2)	

; SRC:<6-EXEC>EXECSU.MAC.19 & EXECSU.MAC.1 26-Jul-85 0102	PAGE 82




LINE 49, PAGE 72
1)		CAIN A,DESX3		;RESTRICTED JFN ERROR?
1)		 JRST [	TYPE < Restricted JFN>
1)			RETSKP]
1)		TXNN B,GS%NAM		;DOES JFN HAVE NAME?
1)		RET			;NO - JUST RETURN ERROR CODE
1)		CAIN A,GJFX24		;YES - IS THE FILE GONE?
1)		 JRST [	TYPE < Nonexistent file>
LINE 34, PAGE 74
2)		TXNN B,GS%NAM		;DOES JFN HAVE NAME?
2)		RET			;NO, JUST RETURN ERROR CODE
2)		CAIN A,DESX3		;UNASSIGNED JFN ERROR?
2)		 JRST [	TYPE < Restricted JFN>
2)			RETSKP]
2)		CAIN A,GJFX24		;FILE GONE?
2)		 JRST [	TYPE < Nonexistent file>


LINE 51, PAGE 73
1)	IFE STANSW,<
1)		MOVEI C,0		;USE STANDARD BRIEF FORMAT
1)	>;IFE STANSW
1)	IFN STANSW,<
1)		MOVX C,<OT%DAY!OT%NSC!OT%12H>
1)	>;IFN STANSW
1)		ODTIM
LINE 51, PAGE 75
2)		MOVEI C,0		;USE STANDARD BRIEF FORMAT
2)		ODTIM


LINE 21, PAGE 74
1)	IFN STANSW,<
1)		TRNE A,777760		;AC REFERENCE?
1)		IFSKP.			;YES...
1)		  MOVE D,A
1)		  HRRZ A,A		;USE ONLY AC PART OF PC
1)		  CALL LOADF		;READ INSTRUCTION
1)		   JRST %X1		;CAN'T HAPPEN (?)
1)		  ETYPE <%1/ at %4Y (PC = %3Y)>
1)		  JRST %X01
1)		ENDIF.
1)	>;IFN STANSW
1)		CALL LOADF		;GET CONTENTS OF PC
1)		 JRST %X1		;CAN'T READ INSTRUCTION-- DON'T PRINT IT
1)		ETYPE <%1/ at %3Y>
1)	IFN STANSW,<
1)	%X01:
1)	>;IFN STANSW

; SRC:<6-EXEC>EXECSU.MAC.19 & EXECSU.MAC.1 26-Jul-85 0102	PAGE 83


1)		HLRZS A			;GET OPCODE TO SEE IF IT'S A JSYS
LINE 21, PAGE 76
2)		CALL LOADF		;GET CONTENTS OF PC
2)		 JRST %X1		;CAN'T READ INSTRUCTION-- DON'T PRINT IT
2)		ETYPE <%1/ at %3Y>
2)		HLRZS A			;GET OPCODE TO SEE IF IT'S A JSYS


LINE 48, PAGE 74
1)		ETYPE <%_>		;TYPE EOL
1)		SKIPE INDQUS		;IF SET, WE ARE PRINTING "INFO PROG"
1)		JRST %X4		;DONT WANT QUESTION MARK IN COLUMN 1
1)		ETYPE <?%2?>		;NOT SET, PROCEED NORMALLY
1)	%X3:	SETO A,			;ADD LABEL
1)		CALL MAPPF		;UNMAP PAGE
LINE 34, PAGE 76
2)	;**;[735] Replace 2 lines with 5 at %X2:+3L	KR	17-MAY-82
2)		ETYPE <%_>		;[735]TYPE EOL
2)		SKIPE INDQUS		;[735]IF SET, WE ARE PRINTING "INFO PROG",
2)		JRST %X4		;[735] DON'T WANT QUESTION MARK IN FIRST COLUMN
2)		ETYPE <?%2?>		;[735]NOT SET; PROCEED NORMALLY
2)	%X3:	SETO A,			;[735]ADD LABEL
2)		CALL MAPPF		;UNMAP PAGE


LINE 59, PAGE 74
1)	%X4:	ETYPE <   >		;TYPE THREE SPACES FOR EACH FORK-LEVEL
1)		SOJGE Q1,%X4		;Q1, IS SETUP BY FSTAT TO CONTAIN FORK-LEVEL
1)		ETYPE <?%2?>		;FINALLY PRINT FORK'S ERROR MESSAGE
1)		JRST %X3
1)	^L
1)	;ETYPE'S % ROUTINES...
1)	
LINE 46, PAGE 76
2)	;**;[735] Insert 4 lines at %EXPR:-4L	KR	17-MAY-82
2)	%X4:	ETYPE <   >		;[735]TYPE 3 SPACES FOR EACH FORK-LEVEL
2)	;**;[736] Change 1 line at %X4:+1L	KR	1-JUN-82
2)		SOJGE Q1,%X4		;[735][736] Q1 IS SETUP BY FSTAT TO CONTAIN FORK-LEVEL
2)		ETYPE <?%2?>		;[735]FINALLY PRINT FORK'S ERROR MESSAGE
2)		JRST %X3		;[735]RETURN TO NORMAL FLOW
2)	^L
2)	;ETYPE'S %-ROUTINES...
2)	


; SRC:<6-EXEC>EXECSU.MAC.19 & EXECSU.MAC.1 26-Jul-85 0102	PAGE 84



LINE 7, PAGE 75
1)	IFE STANSW,<
1)		JRST %Y			;NO, DO LIKE ADDRESS
1)		MOVE A,C		;YES, GET VALUE
1)	>;IFE STANSW
1)	IFN STANSW,<
1)		IFSKP.
1)		  MOVE A,C		;YES, GET VALUE
1)		ELSE.
1)		  SKIPE B,TRADIX	;IS A RADIX SET?
1)		  CAIN B,^D8		;YES, IS IT OCTAL?
1)		   JRST %NUMS		;NO RADIX OR OCTAL, USE %# PRINTOUT
1)		  MOVE A,COJFN		;STANDARD OUTPUT STREAM
1)		  EXCH B,C		;PUT NUMBER IN B, RADIX IN C
1)		  NOUT%
1)		   CALL JERRC		;PRINT STANDARD MESSAGE
1)		  MOVEM A,COJFN		;UPDATE IN CASE IT'S A BYTE POINTER
1)		  RET
1)		ENDIF.	  
1)	>;IFN STANSW
1)		CALLRET TYPEXP		;PRINT EXPRESSION
LINE 7, PAGE 77
2)		JRST %Y			;NO, DO LIKE ADDRESS
2)		MOVE A,C		;YES, GET VALUE
2)		CALLRET TYPEXP		;PRINT EXPRESSION


LINE 50, PAGE 75
1)	;%Z TYPES "," SPACE SPACE ... SPACE
1)	
1)	%Z:	SKIPN D			;WAS AN AC SPECIFIED?
1)		SETZM C			;NO, OUTPUT COMMA ONLY
1)		CAILE C,%COMN		;.LEQ. MAX COMMAS ?
1)		MOVEI C,%COMN		;NO, USE MAX
1)		MOVE A,COJFN		;STANDARD OUTPUT JFN
1)		HRRO B,COMTAB(C)	;GET POINTER TO STRING
1)		SETZM C			;END ON NULL
1)		SOUT			;OUTPUT STRING
1)		RET			;RETURN
1)	
1)	
1)	COMTAB: [ASCIZ/,/]
1)		[ASCIZ/, /]
1)		[ASCIZ/,  /]
1)		[ASCIZ/,   /]
1)		[ASCIZ/,    /]
1)		[ASCIZ/,     /]
1)		[ASCIZ/,      /]
1)		[ASCIZ/,       /]

; SRC:<6-EXEC>EXECSU.MAC.19 & EXECSU.MAC.1 26-Jul-85 0102	PAGE 85


1)		[ASCIZ/,        /]
1)		%COMN=.-COMTAB
1)	
1)		;%a TYPES OUT AN OCTAL NUMBER IN A 3-DIGIT FIELD
1)	%AA:	MOVE A,COJFN		;GET CURRENT JFN
1)		MOVE B,C		;GET THE NUMBER
1)		MOVE C,[NO%LFL+NO%MAG+NO%ZRO+3B17+10]
1)		NOUT
1)		JFCL			;IGNORE ERRORS
1)		RET
1)	
1)		;%b TYPES OUT CONTENTS OF ATOM BUFFER
1)	%BB:	MOVE A,COJFN		;GET CURRENT JFN
1)		MOVE B,[POINT 7,ATMBUF]
1)		SETZM C
1)		SOUT
1)		RET
1)	;%? TYPES LAST ERROR MESSAGE
LINE 33, PAGE 77
2)	;%? TYPES LAST ERROR MESSAGE


LINE 2, PAGE 77
1)	;SUBROUTINE TO TYPE NUMBER OF SECONDS IN A IN THE FORM H:MM:SS.
LINE 2, PAGE 79
2)	;EM9 Start
2)	;Subroutine to convert an asciz buffer to pleasent lower case. We use the
2)	;following algorithm:
2)	;  The first character is always left alone.
2)	;  The character following any non-alphanumeric is left alone
2)	;  Any other upper case letter is converted to lower case
2)	FIXCAS::MOVE A,[POINT 7,LBUFF]
2)		CALL LOWCAS		;EM28
2)		MOVE A,COJFN
2)		MOVE B,[POINT 7,LBUFF]
2)		SETZ C,
2)		SOUT			;Print the fixed string
2)		MOVEM A,COJFN		;Update in case byte pointer
2)		RET
2)	;EM9 End
2)	
2)	;EM28 Start
2)	;Lower case the buffer pointed to by A, and put it back where we found it
2)	LOWCAS::SKIPE CASFLG		;EM134 Are we doing lowercasing?
2)		 RET			;EM134 Nope - just return
2)		SETO C,			;C FLAGS THAT LAST CHAR WAS NON-ALPHANUM
2)	LOW1:	ILDB B,A		;GET A CHARACTER
2)		JUMPE B,LOWDON		;IF ZERO, ALL DONE
2)		JUMPN C,LOW5		;IF LAST CHAR NON-ALPHANUM, DON'T CHANGE
2)		CAIL B,"A"
2)		 CAILE B,"Z"

; SRC:<6-EXEC>EXECSU.MAC.19 & EXECSU.MAC.1 26-Jul-85 0102	PAGE 86


2)		  JRST LOW3		;NOT UPPER CASE
2)		ADDI B,"a"-"A"		;CONVERT TO UPPER CASE
2)		DPB B,A
2)	LOW2:	SETZ C,
2)		JRST LOW1
2)	LOW3:	CAIL B,"a"
2)		 CAILE B,"z"
2)		  JRST LOW4		;NOT LOWER CASE
2)		JRST LOW2
2)	LOW4:	CAIL B,"0"
2)		 CAILE B,"9"
2)		  JRST LOWCAS		;NOT ALPHANUM
2)		JRST LOW2
2)	LOW5:	CAIL B,"A"
2)		 CAILE B,"Z"
2)		  JRST LOW3
2)		JRST LOW2
2)	LOWDON:	RET
2)	;EM28 End
2)	^L
2)	;SUBROUTINE TO TYPE NUMBER OF SECONDS IN A IN THE FORM H:MM:SS.


LINE 2, PAGE 78
1)	;ROUTINE TO STACK ALL THE AC'S.  THIS IS USEFUL FOR INTERRUPT
LINE 2, PAGE 81
2)	NONEWF,<
2)	;SUBROUTINE CALLED AT RETURN TO COMMAND LOOP, TO DO MAIL WATCH.
2)	; CALLED IFF MWATCF (MAIL WATCH FLAG) IS NON-ZERO.
2)	;"CALL CHKPTY" REMOVED FROM THIS ROUTINE BECAUSE 1) IT WAS CAUSING TWO
2)	;EXTRA JSYS'S TO BE EXECUTED PER EXEC COMMAND AND 2) USER RUNNING UNDER NEWRUN
2)	;OR PTYCON MAY VERY WELL HAVE MAIL BE WATCHED.
2)	
2)	MWATCH::SKIPE CUSRNO		;MUST BE LOGGED IN
2)		SKIPN MAILF		;TIME TO CHECK?
2)		RET			;NO
2)		CALL MINT0		;ENABLE FOR ANOTHER MAIL INTERRUPT
2)		MOVE B,CUSRNO		;GET LOGGED-IN USER NUMBER
2)		CALL MALCHK		;CHECK MY MAIL BOX
2)		 RET			;NO NEW MAIL
2)		TYPE <[You have new mail]
2)	>
2)		RET			;RETURN TO COMMAND LOOP
2)	
2)	;ROUTINE TO ENABLE FOR A TIMER INTERRUPT AT SOME ELAPSED TIME FROM NOW.
2)	;WHEN THE INTERRUPT OCCURS, IT MEANS THAT MAIL SHOULD BE CHECKED.
2)	
2)	MINT0::	SETZM MAILF		;SAY NO INTERRUPT YET
2)		GTAD			;GET CURRENT TIME AND DATE
2)		MOVX B,MWATCI		;GET INCREMENT
2)		ADD B,A			;CALCULATE WHEN TO INTERRUPT

; SRC:<6-EXEC>EXECSU.MAC.19 & EXECSU.MAC.1 26-Jul-85 0102	PAGE 87


2)		MOVEM B,MALWEN		;REMEMBER WHEN
2)		MOVE A,[.FHSLF,,.TIMDT]	;SAY TO INTERRUPT AT EXACT TIME
2)		MOVEI C,MALCHN		;USE MAIL CHANNEL
2)		TIMER			;ENABLE FOR INTERRUPT
2)		 ETYPE <
2)	%%Unexpected MAIL-WATCH failure, mail no longer being watched - %?
2)	>
2)		RET
2)	> ; NONEWF
2)	;ROUTINE TO STACK ALL THE AC'S.  THIS IS USEFUL FOR INTERRUPT


LINE 2, PAGE 79
1)	;NEW MAIL WATCH SUBROUTINE - CAN BE CALLED FROM EITHER INTERRUPT LEVEL
LINE 2, PAGE 82
2)	NONEWF,<
2)	;SUBROUTINE USED BY MAIL WATCH LOGIC AND INFO MAIL COMMAND
2)	;CALLED WITH B CONTAINING THE USER NUMBER
2)	;SKIP RETURNS IF THAT DIRECTORY'S MAIL.TXT EXISTS AND HAS NEW STUFF.
2)	;NON-SKIP IF NO NEW MAIL (A=0) OR CANNOT TELL (A=-1).
2)	
2)	MALCHK::STKVAR <MALUSR,<MALBFR,FILWDS>>
2)		MOVEM B,MALUSR		;SAVE USER NUMBER
2)		HRROI A,MALBFR		;SPACE TO CREATE FILENAME
2)		HRROI B,[ASCIZ /PS:</]	;MUST BE ON PS:
2)		MOVEI C,0
2)		SOUT
2)		MOVE B,MALUSR		;RESTORE USER NUMBER
2)		DIRST			;ADD USER NAME
2)		 CALL JERR		;NO SUCH DIRECORY. SHOULDN'T HAPPEN
2)		HRROI B,[ASCIZ />MAIL.TXT.1/]
2)		MOVEI C,0
2)		SETO Q1,		;NO JFN YET
2)		SOUT			;FINISH FILE NAME
2)		MOVX A,GJ%OLD+GJ%DEL+GJ%SHT ;OLD,DELETED AND SHORT FORM
2)		HRROI B,MALBFR		;POINT TO FILE NAME
2)		CALL GTJFS		;GET AND STACK JFN
2)		 JRST MALCH2		;FAILED
2)		HRRZ Q1,A		;SAVE THE JFN IN MORE PERMANENT AC
2)		MOVE B,[1,,.FBCTL]	;ANALYZE THE FILE
2)		MOVEI C,C
2)		CALL $GTFDB		;SEE IF IT IS DELETED
2)		 JRST MALCHP		;PROTECTED
2)		TXNE C,FB%DEL		;DELETED?
2)		JRST MALCHM		;YES. NO NEW MAIL
2)		MOVE B,[1,,.FBSIZ]	;NOT DELETE.  GET SIZE
2)		MOVEI C,C
2)		CALL $GTFDB		;GET SIZE
2)		 JRST MALCHP		;PROTECTED
2)		JUMPLE C,MALCHM		;IF EMPTY.  NO MAIL
2)		MOVE B,[1,,.FBWRT]	;NOT EMPTY GET WRITE DATE

; SRC:<6-EXEC>EXECSU.MAC.19 & EXECSU.MAC.1 26-Jul-85 0102	PAGE 88


2)		MOVEI C,D		;PUT WRITE DATE IN D
2)		CALL $GTFDB
2)		 JRST MALCHP		;PROTECTED
2)		MOVE B,[1,,.FBREF]	;GET LAST REFERENCE DATE
2)		MOVEI C,C
2)		CALL $GTFDB
2)		 JRST MALCHP		;PROTECTED
2)		CAML C,D		;WRITTEN LATELY?
2)		JRST MALCHM		;NO.  NO MAIL
2)		RETSKP
2)	^L
2)	;... MALCHK CONTINUED
2)	
2)	MALCH2:	CAIN A,GJFX24		;SPECIFIC FILE NOT FOUND
2)		JRST MALCHM		;RIGHT. NO NEW MAIL
2)		CAIL A,GJFX16		;RANGE FOR NOT FOUND
2)		CAILE A,GJFX20		;..
2)		JRST MALCHP		;SAY DON'T KNOW ABOUT MAIL
2)	MALCHM:	TDZA A,A		;MAIL REALLY NOT THERE
2)	MALCHP:	SETO A,			;CAN'T TELL IF MAIL IS THERE
2)		RET
2)	> ; NONEWF
2)	^L
2)	NEWF,<
2)	;NEW MAIL WATCH SUBROUTINE - CAN BE CALLED FROM EITHER INTERRUPT LEVEL


LINE 46, PAGE 79
1)		TLNN B,77		;NETWORKS
1)		TYPE <net>
1)		ETYPE <mail %1\]%_>
LINE 47, PAGE 84
2)		JUMPE A,[ETYPE <new mail]%_> ;CM317
2)			 JRST MWATC4]	;CM317
2)		TYPE <new >		;CM317
2)	;CM236	TLNN B,77		;NETWORKS
2)	;CM236	TYPE <net>
2)		ETYPE <mail %1\]%_>


LINE 14, PAGE 80
1)	IFE STANSW,<
1)		HRROI B,[ASCIZ "POBOX:<"] ;>
1)	>;IFE STANSW
1)	IFN STANSW,<
1)		HRROI B,[ASCIZ "PS:<"]	;>
1)	>;IFN STANSW
1)		MOVEI C,0
LINE 14, PAGE 85
2)		HRROI B,[ASCIZ "PS:<"]
2)		MOVEI C,0

; SRC:<6-EXEC>EXECSU.MAC.19 & EXECSU.MAC.1 26-Jul-85 0102	PAGE 89




LINE 48, PAGE 80
1)		HRROI B,MALBUF		;ASSUME LOCAL MAIL (-1,,MALBUF)
1)		SKIPA A,[POINT 7,MALBUF]
LINE 43, PAGE 85
2)		MOVSI A,(BYTE(7) 177,0)	;CM317 See if it is omitted
2)		CAMN A,MALBUF		;CM317
2)		TDZA B,B		;CM317 It is
2)		HRROI B,MALBUF		;ASSUME LOCAL MAIL (-1,,MALBUF)
2)	REPEAT 0,<			;CM236 *** Begin deletion ***
2)		SKIPA A,[POINT 7,MALBUF]


LINE 56, PAGE 80
1)	MALLCL:	MOVEI A,(Q1)		;JFN TO RELEASE
1)		RLJFN
1)		 CALL JERR		;BITCH ABOUT IT
1)		GTAD			;GET D/T NOW
LINE 55, PAGE 85
2)	>;REPEAT 0			;CM236 *** End deletion ***
2)	MALLCL:	MOVEI A,(Q1)		;JFN TO RELEASE
2)		RLJFN
2)		 CALL JERR		;BITCH ABOUT IT
2)		JUMPE B,[SETZ A,	;CM317
2)			 RETSKP]	;CM317
2)		GTAD			;GET D/T NOW


LINE 64, PAGE 80
1)		HRROI A,[ASCIZ "from %2M at %3\%%4E%"] ;TIME
1)		RETSKP			;GOOD RETURN
LINE 66, PAGE 85
2)		HRROI A,[ASCIZ "from %2M at %3\%%4E%"] ;CM236 (Allow % in from string)
2)		RETSKP			;GOOD RETURN


LINE 2, PAGE 82
1)	
LINE 2, PAGE 87
2)	; STILL IN NEWF
2)	


; SRC:<6-EXEC>EXECSU.MAC.19 & EXECSU.MAC.1 26-Jul-85 0102	PAGE 90



LINE 31, PAGE 82
1)	
1)	^L
LINE 32, PAGE 87
2)	> ; NEWF
2)	^L


LINE 31, PAGE 83
1)	DGFRKS::
1)	IFN STANSW,<
1)		MOVEI A,.FHTOP		;DO EVERYTHING
1)		TXNN Z,F2		;IF THAT WAS CHOSEN
1)	>;IFN STANSW
1)		MOVEI A,.FHSLF		;SAY START AT SELF
1)		LDF B,GF%GFH+GF%GFS	;ASSIGN FORK HANDLES, GET STATUS
LINE 31, PAGE 88
2)	DGFRKS::MOVEI A,.FHSLF		;SAY START AT SELF
2)		LDF B,GF%GFH+GF%GFS	;ASSIGN FORK HANDLES, GET STATUS


LINE 1, PAGE 84
1)	^L
1)	IFN STANSW,<
1)	;TTYINI ROUTINE TO SET TERMINAL PARAMETERS CALLED FROM EXEC0
1)	
1)	;FOR THE TIME BEING USE THESE SWITCHES TO SELECT STYLE OF TTYINI.
1)	;LAST ONE TO CONVERT SHOULD FLUSH THE SWITCHES AND THIS COMMENT.
1)	
1)	FTOLD==SUMXSW				;OLD STYLE JQJ TTYINI
1)	FTNEW==GSBSW!LOTSW!SIERSW!CSLISW	;NEW STYLE RMK TTYINI
1)	
1)	IFE SCORSW!NICSW,<		;[NIC1023] ADD ON NICSW
1)	B%TTYT==0			;OFFSET OF TERMINAL TYPE
1)	B%DEFT==1			;OFFSET OF DEFAULT TERMINAL TYPE
1)	B%LENG==2			;OFFSET OF TERMINAL LENGTH
1)	IFN FTOLD,<
1)	B%BITS==16			;OFFSET OF FIRST FLAG WORD (THERE ARE TWO)
1)	B%PRIN==20			;OFFSET OF DEFAULT PRINT NODE (DECNET NODE)
1)	>;IFN FTOLD
1)	IFN FTNEW,<
1)	B%BITS==24			;OFFSET OF FIRST FLAG WORD (THERE ARE TWO)
1)	B%PRIN==26			;OFFSET OF DEFAULT PRINT NODE (DECNET NODE)
1)	>;IFN FTNEW
1)	B%REFU==1B11			;FLAG - REFUSE SYSTEM MESSAGES
1)	
1)	IFN FTNEW,<
1)	;ADDRESSES IN FIRST PAGE OF TTYINI.NET-BIN
1)	BLKSIZ==FREE+1			;SIZE OF EACH TTYINI BLOCK

; SRC:<6-EXEC>EXECSU.MAC.19 & EXECSU.MAC.1 26-Jul-85 0102	PAGE 91


1)	NETADS==FREE+2			;TABLE OF PAGE INDEXES FOR EACH NET
1)	
1)	;ADDRESSES IN NET PAGES OF TTYINI.NET-BIN
1)	HSTADS==FREE			;TABLE OF PAGE INDEXES FOR EACH HOST ON NET
1)	
1)	;ADDRESSES IN HOST PAGES OF TTYINI.NET-BIN
1)	NUMTTY==FREE			;NUMBER OF TTYS ON THIS HOST
1)	TTYBLK==FREE+1			;START OF TTYINI INFORMATION
1)	>;IFN FTNEW
1)	
1)	TTYINI::CALL PIOFF		;TURN OFF INTERRRUPTS FOR TERMINAL TYPE SETTING
1)		SKIPN CUSRNO		;IF LOGGED IN
1)		 CALL CHKPTY		;OR ON A PTY
1)		IFSKP.
1)		  GJINF%		;GET JOB INFORMATION
1)		  IFGE. D		;IF NOT DETACHED...
1)	IFN FTOLD,<
1)		    STKVAR <TTYJFN,TTYNUM,TTYPAG> ;DECLARE LOCAL STORAGE
1)		    MOVEM D,TTYNUM	;ELSE SAVE TERMINAL NUMBER
1)		    MOVX A,GJ%SHT+GJ%OLD	;SHORT FORM, OLD FILE
1)	 	    HRROI B,[ASCIZ/SYSTEM:TTYINI.BIN/] ;WHAT WE ARE LOOKING FOR
1)		    GTJFN%		;GET A HANDLE ON THE FILE
1)		    IFNJE.
1)		      MOVEM A,TTYJFN	;STASH JFN IN D
1)		      MOVX B,OF%RD	;FULL WORD, READ ACCESS
1)		      OPENF%		;OPEN THE FILE
1)		      IFJER.
1)		        RLJFN%		;PUNT THIS IF CAN'T OPEN IT.
1)		         JFCL
1)		      ELSE.
1)			SIZEF%		;GET FILE SIZE
1)			IFJER.
1)			  CALL TTYIX0	;SOME ERROR, SET DEFAULT TERMINAL TYPE.
1)			ELSE.
1)			  MOVEM C,TTYPAG	;STORE PAGE COUNT FOR LATER
1)			  HRLZ A,TTYJFN	;JFN,,PAGE
1)			  MOVE B,[XWD .FHSLF, FREE/1000] ;FORK HANDLE,,FORK PAGE
1)			  HRLI C,(PM%CNT+PM%RD)	;ACCESS,,PAGE COUNT
1)			  PMAP%		;MAP THE FILE
1)			  IFJER.
1)			    CALL TTYIX0	;SOME ERROR, SET DEFAULT TERMINAL TYPE.
1)			  ELSE.
1)			    MOVE D,TTYNUM	;FETCH TERMINAL NUMBER
1)			    IMUL D,FREE+1	;MULTIPLY TIMES LENGTH OF ONE RECORD
1)			    ADDI D,FREE	;ADD PAGE ADDRESS TO GET RECORD ADDRESS IN D
1)			    SKIPG B,B%TTYT(D)	;FETCH TERMINAL TYPE
1)			    SKIPL B,B%DEFT(D)	;ZERO OR NONE SET, TRY DEFAULT INSTEAD
1)			    IFSKP.
1)			      MOVEI B,.TTADM	;NO DEFAULT SET, USE ADM-3
1)			    ENDIF.
1)			    MOVEI A,.PRIOU	;TERMINAL

; SRC:<6-EXEC>EXECSU.MAC.19 & EXECSU.MAC.1 26-Jul-85 0102	PAGE 92


1)			    STTYP%	;SET THE TERMINAL TYPE
1)			     ERJMP .+1	;DON'T BOMB ON ERRORS
1)			    MOVX B,.MOSLL	;SETTING LINE LENGTH
1)			    SKIPL C,B%LENG(D)	;GET LINE LENGTH IF ANY GIVEN
1)			     MTOPR%	;SET TERMINAL LINE LENGTH
1)			      ERJMP .+1	;IGNORE ANY POSSIBLE ERRORS
1)	IFN LOTSW,<
1)			    SKIPE A,B%PRIN(D)	;FETCH FIRST WORD OF NODE STRING
1)			    CAMN A,[-1]	;NOT SET?
1)		 	    IFSKP.
1)			      SETO A,		;-1 FOR CURRENT JOB
1)			      MOVX B,.SJLLO	;FUNCTION CODE IS SET LOCATION
1)			      HRROI C,B%PRIN(D)	;POINTER TO NODE NAME
1)			      SETJB%	;SET JOB LOCATION
1)			       ERJMP .+1	;DON'T BOMB ON ERRORS
1)			    ELSE.		
1)			      CALL FREINI	;INITIALIZE FREE SPACE
1)			      CALL GETNOD	;GET LOCAL NODE NAME
1)			      IFSKP.
1)				MOVE C,A	;POINTER TO NODE NAME
1)				SETO A,		;-1 FOR CURRENT JOB
1)				MOVX B,.SJLLO	;FUNCTION CODE IS SET LOCATION
1)				SETJB%		;SET JOB LOCATION
1)				 ERJMP .+1	;DON'T BOMB ON ERRORS
1)			      ENDIF.
1)			    ENDIF.
1)	>;IFN LOTSW
1)			    MOVE D,B%BITS(D)	;GET FIRST FLAG WORD, CLOBBER TTY NUM
1)			    IFXN. D,B%REFU	;REFUSE SYSTEM MESSAGES DESIRED?
1)			      MOVX A,.CTTRM
1)			      MOVEI B,.MOSNT
1)			      MOVEI C,.MOSMN
1)			      MTOPR%	;REFUSE SYSTEM MESSAGES
1)			       ERJMP .+1
1)			    ENDIF.
1)			    SETO A,	;-1 TO UNMAP
1)			    MOVE B,[XWD .FHSLF, FREE/1000] ;FORK,,PAGE
1)			    MOVX C,PM%CNT	;REPEAT COUNT
1)			    HRR C,TTYPAG	;NUMBER OF PAGES
1)			    PMAP%	;UNMAP THESE PAGES
1)			    SKIPN BATCHF	;RUNNING BATCH?
1)			     CALL BLANK1	;NO, CLEAR THE SCREEN
1)			  ENDIF.		
1)			ENDIF.
1)			MOVE A,TTYJFN	;FETCH JFN
1)			CLOSF%		;CLOSE THE FILE
1)			IFJER.
1)			  MOVE A,TTYJFN	;TRY RELEASING IT ON ERROR.
1)			  RLJFN%
1)			   JFCL
1)			ENDIF.

; SRC:<6-EXEC>EXECSU.MAC.19 & EXECSU.MAC.1 26-Jul-85 0102	PAGE 93


1)		      ENDIF.
1)		    ENDIF.
1)	>;IFN FTOLD
1)	IFN FTNEW,<
1)		    MOVE A,D		;GET TERMINAL NUMBER
1)		    CALL SETTTY		;GET NET, HOST AND LINE NUMBER FOR IT
1)		    CALL GETTTY		;GET THE POINTER TO TTYINI BLOCK FOR IT
1)		    IFSKP.
1)		      MOVE D,A		;GET POINTER TO TTYINI BLOCK
1)		      SKIPG B,B%TTYT(D)	;FETCH TERMINAL TYPE
1)		      SKIPL B,B%DEFT(D)	;ZERO OR NONE SET, TRY DEFAULT INSTEAD
1)		      IFSKP.
1)		        MOVEI B,.TTADM	;NO DEFAULT SET, USE ADM-3
1)		      ENDIF.
1)		      MOVEI A,.PRIOU	;TERMINAL
1)		      STTYP%		;SET THE TERMINAL TYPE
1)		       ERJMP .+1	;DON'T BOMB ON ERRORS
1)		      MOVX B,.MOSLL	;SETTING LINE LENGTH
1)		      SKIPL C,B%LENG(D)	;GET LINE LENGTH IF ANY GIVEN
1)		       MTOPR%		;SET TERMINAL LINE LENGTH
1)			ERJMP .+1	;IGNORE ANY POSSIBLE ERRORS
1)		      SKIPE A,B%PRIN(D)	;FETCH FIRST WORD OF NODE STRING
1)		      CAMN A,[-1]	;NOT SET?
1)		      IFSKP.
1)		        SETO A,		;-1 FOR CURRENT JOB
1)		        MOVX B,.SJLLO	;FUNCTION CODE IS SET LOCATION
1)		        HRROI C,B%PRIN(D)	;POINTER TO NODE NAME
1)		        SETJB%		;SET JOB LOCATION
1)		         ERJMP .+1	;DON'T BOMB ON ERRORS
1)		      ELSE.
1)			CALL FREINI	;INITIALIZE FREE SPACE
1)			CALL GETNOD	;GET LOCAL NODE NAME
1)			IFSKP.
1)			  MOVE C,A	;POINTER TO NODE NAME
1)			  SETO A,	;-1 FOR CURRENT JOB
1)			  MOVX B,.SJLLO ;FUNCTION CODE IS SET LOCATION
1)			  SETJB%	;SET JOB LOCATION
1)			   ERJMP .+1	;DON'T BOMB ON ERRORS
1)			ENDIF.
1)		      ENDIF.
1)		      MOVE D,B%BITS(D)	;GET FIRST FLAG WORD, CLOBBER TTY NUM
1)		      IFXN. D,B%REFU	;REFUSE SYSTEM MESSAGES DESIRED?
1)		        MOVX A,.CTTRM
1)		        MOVEI B,.MOSNT
1)		        MOVEI C,.MOSMN
1)		        MTOPR%		;REFUSE SYSTEM MESSAGES
1)		         ERJMP .+1
1)		      ENDIF.
1)		    ELSE.
1)		      CALL TTYIX0	;SET THE TERMINAL TYPE TO ADM IF NOT IN TTYINI
1)		    ENDIF.	

; SRC:<6-EXEC>EXECSU.MAC.19 & EXECSU.MAC.1 26-Jul-85 0102	PAGE 94


1)		    SKIPN BATCHF	;RUNNING BATCH?
1)		     CALL BLANK1	;NO, CLEAR THE SCREEN
1)	>;IFN FTNEW
1)		  ENDIF.
1)		ENDIF.
1)		CALL PION		;TURN CTRL-C BACK ON
1)		RET			;RETURN TO CALLER
1)	
1)	
1)	;SUBROUTINE FOR ERRORS ON SIZEF% AND PMAP%, ABOVE.
1)	TTYIX0:	MOVEI A,.PRIOU		;A/ CONTROLLING TERMINAL
1)		MOVEI B,.TTADM		;B/ DEFAULT TO ADM-3
1)		STTYP%			;SET THE TERMINAL TYPE
1)		 ERJMP .+1
1)		RET
1)	^L
1)	IFN FTNEW,<
1)	;SETTTY - SET NETWORK ADDRESS FOR A TERMINAL.
1)	;CALL:	A/  LOCAL TTY NUMBER
1)	;RETURNS:
1)	;	+1 WITH:
1)	;		A/  NET NUMBER FOR NET TTY IS ON
1)	;		B/  HOST NUMBER FOR HOST TTY IS ON
1)	;		C/  LINE NUMBER
1)	;BLASTS A-D.
1)	
1)	SETTTY: ACVAR <TIPADR,TIPLIN,LINNUM>	; TIPLIN IS THE LINE NUMBER ON THE TIP.
1)		STKVAR <<TEMP,10>>	; TEMPORARY FOR PUPNM%
1)		SETZM TIPADR		; SHOW WE ARE NOT ON A TIP.
1)		MOVEM A,LINNUM
1)		CAML A,PUPLOW		; IN RANGE?
1)		CAML A,PUPHGH
1)		 JRST SETTT0		; NO, GET LOCAL NET AND HOST NUMBERS
1)		SUB A,PUPLOW		; CONVERT TTY NUMBER TO NVTPUP INDEX.
1)		HRLS A
1)		HRR A,$NVTPUP
1)		GETAB%			; GET THE ENTRY FROM NVTPUP FOR THIS NVT.
1)		 ERJMP SETTT0		; IF IT DIDN'T WORK, GO DO LOCAL
1)		HRLS A			; SAVE THE PORT NUMBER.
1)		HRR A,$PUPFPT		; GET TABLE NUMBER FOR PUPFPT.
1)		GETAB%			; GET THE FOREIGN PORT ADDRESS INFORMATION.
1)		 ERJMP SETTT0
1)		JUMPE A,SETTT0		; IF PORT IS ZERO, DO LOCAL
1)		HRRZS A			; OTHERWISE, ISOLATE TABLE ADDRESS.
1)		SUB A,PUPBUF		; MAKE INDEX INTO PUPBUF.
1)		HRLI B,2(A)		; INDEX TO SECOND WORD OF NET ADDRESS.
1)		HRLI A,1(A)		; INDEX TO NET ADDRESS FOR THIS FOREIGN PORT
1)		HRR A,$PUPBUF		; GET PUPBUF TABLE NUMBER
1)		GETAB%			; GET FIRST WORD OF NET ADDRESS
1)		 JRST SETTT0
1)		MOVEM A,TIPADR		; SAVE IT.

; SRC:<6-EXEC>EXECSU.MAC.19 & EXECSU.MAC.1 26-Jul-85 0102	PAGE 95


1)		MOVEM A,TEMP		; SET UP FOR PUPNM%.
1)		SETZM 1+TEMP		; FLUSH SOCKET INFORMATION.
1)		MOVE A,B		; GET THE SOCKET INFORMATION.
1)		HRR A,$PUPBUF
1)		GETAB%
1)		 NOP
1)		ANDI A,77		; FLUSH MOST OF THE JUNK, JUST WANT THE LINE.
1)		MOVEM A,TIPLIN		; SAVE IT.
1)		HRROI A,TEMP		; PUT ASCIZ ADDRESS THERE
1)		HRRZ B,A
1)		TXO B,PN%FLD
1)		PUPNM%
1)		 ERJMP SETTT0
1)		MOVE B,TEMP
1)		TLZ B,201004		;UPPERCASE FIRST THREE LETTERS
1)		CAML B,[ASCIZ/TIP-/]	; IS IT?
1)		 CAML B,[ASCIZ/TIP./]
1)		  SETZM TIPLIN		; NO, ALWAYS USE PORT 0
1)		HLRZ A,TIPADR		; GET THE NET NUMBER
1)		HRRZ B,TIPADR		; GET THE HOST NUMBER
1)		HRRZ C,TIPLIN		; SET THE LINE.
1)		RET
1)	
1)	SETTT0:	CALL GETLNH		; GET LOCAL NET AND HOST NUMBERS.
1)		MOVE C,LINNUM
1)		RET
1)		ENDAV.
1)	^L
1)	;GETTTY - GET POINTER TO TTYINI DATA BLOCK FOR A TERMINAL.
1)	;CALL:	A/  NET NUMBER TERMINAL IS ON
1)	;	B/  HOST NUMBER TERMINAL IS ON
1)	;	C/  LINE NUMBER TERMINAL IS ON
1)	;RETURNS:
1)	;	+1:  TERMINAL IS NOT IN TTYINI.BIN
1)	;	+2:  TERMINAL IS IN TTYINI.BIN:
1)	;		A/  POINTER TO TTYINI BLOCK FOR TERMINAL
1)	 
1)	GETTTY:	ACVAR <NETNUM,HSTNUM,LINNUM,TTYSIZ,TTYJFN>
1)		MOVEM A,NETNUM		;SAVE PARAMETERS.
1)		MOVEM B,HSTNUM
1)		MOVEM C,LINNUM
1)		MOVX A,GJ%SHT+GJ%OLD	;SHORT FORM, OLD FILE
1)		HRROI B,[ASCIZ/FINGER:TTYINI.NET-BIN/]
1)		GTJFN%			;GET A HANDLE ON THE FILE
1)		 RET			;PUNT IF LOSING
1)		MOVEM A,TTYJFN		;STASH JFN
1)		MOVX B,OF%RD		;FULL WORD, READ ACCESS
1)		OPENF%			;OPEN THE FILE
1)		IFJER.
1)		  RLJFN%		;PUNT THIS IF CAN'T OPEN IT.
1)		   JFCL

; SRC:<6-EXEC>EXECSU.MAC.19 & EXECSU.MAC.1 26-Jul-85 0102	PAGE 96


1)		  RET
1)		ENDIF.
1)	GETTT0:	HRLZ A,TTYJFN		;GET FIRST PAGE OF FILE
1)		MOVE B,[XWD .FHSLF,FREE/1000]
1)		MOVX C,PM%RD
1)		PMAP%
1)		IFJER.
1)		  MOVE A,TTYJFN
1)		  CALL TTYCLS		;FLUSH THE FILE
1)		  RET			;RETURN NOT FOUND
1)		ENDIF.
1)		MV. BLKSIZ,TTYSIZ	;SAVE THE SIZE OF TTYINI BLOCKS
1)		SKIPLE D,NETADS(NETNUM)	;IS THERE AN ENTRY FOR THIS TERMINAL'S NET?
1)		IFSKP.			;NO.
1)		  MOVE A,TTYJFN
1)		  CALL TTYUNM		;FLUSH THE FILE
1)		  RET			;RETURN NOT FOUND
1)		ENDIF.
1)		SETOM A			;YES, UNMAP FIRST PAGE OF FILE
1)		PMAP%
1)		IFJER.
1)		  MOVE A,TTYJFN
1)		  CALL TTYUNM		;FLUSH THE FILE
1)		  RET			;RETURN NOT FOUND
1)		ENDIF.
1)		HRL A,TTYJFN		;MAP THE PAGE FOR THIS NETWORK
1)		HRR A,D
1)		PMAP%
1)		IFJER.
1)		  MOVE A,TTYJFN
1)		  CALL TTYUNM		;FLUSH THE FILE
1)		  RET			;RETURN NOT FOUND
1)		ENDIF.
1)		SKIPLE D,HSTADS(HSTNUM)	;IS THERE AN ENTRY FOR TERMINAL'S HOST?
1)		IFSKP.			;NO.
1)		  MOVE A,TTYJFN
1)		  CALL TTYUNM		;FLUSH THE FILE
1)		  RET			;RETURN NOT FOUND
1)		ENDIF.
1)		SETOM A			;YES, UNMAP THIS PAGE AND GET HOST PAGE(S)
1)		PMAP%
1)		TLNN D,-1		;IS THIS A POINTER TO ANOTHER HOST?
1)		IFSKP.			; (LEFT HALF NONZERO POSITIVE)
1)		  HLRZM D,NETNUM	;SAVE THE NEW NET NUMBER
1)		  HRRZM D,HSTNUM	;AND HOST NUMBER
1)		  JRST GETTT0		;GO TRY THIS ONE
1)		ENDIF.
1)		HRL A,TTYJFN
1)		HRR A,D
1)		TXO C,PM%CPY
1)		PMAP%

; SRC:<6-EXEC>EXECSU.MAC.19 & EXECSU.MAC.1 26-Jul-85 0102	PAGE 97


1)		IFJER.
1)		  MOVE A,TTYJFN
1)		  CALL TTYCLS		;FLUSH THE FILE
1)		  RET			;RETURN NOT FOUND
1)		ENDIF.
1)		MOVE C,FREE		;TOUCH THE PAGE
1)		MOVEM C,FREE
1)		MOVE C,NUMTTY		;GET NUMBER OF TTYS ON THIS HOST
1)		IMUL C,TTYSIZ		;TIMES THE WORDS PER BLOCK
1)		AOS C			;PLUS TERMINAL COUNTER
1)		LSH C,-^D9		;MAKE A COUNT
1)		IFN. C			;IF MORE THAN ONE PAGE, GET THE REST
1)		  TXO C,PM%CNT!PM%RD!PM%CPY
1)		  AOS A			;...BUMP PAGE NUMBERS
1)		  AOS B
1)		  PMAP%			;MAP THEM
1)		  IFJER.
1)		    MOVE A,TTYJFN
1)		    CALL TTYCLS		;FLUSH THE FILE
1)		    RET			;RETURN NOT FOUND
1)		  ENDIF.
1)		  HRRZS C		;FLUSH ACCESS BITS
1)		  MOVEI A,FREE+1000	;POINT TO FIRST PAGE MAPPED
1)		  DO.
1)		    MOVE B,(A)		;TOUCH EACH PAGE
1)		    MOVEM B,(A)
1)		    ADDI A,1000
1)		    SOJG C,TOP.
1)		  ENDDO.
1)		ENDIF.
1)		MOVE A,TTYJFN		;FLUSH THE JFN
1)		CALL TTYCLS
1)		MOVE A,LINNUM
1)		IMUL A,TTYSIZ		;MULTIPLY LINE NUMBER TIMES LENGTH OF BLOCK
1)		ADDI A,TTYBLK		;ADD ADDRESS TO GET RECORD ADDRESS IN LINNUM
1)		ENDAV.
1)		RETSKP
1)	^L
1)	;TTYUNM, TTYCLS - CLOSE TTYINI.NET-BIN
1)	;CALL:	A/  JFN OF TTYINI.NET-BIN
1)	;RETURNS:  +1, FILE CLOSED.
1)	
1)	TTYUNM:	PUSH P,A
1)		SETO A,			;-1 TO UNMAP
1)		MOVE B,[XWD .FHSLF,FREE/1000]	;FORK,,PAGE
1)		PMAP%			;UNMAP THEM.
1)		POP P,A
1)	TTYCLS:	MOVE B,A
1)		CLOSF%
1)		IFJER.			;IF LOSSAGE, RELEASE IT.
1)		  MOVE A,B

; SRC:<6-EXEC>EXECSU.MAC.19 & EXECSU.MAC.1 26-Jul-85 0102	PAGE 98


1)		  RLJFN%
1)		   JFCL
1)		ENDIF.
1)		RET
1)	^L
1)	;GETLNH - GET LOCAL NET AND HOST NUMBER
1)	;RETURNS:	A/  NET NUMBER
1)	;		B/  HOST NUMBER
1)	GETLNH:	MOVE A,['PUPROU']	;GET THE TABLE NUMBER AND NUMBER OF ENTRIES
1)		SYSGT%
1)		MOVE D,B		;GET TABLE NUMBER
1)		HLLZS B			;ZERO NET INDEX
1)		DO.
1)		  HRL A,B		;GET TABLE INDEX
1)		  HRR A,D		;GET TABLE NUMBER
1)		  GETAB%
1)		  IFNJE.
1)		    IFGE. A		;IS THIS AN INACCESSIBLE NET?
1)		      HRRZS A		;NO, GET POSSIBLE HOST NUMBER.
1)		      IFN. A		;THERE IS A HOST?
1)			HRRZI B,1(B)	;YES, MAKE NET NUMBER.
1)			EXCH A,B	;RETURN NET AND HOST IN CORRECT ACS.
1)			RET
1)		      ENDIF.
1)		    ENDIF.
1)		    AOBJN B,TOP.
1)		  ENDIF.
1)		ENDDO.
1)		SETZB A,B		;RETURN 0 FOR NET/HOST ON FAILURE
1)		RET
1)	>;IFN FTNEW
1)	>;IFE SCORSW!NICSW		;[NIC1023] ADD ON NICSW
1)	IFN SCORSW!NICSW,<		;[NIC1023] ADD ON NICSW
1)	TTYINI::CALL PIOFF		;TURN OFF INTERRRUPTS FOR TERMINAL TYPE SETTING
1)		SKIPN CUSRNO		;IF LOGGED IN
1)		CALL CHKPTY		;OR ON A PTY
1)		IFSKP.			;WE AREN'T LOGGED IN OR ON A PTY...
1)		  MOVX A,CR%CAP		;RUN TTYINI AT STARTUP
1)		  CFORK%
1)		  IFNJE.
1)		    RPCAP%		;GET CAPS WE GAVE IT
1)		    TXZ B,.RHALF	;ABSOLUTELY NO RIGHT HALF CAPABILITIES
1)		    SETZ C,		;AND NOTHING ENABLED BY DEFAULT
1)		    EPCAP%		;SET THOSE CAPS
1)		    MOVEI D,(A)
1)		    MOVX A,GJ%OLD!GJ%SHT
1)		    HRROI B,[ASCIZ/SYS:TTYINI.EXE/]
1)		    GTJFN%
1)		    IFJER.
1)		      MOVEI A,(D)	;NO PROGRAM, FLUSH
1)		    ELSE.

; SRC:<6-EXEC>EXECSU.MAC.19 & EXECSU.MAC.1 26-Jul-85 0102	PAGE 99


1)		      HRLI A,(D)
1)		      GET%
1)		      MOVEI A,(D)
1)		      SETZ B,
1)		      SFRKV%
1)		      WFORK%
1)		    ENDIF.
1)		    KFORK%
1)		  ENDIF.
1)		  SKIPN BATCHF		;RUNNING BATCH?
1)		   CALL BLANK1		;CLEAR SCREEN
1)		ENDIF.
1)		CALLRET PION		;TURN INTERRUPTS BACK ON AND RETURN
1)	>;IFN SCORSW!NICSW		;[NIC1023] ADD ON NICSW
1)	>;IFN STANSW
1)	
1)	MSKLB:	1B9+1B10+1B13		;TAB AND CR/LF ARE BREAK MASK
1)		1B0			;SPACE IS BREAK MASK
1)		0
1)		0
1)	
1)	;BITS+N CONTAINS A WORD WITH A 1 IN BIT N
LINE 104, PAGE 88
2)	;BITS+N CONTAINS A WORD WITH A 1 IN BIT N


LINE 75, PAGE 89
1)	XEND==:.	;MUST BE LAST LOCATION OF EXEC!
1)	
LINE 110, PAGE 88
2)	XEND==:.			;MUST BE LAST LOCATION OF EXEC !!!!!
2)	
