;<EXEC.CMU>EXEC1.MAC.21,  4-Apr-85 21:54:55, Edit by VAF
;CS146 Changes for new fascist password policy.
;<EXEC.CMU>EXEC1.MAC.20,  4-Apr-85 21:33:03, Edit by VAF
;CS122 Print last login time at CC also
;<EXEC.CMU>EXEC1.MAC.19, 12-Mar-85 22:17:16, Edit by VAF
;EM32  Merge: fix LOGOUT/QUIET option at CC.
;<EXEC.CMU>EXEC1.MAC.18,  7-Nov-84 16:52:35, Edit by VAF
;CS131 Fix bug introduced by previous edit.
;<EXEC.CMU>EXEC1.MAC.17, 30-Oct-84 11:24:48, Edit by VAF
;CS131 Turn on backspace-means-delete in MKPLAN so Unix losers don't put
;      bogus ^H's in their plan files. Set FINGER.PLAN protection to 774242
;<EXEC.CMU>EXEC1.MAC.16, 13-Sep-84 16:12:47, Edit by VAF
;CS131 Force creation of new plan file if FINGER.PLAN is offline.
;<EXEC.CMU>EXEC1.MAC.15, 20-Aug-84 12:02:36, Edit by VAF
;CS131 Rename MKPLAN.TMP to FINGER.PLAN.
;<EXEC.CMU>EXEC1.MAC.14,  9-Aug-84 15:04:03, Edit by VAF
;CS122 Handle failure of NODE jsys in GETLLS.
;<EXEC.CMU>EXEC1.MAC.13,  7-Aug-84 15:23:19, Edit by VAF
;CS131 Add code to support automatic plan file generation after login.
;<EXEC.CMU>EXEC1.MAC.12, 26-Jun-84 14:18:20, Edit by VAF
;CS122 Disable interrupts in GETLLS - it's not nice to get interrupts while in
;      section 1.
;<EXEC.CMU>EXEC1.MAC.11,  7-Jun-84 01:34:33, Edit by VAF
;CS90 Don't try to attach to detached jobs for SYSJOB subjob.
;<EXEC.CMU>EXEC1.MAC.10,  2-Jun-84 00:59:26, Edit by VAF
;CS111 Don't print login account if QLOGIN
;<EXEC.CMU>EXEC1.MAC.8, 25-Apr-84 14:01:21, Edit by VAF
;CM224 Turn on control-C capability after login
;<EXEC.CMU>EXEC1.MAC.7, 24-Apr-84 12:09:45, Edit by VAF
;CM358 Disallow ARCHIVE at CS as well.
;<EXEC.CMU>EXEC1.MAC.6, 20-Apr-84 18:39:31, Edit by VAF
;CS122 Klugy code for last login information
;<EXEC.CMU>EXEC1.MAC.4, 12-Apr-84 16:55:00, Edit by VAF
;CS119 Allow wheel or operator to attach/unattach NLI jobs
;      Make enabling during access be settable.
;<EXEC.CMU>EXEC1.MAC.3, 31-Mar-84 23:09:03, Edit by VAF
;CS118 Add LOGIN0 label
;<EXEC.CMU>EXEC1.MAC.2,  1-Mar-84 20:26:29, Edit by VAF
; CS111 Support for fast login.
; EM140 Make send confirmation a little more understandable.
; EM135 Document some changes
; EM134 Setup LGNFLG after doing LOGIN%
; EM115 Enable/disable capabilities around ACCES%
; EM101 Don't allow sends to batch jobs
; EM85 PMAP and UNMAP commands
; EM84 Extra confirmation for logout of other job
; EM66 Command history
; EM42 Logout clears screen
; EM40 Multi-line sends
; EM37 Reply command
; EM34 User IPCF
; EM32 KJOB and KKJOB
; EM27 Rework send to take user name, other changes
; EM16 Remove CS conditional for sends
; CS90 ATTACH & LOGIN restrictions.
;<5.1.EXEC>EXEC1.MAC.6, 22-Aug-83 20:25:46, Edit by PA0B
;CS59 Add .REPLA (^EReplace) and .EREPL (EReplace) code.
;CS61 Offer to attach to detached jobs in .LOGIN.  CS78 Force
; attach if less than 10 free job slots.
;<5.1.EXEC>EXEC1.MAC.5, 15-May-83 22:30:40, Edit by PA0B
;CM358 STKVAR should have been a TRVAR because of PUSH's
;<5.1.EXEC>EXEC1.MAC.4, 20-Jan-83 04:24:33, Edit by PA0B
;CM348 Include account titles in " Usage is being charged to ..."
; messages.  This change included replacing the inline code to do
; the message with a subroutine and also reordering things so that
; the message gets printed after ^C is allowed (in case Fngdat
; has died...)
;CM358 Add "Migrate" and "Cancel migrate" to replace archiving at CC
;CM156 Add code in PASSX to implement $Password_Required
;<5.1.EXEC>EXEC1.MAC.3,  1-Jan-83 06:13:46, Edit by PA0B
;CM264 Hazeltine-1500 and Regent-40 terminal types
;Redo a CM236 change: remove a couple of SETOM PWDFLG's since
; NOECHO now does it
;CM236 Replace GNJFN's with calls to $GNJFN to avoid problems
; when the Exec tries to delete a stacked JFN that GNJFN has
; already killed
;<5.1.EXEC>EXEC1.MAC.2,  3-Dec-82 00:33:29, Edit by PA0B
;Merge CMU v5:
; CM138 Don't expunge directory at "Logout"
; CM224 Efficiency hacks
; CM224 Don't fail to print system messages if user never exits from
;	Login.Cmd (Login.Cmd does a "Push" or runs Getmsg, for example)
; CM224 Make ATTAC5 not bother to check if job 0 is the job a user wants
;	to attach to when s/he specified a user name but not a job number
;	to "Attach" (for Glenn's startup hacks)
; CM236 Don't allow wildcards in retrieval requests
; CM236 Do an SFPOS% after clearing the screen to keep the Monitor up
;	to date on the cursor position
; CM236 Compute BLNKMX correctly
; CM236 No archiving at CC
; CM236 Remove silly check for netmail in MESMES
; CM236 Make sure DOACC doesn't echo password on failure
; CM236 For sends, the monitor puts on a <cr><lf>^G^GFrom:... header if
;	not privleged, put the same on if privleged ourself
; CM236 Keep track of whether line we are parsing contains a password
; CM244 "Logout /fast" at CC
; CM259 Request password on a separate line in "Login"
; CM290 ^E breaks links at CS
; CM290 Logout.Cmd at CS
; CM290 Allow non-privileged sends at CS
; CM290 Generate a correct "[From ..." header for privileged sends at CC
; CM290 At CS, Exec checks quota at logout and we don't call CHKDAL in
;	nearly as many commands
; CM335 Password change required on first login at CC
; CM336 Print only recent (past 24 hours) system messages the first
;	time a new user logs in at CC
; CM348 "Login" tells user what account is being charged if the user did
;	not specify an account
; CS15 Add "Receive/Refuse sends" at CS,
; CS28 Warn of approaching account expiration at CS
; CS41 Change the format of sends at CS
; CS41 Handle not-logged in sends
; CS45 "^EMddt"
; CM47+CM228+CM256+CM264+CM155+CM251 Added gobs of terminal types
; UPD ID= 61, FARK:<5-WORKING-SOURCES.EXEC>EXEC1.MAC.3,   2-Jun-82 14:07:19 by KROSENBLUH
;Edit 738 - new entry routine TRYGTS for getting a jfn for SYSJOB.COMMANDS
; UPD ID= 27, FARK:<4-1-WORKING-SOURCES.EXEC>EXEC1.MAC.2,  12-Apr-82 18:19:18 by KROSENBLUH
;IF ADVISOR TYPES CTRL/O, SEND IT'S EFFECT TO HIS TERMINAL TOO [721]
;<5.EXEC>EXEC1.MAC.17, 18-Mar-82 10:09:20, Edit by CHALL
; UPD ID= 134, SNARK:<5.EXEC>EXEC1.MAC.15,  22-Jan-82 14:49:11 by CHALL
;TCO 5.1698 .TKLOG- ADD NEW SUBCOMMAND TO TAKE: LOG-FILE
; UPD ID= 132, SNARK:<5.EXEC>EXEC1.MAC.14,  15-Jan-82 16:26:55 by CHALL
;TCO 5.1668 .CLOSE- ADD HELP MESSAGE TO OCTX LUUO
; UPD ID= 120, SNARK:<5.EXEC>EXECIN.MAC.21,  28-Dec-81 11:14:01 by CHALL
;TCO 5.1644 - UPDATE COPYRIGHT NOTICE
; UPD ID= 82, SNARK:<5.EXEC>EXEC1.MAC.12,  10-Oct-81 19:40:43 by CHALL
;TCO 5.1563 .CONNE- ADD "STRUCTURE NOT MOUNTED" TO CONNECT ERROR MESSAGE
; UPD ID= 32, SNARK:<5.EXEC>EXEC1.MAC.9,  14-Aug-81 19:11:58 by CHALL
;TCO 5.1454 CHANGE NAME FROM XDEF TO EXECDE
; UPD ID= 19, SNARK:<5.EXEC>EXEC1.MAC.8,  21-Jul-81 12:29:01 by MURPHY
;TCO 5.1427 - GET RID OF SYSTEM MAIL BEFORE PUSH
; UPD ID= 15, SNARK:<5.EXEC>EXEC1.MAC.6,  17-Jul-81 15:42:41 by CHALL
;TCO 5.1420 DETSND- HAVE SEND * SAY IT'S GOING TO ALL
; UPD ID= 4, SNARK:<5.EXEC>EXEC1.MAC.5,  10-Jul-81 17:07:35 by TILLSON
;Remove TCO 5.1400 - this code was already added!
; UPD ID= 2310, SNARK:<5.EXEC>EXEC1.MAC.4,   8-Jul-81 14:22:45 by TILLSON
;TCO 5.1400 - Fix CTRL/C out of LOGIN
; UPD ID= 2247, SNARK:<5.EXEC>EXEC1.MAC.3,  23-Jun-81 15:36:48 by LEACHE
;TCO 5.1379
;Make CANCEL ARCHIVE fail if FB%ARC set (collection run-1 started)
;<HELLIWELL.EXEC.5>EXEC1.MAC.1, 13-May-81 19:58:46, EDIT BY HELLIWELL
;REMOVE .CLEAR ROUTINE (NOW UNUSED)
;<4.EXEC>EXEC1.MAC.1, 10-May-80 16:42:52, Edit by DK32
;Programmable Command Language, SPR 13716
; UPD ID= 1511, SNARK:<5.EXEC>EXEC1.MAC.16,   2-Feb-81 18:10:30 by ELFSTROM
;change stroage to storage in error message for KEEPOV:
; UPD ID= 1321, SNARK:<5.EXEC>EXEC1.MAC.15,   1-Dec-80 16:00:47 by OSMAN
;Use SETENT instead of SEVEC
; UPD ID= 1307, SNARK:<5.EXEC>EXEC1.MAC.14,  24-Nov-80 12:13:52 by DONAHUE
;TCO 5.1191 - Allow UNDELETE to see invisible files (in case one got deleted)
; UPD ID= 1305, SNARK:<5.EXEC>EXEC1.MAC.13,  21-Nov-80 14:22:52 by DONAHUE
;TCO 5.1201 - Set GJ%ACC when getting JFN on LOGIN.CMD
; UPD ID= 1106, SNARK:<5.EXEC>EXEC1.MAC.12,   2-Oct-80 09:55:40 by OSMAN
;tco 5.1163 - Put CONFIRM in ^ESEND command
; UPD ID= 1024, SNARK:<5.EXEC>EXEC1.MAC.11,  17-Sep-80 10:35:57 by OSMAN
;tco 5.1148 - Make DISABLE/RUN equivalent capwise to RUN/DISABLE/START
; UPD ID= 853, SNARK:<5.EXEC>EXEC1.MAC.10,  10-Aug-80 15:20:07 by OSMAN
;tco 5.1129 - Add symbolic address and expression support
;tco 5.1128 - More correct error on "SET ENTRY 2000 2000"
; UPD ID= 832, SNARK:<5.EXEC>EXEC1.MAC.9,   4-Aug-80 12:57:35 by LYONS
; Fix typo in last fix
; UPD ID= 830, SNARK:<5.EXEC>EXEC1.MAC.8,   4-Aug-80 12:37:05 by LYONS
; Allow BLANK command to work for tty types over 18
; UPD ID= 592, SNARK:<5.EXEC>EXEC1.MAC.7,   3-Jun-80 09:33:31 by OSMAN
;tco 5.1057 - Allow ENABLE, DISABLE, and PUSH under BUILD
;<5.EXEC>EXEC1.MAC.6, 30-May-80 16:44:41, EDIT BY MURPHY
;PUT NEW ALERT AND MAIL WATCH UNDER NEWF
; UPD ID= 531, SNARK:<5.EXEC>EXEC1.MAC.5,  20-May-80 14:55:12 by MURPHY
;CHANGE SOME XTND TO NEWF OR MFRK
; UPD ID= 493, SNARK:<5.EXEC>EXEC1.MAC.4,  30-Apr-80 14:34:40 by OSMAN
; UPD ID= 492, SNARK:<4.1.EXEC>EXEC1.MAC.19,  30-Apr-80 09:55:25 by OSMAN
;Fix confirmation on TAKE subcommands
; UPD ID= 458, SNARK:<4.1.EXEC>EXEC1.MAC.13,  22-Apr-80 16:42:22 by OSMAN
;tco 4.1.1146 - Make CTRL/Q during advice work.
;tco 4.1.1145 - Make ADVISE smarter about "line not active"
;<4.1.EXEC>EXEC1.MAC.12,  8-Apr-80 14:18:46, EDIT BY OSMAN
;tco 4.1.1140 - Remove "(MESSAGE)" guidewords on ^ESEND
; UPD ID= 342, SNARK:<4.1.EXEC>EXEC1.MAC.11,  19-Mar-80 14:59:24 by TOMCZAK
;TCO# 4.1.1117 Clean up some password parsing problems (add PASFLD and a flag)
;<4.1.EXEC>EXEC1.MAC.3, 20-Nov-79 10:02:38, EDIT BY OSMAN
;TCO 4.1.1023 - Fix TAKE stuff
;<4.1.EXEC>EXEC1.MAC.2,  9-Nov-79 09:22:17, EDIT BY OSMAN
;tco 4.1.1011 - Don't allow ^C between LOGIN jsys and setting up CUSRNO
;<4.EXEC>EXEC1.MAC.151, 24-Oct-79 15:40:39, EDIT BY TOMCZAK
;TCO# 4.2544 - Make TAKE file command echoing work right
;<OSMAN.EXEC>EXEC1.MAC.1, 12-Oct-79 16:16:01, EDIT BY OSMAN
;TCO 4.2500 - USE THE CBACK AND CCHKPT LOGIC IN PASSWORD STUFF ONLY
;<4.EXEC>EXEC1.MAC.149,  8-Oct-79 16:13:03, EDIT BY OSMAN
;tco 4.2520 - Get confirmation after password
;<4.EXEC>EXEC1.MAC.147, 15-Sep-79 16:07:25, EDIT BY TOMCZAK
;TCO#4.2471 - Add GJ%ACC bit for getting JFNs on command and log files in TAKE
;<4.EXEC>EXEC1.MAC.146, 12-Sep-79 15:43:01, Edit by HESS
; Re-arrange invocation of MESMES for "set no login-mail" (XTND only)
;<4.EXEC>EXEC1.MAC.144,  5-Sep-79 10:22:16, EDIT BY OSMAN
;tco 4.2440 - Avoid "?JFN is not assigned" in TV (Don't close jfns after GET
;jsys
;<4.EXEC>EXEC1.MAC.141, 28-Aug-79 15:21:50, EDIT BY OSMAN
;tco 4.2427 - Print [n pages freed] message for all appropriate directories.
;<4.EXEC>EXEC1.MAC.141, 28-Aug-79 15:55:01, Edit by HESS
;<4.EXEC>EXEC1.MAC.140, 22-Aug-79 16:14:01, EDIT BY DBELL
;TCO 4.2415 - SKIP OUR OWN JOB WHEN SEARCHING JOBS IN ADVISE OR TALK
;<HESS.E>EXEC1.MAC.15, 19-Aug-79 23:03:39, Edit by HESS
; Add extended features
;<4.EXEC>EXEC1.MAC.138, 14-Aug-79 13:45:57, EDIT BY DBELL
;TCO 4.2396 - STOP PDL OVERFLOWS IN PUSHIO (REPLACE ERJMP WITH MANUAL CHECK)
;<4.EXEC>EXEC1.MAC.137, 10-Aug-79 14:50:41, EDIT BY OSMAN
;tco 4.2384 - Give warning, if nothing retrieved
;<4.EXEC>EXEC1.MAC.135, 10-Aug-79 08:18:18, EDIT BY OSMAN
;tco 4.2380 - Use standard error message if RNAMF jsys fails
;<4.EXEC>EXEC1.MAC.134,  2-Aug-79 09:07:28, EDIT BY OSMAN
;tco 4.2368 - Don't allow NO NO NO NO NO in TAKE subcommands
;<4.UTILITIES>FOO.BAR.8, 26-Jul-79 13:08:06, EDIT BY OSMAN
;tco 4.2347 - Check BATCHF instead of CHKPTY for whether to calculate
;"You have a message"
;<4.EXEC>EXEC1.MAC.125, 26-Jun-79 08:54:45, EDIT BY OSMAN
;tco 4.2310 - Fix prompt "[Attached to TTY67, confirm]"
;<4.EXEC>EXEC1.MAC.124, 21-Jun-79 14:35:56, EDIT BY OSMAN
;<4.EXEC>EXEC1.MAC.123, 21-Jun-79 13:34:10, EDIT BY OSMAN
;REMOVE EXTRANEOUS REFS TO RLJFNS
;<4.EXEC>EXEC1.MAC.122, 20-Jun-79 16:33:29, EDIT BY OSMAN
;tco 4.2301 - Don't type "garbage  [No pages freed]" on "DELETE nonxfile"
;and EXP subcommand
;<4.EXEC>EXEC1.MAC.121,  6-Jun-79 09:23:14, EDIT BY HELLIWELL
;DELETE CODE FOR UNMOUNT COMMAND (WAS NOSHIP)
;<4.EXEC>EXEC1.MAC.120,  4-May-79 10:51:28, EDIT BY OSMAN
;DOATI INSTEAD OF BLECCH
;<4.EXEC>EXEC1.MAC.119,  4-May-79 09:16:26, EDIT BY OSMAN
;REMOVE EPCAP AFTER LOGIN (IT'S USELESS, SINCE USER CAN ^C BEFORE IT ANYWAY)
;<4.EXEC>EXEC1.MAC.117,  1-May-79 11:16:39, EDIT BY OSMAN
;CHANGE GTJFN TO GTJFS IN KEEP
;<4.EXEC>EXEC1.MAC.116,  1-May-79 10:17:56, EDIT BY OSMAN
;FOR ADVICE, ATI ^E.  SEND ALL OTHER CHARACTERS (INCLUDING ^O!) TO REMOTE JOB
;<4.EXEC>EXEC1.MAC.115,  1-May-79 09:48:21, EDIT BY OSMAN
;try not doing process STIW for ADVISE, just job-wide STIW
;<4.EXEC>EXEC1.MAC.114, 30-Apr-79 16:55:02, EDIT BY OSMAN
;CALL BLECCH AT END OF ADVISE SO STIW ISN'T NEEDED AFTER EVERY ERROR
;<4.EXEC>EXEC1.MAC.113, 30-Apr-79 14:34:46, EDIT BY OSMAN
;DON'T DTI ^C IN ^EEDDT, SINCE WARM START NO LONGER DOES ATI
;<4.EXEC>EXEC1.MAC.112, 30-Apr-79 13:54:03, EDIT BY OSMAN
;DON'T DTI ^C AND ^T ON ^EQUIT OR POP, SINCE WARM START NO LONGER ATI'S THEM!
;<4.EXEC>EXEC1.MAC.111, 12-Mar-79 17:48:08, EDIT BY KONEN
;UPDATE COPYRIGHT FOR RELEASE 4
;<HURLEY.CALVIN>EXEC1.MAC.1, 12-Mar-79 16:04:43, EDIT BY HURLEY.CALVIN
; FIX RETRIEVE - USE ETYPE < %1S> INSTEAD OF TYPIF SINCE USING IT
; WITH NXFILE DOESN'T QUITE WIN FOR THINGS LIKE RETRIEVE AND UNDELETE
; THAT IS, BY THE TIME YOU CALL TYPIF, NXFILE MAY HAVE STEPPED OFF
; THE END CAUSING TYPIF TO LOSE BIG
;<4.EXEC>EXEC1.MAC.109, 12-Mar-79 14:51:15, EDIT BY HURLEY.CALVIN
; CAUSE ARCHIVE, RETAIN NOT TO MAKE FILE INVISIBLE
;<4.EXEC>EXEC1.MAC.106,  9-Mar-79 15:45:51, EDIT BY OSMAN
;CALL MFINP BEFORE DOING GTFDB IN RETRIEVE
;<4.EXEC>EXEC1.MAC.105,  6-Mar-79 09:58:07, EDIT BY OSMAN
;USE GTJFS INSTEAD OF $GTJFN IN ^EEDDT
;<4.EXEC>EXEC1.MAC.104,  5-Mar-79 16:27:02, EDIT BY HURLEY.CALVIN
; don't try to retrieve files that aren't offline
;<4.EXEC>EXEC1.MAC.103,  1-Mar-79 16:27:37, EDIT BY OSMAN
;NOECHO BEFORE (PASSWORD) IN LOGIN
;<4.EXEC>EXEC1.MAC.102, 28-Feb-79 09:53:49, EDIT BY OSMAN
;REMOVE REFS TO CTYPE (USE ETYPE INSTEAD)
;<4.EXEC>EXEC1.MAC.100, 21-Feb-79 16:32:34, EDIT BY OSMAN
;tco 4.2195 - Don't write-enable exec when doing ^EEDDT
;<4.EXEC>EXEC1.MAC.99, 21-Feb-79 09:35:18, EDIT BY OSMAN
;TCO 4.2189 - CONTINUED
;<4.EXEC>EXEC1.MAC.97, 14-Feb-79 14:23:57, EDIT BY OSMAN
;<4.EXEC>EXEC1.MAC.96, 14-Feb-79 13:59:08, EDIT BY OSMAN
;TCO 4.2189 - ASSUME NULL PASSWORD IF USER TYPES CR AT "PASSWORD:"
;<4.EXEC>EXEC1.MAC.94,  9-Feb-79 10:27:56, EDIT BY OSMAN
;MOVE ASSIGN AND DEASSIGN INTO EXECMT
;<4.EXEC>EXEC1.MAC.93,  9-Feb-79 10:17:44, EDIT BY OSMAN
;Make JFNRLA global
;<4.EXEC>EXEC1.MAC.91,  9-Feb-79 09:47:45, EDIT BY OSMAN
;Move tape stuff from here into EXECMT
;<4.EXEC>EXEC1.MAC.89,  6-Feb-79 16:55:23, EDIT BY HURLEY.CALVIN
;<4.EXEC>EXEC1.MAC.86,  6-Feb-79 16:19:16, EDIT BY HURLEY.CALVIN
; Remove XARC around making visible again on CANCEL ARCHIVE, also, ok
; cancel the request for files pending archive
;<4.EXEC>EXEC1.MAC.85,  6-Feb-79 15:44:32, EDIT BY HURLEY.CALVIN
; Cause CANCEL ARCHIVE to find invisible files
;<4.EXEC>EXEC1.MAC.84, 29-Jan-79 09:13:09, EDIT BY OSMAN
;fix call to SPECFN in DISCARD so user doesn't think there's subcommands
;<4.EXEC>EXEC1.MAC.83, 26-Jan-79 15:24:18, EDIT BY OSMAN
;take INVISIBLE feature out of XARC (i.e. make feature always available)
;<4.EXEC>EXEC1.MAC.82, 24-Jan-79 12:44:47, EDIT BY HURLEY.CALVIN
; Also make CANCEL ARCHIVE make 'em visible again (under XARC)
;<4.EXEC>EXEC1.MAC.81, 24-Jan-79 12:37:04, EDIT BY HURLEY.CALVIN
; Cause ARCHIVE request to make files invisible right away (under XARC)
;<4.EXEC>EXEC1.MAC.80, 10-Jan-79 10:56:14, EDIT BY R.ACE
;TAKE OUT "UNAVAILABLE, USE TMOUNT COMMAND" MSG IN ASSIGN COMMAND CODE
;<4.EXEC>EXEC1.MAC.79,  7-Jan-79 16:18:39, EDIT BY DBELL
;CHANGE ^ESEND MESSAGE FORMATS FROM "TTY1" TO "LINE 1"
;<4.EXEC>EXEC1.MAC.76, 20-Dec-78 15:50:42, EDIT BY HURLEY.CALVIN
; Add 1B17 to SPECFN bits in .RETRI
;<4.EXEC>EXEC1.MAC.75,  6-Dec-78 09:29:36, EDIT BY R.ACE
;CREATE CJDEV SUBROUTINE TO CLOSE JFN FOR A GIVEN DEVICE
;<4.EXEC>EXEC1.MAC.74, 19-Nov-78 17:55:11, EDIT BY DBELL
;TCO 4.2092 - GIVE TERMINAL NAME IN ^ESEND TEXTS SO REPLIES ARE EASIER
;<HURLEY.CALVIN>EXEC1.MAC.1,  8-Nov-78 22:09:25, EDIT BY HURLEY.CALVIN
; Change some GUIDE words to upper case only
;<4.EXEC>EXEC1.MAC.72, 27-Oct-78 18:28:19, EDIT BY OSMAN
;DON'T REFERENCE ACTBUF IN LOGIN
;<CALVIN>EXEC1.MAC.2,  8-Aug-78 13:59:05, EDIT BY CALVIN
; Install DISCARD
;[BBN-TENEXD]<CALVIN>EXEC1.MAC.1,  8-Aug-78 11:01:45, Ed: CALVIN
; Install ARCHIVE and RETRIEVE commands in this module (from EXECAR)
;<3-ARC-EXEC>EXEC1.MAC.4,  4-Aug-78 10:00:21, EDIT BY CALVIN
; Bugfixes from BBN sources into DEC archive sources
;<3-ARC-EXEC>EXEC1.MAC.3, 14-May-78 18:56:41, Edit by MTRAVERS
; TYPFRE made external for FLUSH to use.
;<3-ARC-EXEC>EXEC1.MAC.2, 14-May-78 18:02:05, Edit by MTRAVERS
;<3-ARC-EXEC>EXEC1.MAC.1, 14-May-78; Added stuff for DELETE, ARCHIVE.
;<4.EXEC>EXEC1.MAC.68, 22-Oct-78 07:51:42, EDIT BY HEMPHILL
;TCO 4.2059  ADD WARNING MESSAGE IF USER TRIES TO TALK TO SELF
;<4.EXEC>EXEC1.MAC.66,  8-Oct-78 18:49:14, EDIT BY OSMAN
;CALL ICLEAR INSTEAD OF CIS IN ADVISE CODE
;<4.EXEC>EXEC1.MAC.65,  7-Oct-78 00:48:07, EDIT BY OSMAN
;FIX ADVISE HEADER MESSAGE
;<4.EXEC>EXEC1.MAC.64, 28-Sep-78 15:44:33, EDIT BY HELLIWELL
;CHANGE B7 TO DV%MDV AT UNMOUNT
;<4.EXEC>EXEC1.MAC.63, 28-Sep-78 11:38:18, EDIT BY R.ACE
;IF RELD FAILS IN DEASSIGN COMMAND, CALL CJERRE INSTEAD OF JERR
;<4.EXEC>EXEC1.MAC.61, 27-Sep-78 16:15:23, EDIT BY OSMAN
;GET RID OF ALL REFS TO "B3" ETC. (EXCEPT FOR B7 UNDER NOSHIP???)
;TCO 4.2024 - WAIT FOR END OF LOGIN BEFORE PRINTING ERROR (SO PASSWORD DOESN'T ECHO)
;<4.EXEC>EXEC1.MAC.55, 26-Sep-78 13:24:57, EDIT BY OSMAN
;PUT BACK SINGLE-LINE LOGIN
;<4.EXEC>EXEC1.MAC.54, 21-Sep-78 15:21:19, EDIT BY OSMAN
;CHANGE WHLUO ETC. TO WHLU (SEE EXECDE)
;TCO 4.2012 - PRINT SENSIBLE ERROR ON DELETE COMMAND FAILING
;<4.EXEC>EXEC1.MAC.50, 15-Sep-78 22:24:34, EDIT BY OSMAN
;REMOVE ALL REFS TO CSBUF, CSBUFP
;<4.EXEC>EXEC1.MAC.49, 15-Sep-78 11:55:03, EDIT BY OSMAN
;Tco 4.2009 - Remove extra "PASSWORD)" in password routine
;<4.EXEC>EXEC1.MAC.48, 14-Sep-78 14:06:13, EDIT BY OSMAN
;DO SETNM IF ^EEDDT
;<4.EXEC>EXEC1.MAC.46, 14-Sep-78 11:37:41, EDIT BY OSMAN
;REMOVE SEARCH
;Remove mounting stuff.  Move to new module, EXECMT
;<4.EXEC>NEW1.MAC.1, 12-Sep-78 15:14:07, EDIT BY OSMAN
;MAKE LOGIN BE ON TWO LINES
;<4.EXEC>EXEC1.MAC.42,  6-Sep-78 13:43:52, EDIT BY R.ACE
;TCO 4.2002 - CHANGE HELP MESSAGE OF "TAKE" COMMAND
;<4.EXEC>EXEC1.MAC.41,  1-Sep-78 17:43:16, EDIT BY OSMAN
;REMOVE PASSWORD-ON-SAME-LINE OPTION OF CONNECT
;<4.EXEC>EXEC1.MAC.40, 30-Aug-78 23:52:07, EDIT BY DBELL
;TCO 4.2001 - MAKE SENDS TO PARTICULAR TTY NUMBER WORK AGAIN
;<4.EXEC>EXEC1.MAC.39, 21-Aug-78 20:06:23, EDIT BY OSMAN
;TCO 4.1988 - FIX "DEFINE" COMMAND HELP MESSAGE
;<4.EXEC>EXEC1.MAC.38, 10-Aug-78 10:11:38, EDIT BY OSMAN
;TCO 1977 DON'T ADVERTISE SUBCOMMANDS FOR UNDELETE
;<4.EXEC>EXEC1.MAC.37,  1-Aug-78 14:31:58, Edit by HEMPHILL
;TCO 1963 -- CORRECT FIX
;<4.EXEC>EXEC1.MAC.35,  1-Aug-78 10:02:06, EDIT BY OSMAN
;FIX SDISMOUNT, PUT ERROR RETURN ON STRX CALL, AND USE LOCAL CELL TO HOLD ALIAS NAME
;<4.EXEC>EXEC1.MAC.34, 31-Jul-78 11:08:42, Edit by HEMPHILL
;TCO 1963 -- MAKE TMOUNT WARN USER ABOUT OPERATOR NOT IN ATTENDANCE
;<4.EXEC>EXEC1.MAC.33, 27-Jul-78 15:43:39, EDIT BY OSMAN
;FIX "DEFINE" HELP MESSAGE
;<4.EXEC>EXEC1.MAC.32, 25-Jul-78 14:01:12, EDIT BY OSMAN
;TCO 1954
;DON'T PRINT OVER QUOTA MESSAGE ON ACCESS, OR IF NOT CHANGING CONNECTED DIRECTORY DURING CONNECT
;<4.EXEC>EXEC1.MAC.30, 21-Jul-78 15:31:19, EDIT BY OSMAN
;RESTORE NAME WHEN POP
;<4.EXEC>EXEC1.MAC.29, 21-Jul-78 10:34:41, Edit by PORCHER
;FIX SET ENTRY VECTOR FOR EX-ONLY
;<4.EXEC>EXEC1.MAC.28, 20-Jul-78 15:40:07, EDIT BY OSMAN
;RESTORE .SJT20 UPON EXITING (.POP)
;<4.EXEC>EXEC1.MAC.26, 17-Jul-78 11:30:43, EDIT BY OSMAN
;GET RID OF GTBUF, USE LOCAL STORAGE, ALSO REMOVE PUS/POP'S IN LOGIN
;<4.EXEC>EXEC1.MAC.23, 13-Jul-78 14:56:47, EDIT BY OSMAN
;CHANGE KEEPNM TO KEPNUM AND MAKE IT LOCAL
;<4.EXEC>EXEC1.MAC.22, 13-Jul-78 13:32:22, EDIT BY OSMAN
;MAKE TALK'S USE OF FRAME BE LOCAL (TFRAME)
;<4.EXEC>EXEC1.MAC.20, 11-Jul-78 15:44:28, EDIT BY OSMAN
;MAKE ADVISE, ATTACH, TALK USE LOCAL VARIABLES
;<4.EXEC>EXEC1.MAC.18, 10-Jul-78 20:50:23, EDIT BY OSMAN
;CHANGE REMARK'S USE OF TEXTIB TO BE LOCAL, AND RENAME IT TO CMTXTB
;<4.EXEC>EXEC1.MAC.17, 29-Jun-78 15:49:43, EDIT BY OSMAN
;make talk's dirno be local
;<4.EXEC>EXEC1.MAC.14, 29-Jun-78 14:56:48, EDIT BY OSMAN
;USE GTJFS, AND MAKE ADVJFN BE TRVAR.  ALSO TRVAR FOR CONNECT/ACCESS, STRNAM TOO
;<4.EXEC>EXEC1.MAC.13, 27-Jun-78 16:09:12, EDIT BY OSMAN
;CHANGE ALL THE GTB'S TO BE IMMEDIATE
;<4.EXEC>EXEC1.MAC.12, 26-Jun-78 09:55:49, EDIT BY OSMAN
;MAKE SURE LOGIN BANNER NOT ON SAME LINE AS LOGIN COMMAND
;(BROKE WHEN COMND CHANGED TO PUT CRLF'S IN BUFFER INSTEAD OF LF)
;<4.EXEC>EXEC1.MAC.11, 23-Jun-78 18:20:08, EDIT BY OSMAN
;REMOVE SYMBOLS: CONN2-3-4, ENTRY5, KEEP1A, LOGIN6, RECRF2, SMOUN1
;STRSIX, TAKIN1, TMOUN1, TRYGTP, .ASSO3, .CONN1, .SKIP0-1 (NOT REFERENCED!)
;<4.EXEC>EXEC1.MAC.10, 23-Jun-78 18:00:05, EDIT BY OSMAN
;REMOVE ADVLP0 (UNREFERENCED)
;<4.EXEC>EXECGL.MAC.25, 22-Jun-78 15:14:15, EDIT BY OSMAN
;IN MESMES, REMOVE HACK WITH MWATCT
;<4.EXEC>EXEC1.MAC.8, 19-Jun-78 14:48:55, EDIT BY OSMAN
;CALL SETIOF IN PUSHIO, INSTEAD OF DOING DVCHR AT READ1 (AVOIDS DOING DVCHR BEFORE EVERY COMMAND!)
;<4.EXEC>EXEC1.MAC.7,  9-Jun-78 18:03:56, EDIT BY OSMAN
;CHANGE CALLS TO FIELD TO FLDSKP
;<4.EXEC>EXEC1.MAC.6, 31-Jan-78 14:00:04, Edit by PORCHER
;<4.EXEC>EXEC1.MAC.5, 31-Jan-78 11:52:40, Edit by PORCHER
;Add "TAKE,ECHO"
;<4.EXEC>EXEC1.MAC.2, 19-Jan-78 14:53:42, EDIT BY HELLIWELL
;FIX STACK FOR NON-MTA (NOSHIP) AT DOMTOP
;<4.EXEC>EXEC1.MAC.1,  6-Jan-78 11:46:01, EDIT BY HELLIWELL
;TEST FOR DEVICE MTA BEFORE GDSTS AT DOMTOP
;FIX ERCAL .+2 AT DOACC

;TOPS20 'EXECUTIVE' COMMAND LANGUAGE

;THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY ONLY BE USED
;  OR COPIED IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
;COPYRIGHT (C) 1980,1981,1982 BY DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.

	SEARCH EXECDE
	TTITLE EXEC1
CC,<	SEARCH FNGUNV>		;CM348 Get defn's to get account titles

;THIS FILE CONTAINS
;LOTS OF COMMANDS...

;ARCHIVE <Files>
;F2 - DON'T FLUSH FILE CONTENTS

.MIGRA::TROA A,-1		;CM358 Flag this "Migrate"
.ARCHI::SETZ A,			;CM358 Flag this is "Archive"
	TRVAR <MIGFLG>		;CM358 Flag to tell the two apart
	HRREM A,MIGFLG		;CM358 Store flag in safe place
	NOISE <FILES>
	TLZ Z,F2		;DEFAULT IS NOT TO RETAIN CONTENTS
	MOVE A,[XWD -1,0]	;NO DEFAULT NAMES
	HRLI B,-3		;DEFAULT VERSION IS *
	SKIPN MIGFLG		;CM358 Is this a migration request?
	IFSKP.			;CM358
	  HRRI B,(GJ%OLD+GJ%IFG+GJ%NS+GJ%XTN+GJ%FNS+CF%NS) ;CM358 Yes
	ELSE.			;CM358
	  HRRI B,(GJ%OLD+GJ%IFG+GJ%PHY+GJ%XTN+GJ%FNS)
	ENDIF.			;CM358
	CALL SPECFN
	 JRST ARCHI1
	JRST ARCHI2		;DO IT

ARCHI1:	SUBCOM $ARCHI

ARCHI2:	SETOM TYPGRP		;ALWAYS TYPE NAME
	SKIPN MIGFLG		;CM358 Migration request?
	 ERROR <Archiving is not done at CMU - try MIGRATE instead> ;CM358
	MOVE A,COJFN
	MOVEM A,OUTDSG
	MOVE A,JBUFP
	MOVEM A,.JBUFP
	MOVX C,.ARSET		;WITH NO FLAGS
	TLNE Z,F2		;WANT TO RETAIN FILE CONTENTS?
	TXO C,AR%NDL		;RIGHT, FLAG THAT ON THE CALL
	PUSH P,C		;SAVE DISPOSITION BITS ETC
ARCHI3:	CALL RLJFNS
	CALL NXFILE
	 JRST ARCHI9
	CALL TYPIF
	CALL MFINP		;GET 2ND JFN
	 JRST ARCHI9		;FAILED
	SKIPN MIGFLG		;CM358 Migration request?
	IFSKP.			;CM358
	  MOVX B,.ARRIV		;CM358 Yes, so function code is please migrate
	ELSE.			;CM358
	  MOVX B,.ARRAR		;CM358 No, function code is please archive
	ENDIF.			;CM358
	MOVE C,0(P)		;AND BITS
	ARCF
	 ERJMP [ETYPE < %?%%_>
		JRST ARCHI9]
REPEAT 0,<			;CM290, CM358
	HRLI A,.FBCTL
	MOVX B,FB%INV		;MAKE THE FILE INVISIBLE TOO
	MOVX C,FB%INV
	TLNN Z,F2		;RETAIN CONTENTS?
	CHFDB
	 ERJMP [ETYPE < %?%%_>
		JRST .+1]
>;REPEAT 0			;CM290, CM358
	TYPE < [Requested]
>
ARCHI9:	SKIPE INIFH1		;DONE THEM ALL?
	 JRST ARCHI3		;NO, LOOP
	SETZM .JBUFP
	ADJSP P,-1		;FLAGS NO LONGER USEFUL
	RET

	ENDTV.			;CM358

;TABLES ETC. TO ARCHIVE

$ARCHI:	TABLE
	T RETAIN,,.ARFL
	TEND

.ARFL:	NOISE <DISK CONTENTS>
	CONFIRM
	TLO Z,F2
	RET

;LET (LOGICAL NAME) -- (AS) --

EDEFIN::TLO Z,F2
	NOISE <SYSTEM LOGICAL NAME>
	JRST .ASSO

.DEFIN::TLZ Z,F2
	NOISE <LOGICAL NAME>
.ASSO:	STARX <
 Logical name to define or delete,
 or "*" to delete all>
	JRST .ASSO1		;NOT "DEFINE *"
	PUSH P,[0]		;PUSH 0 TO INDICATE ALL
	JRST .ASSO2		;AND EAT TERMINATOR

.ASSO1:	STRX <Logical name to define or delete>	;READ LOGICAL NAME
	 CMERRX
	CALL BUFFF		;GET POINTER TO NAME
	PUSH P,A		;SAVE PNTR
.ASSO2:	SKIPN (P)		;ALL?
	JRST .ASS3B		;YES, SEPARATE ROUTINE
	NOISE <AS>
	CRRX <Definition list or null to delete>
	 CAIA			;NOT JUST "DEFINE FOO<CR>"
	JRST .ASSO9		;YES, JUST "DEFINE FOO<CR>"
	LINEX <Definition list>	;READ DEFINITION LINE
	 CMERRX			;NOT ANYTHING LEGAL AFTER "DEFINE" !
	CALL BUFFF		;GET POINTER TO DEFINITION STRING
	CONFIRM
	MOVE C,A		;NEW NAME IN C
	MOVEI A,.CLNJB
	TLNE Z,F2		;SYSTEM?
	MOVEI A,.CLNSY		;YES
.ASSO4:	TLNE Z,F2		;SYSTEM?
	CALL FCONF		;YES, FORCE FURTHER CONFIRMATION
	MOVE B,(P)		;GET LOGICAL NAME
	PUSH P,A		;REMEMBER ATTEMPTED FUNCTION IN CASE ERROR
	CRLNM
	 JRST ASSONO		;COULDN'T DO IT
	POP P,(P)
	POP P,(P)		;FIX STACK
	RET

;HERE WHEN LOGICAL NAME MANIPULATION FAILED

ASSONO:	CAIE A,CRLNX1
	 CALL CJERRE		;UNKNOWN ERROR
	POP P,A			;NOW WE KNOW "NAME UNDEFINED"
	CAIE A,.clnj1		;TRYING TO DELETE ONE JOB NAME?
	CAIN A,.clns1		;OR TRYING TO DELETE ONE SYSTEM NAME?
	CAIA			;YES
	 CALL CJERRE		;NO, TYPE MONITOR MESSAGE
	POP P,A			;GET POINTER TO NAME WE COULDN'T DELETE
	ETYPE <%%Logical name %1M: was not defined
>
	RET			;NON-FATAL ERROR IF DELETING NON-EXISTENT LOGICAL NAME

.ASSO9:	MOVEI A,.CLNJ1		;DELETE
	TLNE Z,F2
	MOVEI A,.CLNS1
	JRST .ASSO4

.ASS3B:	CRRX <Confirm to delete all logical names>
	 CMERRX
	MOVEI A,.CLNJA		;DELETE ALL
	TLNE Z,F2		;SYSTEM?
	MOVEI A,.CLNSA
	TLNE Z,F2		;SYSTEM?
	PROMPT <[Confirm to delete all SYSTEM logical names]>
	TLNN Z,F2
	PROMPT <[Confirm to delete ALL logical names]>
	CALL FCONFA
	CRLNM
	 CALL CJERR
	POP P,B
	RET

;ATTACH (USER) <NAME> (PASSWORD) -- (TSS JOB #) <#>

;LIKE LOGIN, THIS COMMAND ALSO ACCEPTS THE FORM:
;ATTACH
;(USER) <NAME>
;(PASSWORD) ----
;(TSS JOB #) <#>

;PASSWORD IS NOT ECHOED IN FULL DUPLEX, TYPED OVER MASK ON
;FOLLOWING LINE IN HALF DUPLEX.
;TSS JOB # CAN BE OMITTED IF THERE IS ONLY ONE JOB FOR GIVEN USER.
;IF NOT LOGGED IN, CURRENT JOB GOES AWAY (HANDLED BY MONITOR),
;IF LOGGED IN IT IS DETACHED.

;IN ORDER TO NOT HAVE TO HAVE THE EXEC WAKING UP AFTER EVERY FIELD
;OF INPUT TO SEE IF WE'RE DOING SOME SORT OF PASSWORD COMMAND, THE
;FORMAT OF THE "ATTACH" AND "UNATTACH" COMMANDS HAVE BEEN CHANGED TO
;PROMPT FOR THEIR PASSWORD ON THE SECOND LINE.  SINCE THE CR AT END
;OF FIRST LINE CAUSES WAKEUP, THIS GUARANTEES THAT ECHOING WILL HAVE
;A CHANCE TO BE TURNED OFF BEFORE USER TYPES PASSWORD.E.O. JUL-8-77

.ATTAC::			;ENTRY FOR COMMAND, NEXT TAG IS FROM UNATTACH
	IFNBATCH <[ERROR <ATTACH illegal from BATCH job>]>
ATTAU1:

;DECODE ARGUMENTS

	TRVAR <LPASP,LOGNO,ATTNM,<APBUF,20>,AT1,AT2> ;CS90 HOLDS ATACH ARGS
	NOISE <USER>
	CALL USERN
	 CMERRX
	SETOM ATTNM		;CLEAR ATTACHED TERMINAL # HERE
	SETZM LPASP		;CS90 Indicate no password gotten yet
	MOVEM C,LOGNO		;CS90 Save user number
	SKIPN NLIACC		;CS90 NLI restricted?
	IFSKP.			;CS90 Yes
	  CONFIRM		;CS90 Don't allow a job number
	  CALL GETPSW		;CS90 Get password & verify
	  JRST ATTAC5		;CS90 Go default job number
	ENDIF.			;CS90
	TXNE A,RC%DIR
	ERROR <That's a FILES-ONLY directory name>
	NOISE <JOB #>
	DECX < Number if more than one job under that name>
	 CAIA			;NON-DECIMAL NUMBER TYPED
	JRST ATTNUM		;NUMBER TYPED, GO PROCESS IT
	CONFIRM			;REQUIRE CONFIRMATION OF COMMAND
	JRST ATTAC5		;GO DEFAULT A VALUE
ATTNUM:	CONFIRM
	PUSH P,B		;SAVE JOB # INPUT BY USER

;ATTACH...
;CHECK THAT USER-GIVEN JOB # IS IN LEGAL RANGE

	SETO D,
	GTB .JOBRT		;GET MAX JOB # AS LENGTH OF SYSTEM TABLE
	MOVN A,A		;LENGTH COMES BACK NEGATIVE
	SUBI A,1		;SO VALUE COMES OUT RIGHT IN ERR MSG
	CAML A,(P)		;LENGTH MUST BE > GIVEN #
	SKIPGE D,(P)		;GIVEN JOB # TO D
	ERROR <Job # must be between 0 and %1Q>

;MAKE SURE GIVEN JOB # IS LOGGED IN W MATCHING USER # AND IS ATTACHED

	GTB .JOBRT		;ENTRY NEG IF NO SUCH JOB
	JUMPL A,[UERR[ASCIZ /No job %4Q/]]
	GTB .JOBTT		;LINE # OR NEGATIVE FOR DETACHED IN LH
	HLREM A,ATTNM		;STORE ATTACHED LINE NUMBER FOR LATER
	CALL USERNO		;GET USER OWNING JOB BEING ATTACHED
	IFE. A			;CS119 Not logged in?
	  MOVX CX,SC%WHL!SC%OPR	;CS119
	  TDNN CX,EXECAP	;CS119 Priviliged?
	   UERR [ASCIZ /Job %4Q not logged in/] ;CS119 No - error
	  MOVSI A,500000	;CS119 Make NLI user number
	  MOVEM A,LOGNO		;CS119 Set it
	  JRST ATTAC7		;CS119 Go do it
	ENDIF.			;CS119
	MOVE Q1,LOGNO		;CS90 DESIRED USER #, FOR USE IN ERR MSG
	CAME A,Q1
	ERROR <Job %4Q not logged in under %5R>
	JRST ATTAC7		;GO CONFIRM AND EXECUTE

;ATTACH...
;NO JOB # GIVEN, SEE IF THERE IS A UNIQUE ONE FOR GIVEN NAME.

ATTAC5:				;SEARCH JOBDIR TABLE FOR A MATCH
;CM224	GJINF			;GET JOB # INTO C FOR TEST LATER
	MOVE Q1,LOGNO		;CS90 DIR # TO SEARCH FOR (USED IN ERR MSGS!)
	SETO D,
	GTB .JOBRT		;JOBRT TABLE BY JOB #, LOGIN DIR # IN RH.
	HRLZ D,A		;SET UP XWD LENGTH, INDEX FOR AOBJN & GTB.
	AOBJN D,.+1		;CM224 Don't check job 0, get count right
	TLZ Z,F2		;FLAG NO DETACHED JOBS SEEN YET
	PUSH P,[-1]		;INIT JOB TO UNKNOWN
ATA5A:	HRRZ A,D		;CM224 Get the job number half
	CAMN A,JOBNO		;CM224 ALWAYS SKIP US
	JRST ATA5L
	CALL USERNO
	CAME A,Q1		;IS THIS THE CORRECT USER?
	JRST ATA5L		;NO
	GTB .JOBTT		;YES - GET TTY WORD
	TLNN Z,F1		;ATTACH OR UNATTACH?
	JRST ATA5B		;ATTACH
	JUMPL A,ATA5L		;JUMP IF DETACHED
	SKIPL (P)		;ATTACHED JOB, SEEN ONE ALREADY?
	JRST ATA5E1		;YES, ERROR
	HRRZM D,(P)		;SAVE JOB #
	SETOM ATTNM		; AND SET TERM AS DETACHED
	JRST ATA5L

ATA5B:	JUMPL A,ATA5C		;JUMP IF DETACHED
	TLNE Z,F2		;ALREADY SEEN DETACHED JOB?
	JRST ATA5L		;YES, DON'T LOOK AT ATTACHED ONES
	SKIPL (P)		;FIRST ATTACHED ONE?
	JRST ATA5D		;NO, STOP LOOKING AT ATTACHED ONES
	HRRZM D,(P)		;SAVE JOB #
	HLREM A,ATTNM		; AND TERMINAL #
	JRST ATA5L

ATA5D:	SETOM (P)		;RESET JOB # TO UNKNOWN
	SETOM ATTNM		; AND TERMINAL # ALSO
	TLO Z,F2		;SET FLAG TO LOOK ONLY AT DETACHED JOBS
	JRST ATA5L

ATA5C:	TLON Z,F2		;FLAG DETACHED JOB FOUND
	SETOM (P)		;FORGET ANY ATTACHED JOB
	SKIPL (P)		;MORE THAN ONE?
	ERROR <Job # required - %5R has more than one detached job>
	HRRZM D,(P)		;NO, SAVE JOB #
	SETOM ATTNM		; AND MARK TERMINAL DETACHED
ATA5L:	AOBJN D,ATA5A		;LOOP THROUGH ALL JOBS
	SKIPL (P)		;DID WE FIND A JOB?
	JRST ATTAC7		;YES, GO DO IT
	TLNE Z,F2		;.GT. 1 ATTACHED, BUT 0 DETACHED?
	JRST ATA5E1		;YES, SAME ERROR MESSAGE AS UNATTACH
	TLNE Z,F1		;ATTACH OF UNATTACH?
	JRST ATA5E2		;UNATTACH
	CAMN Q1,CUSRNO
	ERROR <No other jobs logged in under %5R>
	ERROR <No jobs logged in under %5R>

ATA5E2:	CAMN Q1,CUSRNO
	ERROR <No other attached jobs logged in under %5R>
	ERROR <No attached jobs logged in under %5R>

ATA5E1:	CAMN Q1,CUSRNO
	ERROR <Job # required - %5R has more than one other attached job>
	ERROR <Job # required - %5R has more than one attached job>

;ATTACH...

;CHECK FOR SELF

ATTAC7:	MOVE C,JOBNO		;CM224 GET JOB NUMBER IN C
	CAMN C,(P)		;IS IT US?
	 JRST [	TLNN Z,F1	;ATTACH OR UNATTACH?
		ERROR <Cannot ATTACH to self>
		ERROR <Cannot UNATTACH self>]

;CHECK FOR ALREADY ATTACHED

	SKIPGE A,ATTNM		;TTY #
	JRST ATAC4B
	HRROI B,APBUF		;REDIRECT OUTPUT TO OUR BUFFER
	MOVEM B,COJFN
	ETYPE < [Attached to TTY%1O, confirm]>
	CALL FIXIO		;RESUME NORMAL OUTPUT
	UPROMP APBUF		;PROMPT USER FOR CONFIRMATION
	CALL FCONFA

;EXECUTE THE COMMAND

ATAC4B:	POP P,A			;TSS JOB # TO ATTACH TO
	MOVEI C,0		;NO PASSWORD POINTER
	MOVE B,LOGNO		;CS90 User to attach to
	TLNN Z,F1		;IF NOT LOSING THIS JOB
	SKIPN CUSRNO		;OR NOT LOGGED IN,
	CAIA			;THEN SAY NOTHING
	ETYPE < Detaching job # %J
>
	TLNE Z,F1		;UNATTACH?
	TLO A,(1B1)		;YES, TELL ATACH
ATTAC1:				;CS61
	DMOVEM A,AT1		;SAVE ARGS IN CASE REDO NECESSARY
	MOVE C,LPASP		;CS90 Maybe we have a password already...
	ATACH			;TRY TO DO IT
	 ERJMP .+2		;FAILED
	JRST ATGOOD		;SUCCEEDED
	CAIE A,ATACX4		;PASSWORD PROBLEM?
	JRST ATNG		;NO, SOME OTHER ERROR
	CALL PASLIN		;PASSWORD NOT GIVEN BUT REQUIRED, GET IT
	MOVE C,A		;STORE NEW PASSWORD POINTER
	DMOVE A,AT1		;GET OTHER ARGS
	ATACH
ATNG:	 CALL [	TLNN Z,F1	;DIDN'T SAY DETACHING JOB IF UNATTACH
		ETYPE <?ATTACH failure, still attached to job # %J
>
		CALL CJERRE]
ATGOOD:	JRST CMDIN4		;ATACH RETURNS +2 IF LOGGED IN--THIS JOB
				; STILL ATTACHED IF 'UNATTACH' JUST DONE.

;BREAK (LINKS)

NONEWF,<
.BREAK::NOISE <LINKS>
>
BREAK0:	CONFIRM
BREK0A:	MOVEI B,-1		;SET TO BREAK ALL LINKS
				;(FALL INTO BREAK1)

;BREAK1 breaks links from specific terminal.
;
;Accepts:	B/	terminal number or 777777 for all

BREAK1::MOVE A,[TL%CRO!TL%COR+.CTTRM] ;BREAK TO AND FROM LINKS
	TLINK
	 CALL JERR
CS,<				;CM290 If ^E enabled
	CAIN B,-1		;CM290 Breaking all links?
	 JRST [ CALL DOATI	;CM290 Disable it
		SETZM ADVFLG	;CM290 No longer in this mode
		JRST .+1]	;CM290
>;CS				;CM290
	RET

NEWF,<
;BREAK (LINKS WITH) - FANCIER FORM OF BREAK COMMAND

.BREAK::NOISE <LINKS WITH>
	STKVAR <BYUNO>
	MOVEI B,[FLDDB. .CMTOK,CM%SDH,<-1,,[ASCIZ "*"]>,<User name, line number, or CR for all>,<*>,[
		 FLDDB. .CMUSR,CM%SDH,,,,[
		 FLDDB. .CMNUM,CM%SDH,10,,,[
		 FLDDB. .CMCFM,CM%SDH,,,,]]]]
	CALL FLDSKP		;PARSE THIS MESS
	 CMERRX
	LDB C,[POINT 9,0(C),8]	;FIGURE OUT WHAT WAS TYPED
	CAIN C,.CMCFM		;JUST CR?
	 JRST BREK0A		;YES - DO ALL
	CAIN C,.CMTOK		;WAS IT "*"
	 JRST BREAK0		;YES - CONFIRM AND DO ALL
	CONFIRM			;MUST BE USER NAME OR LINE #
	CAIN C,.CMNUM		;LINE NUMBER?
	 JRST .BYEBY		;YES - CONFIRM, BREAK, AND RETURN
	MOVEM B,BYUNO		;SAVE USER #
	TLZ Z,F1!F2		;INIT FLAGS
	HLLZ D,JOBRT		;-# OF JOBS AS AOBJN CNTR
.BYE2:	CALL USERNO		;GET USER # OF JOB IN D
	CAME A,BYUNO		;IS IT THE ONE WE WANT?
	 JRST .BYE3		;NO
	TLO Z,F2		;FOUND ONE
	GTB .JOBTT		;GET TTY # FOR JOB
	JUMPL A,.BYE3		;JUMP IF DETACHED
	TLO Z,F1		;ACTUALLY OK TO BREAK LINK
	HLRZ B,A		;LINE # TO RHS
	CALL .BYEBY		;BREAK A LINK
.BYE3:	AOBJN D,.BYE2		;LOOP THRU ALL JOBS
	TLNE Z,F1		;DID ANY?
	 RET			;YUP - DONE
	TLNE Z,F2		;WHAT KIND OF LOSAGE?
	 ERROR <User has detached jobs only>
	ERROR <User not logged in>

.BYEBY:	TXO B,.TTDES		;MAKE INTO TERMINAL DESC.
	CALLRET BREAK1		;BREAK THE LINK AND RETURN
>

;CANCEL (Request type) ARCHIVE - arrive here from EXECQU

CANMIG::TROA A,-1		;CM358 Flag this is "Cancel migrate"
CANARC::SETZ A,			;CM358 Flag this is "Cancel archive"
	STKVAR <MIGFLG>		;CM358 Flag to remember which we're doing
	HRREM A,MIGFLG		;CM358 Store in a safe place
	NOISE <FOR FILES>
	MOVE A,[XWD -1,0]
	HRLI B,-3		;ALL GENERATIONS
	SKIPN MIGFLG		;CM358 Is this a migration request?
	IFSKP.			;CM358
	  HRRI B,(GJ%OLD+GJ%IFG+GJ%NS+GJ%XTN+GJ%FNS+CF%NS) ;CM358 Yes
	ELSE.			;CM358
	  HRRI B,(GJ%OLD+GJ%IFG+GJ%PHY+GJ%XTN+GJ%FNS)
	ENDIF.			;CM358
	TXO Z,IGINV		;FIND INVISIBLE FILES
	CALL SPECFN
	 JRST CERR		;NO "STUFF,"
CC,<				;CM358
	SKIPN MIGFLG		;CM358 Migration request?
	 ERROR <Archiving is not done at CMU> ;CM358 No, lose
>;CC				;CM358
	SETOM TYPGRP
	MOVE A,COJFN
	MOVEM A,OUTDSG
	MOVE A,JBUFP
	MOVEM A,.JBUFP		;SET JFN STACK FENCE
CANAR1:	CALL RLJFNS		;RELEASE UNNEEDED JFNS
	CALL NXFILE		;STEP TO NEXT FILE
	 JRST CANAR2
	HRRZ A,@INIFH1		;GET THE JFN WITH NO BITS
	MOVE B,[1,,.FBBBT]	;GET WORD WITH REQUEST BIT
	MOVEI C,C
	GTFDB			;GET IT NOW
	 ERJMP CANAR3		;SKIP THIS ONE
	SKIPN MIGFLG		;CM358 "Cancel migrate"?
	IFSKP.			;CM358
	  TXNN C,AR%RIV		;CM358 Yes, has this file been MIGRATE'd?
	   JRST CANAR3		;CM358 No, skip this file
	ELSE.			;CM358
	  TXNN C,AR%RAR		;REQUESTED?
	   JRST CANAR3		;NO, SKIP THIS FILE
	ENDIF.			;CM358
	HRRZ A,@INIFH1		;GET THE JFN WITH NO BITS
	SKIPE MIGFLG		;CM358 "Cancel migrate"?
	 JRST CANAR4		;CM358 Yes, so skip first pass done test
	MOVE B,[1,,.FBCTL]	;GET FDB FLAG WORD
	MOVEI C,C
	GTFDB			;GET IT NOW
	 ERJMP CANAR3		;SKIP THIS ONE
	TXNE C,FB%ARC		;DOES THE FILE CURRENTLY HAVE ARCHIVE STATUS?
				;EG, HAS COLLECTION RUN-1 ALREADY STARTED?
	JRST	[TYPE <?File has archive status: >
		CALL TYPIF	;DISPLAY OFFENDING FILE
		TYPE <
>
		JRST CANAR3]	;TRY FOR NEXT FILE

CANAR4:				;CM358
	CALL TYPIF		;TYPE NAME OF FILE
	CALL MFINP		;GET A SECOND JFN
	 JRST [ETYPE < %?
>
		JRST CANAR2]	;FAILED FOR SOME REASON
	SKIPN MIGFLG		;CM358 Migration request?
	IFSKP.			;CM358
	  MOVX B,.ARRIV		;CM358 Yes, so function code is migrate
	ELSE.			;CM358
	  MOVX B,.ARRAR		;CM358 No, function code is archive
	ENDIF.			;CM358
	MOVEI C,.ARCLR		;CLEAR THE REQUEST
	ARCF
	 ERJMP [ETYPE < %?
>
		JRST CANAR2]
	HRLI A,.FBCTL
	MOVX B,FB%INV
	SETZ C,			;MAKE FILE VISIBLE AGAIN
	CHFDB
	 ERJMP [ETYPE < %?
>
		JRST .+1]	;SAY OK IF JUST MAKING VISIBLE FAILED
	CALL TYPOK
CANAR2:	SKIPE INIFH1
	JRST CANAR1
	RET

CANAR3:	CALL GNFIL		;ADVANCE TO NEXT GUY
	 SETZM INIFH1		;NONE LEFT
	JRST CANAR2		;AND GO ON

	ENDSV.			;CM358

;END-ACCESS (DIRECTORY) <NAME> --

.ENDAC::TLO Z,F2+F3		;F2 MEANS ACCESS OR END-ACCESS, F3 MEANS END-ACCESS
	JRST CONNX		;JOIN COMMON CODE

;ACCESS (DIRECTORY) <NAME> --

.ACCES::TLO Z,F2		;F2 ON MEANS "ACCESS", OFF MEANS "CONNECT"
	TLZ Z,F3		;F2 MEANS ACCESS
	JRST CONNX		;JOIN COMMON CODE

;CONNECT (TO DIRECTORY) <NAME> --

.CONNE::TLZ Z,F2+F3		;OFF MEANS "CONNECT", ON MEANS "ACCESS"
CONNX:	TRVAR <ACDNUM,ACPASS,ACJNUM,OLDCON> ;KEEP ACDNUM,ACPASS,ACJNUM CONSECUTIVE AND IN ORDER!!
	SETZM ACPASS		;NO PASSWORD ASSUMED THIS TIME
	SETOM ACJNUM		;USE OUR OWN JOB NUMBER
	NOISE <TO DIRECTORY>
	TLNE Z,F2		;WANT DEFAULTING?
	TLOA Z,F1		;NO (ACCESS, END ACCESS)
	TLZ Z,F1		;YES (CONNECT)
	CALL DIRNAM		;INPUT & CHECK DIRECTORY NAME
	 ERROR <No such directory or structure not mounted>
	MOVEM C,ACDNUM		;REMEMBER DIRECTORY NUMBER
	CONFIRM
	TLNE Z,F2		;CONNECT?
	JRST NOCONN		;NO, SO NO OVER QUOTA REPORTING
	GJINF			;GET CONNECTED DIRECTORY
	MOVEM B,OLDCON		;REMEMBER OLD ONE
CC,<	CALL CHKDAL >		;CM290 CHECK CURRENT DIRECTORY BEFORE LEAVING
NOCONN:	SETZM ACPASS		;FIRST TRY WITHOUT PASSWORD
	CALL DOACC		;DO THE JSYS
	TLNE Z,F2		;CONNECT?
	JRST CMDIN4		;NO, ACCESS, SO NO OVER QUOTA REPORT
CC,<				;CM290
	GJINF			;GET CONNECTED DIRECTORY NOW
	CAME B,OLDCON		;DON'T GIVE SAME REPORT TWICE!
	CALL CHKDAL		;CHECK NEW DIRECTORY
>;CC				;CM290
	JRST CMDIN4

;ROUTINE TO DO JSYS FOR ACCESS, END-ACCESS, CONNECT

DOACC:
	SKIPN ENAFLG		;CS119 Want to enable?
	IFSKP.			;CS119
	  MOVX A,.FHSLF		;EM115
	  MOVE B,EXECAP		;EM115 Get possible caps
	  MOVE C,B		;EM115 To enable them
	  EPCAP%		;EM115 Turn on capabilities for access
	ENDIF.			;CS119
	MOVE A,[AC%CON+3]	;SAY "CONNECT"+"3 WORDS IN INFO BLOCK"
	TLNE Z,F2		;"ACCESS"?
	TXC A,AC%CON+AC%OWN	;YES, TURN OFF CONNECT AND ON ACCESS
	TLNE Z,F3		;END-ACCESS?
	TXC A,AC%OWN+AC%REM	;YES, TURN OFF "ACCESS", TURN ON "END-ACCESS"
	MOVEI B,ACDNUM		;WHERE THE BLOCK IS.
	ACCES
	 ERCAL ACCHK		;FAILED
DOACC1:	SKIPN ENAFLG		;CS119 This needed?
	IFSKP.			;CS119
	  MOVX A,.FHSLF		;EM115
	  DMOVE B,EXECAP	;EM115 Get possible & enabled caps
	  EPCAP%		;EM115 Set them back
	ENDIF.			;CS119
	RET			;SUCCEEDED

;CHECK FOR FAILING END-ACCESS AND USER WASN'T ACCESSING THE DIRECTORY

ACCHK:	CALL %GETER		;GET ERROR CODE FOR FAILING ACCES JSYS
	MOVE A,ERCOD
	CAIE A,ACESX6		;"DIRECTORY ISN'T BEING ACCESSED" ERROR?
	 JRST ACNOP		;NO, MAYBE PASSWORD NOT GIVEN BUT REQUIRED
	MOVE A,ACDNUM		;GET DIRECTORY NUMBER REFERRED TO
	ETYPE <%%Directory %1R wasn't being ACCESSed
>
	CALL DOACC1		;CS119 Disable, if necessary
	JRST CMDIN4		;GIVE SUCCESS RETURN FOR COMMAND

;CONNECT OR ACCESS FAILED.  SEE IF PASSWORD NOT GIVEN, BUT REQUIRED.
;IF SO, PROMPT FOR IT AND TRY AGAIN.  IF NOT, PRINT SYSTEM ERROR.

ACNOP:	CAIE A,ACESX3		;"?PASSWORD IS REQUIRED"?
	 JRST ACNOE		;CM236 NO, OTHER ERROR.  PRINT ERROR MESSAGE.
	CALL PASLIN		;YES, GET PASSWORD ON NEW LINE.
	MOVEM A,ACPASS		;STORE NEW PASSWORD POINTER
	JRST DOACC		;TRY THE JSYS AGAIN

ACNOE:	SKIPE ACPASS		;CM236 Password specified?
	 SETOM PWDFLG		;CM236 Make sure error routine doesn't echo it
	JRST CJERRE		;CM236 Go to standard JSYS error routine

;"COPY" IS IN X2CMD.MAC.

;DAYTIME
;THIS AND ALL ONE-WORD COMMANDS ARE CONFIRMED BEFORE DISPATCH.

.DAYTI::PRINT " "
	MOVE A,COJFN		;DESTINATION
	SETOB B,C		;SAY CURRENT DATE AND TIME, SUPER-VERBOSE FORMAT
	ODTIM
	ETYPE<%_>
	RET

;DELETE <FILE GROUP>

.DELET::TRVAR <EXMFLG,NEWDIR,INIFHO,<DELBUF,FILWDS>,KEPNUM,KEPJNM,DELDIR,DELPGS,DELJFN>
	SETZM KEPNUM		;ASSUME NOT KEEP
	NOISE <FILES>
	MOVE A,[XWD -1,0]	;NO DEFAULT NAMES
	HRLI B,-3		;DEFAULT VERSION IS *
	HRRI B,(GJ%OLD!GJ%NS!GJ%IFG!1B14!1B15!1B16) ;OLD FILE, NO SEARCH, *'S AND COMMA OK
	CALL SPECFN		;INPUT FILE GROUP DESCRIPTOR
	JRST DELET1
	TDZ Z,[F5!F2!F3!F4!1B18] ;CAN'T BE EXPUNGE IF NO SUBCOMMAND
	JRST DELET2

DELET1:	TDZ Z,[F5!F2!F3!F4!1B18] ;CLEAR FLAGS
	SUBCOM $DELET
DELET2:	SETOM TYPGRP		;ALWAYS TYPE NAME
	MOVE A,COJFN
	MOVEM A,OUTDSG		;FOR NXFILE TYPEOUT
	MOVE A,JBUFP		;SAVE THESE JFNS
	MOVEM A,.JBUFP
	SETZM DELDIR		;NO DIRECTORY INITIALIZED YET
	SETOM EXMFLG		;FORCE DIRECTORY TO BE EXAMINED
	SKIPE KEPNUM		;DELETING ALL VERSIONS?
	JRST KEEPDL		;NO, SPECIAL CODE
DELET3:	CALL RLJFNS		;RELEASE ALL TEMPORARY JFNS
	CALL NXFILE		;CHECK FOR SPECIAL TERM
	JRST [	SETOM EXMFLG	;BAD JFN STEPPED TO NEXT, REMEMBER TO EXAMINE IT
		JRST DTDEL2]
	SKIPE EXMFLG		;ARE WE SUPPOSED TO EXAMINE THIS DIRECTORY?
	JRST [	CALL GETDNM	;YES, SEE WHAT NUMBER IT IS
		CALL DELINI	;ESTABLISH THIS DIRECTORY AS CURRENT
		SETZM EXMFLG	;SAY NO MORE EXAMINATION NEEDED YET
		JRST .+1]
	CALL TYPIF		;TYPE FILENAME (RETURNS JFN IN A)
	MOVE A,INIFH1		;BEFORE STEPPING TO NEXT FILE
	MOVEM A,INIFHO		;REMEMBER WHICH JFN WE'RE ON
	CALL MFINP0		;GET SECOND JFN ON CURRENT FILE, RETURN IN A
	 JRST DTDEL2		;ERROR, MESSAGE ALREADY PRINTED
	MOVEM A,DELJFN		;SAVE JFN
	HRRZ A,A		;GET JFN
	TLNE Z,F5
	TXO A,DF%ARC		;ALLOW ARCHIVED FILES
	TLNE Z,F2
	TXO A,DF%EXP		;EXPUNGE FILE
	TLNE Z,F3
	TXO A,DF%FGT		;FORGET FILE
	TLNE Z,F4
	TXO A,DF%DIR		;ZAP DIRECTORY
	TRNE Z,1B18		;CONTENTS ONLY?
	TXO A,DF%CNO
	DELF
	 JRST [	TYPE <  >
		CALL $ERSTR	;PRINT ERROR MESSAGE
		ETYPE<%_>
		JRST DTDEL2]
	CALL TYPOK
	MOVE A,DELJFN		;GET FLAGS
	MOVE B,INIFHO		;GET OLD JFN POINTER
	CAMN B,INIFH1		;IF DIFFERENT JFN NOW, REPORT MIGHT BE DUE
	TXNE A,GN%STR!GN%DIR	;DID DIRECTORY JUST CHANGE?
	SETOM EXMFLG		;NEW JFN OR DIRECTORY CHANGED, REMEMBER TO EXAMINE DIRECTORY
DTDEL2:	SKIPE INIFH1		;DID WE USE UP ALL THE JFNS?
	JRST DELET3		;NO, GO CHECK NEXT JFN
	CALLRET PDLFRE		;REPORT ABOUT FINAL DIRECTORY AND RETURN

;ROUTINE USED BY DELETE TO PRINT NUMBER OF PAGES FREED IF EXPUNGE SUBCOMMAND
;WAS USED, OR IF SOME PAGES HAVE BEEN FREED

PDLFRE:	SKIPN A,DELDIR		;GET CURRENT DIRECTORY NUMBER
	RET			;WHOOPS, NONE!  USER TYPED "DELETE BLECCH"
	MOVE B,DELPGS		;CAUSE "PAGES FREED" TO BE 0 FOR NON-DIR DEVICE
	CAIE Q2,0		;DON'T TO "GTDAL" UNLESS MULTIPLE DIRECTORY DEVICE
	GTDAL			;CHECK ALLOCATION
	MOVE A,DELPGS		;GET ORIGINAL ALLOC
	SUB	A,B		;TAKE DIFFERENCE NOW
	TLNN Z,F2		;ALWAYS PRINT AFTER EXPUNGE
	JUMPE A,R		;DON'T PRINT IF 0
	MOVE C,DELDIR		;TELL TYPFRE WHICH DIRECTORY TO PRINT
	CALLRET TYPFRE		;PRINT RESULTS

;DELINI TAKES DIRECTORY NUMBER IN A AND INITIALIZES DATA TO WORK ON THAT
;DIRECTORY

DELINI:	MOVEM A,NEWDIR		;SET NEW DIRECTORY WE'RE WORKING ON
	CAMN A,DELDIR		;IS NEW ONE THE SAME AS THE OLD ONE?
	RET			;YES, SO DON'T RESET COUNTS OR TRY TO PRINT
	SKIPE DELDIR		;WAS THERE A PREVIOUS DIRECTORY?
	CALL PDLFRE		;YES, PRINT ITS RESULTS
	MOVE A,NEWDIR		;SET UP NEW ONE AS CURRENT
	MOVEM A,DELDIR		;REMEMBER DIRECTORY NUMBER
	CAIE Q2,0		;DON'T GET ALLOCATION FOR NON-DIRECTORY DEVICE
	GTDAL			;GET ALLOCATION
	MOVEM B,DELPGS		;SAVE PAGES IN USE
	RET

;GETDNM DECIDES WHAT DIRECTORY NUMBER WE'RE WORKING ON

GETDNM:	HRRZ A,@INIFH1		;GET JFN
	SETOM Q2		;ASSUME MULTIPLE DIRECTORY DEVICE
	CALL DIRQ		;SKIP IF DIRECTORY DEVICE
	MOVEI Q2,0		;NOT A MULTIPLE DIRECTORY DEVICE
	JUMPE Q2,R		;SKIP DIRECTORY NAME STUFF IF NOT MULTIPLE DIRECTORY DEVICE
	HRRZ B,@INIFH1		;JFN TO B
	LDF C,1B2+1B5+JS%PAF	;GET PUNCTUATED STRUCTURE AND DIRECTORY
	HRROI A,DELBUF		;WHERE TO PUT IT
	JFNS
	MOVSI A,(RC%EMO)	;LITERAL MATCH
	HRROI B,DELBUF		;STRING
	RCDIR			;GET DIR #
	HRROI B,DELBUF		;FOR ERROR MESSAGE
	TLNE A,(RC%AMB+RC%NOM)
	 ERROR <No such directory - %2m>
	MOVE A,C		;RETURN DIRECTORY NUMBER IN A
	RET

;DIRQ SKIPS IFF THE CURRENT JFN IS A MULTIPLE DIRECTORY DEVICE

DIRQ:	HRRZ A,@INIFH1		;GET RID OF FLAGS
	DVCHR			;GET DEVICE CHARACTERISTICS
	 ERCAL JERR		;UNEXPECTED FAILURE
	TXNE B,DV%MDD		;SKIP IF NON-DIRECTORY DEVICE
	RETSKP			;WE'LL SKIP, BECAUSE IT'S A DIRECTORY DEVICE
	RET

$DELET:	TABLE
	T ARCHIVE,,..ARCH
	T CONTENTS-ONLY,,.CNOLY
	T DIRECTORY,,..DIR
	T EXPUNGE,,..EXP
	T FORGET,,..FORG
	T KEEP,,..KEEP
	TEND

..ARCH:	NOISE <FILES INCLUDED>
	CONFIRM
	TLO Z,F5
	RET

.CNOLY:	CONFIRM
	SKIPE KEPNUM
	ERROR <Can't "KEEP" and "CONTENTS-ONLY" at the same time>
	TRO Z,1B18
	RET

..EXP:	NOISE <AFTER DELETING>
	CONFIRM
	SKIPE KEPNUM
	ERROR <Can't "KEEP" and "EXPUNGE" at the same time>
	TLO Z,F2		;FLAG EXPUNGE
	RET

..FORG:	NOISE <WITHOUT DEASSIGNING DISK ADDRESSES>
	CONFIRM
	SKIPE KEPNUM
	ERROR <Can't "KEEP" and "FORGET" at the same time>
	MOVX B,WHLU+OPRU
	CALL PRVCK
	 ERROR <WHEEL or OPERATOR capability required>
	TLO Z,F3
	RET

..KEEP:	DEFX <1>		;DEFAULT IS "1"
	DECX <Number of generations>
	 CMERRX			;NO DECIMAL NUMBER SUPPLIED
	CAIN B,1
	NOISE <GENERATION>
	CAIE B,1
	NOISE <GENERATIONS>
	CONFIRM
	SKIPN B
	ERROR <Number of generations may not be 0>
	TLNE Z,F3
	ERROR <Can't "KEEP" and "FORGET" at the same time>
	TLNE Z,F2
	ERROR <Can't "KEEP" and "EXPUNGE" at the same time>
	TRNE Z,1B18
	ERROR <Can't "KEEP" and "CONTENTS-ONLY" at the same time>
	MOVEM B,KEPNUM
	RET

..DIR:	NOISE <AND "FORGET" FILE SPACE>
	CONFIRM
	MOVX B,WHLU+OPRU
	CALL PRVCK		;MUST HAVE PRIVS FOR THIS FCN
	 ERROR <WHEEL or OPERATOR capability required>
	SKIPN KEPNUM
	TLZE Z,F2!F3
	TYPE <% KEEP or EXPUNGE or FORGET subcommand ignored>
	SETZM KEPNUM		;ZERO THIS
	TLO Z,F4		;SET FLAG FOR ZAP DIRECTORY
	RET

;PRUNE NUMBER OF GENERATIONS

;SOME BUFFER DEFINITIONS

VERBUF==BUF0			;PUT TABLE AT BUF0
VRTBLN==<BUFL-BUF0>/2		;USE 1/2 THE SPACE FOR STRING POINTERS,
				;THE OTHER 1/2 FOR STRINGS
VERSTR==VERBUF+VRTBLN		;START OF STRING SPACE
VEREND==BUFL+1000-5		;5 WORDS FOR OVERFLOW

KEEPDL:	CALL RLJFNS		;RELEASE ANY TEMPORARY JFNS
	CALL NXFILE		;CHECK FOR NON-EX TERMS
	 JRST KEEPDE		;END CHECK
	HRROI A,DELBUF		;GET POINTER TO STRING BUFFER
	HRRZ B,@INIFH1		;GET JFN
	LDF C,2B2+2B5+1B8+1B11+1B35 ;DEV, DIR, NAME, EXT
	JFNS			;SAVE NAME OF FILE
	 ERCAL JERRE
	MOVE A,[POINT 7,VERSTR]	;INIT POINTER TO VERSION STRING SPACE
	MOVEM A,KEPJNM		;SAVE HERE
	MOVSI Q1,-VRTBLN	;AOBJN PTR TO VER STRING PTR TABLE
	LDF	D,1B14+1B35	;GENERATION + PUNCTUATION
KEEPD1:	MOVE A,KEPJNM		;GET VERSION POINTER
	TLNE Z,F5		;ALLOWED TO DELETE ARCHIVE STUFF?
	 JRST KEEPD8		;YES, BYPASS CHECKS
	HRRZ A,@INIFH1		;GET CURRENT JFN
	MOVE B,[1,,.FBCTL]	;GET CONTROL BITS
	MOVEI C,C
	GTFDB
	 ERJMP .+1
	TXNE C,FB%ARC		;NOT DELETABLE?
	 JRST KEEPD9		;NO, PASS OVER IT
	HRRZ A,@INIFH1
	MOVE B,[1,,.FBBK0]
	MOVEI C,C
	GTFDB
	 ERJMP .+1
	TXNE C,AR%RAR		;REQUESTED ARCHIVE?
	 JRST KEEPD9		;YES, PASS OVER IT
KEEPD8:	MOVE A,KEPJNM		;GET VERSION POINTER
	HRRZ B,A
	CAIL B,VEREND		;BUFFER SPACE FULL?
	JRST KEEPOV		;YES
	MOVEM A,VERBUF(Q1)	;SAVE IN TABLE
	HRRZ B,@INIFH1
	MOVE C,D		;GET DISPOSITION
	JFNS			;INTO VERSION STRING SPACE
	 ERCAL JERRE
	SETZ C,
	IDPB C,A		;TERMINATE STRING
	MOVEM A,KEPJNM		;STORE UPDATED STRING POINTER
KEEPD9:	MOVE A,@INIFH1
	TLNE A,770000		;SKIP GNJFN IF NO STARS
	CALL $GNJFN		;CM236
	 JRST KEEPD3
	TLNE A,(1B14+1B15+1B16)	;DIR, NAME, EXT CHANGED?
	JRST KEEPD2		;YES, FINISH THIS FILE
	JUMPN C,KEEPD1		;IF NONE FOUND
	LDF	D,1B14		;GENERATION WITHOUT PUNCT.
	AOBJN Q1,KEEPD1		;INCREMENT VERSION PTR AND LOOP BACK
KEEPOV:	TYPE <%Too many generations for internal storage, will not print generations
>
	CALL KEEPPN		;PRINT NAME
	CALL KEEPDO		;DO DELETE (RETURNS # DELETED IN A)
	SKIPL A
	ETYPE < [%1Q generations deleted]
>
	MOVE A,@INIFH1
	TLNE A,770000
KEEPD4:	CALL $GNJFN		;CM236
	 JRST [	AOS A,INIFH1
		CAMLE A,INIFH2	;OFF END?
		SETZM INIFH1	;YES, INDICATE SUCH
		JRST KEEPDE]
	TLNN A,(1B14+1B15+1B16)
	JRST KEEPD4
	JRST KEEPDE

KEEPD3:	AOS A,INIFH1
	CAMLE A,INIFH2
	SETZM INIFH1
KEEPD2:	MOVEI A,1(Q1)		;GET NUMBER OF VERSIONS
	SUB A,KEPNUM		;GET NUMBER TO DELETE
	JUMPLE A,KEEPDE		;JUMP IF NONE
	CALL KEEPPN		;PRINT NAME
	MOVNI A,1(Q1)		;GET -NUMBER OF VERSIONS
	ADD A,KEPNUM		;GET NUMBER TO DELETE
	HRLZ Q1,A		;MAKE AOBJN PTR
KEEPD5:	MOVE A,VERBUF(Q1)
	ETYPE <%1M>
	AOBJN	Q1,[PRINT ","	;PRINT THEM ALL
		    JRST KEEPD5]
	CALL KEEPDO		;DO DELNF
	JUMPL A,KEEPDE		;ERROR?
	CALL TYPOK		;TYPE [OK]
KEEPDE:	SKIPE INIFH1
	JRST KEEPDL
	JRST DTDEL2

KEEPPN:	PRINT " "
	HRROI A,DELBUF		;GET NAME POINTER
	ETYPE <%1M>		;TYPE IT
	RET

KEEPDO:	MOVSI A,(GJ%OLD+GJ%PHY+GJ%SHT)
	HRROI B,DELBUF		;GET FILE VERSION 0 (HIGHEST)
	CALL GTJFS		;GET AND STACK JFN
	 JRST KEEPE1		;GTJFN FAILED
	MOVE B,KEPNUM		;NUMBER TO KEEP
	TLNE Z,F5		;ARCHIVE ALLOWED?
	 TXO A,DF%ARC		;YES, SAY SO.
	DELNF
	 JRST KEEPE2
	MOVE A,B		;RETURN NUMBER IN A
	RET

KEEPE2:	TYPE <   >
	CAIA
KEEPE1:	TYPE <   GTJFN failure for highest generation
?>
	CALL $ERSTR
	TYPE <
>
	SETO A,
	RET

;DISCARD (TAPE INFORMATION FOR FILES) <FILES>

.DISCA::NOISE <TAPE INFORMATION FOR FILES>
	MOVE A,[XWD -1,0]	;NO DEFAULT NAMES
	HRRZI B,(GJ%OLD+GJ%IFG+GJ%PHY+GJ%XTN+GJ%FNS+CF%NS) ;NO SUBCOMMANDS
	CALL SPECFN
	 JRST CERR		;DON'T ALLOW "STUFF,"
	SETOM TYPGRP		;ALWAYS TYPE THE NAME
	MOVE A,COJFN
	MOVEM A,OUTDSG		;WHERE OUTPUT GOES
	MOVE A,JBUFP
	MOVEM A,.JBUFP
DISCA1:	CALL RLJFNS		;RELEASE STRAY JFN'S
	CALL NXFILE		;STEP TO NEXT FILE IN GROUP
	 JRST DISCA2		;NO MORE IN THIS GROUP
	CALL TYPIF		;DO NAME
	CALL MFINP		;GET A SECOND JFN
	 JRST DISCA2		;FAILED?
	MOVX B,.ARDIS		;FUNCTION CODE FOR THE DISCARD
	MOVX C,AR%CR1+AR%CR2	;DO BOTH TAPES
	ARCF
	 ERJMP DISCA9		;FAILED...
	CALL TYPOK		;TELL THE USER IT'S DONE
DISCA2:	SKIPE INIFH1		;DONE THEM ALL?
	JRST DISCA1		;NO, CONTINUE THE PROCESS
	RET

DISCA9:	ETYPE < %?
>
	JRST DISCA2

;EXPUNGE (ALL DELETED FILES)

.EXPUN::TRVAR <EXPNST,EXPNFL,EXPDIR,OLDALC>
	GJINF
	MOVEM B,EXPDIR		;DEFAULT IS CONNECTED DIR
	NOISE <DIRECTORY>
	CALL CURNMS		;READ DIRECTORY NAME ALLOWING STARS
	 ERROR <No such directory>
	MOVEM A,EXPNFL		;SAVE THE FLAGS RETURNED
	MOVEM B,EXPNST		;SAVE THE POINTER TO THE DIR NAME STRING
	MOVEM C,EXPDIR		;SAVE DIRECTORY NUMBER

	CALL %EXPUN		;CHECK SUBCOMMANDS
EXPUN1:	CALL EXPDO		;GO EXPUNGE THIS DIRECTORY
	MOVE A,EXPDIR		;NOW STEP THE DIRECTORY NAME
	MOVE B,EXPNST		;GET POINTER TO THE USER NAME STRING
	MOVE C,EXPNFL		;GET THE FLAGS
	TXNE C,RC%WLD		;WILD CARDS TYPED?
	CALL STPDIR		;YES, GO STEP THE DIR NUMBER
	 RET			;NO MORE TO BE DONE
	MOVEM A,EXPDIR		;SAVE THE NEW DIRECTORY NUMBER
	JRST EXPUN1		;LOOP BACK FOR REST OF DIRS

;ROUTINE TO DO THE EXPUNGING
;ACCEPTS IN EXPDIR/	DIR NUMBER
;WARNING:  THIS IS NOT A GENERAL ROUTINE.  TO MAKE IT ONE, HAVE IT
;ACCEPT THE DIR IN A INSTEAD OF EXPDIR, SINCE EXPDIR IS LOCAL TO THE
;EXPUNGE COMMAND

EXPDO:	MOVE A,EXPDIR
	GTDAL
	MOVEM B,OLDALC
	MOVE B,EXPDIR
	HLLZ A,Q1		;GET BITS FROM ARGS
	DELDF
	  ERJMP	[TYPE <% >	;HANDLE ERROR
		 CALL %GETER	;GET ERROR CODE
		 MOVE A,ERCOD
		 CALL $ERSTR	;PRINT IT
		 MOVE A,EXPDIR	;GET DIR NUMBER
		 ETYPE< - %1R%%_> ;TERMINATE ERROR MESSAGE
		 RET]		;AND RETURN
	MOVE A,EXPDIR
	GTDAL
	MOVE A,OLDALC
	SUB A,B
	MOVE C,EXPDIR		;GET THE DIR NUMBER TO BE OUTPUT

;... FALL INTO TYPFRE

;TYPFRE TAKES NUMBER OF PAGES FREED IN A, DIR NUMBER IN C, AND PRINTS
;MESSAGE SAYING HOW MANY PAGES FREED

TYPFRE::MOVEI	B,[ASCIZ " %3R [%1Q"]
	SKIPN	A		;ANYTHING?
	MOVEI	B,[ASCIZ " %3R [No"]
	UETYPE	(B)		;PRINT FIRST PART
	TYPE	< page>		;BUILD CORRECT GRAMMAR
	CAIE	A,1		;ONLY ONE?
	PRINT	"s"		;NO - THEN PLURAL
	TYPE	< freed]
>
	RET

;ROUTINE TO GET EXPUNGE SUBCOMMANDS

%EXPUN:	SETZ Q1,		;CLEAR BITS
	CALL SPRTR
	 SUBCOM $EXPUN		;SUBCOMMANDS, READ 'EM
	RET

$EXPUN:	TABLE
	T DELETE,,.TEXP
	T PURGE,,.NXEXP
	T REBUILD,,.REBLD
	TEND

.TEXP:	NOISE <TEMPORARY FILES>
	CONFIRM
	TXO Q1,DD%DTF
	RET

.NXEXP:	NOISE <NOT COMPLETELY CREATED FILES>
	CONFIRM
	TXO Q1,DD%DNF
	RET

.REBLD:	NOISE <SYMBOL TABLE>
	CONFIRM
	TXO Q1,DD%RST
	RET

;COMMENT (END WITH ^Z)

.REMAR::NOISE (MODE)
	CONFIRM			;GET COMMAND CONFIRMATION
	TYPE <Type remark.  End with CTRL/Z.
>
	STKVAR <<CMTXTB,10>>
	SETZM .RDBFP+CMTXTB	;SAY NO BACKUP POINTER
	SETZM .RDRTY+CMTXTB	;SAY NO ^R POINTER
COM1:	MOVEI A,.RDBRK		;THIS MANY WORDS IN TEXTI BLOCK
	MOVEM A,.RDCWB+CMTXTB
	MOVX A,RD%JFN		;SAY WE'RE GIVING JFNS
	MOVEM A,.RDFLG+CMTXTB
	HRL A,CIJFN		;INPUT STREAM
	HRR A,COJFN		;EDITING STREAM
	MOVEM A,.RDIOJ+CMTXTB
	HRROI A,BUF0		;USE BUFFER SPACE FOR INPUT
	MOVEM A,.RDDBP+CMTXTB
	MOVX A,<BUFEND-BUF0+1>*5;THIS MANY CHARACTERS AVAILABLE IN BUFFER
	MOVEM A,.RDDBC+CMTXTB
	MOVEI A,[EXP 1B<3*8+2>,0,0,0]	;ONLY BREAK ON ^Z
	MOVEM A,.RDBRK+CMTXTB	;SET UP BREAK MASK
	MOVEI A,CMTXTB		;POINT TO BLOCK
	TEXTI			;INPUT SOME OF THE COMMENT
	 ERCAL CJERRE		;FAILED, GO SEE WHY
	MOVE A,.RDFLG+CMTXTB	;GET RESULTS
	TXNE A,RD%BTM		;^Z TYPED YET?
	 JRST UNMAP		;YES, CLEAN UP AND RETURN
	JRST COM1		;NOT YET, READ MORE

.CLOSE::NOISE <JFN>
	CRRX <Octal JFN number or blank for all>
	 CAIA			;NOT JUST "CLOSE<CR>"
	JRST SHUT
	OCTX <Octal JFN number>	;SEE IF OCTAL NUMBER
	 CMERRX			;NOT OCTAL NUMBER EITHER!
	CONFIRM
	PUSH P,B		;SAVE THE JFN
	CALL CLOPAT		;GO UNMAP THE FILES IF PA1050 THERE
	POP P,A			;PUT JFN IN A
	CAIG A,MAXJFN		;ERROR IF THE JFN IS NOT WITHIN BOUNDS
	SKIPG A
	ERROR <Illegal JFN number>
	CALL JFNREL
	 ERROR <JFN not in use>
	RET

;ENTER HERE WITH JFN TO RELEASE IN A

JFNREL:	TDZA	D,D		;NO SPECIAL BITS
JFNRLA::LDF	D,CZ%ABT	;CLOSE WITH ABORT
	HRRZ	A,A		;CLEAR LHS
	GTSTS
	TXNN B,GS%NAM		;ANYTHING IN THIS JFN?
	RET			;NO, RETURN
	ETYPE < %1P   %1S  >	;TYPE JFN AND NAME
	CAIN A,.PRIIN		;PRIMARY INPUT?
	JRST NRLPRI		;YES
	CAIN A,.PRIOU		;PRIMARY OUTPUT?
	JRST NRLPRO
	CALL NOTIO		;MAKE SURE JFN ISN'T BEING USED FOR EXEC COMMAND INPUT OR OUTPUT
	 JRST NRLEX		;NAUGHTY, NAUGHTY, TRYING TO CLOSE COMMAND JFN!
	TXNN B,GS%OPN		;OPEN?
	JRST [	RLJFN
		 JRST JFNER1
		JRST JFNOK1]
	HLL A,D			;USE BITS IN D
	CLOSF
	JRST JFNER2
JFNOK1:	GTSTS
	TXNE B,GS%NAM		;NAME STILL THERE?
	JRST JFNOK2
	TYPE < [OK]
>
	RETSKP

NRLPRI:	TYPE < Primary input not closed
>
	RETSKP

NRLPRO:	TYPE < Primary output not closed
>
	RETSKP

;USER TRIED TO CLOSE COMMAND JFN.  SEE WHETHER INPUT OR OUTPUT TO
;GIVE FANCY MESSAGE.

NRLEX:	TXNE B,GS%WRF		;OPEN FOR WRITE?
	JRST NRLEXO		;YES, ASSUME OUTPUT JFN
	JRST NRLEXI		;NO, ASSUME INPUT

NRLEXI:	TYPE < EXEC command input not closed
>
	RETSKP

NRLEXO:	TYPE < EXEC command output not closed
>
	RETSKP

JFNOK2:	TXNE B,GS%OPN
	TYPE < Can't close file
>
	TXNN B,GS%OPN
	TYPE < Can't release JFN
>
	RETSKP

JFNER1:	TYPE < Can't release JFN - >
	CAIA
JFNER2:	TYPE < Can't close file - >
	CALL $ERSTR		;PRINT ERROR IN A
	ETYPE<%_>
	RETSKP

SHUT:	CALL CLOPAT		;GO UNMAP THE PA1050 OPEN FILES
	MOVEI A,MAXJFN		;START WITH LARGEST TO BE LIKE FILSTAT
SHUT1:	PUSH P,A
	CALL JFNREL		;RELEASE JFN
	 JFCL			;IGNORE NOTHING THERE
	POP P,A
	SOJG A,SHUT1
	RET

;ADVISE (TERMINAL/USER)

.ADVIS::TLO Z,F2		;FLAG ADVISE
	NOISE <USER>
	JRST LINK0

.JILEN==.JILNO+1		;ROOM FOR ALL JOB INFO WE MAY NEED

;TALK (TERMINAL/USER)

.TALK::	TLZ Z,F2
	NOISE <TO>
LINK0:	TRVAR <DOLNKF,<JIBUF,.JILEN>,<LDBUF,3>,TFRAME,ADVJFN,ADVJNM,DIRNO>
	MOVEM P,TFRAME		;SAVE BEGINNING OF POSSIBITITES
	USERX <User name or terminal number>
	 JRST LTTY		;NOT USER NAME, SEE IF TERMINAL NUMBER TYPED
	CONFIRM
	MOVEM B,DIRNO		;SAVE USER NUMBER
	TLZ Z,F1		;NO DETACHED JOBS SEEN YET
	MOVEM P,TFRAME		;SAVE BEG OF ARGS
	HLLZ D,JOBRT		;MAKE AOBJN PTR
LINK3:	MOVEI B,(D)		;GET JOB NUMBER BY ITSELF
	CAME B,JOBNO		;LOOKING AT MY OWN JOB?
	SKIPN B			;OR JOB 0?
	JRST LINK6		;YES, SKIP IT
	CALL USERNO		;GET USER NUMBER
	CAME A,DIRNO
	JRST LINK6		;WRONG GUY
	GTB .JOBTT
	TLO Z,F1		;FLAG DETACHED JOB SEEN
	JUMPL A,LINK6		;AND SKIP IT IF DETACHED
	HLRZS A
	PUSH P,A		;SAVE TTY# (1ST WORD OF A POSSIBILITY)
	GTB .JOBPN		;GET PROGRAM NAME
	PUSH P,A		;SAVE SUBSYSTEM NAME (2ND WRD OF POSS.)
LINK6:	AOBJN D,LINK3		;MAY HAVE MORE JOBS
	CAMN P,TFRAME		;FOUND ANY?
	 JRST [	TLNE Z,F1
		ERROR <User has detached jobs only
 Use "MAIL" to send mail to user>
		MOVE A,CUSRNO	;GET MY USER NUMBER
		CAMN A,DIRNO	;LOOKED FOR MY OWN JOBS?
		JRST LINKNS	;YES, SAY CAN'T DO MYSELF
		ERROR <User is not logged in
 Use "MAIL" to send mail to user>]
	POP P,A			;SUBSYSTEM NAME
	POP P,B			;TTY#
	CAMN P,TFRAME		;ONLY ONE POSSIBILITY?
	JRST [	MOVE A,B	;YES, USE IT
		TLO Z,F3	;NO CONFIRM NEEDED
		JRST LINK11]

LINK7:	MOVE C,B		;SAVE FOR POSSIBLE DEFAULT
	ETYPE < TTY%2O%, >
	JUMPE A,[PRINT "?"	;NO SUBSYS NAME
		JRST LINK8]
	CALL SIXPRT		;PRINT SUBSYSTEM

LINK8:	ETYPE <%_>
	CAMN P,TFRAME		;DONE ALL?
	 JRST LINK9		;YES
	POP P,A
	POP P,B
	JRST LINK7

LINK9:	PROMPT <TTY: >
	HRROI A,LDBUF		;GET POINTER FOR DEFAULT STRING
	MOVEM A,CMDEF		;SAVE POINTER TO DEFAULT
	MOVE B,C		;GET DEFAULT TTY # (FIRST ONE ON LIST)
	MOVEI C,8		;IN OCTAL
	NOUT			;CREATE DEFAULT STRING
	 CALL JERR		;SHOULDN'T FAIL
	OCTX <Terminal number>
	 CMERRX			;NON-OCTAL NUMBER TYPED
	JRST LINK10

LTTY:	OCTX			;USER NAME NOT TYPED, SEE IF TERMINAL NUMBER
	 CMERRX <User name or terminal number required>
LINK10:	CONFIRM

LINK11:	PUSH P,B		;SAVE TTY#
	GJINF			;GET JOB INFORMATION
	TLNN Z,F2		;SKIP CHECK IF ADVISING
	CAME D,0(P)		;IS TTY# IDENTICAL TO MY TTY NUMBER ?
	SKIPA
LINKNS:	 ERROR <Cannot talk to self>
	HLRE B,TTYJOB		;GET NEG SIZE OF TABLE
	MOVMS B
	POP P,A			;TTY#
	CAIGE A,0(B)
	CAIGE A,0
	 ERROR <Nonexistent terminal number>
	TLNN Z,F3
	MOVE P,TFRAME
	PUSH P,A
	SETZ D,
	GTB .PTYPA
	MOVE D,A
	POP P,A
	CAIGE A,(D)		;PTY?
	JRST NOPTYL		;NO
	PUSH P,D		;MAYBE.  CHECK FOR ABOVE LAST PTY
	HLRZ D,D		;NUMBER OF PTYS
	ADD D,0(P)		;LAST PLUS ONE
	POP P,0(P)		;CLEAR STACK
	CAIL A,(D)		;ABOVE PTY'S?
	JRST NOPTYL		;YES.  NVT OR SOMETHING ELSE
	PROMPT < [Pseudo-terminal, confirm]>
	CALL FCONFA
NOPTYL:	TLNE Z,F2
	JRST ADVISE		;GO GIVE ADVISE
CS,<				;CM290 Additional message
	TYPE < Escape character is <CTRL>E
>				;CM290
>;CS				;CM290
	MOVEI B,.TTDES(A)	;FORM TTY DESIGNATOR
	MOVE A,[1B2+1B3+.CTTRM]	;TO AND FROM CONTROLLING TTY
	TLINK
	 ERROR <Refused, use "MAIL" to send mail to user>
CS,<				;CM290 Additional escape
	MOVEI A,1		;CM290 Tell interrupt handler
	MOVEM A,ADVFLG		;CM290 That Talk is in progress
	MOVE C,EXECAP+1		;CM290 Get current capabilities
	MOVEI A,.FHJOB		;CM290 Change job-wide setting
	MOVX B,1B<ADVESC>	;CM290 For the ^E character
	TXNE C,SC%CTC		;CM290 Can it be done?
	STIW%			;CM290 No
	MOVE A,[ADVESC,,^D24]	;CM290 Enable ^E channel
	ATI%			;CM290 For escape
>;CS				;CM290
	RET

;CODE TO GIVE ADVISE - CHECK TERMINAL PRINT JOB INFO

ADVISE:	MOVEM A,ADVTNM
	MOVX B,WHLU!OPRU
	CALL PRVCK
	CAIA
	JRST ADVIS1		;SKIP CHECK IF PRIVILEGED
	TRO A,.TTDES
	RFMOD
	 ERJMP [CALL TX1SKP	;FAILED, SEE IF FOR LINE NOT ACTIVE
		 CALL JERRE	;STRANGE ERROR, REPORT IT
		JRST ADVIS1]	;NOTHING ON LINE, THAT'S O.K.
	TRNN B,TT%AAD
	ERROR <Destination not receiving advice>
ADVIS1:	HLRE A,TTYJOB		;CM224
	MOVNS A,A
	CAMGE A,ADVTNM
	ERROR <Illegal terminal number>
	MOVNI A,1
	MOVE B,[-1,,C]
	MOVEI C,.JITNO
	GETJI
	 CALL JERR
	CAMN C,ADVTNM
	ERROR <Cannot advise self>
	TYPE < Escape character is <CTRL>E, type <CTRL>^? for help
>
	MOVE D,ADVTNM
	GTB .TTYJO
	HLRZ B,A
	CAIN B,-1
	JRST [	TYPE < No job on terminal.
>
		JRST CONNECT]
	CAIN B,-2
	JRST [	TYPE < Terminal being assigned.
>
		JRST CONNECT]
	TRZE B,400000
	TYPE < Not controlling terminal.
>
	MOVEM B,ADVJNM
	PRINT " "
	MOVE A,ADVJNM
	MOVEI B,JIBUF		;GET ADDRESS OF BUFFER
	HRLI B,-.JILEN		;SPECIFY LENGTH
	MOVEI C,0
	GETJI
	 CALL JERR
	SKIPN B,.JIUNO+JIBUF
	JRST [	TYPE <Not logged in>
		JRST NOLOGD]
	ETYPE <%2R>
NOLOGD:	MOVE B,.JIDNO+JIBUF
	CAMN B,.JILNO+JIBUF
	JRST NOCOND
	UETYPE [ASCIZ /, %2R/]
NOCOND:	MOVE B,ADVJNM
	ETYPE < Job %2Q>
	PRINT " "
	SKIPN A,.JIPNM+JIBUF
	MOVE A,.JISNM+JIBUF
	CALL SIXPRT
	ETYPE<%_>

;CODE TO GIVE ADVISE - MAKE CONNECTION, LOOP SENDING CHARACTERS

CONNEC:	SETOM DOLNKF		;SAY TLINK NEEDED
	MOVE B,ADVTNM		;GET TERMINAL NUMBER
	TRO B,.TTDES		;SET UP TERMINAL NUMBER FOR STI
	MOVEM B,ADVTNM
	CALL CHKLNK		;TRY TO ESTABLISH LINK FIRST
	MOVE C,EXECAP+1		;CM224 get current capabilities
	MOVEI A,.FHJOB
	MOVX B,1B<ADVESC>	;ONLY THE ADVICE ESCAPE CHARACTER DOESN'T GET SENT TO THE REMOTE JOB
	TXNE C,SC%CTC		;CAN'T SET JOB TIW IF NO ^C PRIV
	STIW
	MOVE A,[ADVESC,,^D24]	;CONTROL-E IS USED TO GET OUT
	ATI
	SETOM ADVFLG		;FLAG IN ADVISE CODE
	TLZ Z,F3		;NOT IN COMMENT NOW
	LDF A,GJ%SHT		;SHORT FORM GTJFN
	HRROI B,[ASCIZ /TTY:/]	;WE NEED BINARY CHANNEL.  THIS IS SO
				;IF THINGS LIKE "TER RA" OR "TER NO RA"
				;ARE "SENT" TO REMOTE JOB, THEY HAVE
				;EFFECT
	CALL GTJFS		;GET HANDLE ON TTY FOR BINARY COMMUNICATION
	 CALL CJERRE		;FAILURE, PRINT ERROR AND RETURN
	MOVE B,[100000,,OF%RD]	;OPEN THE JFN FOR READ
	OPENF
	 ERCAL CJERRE		;FAILED
	MOVEM A,ADVJFN		;REMEMBER THE ADVISE JFN
	MOVEI A,.CTTRM		;CONTROLLING TERMINAL
	RFMOD			;GET CURRENT SETTING OF PAGE MODE
	MOVE C,B		;GET A COPY OF IT
	ANDX C,TT%PGM		;KEEP ONLY PAGE MODE
	MOVEM C,SAVPGM		;REMEMBER CORRECT SETTING
	TXZ B,TT%PGM		;TURN OFF PAGING SO WE CAN SEND CTRL/Q TO REMOTE TERMINAL
	STPAR
ADVLOP:	MOVE A,ADVJFN
	TLNE Z,F3		;COMMENT?
	MOVE A,CIJFN		;YES, USE REGULAR ECHOING TTY CHANNEL
	BIN
	MOVE C,B		;PUT CHARACTER IN C
	ANDI C,177		;STRIP TO 7 BITS FOR IDENTIFICATION
	CAIN C,"^"-100		;^^ ?
	JRST SNCTRL		;YES, SEND CONTROL CODE
;**;	[721]	Insert 7 lines at ADVLP1: - 1	6-APR-82	KR
	CAIE C,CTRLO		;[721]DID HE TYPE CTRL/O?
	JRST ADVLP1		;[721]NO, GO ON
	PUSH P,B		;[721]SAVE FOR LATER
	MOVEI A,.FHSLF		;[721]SET UP TO SEND INTERRUPT
	HRLZI B,10000		;[721] ON USUAL CTRL/O CHANNEL
	IIC			;[721] TO OURSELVES.
	POP P,B			;[721]SET UP FOR STI
ADVLP1:	TLNE Z,F3		;COMMENT?
	JRST ADVLOP		;YES, DON'T SEND CHAR
	MOVE A,ADVTNM
	STI
	 ERJMP [SKIPL DOLNKF	;HAVE WE SUCCESSFULLY LINKED YET?
		JRST ILISTI	;YES, SO ANALYZE ERROR
		PRINT .CHBEL	;NO, SO ECHO A BELL TO TYPIST
		JRST .+1]	;GO WAIT FOR TLINK TO SUCCEED (WAIT FOR USER TO TYPE ^C)
ADVLP2:	CALL CHKLNK		;SEE IF TLINK NEEDED (MAYBE OTHER JOB WENT AWAY, WHICH BREAKS LINK)
	JRST ADVLOP		;GO GET NEXT CHARACTER

;TX1SKP sees if the last error was due to line being not active.
;
;Returns+1:	other error
;	+2:	TTYX01 was last error

TX1SKP:	CALL DGETER		;GET REASON
	CAIE A,TTYX01		;IS LINE NOT ACTIVE?
	RET			;OTHER ERROR
	RETSKP			;LINE IS NOT ACTIVE

;CHKLNK ATTEMPTS TO ESTABLISH LINKS IF THEY'RE NOT ALREADY ESTABLISHED.

CHKLNK:	MOVE B,ADVTNM
	MOVE A,[1B2+1B3+.CTTRM]	;TO AND FROM CONTROLLING TTY
	TLINK
	 ERJMP [CALL TX1SKP	;TLINK FAILED, SEE IF BECAUSE LINE NOT ACTIVE
		 JRST CJERRE	;OTHER FAILURE, TELL USER WHAT IT IS
		JRST CONN1]	;LINE NOT ACTIVE, DON'T CLEAR FLAG YET
	AOSN DOLNKF		;GIVE ANNOUNCEMENT FIRST TIME
	TYPE < [Advising]
>
CONN1:	RET

ILISTI:	SETOM DOLNKF		;REMEMBER TO RETRY LINK IF WE RECOVER
	CALL %GETER
	MOVE A,ERCOD
	CAIN A,IOX33		;INPUT BUFFER IS FULL?
	JRST ADVLP2		;RIGHT, ASSUME USER HEARD BELL
	CAIN A,TTYX01		;LINE BECAME INACTIVE AND USER ISN'T A WHEEL?
	JRST IS1		;WHAT A CROCK, STI SHOULD BE FIXED IN MONITOR
				;TO MERELY WORK ON INACTIVE LINE.  ^C SHOULD
				;START JOB, AND OTHER CHARACTERS SHOULD BEEP
				;JUST AS THOUGH REAL TYPIST WERE THERE.
	CAIE A,DEVX2
	CAIN A,DESX2
	CAIA
	JRST CJERR
IS1:	TYPE <
 [Destination refused advice]
>
	JRST ADVDON

SNCTRL:	BIN
	MOVE C,B		;GET 7-BIT VERSION OF CHARACTER
	ANDI C,177
	CAIN C,"("
	JRST STCOMM
	CAIN C,")"
	JRST ENCOMM
	CAIN C,"+"
	JRST RELINK
	CAIN C,"?"
	JRST TYPADV
	CAIL C,141
	CAILE C,172
	CAIA			;NOT LOWER CASE LETTER
	TRZ B,40		;LOWER CASE, MAKE UPPER CASE
	TRZ B,300		;MAKE INTO A CONTROL (A BECOMES CTRL/A ETC.)

	JRST ADVLP1

;START COMMENT

STCOMM:	TYPE <^^(>		;ECHO CHARACTER HE TYPED
	TLO Z,F3		;FLAG NOT TO SEND CHARS
	JRST ADVLOP

;END COMMENT

ENCOMM:	TLZ Z,F3		;FLAG TO SEND CHARS AGAIN
	JRST ADVLOP

TYPADV:	UTYPE [ASCIZ /
CMND		EFFECT
----		------
<CTRL>E		Quit
<CTRL>^+	Relink to remote terminal
<CTRL>^(	Start comment
<CTRL>^)	End comment
<CTRL>^?	Type this list
<CTRL>^<CHAR>	Send <CTRL><CHAR>
/]
	JRST ADVLOP

RELINK:	MOVE A,[1B2+1B3+.CTTRM]	;TO AND FROM CONTROLLING TTY
	MOVE B,ADVTNM
	TLINK			;PUT HIS OUTPUT ON OUR TERMINAL
	 JRST [	TYPE <
 TLINK failure
>
		JRST ADVLOP]
	TYPE < [Advising]
>
	JRST ADVLOP

ESCPSI::SKIPN ADVFLG
	DEBRK			;JUST IN CASE
ADVDON:	CALL ICLEAR		;DISMISS INTERRUPT TO .+1
CS,<				;CM290 
	SKIPL ADVFLG		;CM290 Is it only a Talk?
	JRST ADVDN1		;CM290 Yes
>;CS				;CM290
	CALL DOATI		;FIX ^C AND ^E (DO HERE SO ^C WORKS IF REMOTE IS XOFFED)
	CALL FIXON		;FIX PAGE MODE
ADVMES::TYPE <
 [Advice terminated]
>
	MOVEI Q1,ETTYMD
	CALL LTTYMD		;RESTORE TTY MODES
	MOVE B,ADVTNM		;GET TERMINAL WE WERE ADVISING
	CALL BREAK1		;BREAK LINKS
	SETZM ADVFLG
	MOVE A,ADVJFN		;GET SPECIAL JFN AGAIN
	CLOSF			;RELEASE IT
	 ERCAL CJERRE		;SHOULDN'T FAIL
	JRST ERRET		;ERROR RETURN TO TTY MODES RESET

CS,<				;CM290
ADVDN1:	MOVEI B,-1		;CM290 Break the link to all remotes
	CALL BREAK1		;CM290 ...
	CALL DOATI		;CM290 Reset interrupts
	SETZM ADVFLG		;CM290 No longer in this mode
	TYPE <
 [Link terminated]
>				;CM290
	JRST ERRET		;CM290 Done
>;CM290 end CS

;"LIST" IS WITH "TYPE" BELOW.

;LOGIN COMMAND
;LOGIN (USER) NAME (ACCOUNT) ACCOUNT (SESSION-REMARK) REMARK
;PASSWORD: PASSWORD

MAXLLS==40			;CS122 Max length of this string

.QLOGI::SKIPA A,[1]		;CS111 Flag process did fast login
.LOGIN::SETO A,			;CS111 Normal login case
	TRVAR <LPASP,LOGNO,LERRF,RCBITS,<LDBLK,GTDLN>,LACCT,SAV17,<ACBLK,.ACJOB+1>,LFLAG,<LLLSTR,MAXLLS>,LCJB> ;CS111;CM335;CS90;CS122
	MOVEM A,LFLAG		;CS111 Save type of login
	SKIPE CUSRNO
	ERROR <You are already logged in>
	SETO A,			;CS90 This job
	MOVEI B,LCJB		;CS90 Where to put CJB value
	HRLI B,-1		;CS90 One word
	MOVEI C,.JICPJ		;CS90 want controlling job info
	GETJI%			;CS90 Get it
	 SETOM LCJB		;CS90 Assume none

;DECODE ARGUMENTS

;FIRST ARGUMENT: USER NAME

	NOISE <USER>		;SEE COMMENTS ON "SPECEOL" ABOUT "NOISE"
	SETZM LERRF		;NO ERROR YET
	CALL USERN		;CS92 Get user name
	 JRST [	MOVEM A,LERRF	;FAILED, REMEMBER
		MOVEI B,[FLDDB. .CMUSR,CM%PO]	;TRY TO READ PARSE-ONLY NAME
		CALL FLDSKP
		 CMERRX		;IF THAT FAILS, GIVE UP
		JRST .+1]
	SETOM CEBPTR		;EM66 Don't save the login command
	MOVEM A,RCBITS		;SAVE INFO RETURNED BY "RCDIR"
	MOVEM C,LOGNO		;SAVE DIRECTORY NUMBER
	SETZM LPASP		;CM259 Default to none
;CM259 *** 4 lines deleted ***
	NOISE <ACCOUNT>
;CM259 *** 14 lines deleted ***
	SETZM CMDEF		;CM259 NO DEFAULT
	CALL ACCT		;INPUT AND DECODE ACCT # (USES A)
	MOVEM A,LACCT		;SAVE FOR LOGIN JSYS
	NOISE (SESSION-REMARK)
	CALL GSR		;GET SESSION-REMARK
	MOVE Q1,A		;SAVE POINTER TO SESSION-REMARK
	CONFIRM			;CONFIRM THE WHOLE COMMAND

;LOGIN...
;ALL ARGS DECODED, NOW LOG THE GUY IN

NEWF,<
	GTAD			;SET UP MAIL WATCH INTERVAL HERE
	ADDI A,^D910		; FOR +5 MINS
	MOVEM A,MWATCT		; IN CASE "MESMES" NEVER CALLED
>
	SETOM MESMSF		;SAY TYPE "YOU HAVE A MESSAGE" IF APPROPRIATE,
				;EVEN AFTER ^C'S
	SKIPE A,LERRF		;ERROR ALREADY?
	ERROR <%1?>		;YES, PRINT MESSAGE INSTEAD OF TRYING TO LOG IN
	CALL PIOFF		;^C BETWEEN LOGIN AND CUSRNO SETUP WOULD BE EMBARRASING
	SKIPE NLIACC		;CS90 Restricted?
	 CALL GETPSW		;CS90 Get password & verify it always
LOGIN1:				;CM259
	MOVE A,LOGNO		;CS61 USER #
	SKIPN LCJB		;CS90 Make sure not CJB=0 - SYSJOB login
	IFSKP.			;CS90 (don't need to worry about batch case)
	  SKIPN NLIACC		;CS90 If restricted, then go for it (have pwd)
	  SKIPN LPASP		;CS61 If no pword yet, try attaching
	  CALL TRYATT		;CS61 Maybe attach to detached job
	ENDIF.			;CS90
	MOVE C,LACCT		;ACCT # OR PTR THERETO
	MOVE B,LPASP		;POINTER TO PASSWORD
	MOVE D,C		;GET ACCT STRING
	ILDB D,D		;LOOK AT FINAL ACCOUNT
	SKIPN D			;HAVE ONE?
	SETZM C			;NO. USE NOTHING
	MOVEI D,0		;RESERVE D FOR FUTURE FLAGS
	LOGIN
	IFJER.			;CS90 Failed
	  CAIN A,LGINX1
	  ERROR <Illegal account>
	  CAIE A,
	  CAIE A,LGINX4		;CS90 Bad password?
	   CALL CJERRE		;CS90 Nope - punt
	  CALL GETPSW		;CS90 Get a password if none yet
	  JRST LOGIN1		;CS90 and try LOGIN again
	ENDIF.			;CS90
LOGIN0::SETZM NLIACC		;CS118;CS90 No longer restricted
	SETOM SYSMF		;SET FLAG SO SYSTEM MESSAGES WILL GET PRINTED
	MOVE B,LFLAG		;CS111 Get type of login done
	MOVEM B,LGNFLG		;CS111 Remember it
	MOVE B,LOGNO		;WHAT "RCUSR" RETURNED
	MOVEM B,CUSRNO		;STORE USER NUMBER
	MOVEM A,LOGDAT		;SAVE DATE OF LOGIN
	GJINF			;GET LOGGED-IN DIRECTORY NUMBER
	MOVEM B,LIDNO		;SAVE IT.
	MOVEI A,.FHSLF		;CM224 Get new capabilities
	RPCAP%			;CM224
	IFXN. B,SC%CTC		;CM224 Have control-c capability?
	  TXO C,SC%CTC		;CM224 Turn it on
	  EPCAP%		;CM224 and enable it
	ENDIF.			;CM224
	DMOVEM B,EXECAP		;CM224
;CM335	CALL PION		;ALLOW ^C NOW THAT CUSRNO IS SET UP
	CALL IPCINI		;EM34 Initialize user IPCF
	MOVE A,Q1		;POINTER TO SESSION REMARK
	CALL SSR		;SET SESSION-REMARK

;LOGIN...
;THE AUTOLOGOUT FOR USE TO GET KILLED HERE, NOW WE MUST KILL OFF THE
;PENDING TIMER CLOCK

	MOVE A,[.FHSLF,,.TIMBF]	;DELETE ALL ENTRIES BEFORE GIVEN TIME
	MOVE B,[377777,,-1]	;TIME WAY OUT IN THE BOONIES (WON'T
				;CLOBBER ANY RUNTIME LIMIT SETTING
	SETZ C,
	TIMER
	 JFCL			;DON'T CARE IF NONE PENDING

;TYPE "JOB <N> ON LINE N <DATE> <TIME>"

	ETYPE < Job %J on %L %D %E
>				;EOL NEEDED BEFORE LOGIN MESSAGE
	SKIPG LOGDAT		;CM335 Has the user logged in before?
	 CALL CHGPAS		;CM335 No, require a password change now
	SKIPG LGNFLG		;CS122 Skip this stuff if quick login
	SKIPG D,LOGDAT		;CS122 Logged in before?
	IFSKP.			;CS122 Yes
CS,<	  SETO A,		;CS122 Current job
	  MOVX B,<-2,,Q1>	;CS122 Get info into Q1 and Q2
	  MOVX C,.JILL1		;CS122 Want last login location info
	  GETJI% >		;CS122 Get it
	   SETZ Q1,		;CS122 Failed
	  TYPE < Last login on > ;CS122
	  MOVE A,COJFN		;CS122
	  MOVE B,D		;CS122 Get TAD of last login
	  SETZ C,		;CS122
	  ODTIM%		;CS122
CS,<	  IFN. Q1		;CS122 No location info?
	    CALL GETLLS		;CS122 Get last login string
	    ETYPE < from %3\>	;CS122
	  ENDIF.		;CS122
   >;CS				;CS122
	  ETYPE <%_>		;CS122
	ENDIF.			;CS122
CS,<	SKIPN A,LPASP		;CS146 Have a password?
	IFSKP.			;CS146 Yes
	  CALL CHKPSW		;CS146 See if it is valid
	   JRST CHGPA0		;CS146 Print error & force password change
;	ANNSK.			;CS146 It isn't...
;	  ETYPE <%% Your password is not secure - %1M %_> ;CS146
;	  TYPE <% You should change it, since the system will soon require you to do so.
;>				;CS146
	ENDIF.			;CS146
   >;CS				;CS146
	
	CALL PION		;CM335 Now allow ^C (moved here from about 20
				; lines earlier, so user can't ^C out of the
				; password change)
	SKIPLE LGNFLG		;CS111 Skip crud if QLOGIN
	IFSKP.			;CS111
	  MOVE A,LACCT		;CM348 Specified an account?
	  ILDB A,A		;CM348
	  SKIPN A		;CM348
	  CALL PRTACC		;CM348 No, tell user
CS,<	  CALL CHKDAL		;CM290
	  CALL ACCEXP		;CS28 See if account is about to expire
	  CALL CHKPLN >		;CS131 Check for a plan file
	ENDIF.			;CS111
	SKIPG LOGDAT		;CM336 Has the user logged in before?
	 JRST [ GTAD%		;CM336 Get current date/time
		SUB A,[1,,0]	;CM336 Subtract 24 hours
		MOVEM A,LOGDAT	;CM336 Don't print system messages posted
				; earlier than that date/time
		JRST .+1 ]	;CM336 Proceed
	MOVE B,RCBITS		;WHAT RCUSR RETURNED
	TXNE B,RC%RLM		;B2 SAYS ALWAYS PRINT LOGIN MESSAGE
	SETZM LOGDAT		;SET DATE TO 0 TO FORCE PRINTING

NONEWF,<
;TYPE "YOU HAVE A MESSAGE" IF A FILE "MAIL.TXT.1" OF NON-0 LENGTH
; EXISTS IN THIS DIRECTORY.

	CALL MESMES
>
;GET DEFAULT EXEC INPUT FILE

	CALL PNTMES		;CM224 Print system messages, etc.  Here
				; (before Login.Cmd) for people who run
				; Getmsg, <Cl0x>Exec, etc...
	SETOM LOGINI		;SET FLAG TO DO "TAKE INITIAL-LOGIN-TYPIN.TXT"
				;AT NEXT OPPORTUNITY.
	RET


;CS90  *** Begin *** (derived from CM259)

;Routine to get a password if none obtained yet. Gets password string from
;user and verifies it if NLI restricted. Does not return if password is
;incorrect or a password was already obtained. Used by ATTACH and LOGIN.

GETPSW:	SKIPE LPASP		;Any password yet?
	ERROR <Incorrect password> ;Yes, it was wrong
	CALL PASLIN		;Request password
	MOVEM A,LPASP		;Remember it
	SKIPN NLIACC		;Restricted?
	 RET			;Nope - just return with it
	MOVEI B,ACBLK		;Address of argument block
	MOVE C,LOGNO		;User number
	HRLI C,540000		;LH directory number
	MOVEM C,.ACDIR(B)	;Set up in block
	MOVEM A,.ACPSW(B)	;Pointer to password
	SETOM .ACJOB(B)		;For this job
	MOVX A,AC%PWD!.ACJOB+1	;Function+block length
	ACCES%			;Check password
	IFJER.			;Failed
	  ERROR <Login incorrect> ;Give ambiguous error & abort
	ENDIF.
	RET			;Password OK - return success

;CS90 *** End ***

;CS131 *** Begin ***
CS,<
;Check for existance of a plan file for the user. If none exists, then we
;try to run the MKPLAN program.

CHKPLN:	MOVX A,GJ%SHT!GJ%OLD	;Old files only...
	HRROI B,[ASCIZ/FINGER.PLAN/]
	GTJFN%			;Check for it
	IFSKP.			;Found one...
	  MOVX B,<1,,.FBCTL>
	  MOVX C,D
	  GTFDB%		;Get file information
	   ERCAL CJERRE		;Shouldn't happen
	ANDXE. D,FB%OFF		;File must be online...
	  RLJFN%		;All ok - flush the jfn
	  TRN
	  RET			;And just return
	ENDIF.

	HRROI B,[GETSAVE (SYS:MKPLAN.)]
	CALL TRYGTJ		;Try to get it
	 RET			;No program. No big deal - punt
	CALL PIOFF		;Be fascist
	PUSH P,[300000,,PION]	;Force return to turn on interrupts
	PUSH P,A		;Preserve MKPLAN.EXE jfn
	MOVE A,COJFN
	MOVX B,.MOSBD		;Want backspace-means-delete
	SETO C,			;  so Unix idiots don't put ^H in plan files
	MTOPR%
	POP P,A			;Restore MKPLAN.EXE jfn
	CALL STEPH		;Go run the program
	MOVE A,COJFN
	MOVX B,.MOSBD		;Fix backspace-means-delete to system default
	SETZ C,
	MTOPR%
	MOVX A,GJ%SHT!GJ%OLD
	HRROI B,[ASCIZ/MKPLAN.TMP/]
	GTJFN%
	 RET			;Nope. Don't bother
	MOVE D,A		;Stash the jfn
	MOVX A,GJ%SHT!GJ%FOU
	HRROI B,[ASCIZ/FINGER.PLAN;P774242/]
	GTJFN%			;Can we get a new one?
	IFSKP.			;Good...
	  MOVE B,A		;Copy new designator to correct place
	  MOVE A,D		;Get back file des.
	  RNAMF%		;Rename it
	  TRN			;Ignore failure
	  SKIPA A,B		;Get FINGER.PLAN jfn
	ENDIF.			;And fall through to release it
	MOVE A,D		;Get back MKPLAN.TMP jfn
	RLJFN%			;Flush it
	TRN
	RET			;Done
	  
>;CS
;CS131 *** End ***

;CS122 *** Begin ***
CS,<
; Routine to search TTYLOC database to get location string ptr in C
; Called with Q1 and Q2 containing terminal location information
; This code is stolen from Finger and is probably not the best way to
; do this. It is the only Exec code that runs in a non-zero section.

TTLSEC==2
TTLPAG==<TTLSEC>_9
TTLADR==<TTLPAG>_9
TTYLEN==MAXLLS

GETLLS:	MOVX A,.FHSLF
	DIR%			;Cannot take interrupts in section 1
	CALL GETLLX		;Do the work
	MOVX A,.FHSLF
	EIR%			;Turn interrupts back on
	RET

GETLLX:	IFXN. Q1,JI%LBT		;Batch job (shouldn't happen)?
	  HRROI C,[ASCIZ/Batch job/]
	  RET
	ENDIF.
	IFXN. Q1,JI%LPT		;Was it a PTY?
	  LOAD D,JI%LCJ,Q1	;Get job number
	  IFE. D		;SYSJOB?
	    HRROI C,[ASCIZ/Sysjob subjob/]
	    RET
	  ENDIF.
	  HRROI A,LLLSTR	;Point at string
	  HRROI B,[ASCIZ/PTY (CJ #/]
	  SETZ C,
	  SOUT%
	  MOVE B,D		;Get controlling job #
	  MOVEI C,^D10
	  NOUT%
	   TRN
	  HRROI B,[ASCIZ/, user /]
	  SETZ C,
	  SOUT%
	  PUSH P,A		;Save BP
	  MOVE B,Q2		;Get number
	  HRLI B,500000		;Make user number
	  DIRST%		;Translate it
	   JRST [MOVE A,(P)	;Get back BP
		 MOVEI B,"#"
		 IDPB B,A
		 MOVE B,Q2	;Get number again
		 MOVEI C,^D10
		 NOUT%
		  TRN
		 JRST .+1]
	  ADJSP P,-1
	  MOVEI B,")"
	  IDPB B,A
	  SETZ B,
	  IDPB B,A
	  HRROI C,LLLSTR
	  RET
	ENDIF.
	STKVAR <TTYJFN,TTYSIZ>
	HRROI C,[ASCIZ/Unknown location/]
	MOVX A,<GJ%SHT!GJ%OLD!GJ%PHY>
	HRROI B,[ASCIZ/SYSTEM:TTYLOC.BIN/]
	GTJFN%			;Lookup ttyloc file
	 RET			;Failed. Punt with string ptr in C
	MOVEM A,TTYJFN
	MOVX B,OF%RD
	OPENF%			;Open it
	 JRST [	MOVE A,TTYJFN
		RLJFN%
		 TRN
		RET]
	MOVE A,TTYJFN		;Get jfn
	SIZEF%			;Get size
	 SETZ C,
	SKIPN C			;Make sure not empty
	 JRST [	MOVE A,TTYJFN
		CLOSF%
		 TRN
		RET]
	MOVEM C,TTYSIZ		;Save size
	MOVX A,.FHSLF		;This process
	DIR%			;Turn off interrupts, since unhandlable
	MOVX A,<.FHSLF,,0>
	MOVX B,<.FHSLF,,1>
	MOVX C,<SM%RD!SM%WR!SM%EX!1>
	SMAP%			;Copy section 0 to 1
	XJRSTF [0
		1,,.+1]		;Enter extended section
	MOVE C,TTYSIZ
	HRLZ A,TTYJFN		;JFN on ttyloc file
	MOVX B,<.FHSLF,,TTLPAG>	;This process, ttyloc section
	TXO C,<PM%RD!PM%CNT>	;PMAP flags
	PMAP%			;Read ttyloc file
	HRROI A,LLLSTR		;Point to string buffer address
	DMOVE B,Q1		;Get arguments
	CALL DOLOOK		;Lookup name
	 SKIPA C,[-1,,[ASCIZ/Unknown location/]]
	HRROI C,LLLSTR		;Point to string
	XJRSTF [0
		0,,.+1]		;Return to section 0
	EXCH C,TTYSIZ		;Save C, get size back
	SETO A,
	MOVX B,<.FHSLF,,TTLPAG>
	TXO C,PM%CNT		;Only want count
	PMAP%			;Unmap file
	MOVX B,<.FHSLF,,TTLSEC>
	MOVEI C,1
	SMAP%			;Delete section 1
	MOVE A,TTYJFN		;JFN
	CLOSF%			;Close file
	 TRN
	MOVE C,TTYSIZ		;Get back pointer
	MOVX A,.FHSLF
	EIR%			;Turn interrupts back on
	RET			;And return

;Routine stolen from Finger to do the actual lookup
;
;Accepts:
;	T1:	Byte pointer to buffer
;	T2:	Internet host number
;	T3:	16-bit terminal identifier
;
;Returns:
;	+1 on failure
;	+2 on success, with updated pointer in T1
;

DOLOOK:	ACVAR <W1,W2,W3,W4>	;AC variables
	SAVEAC <B,C>		;Save temp AC's
	MOVX W2,TTLADR		;Put file start address in W2
	MOVE W3,(W2)		;Number of 2-word host entries
	LSH W3,1		;Multiply by 2
	ADD W3,W2		;Point at last host entry+1
	DO.
	  MOVE W1,W2		;Low bound
	  ADD W1,W3		;High bound
	  LSH W1,-1		;Divide by 2 to make average
	  TRZ W1,1		;Must always be even
	  CAMN B,1(W1)		;See if it's this host
	  EXIT.			;Found host
	  CAMG W3,W2		;Upper bound must be .LT. lower bound
	  JRST TTNFND		;Or else we overlapped - not found
	  CAMGE B,1(W1)		;Compare
	  IFSKP.		;
	    MOVE W2,W1		;It was greater - lower bound := current
	    ADDI W2,2		;And make it one entry more
	    LOOP.		;Go for more
	  ENDIF.		;End if
	  MOVE W3,W1		;It was less - upper bound := current
	  SUBI W3,2		;Minus one entry
	  LOOP.			;Go for more
	ENDDO.			;End do
	HRR W2,2(W1)		;Get pointer to terminal table for this host
	MOVE W3,(W2)		;Number of 2-word terminal entries
	MOVE W4,[TRZ W1,1]	;Instruction to use if parity is even
	TRNE W2,1		;Skip if parity is even
	MOVE W4,[TRO W1,1]	;Instruction to use if parity is odd
	SUBI W3,1		;Subtract one from the total
	LSH W3,1		;Multiply by 2
	ADD W3,W2		;Point at last terminal table entry
	DO.			;Loop
	  MOVE W1,W2		;Low bound
	  ADD W1,W3		;High bound
	  LSH W1,-1		;Divide by 2 to make average
	  XCT W4		;Execute the check
	  CAME C,1(W1)		;See if it's this terminal
	  IFSKP.		;Yes
	    MOVE B,2(W1)	;Make pointer to description
	    HLL B,W2		;Use same section
	    ADD B,[G1BPT 0,7,0] ;Point there
	    MOVEI C,<TTYLEN*5>	;Max count
	    SETZ D,		;Terminate on null
	    SOUT%		;Copy string
	    RETSKP		;Done
	  ENDIF.
	  CAMG W3,W2		;Upper bound must be .LT. lower bound
	  JRST TTNFND		;Or else we overlapped - not found
	  CAMGE C,1(W1)		;Compare
	  IFSKP.
	    MOVE W2,W1		;It was greater - lower bound := current
	    ADDI W2,2		;Plus one entry
	    LOOP.		;Go for more
	  ENDIF.		;End if
	  MOVE W3,W1		;It was less - upper bound := current
	  SUBI W3,2		;Minus one entry
	  LOOP.			;Go for more
	ENDDO.
;
; If we couldn't find either the host or the terminal, then put 'Via '<name>
; as the location.
;
TTNFND:	MOVE W3,C		;Move terminal ID to W3
	CAME B,[^D128_^D24+^D2_^D16+^D254_8+^D255] ;CSFE host?
	IFSKP.			;Yes
	  HRROI B,[ASCIZ/F.E. line/]
	  MOVEI C,^D10
	  SOUT%
	ELSE.	  
	  MOVE W2,B		;Put host number into W2
	  HRROI B,[ASCIZ/host /]
	  MOVEI C,5
	  SOUT%
	  MOVE B,W2		;Host number here
	  CALL GETNAM		;Translate it to the name
	  IFNSK.
	    MOVE B,W2		;And host number
	    CALL HOSTNM		;Translate it
	  ENDIF.
	ENDIF.
	CAMN W3,[37777,,777777]	;If 32-bit -1, then not terminal ID
	IFSKP.
	  MOVEI B," "		;Separator
	  IDPB B,A
	  MOVEI B,"#"
	  IDPB B,A
	  MOVE B,W3		;The terminal ID
	  MOVEI C,^D8		;In octal
	  NOUT%			;Output it
	   TRN
	ENDIF.
	RETSKP			;Done

; Routine to translate host number to name
; T1/Byte pointer to string
; T2/Host number

GETNAM:	SAVEAC <C,D>
	MOVE C,B		;Copy host number
	MOVE B,A		;Copy byte ptr
	MOVX A,.GTHNS		;Want primary Internet name
	GTHST%			;Try to get it
	 ERJMP GETNA1		;Nope. Try for DECnet
	MOVE A,B		;Update ptr
	RETSKP			;Success return
GETNA1:	LDB D,[POINT 24,C,^D27] ;Get first 3 bytes of host number
	CAMN D,[<^D128_^D16>+<2_^D8>+^D253] ;Is it a decnet host (crock)?
	IFSKP.
	  MOVE A,B		;Restore pointer
	  RET			;and return failure
	ENDIF.
	MOVE D,B		;Copy byte ptr
	PUSH P,D		;Save it
	ANDX C,377		;Isolate last byte of host number
	MOVEI B,C		;Block is at T3
	MOVEI A,.NDRNM		;Get node name function
	NODE%
	 ERJMP .+1		;NODE jsys probably nonexistant - just fail
	POP P,C			;Get back old byte ptr
	CAME C,D		;Same?
	 AOS (P)		;Nope. Must've been updated - retskp
	MOVE A,D		;Update byte pointer
	RET

; Routine to translate host number into octet string
; T1/byte pointer to string
; T2/host number
; Get host number into octet format string.

HOSTNM:	SAVEAC <C,D,Q1>
	MOVEM B,Q1		;Put host number elsewhere
	LDB B,[POINT 8,Q1,11]	;Get first byte
	MOVEI C,^D10		;Output host parts in decimal
	NOUT%
	 TRN
	MOVEI D,"."		;Delimiter
	IDPB D,A		;Add it
	LDB B,[POINT 8,Q1,19]	;Get next byte
	NOUT%
	 TRN
	IDPB D,A		;Another dot
	LDB B,[POINT 8,Q1,27]	;Get next byte
	NOUT%
	 TRN
	IDPB D,A		;...
	LDB B,[POINT 8,Q1,35]	;Get final byte
	NOUT%
	 TRN
	RET
	ENDAV.
   >
;CS122 *** End ***

;CS61  *** Begin *** 

;Routine to check for detached jobs & offer to attach

TRYATT:	PUSH P,A		;Save A (user #) from LOGIN%
	CALL PION		;CS78 Allow interrupts....
	CALL CHKDET		;Check for detached jobs
	IFSKP.			;He wants to attach...
	  POP P,B		;Restore user number into B
	  MOVE C,LPASP		;CS90 Point to password, if it exists yet
	  ADJSP P,-1		;Make us not called from LOGIN
	  CALLRET ATTAC1	;And join ATTACH code
	ELSE.
	  CALL PIOFF		;Turn interrupts back off in login
	  POP P,A		;Restore A
	  RET			;And return to LOGIN code
	ENDIF.

$ATTK1:	TABLE
	T No,ONEWRD,0
	T Yes,ONEWRD,1
	TEND

$ATTK2:	TABLE
	T No,ONEWRD,0
	TEND

;Check for detached jobs.
;   A/ user number
;   CALL CHKDET
;Returns +1 if no detached jobs, or doesn't want to attach
;        +2, with job number in A of job to attach
;
;Clobbers A,B,C,D and the BUF1 buffer
;

CHKDET:	SAVEAC <Q1>		;Use this for counting up total jobs
	SETZ Q1,		;Counter of inuse jobs
	HRRZ D,A		;Stash user number away for later
	HLRZ B,JOBRT		;-number of jobs in system
	CAIL B,-1000		;More than will fit in BUF1?
	IFSKP.
	  TMSG <%Unable to check for detached jobs - more than 512 jobs
>
	  RET
	ENDIF.
	MOVEI A,.JOBDI		;JOBDIR table number
	HLLZ B,JOBRT		;Number of jobs
	HRRI B,BUF1		;Put it in BUF1
	GTBLT%			;Read JOBDIR table
	IFJER.			;Failed...
	  TMSG <%Unable to check for detached jobs - error reading JOBDIR
>
	  RET
	ENDIF.
	MOVE B,JOBRT		;AOBJN pointer of jobs
	SETZ C,			;Count of jobs found
	DO.
	  SKIPE BUF1(B)		;Is there a (logged-in) job there?
	   ADDI Q1,1		;Increment count
	  CAME D,BUF1(B)	;This user number?
	  IFSKP.		;Yup.
	    HRLZ A,B		;Get job number in LH of A
	    HRRI A,.JOBTT	;Job/terminal table number
	    GETAB%		;Get terminal number for this job
	     JRST NOTDET	;If error, then ignore this job
	    JUMPGE A,NOTDET	;If positive tty number, then not detached
	    HRRZM B,BUF1(C)	;A detached job. Save it in the list
	    ADDI C,1		;And increment count of them
	  ENDIF.
NOTDET:	  AOBJN B,TOP.		;Loop for all jobs
	ENDDO.
	SKIPN C			;Any found?
	 RET			;Nope
	HLRE B,JOBRT		;Get -number of jobs in system
	ADD Q1,B		;Add to Q1
	MOVNS Q1		;Make positive count of free job slots
	CAIE C,1		;Only one detached job?
	IFSKP.
	  MOVE B,BUF1		;Get job number from list
	  CAIL Q1,^D10		;Less than 10 free job slots?
	  IFSKP.		;Yes - force the issue
	    ETYPE <[Attaching to your detached job #%2Q]
>
	    MOVE A,B		;Put job number into A
	    RETSKP		;And return success
	  ELSE.
	    ETYPE <You have a detached job (job #%2Q)
>
	    PROMPT <Attach to this detached job? >
	    MOVEI A,.PRIIN
	    CFIBF%		;Flush any typeahead
	    KEYWD $ATTK1	;Parse response
	     0
	     JRST CERR		;Error...
	    HRRZ C,(B)		;Get the value
	    HRLZ D,(C)		;From the address
	    SKIPN D		;Yes response?
	    IFSKP.
	      MOVE A,BUF1	;Put the job number in A
	      RETSKP		;And return good
	    ELSE.
	      RET		;Just return
	    ENDIF.
	  ENDIF.
	ELSE.			;More than one
	  TMSG <You have the following detached jobs:>
	  MOVN D,C		;Copy A & negate
	  HRLZS D		;Move RH to LH
	  DO.
	    MOVE B,BUF1(D)	; Get the job number
	    ETYPE < %2Q>	;Print this one
	    AOBJN D,TOP.	; For all jobs in list
	  ENDDO.
	  TMSG <
>
	  CAIL Q1,^D10		;Less than 10 free job slots?
	  IFSKP.		;Don't give him "No" option
	    PROMPT <Enter job number: >
	  ELSE.
	    PROMPT <Enter job number or "No" to not attach: >
	  ENDIF.
	  MOVEI A,.PRIIN
	  CFIBF%		;Flush any typeahead
	  MOVEI B,[FLDDB. .CMKEY,CM%SDH,$ATTK2,,,[
		   FLDDB. .CMNUM,CM%SDH,^D10,<Job number or "No">,,]]
	  CAIGE Q1,^D10		;CS78 10 or more job slots?
	   MOVEI B,[FLDDB. .CMNUM,CM%SDH,^D10,<Job number>] ;CS78
	  CALL FLDSKP		;Parse response
	   CMERRX		;Failed...
	  CONFIRM		;Do a confirm
	  LDB D,[331100,,(C)]	;Get function typed
	  CAIE D,.CMNUM		;A job number?
	   RET			;Must be "No" keyword.
	  MOVE A,B		;Put job number into A
	  RETSKP		;And return true
	ENDIF.


;CM348 Routine to print " Usage is being charged to ..." message

PRTACC::STKVAR<<ACTBUF,10>>	;CM348
	SETO A,			;CM348 Find out which account we are using
	HRROI B,ACTBUF		;CM348 ...
	GACCT%			;CM348 ...
	HRROI A,ACTBUF		;CM348 Get back pointer to string
	ETYPE < Usage is being charged to account %1M> ;CM348
CC,<				;CM348
	MOVX A,F%USET		;CM348 Tell Fngdat we want account title
	DMOVE B,ACTBUF		;CM348 Pass it first 10 chars of account number
	SETZ D,			;CM348 No special formatting wanted
	ETYPE < (>		;CM348 Format the output nicely
	CALL IACSND		;CM348 Talk to Fngdat (routine prints response)
	TYPE <)>		;CM348 Terminate message nicely
>;CC				;CM348
	ETYPE <%_>		;CM348
	RET			;CM348

CS,<
;CS28 Routine to determine if the user's logged in account will expire "soon"
; and wrn him if so.  "Soon" is currently .LEQ. 30 days.

ACCEXP::SETO A,			;CS28 Current job
	MOVE B,[-1,,C]		;CS28 Return 1 word in C
	MOVX C,.JIEXP		;CS28
	GETJI%			;CS28 Get account expiration date
	 ERJMP ACCEX2		;CS28 If error assume no expiration date
	SKIPN C			;CS28 Is there one?
	 JRST ACCEX2		;CS28 No, skip this
	GTAD%			;CS28 Yes, get current date/time
	ADD A,[30,,0]		;CS28 Add 30 days
	CAMLE C,A		;CS28 Will account expire before then?
	 JRST ACCEX2		;CS28 No
	STKVAR <<CURACT,^D8>>	;CS28 Yes, create temp storage for account
	SETO A,			;CS28 Specify current job
	HRROI B,CURACT		;CS28 Put account string here
	GACCT%			;CS28 Get account string for this job
	HRROI A,CURACT		;CS28 Get back pointer to account string
	ETYPE < [Your account %1\ will expire on %3D]%_> ;CS28
ACCEX2:	RET			;CS28
> ;end CS

;*** CM335 Begin addition ***

;Routine which forces a user to change his password the first time s/he logs
;in after the directory is created.
;
;Takes:
;	LPASP (TRVAR)/	Pointer to current password string.  If 0, we assume
;			that the login was via PTYCON or something similar and
;			do nothing
;	BATCHF/		non-zero if job is a batch job
;Returns:
;	+1 always (does a JRST @CERET on "impossible" CRDIR% failure)
;Clobbers:
;	A-D
;NB:
;	- This routine should be called with ^C turned off, since otherwise
;	  it can't force users to change their passwords if they don't want
;	  to.
;	- This routine does nothing if the job is a batch job or the old
;	  password pointer is 0 (indicating that no password was specified
;	  during the Login).
;	- There is a loop in this routine, extending from CHGPS2 down to
;	  the POP P,CERET.  Normally the loop is executed once, but if an
;	  error occurs inside the loop, the special we have stuffed into
;	  CERET causes the error handler to return to the top of the loop
;	  after the error has been processed.

CHGPA0:	STKVAR<<CHPBLK,.CDPSW+1>,<MYDIR,^D10>,ERRSAV>
	ETYPE <?Sorry, your password is insecure - %1M %_>
	JRST CHGPA1		;Enter common routine

CHGPAS:	STKVAR<<CHPBLK,.CDPSW+1>,<MYDIR,^D10>,ERRSAV>
	SKIPN LPASP		;Password specified for login?
	 RET			;No, Ptycon login or some such so skip this
	SKIPE BATCHF		;Batch job?
	 RET			;Yes, skip this
	TYPE <
 This is the first time that you have logged into this user-id on  this
 system.  You should  change your password  now so that  only you  know
 what it  is.
>
CHGPA1:	TYPE < You  will be  prompted for  a new  password.   Passwords should be 6  to 8
 characters in length.   They should  not be  common words or names that might
 easily be guessed by someone trying to break into your user-id.
>
	HRROI A,MYDIR		;Make pointer to directory name string buffer
	MOVE B,LIDNO		;Get directory number of user's directory
	DIRST%			;Get directory name string
	 CALL CJERRE		;Shouldn't happen...
	MOVEM P,SAV17		;Save Stack pointer in case of an error
	MOVE A,CERET		;Save error address
	MOVEM A,ERRSAV		;...
	MOVEI A,CHGPS2		;Get local error address
	MOVEM A,CERET		;Store it in case of an error
CHGPS2:	MOVE P,SAV17		;Restore stack pointer (might be wrong due to
				; an error in a subroutine)
	MOVEI A,[ASCIZ /        New password: /]
	CALL PASSX		;Read password with noise words "New password"
	MOVEM A,.CDPSW+CHPBLK	;Save pointer to new password string
	ILDB A,A		;Get first character of new password
	SKIPN A			;Null?
	 ERROR <A zero-length password is not allowed>
IFN 1,<				;Future...
CS,<	MOVE A,.CDPSW+CHPBLK	;Get password again
	CALL CHKPSW		;See if password is OK
	 ERROR <That password is not secure - %1M>
   >;CS
   >;IFN 0
	MOVEI A,[ASCIZ /        Retype new password: /]
	CALL PASSX		;Read new password again
	MOVE B,.CDPSW+CHPBLK	;Get first attempt at typing it
	STCMP%			;Make sure they're the same
	CAIE A,0		;Are they?
	ERROR <The two copies of the new password weren't the same>
	MOVE A,LPASP		;Get pointer to old password
	MOVE B,.CDPSW+CHPBLK	;Get pointer to new password
	STCMP%			;Make sure they're not the same
	CAIN A,0		;Are they?
	ERROR <Please choose a new password which is not the same as your old password>
	MOVEI B,CHPBLK		;Get address of the argument block
	TXO B,CD%PSW		;Indicate we're changing the password only
	MOVE C,LPASP		;Get pointer to current password
	MOVE A,ERRSAV		;Get back original error address
	MOVEM A,CERET		;The CRDIR% should succeed, but don't loop
				; if it doesn't
	HRROI A,MYDIR		;Get pointer to directory string
	CRDIR%			;Make the change
	RET			;All done

;***  CM335 end addition  ***

;SIMULATE "TAKE" COMMAND OF FILSPEC (STRING POINTER IN B)
;SKIPS IFF SUCCEEDS IN SETTING UP STREAM

TAKEIN::STKVAR <<TAKBUF,FILWDS>,SPB>
	MOVEM B,SPB		;SAVE STRING POINTER
	MOVE B,LIDNO		;GET LOGGED-IN DIRECTORY NUMBER
	HRROI A,TAKBUF		;GET STRING SPACE POINTER
	CAMN B,[-1]		;DEFAULT?
	JRST TAKEI1		;YES, SKIP DIR
	DIRST			;STORE DIR STRING
	 CALL JERR		;WE JUST SCANNED IT?!
TAKEI1:	MOVE B,A
	MOVE A,SPB
	SETZ C,			;READ TO NULL
	SIN			;APPEND TO STRING
	HRROI B,TAKBUF		;GET POINTER TO BEGINNING
	CALL TRYGTL		;TRY TO FIND IT.
	 JRST TAKIN2		;NO SUCH FILE, GO AWAY QUIETLY
	MOVE B,[70000,,OF%RD]
	OPENF
	 JRST [	HRROI B,TAKBUF	;GET POINTER FOR ERROR MESSAGE
		LERROR <Can't read %2m%%_%%1?>
		HRRZ A,JBUFP
		HRRZ A,(A)	;GET SAVED JFN
		RLJFN		;RELEASE IT
		 CALL JERR
		HRRZ A,JBUFP
		SETOM (A)
		RET]
	HRL A,A			;PUT INPUT JFN IN LEFT HALF
	HRR A,COJFN		;USE SAME OUTPUT AS WERE USING
	MOVE B,TAKDEF		;USE DEFAULT SETTINGS
	CALL PUSHIO		;SAVE OLD IO STREAM, START NEW ONE
	RETSKP			;DOUBLE RETURN WHEN SUCCESSFUL
TAKIN2:	RET			;FAILED, TAKE SINGLE RETURN

;SPECEOL
;SUBROUTINE TO HANDLE EOL AS FIELD TERMINATOR IN THE MIDDLE OF A COMMAND
; IN THE SPECIAL MANNER REQUIRED FOR "LOGIN".
;CR NORMALLY TERMINATES COMMAND, DEFAULTING ANY FOLLOWING FIELDS.
;BUT IF P2=EOL AND THIS SUBROUTINE IS CALLED AND A "NOISE"
;  MACRO FOLLOWS THE CALL, THE FOLLOWING NOISE WORD IS TYPED
;  (AS AFTER ALT MODE), PARENTHESIZED TEXT IS IGNORED (AS AFTER SPACE),
;  AND FIELD IS INPUT NORMALLY, NOT DEFAULTED.

	;THIS UNWRITTEN ROUTINE SHOULD SOMEHOW ALLOW CARRIAGE RETURN
	;IN THE MIDDLE OF COMMANDS, SUCH THAT THE GUIDE WORDS FOR THE NEXT
	;FIELD COME OUT ON THE NEW LINE, AS THOUGH THE CR WAS $.  BEWARE
	;OF THE FOLLOWING PITFALLS OF THIS:
	;1)	ON REPARSE, GUIDEWORDS ARE ALREADY IN BUFFER, SO SOMEHOW
	;	REPARSED CR SHOULD DO NOTHING.  NOTE THAT REPARSED $ IS
	;	NONEXISTANT, AS $ CAUSES ACTION BUT DOESN'T STAY IN
	;	BUFFER.  YOU CAN'T AFFORD NOT TO LEAVE CR IN BUFFER,
	;	BECAUSE ^R AND RUBOUT WON'T WORK CORRECTLY, ESPECIALLY
	;	ON SCREEN TERMINALS.
	;2)	IF THE CR PROVOKED GUIDEWORDS ARE IMPLEMENTED AS PROMPTS,
	;	RUBBING OUT WON'T WORK.  USER WILL JUST GET A DING.
	;3)	MOST DESIRABLY, CR IN THE MIDDLE OF COMMANDS SHOULD WORK
	;	FOR ALL COMMANDS, NOT JUST SPECIAL ONES LIKE LOGIN,ATTACH.
	;	THIS CREATES A PROBLEM WITH CASES WHERE A FIELD HAS A
	;	DEFAULT VALUE.  CONSIDER THE AMBIGUITY UPON SEEING
	;	CR:  DOES THE CR MEAN DEFAULT THE FIELD VALUE, OR
	;	TYPE THE GUIDEWORDS.  FOR INSTANCE, SHOULD "DIRECTORY<CR>"
	;	TYPE "(OF FILES)", OR DEFAULT THE FILE SPEC TO *.* AND
	;	TAKE OFF?
	RET

;USERN
;INPUT USER NAME SUBR
;USED BY "LOGIN" AND "ATTACH".
;RETURNS RCUSR'S RETURNED INFO IN A,B,C.
;SKIPS, BUT NOT IF BAD NAME TYPED, IN WHICH CASE A CONTAINS ERROR CODE

USERN:	SKIPN NLIACC		;CS90 NLI restricted?
	IFSKP.			;CS90 Yes
	  MOVEI B,[FLDBK. .CMFLD,,,<User name>,,[BRMSK. FLDB0.,FLDB1.,FLDB2.,FLDB3.,<.>]] ;CS90
	  CALL FLDSKP		;CS90 Parse it
	   CMERRX <Invalid USER name> ;CS90 Punt if an error here
	ELSE.			;CS90
	  USERX <User name>
	   JRST [CALL %GETER	;FAILED, FIND OUT WHY
		 MOVE A,ERCOD	;RETURN ERROR IN A
		 RET]
	ENDIF.			;CS90
	CALL BUFFF		;BUFFER IT RIGHT FOR JSYS, PUT PTR IN A
	MOVE B,A
	ILDB A,A		;CS90 Get one character
	SKIPN A			;CS90 Make sure he typed something...
	 ERROR <User name not specified> ;CS90 Punt
	MOVSI A,(RC%EMO)	;SAYS NO RECOGNITION
	RCUSR			;STRING TO DIRECTORY # TRANSLATION
	IFXN. A,RC%AMB!RC%NOM	;CS90 RCUSR Lost
	  HRROI B,[ASCIZ/NOT-LOGGED-IN/] ;CS90 Random non-FILES-ONLY directory
	  MOVSI A,(RC%EMO)	;CS90 Exact match
	  RCUSR			;CS90 Use this
	  TXNE A,RC%AMB!RC%NOM	;CS90 Lost again??
	   SETZ C,		;CS90 Then use 0
	ENDIF.
	RETSKP

;ACCT
;RUTINE TO INPUT ACCOUNT STRING, RETURNS SUITABLE ARG
;FOR LOGIN OR CACCT JSYS.
;USED IN ACCOUNT, CHANGE, LOGIN COMMANDS.

ACCT::	ACCTX <Account name>
	 CMERRX
	JRST BUFFF		;STRING CASE. SAVE IN BUFFER.

;PASWD
;SUBROUTINE TO INPUT PASSWORD FOR "LOGIN", "ATTACH", AND "CONNECT".
;HANDLES HALF AND FULL DUPLEX CASES.
;BUFFERS IT FOR USE AS A JSYS ARGUMENT AND RETURNS BYTE PTR IN A.

PASLIN::MOVEI A,[ASCIZ /Password: /]

PASSX::	MOVEI C,1
	CALL NOECHO		;PROMPT TYPER LOOKS AT ONE INPUT CHARACTER SO TURN OFF ECHOING FIRST
	SETOM PWDREQ		;CM156 Flag password required for this command
	UPROMPT @A		;TYPE PROMPT
	CALL PASWD		;SPR 13716
	CONFIRM			;SPR 13716
	RET			;SPR 13716

PASFLD::TDZ C,C			;FOR A PASSWORD FIELD, NO CRLF WANTED (IE LOGIN)

PASWD::	CALL NOECHO		;MAKE SURE ECHOING OFF
	CALL CHKPTY		;SKIP IF NOT A PTY
	JRST PASWDF		;PTY - HANDLE FULL DUPLEX CASE ONLY
	MOVE A,CIJFN
	RFMOD			;READ TTY MODE
	TRNE B,1B32		;SKIP IF FULL DUPLEX
	JRST PASWD1

;FULL DUPLEX CASE
;DON'T ECHO PASSWORD FIELD, DO ECHO TERMINATOR

PASWDF:	CALL INPPAS		;INPUT THE PASSWORD
	CALL DOECHO		;NOW WE WANT ECHOING ON
	CALL GETTER		;GET THE TERMINATING CHARACTER
	CAIE A,.CHCRT		;END OF LINE?
	CAIN A,.CHLFD
	CAIA			;YES
	JRST PSWDF1		;NO
	MOVEI A,.CHLFD		;CM259 Fix command buffer
	DPB A,CMPTR		;CM259 so .CMINI doesn't try to redo it
	MOVE A,CIJFN		;YES, SEE IF IT GOT ECHOED
	RFPOS
	TRNE B,-1		;ARE WE AT COLUMN 1?
	ETYPE <%_>		;NO, TYPE A CRLF
PSWDF1:	CALLRET BUFFF		;BUFFER PASSWORD AND CHECK IT IF POSSIBLE

;PASWD...
;HALF DUPLEX CASE
;USE SEPARATE LINE, TYPE MASK FIRST

PASWD1:	TYPE <
>
	UPROMPT [BYTE (7)130,130,130,130,130,130,130,130,130,15
		BYTE (7)127,127,127,127,127,127,127,127,127,15
		BYTE (7)115,115,115,115,115,115,115,115,115,15
		BYTE (7)15,15,0]
				;PASWORD MASK, OVERLAYED X, W, M, AND GARBAGE
	CALL INPPAS		;INPUT THE PASSWORD
	PRINT CR		;SET TO OVERPRINT SAME LINE
	TYPE <Thank you ... >
	ETYPE<%_>
	ETYPE<%_>
	CALLRET BUFFF		;BUFFER AND MAYBE CHECK PASSWORD

;ROUTINE TO INPUT THE PASSWORD

INPPAS:	JUMPE C,INPP1		;DO THIS ONLY IF CRLF IS NEEDED
	STKVAR <SAVFLG,SAVPTR>
	MOVE A,CMFLG
	MOVEM A,SAVFLG		;SAVE FLAGS IN CASE REPARSE IS NEEDED
	MOVE A,CMPTR
	MOVEM A,SAVPTR
	CRRX <Password>		;HAVE TO TRY CR SO COMND DOESN'T RETYPE "PASSWORD:" IF HE TYPES NULL PASSWORD
	 JRST INPP1		;NOT NULL PASSWORD
	MOVE A,SAVFLG		;UNPARSE THE CARRIAGE RETURN
	MOVEM A,CMFLG		;CALLERS WILL PARSE CONFIRM AFTER PASSWORD
	MOVE A,CMPTR		;SEE WHERE WE ARE ON LINE NOW
	MOVE B,SAVPTR		;SEE WHERE WE WERE AT BEGINNING OF LINE
	MOVEM B,CMPTR		;RESET FIELD POINTER TO BEGINNING OF LINE
	CALL SUBBP		;GET NUMBER OF CHARACTERS WE WANT TO BACK UP
	ADDM A,CMINC		;INCREASE NUMBER OF UNPARSED CHARACTERS
	ADDM A,CMCNT		;SHOW INCREASE IN SPACE LEFT
	SETZM ATMBUF		;DENOTE NULL PASSWORD
	RET

INPP1:	WORDX <Password>	;READ NON-NULL PASSWORD
	 CMERRX
	RET

;MESMES
;SUBROUTINE TO TYPE "YOU HAVE A MESSAGE" IF FLAG "MESMSF" IS ON AND
;THERE IS A MESSAGE FILE IN CONNECTED DIRECTORY.
;USED IN LOGIN, MAIN LOOP. CLOBBERS A,B,C.

MESMES::SKIPN CUSRNO
	JRST MESMS9		;IGNORE IF NOT LOGGED IN
	SKIPE BATCHF		;DON'T CHECK FOR MESSAGES IN BATCH (TO SAVE TIME)
	 JRST MESMS9		;YES, SKIP MESSAGES
CC,<	CALL CHKDAL >		;CM290 NOTE OVER ALLOCATION IN PRESENT FIRST
NONEWF,<
	MOVE B,CUSRNO		;THE USER NUMBER TO CHECK FOR MAIL
	CALL MALCHK		;CHECK FOR NEW MAIL
	 JRST MESMS9		;NO NEW MAIL, NO PRINTOUT
	TYPE < You have a message
>				;USER TYPES FILE TO RECEIVE MESSAGE
>
NEWF,<
	HRLOI B,377777		;SET INF COUNT FOR US
	MOVEM B,MWATN0
	MOVE B,CUSRNO		;SET UP FOR MAIL CHECK FOR THIS USER
	MOVEM B,MWATDR
	CALL MALCHK		;DO MAIL CHECK
	 JRST MESMS9		;NO MAIL
	TYPE < You have >
	JUMPE A,[ETYPE <new mail%_> ;CM317
		 JRST MESME1]	;CM317
	TYPE <new >		;CM317
;CM236	TLNN B,77		;CHECK NETWORK MAIL FLAG
;CM236	TYPE <net >
	ETYPE <mail %1\%%_%>
>
MESME1:				;CM317
	MOVE A,COJFN
	DOBE			;WAIT FOR IT TO REALLY PRINT
NEWF,<
	GTAD			;SET UP NEXT LOOK TIME
	ADDI A,^D910		; FOR +5 MINS
	MOVEM A,MWATCT
>
MESMS9:	SETZM MESMSF		;CLEAR FLAG SO IT WONT BE REPEATED
	RET

;CHKPTY - SKIPS IF NOT RUNNING ON PSEUDO-TELETYPE

CHKPTY::PUSH P,A
	PUSH P,B
	PUSH P,C
	PUSH P,D
	SETZ D,
	GTB .PTYPA		;GET PSEUDO TTY PARMS
	HRRZ D,A		;SAVE FIRST PTY NUMBER
	PUSH P,D		;FIRST PTY ON STACK
	HLRZ A,A		;NUMBER OF PTY'S
	ADDI D,(A)		;LAST PTY NUMBER PLUS ONE
	MOVNI A,1
	MOVE B,[XWD -1,C]	;1 WORD INTO C
	MOVEI C,.JITNO		;READ TERMINAL NUMBER
	GETJI
	 CALL JERR
	POP P,A			;RESTORE FIRST PTY NUMBER
	CAML C,A		;ARE WE A PTY? (DET IS -1)
	CAML C,D
	AOS -4(P)		;NO, SKIP
	POP P,D
	POP P,C
	POP P,B
	POP P,A
	RET

;TRYGTJ
;TAKES: B: POINTER TO STRING FOR GTJFN
;RETS:	+1: NO SUCH FILE
;	+2: JFN IN A
;USED IN "MESS", AND IN "LOGIN" WITH REGARD TO PRIVATE MESSAGES.

;**;[738] Insert 4 lines at TRYGTO:+0L	KR	2-JUN-82
TRYGTS::PUSH P,B		;[738]THIS IS CALLED FROM CTRL/E-SPEAK
	PUSH P,A		;[738]
	MOVSI A,(GJ%FOU!GJ%SHT!GJ%PHY)	;[738]
	JRST TRYGT1		;[738]
TRYGTO::PUSH P,B
	PUSH P,A
	MOVSI A,(GJ%FOU!GJ%SHT)
	JRST TRYGT1

TRGTV1::PUSH P,B
	PUSH P,A
	MOVE A,[GJ%OLD!GJ%SHT+1]	;OLD FILE, SHORT CALL, VERSION 1
	JRST TRYGT1

TRYGTL:	PUSH P,B
	PUSH P,A
	MOVSI A,(GJ%OLD!GJ%SHT!GJ%ACC)	;OLD FILE, SHORT, NO ACCESS
	JRST TRYGT1

TRYGTP::PUSH P,B		;CM114
	PUSH P,A		;CM114
	MOVSI A,(GJ%OLD!GJ%SHT!GJ%PHY) ;CM114 Like TRYGTJ except set GJ%PHY
	JRST TRYGT1		;CM114

TRYGTJ::PUSH P,B
	PUSH P,A
	MOVSI A,(GJ%OLD!GJ%SHT)	;OLD FILE ONLY AND SHORT FORM
TRYGT1:	CALL GTJFS		;ASSIGN JFN USING STRING POINTER IN B
	 JRST [	POP P,A		;LOSE, ERROR RETURN
		JRST TRYG9]
	SUB P,[XWD 1,1]		;FORGET SAVED A
	AOS -1(P)		;SKIP
TRYG9:	POP P,B
	RET

;EM32 ***Begin***
;KKJOB, KJOB

.KKJOB::CONFIRM			;You sure?
	CALL BLANK1		;Clear the screen
CS,<	TYPE <Bye.
>>				;Type a little message
CC,<	TYPE <Logged off.
>>
	MOVEI A,.PRIOU		;Output designator
	DOBE			;Make sure the output finishes...
	TLO Z,LOGOFF		;Indicate logging out (tells error and ^C)
	SETO A,			;Kill self
	JRST LOGOU4		;Join main logout code

.KJOB::	TRVAR <LGOFST,LGOQUI>	;LOGOU expects these
	SETZM LGOFST		;Not fast
	SETOM LGOQUI		;but quiet
	JRST LOGOU1		;Join main logout code
;EM32 ***End***

;LOGOUT

.LOGOU::TRVAR <LGOFST,LGOQUI>	;CM244;EM32 Need another flag
	SETZM LGOFST		;CM244
	NOISE <JOB>		;CM244
	SETZM LGOQUI		;EM32 Default not quiet
	SKIPN CUSRNO		;LOGGED IN?
	JRST LOGOU1		;NO, ONLY ONE CASE
CC,<				;CM244
	MOVEI B,[FLDDB. .CMSWI,,LGOSWI,,,[ ;CM244
		 FLDDB. .CMNUM,CM%SDH,^D10,<Carriage return or job number>,,]]
	CALL FLDSKP		;CM244 Parse something
	 JRST LOGOU1		;NO NUMBER TYPED, LOG OUT THIS JOB
	LDB D,[331100,,(C)]	;CM244 Get function typed
	CAIE D,.CMNUM		;CM244 Another job number?
	JRST LOGOU3		;CM244 No, must be switch
>				;CM244
CS,<				;CM244
	DECX <carriage return or job number>
	 JRST LOGOU1		;NO NUMBER TYPED, LOG OUT THIS JOB
>				;CM244
	MOVE A,B		;PUT JOB NUMBER IN A
	JRST ..LOGO		;GO LOG OUT REMOTE JOB

CC,<				;CM244
LGOSWI:	TABLE			;CM244
T FAST,,0			;CM244
T QUIET,,1			;EM32
TEND				;CM244

LOGOU3:	MOVE B,@(B)		;EM32 Get the switch block
	SKIPN B			;EM32 See if they specified fast
	 SETOM LGOFST		;CM244 Remember to use quiet logout option
	SKIPE B			;EM32 See if they specified real quiet
	 SETOM LGOQUI		;EM32
>				;CM244

LOGOU1:	CONFIRM
CS,<				;CM290 *** Start ***
	SKIPE LGOFLG		;Called from LOGOUT.CMD?
	JRST LOGOU2		;Yes
	CALL BLANK1		;CLEAR SCREEN
	CALL DWNPNT		;INFORM DOWNTIME
	SKIPN CUSRNO
	JRST LOGOU2
	GJINF			;GET CONNECTED DIRECTORY NUMBER
	CAMN B,LIDNO		;DIFFERENT FROM LOGGED-IN ONE?
	JRST LOGOU3		;NO SO DON'T BOTHER EXPUNGING CONNECTED DIR
	LDF A,DD%DTF		;FLUSH TEMPORARY FILES
	DELDF			;EXPUNG CONNECTED DIR
	  ERJMP	[TYPE <%Warning -- EXPUNGE failed, continuing...>
		 ETYPE<%_>
		 JRST .+1]
	CALL CHKDAL		;NOW CHECK IT
LOGOU3:	MOVE B,LIDNO		;GET LOGGED-IN DIRECTORY NUMBER
	LDF A,DD%DTF		;FLUSH TEMPORARY FILES ALSO
	DELDF
	  ERJMP	[TYPE <%Warning -- EXPUNGE failed, continuing...>
		 ETYPE<%_>
		 JRST .+1]
	MOVE B,LIDNO		;CM290
	CALL CHKDL3		;CM290 Warn if over quota
	HRROI B,[ASCIZ/LOGOUT.CMD/]
	CALL TAKEIN		;Try to take file
	 JRST LOGOU2		;None there
	SETOM LGOFLG		;Say logout in progress
	RET			;And go do the commands
>				;CM290 *** End ***

LOGOU2::TLO Z,LOGOFF		;SAY LOGGING OUT (TELLS ERROR AND ^C
				;ROUTINES TO SAY "NOT LOGGED OUT AFTER ALL").
	MOVE A,COJFN
	DOBE			;WAIT TO GIVE HIM MAXIMUM CHANCE TO ^C.
				;SET MAP TO "USER"
	SETO A,			;SAY ITS SUICIDE
CC,<				;CM244
	SKIPE LGOFST		;CM244 Quiet?
	SOS A			;CM244 Then use -2
>				;CM244
	SKIPN LGOQUI		;EM32 Really quiet?
	 JRST LOGOU5		;EM32 Nope
LOGOU4:	DTACH%			;EM32 detach first
	 ERJMP .+1		;EM32 Ignore failure...
LOGOU5:	LGOUT			;EM32
	 CALL CJERR
				;DOESN'T RETURN ON SUCCESS

;"MERGE" IS WITH "GET" ABOVE.

; 'PUSH' = 'PUSH EXEC' (FORMERLY 'EXEC')
; - STARTS AN EXEC IN INFERIOR FORK SEPARATE FROM 'FORK'

.PUSH::	NOISE (COMMAND LEVEL)
	CONFIRM
   REPEAT 0,<
	CALL PNTMES		;MAKE SURE SYSTEM MESSAGES HAVE BEEN SEEN BEFORE DOING "PUSH"
   >
	MOVSI 1,(1B2+1B17)
	HRROI 2,[GETSAVE(<SYSTEM:EXEC.>)]
	CALL TRYGTJ		;GTJFN AND SAVE IT
	 ERROR <EXEC not found>
	PUSH P,1
	MOVSI 1,(1B1)		;XMIT CAPS
	CFORK
	 CALL CJERR
	MOVEM 1,EFORK
	POP P,1
	HRL 1,EFORK
	CALL DOGET		;DO THE GET
	 CALL CJERRE		;FAILED
	MOVE 1,EFORK
	SETZ 2,
	SFRKV
	 ERJMP CJERRE
	WFORK
	RFSTS
	MOVE C,A
	MOVE A,EFORK
	SETZM EFORK
	KFORK
	CAME C,[1B0+2B17]
	CAMN C,[2B17]		;VOLUNTARY TERMINATION IS NORMAL
	RET
	ERROR <PUSH terminated abnormally - Fork status = %3O, PC = %2P>

;'POP' = 'POP EXEC' - POP TO HIGHER LEVEL EXEC

.POP::	NOISE (COMMAND LEVEL)
	CONFIRM
	CALL INFER		;TEST FOR EXISTENCE OF SUPERIOR FORK
	 ERROR <No higher command level>
	JRST QUIT2		;GO DO HALTF, ETC.

;QUIT: EXIT TO SUPERIOR EXEC OR OTHER PROGRAM.
;IF TOP-LEVEL FORK, LEGAL ONLY FOR ENABLED WHEELS OR OPERS.

.QUIT::	CALL INFER		;SKIP IF INFERIOR
	 JRST [	MOVX B,WHLU+OPRU
		SKIPE PRVENF
		CALL PRVCK
		ERROR <Not legal in top-level EXEC>
		JRST .+1]
QUIT2:	MOVE A,SAVT20		;GET STATE BEFORE WE RAN
	CALL SETMOD		;RESTORE IT
	MOVE A,SAVNAM		;GET SAVED PROGRAM NAME
	SETNM			;RESTORE IT
	CALL IPCKIL		;EM34 Clean up IPCF stuff
	HALTF
	JRST REE		;IN CASE OF RETURN FROM MINI-EXEC

;INFERIORNESS TEST SUBROUTINE: SKIP IF THIS FORK HAS A SUPERIOR
;USED IN LOGOUT, QUIT, ^E EDDT.

INFER::	ATSAVE
	MOVEI 1,.FHTOP		;SAY TOP FORK
	SETZ 2,			;SAY NO HANDLES OR STATUS
	MOVEI 3,1(P)		;SAY BUILD STRUCTURE ON STACK
	HRLI 3,-4		;BUT 4 WORDS MAX
	ADD P,[4,,4]		;MAKE ROOM ON STACK
	GFRKS			;GET 'STRUCTURE' OF TOP FORK
	 CALL [	CAIE 1,GFKSX1	;RAN OUT OF SPACE?
		JRST JERR	;NO, STRANGE
		RET]		;YES, WE EXPECT THAT
	HRRZ 1,1(3)		;GET HANDLE OF TOP FORK
	SUB P,[4,,4]		;CLEAR STACK
	CAIN 1,.FHSLF		;IS IT SELF?
	RET			;YES, WE ARE TOP AND HAVE NO SUPERIOR
	RETSKP			;NO, WE ARE AN INFERIOR

;EM135 Remove conditional below
;CS59 *** Begin ***

;^EREPLACE COMMAND -- REPLACE EXEC BY GIVEN PROCESS

.EREPL::SKIPN PRVENF		;Did he "enable"?
	 ERROR <You must "Enable" first>
.REPLA::NOISE <Exec with>
	HRROI A,[GETSAVE()]	;DEFAULT TO .EXE
	MOVEI B,(GJ%OLD)	;Existing file
	CALL SPECFN
	 ERROR <No such file>
	CONFIRM
	MOVEI A,.FHSLF		;CS60
	DIR%			;CS60 Turn off the interrupt system
	MOVE A,[ACPRG,,ACST]
	BLT A,HIAC
	HRRZ JBUF		;GET JFN AGAIN
	MOVNI A,1
	HRLZI B,400000
	MOVE C,[PM%CNT+1000]
	JRST ACST

ACPRG:	PHASE 4
ACST:	PMAP			;CLEAR CORE
	HRLZI A,400000
	HRR 1,0
	HRRZI B,777
	GET			;LOAD NEW PROCESS
	HRRZI A,400000
	GEVEC			;START AT POSITION 0 OF E.V.
	CLZFF			;CLOSE ALL FILES
HIAC:	JRST (B)
DEPHASE

;CS59 *** End ***


;RECEIVE (LINKS)

.RECEI::TLZ Z,F4		;SAY RECEIVE CMD
	CALL RECREF		;CALL RECEIVE/REFUSE SUBR
	MOVE A,[1B5+1B7+.CTTRM]
	CAIN Q2,.REIPC		;EM34 Is it IPCF-messages?
	 JRST REC4		;EM34 Go set it	
	JUMPE Q1,REC2		;IF Q1 STILL 0, ASSUME SYSTEM-MESSAGES
	JUMPL Q2,REC3		;CS15;EM16 Sends
	TDO A,Q1		;GET ENABLE BITS
	TLINK
	CALL JERR
	JRST CMDIN4

RECREF:	SETZ Q1,		;ACCUMULATE LINKS/ADVICE BITS HERE
	KEYWD $LNADV
	 T LINKS,,.RELNK
	 JRST CERR
	SETZ Q2,
	CALL (P3)
	CONFIRM			;GET CONFIRMATION
	RET

$LNADV:	TABLE
	T ADVICE,,.READV
	T IPCF-MESSAGES,,.REIPC	;EM34
	T LINKS,,.RELNK
	T SENDS,,.RESND		;CS15;EM16
	T SYSTEM-MESSAGES,,[RET]
	TEND

.READV:	TLO Q1,(1B6)
	TLNE Z,F4		;RECEIVE?
	RET			;NO - RETURN
	TLO Q1,(1B4)		;LINKS TOO
	NOISE <AND LINKS>
	RET

.RELNK:	TLNE Z,F4		;WHICH KIND?
	NOISE <AND ADVICE>
	TLO Q1,(1B4)
	RET

.RESND:	SETOB Q1,Q2		;CS15
	RET			;CS15

.REIPC:	SETZ Q1,		;EM34 Return value
	TLNE Z,F4		;EM34 Receive?
	 SETO Q1,		;EM34 Indicate it
	MOVEI Q2,.REIPC		;EM34 Indicate which we did
	RET			;EM34 And return

;REFUSE (LINKS)

.REFUS::TLO Z,F4		;SAY REFUSE CMD
	CALL RECREF		;CALL RECEIVE/REFUSE SUBR
	CAIN Q2,.REIPC		;EM34 Is it IPCF-messages?
	 JRST REF4		;EM34 Go set it
	MOVEI A,.CTTRM
	JUMPE Q1,REF2		;IF NO BITS ON IN Q1, ASSUME SYSTEM-MESSAGES
	JUMPL Q2,REF3		;CS15;EM16 Sends
	HLL A,Q1		;COPY ENABLES FROM SUBR
	TLINK
	CALL JERR
	JRST CMDIN4

;REFUSE SYSTEM-MESSAGES

;EM16 Remove CS conditional
REF3:	MOVEI C,.MOREF		;Refuse
	TRNA
REC3:	MOVEI C,.MOALW		;Receive
	MOVEI B,.MOSEN
	JRST REF1
REF2:	MOVEI C,.MOSMN		;SAY REFUSE
	TRNA			;CS15
REC2:	MOVEI C,.MOSMY		;CS15
	MOVEI B,.MOSNT		;CS15
REF1:	MOVEI A,.CTTRM
;CS15	MOVEI B,.MOSNT		;FUNCTION CODE FOR CONTROLLING MESSAGES
	MTOPR			;DO IT
	 ERCAL CJERRE		;COULDN'T
	RET

;EM34 *** Begin ***
;Refuse user-IPCF messages
REF4:	SETOM RCVFLG		;No longer receiving IPCF messages
	CALL IPCKIL		;Kill off our named PID
	RET

;Receive user-IPCF messages
REC4:	SETZM RCVFLG		;Now receiving IPCF messages
	CALL IPCINI		;Make a named PID, if necessary
	RET
;EM34 *** End ***

;RENAME (EXISTING FILE) <NAME> (TO BE) <NAME>

.RENAM::SETOM TYPGRP		;TYPE ALL FILES
	NOISE <EXISTING FILE>
	CALL INFGNS		;GET INPUT FILE GROUP WITH NO SEARCH
	NOISE <TO BE>
	CALL MFOUT		;GET MULTI FILE OUTPUT TERM
	CONFIRM
	HLRZ A,JBUFP
	CAIL A,-2		;WILL NEED 2 MORE FOR PROCESSING
	ERROR <Too many JFNs in command>
	MOVE A,JBUFP
	MOVEM A,.JBUFP		;SAVE THESE JFNS
RENAM1:	CALL RLJFNS		;RELEASE ALL TEMPORARY JFNS
	CALL NXFILE		;CHECK FOR NON-EX FILE TERM
	 JRST RENAM2
	CALL TYPIF		;TYPE INPUT NAME IF GROUP
	CALL MFSET		;SET UP OUTPUT TERM
	 JRST [	CALL GNFIL	;ERROR, MESSAGE ALREADY PRINTED
		 SETZM INIFH1	;CLEAR WHEN NO MORE
		JRST RENAM2]
	CALL MFINP		;GET SECOND JFN ON INPUT JFN
	 JRST RENAM2
	HRRZ B,OUTDSG		;GET OUTPUT DESCRIPTOR
	RNAMF			;RENAME FILE
	 ERJMP [LERROR <%1?>	;TELL USER WHY IT FAILED
		JRST RENAM2]	;GO ON TO NEXT FILE
	CALL TYPOK
RENAM2:	SKIPE INIFH1		;DID LAST GNFIL HIT END?
	JRST RENAM1		;NO
	RET

;REQUEST A FILE BE RETRIEVED FROM OFFLINE STORAGE

.RETRI::STKVAR <NRETR>
	NOISE <FILES>
	MOVE A,[XWD -1,0]	;NO DEFAULT NAMES
	HRLI B,0		;DEFAULT VERSION IS 0
	HRRI B,(GJ%OLD+GJ%NS+1B15+1B16+CF%NS) ;CM236 No wildcards
	TXO Z,IGINV		;FIND INVISIBLE FILES
	CALL SPECFN
	 JRST CERR		;NO "STUFF,"
	TXZ Z,IGINV
RETRI2:	SETOM TYPGRP		;ALWAYS TYPE NAME
	MOVE A,COJFN
	MOVEM A,OUTDSG
	MOVE A,JBUFP
	MOVEM A,.JBUFP
	SETZM NRETR		;KEEP TRACK OF HOW MANY RETRIEVED
RETRI3:	CALL RLJFNS
	CALL NXFILE
	 JRST RETRI4
	CALL MFINP		;GET 2ND JFN
	 JRST RETRI4		;FAILED
	MOVE B,[1,,.FBCTL]
	MOVEI C,C		;FIND OUT IF FILE IS OFFLINE
	GTFDB
	 ERJMP RETRI4		;SKIP FILE IF CAN'T FIND OUT
	TXNN C,FB%OFF		;IS IT OFFLINE?
	JRST RETRI4		;NO, CAN'T POSSIBLEY RETRIEVE IT
	ETYPE < %1S>		;TYPE FILE NAME - SHOULD USE TYPIF
				;BUT NXFILE MAY HAVE STEPPED US OFF
				;THE END CAUSING TYPIF TO LOSE BIG
	MOVEI B,.ARRFR		;REQUEST TO RETRIEVE IT
	SETZ C,			;NO FLAGS
	ARCF
	 ERJMP [ETYPE < %?
>
		JRST RETRI4]
	CALL TYPOK
	AOS NRETR		;REMEMBER HOW MANY
RETRI4:	SKIPE INIFH1		;DONE THEM ALL?
	 JRST RETRI3		;NO, LOOP
	SKIPN NRETR		;DON'T BE TOO QUIET IF NOTHING DONE
	ETYPE <%%No files found for retrieving%_>
	RET

;*** Begin EM27 *** Redo things a bit
;SEND and ^ESEND - Send a message to a user or to all users
;In SEND, if a user name is specified, the message is sent to all of that
;user that is logged in (but not detached).

.XSEND::TRVAR <SNDLNO,DIRNO,SFRAME,IPCFLG>
	SETOM XFLG
	JRST .SENDX

.SEND::	TRVAR <SNDLNO,DIRNO,SFRAME,IPCFLG> ;EM35;EM94
	SETZM XFLG		;EM98 Not ^EXsend
.SENDX:	SETZM IPCFLG		;EM35 ^ESend never uses IPCF
	NOISE (to)
	OCTX <Octal line # or * for all>
	 CAIA			;NO NUMBER TYPED
	JRST SENDA		;NUMBER TYPED.
	STARX			;SEE IF "*" TYPD
	 CMERRX <Octal line number or * required>
	SETO B,			;NOTE "*" WITH -1
	JRST SENDA		;CM290 Go to it

.SENDO::TRVAR <SNDLNO,DIRNO,SFRAME,IPCFLG> ;EM35;EM94
	SETOM IPCFLG		;EM35 Use IPCF, if possible
	NOISE (to)
	USERX <User name or octal line number>
	 JRST SENDL		;Didn't give a user name, so try a line number
	MOVEM B,DIRNO		;Save user number
	TLZ Z,F1		;No detached or batch jobs seen yet
	MOVEM P,SFRAME		;Save beginning of args
	HLLZ D,JOBRT		;Make AOBJN pointer
SEND1:	MOVEI A,(D)		;EM101 Get job number by itself
	CAMN A,JOBNO		;EM101 Is this me?
	 JRST SEND2		;EM101 Yep, skip it.
	MOVX B,<-1,,C>		;EM101 Want one word into C
	MOVEI C,.JIBAT		;EM101 See if this is controlled by Batch
	GETJI%			;EM101
	 NOP			;EM101
	JUMPL C,[ TLO Z,F1	;EM101 If batch, set flag
		  JRST SEND2 ]	;EM101 and ignore this one
	CALL USERNO		;Get user number (from job # in left half of D)
	CAME A,DIRNO
	 JRST SEND2		;Wrong guy
	GTB .JOBTT
	 TLO Z,F1		;Flag if detached job seen
	JUMPL A,SEND2		;And skip if detached
	HLRZS A
	PUSH P,A		;Save TTY#
SEND2:	AOBJN D,SEND1		;May have more jobs
	CAMN P,SFRAME		;Found any?
	 JRST [	TLNE Z,F1
		 ERROR <User has detached or batch jobs only>
		ERROR <User is not logged in>]
	POP P,B			;Get TTY#
	CAMN P,SFRAME		;Only one possibility?
	 JRST SENDA		;Yep, use it
	PUSH P,B		;Save TTY# again
	CALL SNDQRY		;EM36 Get the line to send into the atom buffer
SEND3:	POP P,A			;Get next TTY#
	SKIPE IPCFLG		;EM40 Are we allowed to use IPCF?
	 CALL SNDIPC		;EM35 Try to send via IPCF first
	  CALL SENDIT		;EM35 Send the message via TTMSG
	CAMN P,SFRAME		;Sent to all?
	 JRST SNDDON		;Yep, all done
	JRST SEND3
	 

SENDL:	OCTX
	 CMERRX <User name or octal line number required>
SENDA:	PUSH P,B		;Save TTY number
	CALL SNDQRY		;EM36 Get line to send into atom buffer
	POP P,A			;Get TTY number back
	SKIPE IPCFLG		;EM40 Allowed to use IPCF?
	 CALL SNDIPC		;EM35 Try to send via IPCF first
	  CALL SENDIT		;EM35 Send the message via TTMSG
SNDDON:	CALL UNMAP		;Unmap buffer page
	RET			;All done

;EM40 *** Begin ***

SNDQRY:	TRVAR <<CMTXTB,10>>
	LINEX <text of message, or confirm for multiple lines>
	 CMERRX <Carriage return or text of message required>
	CONFIRM
	LDB A,[POINT 7,ATMBUF,6]
	SKIPE A			;Is the text field non-null?
	 RET			;If so, then all done - message in ATMBUF
	TYPE <Message (end with ^Z)
>
	SETZM .RDBFP+CMTXTB	;Say no backup pointer
	SETZM .RDRTY+CMTXTB	;Say no ^R pointer
SNDX1:	MOVEI A,.RDBRK		;This many words in TEXTI block
	MOVEM A,.RDCWB+CMTXTB
	MOVX A,RD%JFN		;Say we're giving jfns
	MOVEM A,.RDFLG+CMTXTB
	HRL A,CIJFN		;Input stream
	HRR A,COJFN		;Editing stream
	MOVEM A,.RDIOJ+CMTXTB
	HRROI A,ATMBUF		;Use buffer space for input
	MOVEM A,.RDDBP+CMTXTB
	MOVX A,ATMLEN*5-1	;This many characters available in bufferp
	MOVEM A,.RDDBC+CMTXTB
	MOVEI A,[EXP 1B<3*8+2>!1b<3*8+3>,0,0,0]	;Only break on ^Z, escape
	MOVEM A,.RDBRK+CMTXTB	;Set up break mask
	MOVEI A,CMTXTB		;Point to block
	TEXTI			;Input some of the comment
	 ERCAL CJERRE		;Failed, go see why
	MOVE A,.RDFLG+CMTXTB	;Get results
	TXNN A,RD%BTM		;^Z typed yet?
	 JRST SNDX1		;Not yet, read more
	MOVE A,.RDDBP+CMTXTB	;Get resulting byte ptr
SNDX2:	LDB B,A			;EM43 Get last byte
	CAIGE B,40		;EM43 Is this a control character?
	 JRST [	SETO B,		;EM43 Yes, decrement pointer
		ADJBP B,A	;EM43
		MOVE A,B	;EM43
		JRST SNDX2 ]	;EM43 Go 'till we get a non-control char
	SETZ B,			;Want a 0
	IDPB B,A		;EM43 Flush control chars at end of buffer
	TYPE <
>				;EM43a So things look nicer.
	RET			;Return with message text in ATMBUF

;EM40 *** End ***

SNDMAK:	TRVAR <SNDPT,SNDLNO>
	MOVEM B,SNDLNO		;Save TTY#
	MOVE A,CSBUFP		;Get pointer to string buffer
	MOVEM A,SNDPT
	MOVE B,EXECAP+1		;Will the monitor force the header on us?
	SKIPN XFLG		;EM94 If Xsend, never put a header on
	 TXNN B,SC%WHL!SC%OPR
	  JRST SNDX0		;Yes, don't duplicate it then
CC,<	HRROI B,[ASCIZ /
[From /]>
CS,<	HRROI B,[ASCIZ /
[/]>
	SETZ C,
	SOUT			;"[FROM ...."
	MOVE B,CUSRNO		;Get user name
	DIRST			;Put name on
	 CALL JERR		;Shouldn't fail
	PUSH P,A		;Save output designator
	GJINF			;Find out about my job
	POP P,A			;Restore ac
	JUMPL D,DETSND		;Skip on if we're detached
	HRROI B,[ASCIZ/, TTY/]	;Get some more text
	SETZ C,
	SOUT			;Store it
	MOVE B,D		;Get number in right ac
	MOVEI C,^D8		;Octal output
	NOUT			;Store terminal number
	 CALL JERR
DETSND:	HRROI B,[ASCIZ /: /]
	SKIPGE SNDLNO		;If sending to all, say so
	HRRI B,[ASCIZ / to all: /]
	SETZ C,
	SOUT			;"[From OPERATOR on line 1: ..."
SNDX0:	HRROI B,ATMBUF		;Copy message from atom buffer
	MOVEI C,0		;Stop on null
	SOUT
	MOVEM A,SNDPT		;Update pointer
	MOVEI Q1,"]"
	SKIPN XFLG		;EM94 If no header requested, no close bracket
	 IDPB Q1,SNDPT		;With close bracket
	CALL SCRLF		;And terminate with crlf
	MOVEI Q1,0		;Guarantee null
	IDPB Q1,SNDPT		;  at end
	MOVE A,CSBUFP
	CALL SNDFIX		;Format text so none lost at end of lines
	MOVE B,A		;Copy pointer to message
	RET


;TTY# is in A
SENDIT:	TRVAR <SNDTTY>		;EM36
	MOVEM A,SNDTTY		;EM36 Save TTY number
	CALL SNDMAK		;EM36 Build message, pointer returned in B
	MOVE A,SNDTTY		;EM36
	SKIPL A			;Sending to particular terminal?
	 ADDI A,.TTDES		;Yes, add in terminal designator
	TTMSG			;Do it
	  ERJMP CJERRE		;In case of losage
	MOVE A,SNDTTY		;EM36
	SKIPL A			;If sending to all, don't print 'ok' line
	 ETYPE < tty %1O - ok%_> ;EM140
	RET			;Return

;EM34 *** Begin ***

;SNDIPC attempts to send the atom buffer as an IPCF message to the tty number
;specified in A.

SNDIPC:	TRVAR <CUNO,CJNO>
	PUSH P,A		;Save tty#
	CALL GUSPID		;Try to get PID for this tty#
	 JRST SNDIF1		;Fail & return -1 in AC1
	MOVEM B,CUNO		;Save returned user #
	MOVEM C,CJNO		;And returned job #
	MOVEI B,ATMBUF		;Where the message is
	CALL USRSND		;Send a message to the PID in AC1
	 JRST SNDIF2		;If it failed, we fail...
	MOVE B,CUNO		;Get user#
	MOVE C,CJNO		;and job #
	ETYPE < %2N, job %3Q - ok%_> ;EM140 Type a little message
	MOVEM B,LTUSER		;Update last user we sent to
	MOVEM C,LTJOB		;And last job we sent to
	MOVE A,RECFLG		;Get our record flag
	ANDX A,RC%SND		;Mask the record-sends bit
	JUMPE A,SNDNRC		;If not there, then not recording sends...
	MOVEI D,ATMBUF		;Where the message is
	CALL USRMRC		;Record the message
SNDNRC:	POP P,A
	RETSKP			;Return & skip
SNDIF1:
SNDIF2:	POP P,A
	RET			;And just return
;EM34 *** End ***

;*** End EM27 ***

;SNDFIX - ROUTINE TO BREAK UP LONG ^ESEND TEXT INTO MULTIPLE LINES
;
;ACCEPTS IN A/ POINTER TO ORIGINAL TEXT
;		CALL SNDFIX
;RETURNS: +1 ALWAYS, WITH A/ POINTER TO NEW TEXT

SNDSIZ==^D71			;MAX SIZE OF ^ESEND LINES

SNDFIX:	MOVE C,[POINT 7,BUF0]	;GET POINTER TO NEW STRING

SNDFX1:	MOVSI D,-SNDSIZ		;GET MAX SIZE FOR ^ESEND LINES

SNDFX2:	ILDB B,A		;GET A CHARACTER FROM INPUT STRING
	IDPB B,C		;DEPOSIT CHARACTER IN NEW STRING
	JUMPE B,SNDFX3		;IF END OF STRING, ALL DONE
	AOBJN D,SNDFX2		;LOOP OVER A LINE-FUL OF CHARACTERS

	MOVX B,.CHCRT		;GET A CARRIAGE RETURN
	IDPB B,C		;ADD RETURN TO STRING
	MOVX B,.CHLFD		;GET A LINE FEED
	IDPB B,C		;FORM NEW LINE
	MOVX B," "		;GET A BLANK
	IDPB B,C		;INDENT SUCCESSIVE LINES
	JRST SNDFX1		;GO ADD REMAINDER OF STRING

SNDFX3:	MOVE A,[POINT 7,BUF0]	;GET POINTER TO START OF STRING
	RET			;DONE, RETURN

;SCRLF - ROUTINE TO ADD CRLF TO INITIAL STRING ASSEMBLED BY ^ESEND

SCRLF:	MOVEI Q1,CR		;INSERT CRLF SEQUENCE
	IDPB Q1,SNDPT		; INTO MESSAGE
	MOVEI Q1,LF
	IDPB Q1,SNDPT		;...
	RET

;EM37 *** Begin ***
;Reply sends an IPCF message to the last person who sent a message to us.

.REPLY::SKIPN LFUSER		;Any prev user?
	 ERROR <No previous message> ;Error...
	MOVE A,LFJOB		;Last job
	MOVX B,<-2,,C>		;Want two words at C
	MOVEI C,.JITNO		;Want TTY#, user number
	GETJI%
	IFJER.			;Failed
	  ERROR <User job logged out>
	ENDIF.
	CAME D,LFUSER		;Same user?
	 ERROR <User job logged out>
	CAMN C,[-1]		;Detached?
	 ERROR <User is detached>
	MOVE D,C		;Move the TTY# here for later
	TRVAR <<NOIMSG,13>>	;Some space for noise...
	HRROI A,NOIMSG		;Where we will build a noise msg
	HRROI B,[ASCIZ/to /]	;First part
	MOVNI C,3
	SOUT%
	MOVE B,LFUSER		;Last user we got a msg from
	DIRST%			;Translate him
	 CALL JERR		;How could that happen...?
	HRROI B,[ASCIZ/, job /]
	MOVNI C,6
	SOUT%
	MOVE B,LFJOB		;Last job we got a msg from
	MOVEI C,^D10		;in decimal
	NOUT%
	 TRN
	UNOI NOIMSG		;Parse this special noise
	CALL SNDQRY		;Get the line of text
	MOVE A,D		;TTY# we'll send to
	CALL SNDIPC		;Attempt an IPCF send
	 ERROR <Unable to send message>
	RET			;Done...
;EM37 *** End ***

;TAKE (EXEC INPUT FROM) FILESPEC

.TAKE::	TRVAR <TAKCON,JFN1,JFN2>	;CELLS TO HOLD NEW JFNS
	NOISE <COMMANDS FROM>
	SETZM JFN1		;INDICATE NO INPUT JFN YET
	MOVE A,TAKDEF		;GET THE DEFAULTS
	MOVEM A,TAKCON		;REMEMBER SETTINGS BEFORE SUBCOMMANDS CHANGE THEM
	MOVE A,COJFN
	MOVEM A,JFN2		;DEFAULT NEW JFNS TO OLD
	DEXTX <CMD>		;DEFAULT INPUT EXTENSION IS CMD
	MOVX A,GJ%OLD+GJ%ACC	;OLD FILE ONLY AND DON'T LET INFERIORS KILL IT
	MOVEM A,CJFNBK+.GJGEN	;STORE FLAGS
	MOVEI B,[FLDDB. .CMCFM,CM%SDH,,<Carriage return to end current command level>,,[
		 FLDDB. .CMCMA,CM%SDH,,<Comma to enter subcommands>,,[
		 FLDDB. .CMFIL,CM%SDH,,<Command file name>]]]
	CALL FLDSKP		;READ EITHER CR OR FILESPEC
	 CMERRX			;NEITHER TYPED!
	LDB C,[331100,,(C)]	;FIGURE OUT WHAT GOT TYPED
	CAIN C,.CMCFM		;CARRIAGE RETURN?
	 JRST PRIRES		;YES
	CAIN C,.CMCMA		;COMMA?
	 JRST TAKEC		;YES, GET SUBCOMMANDS
	MOVEM B,JFN1		;REMEMBER FIRST JFN

	NOISE <LOGGING OUTPUT ON>
	DEXTX <LOG>		;DEFAULT OUTPUT EXTENSION IS LOG
	MOVX A,GJ%FOU+GJ%MSG+GJ%ACC ;FILE FOR OUTPUT USE PLUS PRINT MESSAGE
	MOVEM A,CJFNBK+.GJGEN	;AND DON'T LET INFERIORS TOUCH THIS JFN
	MOVEI B,[FLDDB. .CMCFM,CM%SDH,,<Carriage return if no change of output desired>,,[
		 FLDDB. .CMCMA,CM%SDH,,<Comma for no change, but to enter subcommands>,,[
		 FLDDB. .CMFIL,CM%SDH,,<Output file name>]]]
	CALL FLDSKP		;READ EITHER CR OR FILESPEC
	 CMERRX			;NEITHER TYPED
	LDB C,[331100,,(C)]	;FIGURE OUT WHAT GOT TYPED
	CAIN C,.CMCFM		;CARRIAGE RETURN?
	JRST TAKE1		;YES, DON'T CHANGE OUTPUT SIDE
	CAIN C,.CMCMA		;COMMA?
	JRST TAKEC		;YES, GO GET SUBCOMMANDS
	MOVEM B,JFN2		;SAVE OUTPUT JFN
	MOVEI Q1,0		;FIRST ASSUME NO SUBCOMMANDS
	COMMAX <Comma to enter subcommands, or confirm with carriage return>
	 CAIA			;NO SUBCOMMANDS COMING
	MOVEI Q1,1		;SUBCOMMANDS COMING
	CONFIRM			;REQUIRE CONFIRMATION AFTER FILE NAME
	JUMPE Q1,TAKE1		;SKIP SUBCOMMAND STUFF IF NO COMMA
	CAIA			;WE'VE ALREADY GOT CONFIRMATION
TAKEC:	CONFIRM
	SUBCOM $TAKE		;DO THE SUBCOMMANDS
TAKE1:	SKIPN A,JFN1		;INPUT FILE TYPED?
	 RET			;NO, THIS IS A NO-OP
	MOVE B,[XWD 70000,OF%RD]
	OPENF
	 ERCAL CJERRE		;COULDN'T OPEN TAKE FILE
	MOVE A,JFN2
	MOVE B,COJFN		;GET OLD OUTPUT
	CAIN A,(B)		;OUTPUT BEING CHANGED?
	JRST TAKE33		;NO
	MOVE B,[XWD 70000,OF%APP]
	OPENF
	 ERCAL CJERRE		;GO PRINT ERROR MESSAGE
TAKE33:	HRL A,JFN1		;GET XWD INPUT,OUTPUT
	MOVE B,TAKCON		;GET DESIRED SETTING FOR NESTED TAKE
	CALLRET PUSHIO		;START NEW STREAM, REMEMBER OLD

PRIRES:	CALL CIOREL		;POP BACK ONE LEVEL
	 CAIA			;THERE WAS A LEVEL TO CLOSE
	RET			;NOTHING TO CLOSE (WE'RE AT TOP LEVEL)
	CLOSF			;CLOSE OLD INPUT SIDE
	 ERCAL JERR		;SHOULDN'T FAIL
	RET

;SUBCOMMANDS TO "TAKE" COMMAND

$TAKE:	TABLE
	T ALLOW			;IGNORE ERRORS DURING TAKE
	T DISALLOW		;STOP ON ERRORS DURING TAKE
	T ECHO			;ECHO COMMANDS IN TAKE FILE
	T LOG-FILE,,.TKLOG	;FILE TO LOG OUTPUT ON
	T NO,,.NOTAK		;NO
	TEND

.ALLOW:	CALL ALONOI
	MOVX A,TKALEF		;BIT TO ALLOW ERRORS
	IORM A,TAKCON		;TURN IT ON
	RET

.DISAL:	CALL ALONOI
	MOVX A,TKALEF		;BIT FOR ALLOWING ERRORS
	ANDCAM A,TAKCON		;TURN IT OFF
	RET

.ECHO:	CALL ECHNOI
	MOVX A,TKECOF		;FLAG TO ALLOW ECHOING
	IORM A,TAKCON		;TURN IT ON
	RET

.TKLOG:	DEXTX <LOG>		;DEFAULT OUTPUT EXTENSION IS LOG
	MOVX A,GJ%FOU+GJ%MSG+GJ%ACC ;FILE FOR OUTPUT USE PLUS PRINT MESSAGE
	MOVEM A,CJFNBK+.GJGEN	;AND DON'T LET INFERIORS TOUCH THIS JFN
	MOVEI B,[FLDDB. .CMFIL,CM%SDH,,<Output file name>]
	CALL FLDSKP		;READ FILESPEC
	 CMERRX			;THAT'S NOT WHAT IT WAS
	MOVEM B,JFN2		;SAVE OUTPUT JFN
	RET

.NECHO:	CALL ECHNOI
	MOVX A,TKECOF		;FLAG TO ALLOW ECHOING
	ANDCAM A,TAKCON		;TURN IT OFF
	RET

.NOTAK:	KEYWD $NOTAK		;GET NEXT KEYWORD
	 T ECHO,,.NECHO
	 JRST CERR
	JRST (P3)		;CALL PROPER ROUTINE

$NOTAK:	TABLE
	T ECHO,,.NECHO
	TEND

;ROUTINE TO PUSH THE EXEC PRIMARY IO STREAM
;
;ACCEPTS:	A/	INPUT JFN,,OUTPUT JFN
;		B/	FLAG BITS (SUCH AS TKALEF, TKECOF)
;
;RETURNS +1

PUSHIO::MOVE C,TAKLEN		;GET CURRENT LENGTH
	CAIL C,TAKLNX		;MAKE SURE WE'RE NOT AT MAXIMUM
	JRST NOPE		;WE ARE
	AOJ C,			;INCREASE LENGTH OF LIST
	CALL PIOFF		;NO ^C WHILE WE STRAIGHTEN THINGS OUT
	MOVEM A,TAKJFN-1(C)	;STORE JFNS
	MOVEM B,TAKBTS-1(C)	;STORE CONTROL BITS
	MOVEM C,TAKLEN		;REMEMBER NEW LENGTH
	CALL FIXIO		;SET UP DYNAMIC VARIABLES
	HRRZ A,CIJFN		;FIND OUT WHERE WE'RE READING FROM
	DVCHR
	LDB B,[221100,,B]	;GET DEVICE TYPE OF INPUT DEVICE
	MOVE A,TAKCUR		;GET CURRENT SETTINGS
	TXO A,TKTERF		;FIRST ASSUME INPUTTING FROM TERMINAL
	CAIE B,.DVTTY		;GOOD GUESS?
	TXZ A,TKTERF		;NO, LOUSY GUESS.
	MOVEM A,TAKCUR		;UPDATE SETTINGS
	MOVE B,TAKLEN		;GET POINTER TO END OF LIST AGAIN
	MOVEM A,TAKBTS-1(B)	;REMEMBER WHETHER INPUTTING FROM TERMINAL
	CALLRET PION		;ALLOW ^C AGAIN

NOPE:	MOVE C,A		;SAVE JFNS IN C
	HRRZ A,C
	MOVE B,TAKJFN-1(B)	;GET LAST JFNS ON LIST
	CAIE A,(B)		;DON'T CLOSE IF LAST JFN IS SAME
	CLOSF			;CLOSE THIS LAST SET OF JFNS, SINCE THEY'RE NOT ON THE STACK YET
	 ERJMP .+1		;FAILED, PROBABLY BECAUSE 100 OR 101
	HLRZ A,C		;GET OTHER JFN
	CLOSF
	 ERJMP .+1
	HLRZ A,C		;PCL Look at input
	CAIN A,.NULIO		;PCL Command procedure?
	ERROR <Command procedures nested too deeply> ;PCL
	ERROR <TAKE commands nested too deeply>

;"TYPE" AND "LIST" ARE IN A SEPARATE FILE BELOW.

;UNATTACH - DETACH REMOTE JOB WITHOUT REATTACHING HERE

.UNATT::TLO Z,F1		;SAY UNATTACH INSTEAD OF ATTACH
	JRST ATTAU1		;GO JOIN ATTACH

;UNDELETE <DELETED FILE NAMES>

.UNDEL::NOISE <FILES>
	MOVE A,[XWD -1,0]	;NO DEFAULT NAMES
	MOVX B,(GJ%OLD!GJ%NS!GJ%DEL!GJ%IFG!1B15!1B16!1B17) ;"MUST BE NEW" AND "IGNORE DELETED BIT"
				;  ALSO, NO SEARCHING TO BE DONE
	HRLI B,-3		;DEFAULT VERSION IS *
	TRO Z,IGINV		;SEE INVISIBLE FILES
	CALL SPECFN		;INPUT FILE NAME USING GTJFN FLAGS IN B
	 JFCL			;IGNORE SUBCOMMAND ENDING
	SETOM TYPGRP		;ALWAYS PRINT FILENAME AT TYPIF
UNDEL1:	HRRZ A,@INIFH1		;JFN
	DVCHR
	TXNN B,DV%MDD		;MULT DIR DEVICE?
	 JRST [	ETYPE <?%1H: Can't undelete files on this device
>
		MOVSI A,(77B5)
		ANDCAM A,@INIFH1 ;CLEAR * INDICATIONS TO FORCE STEPPING TO NEXT JFN
		JRST UNDEL8]
	HRRZ A,@INIFH1
	MOVE B,[XWD 1,.FBCTL]	;CONTROL BITS WORD OF FILE DESC BLOCK
	MOVEI C,C		;READ INTO C
	CALL $GTFDB		;DO GTFDB JSYS, NO SKIP IF NO ACCESS
	SETO C,			;NO ACCESS, ASSUME DELETED
	TXNN	C,FB%DEL	;"FILE IS DELETED" BIT
	JRST [	MOVE A,@INIFH1	;GET JFN WITH FLAGS
		TLNE A,<77B5>B53 ;ANY *'S?
		JRST UNDEL8	;YES, NO MESSAGE
		CALL TYPIF	;PRINT NAME
		TYPE <  Wasn't deleted
>
		JRST UNDEL8]
	CALL TYPIF		;TYPE NAME IF GROUP
	HRLI A,.FBCTL		;1: XWD DISPLACEMENT, JFN
	LDF	B,FB%DEL	;MASK OF BITS TO CHANGE
	SETZ C,			;VALUE TO CHANGE TO: OFF.
	CALL $CHFDB		;DO CHFDB AND FIELD ITRAP IF ANY
	 JRST [	TYPE <  Access not allowed
>
		JRST UNDEL8]
	CALL TYPOK		;INDICATE DONE OK
UNDEL8:	CALL GNFIL		;GET JFN OF NEXT FILE OF GROUP
	RET			;NO MORE, GO GET NEXT COMMAND.
	JRST UNDEL1		;HAVE ANOTHER

;PRIVILEGED COMMANDS

;^E EDDT
;TRANSFER CONTROL TO TOPS20 DDT, GETTING IT IF IT ISN'T ALREADY THERE.

.EDDT::	SKIPE DDTORG
	JRST EDDT4		;DDT ALREADY THERE

	SKIPN Q1,.JOBSY		;DO WE HAVE SOME SYMBOLS?
	SKIPE Q1,JOBSYM		;???
	SKIPA B,[-1,,[GETSAVE <SYS:UDDT.>]]
	HRROI B,[GETSAVE <SYS:SDDT.>] ;USE SDDT IF NO SYMBOLS
	MOVSI A,(GJ%OLD!GJ%SHT)	;OLD FILE ONLY, AND SHORT FORM
	CALL GTJFS		;GET AND STACK THE JFN
	 CALL CJERRE		;IF CAN'T, JUST GIVE ERROR TO USER
	HRLI A,.FHSLF		;SAY THIS FORK (JFN IS IN RH A)
	CALL DOGET		;DO THE GET
	 CALL CJERRE		;FAILED, SAY WHY
	CALL RLJFNS

;"GET" CHANGES ENTRY VECTOR TO POINT AT DDT.
;CHANGE IT BACK.

	MOVEI A,.FHSLF
	DMOVE B,[EXP EVLEN,EXEC] ;ENTRY VECTOR
	CALL SETENT

;IF WE CAN FIND A SYMBOL TABLE POINTER, PUT IT IN THE DDT.

	SKIPN Q1		;HAVE ONE?
	JRST	[TYPE <% No symbols
>
		 JRST EDDT4]	;NO - PROCEED
	MOVEM Q1,@DDTORG+1	;YES - STORE INTO DDT
EDDT4:	MOVX A,OURNAM		;GET OUR NAME
	SETNM			;SET IT IN CASE USER EXITS DDT AND TYPES "SAVE"
	JRST DDTORG		;ENTER DDT

;CS45 ^EMddt enters MDDT

.MDDT::	ETYPE <[Type MRETN$G to return to Exec]%_> ;CS45
	MDDT%			;CS45
	 ERJMP CJERRE		;CS45
	JRST CMDIN2		;CS45

;DISABLE
;DISABLES PRIVILEGED COMMANDS,
;DISABLES USER (RH) SPEC CAPS IN EXEC AND INFERIOR FORK
; (CAPS POSSIBLE ARE STILL TRANSMITTED, SO INFERIOR CAN USE THEM
; IF IT ENABLES THEM ITSELF)

.DISAB::SETZ A,			;FLAG DISABLE
DISAB1:	STKVAR <REMA>
	MOVEM A,REMA		;REMEMBER DESIRED SETTING
	NOISE <CAPABILITIES>
	CONFIRM
	MOVE A,REMA
	MOVEM A,PRVENF		;GET DESIRED SETTING
	MOVEI A,.FHSLF		;"ENABLE" JOINS HERE
	RPCAP
	TRZ C,-1
	SKIPE PRVENF
	HRR C,B
	MOVE D,C		;REMEMBER EXEC'S CAPS
	EPCAP			;EXEC'S CAPABILITIES
	RPCAP%			;CM224 Ask Monitor what we really have enabled
	DMOVEM B,EXECAP		;CM224 Save them for reference
	SKIPG A,FORK
	RET			;NO INFERIOR, DONE
	RPCAP
	MOVE C,D		;SET FORK TO WHATEVER WE ARE
	EPCAP			;INFERIOR'S CAPS
	RET

;ENABLE
;ENABLES OTHER PRIVILEGED COMMANDS IN EXEC, AND ENABLES
;RH (USER) SPECIAL CAPS IN EXEC AND IN INFERIOR FORK, IF THERE IS ONE.

.ENABL::SETO A,			;FLAG TO DO ENABLE
	JRST DISAB1

;^ELOGOUT (JOB #)

..LOGO::PUSH P,A
	GJINF
	CAMN 3,0(P)		;THIS JOB?
	ERROR <If you want to logout this job, use LOGOUT>
	MOVE D,0(P)		;RECOVER JOB NUMBER
	HLRE A,JOBRT		;GET NUMBER OF JOBS ON SYSTEM
	MOVM A,A		;MAKE IT POSITIVE
	CAML D,A		;VALID ARG?
	JRST ELOGO1		;NO
	JUMPL D,ELOGO1		;NEGATIVE ALSO INVALID
	GTB .JOBRT		;CHECK RUNTIME TABLE
	JUMPGE 1,.+2		;REQUESTED JOB EXISTS?
ELOGO1:	ERROR <That job does not exist>
	CONFIRM
;EM84 *** Begin ***
	MOVE A,(P)		;Get job number off of stack
	ADJSP P,6		;Make room for job info
	MOVSI B,-<.JIPNM-.JIJNO+1>;Number of words
	HRRI B,-5(P)		;First location
	MOVX C,.JIJNO		;Start with job number
	GETJI%			;Retrieve job info
	 ERROR <Job does not exist> ;Sigh...
	PRINT " "		;Start the string
	SKIPN B,-5+.JIUNO(P)	;User number 0?
	 JRST [	TYPE <Not logged in> ;Handle it specially
		JRST ELOGO2]
	ETYPE <%2R>		;Show his userid
ELOGO2:	TYPE <, >
	SKIPGE A,-5+.JITNO(P)	;Detached?
	 JRST [	TYPE <Detached>	;Say so
		JRST ELOGO3]
	ETYPE <TTY%1O>		;Type tty number
ELOGO3:	TYPE <, >
	MOVE A,-5+.JIPNM(P)	;Program name
	ADJSP P,-6		;Release stack used
	CALL SIXPRT		;Print out the program name
	CALL FCONF		;Do an extra confirmation
;EM84 *** End ***
	POP P,A
	LGOUT
	 CALL CJERR
	JRST CMDIN4

NEWF,<
.BLANK::NOISE (SCREEN)
	CONFIRM
BLANK1::STKVAR <TMOD>
	MOVE 1,COJFN		;CURRENT OUTPUT JFN
	RFMOD			;GET MODE WORD
	MOVEM B,TMOD		;SAVE IT
	TXZ B,TT%DAM		;NO XLATION
	SFMOD
	GTTYP			;GET TERMINAL TYPE
	CAIG B,BLNKMX		;ALL WE KNOW ABOUT NOW
	SKIPN A,BLNKTB(B)	;GET STRING TO DUMP
	 JRST BLANK2		;NONE - DO NOTHING
	TLNN A,-1		;STRING OR PNTR?
	 TLOA A,-1		;PNTR TO TEXT
	  HRROI A,BLNKTB(B)	;STRING - POINT TO IT INSTEAD
	PSOUT			;DUMP IT
	MOVX A,.PRIOU		;CM236
	SETZ B,			;CM236
	SFPOS%			;CM236 Tell system we homed the cursor
	 ERJMP .+1		;CM236
BLANK2:	MOVE A,COJFN
	MOVE B,TMOD		;RESTORE MODES WORD
	SFMOD
	RET

BLNKTB:	0			;(0) TTY 33
	0			;(1) TTY 35
	0			;(2) TTY 37
	0			;(3) TI / EXECUPORT
REPEAT 4,<0>			;(4-7) RESERVED FOR CUSTOMER
	0			;(8) SYSTEM DEFAULT
	0			;(9) IDEAL (NO FILL)
	[BYTE (7)35,177,177,177,177,177,177,37,0] ;(10) VT05
	BYTE (7)33,"H",33,"J",0	;(11) VT50
	0			;(12) LA30
	BYTE (7)35,37		;(13) GT40 - NO FILL REQUIRED
	0			;(14) LA36
	BYTE (7)33,"H",33,"J",0	;(15) VT52
	[BYTE (7)33,"[","H",33,"[","J",0] ;(16) VT100
	0			;(17) LA38
	0			;(18) LA120
	BYTE(7) .CHFFD		;CM264 19 Regent-20
	BYTE(7) 33,"L",0	;CM264 20 IBM 3101
	REPEAT 2,<0>		;CM256 21-22 Not displays
	BYTE(7) 33,"H",33,"K"	;CM256 23 Bantam
	[BYTE(7) 33,"H",33,"J",33 ;CM251 24 Teleray
	 BYTE(7) "G",33,"Y",41,50
	 BYTE(7) 33,"F",33,"Y",41
	 BYTE(7) 60,33,"F",33,"Y"
	 BYTE(7) 41,70,33,"F",33
	 BYTE(7) "Y",41,100,33,"F"
	 BYTE(7) 33,"Y",41,110,33
	 BYTE(7) "F",33,"Y",41,120
	 BYTE(7) 33,"F",33,"Y",41
	 BYTE(7) 130,33,"F",33,"Y"
	 BYTE(7) 41,140,33,"F",33
	 BYTE(7) "Y",41,150,33,"F"
	 BYTE(7) 15,0]
	BYTE(7) "Z"-100		;25 ADM3A
	BYTE(7) 33,110,33,112	;26 Beehive 100
	BYTE(7) "L"-100		;27 HAZELTINE 1200
	BYTE(7) 33,110,33,112	;28 HP 2645
	REPEAT 2,<0>		;29-30 Unknown
	[BYTE(7) 33,110,33,112,33 ;31 FOX
	 BYTE(7) 63,33,131,50,33
	 BYTE(7) 61,33,131,60,33
	 BYTE(7) 61,33,131,70,33
	 BYTE(7) 61,33,131,100,33
	 BYTE(7) 61,33,131,110,33
	 BYTE(7) 61,33,131,120,33
	 BYTE(7) 61,33,131,130,33
	 BYTE(7) 61,33,131,137,40
	 BYTE(7) 33,61,40,40,40
	 BYTE(7) 40,40,40,40,40
	 BYTE(7) 33,61,15,0]
	BYTE(7) 33,"U",.CHFFD,0	;CM264 32 Concept-100
	BYTE(7) 10		;CM264 33 Infoton-Vista
	BYTE(7) 33,"H",33,"J",0 ;CM264 34 Heath 19
	REPEAT 2,<0>		;VT125, VK100
	0			;CM264 37 Diablo 1620 not display
	BYTE(7) 33,"H",33,"J",0	;CM264 38 Minibee 4
	BYTE(7) 20,26,0		;CM264 39 CT82
	BYTE(7) .CHFFD,0	;CM264 40 Datamedia 1520A
	BYTE(7) .CHESC,"*",0	;CM264 41 Televideo 912C
	BYTE(7) 33,"H",33,"J",0	;CM264 42 Super Bee
	BYTE(7) .CHESC,"*",0	;CM264 43 ADM 31
	BYTE(7) 33,"H",33,"J",0 ;CM264 44 OSIC4
	BYTE(7) 176,.CHFFD,0	;CM264 45 Hazeltine 2000
	[BYTE(7) .CHESC,"[","H",.CHESC,"[","J",0] ;CM264 46 ANSI (generic)
	BYTE(7) 36,.CHESC,"y",0	;CM264 47 Dialogue-80
	BYTE(7) 33,"U",.CHFFD,0	;CM264 48 Concept-108
	BYTE(7) .CHFFD,0	;CM264 49 DG Dasher D200
	[BYTE(7) 33,"[","H",33,"[","J",0] ;CM264 50 Ann Arbor Ambassador
	BYTE(7) 33,"H",33,"J",0 ;CM264 51 Owl
	BYTE(7) 33,34,0		;CM264 52 Hazeltine 1420
	BYTE(7) 33,"H",33,"J",0	;CM264 53 Micro Bee
	BYTE(7) 33,"U",.CHFFD,0	;CM264 54 PERQ
	BYTE(7) "Z"-100,0	;CM264 55 ADM 21
	0			;CM264 56 Tektronix 4025
	BYTE(7) 33,"U",.CHFFD,0	;CM264 57 Concept-LNZ
	BYTE(7) 36,.CHESC,"y",0	;CM264 58 Dialogue-81
	BYTE(7) .CHFFD,0	;CM264 59 DG Dasher D400
	BYTE(7) 33,34,0		;CM264 60 Hazeltine 1410
	BYTE(7) .CHFFD,0	;CM264 61 ADDS Viewpoint
	BYTE(7) 33,"H",33,"J",0	;CM264 62 Zenith ZT-1
	BYTE(7) .CHFFD,0	;CM264 63 Netronics
	BYTE(7) "~",34,0	;CM264 64 Hazeltine 1500
	BYTE(7) .CHFFD		;CM264 65 Regent-40

BLNKMX==.-BLNKTB-1		;CM236
>

	END
