;<EXEC.CMU>EXECSE.MAC.11,  4-Apr-85 21:56:55, Edit by VAF
;CS146 Fascist code for new password policy.
;<EXEC.CMU>EXECSE.MAC.10, 15-Feb-85 14:50:06, Edit by VAF
;Minor changes for merge - make ^ESET FRONT-END be CS-only.
;<EXEC.CMU>EXECSE.MAC.9, 19-Dec-84 17:33:43, Edit by VAF
;CS133 Redo - don't disable console login on ^ESET NO LOGIN ANY only
;<EXEC.CMU>EXECSE.MAC.8, 25-Oct-84 09:03:27, Edit by VAF
;CS134 New monitor doesn't print "Changed" when account changed.
;<EXEC.CMU>EXECSE.MAC.7, 19-Oct-84 18:11:32, Edit by VAF
;CS133 Don't ever disallow logins on console.
;<EXEC.CMU>EXECSE.MAC.16, 27-Jun-84 10:07:40, Edit by AW0G
;CM302 take a crash dump on string space exausted
;<EXEC.CMU>EXECSE.MAC.5,  2-Jun-84 16:03:37, Edit by VAF
;CS126 SET FILE [no] SETUID
;<EXEC.CMU>EXECSE.MAC.4, 12-Apr-84 16:56:17, Edit by VAF
;CS119 SET [no] ENABLE
;<EXEC.CMU>EXECSE.MAC.14,  3-May-84 00:06:26, Edit by EC0N
; C390	Added ^ESET MICOM-DEBUGGING and ^ESET NO MICOM-DEBUGGING
;<5.1.EXEC.CMU>EXECSE.MAC.13, 16-Apr-84 20:33:16, Edit by EC0N
; C385	Added symbols SF%CSC and .SFCSC because Aaron removed them from the
;	monitor too soon.
;<EXEC.CMU>EXECSE.MAC.3,  1-Mar-84 22:52:02, Edit by VAF
; CM9 Modularize SET USE-BY - add global routine HSHUSR to hash user string.
; CS112 Add ^ESET LOGIN DECNET-TERMINALS option.
; EM136 Remove brackets around noise in .KFRKC - it breaks XLWR.
; EM134 Set [no] Casify
; EM66 Command history
; EM57 Set Prompt
; EM35 Set [no] Record-options
; EM6 Set [no] Verbose-control-T
; CM301 CHKMRA is CC-only
; CS90 Use alternate command set for NLI SET
;<5.1.EXEC>EXECSE.MAC.3, 21-Apr-83 19:19:31, Edit by PA0B
;CM12 Require confirmation of "Set dir generation ..." command
; (broken by CM12)
;CM288 SPR #18816 (15-Apr-83 "Dispatch") Fix "Set [no] 
; late-clear-typeahead" to not take effect until confirmed
;CM301 Add "Set directory no mail-routing-address", Remove
; "Set directory no archive-online-expired-files", Invoke
; Check-Routing-Address.Exe to parse mail-routing addresses.
;<5.1.EXEC>EXECSE.MAC.2,  4-Dec-82 05:49:40, Edit by PA0B
;Merge CMU v5:
; CM9   "Set directory use-by
; CM12  Warn user if s/he tries to protect a file so that the owner
;	does not have list access or a directory so that the owner
;	does not have full access
; CM156 PCL
; CM191 "Set account" defaults to user's default account,
; CM224 Default the directory to the user's logged in directory in
;	"Set directory ..."
; CM236 Disallow "Set trap no no no ..."
; CM236 Allow "^ECease +0" (does this change work???)
; CM290 SET [no] LOWER-CASE (ALL EXEC OUTPUT) at CS
; CM301 Mail-routing addresses
; CM313 ^Set front-end up/down" (for CS front end links)
; CM318 "Set [no] privileges",
; CM346 Require uptime argument to "^Cease" unless the shutdown
;	is being cancelled or the system is standalone (operator
;	may type "UNKNOWN" if the uptime is truly unknown)
; CS28  "Set account" warns users at CS of impending account expiration
; UPD ID= 36, FARK:<4-1-WORKING-SOURCES.EXEC>EXECSE.MAC.2,  29-Apr-82 13:52:43 by KROSENBLUH
;Edit 728 - Reinsert edit 643.
; UPD ID= 126, SNARK:<5.EXEC>EXECSE.MAC.5,  28-Dec-81 11:18:25 by CHALL
;TCO 5.1644 - UPDATE COPYRIGHT NOTICE
; UPD ID= 107, SNARK:<5.EXEC>EXECSE.MAC.4,   6-Nov-81 13:31:17 by CHALL
;TCO 5.1602 ALRDL7- FIX: "SET NO AL BEF" CLEARED ALL ALERTS
; UPD ID= 42, SNARK:<5.EXEC>EXECSE.MAC.12,  27-Aug-81 14:31:40 by GROUT
;TCO 5.1477 .PAXL- ADD ERJMP CJERRE AFTER SCVEC
; UPD ID= 41, SNARK:<5.EXEC>EXECSE.MAC.11,  21-Aug-81 14:31:40 by CHALL
;ADD DEFAULTS FOR THESE COMMANDS, WHICH TAKE A SINGLE KEYWORD:
;"SET DEF TAKE NO", "SET DIR NO", "^ESET TERM"
; UPD ID= 38, SNARK:<5.EXEC>EXECSE.MAC.9,  19-Aug-81 10:57:37 by CHALL
;TCO 5.1463 .NODEF: MOVE "SET NO DEFAULT" OPTIONS TABLE TO EXECCA
; UPD ID= 22, SNARK:<5.EXEC>EXECSE.MAC.8,  17-Aug-81 10:19:31 by CHALL
;TCO 5.1454 CHANGE NAME FROM XDEF TO EXECDE
;.TYPEO: MAKE "MODE" BE THE DEFAULT FOR SET TYPEOUT
;TCO 5.1443 - TJSYS: ALLOW SET TRAP JSYS TO TAKE OCTAL ARGUMENTS
; UPD ID= 3, SNARK:<5.EXEC>EXECSE.MAC.6,  14-Jul-81 12:54:32 by CHALL
;TCO 5.1411 - DMODE: NEED TO SET LENGTH IN GTDIR BLOCK
; UPD ID= 2257, SNARK:<5.EXEC>EXECSE.MAC.4,  26-Jun-81 09:12:33 by CHALL
;TCO 5.1388 - .ALERT: IF NEW ALERT IS AT SAME TIME AS AN OLD ONE, SUPERCEDE OLD
;<5.EXEC>EXECSE.MAC.3, 12-Jun-81 14:18:33, EDIT BY HELLIWELL
;MAKE .KFRKC AND .NOLM INTERNAL (::)
; UPD ID= 1729, SNARK:<5.EXEC>EXECSE.MAC.2,  18-Mar-81 16:34:40 by OSMAN
;tco 6.1007 - Fix "SET ALERT +0" to not set alert to be tomorrow.
;REMOVE MFRK CONDITIONALS
;<4.EXEC>EXECSE.MAC.1, 28-Jul-80 15:06:24, Edit by DK32
;Programmable Command Language
; UPD ID= 1439, SNARK:<5.EXEC>EXECSE.MAC.18,  15-Jan-81 10:52:03 by OSMAN
;Tco 5.1233 - Make FILE-OPENINGS and JSYS OPENF independent
; UPD ID= 1427, SNARK:<5.EXEC>EXECSE.MAC.17,   9-Jan-81 11:18:02 by OSMAN
;More 5.1225 - Make "SET TRAP NO" and "SET NO TRAP" equivalent.  Also,
;make "SET NO TRAP<cr>" get rid of all traps
; UPD ID= 1402, SNARK:<5.EXEC>EXECSE.MAC.16,   6-Jan-81 10:28:05 by OSMAN
;tco 5.1225 - Implement jsys trapping and file-opening trapping!
; UPD ID= 1386, SNARK:<5.EXEC>EXECSE.MAC.15,  29-Dec-80 09:12:09 by OSMAN
; Make SET NO ALERT take input the same as SET ALERT, so SET ALERT 300 followed
;immediately by SET NO ALERT 300 will usually work (not always since day may
;change!)
; UPD ID= 1338, SNARK:<5.EXEC>EXECSE.MAC.14,   8-Dec-80 10:07:54 by ACARLSON
;<GALAXY.DEVELOPMENT>EXECSE.MAC.2,  8-Dec-80 09:55:28, EDIT BY ACARLSON
;TCO 5.1210 - Add commands ^ESET (NO) PRIVATE-QUASAR for debugging GALAXY
; UPD ID= 1325, SNARK:<5.EXEC>EXECSE.MAC.13,   1-Dec-80 16:02:58 by OSMAN
; UPD ID= 1203, SNARK:<5.EXEC>EXECSE.MAC.12,  27-Oct-80 14:32:35 by OSMAN
;Fix SET NO ALERT
; UPD ID= 1132, SNARK:<5.EXEC>EXECSE.MAC.11,   6-Oct-80 10:44:10 by OSMAN
;tco 5.1167 - Remove "SET FILE [NO] AUTOKEEP"
; UPD ID= 1045, SNARK:<5.EXEC>EXECSE.MAC.10,  25-Sep-80 14:21:53 by OSMAN
;tco 5.1156
; UPD ID= 1027, SNARK:<5.EXEC>EXECSE.MAC.9,  22-Sep-80 10:38:01 by OSMAN
;tco 5.1150 - Add SET PROGRAM
; UPD ID= 859, SNARK:<5.EXEC>EXECSE.MAC.8,  10-Aug-80 15:20:23 by OSMAN
;tco 5.1129 - Add symbolic address and expression support
; UPD ID= 804, SNARK:<5.EXEC>EXECSE.MAC.7,  28-Jul-80 10:25:44 by OSMAN
;tco 5.1114 - Don't give error on SET NO ALERT if none to remove
;<5.EXEC>EXECSE.MAC.6, 30-May-80 16:49:20, EDIT BY MURPHY
;PUT NEW MAIL WATCH AND ALERT UNDER NEWF
; UPD ID= 539, SNARK:<5.EXEC>EXECSE.MAC.5,  20-May-80 15:46:45 by MURPHY
;CHANGE SOME XTND TO NEWF OR MFRK
; UPD ID= 520, SNARK:<5.EXEC>EXECSE.MAC.4,  14-May-80 13:20:26 by OSMAN
;Don't make past time mean tomorrow if date was typed
; UPD ID= 495, SNARK:<5.EXEC>EXECSE.MAC.3,  30-Apr-80 14:34:58 by OSMAN
;Fix confirmation on TAKE subcommands and SET DEFAULT TAKE
;<4.1.EXEC>EXECSE.MAC.6, 25-Mar-80 10:39:43, EDIT BY OSMAN
;More ONEWRD fixes on SET PAGE-ACCESS
;<4.1.EXEC>EXECSE.MAC.5, 17-Mar-80 14:07:49, EDIT BY OSMAN
;Get rid of ONEWRD checks
; UPD ID= 93, SNARK:<4.1.EXEC>EXECSE.MAC.4,   5-Dec-79 10:24:11 by OSMAN
;tco 4.2589 - Change $DEFAU to TDEFAU to not conflict with GLXLIB
;<4.1.EXEC>EXECSE.MAC.2, 20-Nov-79 14:01:16, EDIT BY OSMAN
;TCO 4.1.1023 - Fix TAKE stuff
;<4.EXEC>EXECSE.MAC.127, 12-Sep-79 15:35:33, Edit by HESS
; Fix mail-watch timers init (XTND only)
;<4.EXEC>EXECSE.MAC.126, 10-Sep-79 17:56:01, Edit by HESS
; TIMER JSYS requires valid chl even if clearing (See .AUTO2 , XTND only)
;<4.EXEC>EXECSE.MAC.125,  5-Sep-79 13:37:45, EDIT BY OSMAN
;TCO 4.2443 - Fix SET DIRECTORY PASSWORD
;<4.EXEC>EXECSE.MAC.124,  5-Sep-79 09:34:58, EDIT BY OSMAN
;tco 4.2439 - Don't run QUENCH on SET DIRECTORY PASSWORD
;<4.EXEC>EXECSE.MAC.123,  4-Sep-79 14:31:13, Edit by HESS
; Have SET NO ALERT<CR> clear all alerts (XTND only)
; Always ring bell on alert / Fix help message.
;<4.EXEC>EXECSE.MAC.121, 31-Aug-79 16:02:48, EDIT BY OSMAN
;MORE 4.2404 - Don't prompt for password unless it was not given and that's
;what's wrong.
;<4.EXEC>EXECSE.MAC.120, 30-Aug-79 17:58:10, Edit by HESS
; Add "SET NO LOGIN-MAIL" under XTND
;<HESS.E>EXECSE.MAC.23, 21-Aug-79 12:51:42, Edit by HESS
; Add extended features
;<4.EXEC>EXECSE.MAC.117, 16-Aug-79 10:14:46, EDIT BY OSMAN
;tco 4.2404 - Don't ask for password on SET DIRECTORY unless it fails without it
;<4.EXEC>EXECSE.MAC.115, 10-Aug-79 15:21:28, EDIT BY OSMAN
;tco 4.2385 - Allow escape and filespec after SET FILE INVIS FOO
;<4.EXEC>EXECSE.MAC.113,  1-Aug-79 10:22:00, EDIT BY OSMAN
;CHANGE $SETNO TO $SETN SINCE TRVAR OF SETNOF GENERATES $SETNO
;<4.EXEC>EXECSE.MAC.111,  1-Aug-79 10:12:33, EDIT BY OSMAN
;tco 4.2361 - Disallow SET NO DEFAULT TAKE
;MAKE SETNOF BE LOCAL
;<4.EXEC>EXECSE.MAC.110,  1-Aug-79 09:43:29, EDIT BY OSMAN
;tco 4.2360 - Handle illegal instruction trap on SET PAGE-ACCESS 2000
;<4.EXEC>EXECSE.MAC.109,  9-Jul-79 13:20:00, EDIT BY EKLUND
;check valid values for SET TAPE RECORD-LENGTH command
;<4.EXEC>EXECSE.MAC.108, 21-Jun-79 13:31:07, EDIT BY OSMAN
;REMOVE EXTRANEOUS CALLS TO RLJFNS
;tco 4.2304 - remove TAPE-RECYCLE commands
;<4.EXEC>EXECSE.MAC.107, 21-Jun-79 13:20:54, EDIT BY OSMAN
;put SET RETRIEVAL WAIT back in
;<4.EXEC>EXECSE.MAC.106, 19-Jun-79 13:10:15, EDIT BY OSMAN
;really do TCO 4.2268!
;<4.EXEC>EXECSE.MAC.105,  1-Jun-79 14:51:37, EDIT BY OSMAN
;tco 4.2268 - remove ^Eset retrieval-wait and ^Eset bias-control
;<4.EXEC>EXECSE.MAC.103,  2-Apr-79 13:30:56, EDIT BY OSMAN
;tco 4.2223 - CATCH "^ESET TERMINAL 4000 ..."
;<4.EXEC>EXECSE.MAC.102, 13-Mar-79 16:19:44, EDIT BY OSMAN
;remove all ^ESET STR commands.  (They are being moved to OPR)
;<4.EXEC>EXECSE.MAC.101, 12-Mar-79 18:05:17, EDIT BY KONEN
;UPDATE COPYRIGHT FOR RELEASE 4
;<4.EXEC>EXECSE.MAC.100,  8-Feb-79 15:49:08, EDIT BY OSMAN
;ADD SET [NO] DEFAULTS (FOR) PLOT
;<4.EXEC>EXECSE.MAC.99,  8-Feb-79 13:31:00, EDIT BY OSMAN
;tco 4.2184 - Fix "^ESET NO RUNTIM-GUARANTEE" which used to work.
;<4.EXEC>EXECSE.MAC.97,  7-Feb-79 21:40:21, EDIT BY KIRSCHEN
;MAKE SET DEFAULT TAKE WORK AS PER EXEC.MEM SPEC
;<4.MONITOR>EXECSE.MAC.1,  7-Feb-79 10:40:06, EDIT BY OSMAN
;ON "SET LOCATION", MERELY DON'T HAVE A DEFAULT IF NO DECNET PRESENT
;<4.EXEC>EXECSE.MAC.94,  1-Feb-79 19:02:05, EDIT BY ACARLSON
;DELETE ^ESET DEBUG FUNCTION TO APPEASE BIG WIGS (CODE FREEZE)
;<4.EXEC>EXECSE.MAC.92,  1-Feb-79 14:20:29, EDIT BY HURLEY.CALVIN
; Clean up code in SET FILE PROHIBIT so nonx file doesn't blow up
;<4.EXEC>EXECSE.MAC.91, 31-Jan-79 20:29:02, EDIT BY ACARLSON
;Add ^ESET DEBUG (FOR PRIVATE GALAXY SYSTEM) ALSO 'NO DEBUG'
;<4.EXEC>EXECSE.MAC.89, 26-Jan-79 15:26:08, EDIT BY OSMAN
;put SET FILE INVISIBLE back in (take it out of XARC)
;<4.EXEC>EXECSE.MAC.88, 25-Jan-79 15:26:00, EDIT BY OSMAN
;AT PAC7, IT SHOULD BE ERCAL, NOT ERJMP
;<4.EXEC>EXECSE.MAC.87, 23-Jan-79 15:16:19, EDIT BY OSMAN
;ALLOW SET FILE [NO] PROHIBIT
;<4.EXEC>EXECSE.MAC.86, 22-Jan-79 10:07:51, EDIT BY OSMAN
;PUT XARC AROUND ONLINE-EXPIRED-FILES
;<4.EXEC>EXECSE.MAC.84, 18-Jan-79 18:06:14, EDIT BY OSMAN
;PUT XARC AROUND SET FILE EXPIRED/ON[OFF]LINE-EXPIRATION, SET DIR ONLINE-EXPIRATION-DEFAULT
;<4.EXEC>EXECSE.MAC.83, 18-Jan-79 17:57:26, EDIT BY OSMAN
;PUT XARC AROUND SET FILE [NO] RESIST/PROHIBIT/VISIBLE/INVISIBLE
;<4.EXEC>EXECSE.MAC.78, 16-Jan-79 18:22:35, EDIT BY OSMAN
;DEFAULT NODE NAME TO HOST NAME IN SET LOCATION
;<4.EXEC>EXECSE.MAC.77, 15-Jan-79 02:43:18, EDIT BY HEMPHILL
;MAKE "SET ADDRESS-BREAK" HANDLE LARGE ADDRESSES
;<4.EXEC>EXECSE.MAC.74,  5-Dec-78 11:26:26, EDIT BY OSMAN
;PUT IN ^ESET BIAS-CONTROL (FOR SCHEDULER)
;<4.EXEC>EXECSE.MAC.73,  1-Dec-78 11:41:04, EDIT BY KIRSCHEN
;<4.EXEC>EXECSE.MAC.72,  1-Dec-78 11:20:40, EDIT BY KIRSCHEN
;<4.EXEC>EXECSE.MAC.71,  1-Dec-78 10:41:01, EDIT BY KIRSCHEN
;ADD SET [NO] DEFAULT TAKE
;<4.EXEC>EXECSE.MAC.70, 29-Nov-78 14:54:06, EDIT BY OSMAN
;FIX ^ESET STRUCTURE DISMOUNTED (CHANGE ERCAL TO CALL)
;<4.EXEC>EXECSE.MAC.69, 17-Nov-78 18:44:40, EDIT BY HURLEY.CALVIN
; Fix SET FILE VISIBLE - MOVE A,@INIFH1 becomes HRRZ A,@INIFH1
;<4.EXEC>EXECSE.MAC.67, 10-Nov-78 09:10:49, EDIT BY OSMAN
;fix alphabetical order of set no defaults paper-tape/print, and remove garbage from table
;<4.EXEC>EXECSE.MAC.66,  7-Nov-78 05:18:00, Edit by CALVIN
; SAVE VIS/INVIS PARAMETER EARLIER SINCE SOMEONE NOW SEEMS TO CLOBBER IT
;<4.EXEC>EXECSE.MAC.65,  6-Nov-78 20:04:40, Edit by CALVIN
; CAUSE SET FILE VISIBLE TO PRINT ONLY FILES ACTUALLY BEING MADE VISIBLE
;<4.EXEC>EXECSE.MAC.64, 30-Oct-78 14:30:27, EDIT BY OSMAN
;FIX SET STR IGNORED (FORGOT TO CALL GOPID BEFORE SNDMSG)
;<4.EXEC>EXECSE.MAC.61, 26-Oct-78 15:56:39, EDIT BY OSMAN
;REMOVE REFS TO SSSBLK, GSSBLK, NAMBLK.  MAKE THESE LOCAL VARIABLES
;<4.EXEC>EXECSE.MAC.60, 25-Oct-78 17:09:46, EDIT BY OSMAN
;CHANGE NETOFF TO NETFF (WAS GETTING M FROM MACRO)
;<4.EXEC>EXECSE.MAC.59, 25-Oct-78 16:16:13, EDIT BY OSMAN
;ADD SET LOCATION
;<ARC-DEC>EXECSE.MAC.7, 23-Aug-78 10:15:54, EDIT BY CALVIN
; Add ^ESet TAPE-RECYCLE-PERIOD and ^ESet ARCHIVE-TAPE-RECYCLE-PERIOD
;<CALVIN>EXECSE.MAC.9, 11-Aug-78 15:23:16, EDIT BY CALVIN
; Install ^ESET [NO] RETRIEVAL-WAITS & SET DIR [NO] ARCHIVE-ONLINE...
;<CALVIN>EXECSE.MAC.7, 11-Aug-78 12:01:27, EDIT BY CALVIN
; Install Set file [no] prohibit/resist <files>, also fixup pagination
;<CALVIN>EXECSE.MAC.4,  9-Aug-78 15:54:20, EDIT BY CALVIN
; Install SET DIRECTORY OFF/ON-EXPIRATION-DEFAULT commands
;<CALVIN>EXECSE.MAC.3,  9-Aug-78 14:05:01, EDIT BY CALVIN
; Install SET FILE OFFLINE-EXP/ONLINE-EXP/EXPIRED commands
;[BBN-TEN; Add SET FILE VISIBLE/INVISIBLE <Files>
;<3-ARC-EXEC>EXECSE.MAC.2, 14-May-78 15:59:32, Edit by MTRAVERS
; Added SET [NO] RETRIEVAL-WAIT
;<3-ARC-EXEC>EXECSE.MAC.1, 14-May-78 15:38:30, Edit by MTRAVERS
; Added SET FILE VISIBLE/INVISIBLE to command tables
;<4.EXEC>EXECSE.MAC.52,  7-Oct-78 00:43:48, EDIT BY OSMAN
;TCO 4.2037 - Smarten up SET PAGE-ACCESS
;FIX SET PAGE-ACCESS
;<4.EXEC>EXECSE.MAC.48,  1-Oct-78 19:44:32, Edit by OSMAN
;REMOVE CALL GETPID AT SIG1+n
;GET RID OF B0 SYMBOLS
;<4.EXEC>EXECSE.MAC.46, 25-Sep-78 10:46:06, EDIT BY OSMAN
;REMOVE SET OLD/NEW-QUEUE-COMMANDS
;CHANGE ONEWD TO ONEWRD, NOLOG TO NOLG
;<4.EXEC>EXECSE.MAC.44, 17-Sep-78 16:49:58, EDIT BY OSMAN
;CHANGE $SET TO $SET0 ($SET IS A MACRO IN GLXMAC)
;<4.EXEC>EXECSE.MAC.43, 16-Sep-78 00:03:20, EDIT BY OSMAN
;REMOVE REFS TO CSBUFP
;<4.EXEC>EXECSE.MAC.42, 15-Sep-78 13:32:19, EDIT BY OSMAN
;Make tape densities global ($TDENS)
;<4.EXEC>EXECSE.MAC.41, 14-Sep-78 14:13:30, EDIT BY OSMAN
;ONLY SEARCH XDEF, TTITLE DOES REST
;<4.EXEC>EXECSE.MAC.40, 21-Aug-78 16:47:12, EDIT BY HELLIWELL
;REMOVE "SET EDITOR"
;<4.EXEC>EXECSE.MAC.39, 14-Aug-78 15:15:58, Edit by HELLIWELL
;ADD EMACS TO SET EDITOR UNDER NOSHIP
;<4.EXEC>EXECSE.MAC.38, 13-Aug-78 15:22:40, Edit by HELLIWELL
;<4.EXEC>EXECSE.MAC.37, 13-Aug-78 14:57:58, Edit by HELLIWELL
;<4.EXEC>EXECSE.MAC.36, 13-Aug-78 14:47:13, Edit by HELLIWELL
;<4.EXEC>EXECSE.MAC.35, 13-Aug-78 14:39:45, Edit by HELLIWELL
;<4.EXEC>EXECSE.MAC.34, 13-Aug-78 14:34:31, Edit by HELLIWELL
;<4.EXEC>EXECSE.MAC.33, 13-Aug-78 14:28:59, Edit by HELLIWELL
;<4.EXEC>EXECSE.MAC.32, 13-Aug-78 14:22:59, Edit by HELLIWELL
;<4.EXEC>EXECSE.MAC.31, 13-Aug-78 14:19:24, Edit by HELLIWELL
;<4.EXEC>EXECSE.MAC.30, 13-Aug-78 14:07:24, Edit by HELLIWELL
;ADD "SET EDITOR"
;<4.EXEC>EXECSE.MAC.29, 21-Jul-78 10:30:42, Edit by PORCHER
;FIX SET PAGE ACCESS ... NONEXISTENT WITH EX-ONLY PROCESSES
;<4.EXEC>EXECSE.MAC.25, 17-Jul-78 11:46:01, EDIT BY OSMAN
;REMOVE REFS TO GTBUF (USE LOCAL STORAGE INSTEAD)
;<4.EXEC>EXECSE.MAC.24, 13-Jul-78 14:16:48, EDIT BY OSMAN
;MAKE PASSP LOCAL
;<4.EXEC>EXECSE.MAC.23, 11-Jul-78 17:00:39, EDIT BY OSMAN
;USE LOCAL STORAGE FOR ^ESET TERMINAL
;<4.EXEC>EXECSE.MAC.22, 29-Jun-78 15:58:50, EDIT BY OSMAN
;make dirp local
;<4.EXEC>EXECSE.MAC.21, 29-Jun-78 15:35:42, EDIT BY OSMAN
;make cdrdev, cdrstr, cdrdck be trvar'd
;<4.EXEC>EXECSE.MAC.20, 23-Jun-78 21:21:12, EDIT BY OSMAN
;REMOVE UNREFERENCED SYMS: CRDINF, NOCDCK, STRCHK
;<4.EXEC>EXECSE.MAC.15, 22-Jun-78 14:28:49, EDIT BY OSMAN
;USE TIMER FOR MAIL-WATCH (AVOIDS DOING GTAD BEFORE EVERY COMMAND)
;<4.EXEC>EXECSE.MAC.13, 15-Jun-78 14:17:18, EDIT BY OSMAN
;ADD SET NO DEFAULT COMPILE-SWITCHES
;<4.EXEC>EXECSE.MAC.12, 13-Jun-78 14:20:28, EDIT BY OSMAN
;CHANGE COMPILER-SWITCHES TO COMPILE-SWITCHES
;<4.EXEC>EXECSE.MAC.11,  9-Jun-78 18:41:11, EDIT BY OSMAN
;ADD SET DEFAULT COMPILER-SWITCHES
;<4.EXEC>EXECSE.MAC.8,  9-Jun-78 18:08:52, EDIT BY OSMAN
;CHANGE CALLS TO FIELD TO FLDSKP
;<3-EXEC-SNARK>EXECSE.MAC.72, 20-Apr-78 11:14:50, Edit by FORTMILLER
;<3-EXEC-SNARK>EXECSE.MAC.71, 20-Apr-78 11:09:53, Edit by FORTMILLER
;<FORTMILLER>EXECSE.MAC.70, 14-Apr-78 09:07:46, Edit by FORTMILLER
;<4.EXEC>EXECSE.MAC.4, 31-May-78 16:47:36, EDIT BY OSMAN
;<4.EXEC>EXECSE.MAC.3, 31-May-78 16:45:19, EDIT BY OSMAN
;ADD SET DEFAULT CPUNCH AND SET DEFAULT TPUNCH
;<4.EXEC>EXECSE.MAC.2,  2-Mar-78 09:41:44, Edit by PORCHER
;Remove time used from SET ACCOUNT
;<4.EXEC>EXECSE.MAC.1,  1-Feb-78 09:51:20, Edit by PORCHER
;Add ERJMPs for execute-only

;TOPS20 'EXECUTIVE' COMMAND LANGUAGE

;THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY ONLY BE USED
;  OR COPIED IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
;COPYRIGHT (C) 1980,1981,1982 BY DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.

	SEARCH EXECDE
	TTITLE EXECSE

;THIS FILE CONTAINS
;SET AND ^ESET COMMANDS

DEFINE SETSTG
<	TRVAR <ATIME,NOW,AHELP,<ARANGE,2>,ENTADR,WBITS,SETNOF,CDRDEV,CDRSTR,CDRDCK,DIRP,PASSP,<SEBLK,GTDLN>,SPERF,SPCNT,SPPAG,SPERR,ACDIR> ;KEEP DEV,STR,DCK IN ORDER FOR JSYS
>

;"ESET" AND "ESET NO"

ESET::	SETSTG			;ALLOCATE LOCAL STORAGE
	SETZM SETNOF		;CLEAR NO FLAG
	KEYWD $ESET
	 0
	 JRST CERR
	TXNN P3,NOLG		;NEED TO BE LOGGED IN?
	SKIPE CUSRNO		;YES, ARE WE?
	CAIA			;OK
	ERROR <LOGIN please>
	JRST (P3)		;DISPATCH TO COMMAND

;"SET" AND "SET NO"

.SET::	SETSTG			;ALLOCATE STORAGE
	SETZM SETNOF		;CLEAR NO FLAG
	SKIPE CUSRNO		;CS90 Logged in?
	IFSKP.			;CS90 Nope
	  KEYWD $SETNL		;CS90 Use NLI table
	   0
	   JRST CERR
	ELSE.			;CS90
	  KEYWD $SET0
	   0
	   JRST CERR
	ENDIF.			;CS90
	TXNN P3,NOLG		;NEED TO BE LOGGED IN?
	SKIPE CUSRNO		;YES, ARE WE?
	CAIA			;OK
	ERROR <LOGIN please>
	JRST (P3)		;DISPATCH TO COMMAND

;SET ACCOUNT

.CHANG::STKVAR <<LDBLK,GTDLN>>	;CM191
	NOISE <TO>		;OR STRING.
	MOVE A,LIDNO		;CM191 Logged-in directory
	MOVEI C,LDBLK		;CM191 Into here
	CALL GETDIR		;CM191 Read everything
	 JRST CHANG1		;CM191 Got nothing
	MOVEM A,CMDEF		;CM191 Here is the string
	ILDB A,A		;CM191 Any default?
	CAIN A,0		;CM191
CHANG1:	SETZM CMDEF		;CM191 No default at all
	CALL ACCT		;INPUT, CHECK, CONVERT ACCT INTO A (USES A B1)
	PUSH P,A		;SAVE POINTER TO ACCOUNT
	NOISE (SESSION REMARK)
	CALL GSR		;GET SESSION REMARK
	EXCH A,(P)		;GET ACCOUNT, SAVE REMARK
	CONFIRM
	CACCT			;JSYS TO CHANGE ACCOUNT #
	 CALL CJERR
	POP P,A			;GET SESSION REMARK POINTER
	CALL SSR		;SET SESSION REMARK
CS,<	ETYPE <[Changed]%_>	;CS134 Monitor won't do this any more
	CALL ACCEXP		;CS28 Warn user if account will soon expire
   >				;CS134
	JRST CMDIN4

;ACCOUNT (OF FILE) <NAME> (IS) <ACCOUNT # OR STRING>

.ACCOU::NOISE <OF FILES>
	CALL INFGNS		;* VERSION, NO SEARCH, GROUP OK
	MOVE B,INIFH1		;START HERE
	MOVEM B,OUTDSG
	CAIA
ACCOU3:	AOS B,OUTDSG
	CAMLE B,INIFH2		;ALL GONE YET?
	JRST [	MOVX A,1B1	;INDICATE STRING ACCOUNT
		JRST ACCOU4]
	HRRZ A,(B)
	CAIN A,-2		;FOUND REAL JFN YET?
	JRST ACCOU3		;NO, KEEP LOOKING
	DVCHR			;DEVICE CHARACTERISTICS
	LDB A,[POINT 9,B,17]	;DEVICE TYPE
	CAIE A,.DVDSK
	JRST ACCOU3		;LOOP TILL WE FIND ONE

;DETERMINE WHETHER SPECIFIED FILE TAKES STRING OR NUMERIC ACCOUNT

	STKVAR <<ABUF,FILWDS>>
	HRROI A,ABUF
	HRRZ B,@OUTDSG
	LDF C,1B2+1B5+JS%PAF	;GET STR:<DIR>
	JFNS			;GET STRING
	 ERCAL JERRE
	MOVSI A,(RC%EMO)	;NO RECOGNITION
	HRROI B,ABUF
	RCDIR			;CONVERT STRING BACK TO DIR # TO GET BITS
	TLNE A,(RC%NOM+RC%AMB)	;SKIP IF EXACT MATCH
	 JRST ACCOU3		;TRY TO FIND LEGAL ONE
ACCOU4:	NOISE <TO>
	CALL ACCT		;GET ACCOUNT # OR STRING, USING A.
	CONFIRM
	MOVEM A,ACDIR		;SAVE ACCT # OR STRING HERE
	SETOM TYPGRP		;TYPE FILES
	MOVE A,JBUFP		;GET POINTER TO JFN STACK
	MOVEM A,.JBUFP		;MARK HOW FAR BACK TO RELEASE JFNS
ACCOU1:	CALL RLJFNS		;RELEASE TEMPORARY JFNS
	CALL NXFILE		;CHECK FOR NON-EX FILE TERM
	 JRST ACCOU2		;GO SEE IF ANY MORE TO DO
	CALL TYPIF		;TYPE NAME, GET JFN
	CALL MFINP		;GET A TEMP JFN AND STEP TO NEXT FILE
	 JRST ACCOU2		;FAILED
	MOVE B,ACDIR		;ACCT # OR STRING PTR
	SACTF			;SET ACCOUNT OF FILE
	 JRST [	TYPE <  >
		CALL $ERSTR
		ETYPE<%_>
		JRST ACCOU2]
	CALL TYPOK
ACCOU2:	SKIPE INIFH1		;ANYTHING LEFT TO BE DONE?
	JRST ACCOU1		;YES, LOOP BACK FOR REST OF FILES
	RET

;SET ADDRESS-BREAK

.ADDRE::SKIPGE SETNOF		;"NO" TYPED?
	JRST [	CONFIRM		;YES, CONFIRM IT
		SKIPG A,FORK	;FORK HANDLE
		ERROR <No program>
		HRLI A,.ABCLR	;FUNCTION TO REMOVE BREAKS
		ADBRK		;DO IT
		 ERJMP CJERRE	;FAILED-- TYPE ERROR STRING
		SETZM ABKCNT	;ZERO REPEAT COUNT
		RET]		;AND RETURN
	PUSH P,P1		;GET A SAFE REGISTER
	SETZ P1,		;CLEAR IT (HOLDS FLAG BITS)
	NOISE <AT>
	ADDRX <Location on which to break>
	 ERROR <Invalid address>
	TDNN B,[777776,,777760]	;CAN'T SET BREAK ON ANY ACS
	ERROR <Address break won't work on the ACs>
	TLNE B,777740		;CHECK FOR TOO LARGE AN ADDRESS
	ERROR <Break address not between 0 and 37,,777777>
	PUSH P,B		;SAVE ADDRESS
	CALL SPRTR		;CHECK FOR COMMA OR CONFIRM
	 SUBCOM $ADBK		;COMMA TYPED, GET SUBCOMMANDS
	TRZN P1,1		;ANY SUBCOMMANDS TYPED?
	TXO P1,AB%RED!AB%WRT!AB%XCT ;NO, TAKE DEFAULTS
	SKIPG A,FORK		;FORK HANDLE
	ERROR <No program>
	HRLI A,.ABSET		;FUNCTION TO SET BREAK
	POP P,B			;RECOVER ADDRESS
	MOVE C,P1		;PUT FLAGS IN RIGHT AC
	POP P,P1		;RESTORE P1
	ADBRK			;SET IT
	 ERJMP CJERRE		;FAILED-- SAY WHY
	RET			;AND RETURN

$ADBK:	TABLE
	T AFTER,,.AFT
	T ALL,,.ALL
	T EXECUTE,,.EXE
	T NONE,,.NON
	T READ,,.REA
	T WRITE,,.WRI
	TEND

.AFT:	DECX <Number of times to allow reference before trapping, in decimal>
	 CMERRX
	NOISE <REFERENCES>
	MOVEM B,ABKCNT		;REMEMBER IT
	CALLRET CONF		;CONFIRM AND RETURN

.ALL:	TXO P1,AB%RED!AB%WRT!AB%XCT!1
	NOISE <TYPES OF REFERENCES>
	CALLRET CONF		;CONFIRM AND RETURN

.EXE:	TXOA P1,AB%XCT!1
.REA:	TXO P1,AB%RED!1
	NOISE <REFERENCES>
	CALLRET CONF		;CONFIRM AND RETURN

.WRI:	TXOA P1,AB%WRT!1
.NON:	TXOA P1,1
	NOISE <REFERENCES>
	CALLRET CONF		;CONFIRM AND RETURN

.SETNO::SETOM SETNOF		;FLAG NO TYPED
	SKIPE CUSRNO		;CS90 Logged in?
	IFSKP.			;CS90 Nope
	  KEYWD $SENNL		;CS90 Use NLI table
	   0			;CS90
	   JRST CERR		;CS90
	ELSE.			;CS90
	  KEYWD $SETN
	   0
	   JRST CERR
	ENDIF.			;CS90
	TXNN P3,NOLG		;NEED TO BE LOGGED IN?
	SKIPE CUSRNO		;YES, ARE WE?
	CAIA			;OK
	ERROR <LOGIN please>
	JRST (P3)		;DISPATCH TO COMMAND

;SET TRAP IS FOR CONTROLLING JSYS AND UUO TRAPPING

.TRAP::	KEYWD TRAPT
	 0			;NO DEFAULT
	 CMERRX			;INVALID KEYWORD AFTER "TRAP" TYPED
	CALLRET (P3)		;DO WHAT WAS ASKED AND RETURN

;SET NO TRAP AND SET TRAP NO TURN OFF VARIOUS TRAPPING

TRAPN:	SETOM SETNOF		;REMEMBER THAT "NO" TYPED
NTRAP::	MOVEI B,[FLDDB. .CMCFM,CM%SDH,,<Carriage return to turn off all traps>,,[
		 FLDDB. .CMKEY,,NTRAPT]] ;CM236 Don't allow "Set trap no no..."
	CALL FLDSKP		;READ WHAT'S AFTER "SET NO TRAP" OR "SET TRAP NO"
	 CMERRX
	LOAD D,CM%FNC,.CMFNP(C)	;GET WHAT WAS TYPED
	CAIN D,.CMCFM		;JUST CARRIAGE RETURN?
	JRST UNTRAP		;YES, GO UNTRAP EVERYTHING
	CALL GETKEY		;KEYWORD TYPED, GET INFO
	CALLRET (P3)

TRAPT:	TABLE
	T FILE-OPENINGS,,FOPEN	;SET TRAP FILE-OPENINGS
	T JSYS,,TJSYS		;SET TRAP JSYS X
	T NO,,TRAPN		;SET TRAP NO
	T PROCEED,,TPROC	;SET TRAP PROCEED
	TEND

NTRAPT:	TABLE			;CM236
	T FILE-OPENINGS,,FOPEN	;CM236 SET TRAP FILE-OPENINGS
	T JSYS,,TJSYS		;CM236 SET TRAP JSYS X
	T PROCEED,,TPROC	;CM236 SET TRAP PROCEED
	TEND			;CM236

;SET [NO] TRAP PROCEED CONTROLS WHETHER A JSYS OR UUO TRAPPED PROGRAM
;SHOULD PROCEED AUTOMATICALLY FROM THE TRAP.  THIS COMMAND CONTROLS THE
;CURRENT FORK ONLY.

TPROC:	NOISE (AUTOMATICALLY AFTER TRAPS)
	SKIPN SETNOF		;DIFFERENT ACTION ACCORDING TO "NO" FLAG
	SETZM TSTOPF		;SET TRAP PROCEED
	SKIPE SETNOF
	SETOM TSTOPF		;SET NO TRAP PROCEED
	CALLRET CONF		;CONFIRM AND RETURN

;SET TRAP JSYS X CAUSES AN ANNOUNCEMENT EVERY TIME JSYS X IS EXECUTED
;FOR ANY FORK

TJSYS:	NOISE (NAMED)
	MOVEI B,[FLDDB. .CMSWI,,JSWI,,,[
		 FLDDB. .CMNUM,CM%SDH,10,<Octal JSYS value>,,[
		 FLDDB. .CMFLD,CM%SDH,,<JSYS name>,,]]]
	CALL FLDSKP		;READ JSYS NAME OR SWITCH
	 CMERRX <JSYS or switch required>
	LOAD D,CM%FNC,.CMFNP(C)	;SEE WHAT WAS TYPED
	CAIN D,.CMNUM		;AN OCTAL NUMBER?
	JRST [	MOVE Q1,B	;YES - SAVE THE JSYS VALUE
		JRST JGOOD1]	;AND GO PROCESS IT
	CAIN D,.CMSWI		;A SWITCH?
	JRST [	CALL GETKEY	;YES, SEE WHICH ONE
		JRST (P3)]	;GO EXECUTE THE SWITCH
	MOVSI Q1,-JSLEN		;PREPARE TO SCAN LIST OF JSYS'S
JSCAN:	HRROI A,ATMBUF		;COMPARE ATOM BUFFER
	HRRO B,JTAB(Q1)		;WITH NAME FROM LIST
	STCMP			;COMPARE THEM
	JUMPE A,JGOOD		;GOT IT!
	AOBJN Q1,JSCAN		;KEEP LOOKING
	HRROI A,ATMBUF		;COULDN'T FIND IT
	ERROR <No such JSYS - %1m>
JGOOD:	MOVEI B,[FLDDB. .CMTOK,CM%SDH,<-1,,[ASCIZ /%/]>,<Optional "%">]
	CALL FLDSKP		;ALLOW % FOR ANY JSYS NAME
	 NOP			;NO SWEAT IF NO "%" TYPED
JGOOD1:	CONFIRM			;FINISH OFF THE TYPE-IN
	MOVEI B,JSBDEF		;USE DEFAULT BLOCK SINCE IT'S IMPOSSIBLE TO DO JUST ONE FORK CORRECTLY (SEE COMMENT ON SETTRP)
	HRRZ A,Q1		;SAY WHICH JSYS
	CAMN A,[FLD(OPENF,YFLD)];IS THIS OPENF?
	JRST [	SETCM C,SETNOF	;YES, GET CORRECT VALUE FOR TOPENF
		MOVEM C,TOPENF	;REMEMBER WHETHER WE'RE TRAPPING OPENF OR NOT
		JRST .+1]
	SKIPN SETNOF		;CLEAR OR SET BIT ACCORDING TO YES OR NO
	CALL SETBIT		;SET APPROPRIATE BIT
	SKIPE SETNOF
	CALL CLRBIT
	CALLRET MRKTRP		;SET UP NEW TRAP STATUS

;JTAB IS A TABLE OF JSYSES WITH EACH ENTRY OF THE FORM
;
;	[ASCIZ /NAME/]

DEFINE DEFJS (NAME,VALUE,TRASH,TRASH,TRASH)
<	RELOC JTAB+VALUE	;;ALLOW FOR GAPS IF SOME JSYSES UNDEFINED
	[ASCIZ /NAME/]
	IFG VALUE-LARGST,<LARGST==VALUE>
>

	LARGST==0
JTAB::	JSLIST			;USE JSYS LISTER FROM MONSYM (CALLS DEFJS)
	JSLEN==.-JTAB		;LENGTH OF TABLE
	RELOC JTAB+LARGST+1	;ALLOW FOR JSYSES NOT BEING IN ORDER IN JSLIST

;JSWI IS TABLE OF SWITCHES FOR SET TRAP JSYS

JSWI:	TABLE
	T ALL,,JALL		;SET TRAP JSYS /ALL
	TEND

;UNTRAP UNTRAPS EVERYTHING

UNTRAP:	SETZM TFILEF		;SAY WE'RE NOT TRAPPING FILE-OPENINGS
	CALLRET JALL3		;GO UNTRAP ALL JSYS'S TOO

;JALL CONFIRMS AND EXECUTES "SET NO TRAP JSYS /ALL"

JALL:	CONFIRM			;NOTE THAT SWITCH INTEAD OF KEYWORD ALLOWS A JSYS TO BE CALLED "ALL"
JALL3:	MOVEI A,JSBDEF		;SAY WHERE BLOCK IS
	SKIPE SETNOF		;CLEAR OR SET ALL BITS ACCORDING TO "NO"
	JRST JALNO		;GO HANDLE SET NO TRAP JSYS /ALL
	CALL SETALL
	SETOM TOPENF		;SAY OPENF SHOULD BE TRAPPED
	JRST JALL2

JALNO:	CALL CLRALL
	SETZM TOPENF		;SAY OPENF IS NOT BEING TRAPPED AS A JSYS
JALL2:	MOVE A,FORK		;SAY WHICH FORK
	CALLRET MRKTRP		;SET UP NEW TRAP STATUS

;SET TRAP FILE-OPENINGS causes all forks' file-openings to be announced

FOPEN:	CONFIRM			;MAKE SURE HE MEANS IT
	SETCM A,SETNOF		;SET OR CLEAR TFILEF ACCORDING TO SETNOF
	MOVEM A,TFILEF
;	CALLRET MRKTRP		;GO UPDATE TRAP STATUS

;MRKTRP MARKS THAT TRAP STATUS HAS CHANGED AND HENCE HAS TO BE UPDATED.
;IT IS NOT UPDATED IMMEDIATELY, BECAUSE DOING SO CAN PREVENT EXECUTE-ONLY
;PROGRAMS FROM BEING LOADED WITH GET JSYS, SINCE SETTING TRAPS MAKES
;THE PROCESS NON-VIRGIN

MRKTRP::SETZM TRPOKF		;SAY TRAPS ARE NOT OK
	LOAD A,YFLD,[OPENF]	;GET BIT POSITION OF OPENF JSYS
	MOVEI B,JSBDEF		;POINT AT TRAP BITS
	CALL CLRBIT		;FIRST CLEAR THE BIT
	LOAD A,YFLD,[OPENF]	;GET BIT POSITION OF OPENF JSYS
	MOVEI B,JSBDEF		;POINT AT TRAP BITS
	SKIPN TOPENF		;TURN OPENF BIT ON IF TRAPPING OPENF JSYS
	SKIPE TFILEF		;OR IF TRAPPING FILE-OPENINGS
	JRST SETBIT
	RET

.CIDLY::NOISE <FOR COMMANDS>
	CALL CONF		;CM288 Confirm the command before setting flag
	SETCM A,SETNOF
	MOVEM A,CIDLYF
	RET			;CM288 Return without confirming

;SET LOCATION

.LOCAT::NOISE (TO)
	STKVAR <<NODFDB,.CMDEF+1>>
	MOVX A,FLD(.CMNOD,CM%FNC)!CM%PO!CM%DPP
	MOVEM A,.CMFNP+NODFDB	;NODE FUNCTION, PARSE ONLY, DEFAULT PRESENT
	CALL GETNOD		;GET POINTER TO OUR NODE NAME
	 JRST [	MOVX A,CM%DPP	;FAILED, PROBABLY NO DECNET ON THIS SYSTEM
		ANDCAM A,.CMFNP+NODFDB	;SAY NO DEFAULT PRESENT
		JRST .+1]
	MOVEM A,.CMDEF+NODFDB	;STORE POINTER TO DEFAULT
	MOVEI B,NODFDB
	CALL FLDSKP		;READ NODE NAME, DEFAULT TO SYSTEM'S
	 CMERRX			;FAILED, TELL USER WHY
	CALL BUFFF		;REMEMBER NODE NAME TYPED BY USER
	CONFIRM			;WAIT FOR COMMAND CONFIRMATION
	MOVE C,A		;POINTER TO NODE NAME POINTER IN C
	HRROI A,-1		;OURSELF
	MOVEI B,.SJLLO		;SET LOGICAL LOCATION
	SETJB			;DO IT
	 ERCAL CJERRE		;FAILED, TELL USER WHY
	RET			;DONE

NONEWF,<
.MWATC::SETCM C,SETNOF		;TURN ON OR OFF WATCHING OF MAIL FILE
	EXCH C,MWATCF		;FLAG FOR WATCHING IS 0 (DEFAULT) FOR NO
	CAMN C,MWATCF		;ANY CHANGE?
	RET			;NO
	JUMPE C,MINT0		;IF WAS OFF, GO SET INTERRUPT AND RETURN
	MOVE A,[.FHSLF,,.TIMDD]	;REMOVE TIMER INTERRUPT
	MOVE B,MALWEN		;GET TIME AT WHICH INTERRUPT WAS TO OCCUR
	MOVEI C,MALCHN		;6/23/78 TIMER REQUIRES CHANNEL BUT DOESN'T USE IT!!!
	TIMER			;TURN OFF THE TIMER
	 ERJMP .+1		;WILL FAIL IF TIMER ALREADY TIMED OUT

;NOTE:  THIS COULD CAUSE PROBLEMS IF THE EXEC IS USING TIMER TO TIME
;SOMETHING ELSE, WHICH ALSO WANTS AN INTERRUPT AT THE SAME TIME.  THIS
;TIMER HERE IN THE MAIL CODE WOULD ERRONEOUSLY TURN OFF THE OTHER
;TIMER.  WHAT IS NEEDED IS FOR THE TIMER JSYS TO ALLOW US TO SPECIFY
;EXACTLY WHICH TIMER TO TURN OFF.  THIS WOULD PREVENT THIS PROBLEM.
;
;NOTE ALSO THAT IT IS INDEED NECESSARY TO TURN OFF THE TIMER HERE.
;IF WE DIDN'T, THEN A USER TURNING MAIL OFF, ON, OFF, ON, OFF, ON ETC.
;WOULD PILE UP TIMERS WHICH WOULD GIVE MORE INTERRUPTS THAN THEY'RE
;SUPPOSED TO, OR WOULD HIT QUOTA CAUSING AN ERROR.

	RET
>
NEWF,<		;MORE COMPREHENSIVE MAIL-WATCH AND ALERT FACILITY

.MWATC::NOISE <FOR USER>
	CALL USRNAM		;INPUT USER NAME
	 ERROR <No such user>
	STKVAR <USRNUM>
	MOVEM C,USRNUM		;SAVE USER NUMBER
	SKIPE SETNOF		;SET NO?
	 JRST .MWAT0		;TURN WATCH OFF
	NOISE <MESSAGE COUNT>
	DEFX <10000>		;DEFAULT TO LOTS
	DECX <Number of times to tell of old "new" mail>
	 HRLOI B,377777		;+INF IF NONE TYPED
	MOVE Q1,B		;SAVE COUNT
.MWAT0:	CONFIRM
	MOVE A,USRNUM		;USER NUMBER
	MOVEI C,NMWAT-1		;INIT COUNT
	SETO D,
.MWAT1:	SKIPN B,MWATDR(C)	;LOOK FOR EMPTY SLOT
	 SKIPA D,C		;SAVE INDEX
	  CAME A,B		;MATCH USER?
	   JRST .MWAT2		;FOUND EMPTY SLOT
	SKIPN SETNOF		;FOUND USER - SET NO?
	 JRST .MWAT3		;MATCH FOUND USE IT INSTEAD
	SETZM MWATDR(C)		;TURN OFF MAIL WATCH ON THIS ONE
	RET			;DONE

.MWAT2:	SOJGE C,.MWAT1		;LOOP OVER ALL SLOTS
	SKIPE SETNOF		;SET NO?
	 RET			;YES - ALREADY TURNED OFF
	SKIPGE C,D		;HAVE EMPTY SLOT?
	 ERROR <Maximum number of watches used up.>
	MOVEM A,MWATDR(C)	;SET TO WATCH THIS USER
.MWAT3:	SETOM MWATCF		;TURN ON WATCHING
;	SETZM MWATAT		;RESET TIMERS
;	SETZM MWATCT
	MOVEM Q1,MWATN(C)	;STASH REPEAT COUNTS
	MOVEM Q1,MWATN0(C)
	RET			;EXIT

;STILL IN NEWF

;SET ALERT (AT)

.ALERT::GTAD			;GET VALUE OF NOW FOR DATE DEFAULT IF NOT GIVEN
	MOVEM A,NOW
	SKIPE SETNOF		;SET NO?
	 JRST ALRDEL		;YES - GO DELETE AN ALERT
	NOISE <AT TIME>
	MOVEI A,[ASCIZ /Date and time, or time/]
	CALL REDALT		;READ THE ALERT TIME
	 CMERRX			;COULDN'T
	NOISE <MESSAGE>
	LINEX <Message, must be .LE. 80 characters>
	 CMERRX
	MOVE A,CMABP		;SAVE STRING IN PERMANENT FREE SPACE
	ILDB C,A		;SEE IF STRING GIVEN
	JUMPE C,.ALRT1		;IF NOT DON'T READ IT
	MOVE A,CMABP		;GET POINTER AGAIN
	CALL XBUFFS
	MOVE C,A		;GET STRING POINTER IN C
.ALRT1:	CONFIRM
	MOVE B,ATIME		;RESTORE TIME
	SKIPG ALRTIM		;ALERTS ON?
	 JRST [	MOVEM B,ALRTIM	;NO - SET UP TIMER
		MOVEM C,REASON	;SAVE THE FIRST ALERT
		RET]		;EXIT - CHECK ON COMMAND RETURN

	MOVSI D,-NALTS		;ALERTS ON - SEE IF THERE IS A DUPLICATE
.ALRT2:	CAMN B,ALRTIM(D)	;GOT AN ALERT AT THIS TIME?
	JRST [	EXCH C,REASON(D) ;YES - SWAP THE NEW MESSAGE FOR THE OLD
		SKIPE A,C	 ;WAS THERE AN OLD MESSAGE?
		 CALLRET STREM	 ;YES - REMOVE IT FROM THE FREE POOL; DONE
		RET]		 ;NO - DONE
	AOBJN D,.ALRT2		;LOOP LOOKING FOR DUPLICATES

	MOVSI D,-NALTS		;NOW SEARCH TABLE FOR AN EMPTY SLOT
	SKIPE ALRTMS(D)		;FIND EMPTY SLOT
	AOBJN D,.-1
	JUMPGE D,[ERROR <Alert table full>]
	CAMG B,ALRTIM		;IS NEW ONE EARLIER THAN CURRENT PENDING?
	 JRST [	EXCH B,ALRTIM	;YES - EXCHANGE TIMES
		EXCH C,REASON	; AND MESSAGE
		JRST .+1]	;AND GO RE-SAVE THE OLD PENDING MESSAGE
	MOVEM B,ALRTMS(D)	;FILL IN SLOT (ORDER LATER)
	MOVEM C,REASON+1(D)
	RET			;DONE

;REDALT READS IN THE INTERNAL TIME-AND-DATE OF AN ALERT.
;
;ACCEPTS:	A/	ADDRESS OF HELP STRING
;
;RETURNS+1:	USER TYPED SOMETHING ELSE
;	+2:	ATIME/	INTERNAL DATE AND TIME

REDALT:	MOVEM A,AHELP		;REMEMBER ADDRESS OF HELP STRING
	UDTR @AHELP
	 RET			;COULDN'T
	TXNE A,DATBIT		;WAS A DATE TYPED?
	JRST AL1		;YES, SO NEVER TRY TO CHANGE THE DAY
	CAMGE B,NOW		;DID HE SPECIFY A TIME BEFORE NOW?
	 ADD B,[1B17]		;YES - ASSUME TOMORROW
AL1:	MOVEM B,ATIME		;SAVE TIME
	RETSKP

;HERE TO REMOVE ONE OR MORE ALERTS

ALRDEL:	MOVEI A,[ASCIZ /Date and time or BEFORE or AFTER time
    at which to remove alert/]
	CALL REDALT		;READ THE TIME
	 JRST ALRDL5		;COULDN'T (MAYBE BEFORE, AFTER, CRLF)
	CONFIRM
	MOVSI D,-<NALTS+1>	;SCAN FULL TABLE AND PENDING
ALRDL2:	MOVE A,ATIME		;DATE/TIME REQUESTED
	SUB A,ALRTIM(D)		;GET DIFFERENCE FROM ENTRY
	MOVM A,A		;ABSOLUTE VALUE
	CAIL A,^D182		;WITHIN ONE MINUTE?
	 JRST ALRDL3		;NO - STEP TO NEXT
	TLO Z,F1		;SAY WE FOUND ONE
	SETZM ALRTIM(D)		;CLEAR ENTRY
	SKIPE A,REASON(D)	;REMOVE MESSAGE
	 CALL STREM		;FROM FREE POOL
	SETZM REASON(D)		;CLEAR POINTER
ALRDL3:	AOBJN D,ALRDL2		;LOOP
	TLNN Z,F1		;FOUND ANY?
	 ERROR <No alerts found>
ALRDL4:	SKIPE ALRTIM		;CLEARED CURRENT PENDING ALERT?
	 RET			;NO - DONE
	SETZ B,			;YES - SET UP FOR TABLE RE-ORDER
	HRLOI Q1,377777
	JRST ALRCH1		;AND GO FIND A NEW ONE

;STILL IN NEWF
;COME HERE TO PARSE "BEFORE" & "AFTER"

ALRDL5:	SETZB C,Q1		;INIT RANGE VARIABLES
	HRLOI B,377777
	DMOVEM B,ARANGE		;SAVE
	KEYWD $ALERT
	 0			;NO DEFAULT
	 JRST [	CONFIRM		;HANDLE "SET NO ALERT<CR>"
		JRST ALRD5A]
	CALL 0(P3)		;INVOKE SUBR
ALRD5A:	DMOVE B,ARANGE		;GET RANGE TO CHECK
	MOVSI D,-<NALTS+1>	;CHECK ALL
ALRDL6:	CAMG C,ALRTIM(D)
	 CAMGE B,ALRTIM(D)	;THIS ONE?
	  JRST ALRDL7		;NOT IN RANGE
	SETZM ALRTIM(D)		;IN RANGE - DELETE
	SKIPE A,REASON(D)	;REMOVE MESSAGE IF ANY
	 CALL STREM
	SETZM REASON(D)
ALRDL7:	AOBJN D,ALRDL6		;LOOP
	JRST ALRDL4		;RE-ORDER THE TABLE AND FINISH OFF

$ALERT:	TABLE
	T AFTER,,ALRAFT
	T BEFORE,,ALRBEF
	TEND

ALRAFT:	TLOA Z,F2		;FLAG AFTER
ALRBEF:	TLZ Z,F2		;FLAG BEFORE
	NOISE <TIME>
	DTRX <Date and time>
	 CMERRX
	MOVE A,B		;SAVE USER INPUT IN A
	MOVE B,ARANGE		;PREVIOUS TOP RANGE
	TLNE Z,F2		;RE-ORDER DEPENDING ON BEFORE/AFTER
	 SKIPA C,A
	  MOVE B,A		;USER INPUT AT TOP OR BOTTOM
	DMOVEM B,ARANGE		;SAVE ARGS
	CALLRET CONF		;CONFIRM AND RETURN

;STILL IN NEWF

;CHECK FOR ALERT AND RE-ORDER

ALRCHK::SKIPG B,ALRTIM		;ANY ALERTS PENDING?
	 RET			;NOPE - EXIT
	GTAD			;GET TIME NOW
	CAMGE A,B		;IS IT TIME FOR ALERT
	 RET			;NOPE - EXIT
	SUBI A,^D728		;4 MINUTES
	CAMG A,B		;LATER THAN 4 MINS?
	 TDZA Q1,Q1		;NO - OK
	HRROI Q1,[ASCIZ "%2D "]	;YES - SPECIAL MESSAGE
	MOVE A,COJFN
	DOBE			;WAIT FOR TYPEOUT TO STOP
	TYPE <>		;THEN RING THE CHIMES
	ETYPE <[%5\%%2E% alert>	;START THE MESSAGE
	SKIPE Q1		;IS THE ALERT COMING OUT LATE?
	 ETYPE < at %D %E>	;YES - APOLOGIZE
	SKIPE B,REASON		;GIVE MESSAGE SAVED
	 TYPE < - >
	ETYPE <%2\]%_>
	GTAD			;GET TIME NOW
	MOVE B,A		; INTO B
	HRLOI Q1,377777		; FOR RE-ORDER
ALRCH1:	MOVSI D,-NALTS
	SETO C,			;INIT FLAG
ALRCH2:	SKIPN A,ALRTMS(D)	;GOT AN ENTRY?
	 JRST ALRCH3		;NO - SKIP IT
	CAMG A,Q1		;YES - WITHIN RANGE
	 CAMG A,B
	  JRST [SETZM ALRTMS(D)	;OUT OF RANGE - REMOVE IT
		SKIPE A,REASON+1(D)
		 CALL STREM
		SETZM REASON+1(D)
		JRST ALRCH3]
	SKIPL C			;FOUND ONE YET?
	 CAMGE A,ALRTMS(C)	;YES - BETTER ONE NOW?
	  MOVEI C,(D)		;YES - REMEMBER THIS ENTRY
ALRCH3:	AOBJN D,ALRCH2		;LOOP
	MOVE A,ALRTMS(C)	;SET NEW ENTRY (OR CLEAR ALRTIM)
	MOVEM A,ALRTIM
	SETZM ALRTMS(C)		;...
	SKIPE A,REASON		;CLEAR OLD MESSAGE
	 CALL STREM
	SETZM REASON		;IN CASE IT WAS THE ONLY ONE
	MOVE A,REASON+1(C)	;MOVE MESSAGE ALSO
	MOVEM A,REASON
	RET			;DONE

;STILL IN NEWF

;SET AUTOMATIC MAIL-WATCH AND ALERTS

.AUTOM::NOISE <MAIL AND ALERT CHECKS>
	CONFIRM
	SKIPE SETNOF		;MAYBE SET NO
	 JRST .AUTO2		;YES
	SETZM MWATAT		;CLEAR AUTO TIME
	SKIPE IITSET		;TIMERS ON?
	 RET			;YES - EXIT
	MOVE A,[.FHSLF,,.TIMEL]	;NO - SET UP TIMER INTERRUPT
	MOVEI B,^D60000		;AT 1 MINUTE INTERVALS
	MOVEI C,IITCHN		;GET CHANNEL
	TIMER
	 JRST CJERR		;JSYS LOSAGE
	SETOM IITSET		;INTERRUPT ARMED
	RET			;EXIT

.AUTO2:	GTAD			;FLUSH TIMER IF
	ADDI A,^D182		; WITHIN ONE MINUTE
	MOVE B,A
	MOVE A,[.FHSLF,,.TIMBF]	;ALL TIMES BEFORE NOW + 1 MIN
	MOVEI C,IITCHN		;*** MONITOR CROCK REQUIRES CHL
	TIMER
	 JFCL
	SETZM IITSET		;NO MORE INTERRUPTS
	RET
>	;END NEWF

;SET (NO) UUO-SIMULATION

.PAXL::	NOISE <FOR PROGRAM>
	CONFIRM
	SKIPN SETNOF
	TDZA A,A
	SETO A,
	MOVEM A,PAXLFL		;PA1050 FLAG
	SKIPG A,FORK		;HANDLE OF CURRENT INFERIOR
	RET			;NONE, LEAVE NOW
	GCVEC			;GET CURRENT VECTOR
	CAMN B,[-1]		;DISABLED?
	JRST [	SKIPE PAXLFL	;YES, IS THAT WHAT WE WANT?
		RET		;YES
		SETZ B,		;NO, ENABLE
		JRST PAXL1]
	SKIPN PAXLFL		;ENABLED, IS THAT WHAT WE WANT?
	RET			;YES
	SETO B,			;NO, DISABLE IT
PAXL1:	SETZ C,
	SCVEC			;SET COMPATIBILITY ENTRY
	 ERJMP CJERRE		;FAILED - SAY WHY
	RET

XTND,<
.KFRKC::NOISE <ON CTRL-C>	;EM136 Remove brackets
	SKIPE SETNOF		;SET NO?
	TDZA A,A		;YES - CLEAR
	SETO A,			;SET
	MOVEM A,CCKEEP		;CTRL-C KEEP FLAG
	CALLRET CONF		;CONFIRM AND RETURN

;SET NO LOGIN-MAIL
;DON'T DO ANY OF THE NORMAL MAIL PROCESSING ON LOGIN

.NOLM::	SETZM SYSMF		;THIS SHOULD BE SUFFICIENT
	SETZM MESMSF
	RET
>

;SET PAGE-ACCESS (OF PAGES) P1,P2:P3... (ACCESS) ACCESS-TYPES

.PAC::	SETZM SPCNT		;NO ERRORS YET
	SKIPGE FORK		;MAKE SURE THERE'S A PROCESS
	ERROR <No program>
	NOISE (OF PAGES)
	CALL OCTLST		;GET LIST OF OCTAL PAGE RANGES
	NOISE (ACCESS)
	SETZB Q1,Q2		;Q1 ARE "YESES" AND Q2 ARE "NOS"
	MOVEI Q3,0		;Q3 NON-0 IF "NO" JUST TYPED
PAC2:	MOVEI B,[FLDDB. .CMCFM,,,,,[
		 FLDDB. .CMKEY,,$ACCES,<Access type,>,,]]
	TRNE Q3,1		;WAS "NO" JUST TYPED?
	MOVE B,(B)		;YES, SO EOL ILLEGAL NOW
	CALL FLDSKP		;GET EOL OR ACCESS-TYPE
	 CMERRX			;NO
	LDB C,[331100,,(C)]	;FIND OUT WHAT TYPED
	CAIN C,.CMCFM		;END OF LINE?
	 JRST PAC3		;YES, GO EXECUTE COMMAND
	CALL GETKEY		;KEYWORD TYPED, GET DATA
	MOVE P3,(P3)		;GET CONTROL BITS
	CAIN P3,0		;IS KEYWORD "NO"?
	AOJA Q3,PAC2		;YES, REMEMBER AND GET NEXT KEYWORD
	TRNN Q3,1		;NO, DID "NO" PRECEDE THIS KEYWORD?
	IOR Q1,P3		;NO, ACCUMULATE TO "YES" LIST
	TRNE Q3,1
	IOR Q2,P3		;YES, ACCUMULATE TO "NO" LIST
	TRNN Q3,1
	TDZ Q2,P3		;IF "YES", CANCEL PREVIOUS "NO"
	TRNE Q3,1
	TDZ Q1,P3		;IF "NO", CANCEL PREVIOUS "YES"
	TRZ Q3,1		;CLEAR "NO"
	JRST PAC2		;GO GET MORE INPUT
PAC3:	SOSGE C,RLIST		;PREPARE TO GET NEXT SET OF PAGES FROM LIST
	JRST PAC4		;NO MORE PAGES
	MOVE D,RLIST(C)		;GET BEGINNING OF RANGE
	CAMLE D,RLIST+1(C)	;MAKE SURE RANGE GOES FROM SMALL TO LARGE
	JRST BADRAN		;NO
	HLR D,RLIST+1(C)	;MAKE SURE BOTH ENDS OF RANGE FIT IN 18 BITS
	JUMPN D,BADPAG		;JUMP IF THEY DON'T
	HRR A,RLIST(C)		;GET FIRST PAGE NUMBER OF RANGE TO SET
	HRRZM A,SPPAG		;REMEMBER PAGE
PAC5:	CAMN Q2,[-1]		;"NO NONEXISTENT"?
	JRST PAC6		;YES, DO NOTHING
	HRL A,FORK		;USE CURRENT FORK
	CAMN Q1,[-1]		;"NONEXISTENT"?
	JRST PAC7		;YES, GO REMOVE PAGE
	RPACS			;GET OLD PAGE ACCESS
	 ERJMP [CALL NOSPAC	;PRINT ERROR, RPACS FAILED.
		JRST PAC6]	;GO ON TO NEXT PAGE
	IOR B,Q1		;TURN ON ACCESS DESIRED
	TDZ B,Q2		;TURN OFF ACCESS NOT WANTED
	SPACS			;DO IT
	 ERCAL NOSPAC		;COULDN'T, TYPE ERROR MESSAGE
PAC6:	HRRZ D,SPPAG		;ISOLATE PAGE NUMBER JUST DONE
	AOS A,SPPAG		;STEP TO NEXT PAGE
	MOVE C,RLIST		;C GETS CLOBBERED BY NOSPAC
	CAMGE D,RLIST+1(C)	;HAVE WE DONE ENTIRE RANGE YET?
	JRST PAC5		;NOT YET
PAC8:	SOS RLIST		;YES, GO TO NEXT SET
	JRST PAC3
PAC4:	CALL SPREP		;PERHAPS LAST ERROR CHUNK TO REPORT
	CALLRET UNMAP		;ALL DONE, UNMAP PAGES AND RETURN

;HERE FOR THE CASE OF "SET PAGE N NONEXISTENT"

PAC7:	MOVE B,A		;PUT PAGE IDENTIFIER IN B
	HRROI A,-1		;SAY GET RID OF PAGE
	MOVEI C,0		;SAY NO REPEAT COUNT
	PMAP			;GET RID OF PAGE
	 ERCAL NOSPAC		;FAILED, GO PRINT ERROR
	JRST PAC6

;PAGE NUMBERS OUT OF RANGE 0-777777

BADPAG:	ETYPE <%%Page number negative or larger than 777777 - being skipped
>
	JRST PAC8		;SKIP THIS SET

;BEGINNING OF RANGE NOT LESS THAN OR EQUAL TO END

BADRAN:	ETYPE <%%Beginning of range larger than end - Range being skipped
>
	JRST PAC8

;GET HERE WHEN COULDN'T SET PAGE ACCESS.  JUST PRINT WARNING ABOUT
;THAT PAGE AND RETURN

NOSPAC:	CALL DGETER		;GET LATEST ERROR REASON
	MOVEM A,SPERR		;REMEMBER
NOSP1:	SKIPN SPCNT		;ANY ACCUMULATED ERRORS?
	JRST [	MOVE A,SPPAG	;NO, GET STARTING PAGE NUMBER
		HRRM A,SPERF	;REMEMBER WHERE NEW SET BEGINS
		MOVE A,SPERR	;SEE WHAT THE ERROR IS
		HRLM A,SPERF	;REMEMBER ERROR
		MOVEI A,1
		MOVEM A,SPCNT	;SAY ONE IN A ROW
		RET]		;DONE UNTIL NEXT ERROR
	HRRZ A,SPERF		;THERE'S ACCUMULATED ERRORS, GET STARTING PAGE
	ADD A,SPCNT		;GET NEXT PAGE IN GROUP
	HLRZ C,SPERF		;GET REASON WHY THIS GROUP FAILED
	CAMN A,SPPAG		;IS THIS PAGE NOT NEXT ONE IN GROUP?
	CAME C,SPERR		;OR IS REASON DIFFERENT THAT CURRENT GROUP?
	CAIA			;SOMETHING'S DIFFERENT
	JRST [	AOS SPCNT	;SAME ERROR AND CONSECUTIVE PAGE, JUST REMEMBER HOW MANY IN A ROW
		RET]
	CALL SPREP		;DIFFERENT REASON, REPORT PREVIOUS GROUP
	SETZM SPCNT		;CAUSE NEW GROUP TO START
	JRST NOSP1		;LOOP TO GRAB THIS LATEST ERROR

;ROUTINE TO PRINT ERROR. TAKES NUMBER OF CONSECUTIVE PAGES THAT FAILED IN SPCNT.
;TAKES REASON FOR FAILURE IN LEFT HALF OF SPERF AND STARTING PAGE NUMBER IN
;RIGHT HALF OF SPERF.

SPREP:	SKIPN C,SPCNT		;SEE HOW MANY FAILED IN A ROW
	RET			;NONE, SO NOTHING TO REPORT
	HLRZ A,SPERF		;GET REASON
	HRRZ B,SPERF		;GET FIRST PAGE THAT FAILED
	CAIN C,1		;1 IS SPECIAL CASE
	JRST [	LERROR <Couldn't set access of page %2O - %1?>
		RET]
	ADD C,B			;GET LAST PAGE THAT FAILED
	SOJ C,
	LERROR <Couldn't set access of pages %2O through %3O - %1?>
	RET

$ACCES:	TABLE			;OF ACCESS TYPES
	T COPY-ON-WRITE,,[PA%CPY]
	T EXECUTE,,[PA%EX]
	T NO,,[0]
	T NONEXISTENT,,[-1]
	T READ,,[PA%RD]
	T WRITE,,[PA%WT]
	TEND

.CTRAC::NOISE <OF GENERATED COMMANDS> ;PCL
	CONFIRM			;CM156
	MOVX A,PCFTRC		;TRACE BIT
	ANDCAM A,PCFLAG		;CLEAR IT
	SKIPN SETNOF		;WANT IT SET?
	IORM A,PCFLAG		;SET IT
	RET			;CM156

;CS119 *** Begin ***

.SENAB::NOISE <DURING CONNECT AND ACCESS>
	CONFIRM
	SETCM A,SETNOF		;Did he specify "no"?
	MOVEM A,ENAFLG		;Set flag to value
	RET

;CS119 *** End ***

;EM134 *** Begin ***

.CASIF::NOISE <exec output>
	CONFIRM
	MOVE A,SETNOF		;Did he specify "no"?
	MOVEM A,CASFLG		;Set flag to value
	RET

;EM6 (begin)

.CTRLT::Noise <display>
	CONFIRM
	SETCM A,SETNOF		;Get complement of "no" value
	MOVEM A,CTTFLG		;Save as flag value
	RET

;EM6 (end)

;EM35 *** Begin ***

$RECOR:	TABLE
	T All,ONEWRD,(RC%BOT)
	T Received,ONEWRD,(RC%RCV)
	T Sent,ONEWRD,(RC%SND)
	TEND

.SRECO::NOISE <messages>
	KEYWD $RECOR		;What state are we setting
	 0
	 CMERRX <Invalid record value>
	HRRZ C,(B)		;Get the value
	HRLZ D,(C)		;from the address
	ANDCAM D,RECFLG		;Clear specified bits
	SKIPN SETNOF		;Are we really setting them?
	 IORM D,RECFLG		;Set the bits in the flag word
	RET			;Done

;EM57 Begin
.PROMP::CALL PCOMMN
	CALL DIVPMR
	CALLRET PSDONE

.SPROM::CALL PCOMMN
	CALL DIVPMS
	CALL PSDONE

$PROKEY:TABLE
	T Prompt,,EPROMP
	T Subcommand-prompt,,ESPROM
	TEND

.EPROM::KEYWD $PROKEY
	 0
	 CMERRX
	CALLRET (P3)

EPROMP:	CALL PCOMMN
	CALL DIVPME
	CALLRET PSDONE

ESPROM:	CALL PCOMMN
	CALL DIVPMU
	CALLRET PSDONE

PCOMMN:	NOISE <to>
	LINEX <Prompt string>
	 CMERRX
	HRROI A,ATMBUF
	CALL BCOUNT
	HRLZ A,B
	HRRI A,ATMBUF
	SETO B,
	RET

PSDONE:	CALLRET CMDIN4
;EM57 End
	
;EM66 ***Begin***
;Set Command-Edit-Mode

.CEDMO::NOISE <to>
	KEYWD $CEDIT		;Get the mode
	0			;No default
	JRST CERR		;Parse error
	HRRZM P3,CEFLAG		;Save the mode
	RET

$CEDIT:	TABLE
	T Alter,ONEWRD,-1
	T Emacs,ONEWRD,0
	TEND
;EM66 ***End***

.CTRLC::NOISE <OF PROGRAM>
	CONFIRM
	IFNBATCH (ILLBAT)
	SKIPN SETNOF
	TDZA A,A
	SETO A,
	MOVEM A,CCFLAG		;CONTROL-C FLAG
	MOVE A,C2PASS		;CM318 Get caps we're allowed to pass
	TXZ A,SC%CTC		;CM318 Assume turning off ^C
	SKIPN SETNOF		;CM318 Are we really supposed to turn it on?
	TXO A,SC%CTC		;CM318 Yes, the do it
	JRST SPRIV2		;CM318 Join "Set privileges" code

;CM318 *** Begin deletion ***

REPEAT 0,<
	SKIPG A,FORK		;CURRENT FORK?
	RET			;NO, LEAVE NOW
	RPCAP			;YES, GET CAPS
	SKIPE CCFLAG		;ENABLE OR DISABLE?
	TXZA B,SC%CTC		;DISABLE
	TXO B,SC%CTC		;ENABLE
	SKIPE PRVENF		;IF NO CAPS ENABLED, CLEAR ^C
	SKIPE CCFLAG		;ENABLE OR DISABLE?
	TXZA C,SC%CTC		;DISABLE
	TXO C,SC%CTC		;ENABLE
	EPCAP			;YES, SET
	RET
>;REPEAT 0

;CM318 *** End deletion ***

ILLBAT:	ERROR	<Illegal under BATCH>

;CM318 *** Begin ***

.SPRIV::NOISE <for program>
	CONFIRM
	MOVE A,C2PASS		;Get current caps we're passing
	SKIPE SETNOF		;Turning off caps?
	TRZA A,-1		;Yep, zero bits for right-half capabilities
	TRO A,-1		;Else turn them all on

;"Set [no] control-C..." join here.  Takes new capability mask in A.

SPRIV2:	MOVEM A,C2PASS		;Store for posterity
	SKIPG A,FORK		;Current fork?
	RET			;No, leave now
	RPCAP%			;Yes, get current caps
	MOVE B,C2PASS		;Set its possible caps
	AND C,C2PASS		;Turn off any that are no longer allowed
	EPCAP%
	RET

;CM318 *** End ***

;SET DEFAULT (FOR)

.SEDEF::NOISE (FOR)
	KEYWD TDEFAU		;SEE WHICH COMMAND DEFAULT BEING SET FOR
	 0			;NO DEFAULT
	 CMERRX <Invalid command to set defaults for>
	JRST (P3)		;DISPATCH TO DEFAULTING ROUTINE

;SET NO DEFAULT (FOR)

.NODEF::NOISE (FOR)
	KEYWD $NODEF		;SEE WHICH COMMAND DEFAULT BEING CLEARED FOR
	 0			;NO DEFAULT
	 CMERRX <Invalid command to clear defaults for>
	JRST (P3)		;DISPATCH TO DEFAULTING ROUTINE

.TKD::	KEYWD $TKD		;PARSE NEXT KEYWORD ("ECHO" OR "NO")
	 0			;NO DEFAULT
	 CMERRX <invalid option for SET DEFAULT TAKE command>
	JRST (P3)		;DISPATCH TO DEFAULTING ROUTINE

$TKD:	TABLE
	T ALLOW
	T DISALLOW
	T ECHO,,.ECHO
	T NO,,.TKND
	TEND

.ECHO:	CALL ECHNOI		;FINISH COMMAND
	MOVX A,TKECOF		;GET BIT SAYING ECHOING WANTED
	IORM A,TAKDEF		;REMEMBER IN DEFAULTS WORD
	RET

.TKND:	KEYWD $NTKD		;PARSE NEXT KEYWORD ("ECHO")
	 T ECHO,,.NOECH
	 CMERRX <invalid option for SET DEFAULT TAKE command>
	JRST (P3)		;DISPATCH TO DEFAULTING ROUTINE

$NTKD:	TABLE
	T ECHO,,.NOECH
	TEND

.NOECH:	CALL ECHNOI
	MOVX A,TKECOF		;BIT SAYING WE WANT ECHOING
	ANDCAM A,TAKDEF		;TURN IT OFF IN DEFAULT WORD
	RET

.SDDCL::MOVEI B,[FLDDB. .CMSWI,,$SDEF,,,] ;PCL
	CALL FLDSKP		;SEE WHAT HE WANTS
	 CMERRX
	CALL GETKEY		;GET THE DATA WORD
	CONFIRM			;FINISH IT OFF
	MOVX B,PCFQDC		;GET THE QUIET-DECLARATION BIT
	ANDCAM B,PCFLAG		;CLEAR IT TO ASSUME NOISY DECLARATION
	SKIPN P3		;NOCONFIRM?
	IORM B,PCFLAG		;YES, USE QUIET DECLARATION
	RET			;PCL All done

.ALLOW:	CALL ALONOI		;FINISH COMMAND
	MOVX A,TKALEF
	IORM A,TAKDEF		;ALLOW ERRORS
	RET

.DISAL:	CALL ALONOI		;FINISH COMMAND
	MOVX A,TKALEF
	ANDCAM A,TAKDEF		;DISALLOW ERRORS DURING TAKE FILES
	RET

ALONOI::NOISE (ERRORS DURING "TAKE" FILE)	;THE "NOISE" CALL *MUST* STAY ON THIS TAG
	CALLRET CONF		;CONFIRM AND RETURN

ECHNOI::NOISE (COMMANDS FROM "TAKE" FILE)	;THE "NOISE" CALL *MUST* STAY ON THIS TAG
	CALLRET CONF		;CONFIRM AND RETURN

;"SET DIRECTORY"

.SDIR::	SETZM SETNOF		;ASSUME "NO" NOT TYPED
	SETZM PASSP		;TELL CRDIR THERE'S NO PASSWORD SUPPLIED YET
	KEYWD $SDIR
	 0
	 JRST CERR
	JRST (P3)

$SDIR:	TABLE
	T ACCOUNT-DEFAULT,,.DAD
XARC <
	T ARCHIVE-ONLINE-EXPIRED-FILES,WHLU,.DARF
   >
	T FILE-PROTECTION-DEFAULT,,.DFPD
	T GENERATION-RETENTION-COUNT-DEFAULT,,.DGRCD
	T MAIL-ROUTING-ADDRESS,,.DMROU	;CM301
	T NO,,.SDNO			;CM301 Needs NO
XARC <
;CM301 	T NO,,.SDNO
	T OFFLINE-EXPIRATION-DEFAULT,,.DOFXP
	T ONLINE-EXPIRATION-DEFAULT,,.DONXP
   >
	T PASSWORD,,.DPASS
	T PROTECTION,,.DPRO
CC,<	T USE-BY,,.DUSEB>		;CM9
	TEND

.SDNO:	SETOM SETNOF		;FLAG THAT NO WAS SAID
	KEYWD $SDNO
	 0			;CM301 No default
	 JRST CERR
	JRST (P3)

$SDNO:	TABLE
XARC <				;CM301
	T ARCHIVE-ONLINE-EXPIRED-FILES,WHLU,.DARF
>;XARC				;CM301
	T MAIL-ROUTING-ADDRESS,,.DNMRO ;CM331
CC,<	T USE-BY,,.DUSEB>	;CM9
	TEND

;SET PROGRAM ENTRY (VECTOR LOCATION) <OCTAL> (LENGTH) <OCTAL>

.ENTRY::SKIPGE FORK
	ERROR <No program>
	NOISE <LOCATION TO>
	ADDRX <Memory location of entry vector>
	 ERROR <Invalid location>
	MOVEM B,ENTADR		;REMEMBER ENTRY VECTOR LOCATION
	NOISE <LENGTH>
	DEFX <1>		;DEFAULT
	ADDRX <Value between 1 and 777 octal
or 254000 for TOPS10-compatible entry vector.>
	 ERROR <Invalid length>
	CAILE B,777		;TOO LONG?
	JRST [	CAIN B,254000	;ALLOW JRST FOR COMPATIBLE
		JRST .+1
		ERROR <Invalid length>]
	CONFIRM
	MOVE C,ENTADR		;GET LOCATION OF VECTOR
	MOVE A,FORK
	CALLRET SETENT		;SET ENTRY VECTOR AND RETURN

;"SET FILE"

.SFILE::SETZM SETNOF		;FLAG "NO" WAS NOT SAID YET
	KEYWD $SFILE
	 0
	 JRST CERR
	JRST (P3)

.SFNO::	SETOM SETNOF
	KEYWD $SFNO
	 0
	 JRST CERR
	TXNN P3,NOLG		;NEED TO BE LOGGED IN?
	SKIPE CUSRNO		;YES, AND ARE WE?
	CAIA			;YES, GO AHEAD
	ERROR <LOGIN please>
	JRST (P3)		;DO WHATEVER

;OFFLINE/ONLINE/EXPIRED CODE

.FLINX::SETZ A,			;NO EXPIRATION YET
	MOVX B,.RSFET		;OFFSET TO GUY WE'RE CHANING
	JRST DOEXPI		;JOIN OTHER CODE
.FEXP::	GTAD			;EXPIRE THE FILE, NOW WILL DO
	CAIA
.FLONX::SETZ A,			;SAY NO DATE/TIME OR INTERVAL
	MOVX B,.RSNET		;CELL WHERE THIS VALUE GOES
DOEXPI:	PUSH P,A		;SAVE THE VALUE
	PUSH P,B		;AND THE OFFSET
	CAIN A,0		;DOING FILE EXPIRED? (HAVE VALUE IF SO)
	NOISE <OF FILES>
	CAIE A,0		;HAVE A VALUE?
	NOISE <FILES>		;YES, "SET FILE EXPIRED (FILES) <FILES>"
	CALL INFGNS		;GET FILE GROUPS
	SKIPE -1(P)		;HAVE A VALUE YET?
	JRST DOEXI4		;YES
	NOISE <TO>
	DTIVX <Expiration date>
	 JRST CERR		;LOSES
	MOVEM B,-1(P)		;REMEMBER VALUE GIVEN US
	CAIA
DOEXI4:	CONFIRM
	SETOM FTDBLK
	MOVE A,[FTDBLK,,FTDBLK+1]
	BLT A,FTDBLK+.RSFET	;SET UP THE BLK
	POP P,A			;GET DESIRED OFFSET
	POP P,FTDBLK(A)		;VALUE REQUESTED
	SETOM TYPGRP		;TYPE FILE NAMES
	MOVE A,JBUFP		;SET UP JFN STACK FENCE
	MOVEM A,.JBUFP
DOEXI1:	CALL RLJFNS
	CALL NXFILE
	 JRST DOEXI2		;NO MORE FILES...
	CALL TYPIF		;DO FILE NAME
	CALL MFINP		;GET A TEMP JFN FOR THE FILE
	 JRST DOEXI2		;FAILED...
	MOVEI B,FTDBLK
	MOVEI C,.RSFET+1	;BLK LENGTH
	SFTAD			;SET
	 ERJMP DOEXI3		;FAILED, SAY WHY
	CALL TYPOK		;SAY IT WENT FINE
DOEXI2:	SKIPE INIFH1		;ANYTHING LEFT TO DO?
	JRST DOEXI1		;YES, KEEP GOING
	RET

DOEXI3:	ETYPE < %?
>
	JRST DOEXI2

;PROHIBIT/RESIST-MIGRATION

.FPROH::MOVX A,.AREXM
	CAIA
.FRESI::MOVX A,.ARNAR		;DO RESIST
	MOVX B,.ARSET		;ASSUME USER IS SETTING IT
	SKIPE SETNOF		;USER SAY "NO" ?
	MOVX B,.ARCLR		;YES, CLEAR THE BIT
	PUSH P,A		;SAVE FUNCTION CODE
	PUSH P,B		;AND SET/CLEAR CODE
	NOISE <MIGRATION OF FILES>
	CALL TYPFLS		;COLLECT FILE NAME GROUPS
	SETOM TYPGRP		;TYPE THE NAMES AS WE GO
	MOVE A,JBUFP
	MOVEM A,.JBUFP		;COVER JFN STACK
DOPRRS:	CALL RLJFNS		;RELEASE SPARE JFNS
	CALL NXFILE
	 JRST DOPRR1		;NO MORE
	CALL TYPIF
	CALL MFINP		;GET A SECOND JFN
	 JRST DOPRR1		;COULDN'T
	MOVE B,-1(P)		;GET DESIRED FUNCTION
	MOVE C,0(P)		;WHICH WAY TO SET IT
	ARCF			;DO IT
	 ERJMP [ETYPE < %?
>
		JRST DOPRR1]	;FAILED
	CALL TYPOK
DOPRR1:	SKIPE INIFH1		;ANYTHING LEFT?
	JRST DOPRRS		;NO
	ADJSP P,-2		;DITCH PARAMS
	RET

;CS126 *** Entire page ***
.FSETU::STKVAR <PWDPTR,USRNO,GRPNO,<ACBLK,.ACJOB+1>>
	NOISE <OF FILES>
	CALL INFGNS		;get file spec(s)
	HRRZ A,@INIFH1		;get jfn
	DVCHR
	TXNN B,DV%MDD		;multiple directory device?
	 ERROR <SETUID not implemented for this device>
	SETZM GRPNO		;no group yet
	SETZM PWDPTR		;and no password
	SKIPN SETNOF		;is it no?
	IFSKP.
	  CONFIRM		;just confirm it
	ELSE.			;else, read it and check validity
	  NOISE <TO>
	  MOVEI B,[FLDDB. .CMUSR]
	  MOVX A,SC%WHL
	  TDNE A,EXECAP+1	;allow user group # if wheel
	    MOVEI B,[FLDDB. .CMNUM,CM%SDH,5+3,<Special group number>,,[
		     FLDDB. .CMUSR]] ;get a number or user
	  CALL FLDSKP		;try to read the username/group number
	   CMERRX
	  MOVEM B,USRNO		;stash the value for later
	  HRRZS B		;punt LH of it and move it
CC,<	  LOAD C,CM%FNC,.CMFNP(C) ;find out what parsed
	  CAIE C,.CMUSR		;userid?
	  IFSKP.		;yes
	    MOVE A,[POINT 7,ATMBUF] ;point at it
	    CALL HSHUSR		;hash it into a man-number
	    MOVE B,A		;put in correct ac
	  ENDIF.
   >
	  SKIPL B		;is it negative?
	  CAILE B,777777	;or too big?
CC,<	  ERROR <Group numbers must be between 1 and 777777>>
CS,<	  ERROR <Group numbers must be between 1 and 377777>>
	  MOVEM B,GRPNO		;save the group number
	  CONFIRM		;confirm it
	  MOVX A,SC%WHL
	  TDNE A,EXECAP+1	;enabled wheel?
	  IFSKP.		;nope. must request & check password
	    CALL PASLIN		;go get the password
	    MOVEM A,PWDPTR	;save this
	    MOVEI B,ACBLK	;point at ACCES argblk
	    MOVE C,USRNO	;get user number
	    HRLI C,540000	;make a directory number of it
	    MOVEM C,.ACDIR(B)	;put in argblk
	    MOVEM A,.ACPSW(B)	;save pointer to password
	    SETOM .ACJOB(B)	;this job
	    MOVX A,AC%PWD!.ACJOB+1 ;function+length
	    ACCES%		;check password
	     ERCAL CJERRE	;punt with error
	  ENDIF.
	ENDIF.
	SETOM TYPGRP		;type files as we go
	DO.
	  CALL NXFILE
	  JRST [SKIPE INIFH1	;end of terms?
		LOOP.		;no, do another
		RET]
	  HRRZ A,@INIFH1	;get the JFN
	  CALL TYPIF		;print the file name
	  HRLI A,.UISET		;setting SETUID for file
	  MOVE B,GRPNO		;group number to set
	  MOVE C,PWDPTR		;password pointer
	  UICTL%		;set uid for this file
	  IFJER.		;failed
	    ETYPE < %?
>
	  ELSE.
	    CALL TYPOK
	  ENDIF.
	  CALL GNFIL		;skip to next file
	  TRNA			;no more files
	  LOOP.			;loop for next
	ENDDO.
	RET
	ENDSV.

;PROTECTION (OF FILE) <EXISTING NAME> (IS) <18 BIT OCTAL>
;VERSION-RETENTION-COUNT ...
;INVISIBLE/VISIBLE

.VISIB::TXO Z,IGINV		;FIND INVISIBLE FILES
	TDZA B,B		;MAKE FILES VISIBLE
.INVIS::MOVX B,FB%INV		;MAKE FILES INVISIBLE
	TLO Z,F2		;FLAG DOING INV/VIS STUFF
	NOISE <FILES>
	PUSH P,B		;SAVE OUR PARAM NOW
	CALL TYPFLS		;NOT INFGNS, SINCE NO GUIDE WORD AFTER FILESPEC
	JRST FILEV2		;ENTER DOWN A LITTLE WAY
.FILEV::TLOA Z,F1		;FLAG VERSION-RET...
.PROTE::TLO Z,F3
	NOISE <OF FILES>
	CALL INFGNS
	NOISE <TO>
	TLNE Z,F1
	JRST [	DECX <Decimal generation retention count>
		 CMERRX
		CAILE B,^D63	;LEGAL?
		ERROR <Generation retention count must be 0-63>
		LSH B,^D36-^D6	;LEFTMOST 6 BITS
		JRST FILEV1]
	OCTX <Octal file protection value>
	 CMERRX
	TLO B,500000		;INDICATE THAT THERE'S 18-BIT PROTECTION IN RH
	TRNE B,020202		;CM12 Will he have access to it?
	JRST FILEV1		;CM12 Yes
	CONFIRM			;CM12
	PROMPT <[File will now be protected so that you will not be able to see it,
 are you sure?]>		;CM12 Warn him
	CALL EXTCNF		;CM12 Request extra confirmation
	 RET			;CM12 User wants to punt
	JRST FILEV2		;CM12 User really wants it, go on

FILEV1:	CONFIRM
FILEV2:	SETOM TYPGRP		;PRINT ALL FILES
	TLNN Z,F2		;VIS/INVIS?
	PUSH P,B		;YES, ALREADY HAVE PARAM SAVED
PROTE1:	CALL NXFILE
	 JRST [	SKIPE INIFH1	;END OF TERMS?
		JRST PROTE1	;NO, DO ANOTHER
		POP P,(P)
		RET]
	HRRZ A,@INIFH1		;GET JFN
	DVCHR
	TXNN B,DV%MDD		;MULTIPLE DIRECTORY DEVICE?
	JRST [	TLNE Z,F1
		ETYPE <?%1H: Generation retention count not implemented for this device
>
		TLNE Z,F2
		ETYPE <?%1H: Invisible files not implemented for this device
>
		TLNE Z,F3
		ETYPE <?%1H: Protection not implemented for this device
>
		MOVSI A,(77B5)
		ANDCAM A,@INIFH1 ;CLEAR * INDICATIONS TO FORCE STEPPING TO NEXT JFN
		JRST PROTE2]
	TLNE Z,F2		;INV/VIS?
	JRST [	SKIPE 0(P)	;SET FILE VISIBLE?
		JRST .+1	;NO
		HRRZ A,@INIFH1	;YES, GET JFN
		MOVE B,[1,,.FBCTL] ;FIND OUT IF CURRENTLY INVISIBLE
		MOVEI C,C
		GTFDB
		 ERJMP PROTE2	;SKIP FILE IF WE CAN'T TELL
		TXNE C,FB%INV	;IS IT INVISIBLE NOW?
		JRST .+1	;YES, PRINT NAME & MAKE VISIBLE
		JRST PROTE2]
	CALL TYPIF		;TYPE NAME IF GROUP (RETURNS JFN IN A)
	TLNE Z,F2		;INV/VIS?
	JRST [	HRLI A,.FBCTL	;WHERE THE BIT BE CHANGED IS
		MOVX B,FB%INV	;BIT IN QUESTION
		JRST DOSFL1]
	HRLI A,.FBPRT		;PROTECTION WORD IN FDB
	TLNE Z,F1
	HRLI A,.FBBYV		;THIS IS VER RET WORD
	MOVEI	B,777777	;CHANGE RHS ONLY
	TLNE	Z,F1
	LDF	B,FB%RET	;RETENTION COUNT PART
DOSFL1:	MOVE	C,(P)		;GET PROTECTION OR VER RET COUNT
	CALL	$CHFDB
	 JRST [	TYPE <   Access not allowed
>
		JRST PROTE2]
	CALL TYPOK
PROTE2:	CALL GNFIL
	SKIPA
	JRST PROTE1
	POP P,(P)		;FIX STACK
	RET


;SET FILE EPHEMERAL (ALSO SET NO ...)

.EPHM::	MOVSI A,.FBEPH		;CODE FOR EPHEMERAL
.EPHM0:	STKVAR <FCODE>
	SETZM FCODE		;CLEAR CODE
	SKIPN SETNOF		;SET NO ...?
	 MOVEM A,FCODE		;STORE ACTUAL CODE TO SET
	CALL INFGNS		;COLLECT FILE NAME GROUPS
	CONFIRM
	SETOM TYPGRP		;TYPE THE NAMES AS WE GO
	MOVE A,JBUFP
	MOVEM A,.JBUFP		;COVER JFN STACK
EPHM1:	CALL RLJFNS		;RELEASE SPARE JFNS
	CALL NXFILE		;GET THE NEXT FILE
	 JRST EPHM2		;NO MORE - FINISH UP
	CALL TYPIF		;TYPE OUT THE FILE NAME
	CALL MFINP		;GET A SECOND JFN
	 JRST EPHM2		;COULDN'T - ON TO NEXT FILE
	HRLI A,.FBCTL		;WORD IN FDB TO CHANGE
	MOVX B,FB%FCF		;MASK FOR FILE TYPE CODE
	MOVE C,FCODE		;GET CODE OR 0
	CALL $CHFDB		;SET CODE IN FDB
	 JRST [	TYPE <  Access not allowed
>
		JRST EPHM2]
	CALL TYPOK		;SAY THE CHANGE SUCCEEDED
EPHM2:	SKIPE INIFH1		;ANYTHING LEFT?
	 JRST EPHM1		;YES - LOOP
	RET			;NO - DONE

;SET DIRECTORY [NO] ARCHIVE-ONLINE-EXPIRED-FILES (OF DIRECTORY)

.DARF:	CALL INPDIR		;GET THE DIRECTORY IN QUESTION
	MOVX A,CD%DAR		;BIT TO CHANGE
	CALLRET DMODE		;GO CHANGE A SINGLE MODE BIT

;SET DIRECTORY GENERATION-RETENTION-COUNT-DEFAULT

.DGRCD:	CALL INPDIR		;GET DIRECTORY NAME
	NOISE <TO>
	DECX <Decimal number of generations per file to be retained>
	 CMERRX
	MOVEM B,.CDRET+SEBLK	;REMEMBER NUMBER
	CAIE B,1		;DON'T SAY "1 (GENERATIONS...)"
	NOISE <GENERATIONS PER FILE>
	CAIN B,1
	NOISE <GENERATION PER FILE>
	LDF A,CD%RET		;SPECIFY WHICH PARAMETER TO CHANGE
	CALLRET DWORK		;CM12 FALL TO DO THE WORK AND RETURN

;ROUTINE USED FOR SET DIRECTORY COMMANDS.  IT ATTEMPTS TO DO THE CRDIR
;JSYS, AND IF IT FAILS DUE TO A PASSWORD BEING REQUIRED, IT ASKS FOR ONE
;AND TRIES AGAIN.
;
;ACCEPTS:	A/	BITS SHOWING PARAMETER TO CHANGE (CRDIR AC2)
;
;RETURNS:	+1 ALWAYS

DWRKNC:	MOVEM A,WBITS		;CM12 Like DWORK except skips CONFIRM
	JRST DWORK2		;CM12 Join common code

DWORK:	MOVEM A,WBITS		;REMEMBER WHICH BITS
	CONFIRM			;CONFIRM THE COMMAND
	MOVE A,WBITS		;GET BITS TO SET
DWORK2:				;CM12
	CALL CREDIR		;TRY TO CHANGE THE DIRECTORY
	 JRST DWORK1		;FAILED, SEE WHY
	RET			;SUCCEEDED WITHOUT PASSWORD

DWORK1:	CALL DGETER		;SEE WHY IT FAILED
	CAIE A,ACESX3		;PASSWORD REQUIRED AND NOT GIVEN?
	CALL CJERRE		;OTHER ERROR, FAIL NOW
	CALL GETPAS		;FAILED, ASK FOR A PASSWORD
	MOVE A,WBITS		;TRY AGAIN
	CALL CREDIR
	 CALL CJERRE		;FAILED AGAIN, TELL USER WHY AND DIE.
	RET			;SUCCEEDED, DONE

;ROUTINE TO GET PASSWORD FOR SET DIRECTORY COMMANDS.

GETPAS:	CALL PASLIN		;INPUT THE PASSWORD
	MOVEM A,PASSP		;SAVE POINTER TO IT IN PASSP
	RET

;ROUTINE TO EXECUTE CRDIR FOR USER-SETTABLE PARAMETERS.
;ACCEPTS:
;	A/	BITS DESIGNATING PARAMETERS BEING CHANGED
;RETURNS:	+1 ERROR
;		+2 SUCCESS

;NOTE:  THIS ROUTINE IS NOT GENERALLY CALLABLE, AS PASSP IS A LOCAL
;VARIABLE.  TO MAKE IT GENERAL, MAKE PASSP BE AN ARG.

CREDIR:	MOVE B,A		;PUT CONTROL BITS IN AC2 FOR JSYS
	MOVE A,DIRP		;GET DIRECTORY NUMBER
	MOVE C,PASSP		;AND POINTER TO PASSWORD
	HRRI B,SEBLK		;SPECIFY WHERE PARAMETER BLOCK IS.
	CRDIR			;MAKE THE DIRECTORY MODIFICATION
	 ERJMP R		;FAILED, PROBABLY BECAUSE PASSWORD REQUIRED OR WRONG
	RETSKP			;SUCCEEDED, SKIP

;SET DIRECTORY OFFLINE-EXPIRATION-DEFAULT

.DONXP:	MOVX A,.CDDNE
	CAIA
.DOFXP:	MOVX A,.CDDFE
	PUSH P,A		;SAVE WHAT WE'RE CHANGING
	CALL INPDIR		;GET A DIRECTORY NAME
	NOISE <TO>
	DTIVX <Expiration date>
	 CMERRX
	POP P,A			;WHAT WE'RE CHANGING
	CAIN A,.CDDNE		;GUESS WE'RE CHANGING ONLINE
	JRST [	MOVEM B,.CDDNE+SEBLK ;WE ARE
		MOVX B,CD%NED
		JRST DOFXP1]
	MOVEM B,.CDDFE+SEBLK	;WRONG, IS OFFLINE DEFAULT
	MOVX B,CD%FED
DOFXP1:	HRRI B,.CDDFE+1		;LENGTH OF THE BLK
	MOVEM B,.CDLEN+SEBLK
	MOVX A,CD%LEN		;SET THIS SO BITS IN CDLEN ARE NOTICED
	CALLRET DWORK		;DO IT & RETURN

;SET DIRECTORY FILE-PROTECTION-DEFAULT

.DFPD:	CALL INPDIR		;GET DIRECTORY NAME
	NOISE <TO>
	OCTX <Octal default file-protection value>
	 CMERRX
	MOVEM B,.CDFPT+SEBLK	;REMEMBER GIVEN VALUE
	LDF A,CD%FPT		;SPECIFY WHICH PARAMETER WE'RE CHANGING
	CALLRET DWORK		;GO DO THE WORK

;SET DIRECTORY PASSWORD

.DPASS:	NOISE <OF DIRECTORY>
;CM224	TLO Z,F1		;DON'T DEFAULT THE DIRECTORY NAME
	CALL DIRNAM		;READ THE DIRECTORY NAME
	 ERROR <Invalid directory name or syntax>
	CALL BUFFF		;GET POINTER TO DIRECTORY NAME
	MOVEM A,DIRP		;LEAVE DIRECTORY NAME IN DIRP
	CONFIRM			;INPUT PASSWORDS ON SEPARATE LINES
	MOVEI A,[ASCIZ /Old password: /]
	CALL PASSX		;INPUT THE CURRENT PASSWORD
	MOVEM A,PASSP		;SAVE POINTER TO IT IN PASSP
DPASS1:	MOVEI A,[ASCIZ /New password: /]
	CALL PASSX		;READ PASSWORD WITH NOISE WORDS "NEW PASSWORD"
	MOVEM A,.CDPSW+SEBLK	;SAVE POINTER TO NEW PASSWORD STRING
CS,<				;CS146
	CALL CHKPSW		;CS146 See if that password is OK
	IFNSK.			;CS146
	  ETYPE <?Password is insecure - %1M %_> ;CS146
	  JRST DPASS1 		;CS146
	ENDIF.			;CS146
   >;CS				;CS146
	MOVEI A,[ASCIZ /Retype new password: /]
	CALL PASSX		;READ NEW PASSWORD AGAIN
	MOVE B,.CDPSW+SEBLK	;GET FIRST ATTEMPT AT TYPING IT
	STCMP			;MAKE SURE THEY'RE THE SAME
	CAIE A,0		;ARE THEY?
	ERROR <The two copies of the new password weren't the same>
	LDF A,CD%PSW		;SPECIFY WHAT WE'RE CHANGING
	CALL CREDIR		;GO DO THE WORK
	 CALL CJERRE		;PRINT MONITOR'S ERROR MESSAGE IF FAILS
	RET			;SUCCESS

;SET DIRECTORY ACCOUNT-DEFAULT

.DAD:	CALL INPDIR		;GET NAME
	NOISE (TO)
	LINEX <Default account string for directory>
	 CMERRX
	CALL BUFFF
	MOVEM A,.CDDAC+SEBLK	;SAVE POINTER TO DEFAULT ACCOUNT STRING
	MOVX A,CD%DAC		;BIT FOR SETTING DEFAULT ACCOUNT STRING
	CALLRET DWORK		;DO THE WORK AND RETURN

;CM301 Set Directory [no] Mail-Routing-Address

.DNMRO:	CALL INPDIR		;Get name
	CONFIRM
	HRROI A,[ASCIZ ""]	;Get null string
	MOVEM A,.CDMRA+SEBLK	;Save as new mail routing address
	JRST DMROU2		;Join common code

.DMROU:	STKVAR <MRAPTR>
	CALL INPDIR		;Get name
	NOISE (TO)
CS,<	LINEX <Mail routing address>
	 CMERRX
>;CS
CC,<	MOVE A,CMPTR		;Get .CMPTR word
	MOVEM A,MRAPTR		;Save it for later
	HRROI B,[GETSAVE (SYS:CHECK-ROUTING-ADDRESS.)] ;Get the program
	CALL TRYGTJ
	 ERROR <Can't find SYS:CHECK-ROUTING-ADDRESS.EXE>
	MOVE B,CMPTR		;Get pointer to the rest of the input line
	MOVE C,CMINC		;  and the number of unparsed characters
	ADJBP C,B		;Make C point to end of user's input
	SETZ B,			;Load B with nulls
	IDPB B,C		;Null-terminate CBUF
	CALL STEPHF		;Run the program
>;CC
	MOVE A,MRAPTR		;Get pointer to routing address
	MOVE B,[POINT 7,ATMBUF]	;Get pointer to atom buffer
	DO.			;Get first char, skipping initial whitespace
	  ILDB C,A		;Get character
	  CAIE C,.CHSPC		;Space?
	   CAIN C,.CHTAB	; or tab
	    LOOP.		;Yes, skip over it
	OD.
	SETO C,			;Back up one
	ADJBP C,A		;...
	MOVEM C,A
	DO.			;Copy routing address
	  ILDB C,A		;Get a character
	  CAIE C,.CHCRT		;CR?
	   CAIN C,.CHLFD	; or LF?
	    JRST ENDLP.		;Yes, done
	  JUMPE C,ENDLP.	;Also done on null
	  IDPB C,B		;Store it in the atom buffer
	  CAIE C,.CHSPC		;Whitespace?
	   CAIN C,.CHTAB	; ...
	    LOOP.		;Yes
	  MOVE D,B		;No, update "last significant char" pointer
	  CAIE C,.CHCNV		;^V?
	   LOOP.		;No, keep going
	  ILDB C,A		;Get next character
	  IDPB C,B		;Store it (transparently)
	  MOVE D,B		;Update "last significant char" pointer
	  LOOP.			;Get another character
	OD.
	SETZ C,			;Get a null
	IDPB C,D		;Stick it after last significant char (strip
				; trailing whitespace)
	HRROI A,ATMBUF		;See how long the string is
	CALL BCOUNT
	LSH A,2			;Get twice as much space
	MOVEI B,DICT		;From temporary pool
	CALL GETMEM
	 JRST [BUG		;CM302
	       ERROR <String space exhausted 0>] ;CM302
	HRLI B,440700		;Make pointer to block
	MOVEM B,.CDMRA+SEBLK	;Save pointer to mail routing address
	MOVE A,[POINT 7,ATMBUF]	;Allow lower case letters to pass
	MOVEI D,"V"-100
DMROU1:	ILDB C,A
	CAIL C,"A"+40
	CAILE C,"Z"+40
	TRNA
	IDPB D,B
	IDPB C,B
	JUMPN C,DMROU1
DMROU2:	MOVX B,CD%MRA+.CDMRA+1	;Bit for setting it
	MOVEM B,.CDLEN+SEBLK
	MOVX A,CD%LEN		;So bits in CDLEN are noticed
	CALLRET DWRKNC		;Do the work and return

;SET DIRECTORY PROTECTION

.DPRO:	CALL INPDIR		;INPUT DIRECTORY NAME
	NOISE <TO>
	OCTX <Octal directory protection value>
	 CMERRX
	MOVEM B,.CDDPT+SEBLK	;SAVE DESIRED DIRECTORY PROTECTION
	CONFIRM			;CM12
	TRNN B,10		;CM12 Giving connect access to world?
	 JRST DPRO2		;CM12 No, check for other stupid things
	PROMPT <[Do you really want to allow all users on the system to delete and modify your files?]>	;CM12 Warn him
	CALL EXTCNF		;CM12 Get extra confirmation
	 RET			;CM12 User said to punt
DPRO2:	TRC B,770000		;CM12 Invert
	TRNN B,770000		;CM12 Will he keep access?
	JRST DPROOK		;CM12 Yes
	PROMPT <[Do you really want to protect your directory so that you will not have full access to your own directory?]> ;CM12 Warn him
	CALL EXTCNF		;CM12 Get extra confirmation
	 RET			;CM12 User said to punt
DPROOK:				;CM12
	LDF A,CD%DPT		;BIT FOR CHANGING DIRECTORY PROTECTION
	CALLRET DWRKNC		;CM12 DO THE WORK AND RETURN

;CM12 Routine to request extra confirmation when the user is probably
;doing something s/he doesn't want to do.
;
;Call:
;	PROMPT <Something appropriate>
;	CALL EXTCNF
;	 punt because user checkened out
;	proceed
;Clobbers:
;	No AC's
;
EXTCNF:	SAVEAC <A,B,C,P3>	;CM12
	KEYWD $YESNO		;CM12
	 T YES,,1		;CM12
	 CMERRX <YES or NO required> ;CM12
	HRRZS P3		;CM12 Isolate response
	CONFIRM			;CM12 Request confirmation in any case
	SKIPN P3		;CM12 Check user response
	RET			;CM12 No
	RETSKP			;CM12 Yes

$YESNO:	TABLE			;CM12
	T NO,,0			;CM12
	T YES,,1		;CM12
	TEND			;CM12

CC,<
;CM9 *** Entire page ***

.DUSEB:	CALL INPDIR		;Get directory name
	NOISE <FOR USER>
	MOVEI B,[FLDDB. .CMUSR,CM%PO]
	CALL FLDSKP		;Read user name with "parse-only"
	 CMERRX			;No--give error
	CALL BUFFF		;Copy the name
	CONFIRM
	CALL HSHUSR		;Go hash the userid
	PUSH P,A		;Save for search later
	CALL GETPAS		;Get password
	MOVX A,RC%EMO		;Get number of object directory
	MOVE B,DIRP		;Read in already
	SETZ C,
	RCDIR%
	MOVE A,C
	MOVEI C,SEBLK
	CALL GETDIR		;Fill in with existing groups
	 ERROR <Could not get directory information>
	POP P,A
	HRRZ A,A		;Leave only 18 bits of user number
	MOVEI B,SEBLK
	MOVE B,.CDDGP(B)	;Point to directory group buffer
	MOVN C,(B)		;Check list of groups I am in now
	AOJGE C,USEBY2		;None yet
	HRLZ C,C
	HRRI C,1(B)
USEBY1:	CAMN A,(C)		;Here?
	JRST USEBY3		;Yes
	AOBJN C,USEBY1
USEBY2:	SKIPE SETNOF		;Is he refusing use?
	ERROR <Not used by that user>
	AOS C,(B)		;One more group
	CAILE C,DGBUFL		;Too many?
	ERROR <Directory is in too many groups>
	ADDI C,-1(B)
	MOVEM A,(C)
	JRST USEBY4
USEBY3:	SKIPL SETNOF		;Is he refusing use?
	ERROR <Already permitted to that user>
	HRRI A,(C)
	HRLI A,1(C)
	SOS C,(B)
	ADDI C,-1(B)
	BLT A,(C)
	SETZM 1(C)
USEBY4:	MOVX A,CD%DGP		;Just change directory groups
	CALL CREDIR		;Do the work
	 CALL CJERRE
	RET

;Routine to hash userid - called with pointer to username in A, returns
;hashed userid in A. Preserves all AC's (except A)

HSHUSR::SAVEAC <B,C,D>		;Don't trash any of these
	MOVE C,A		;Remember pointer to start of name
	SETZ B,			;Count bytes in the name
	DO.
	  ILDB D,A
	  SKIPE D		;Stop counting when a null is found
	  AOJA B,TOP.
	ENDDO.
	CAIE B,4		;Name must have exactly four characters
	 ERROR <User name must be four characters long>
	ILDB B,C		;Hash man number
	TRZ B,040		;Upper case
	MOVEI A,-101(B)		;into permanent group number
	ILDB B,C	
	TRZ B,040	
	IMULI A,^D27	
	ADDI A,-100(B)	
	ILDB B,C	
	CAILE B,"9"	
	JRST CERR	
	IMULI A,^D10	
	ADDI A,-60(B)	
	ILDB B,C	
	CAILE B,"Z"	
	TRZ B,040	
	CAIL B,"A"	
	SUBI B,7	
	IMULI A,^D36	
	ADDI A,-60(B)
	RET
>;CC

;ROUTINE TO CHANGE A SINGLE MODE BIT IN A DIRECTORY

DMODE:	MOVEM A,WBITS		;SAVE THE DESIRED MODE BIT
	MOVX A,RC%EMO		;TAKE AS IS ONLY
	MOVE B,DIRP		;DIRECTORY # IN QUESTION
	SETZ C,
	RCDIR			;GET THE DIRECTORY #
	MOVEI A,.CDMOD		;READ SOME OF THE DIRECTORY
	MOVEM A,.CDLEN+SEBLK
	MOVE A,C		;SET UP DIRECTORY NUMBER
	MOVEI B,SEBLK		;READ WHAT THINGS ARE NOW
	SETZ C,			;DON'T WANT TO KNOW THE PASSWORD
	GTDIR
	 ERJMP [ETYPE <No access to directory>
		RET]
	MOVE A,WBITS		;GET THE BIT WE WANTED TO CHANGE
	IORM A,.CDMOD+SEBLK	;ASSUME WE WANTED TO SET IT
	SKIPE SETNOF		;DID COMMAND HAVE A "NO" IN IT?
	ANDCAM A,.CDMOD+SEBLK	;YES, CLEAR THE BIT
	LDF A,CD%MOD		;TELL DWORK WHAT TO CHANGE
	CALLRET DWORK		;GO DO IT

;THIS ROUTINE INPUTS THE DIRECTORY NAME FOR "SET DIRECTORY"
;COMMANDS.

INPDIR:	NOISE <OF DIRECTORY>
;CM224	TLO Z,F1		;DON'T DEFAULT THE DIRECTORY NAME
	CALL DIRNAM		;READ THE DIRECTORY NAME
	 ERROR <Invalid directory name or syntax>
	CALL BUFFF		;GET POINTER TO DIRECTORY NAME STRING
	MOVEM A,DIRP		;REMEMBER POINTER TO IT
	RET

;"SET TAPE"

.TAPE::	KEYWD $TAPE
	 0
	 JRST CERR
	JRST (P3)

$TAPE:	TABLE
	T DENSITY,,TDENSI	;"SET TAPE DENSITY (TO)"
	T FORMAT,,TFRMAT	;"SET TAPE FORMAT (TO)"
	T PARITY,,TPARIT	;"SET TAPE PARITY (TO)"
	T RECORD-LENGTH,,TRECLN	;"SET TAPE RECORD-LENGTH (TO)"
	TEND

TDENSI:	NOISE <TO>
	KEYWD $TDENS
	 T SYSTEM-DEFAULT,,.SJDDN
	 JRST CERR
	NOISE <BPI>
	CONFIRM
	MOVEI B,.SJDEN		;SET DENSITY
SETJOB:	MOVEI C,(P3)		;GET VALUE
SETTAP:	MOVNI A,1		;SET FOR OUR JOB
	SETJB
	 ERCAL CJERRE
	RET

;THIS TABLE MUST BE IN ALPHABETIC ORDER

$TDENS::TABLE
	T 1600,,.SJD16
	T 200,,.SJDN2
	T 556,,.SJDN5
	T 6250,,.SJD62
	T 800,,.SJDN8
	T SYSTEM-DEFAULT,,.SJDDN
	TEND

TFRMAT:	NOISE <TO>
	KEYWD $TFRMT
	 T SYSTEM-DEFAULT,,.SJDDM
	 JRST CERR
	CONFIRM
	MOVEI B,.SJDM
	JRST SETJOB

$TFRMT:	TABLE
	T ANSI-ASCII,,.SJDMA
	T CORE-DUMP,,.SJDMC
	T HIGH-DENSITY,,.SJDMH
	T INDUSTRY-COMPATIBLE,,.SJDM8
	T SIXBIT,,.SJDM6
	T SYSTEM-DEFAULT,,.SJDDM
	TEND

TPARIT:	NOISE <TO>
	KEYWD $TPARI
	 T ODD,,.SJPRO
	 JRST CERR
	CONFIRM
	MOVEI B,.SJPAR		;SET PARITY
	JRST SETJOB

$TPARI:	TABLE
	T EVEN,,.SJPRE
	T ODD,,.SJPRO
	TEND

TRECLN:	NOISE <TO>
	DECX <Number of bytes in decimal>
	 CMERRX
	NOISE <BYTES>
	CONFIRM
	TLNE B,777777
	 ERROR<Number of bytes must be 0-262143>
	MOVE C,B
	MOVEI B,.SJRS
	JRST SETTAP

;"SET SPOOLED-OUTPUT"

SPLSET::NOISE <TO>
	KEYWD $SPSET
	 0
	 JRST CERR
	MOVEI B,.SJDFS
	JRST SETJOB

$SPSET:	TABLE
	T DEFERRED,ONEWRD,.SJSPD
	T IMMEDIATE,ONEWRD,.SJSPI
	TEND

;SET [NO] RETRIEVAL-WAIT (FOR OFFLINE FILES)

.OFL::	NOISE	<For offline files>
	SETO A,			;OUR OWN JOB
	MOVEI B,.SJDFR
	MOVEI C,.SJRFA		;NO RETRIEVAL-WAIT
	SKIPN SETNOF
	 MOVEI C,.SJRWA		;YES, RETRIEVAL-WAIT
	SETJB
	CALLRET CONF		;CONFIRM AND RETURN

;SET SESSION-REMARK (TO) TEXT

SETSRM::NOISE (TO)
	CALL GSR		;GET SESSION REMARK
	CALL SSR		;TELL SYSTEM THE REMARK
	CALLRET CONF		;CONFIRM AND RETURN

;ROUTINE TO GET SESSION REMARK
;RETURNS POINTER IN A

GSR::	LINEX <Session remark, one line of text>
	 CMERRX
	CALLRET BUFFF		;ISOLATE SESSION REMARK AND RETURN

;ROUTINE TO SET SESSION REMARK.  GIVE IT POINTER IN A.

SSR::	MOVE C,A		;PUT POINTER TO REMARK IN C
	MOVEI B,.SJSRM		;FUNCTION FOR SETTING SESSION REMARK
	MOVNI A,1		;SPECIFY CURRENT JOB
	SETJB			;SET REMARK
	 ERJMP .+2		;COULDN'T SET SESSION REMARK
	RET			;DONE
	ETYPE <%%Couldn't set session remark
>
	RET

;"SET CARD-READER-INPUT-SET"

CRDSET::NOISE <TO>
	WORDX <Name of input set>
	 CMERRX
	CALL BUFFF		;BUFFER NAME
	MOVEM A,CDRSTR		;SET A CDR INPUT SET NAME
	NOISE <STARTING WITH DECK NUMBER>
	DEFX <1>		;DEFAULT TO DECK #1
	DECX <Deck number in decimal>
	 CMERRX
	SKIPN B
	ERROR <Zero is illegal for deck number>
	MOVEM B,CDRDCK
	CONFIRM
	HRLOI A,.DVDES+.DVCDR	;SET FOR ALL CDR'S
	MOVEM A,CDRDEV
	MOVE A,[3,,.SPLDI]
	MOVEI B,CDRDEV		;ARGUMENT BLOCK
	SPOOL
	 CALL CJERR
	RET

$ESET:	TABLE
	T ARPANET,,.NETWK		;^ESET ARPANET
	T DATE-AND-TIME,,SETTAD		;^ESET SYSTEM DATE-AND-TIME
CS,<	T FRONT-END,,SETFE >		;CM313 ^ESET FRONT-END n UP-or-DOWN
	T LOGINS-ALLOWED,,TTYLOG	;^ESET LOGINS-ALLOWED
CC,<	T MICOM-DEBUGGING,,SETMCM >	;C390 ^ESET MICOM-DEBUGGING
	T NO,NOLG,ESETNO		;^ESET NO
	T OPERATOR-IN-ATTENDANCE,ONEWRD,SETOPR	;^ESET OPERATOR
	T PRIVATE-QUASAR,,.GDEBG	;^ESET PRIVATE-QUASAR
	T RUN-TIME-GUARANTEE,,.JRUNG	;^ESET JOB RUN-TIME
	T TERMINAL,,ETERMI		;^ESET TERMINAL (NUMBER)
	TEND

ESETNO:	SETOM SETNOF		;FLAG NO TYPED
	KEYWD $ESETN
	 0
	 JRST CERR
	TXNE P3,NOLG		;NEED TO BE LOGGED IN?
	SKIPE CUSRNO		;YES, ARE WE?
	CAIA			;OK
	ERROR <LOGIN please>
	JRST (P3)		;DISPATCH TO COMMAND

$ESETN:	TABLE
	T LOGINS-ALLOWED,,TTYLOG	;^ESET NO LOGINS-ALLOWED
CC,<	T MICOM-DEBUGING,,SETMCM >	;C390 ^ESET NO MICOM-DEBUGGING
	T OPERATOR-IN-ATTENDANCE,ONEWRD,SETOPR	;^ESET NO OPERATOR
	T PRIVATE-QUASAR,,.GDEBG	;^ESET NO PRIVATE-QUASAR
	T RUN-TIME-GUARANTEE,,.JRUNG	;^ESET NO RUN-TIME
	TEND

;"^ESET TERMINAL (NUMBER)"

ETERMI:	STKVAR <ETNM>
	NOISE <NUMBER>
	OCTX <Octal terminal number>
	 CMERRX
	MOVEM B,ETNM
	MOVE A,CSBUFP		;GET SOME SCRATCH SPACE
	MOVEI C,0		;END STRING OUTPUT ON NULL
	HRROI B,[ASCIZ /TTY/]	;MAKE DEVICE NAME
	SOUT
	MOVE B,ETNM		;GET NUMBER HE TYPED
	MOVEI C,8		;OCTAL
	NOUT			;MAKE "TTYnnn"
	 ERCAL JERRE		;SHOULD NEVER FAIL
	MOVE A,CSBUFP		;POINT AT THE NAME
	STDEV			;GET DESIGNATOR FOR IT
	 ERCAL CJERRE		;FAILED, TELL USER THAT TERMINAL DOESN'T EXIST
	MOVEM B,ETNM		;REMEMBER DESIGNATOR
	KEYWD $ETERM
	 T SPEED,,SPEEDA
	 JRST CERR
	MOVE A,ETNM		;GET TERMINAL DESIGNATOR
	JRST (P3)

$ETERM:	TABLE
	T SPEED,,SPEEDA
	TEND

;"^ESET [NO] SYSTEM LOGINS-ALLOWED"

TTYLOG:	NOISE <ON>
	KEYWD $LGTTY
	 T ANY-TERMINAL,ONEWRD,.ANTTY
	 JRST CERR
	JRST (P3)

$LGTTY:	TABLE
	T ANY-TERMINAL,ONEWRD,.ANTTY
	T ARPANET-TERMINALS,ONEWRD,.NVTTY
	T CONSOLE-TERMINAL,ONEWRD,.CNTTY
	T DECNET-TERMINALS,ONEWRD,.MCTTY ;CS112 (temporary)
	T LOCAL-TERMINALS,ONEWRD,.LCTTY
	T PSEUDO-TERMINALS,ONEWRD,.PSTTY
	T REMOTE-TERMINALS,ONEWRD,.RMTTY
	TEND

;DO SET FOR ALL TERMINALS

.ANTTY:	SKIPN SETNOF		;CS133 Don't do console if setting no logins
	CALL .CNTTY
	CALL .MCTTY		;CS112
	CALL .LCTTY
	CALL .NVTTY
	CALL .PSTTY
;	CALLRET .RMTTY

.RMTTY:	MOVEI A,.SFRMT
DOSTTY:	SKIPE SETNOF		;NO?
	TDZA B,B		;DISALLOW LOGINS
	MOVEI B,1		;ALLOW LOGINS
	SMON
	 ERCAL CJERRE
	RET

.CNTTY:	MOVEI A,.SFCTY
	JRST DOSTTY

.MCTTY:	MOVEI A,.SFMCB		;CS112
	JRST DOSTTY		;CS112

.LCTTY:	MOVEI A,.SFLCL
	JRST DOSTTY

.NVTTY:	MOVEI A,.SFNVT
	JRST DOSTTY

.PSTTY:	MOVEI A,.SFPTY
	JRST DOSTTY


;"^ESET ARPANET" ON OR OFF

.NETWK:	KEYWD $NETOO		;OFF OR ON
	 T ON,,NETON
	 JRST CERR
	CONFIRM
	JRST (P3)

$NETOO:	TABLE
	T OFF,,NETFF
	T ON,,NETON
	TEND

NETFF:	TDZA B,B
NETON:	MOVEI B,1
	MOVEI A,.SFNTN		;SET ARPANET OFF OR ON
	SMON
	 ERCAL CJERRE		;SHOULD SUCCEED EVEN IN NON-NET SYSTEMS
	RET

;"^ESET SYSTEM OPERATOR-IN-ATTENDANCE"

SETOPR:	MOVEI A,.SFOPR
	SKIPE SETNOF
	TDZA B,B		;NO OPERATOR
	MOVEI B,1		;OPERATOR IN ATTENDANCE
	SMON
	 ERCAL CJERRE
	RET

;C390	^ESET MICOM-DEBUGGING ...

CC,<
SETMCM:	CONFIRM
	SKIPE SETNOF		;C390 NO?
	TDZA B,B		;C390 NO
	MOVEI B,1		;C390 YES
	MOVEI A,.SFMCD		;C390 Micom debugging
	SMON			;C390
	 ERCAL CJERRE		;C390
	RET			;C390
   >;CC

;CM313 ^ESET FRONT-END ....

CS,<
SETFE:	STKVAR <FENUM>		;Front end number
	NOISE <Number>
	DECX <CS front end number>
	  CMERRX
	HRRZM B,FENUM		;Save the number for later
	KEYWD $SETFE		;Parse UP or DOWN
	  0			;No default
	  JRST CERR
	CONFIRM			;YES
	JRST (P3)		;Dispatch

$SETFE:	TABLE
	T DOWN,,.FEDWN
	T UP,,.FEUP
	TEND

.FEUP:	MOVX A,SF%CSC
	IORM A,FENUM		;Set the flag for the SMON%
.FEDWN:	MOVX A,.SFCSC		;Get SET CS FE function
	MOVE B,FENUM		;Get FE number (and perhaps flag)
	SMON%			;Set it
	  ERJMP SETFE2
	JRST CMDIN4		;Return

SETFE2:	ERROR <No such CS front end> ;The only possible error so far

  >;CS


;^ESET PRIVATE-QUASAR ON OR OFF
.GDEBG:	NOISE <for private GALAXY>
	CONFIRM
	SKIPN SETNOF		;ON?
	CALL GQSRPD		;YES - GET PRIVATE QUASAR PID
	SKIPE	SETNOF		;OFF?
	SETZM	QSRPID		;YES - CLEAR QUASAR'S PID
	RET			;AND RETURN

.JRUNG:	NOISE <FOR JOB>
	DECX <Job number in decimal>
	 CMERRX
	PUSH P,B		;SAVE JOB NUMBER
	SKIPE SETNOF		;NO?
	JRST	[SETZ B,	;YES, 0 PERCENTAGE
		JRST .JRUN1]
	NOISE <TO>
	DECX <Percentage>
	 CMERRX
	NOISE <PERCENT>
	CAIL B,1
	CAILE B,^D100
	ERROR <Run time guarantee percentage must be from 1-100>
.JRUN1:	CONFIRM
	HRLZ B,B		;MAKE LEFT HALF NUMBER
	POP P,A			;GET JOB NUMBER BACK
	SJPRI			;SET IT
	 ERJMP CJERRE
	RET

;SET TIME-LIMIT (TO) N

.STMLM::NOISE <TO>
	DECX <Number of seconds>
	 CMERRX
	NOISE <SECONDS>
	CONFIRM
;**;[728]	Change 1 line at .STMLM:+5L	KR	29-APR-82
	JUMPE B,[ERROR <Use "SET TIME-LIMIT 0" to cause time-out>]	;[728]
	IMULI B,^D1000		;MAKE IT MILLISECONDS
	PUSH P,B
	MOVEI A,.FHJOB
	RUNTM			;GET TIME IN MILLISECONDS
	POP P,B
	ADD B,A			;ADD TO GET FINAL RUNTIME
;**;[728]	Insert 2 lines at .STMLM:+13L	KR	29-APR-82
	CAIGE B,^D1000		;[728]IS IT LESS THAN 1 SECOND?
	MOVEI B,^D1000		;[728]OK, MAKE IT 1 SECOND INSTEAD.
	MOVE A,[.FHJOB,,.TIMRT]	;SET TIME LIMIT CODE
	MOVEI C,4		;CHANNEL
	TIMER
	 CALL CJERR
	RET

.NOTIM::CONFIRM
	IFNBATCH NOTIM1
	MOVE A,[.FHJOB,,.TIMRT]	;SET TIME LIMIT CODE
	SETZB B,C		;NO TIME, (HENCE NO CHANNEL)
	TIMER
	 CALL CJERR
	RET

NOTIM1:	ERROR <Attempt to clear time limit during BATCH process>

;^ESET SYSTEM TIME-AND-DATE (TO)

SETTAD::NOISE <TO>
	DTX <Date and time>
	 CMERRX
	CONFIRM			;CHECK TERMINATOR, INPUT CR IF NECESSARY
	MOVE A,B		;PUT TIME AND DATE INTO AC1
	STAD			;SET TIME AND DATE
	 CALL CJERR
	RET

ECEASE::NOISE <TIMESHARING AT>
	DTX <Date and time or null to cancel shutdown>
	 JRST CEASE3
	JRST DT1		;GOT A TIME AND DATE
DT1:	PUSH P,B
	NOISE <RESUMING AT>
;;	DTX <Date and time of restart, or UNKNOWN if not known> ;CM346
	MOVEI B,[FLDDB. .CMKEY,CM%SDH,$CEASE,<Date and time of restart
  or "+" to enter amount of time from now
  or day of the week or TODAY
  or UNKNOWN if it is unknown when the system will be back up>] ;CM346
	CALL FLDSKP		;CM346 Try to parse UNKNOWN
	 JRST CEASE5		;CM346 Failed, try date/time
	SETZ B,			;CM346 Unknown
CEASE1:	CONFIRM
	SKIPN (P)
	JRST CEASE2		;SKIP CHECK IF CANCELING
	GTAD
	CAML A,(P)
	 JRST [ ADDI A,^D60	;CM236 If downtime already passed, add fudge
		CAML A,(P)	;CM236  factor (approx 20 seconds) and retry
		ERROR <Down time has already passed> ;CM236 Real user error
		MOVEM A,(P)	;CM236 User typed "^ECease +0"
		JRST .+1]	;CM236  so allow it
	JUMPE B,CEASE2
	CAMGE B,(P)
	ERROR <Timesharing will resume before it ends!>
CEASE2:	POP P,A
	HSYS
	 JRST CJERR
	RET

CEASE3:	PUSH P,[0]
CEASE4:	SETZ B,
	JRST CEASE1

CEASE5:	DTX			;CM346 Parse date/time
	 JRST CEASE6		;CM346 Not specified, check if legal
	JRST CEASE1		;CM346 Date/time ok.  Go for it

CEASE6:	MOVE A,[1,,.DBUGS]	;CM346 Get DBUGSW
	GETAB%			;CM346 ...
	 ERJMP .+1		;CM346
	SKIPN A			;CM346 Standalone?
	 ERROR <Time at which system will be up was not specified> ;CM346 No
	JRST CEASE4		;CM346 Yes, it's ok

$CEASE:	TABLE			;CM346
	T UN,,0,CM%NOR		;CM346 Make oper type at least 3 letters
	T UNKNOWN,,0		;CM346
	TEND			;CM346

;SET TYPEOUT CONTROLS HOW MEMORY ADDRESSES AND CONTENTS ARE DISPLAYED.

.TYPEO::KEYWD TYTAB
	 T MODE
	 CMERRX
	CALLRET (P3)		;EXIT THROUGH SPECIFIED KEYWORD ROUTINE

TYTAB:	TABLE
	T MODE
;	T RADIX		;ETC.
	TEND

.MODE:	NOISE (to)
	KEYWD MODTAB
	 0
	 CMERRX
	CALLRET (P3)

MODTAB:	TABLE
;	T ASCII
	T NUMERIC,ONEWRD
	T SYMBOLIC,ONEWRD
	TEND

.NUMER:	SETZM SYMF		;SAY NOT SYMBOLIC
	RET

.SYMBO:	SETOM SYMF		;SAY SYMBOLIC
	RET

END
