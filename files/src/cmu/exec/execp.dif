1: NIC
2: CMU
--------------

LINE 7, PAGE 3
1)	;COPYRIGHT (C) 1980,1981,1982,1983 BY DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
1)	
LINE 7, PAGE 2
2)	;COPYRIGHT (C) 1980,1981,1982 BY DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
2)	


LINE 15, PAGE 3
1)	
1)	DEFINE CONSTG <			;;COMMON STORAGE FOR CONTINUE, START COMMANDS
1)		TRVAR <STADR,UFORK,FTW,TMPJFN,SJBUFP>   
1)	IFN STANSW,<
1)		PUSH P,JBUFP		;REMEMBER JFN BLOCK POINTER IN CASE WE NEED
1)		POP P,SJBUFP		;TO FORGET ABOUT ANY JFN'S WE MAKE
1)	>;IFN STANSW
1)		SETZM TMPJFN		;;INITIALLY NO JFN
1)	   >
1)	
1)	;BITS AND FIELDS DEFINED IN OPLIST:
LINE 15, PAGE 2
2)	DEFINE CONSTG <
2)			TRVAR <UFORK,FTW,TMPJFN,SJBUFP>	;;COMMON STORAGE FOR CONTINUE, START COMMANDS
2)		SETZM TMPJFN		;;INITIALLY NO JFN
2)	   >
2)	;BITS AND FIELDS DEFINED IN OPLIST:


; SRC:<6-EXEC>EXECP.MAC.16 & EXECP.MAC.1 25-Jul-85 2311	PAGE 8



LINE 8, PAGE 4
1)	IFN STANSW,<
1)			TMNE FK%INV,SLFTAB(A) ;CM156 Current fork was INVOKE'd?
1)			 ERROR <No program>   ;CM156 Don't let him do it
1)	>;IFN STANSW
1)			JRST .RESE3]
1)		MOVX A,FK%KPT!FK%BKG!FK%INT
1)		MOVSI Q2,-NFRKS		;CLEAR ENTIRE TABLE
LINE 8, PAGE 3
2)			TMNE FK%INV,SLFTAB(A) ;CM156 Current fork was INVOKE'd?
2)			 ERROR <No program>   ;CM156 Don't let him do it
2)			JRST .RESE3]
2)	CS,<	MOVX A,FK%KPT!FK%BKG!FK%INT!FK%UND >;EM100
2)	CC,<	MOVX A,FK%KPT!FK%BKG!FK%INT>
2)		MOVSI Q2,-NFRKS		;CLEAR ENTIRE TABLE


LINE 24, PAGE 4
1)	IFN STANSW,<
1)		TMNE FK%INV,SLFTAB(A)	;CM156 Current fork was INVOKE'd?
1)		 JRST RESET2		;CM156 Yes, pretend no such fork
1)	>;IFN STANSW
1)		HLRZ B,@SLFTAB(A)	;GET HANDLE
LINE 23, PAGE 3
2)		TMNE FK%INV,SLFTAB(A)	;CM156 Current fork was INVOKE'd?
2)		 JRST RESET2		;CM156 Yes, pretend no such fork
2)		HLRZ B,@SLFTAB(A)	;GET HANDLE


LINE 34, PAGE 4
1)	IFE STANSW,<
1)	RESET2:	
1)		CALLRET ERESET		;KILL OFF FORK AND RETURN
1)	>;IFE STANSW
1)	IFE NICSW,<			;[NIC1045]
1)	IFN STANSW,<
1)	RESET2:	CALL ERESET		;KILL OFF FORK
1)	.RESE5:	SKIPE RNFORK		;SELECTING NEW FORK ON RESET?
1)		 SKIPLE FORK		;AND FORK WE KILLED WAS CURRENT?
1)		  RET			;NO TO ONE OF ABOVE, JUST RETURN
1)		CALLRET NXTFRK		;ELSE SEE IF THERE IS ONE TO STEP TO
1)	>;IFN STANSW
1)	>;IFE NICSW
1)	IFN NICSW,<			;[NIC1045]
1)	RESET2:	CALL ERESET		;[NIC1045] KILL OFF FORK
1)		CALLRET NXTFRK		;[NIC1045] SEE IF THERE IS ANOTHER
1)	>;IFN NICSW
1)	
LINE 31, PAGE 3

; SRC:<6-EXEC>EXECP.MAC.16 & EXECP.MAC.1 25-Jul-85 2311	PAGE 9


2)	RESET2:	CALL ERESET		;CM224 KILL OFF FORK AND RETURN
2)		CALLRET NXTFRK		;CM224 Give user a current fork if possible
2)	


LINE 59, PAGE 4
1)	IFE STANSW,<
1)		CALLRET PION		;TURN THE WORLD BACK ON AND RETURN
1)	>;IFE STANSW
1)	IFE NICSW,<			;[NIC1045]
1)	IFN STANSW,<
1)		CALL PION		;TURN THE WORLD BACK ON
1)		JRST .RESE5		;TRY NEXT FORK AND RETURN
1)	>;IFN STANSW
1)	>;IFE NICSW
1)	IFN NICSW,<			;[NIC1045]
1)		CALL PION		;[NIC1045]
1)		CALL NXTFRK		;[NIC1045]
1)		RET			;[NIC1045]
1)	>;IFN NICSW
1)	
LINE 41, PAGE 3
2)		CALL PION		;CM224 TURN THE WORLD BACK ON
2)		CALLRET NXTFRK		;CM224 Give user a current fork if possible
2)	


LINE 9, PAGE 5
1)	IFE NICSW,<
1)	ERESE1: MOVX B,FK%KPT!FK%BKG	;KEPT OR BACKGROUND TEST
1)	>;IFE NICSW
1)	IFN NICSW,<
1)	ERESE1:	MOVX B,FK%KPT!FK%BKG!FK%INV!FK%UND
1)					;[NIC1002] CM156 KEPT OR BACKGROUND OR INVOKED
1)					;[NIC1002] OR DEBUGGER
1)	>;IFN NICSW
1)		SKIPE CCKEEP		;CHECK INTERRUPTED FORKS ALSO?
LINE 9, PAGE 4
2)	ERESE1: MOVX B,FK%KPT!FK%BKG!FK%INV ;CM156 KEPT OR BACKGROUND or INVOKE'd TEST
2)		SKIPE CCKEEP		;CHECK INTERRUPTED FORKS ALSO?


LINE 60, PAGE 5
1)	KEFRK2:	CAIE A,.FHSLF		;THIS US?
1)		 KFORK			;NOPE - KILL OFF INFERIOR
1)	IFE NICSW,<			;[NIC1002] NIC IDDT
1)		  ERCAL [TYPE <%Process disappeared%_>
1)			 RET]		;RETURN NOW
1)	>;IFE NICSW
1)	IFN NICSW,<			;[NIC1002]
1)		  ERJMP [RFRKH		;[NIC1002] TRY TO RELEASE IT THEN

; SRC:<6-EXEC>EXECP.MAC.16 & EXECP.MAC.1 25-Jul-85 2311	PAGE 10


1)			  ETYPE <%%Couldn't kill fork%_> ;[NIC1002] FAILED AGAIN
1)			 JRST .+1]	;[NIC1002]
1)	>;IFN NICSW
1)		CAMN A,FORK		;CURRENT FORK
LINE 53, PAGE 4
2)	KEFRK2:	CALL RELIO		;CM224 Close primary JFN's if necessary
2)		CAIE A,.FHSLF		;THIS US?
2)		 KFORK			;NOPE - KILL OFF INFERIOR
2)		  ERCAL [TYPE <%Process disappeared
2)	>
2)			 RET]		;RETURN NOW
2)		CAMN A,FORK		;CURRENT FORK


LINE 77, PAGE 5
1)	IFE NICSW,<			;[NIC1002]
1)		CAMN A,IDFORK		;IDDT FORK
1)		 SETOM IDFORK
1)	>;IFE NICSW
1)		CAMN A,MICFRK		;MIC HERE
1)		 SETOM MICFRK
1)	IFN STANSW,<
1)		MOVE B,[-2]		;CM156 Special uninitialized value
1)		CAMN A,PCFORK		;CM156 Saved copy of FORK from INVOKE?
1)		 MOVEM B,PCFORK		;CM156 Yep, we don't want to restore
1)					;  this value to FORK later then
1)		CAMN A,PCRNFK		;CM156 Saved copy of RUNFK from INVOKE?
1)		 MOVEM B,PCRNFK		;CM156 Yep, we don't want to restore this value
1)	>;IFN STANSW
1)		RET
LINE 65, PAGE 4
2)	;;	CAMN A,IDFORK		;EM100 IDDT FORK
2)	;;	 SETOM IDFORK		;EM100
2)	CS,<	CAMN A,UDFORK		;EM85 fork under debugger
2)		 SETOM UDFORK>		;EM85
2)	MIC,<
2)		CAMN A,MICFRK		;MIC HERE
2)		 SETOM MICFRK
2)	>
2)		MOVE B,[-2]		;CM156 Special uninitialized value
2)		CAMN A,PCFORK		;CM156 Saved copy of FORK from INVOKE?
2)		 MOVEM B,PCFORK		;CM156 Yep, we don't want to restore this value
2)					; to FORK later then
2)		CAMN A,PCRNFK		;CM156 Saved copy of RUNFK from INVOKE?
2)		 MOVEM B,PCRNFK		;CM156 Yep, we don't want to restore this value
2)					; to RUNFK later then
2)		RET


; SRC:<6-EXEC>EXECP.MAC.16 & EXECP.MAC.1 25-Jul-85 2311	PAGE 11



LINE 4, PAGE 6
1)	NXTFRK:	MOVEI A,NFRKS-1		;LOOK THRU TABLE
1)	NXTFR1:	SKIPN FRKTAB(A)		;EXISTS?
1)		 JRST NXTFR2		;NO - TRY NEXT
1)	IFN STANSW,<
1)		MOVE B,FRKTAB(A)	;CM156 Get fork flags
1)		TXNE B,FK%INV		;CM156 INVOKE'd fork?
1)		 JRST NXTFR2		;CM156 Yes, ignore it
1)	>;IFN STANSW
1)		HLRZ B,@FRKTAB(A)	;GET OWNER
LINE 4, PAGE 5
2)	NXTFRK::			;CU107 needed by KMIC
2)		MOVEI A,NFRKS-1		;LOOK THRU TABLE
2)	NXTFR1:	SKIPN FRKTAB(A)		;EXISTS?
2)		 JRST NXTFR2		;NO - TRY NEXT
2)		MOVE B,FRKTAB(A)	;CM156 Get fork flags
2)		TXNE B,FK%INV		;CM156 INVOKE'd fork?
2)		 JRST NXTFR2		;CM156 Yes, ignore it
2)		HLRZ B,@FRKTAB(A)	;GET OWNER


LINE 23, PAGE 6
1)		HRRO B,.FKNAM(B)	;POINT TO NAME STRING
LINE 22, PAGE 5
2)		HRRZ C,(P)		;EM47 Kluge... Find out caller
2)		CAIN C,FRKKI1		;EM47 Called from FRKKIL?
2)		 RET			;EM47 Then don't print the fork name
2)		HRRO B,.FKNAM(B)	;POINT TO NAME STRING


LINE 129, PAGE 6
1)		MOVE Q1,SLFTAB(B)	;REMEMBER ADDRESS OF FORK STATE BLOCK
1)		HLRZ B,(A)		;GET ADDRESS OF PROGRAM NAME
1)		MOVEM B,.FKNAM(Q1)	;REMEMBER NAME OF THIS PROGRAM
1)	IFN NICSW,<			;[NIC1033]
1)		SKIPE AUTO		;[NIC1033] WAS IT AN INSTANCE FILE AUTOKEEP
1)		 SETZM AUTO		;[NIC1033] YES, SO RESET IT FOR NEXT GUY
1)	>;IFN NICSW
1)	ADDNM5:	MOVE A,AFORK		;GET HANDLE OF FORK THAT MAY NEED KEEPING
1)		LOAD D,FKFLAG,(C)	;GET FLAGS ABOUT THIS NAME
1)		MOVE B,SLFTAB(A)	;SEE IF FORK IS ALREADY KEPT
1)	IFE STANSW,<
1)		TXNN B,FK%KPT		;IF SO, CALL ANNKEP TO PUT NAME IN KEPNMS
1)		TXNE D,FN%KEP		;ARE WE SUPPOSED TO KEEP THIS GUY?
1)		CALL ANNKEP		;YES, DO IT
1)	>;IFE STANSW
1)	IFN STANSW,<
1)		IFXE. B,FK%KPT		;ALREADY KEPT?
1)		  TXNE D,FN%KEP		;NO, SUPPOSED TO KEEP IN TABLE?

; SRC:<6-EXEC>EXECP.MAC.16 & EXECP.MAC.1 25-Jul-85 2311	PAGE 12


1)		   CALL ANNKEP		;DO IT.
1)		  IFXN. D,FN%KNC	;KEEP BUT NOT IN TABLE?
1)		    TXO B,FK%KPT	;KEEP IT
1)		    MOVEM B,SLFTAB(A)
1)		    HRRO B,.FKNAM(Q1)	;MAKE POINTER TO NAME
1)		    ETYPE <[Keeping %2M]%_>
1)		  ENDIF.
1)		ELSE.
1)		  CALL ANNKEP		;KEPT ALREADY BUT ADD NAME JUST IN CASE
1)		ENDIF.
1)	>;IFN STANSW
1)		MOVE B,CSBUFP		;WE NOW HAVE UNIQUE NAME, ANNOUNCE NEW NAME
LINE 131, PAGE 5
2)		HLRZ B,(A)		;GET ADDRESS OF PROGRAM NAME
2)		MOVEM B,.FKNAM(Q1)	;REMEMBER NAME OF THIS PROGRAM
2)	ADDNM5:	MOVE A,AFORK		;GET HANDLE OF FORK THAT MAY NEED KEEPING
2)		LOAD D,FKFLAG,(C)	;GET FLAGS ABOUT THIS NAME
2)		MOVE B,SLFTAB(A)	;SEE IF FORK IS ALREADY KEPT
2)		TXNN B,FK%KPT		;IF SO, CALL ANNKEP TO PUT NAME IN KEPNMS
2)		TXNE D,FN%KEP		;ARE WE SUPPOSED TO KEEP THIS GUY?
2)		CALL ANNKEP		;YES, DO IT
2)		MOVE B,CSBUFP		;WE NOW HAVE UNIQUE NAME, ANNOUNCE NEW NAME


LINE 176, PAGE 6
1)	IFN NICSW,<			;[NIC1033]
1)		SKIPE AUTO		;[NIC1033] WAS AUTOKEEP SET?
1)		 JRST [ SETZM AUTO	;[NIC1033] RESET FLAG. LUCKILY ^C DISABLED
1)			MOVX A,FN%KEP!FN%NAT ;[NIC1033] THEN SET KEEP FLAG
1)			STOR A,FKFLAG,(B) ;[NIC1033] INTO FORK TABLE
1)			MOVE A,SAD	;[NIC1033] GET THE STARTING ADDRESS
1)			STOR A,FKRADD,(B) ;[NIC1033] AND STORE IT
1)			HRROI A,STMES	;[NIC1033] PTR TO START MESSAGE
1)			STOR A,FKRMES,(B) ;[NIC1033] WHERE OTHERS WILL FIND IT
1)			HLRO A,PROGK+3	;[NIC1033] GET STRING FOR "INFO PROG"
1)			STOR A,FKRESP,(B) ;[NIC1033] AND SAVE IT FOR LATER
1)			JRST .+1]	;[NIC1033] AND CONTINUE
1)	>;IFN NICSW
1)		HRL B,NAMPTR		;STRING PNTR
LINE 157, PAGE 5
2)		HRL B,NAMPTR		;STRING PNTR


; SRC:<6-EXEC>EXECP.MAC.16 & EXECP.MAC.1 25-Jul-85 2311	PAGE 13



LINE 245, PAGE 6
1)		HRRZ Q1,SLFTAB(A)	;POINTER
1)		MOVEI Q1,.FKPTM(Q1)	;POINT TO PTTYMD BLOCK FOR FORK
1)		MOVE A,B		;JFN TO A
1)		CALL SUBNAM		;GET NAME
1)		HRROI A,SFKBUF		;POINTER TO NAME
LINE 213, PAGE 5
2)	;CM224 *** 4 lines deleted ***
2)		HRROI A,SFKBUF		;POINTER TO NAME


LINE 259, PAGE 6
1)		JRST ADDNAM		;GO ADD NAME
1)	^L
LINE 224, PAGE 5
2)		CALL ADDNAM		;CM224 GO ADD NAME
2)		MOVE A,SFKJFN		;CM224 Recover JFN
2)		MOVEI Q1,.FKPTM(Q1)	;CM224 Point to TTY modes block
2)		CALLRET SUBNAM		;CM224 Make full name
2)	^L


LINE 7, PAGE 8
1)	.CONTI::CALL .CONT 		;PARSE COMMAND
1)		CALL $CONTI		;SET FORK
1)		JRST ..CONT		;RESUME PROCESS
1)	
1)	;Here to parse the CONTINUE command
1)	.CONT:	NOISE <FORK>
1)		CONSTG			;ALLOCATE STORAGE
LINE 7, PAGE 7
2)	.CONTI::CALL .CONT1		;PARSE COMMAND
2)		CALL $CONTI		;SET FORK
2)		JRST ..CONT		;RESUME PROCESS
2)	
2)	.CONT1:	NOISE <FORK>
2)		CONSTG			;ALLOCATE STORAGE


LINE 17, PAGE 8
1)	.CONT0:	MOVEI B,$CON1 		;INCLUDES $CON1 AND $CON2
1)		TLOE Z,F1		;FIRST OR SECOND TIME THRU ?
1)		 MOVEI B,$CON2		;SECOND TIME.
1)		CALL FLDSKP		;PARSE LINE
LINE 16, PAGE 7
2)	.CONT2:	MOVEI B,$CONFD		;APPROPRIATE FIELD DESCRIPTORS
2)		TLOE Z,F1		;FIRST TIME THRU?
2)		MOVEI B,$CONF1		;NO - ONLY ALLOW COMMA OR CR
2)		CALL FLDSKP		;PARSE LINE

; SRC:<6-EXEC>EXECP.MAC.16 & EXECP.MAC.1 25-Jul-85 2311	PAGE 14




LINE 24, PAGE 8
1)		 JRST .CONT4		;YES - CHECK MODES
1)		CAIN D,.CMCMA		;GOT A COMMA ?
1)		 JRST .CONT1		;YES
1)		CAIN D,.CMSWI		;SWITCH SEEN?
1)		 JRST .CONT3		;YES - CHECK SUBCOMMANDS
1)		HRRZ A,C		;PICK UP FLDDB. WHICH SCORED
1)		CAIN A,$$PMOD		;GOT $PMODE KEYWORD TABLE ?
1)		 JRST .CONT3		;YES
1)		CALL FRKNM0		;PARSE NAME OR NUMBER
1)		MOVEM A,UFORK		;SAVE HANDLE (DON'T TOUCH "FORK" CELL UNTIL CONFIRMATION!)
1)		JRST .CONT0		;TRY FOR SWITCHES OR CONFIRM
1)	
1)	;Entries from above:
1)	;
1)	; .CONT1 called when a comma has been typed.
1)	; .CONT2 called to make subcommands work on the same line as the comma.
1)	; .CONT3 called when a switch or m-f keyword was typed.
1)	; .CONT4 called when a confirm has been typed.
1)	; .CONT5 is the common code for start and continue.
1)	
1)	.CONT1:	CRRX <Carriage return to enter subcommands>
1)	   	 JRST .CONT2
1)		SUBCOM $CMODE		;MAKES SUBCOMMANDS WORK
1)		JRST .CONT4
1)	
1)	.CONT2:	KEYWD $CMODE		;MAKES COMMA MF-KEYWORD WORK
1)		 0
1)		 CMERRX
1)		CALL 0(P3)		;DO THE SUBCOMMAND
1)		JRST .CONT4
1)	
1)	.CONT3:	HRRZ B,(B)		;B HAS ENTRIES ADDR, GET ADDR OF DISPATCH 
1)		CALL @(B)  		;GO TO PROPER ROUTINE.
1)	.CONT4:	MOVE A,UFORK		;ONLY CHANGE "FORK" NOW THAT COMMAND IS CONFIRMED
1)		MOVEM A,FORK
1)		MOVX B,FK%RUN
1)		TDNE B,SLFTAB(A)	;RAN THIS ONE?
1)		 MOVEM A,RUNFK		;YES - STORE IN RUNFK
1)	.CONT5:	SKIPG A,FORK		;DO WE HAVE A FORK
LINE 23, PAGE 7
2)		 JRST CONU		;YES - CHECK MODES
2)		CAIN D,.CMCMA		;COMMA SEEN?
2)		 JRST .CONT3		;YES - CHECK SUBCOMMANDS
2)		CAIN D,.CMKEY		;KEYWORD?
2)		JRST [	MOVE D,.CMDAT(C) ;YES - SEE WHICH ONE
2)			CAIN D,$CMODE	;MODE KEYWORD?
2)			JRST CONC1	;YES
2)			LOAD D,CM%FNC,.CMFNP(C) ;NO, MUST BE FORK. RESTORE D

; SRC:<6-EXEC>EXECP.MAC.16 & EXECP.MAC.1 25-Jul-85 2311	PAGE 15


2)			JRST .+1]
2)		CALL FRKNM0		;PARSE NAME OR NUMBER
2)		MOVEM A,UFORK		;SAVE HANDLE (DON'T TOUCH "FORK" CELL UNTIL CONFIRMATION!)
2)		JRST .CONT2		;LOOK FOR CR OR COMMA
2)	
2)	.CONT3:	CRRX <Carriage return to enter subcommands>
2)		 JRST .CONT4
2)		SUBCOM $PMODE		;GET PROGRAM MODES
2)	CONU:	MOVE A,UFORK		;ONLY CHANGE "FORK" NOW THAT COMMAND IS CONFIRMED
2)		MOVEM A,FORK
2)		MOVX B,FK%RUN
2)		TDNE B,SLFTAB(A)	;RAN THIS ONE?
2)		MOVEM A,RUNFK		;YES - STORE IN RUNFK
2)		JRST .CONT5
2)	
2)	.CONT4:	KEYWD $PMODE		;LOOK UP A MODE IF NO CR GIVEN
2)		 0			;NO DEFAULT
2)		 CMERRX
2)		CALL 0(P3)		;DISPATCH
2)	.CONT5:	SKIPG A,FORK		;DO WE HAVE A FORK


LINE 71, PAGE 8
1)	.CONT6:	
1)	IFN STANSW,<
1)		MOVE A,SJBUFP		;FORGET ALL ABOUT THE JFNS FOR BACKGROUND FORK
1)		MOVEM A,JBUFP
1)	>;IFN STANSW
1)		MOVEI A,.FHSLF		;SEE WHAT WE HAVE FOR JFNS
1)		GPJFN
LINE 59, PAGE 7
2)	.CONT6:	MOVEI A,.FHSLF		;SEE WHAT WE HAVE FOR JFNS
2)		GPJFN


LINE 89, PAGE 8
1)		SPJFN			;SET PRIMARY JFNS
1)	.CONT7:	SKIPN SLFTAB(A)		;KNOW THIS FORK?
1)		RET			;NO - DONE
1)		MOVX B,FK%INT
1)		ANDCAM B,SLFTAB(A)	;CLEAR INTERRUPTED BIT			        
1)	  	RET			;RETURN
1)	
1)	^L
1)	
1)	;Options for the "CONTINUE" command, ($CON1 includes $CON2)
1)	
1)	$CON1:
1)	$$PMOD:	FLDDB. .CMKEY,CM%SDH,$PMODE,,,[
1)		 FLDDB. .CMKEY,,FRKNMS,<Fork name,>,,[
1)		  FLDDB. .CMNUM,CM%SDH,10,<Octal fork number>,,$CON2]]

; SRC:<6-EXEC>EXECP.MAC.16 & EXECP.MAC.1 25-Jul-85 2311	PAGE 16


1)	
1)	
1)	;Option for the "START" command, ($STA1 includes $CON2)
1)	IFE STANSW,<
1)	$STA1:	FLDDB. .CMNUM,CM%SDH,10,<Octal start address>,,$CON2
1)	>;IFE STANSW
1)	IFN STANSW,<
1)	$STA1:	FLDDB. .CMNUM,CM%SDH,10,<Octal or symbolic start address>,,$CON2
1)	>;IFN STANSW
1)	
1)	;Common multi-forking switches for both "START" and "CONTINUE"
1)	$CON2:	FLDDB. .CMSWI,,$CMODE,,,[
1)		 FLDDB. .CMCMA,CM%SDH,10,,,[
1)	          FLDDB. .CMCFM]]
1)	
1)		 
1)	
1)	;Subcommand table and routines
1)	$CMODE:	TABLE
1)		T BACKGROUND
1)	   XTND,<
1)		T INPUT,,.CINPU
1)		T NO,,.CNO
1)	   >
1)		T NORMALLY
1)	   XTND,<
1)		T OUTPUT,,.COUTP
1)		T QUIET,,.CQUIE
1)		T SIGNAL,,.CSIGN
1)	   >
1)		T STAY
1)		TEND
1)	
1)	;Keyword table for special case of CONT STAY,  CONT NORMALLY
1)	$PMODE:	TABLE
1)		T NORMALLY
1)		T STAY
1)		TEND
1)	
1)	
1)	
1)	;Set BACKGROUND mode
1)	.BACKG:	CONFIRM
1)	.CBAC2:	MOVEI A,677777		;SET FOR INPUT TRAP
1)	.CSIGI:	HRLM A,TMPJFN		;SET PRIMARY INPUT
1)		SETOM STAYF		;STAY AT COMMAND LEVEL
1)		RET			;EXIT
1)	
1)	;STAY at command level
1)	.STAY:	CONFIRM
1)		SETOM STAYF		;STAY AT COMMAND LEVEL

; SRC:<6-EXEC>EXECP.MAC.16 & EXECP.MAC.1 25-Jul-85 2311	PAGE 17


1)		RET			;EXIT
1)	
1)	;Set NORMAL mode
1)	.NORMA:	CONFIRM
1)		SETZM STAYF		;I.E. NO STAY
1)		RET
1)	
1)	^L
1)	   XTND,<
1)	;REDIRECT OUTPUT TO FILE
LINE 72, PAGE 7
2)		CALL PIOFF		;CM224 Keep things consistent
2)		TXNE D,FK%PRI		;CM224 Primary input reset?
2)		JRST [	HLRZ A,B	;CM224 Yes, get it
2)			CAIGE A,.PRIIN	;CM224 Real JFN?
2)			CALL JUNSTK	;CM224 Yes, unstack the jfn
2)			JRST .+1]	;CM224
2)		TXNE D,FK%PRO		;CM224 Primary output reset?
2)		JRST [	HRRZ A,B	;CM224 Yes, get it
2)			CAIGE A,.PRIIN	;CM224 Real JFM?
2)			CALL JUNSTK	;CM224 Yes, unstack the jfn
2)			JRST .+1]	;CM224
2)		MOVE A,FORK		;CM224 JUNSTK kills A
2)		SPJFN			;SET PRIMARY JFNS
2)		CALL PION		;CM224 Things are consistent again
2)	.CONT7:	SKIPN SLFTAB(A)		;KNOW THIS FORK?
2)		RET			;NO - DONE
2)		MOVX B,FK%INT!FK%TTY	;CM236
2)		ANDCAM B,SLFTAB(A)	;CLEAR INTERRUPTED BIT
2)		RET			;RETURN
2)	
2)	;SUBCOMMAND TABLE AND ROUTINES
2)	
2)	$PMODE:	TABLE
2)		T BACKGROUND
2)		T INPUT,,.CINPU
2)		T NO,,.CNO
2)		T OUTPUT,,.COUTP
2)		T QUIET,,.CQUIE
2)		T SIGNAL,,.CSIGN
2)		T STAY
2)		TEND
2)	
2)	;HANDLE "STAY" OR "NORMALLY" AS KEYWORD ON CONTINUE LINE
2)	
2)	CONC1:	CONFIRM
2)		HRRZ C,0(B)		;GET ROUTINE ADDRESS
2)		HRRZ C,0(C)
2)		CALL 0(C)		;DO IT
2)		JRST CONU		;FINISH UP
2)	

; SRC:<6-EXEC>EXECP.MAC.16 & EXECP.MAC.1 25-Jul-85 2311	PAGE 18


2)	$CMODE::TABLE
2)		T NORMALLY,,..NORM
2)		T STAY,,..STAY
2)		TEND
2)	
2)	..NORM:	SETZM STAYF		;I.E. NO STAY
2)		RET
2)	^L
2)	;REDIRECT OUTPUT TO FILE


LINE 18, PAGE 10
1)		SETZ A,
LINE 17, PAGE 8
2)		HLRZ B,B		;CM224 SPECFN wants gen,,flags
2)		SETZ A,


LINE 23, PAGE 10
1)		JRST .CSIGI		;STORE JFN AND RETURN
LINE 23, PAGE 8
2)		CALL $OPEN7		;CM224 Open the file
2)		JRST .CSIGI		;STORE JFN AND RETURN


LINE 32, PAGE 10
1)	;SIGNAL TTY I/O
1)	
1)	.CSIGN:	NOISE <WHEN TTY WANTED FOR>
1)		SKIPA A,[677777]	;CAUSE PRIMARY TRAP
1)	.CNO:	MOVEI A,.NULIO		;NULL DEVICE
1)	.CSIG2:	KEYWD $CSIGN
1)		 T EITHER,,.CSIGB	;DEFAULT TO EITHER
1)		 JRST CERR
1)		CONFIRM
LINE 33, PAGE 8
2)	
2)	;STAY AT COMMAND LEVEL
2)	
2)	.STAY:	CONFIRM
2)		JRST ..STAY
2)	
2)	;SIGNAL TTY I/O
2)	
2)	.CSIGN:	NOISE <WHEN TTY WANTED FOR>
2)		SKIPA A,[.SIGIO]	;CM224 CAUSE PRIMARY TRAP
2)	.CNO:	MOVEI A,.NULIO		;NULL DEVICE
2)	.CSIG2:	PUSH P,A		;CM236 Save designator (KEYWD now clobbers A)
2)		KEYWD $CSIGN
2)		 T EITHER,,.CSIGB	;DEFAULT TO EITHER
2)		 JRST CERR

; SRC:<6-EXEC>EXECP.MAC.16 & EXECP.MAC.1 25-Jul-85 2311	PAGE 19


2)		POP P,A			;CM236 Restore designator
2)		CONFIRM


LINE 51, PAGE 10
1)		JRST .STAY		;RETURN
1)	   > ;END XTND
1)	
1)	^L
1)	
LINE 60, PAGE 8
2)		JRST ..STAY		;RETURN
2)	
2)	;SET BACKGROUND MODE
2)	
2)	.BACKG:	CONFIRM
2)	.CBAC2:	MOVEI A,.SIGIO		;CM224 SET FOR INPUT TRAP
2)	.CSIGI:	HRLM A,TMPJFN		;SET PRIMARY INPUT
2)	..STAY:	SETOM STAYF		;STAY AT COMMAND LEVEL
2)		RET			;EXIT
2)	


LINE 49, PAGE 11
1)	IFE STANSW,<
1)		TXZ B,FN%EPH!FN%KEP	;DON'T BE CONTRADICTORY
1)	>;IFE STANSW
1)	IFN STANSW,<
1)		TXZ B,FN%EPH!FN%KEP!FN%KNC ;DON'T BE CONTRADICTORY
1)	>;IFN STANSW
1)		TXO B,FN%NEF		;SAY NO EPHEMERAL
LINE 116, PAGE 8
2)		TXZ B,FN%EPH!FN%KEP	;DON'T BE CONTRADICTORY
2)		TXO B,FN%NEF		;SAY NO EPHEMERAL


LINE 60, PAGE 11
1)	IFE STANSW,<
1)		TXZ B,FN%KEP!FN%NEF	;AVOID CONTRADICTION
1)	>;IFE STANSW
1)	IFN STANSW,<
1)		TXZ B,FN%KEP!FN%KNC!FN%NEF ;AVOID CONTRADICTION
1)	>;IFN STANSW
1)		TXO B,FN%EPH		;SAY THIS FORK SHOULD BE EPHEMERAL
LINE 122, PAGE 8
2)		TXZ B,FN%KEP!FN%NEF	;AVOID CONTRADICTION
2)		TXO B,FN%EPH		;SAY THIS FORK SHOULD BE EPHEMERAL


; SRC:<6-EXEC>EXECP.MAC.16 & EXECP.MAC.1 25-Jul-85 2311	PAGE 20



LINE 83, PAGE 11
1)		T CONTINUE,,[EXP ..CONT,[ASCIZ /Continuing/]]
1)	IFN STANSW,<
1)		T IGNORE,,0
1)	>;IFN STANSW
1)		T REENTER,,[EXP REENT1,[ASCIZ /Reentering/]]
1)		T START,,[SAD:	EXP .STRT2,[STMES: ASCIZ /Starting/]]
1)		TEND
LINE 140, PAGE 8
2)		T CONTINUE,,[CAD:  EXP ..CONT,[COMES: ASCIZ /Continuing/]] ;EM110
2)		T REENTER,,[EXP REENT1,[ASCIZ /Reentering/]]
2)		T START,,[SAD:	EXP .STRT1,[STMES: ASCIZ /Starting/]]
2)		TEND


LINE 103, PAGE 11
1)	IFN STANSW,<
1)		IFE. P3			;IF FORK SUPPOSED TO BE RESTARTED.
1)		  TXO B,FN%KNC		;KEEP NOT AS A COMMAND
1)		  TXZ B,FN%EPH!FN%NEF!FN%KEP ;AVOID CONTRADICTIONS
1)		  STOR B,FKFLAG,(A)	;STORE FLAGS
1)		  MOVE B,IINFO
1)		  STOR B,FKRESP,(A)	;POINTER FOR INFO PROG
1)		  HLRZ B,(A)		;GET ADDRESS OF NAME
1)		  LOAD A,FKHAN,(A)	;GET FORK HANDLE
1)		  IFN. A		;GOT FORK...
1)		    MOVE C,SLFTAB(A)	;GET OLD SETTING
1)		    SKIPE B,.FKNAM(C)	;GET KEPT FORK NAME OR 0 AND PTR TO NULL STRING
1)		     HRRO B,B		;THERE IS A NAME, MAKE ASCIZ POINTER
1)		    TXON C,FK%KPT	;KEEP FORK AND ANNOUNCE IF THIS IS NEWS
1)		     ETYPE <[Keeping %2M]%_>
1)		    MOVEM C,SLFTAB(A)	;SAVE CHANGED FLAGS
1)		  ENDIF.
1)		  RET			;THAT'S ALL FOR HERE
1)		ENDIF.
1)		TXO B,FN%KEP		;SAY TO KEEP FORK
1)		TXZ B,FN%EPH!FN%NEF!FN%KNC ;AVOID CONTRADICTIONS
1)	>;IFN STANSW
1)	IFE STANSW,<
1)		TXO B,FN%KEP		;SAY TO KEEP FORK
1)		TXZ B,FN%EPH!FN%NEF	;AVOID CONTRADICTIONS
1)	>;IFE STANSW
1)		STOR B,FKFLAG,(A)	;STORE UPDATED FLAGS
LINE 157, PAGE 8
2)		TXO B,FN%KEP		;SAY TO KEEP FORK
2)		TXZ B,FN%EPH!FN%NEF	;AVOID CONTRADICTIONS
2)		STOR B,FKFLAG,(A)	;STORE UPDATED FLAGS


; SRC:<6-EXEC>EXECP.MAC.16 & EXECP.MAC.1 25-Jul-85 2311	PAGE 21



LINE 142, PAGE 11
1)	;[NIC1033] SET PROGRAM NAME NO-KEEP
1)	
1)	IFN NICSW,<			;[NIC1033]
1)	PNKEEP:	CONFIRM			;[NIC1033]
1)		CALL PBLK		;[NIC1033] MAKE SURE THERE IS A BLOCK
1)		TXZ B,FN%EPH!FN%KEP	;[NIC1033] REMOVE CONTRADICTIONS
1)		TXO B,FN%NKP		;[NIC1033] SET NO KEEP
1)		STOR B,FKFLAG,(A)	;[NIC1033] SAVE IT
1)		RET			;[NIC1033]
1)	>;IFN NICSW
1)	
1)	;PBLK is a local routine used by SET PROGRAM to point at the fork block for
LINE 172, PAGE 8
2)	;PBLK is a local routine used by SET PROGRAM to point at the fork block for


LINE 10, PAGE 12
1)	IFN STANSW,<
1)		MOVEM A,UFORK		;MAKE SURE THIS GUY IS SET UP AS WELL
1)	>;IFN STANSW
1)		SETZM STAYF
LINE 10, PAGE 9
2)		SETZM STAYF


LINE 27, PAGE 12
1)	CONTF1:	HRROI A,STMES		;GET CORRECT MESSAGE
1)		XCT DOMES		;PRINT MESSAGE IN STANDARD MANNER
1)		JRST @SAD		;START IT UP
1)	^L
LINE 24, PAGE 9
2)	REPEAT 0,<			;EM110
2)	CONTF1:	HRROI A,STMES		;GET CORRECT MESSAGE
2)		XCT DOMES		;PRINT MESSAGE IN STANDARD MANNER
2)		JRST @SAD		;START IT UP
2)	>				;EM110
2)	CONTF1:	MOVE A,RUNFK		;EM110 Get fork
2)		RFSTS%			;EM110 Get it's status
2)		LDB A,[POINTR A,RF%STS]	;EM110 Isolate status
2)		CAIE A,.RFHLT		;EM110 Halted?
2)		IFSKP.			;EM110 Yes
2)		  HRRZS B		;EM110 Get PC
2)		  SKIPE B		;EM110 "Halted" at 0?
2)		ANSKP.			;EM110 Yes
2)		  HRROI A,STMES		;EM110 Get message
2)		  XCT DOMES		;EM110 Print it
2)		  JRST .STRT1		;EM110 And go start this fork
2)		ENDIF.			;EM110

; SRC:<6-EXEC>EXECP.MAC.16 & EXECP.MAC.1 25-Jul-85 2311	PAGE 22


2)		HRROI A,COMES		;EM110 Get correct message
2)		XCT DOMES		;EM110 Print message in std manner
2)		JRST @CAD		;EM110 Continue it
2)	^L


LINE 5, PAGE 14
1)	.DDT::	TRVAR <SECFLG,DDTSEC,DDTOVL,JBSYM,JBBUSY,SA>
1)		CALL GSWIS		;PARSE POSSIBLE SWITCHES
1)		MOVEM C,DDTOVL		;SAVE THE OVERLAY FLAG
1)		SETOM SECFLG		;FIRST ASSUME SPECIAL SECTION
1)		JUMPGE B,DDT0		;IF A SPECIAL SECTION WAS GIVEN, SKIP THIS
1)		SETZM SECFLG		;ELSE SAY NO SECTION SPECIFIED
1)		SKIPG B,FORK	 	;GOT A FORK?
1)		JRST DDT0	 	;NO - JUST LEAVE IT AS -1
1)		HRRZ C,SLFTAB(B)	;GET THE START ADDRESS OF DDT, IF ANY
1)		HLRZ A,DDTSA(C)
1)		SKIPL DDTSA(C)		;IS DDT ALREADY THERE?
1)		JRST DDT0		;YES - USE ITS SECTION
1)		MOVE A,B		;NO - GET THE FORK
1)		CALL GETENT		;GET THE FORK'S ENTRY VECTOR
1)		HLRZ B,C		;USE SECTION NUMBER OF START ADDRESS
1)	
1)	DDT0:	CAIGE B,0		;HAVE A REAL SECTION YET?
1)		SETZ B,			;NO, SO USE SECTION 0
1)		MOVEM B,DDTSEC		;SAVE SECTION TO PUT DDT IN
1)		SETZM STAYF
1)		SETZM JBSYM
1)		SETZM JBBUSY		;CLEAR SYMBOL DATA
1)		SKIPE SECFLG		;LOADING INTO PARTICULAR SECTION?
1)		JRST DDTLOD		;YES, MAKE SURE WE START A DDT THERE
1)		SKIPLE A,FORK		;CURRENT FORK?
LINE 5, PAGE 11
2)	.DDT::	TRVAR <DDTSEC,JBSYM,JBBUSY,SA,PRGSEC>
2)		CALL GSWIS		;PARSE POSSIBLE SWITCHES
2)		JUMPL A,[SKIPG B,FORK	;IF NO SPECIAL SECTION, IS THERE A FORK?
2)			 JRST .+1	;NO FORK AND NO SPECIAL SECTION, LEAVE AS -1.
2)			 HRRZ C,SLFTAB(B) ;NO SPECIAL SECTION BUT THERE IS A FORK
2)			 MOVE A,CODSEC(C) ;USE CODE SECTION FOR DDT'S
2)			 JRST .+1]
2)		MOVEM A,DDTSEC		;SAVE SECTION TO PUT DDT IN
2)		SETZM STAYF
2)		SETZM JBSYM
2)		SETZM JBBUSY		;CLEAR SYMBOL DATA
2)		SKIPLE A,FORK		;CURRENT FORK?


; SRC:<6-EXEC>EXECP.MAC.16 & EXECP.MAC.1 25-Jul-85 2311	PAGE 23



LINE 34, PAGE 14
1)	
LINE 21, PAGE 11
2)		SETZM PRGSEC		;FIRST ASSUME NO PROGRAM SECTION SPECIFIED
2)		SKIPL A,CODSEC(A)	;IS THERE ONE?
2)		MOVEM A,PRGSEC		;YES, REMEMBER IT
2)	


LINE 39, PAGE 14
1)	DDTLOD:	MOVEI A,DDTORG		;DDT BEGINNING ADDRESS
1)		HRL A,DDTSEC		;LOOK IN CORRECT SECTION
1)		CALL MAPPF
LINE 29, PAGE 11
2)		MOVEI A,DDTORG		;DDT BEGINNING ADDRESS
2)		HRL A,PRGSEC		;LOOK IN CORRECT SECTION
2)		CALL MAPPF


LINE 53, PAGE 14
1)	DDT1:	MOVEI A,JOBDDT		;LOC FOR DEBUGGER ADDRS
1)		HRL A,DDTSEC		;USE APPROPRIATE SECTION
1)		CALL MAPPF		;MAP PAGE OF FORK
LINE 43, PAGE 11
2)	DDT1:	MOVE A,FORK		;EM123
2)		CAME A,EDFORK		;EM123 Editor fork?
2)		IFSKP.			;EM123 Yes
2)		  PROMPT <[Editor fork, Confirm]> ;EM123 Do you really want to do that?
2)		  CRRX <Confirm with carriage return> ;EM123
2)		   CMERRX		;EM123 Failed
2)		ENDIF.			;EM123
2)		MOVEI A,JOBDDT		;LOC FOR DEBUGGER ADDRS
2)		HRL A,PRGSEC		;USE APPROPRIATE SECTION
2)		CALL MAPPF		;MAP PAGE OF FORK


LINE 9, PAGE 15
1)		MOVE B,DDTSEC		;PASS SECTION TO MERGE ROUTINE
1)		MOVE C,DDTOVL		;DITTO OVERLAY FLAG
1)		CALL $MERGE		;MERGE IT INTO FORK, CREATING FORK IF NONE,
LINE 9, PAGE 12
2)		MOVE B,DDTSEC		;PASS -1 OR SECTION TO MERGE ROUTINE
2)		CALL $MERGE		;MERGE IT INTO FORK, CREATING FORK IF NONE,


; SRC:<6-EXEC>EXECP.MAC.16 & EXECP.MAC.1 25-Jul-85 2311	PAGE 24



LINE 19, PAGE 15
1)		HRL A,DDTSEC
1)		CALL MAPPF
LINE 18, PAGE 12
2)		SKIPL DDTSEC		;USE SPECIAL SECTION IF GIVEN
2)		HRL A,DDTSEC
2)		HLL Q1,A		;REMEMBER SECTION
2)		CALL MAPPF


LINE 25, PAGE 15
1)		HRL A,DDTSEC		;SAY WHICH SECTION TO LOOK IN
1)		CALL MAPPF
1)		 CALL CJERRE		;FAILED-- TYPE JSYS ERROR
1)		ANDI A,777
1)		MOVE C,JBSYM
1)		MOVEM C,PAGEN(A)	;STORE POINTER
1)		HRR A,Q1		;WHERE TO PUT UNDEF PTR IN DDT
1)	       	HRL A,DDTSEC		;LOOK IN CORRECT SECTION
1)		CALL MAPPF
1)		 CALL CJERRE		;FAILED-- TYPE JSYS ERROR
1)		ANDI A,777
LINE 26, PAGE 12
2)		SKIPL DDTSEC		;USE DDT SECTION IF SPECIAL
2)		HLL A,Q1		;SAY WHICH SECTION TO LOOK IN
2)		CALL MAPPF
2)		 JRST CJERRE		;FAILED-- TYPE JSYS ERROR
2)		ANDI A,777
2)		MOVE C,JBSYM
2)		MOVEM C,PAGEN(A)	;STORE POINTER
2)		MOVE A,Q1		;WHERE TO PUT UNDEF PTR IN DDT
2)		CALL MAPPF
2)		 JRST CJERRE		;FAILED-- TYPE JSYS ERROR
2)		ANDI A,777


LINE 45, PAGE 15
1)		HRL B,DDTSEC		;GIVE IT CORRECT SECTION
LINE 46, PAGE 12
2)		SKIPL DDTSEC
2)		HRL B,DDTSEC		;GIVE IT CORRECT SECTION


; SRC:<6-EXEC>EXECP.MAC.16 & EXECP.MAC.1 25-Jul-85 2311	PAGE 25



LINE 2, PAGE 16
1)	;[NIC1002] "IDDT" COMMAND AND "NO IDDT" COMMANDS
1)	;[NIC1002] F1 IS CLEARED BY MAIN DISPATCH (TO .IDDT) AND SET BY "NO"
1)	
1)	;[NIC1002] <debugger> <fork>:
1)	;[NIC1002]	1) splice <debugger> between EXEC and <fork>
1)	;[NIC1002] <debugger>: (no fork argument)
1)	;[NIC1002]  do the first possible option:
1)	;[NIC1002]	1) continue <debugger> fork, if exists 
1)	;[NIC1002]	2) splice <debugger> between EXEC and current unkept fork,
1)	;[NIC1002]	   if exists
1)	;[NIC1002]	3) start <debugger>
1)	
1)	.IDDT::	HRROI A,[ASCIZ/IDDT/]	;[NIC1002]
1)		HRROI B,[GETSAVE(SYS:IDDT.)] ;[NIC1002] SETUP FILE NAME
1)	;	JRST DEBUGR		;[NIC1002] JOIN COMMON CODE
1)	
1)	DEBUGR:	TRVAR <DBGNMP,DBGFNP,DBGJFN,USRFRK> ;[NIC1002] DEBUGGER NAME PTR,
1)					;[NIC1002] FILENAME PTR, JFN, USER FORK
1)		MOVEM A,DBGNMP		;[NIC1002] STORE DEBUGGER NAME PTR
1)		MOVEM B,DBGFNP		;[NIC1002] AND FILE NAME PTR
1)		TLNE Z,F1		;[NIC1002] MAKE GRAMMATICAL
1)		 NOISE <over>		;[NIC1002]
1)		MOVEI B,$FRKNM		;[NIC1002] already defined in EXECCA
1)		CALL FLDSKP		;[NIC1002]
1)		 CMERRX <Fork name, number, or CR required>	;[NIC1002]
1)		LDB D,[POINT 9,.CMFNP(C),8]	;[NIC1002] GET PARSE
1)		CAIE D,.CMCFM		;[NIC1002] JUST CR?
1)		 JRST DEBUG1		;[NIC1002] NO
1)		TLNN Z,F1		;[NIC1002] IS IT "NO"?
1)		 JRST DEBUG3		;[NIC1002] NO, HANDLE "DEBUGGER" WITH NO FORK
1)		JRST DEBUG4		;[NIC1002] YES, HANDLE "NO DEBUGGER" NO FORK
1)	
1)	DEBUG1:	CONFIRM			;[NIC1002]
1)		CALL FRKNM0		;[NIC1002] GET A FORK HANDLE
1)		TLNN Z,F1		;[NIC1002] IS THIS "NO IDDT"
1)		 JRST DEBUG2		;[NIC1002] NO, HANDLE "DEBUGGER FORK"
1)		MOVE C,A		;[NIC1002] YES, HANDLE "NO DEBUGGER FORK"
1)		JRST NODBG1		;[NIC1002]
1)	
1)	;[NIC1002] "DEBUGGER FORK"
1)	DEBUG2:	MOVEM A,USRFRK		;[NIC1002] SAVE IT
1)		SETO A,			;[NIC1002]
1)		CALL MAPPF		;[NIC1002] UNMAP ANY INFERIOR PAGE
1)		 JRST CJERRE		;[NIC1002] FAILED?  EXPLAIN WHY AND GET OUT
1)		MOVE B,DBGFNP		;[NIC1002] GET DEBUGGER PROGRAM
1)		CALL TRYGTJ		;[NIC1002] ATTEMPT A JFN
1)		 ERROR <Debugger .EXE file not found>	;[NIC1002]
1)		MOVEM A,DBGJFN		;[NIC1002] SAVE JFN

; SRC:<6-EXEC>EXECP.MAC.16 & EXECP.MAC.1 25-Jul-85 2311	PAGE 26


1)		MOVEI Q1,ETTYMD		;[NIC1002] SAVE EXEC'S TTY MODES
1)		CALL LTTYMD		;[NIC1002]
1)		CALL PIOFF		;[NIC1002] MAKE IT REASONABLE
1)		MOVE A,DBGJFN		;[NIC1002] GET PROGRAM
1)		SETOM FORK		;[NIC1002] FORCE CREATION OF NEW FORK
1)		CALL $GET0		;[NIC1002] SINCE IT WOULD PROBABLY MUNGE USERS
1)		MOVE A,FORK		;[NIC1002] CHECK ENTRY VECTOR, WE NEED LENGTH 3
1)		CALL GETENT		;[NIC1002]
1)		CAIGE B,1000		;[NIC1002]
1)		 CAIGE B,3		;[NIC1002]
1)		  JRST [MOVE A,USRFRK	;[NIC1002] BAD ENTRY VECTOR, KILL ALL
1)			EXCH A,FORK	;[NIC1002]
1)			CALL KEFORK	;[NIC1002]
1)			ERROR <Bad debugger .EXE format>]
1)		MOVE A,FORK		;[NIC1002] GET THE FORK HANDLE
1)		MOVX B,FK%DBG		;[NIC1002] MAKE FORK PROPERLY
1)		IORM B,SLFTAB(A)	;[NIC1002]
1)		MOVE B,USRFRK		;[NIC1002]
1)		SPLFK%			;[NIC1002] DO THE SPLICE
1)		 CALL [PUSH P,A		;[NIC1002] ERROR, SAVE CODE
1)		       MOVE A,USRFRK	;[NIC1002] KILL DEBUGGER FORK
1)		       EXCH A,FORK	;[NIC1002]
1)		       CALL KEFORK	;[NIC1002]
1)		       POP P,A		;[NIC1002] GET ERROR BACK
1)		       JRST JERR]	;[NIC1002] LET HIM KNOW WHY
1)		MOVEM A,PAGEN+1		;[NIC1002] GIVE DEBUGGER A HANDLE ON SUER FORK
1)		MOVE A,FORK		;[NIC1002]
1)		MOVEI B,PAGEN		;[NIC1002]
1)		SFACS%			;[NIC1002] VIA THE ACS
1)		MOVE B,USRFRK		;[NIC1002] UPDATE FORK TABLES
1)		HRLM A,@SLFTAB(B)	;[NIC1002] USER FORKS SUPERIOR IS NOW DEBUGGER
1)		HRRM B,@SLFTAB(A)	;[NIC1002] DEBUGGERS INFERIOR IS NOW USER
1)		MOVX C,FK%UND		;[NIC1002] MARK USER AS UNDER DEBUGGER
1)		IORM C,SLFTAB(B)	;[NIC1002]
1)		CALL PION		;[NIC1002] PERMIT ^C
1)		MOVEM A,RUNFK		;[NIC1002] RUNNING FORK IS DEBUGGER
1)		MOVX B,2		;[NIC1002] START AT VERSION ENTRY
1)		SFRKV%			;[NIC1002]
1)		CALL FTTYMD		;[NIC1002] SET FORK TTY MODES
1)		TLO Z,RUNF		;[NIC1002] SET TO TELL WHAT TO DO ON ^C
1)		CALLRET WAITF		;[NIC1002] WAIT FOR IT TO FINISH
1)	
1)	;[NIC1002] "DEBUGGER" WITH NO FORK ARGUMENT
1)	DEBUG3:	CALL FINDBG		;[NIC1002] IS THERE A DEBUGGER FORK ALREADY
1)		 JRST DEBUG4		;[NIC1002] NO
1)		MOVEM C,FORK		;[NIC1002] YES, MAKE IT CURRENT
1)		MOVEM C,RUNFK		;[NIC1002] AND RUNNING TOO
1)		CALLRET ..CONT		;[NIC1002] CONTINUE IT
1)	
1)	DEBUG4:	MOVX B,FK%KPT		;[NIC1002] IS CURRENT FORK UNKEPT
1)		SKIPLE A,FORK		;[NIC1002]

; SRC:<6-EXEC>EXECP.MAC.16 & EXECP.MAC.1 25-Jul-85 2311	PAGE 27


1)		 TDNE B,SLFTAB(A)	;[NIC1002]
1)		  SKIPA			;[NIC1002]
1)		   JRST DEBUG2		;[NIC1002] YES
1)		MOVE B,DBGFNP		;[NIC1002] GET DEBUGGER PROGRAM
1)		CALL TRYGTJ		;[NIC1002] ATTEMPT A JFN
1)		 ERROR <Debugger file not found>	;[NIC1002] NO GOOD
1)		MOVEM A,DBGJFN		;[NIC1002] SAVE THE JFN
1)		MOVEI Q1,ETTYMD		;[NIC1002] SAVE EXECS TTY MODES
1)		CALL LTTYMD		;[NIC1002]
1)		CALL ERESET		;[NIC1002] CLEANUP LOOSE FORKS
1)		MOVE A,DBGJFN		;[NIC1002] RESTORE THE JFN
1)		CALL $GET0		;[NIC1002] GET THE PROGRAM
1)		MOVE A,FORK		;[NIC1002] MAKR AS DEBUGGER
1)		MOVX B,FK%DBG		;[NIC1002]
1)		IORM B,SLFTAB(A)	;[NIC1002]
1)		CALLRET ..STRT		;[NIC1002] GO START IT
1)	
1)	;[NIC1002] NO COMMAND
1)	;[NIC1002] NO "DEBUGGER FORK":
1)	;[NIC1002] 	1) UNSPLICE FORK
1)	;[NIC1002] NO "DEBUGGER"
1)	;[NIC1002] 	1) UNSPLICE CURRENT FORK IF SPLICED WITH "DEBUGGER"
1)	;[NIC1002] 	2) FIND "DEBUGGER" AND UNSPLICE IT
1)	
1)	.NO::	HELPX <an IDDT style debugger name, one of the following:> ;[NIC1002] 
1)		KEYWD $NO		;[NIC1002]
1)		 T Iddt			;[NIC1002]
1)		 JRST CERR		;[NIC1002]
1)		TLO Z,F1		;[NIC1002] PREFACED WITH "NO"
1)		JRST 0(P3)		;[NIC1002] AND DO IT
1)	
1)	$NO:	TABLE			;[NIC1002]
1)		T Iddt,			;[NIC1002]
1)		TEND			;[NIC1002]
1)	
1)	;[NIC1002] NO "DEBUGGER FORK"
1)	NODBG1:	MOVE D,SLFTAB(C)	;[NIC1002] get fork's flags
1)		TXNE D,FK%DBG		;[NIC1002] is it a debugger with a name?
1)		 TXNN D,FK%NAM		;[NIC1002]
1)		  JRST NODBG2		;[NIC1002] no, get its superior
1)		MOVE A,DBGNMP		;[NIC1002] yes, debugger subset of fork name?
1)		HRROI B,@.FKNAM(D)	;[NIC1002]
1)		STCMP			;[NIC1002]
1)		SKIPE A			;[NIC1002]
1)		 TXNE A,SC%SUB		;[NIC1002]
1)		  JRST NODBG3		;[NIC1002] yes
1)	NODBG2:	HLRZ C,.FKOWN(D)	;[NIC1002] no, get its superior
1)		CAIE C,.FHSLF		;[NIC1002] is superior the EXEC?
1)		 JUMPG C,NODBG1		;[NIC1002] no, check this fork
1)		MOVE A,DBGNMP		;[NIC1002] yes
1)	        ERROR <Not under %1$ debugger> ;[NIC1002]

; SRC:<6-EXEC>EXECP.MAC.16 & EXECP.MAC.1 25-Jul-85 2311	PAGE 28


1)	
1)	NODBG3:	CALL PIOFF		;[NIC1002] no CTRL/Cs
1)		MOVEM C,FORK		;[NIC1002] store debugger fork
1)		HRRZ B,.FKOWN(D)	;[NIC1002] set user fork's superior to be EXEC
1)		MOVX A,.FHSLF		;[NIC1002] 
1)		SPLFK			;[NIC1002] 
1)		 CALL SCREWUP		;[NIC1002]
1)		MOVE B,A		;[NIC1002] update fork tables
1)		MOVE A,FORK		;[NIC1002]
1)		MOVX C,.FHSLF		;[NIC1002]
1)		HRLM C,@SLFTAB(B)	;[NIC1002] user fork's superior is now EXEC
1)		HLLZS @SLFTAB(A)	;[NIC1002] debugger has no inferior
1)		MOVE C,SLFTAB(B)	;[NIC1002] fix up user fork's flags
1)		TXZ C,FK%UND		;[NIC1002] no longer under debugger
1)		TXO C,FK%RUN		;[NIC1002] probably runnable
1)		MOVEM C,SLFTAB(B)	;[NIC1002]
1)		MOVEM B,FORK		;[NIC1002] make user fork be current fork
1)		MOVEM B,RUNFK		;[NIC1002] 
1)		CALL PION		;[NIC1002] CTRL/Cs allowed
1)		CALLRET KEFORK		;[NIC1002] kill debugger
1)	
1)	;[NIC1002] "NO <debugger>" with no fork argument
1)	NODBG4:	MOVX A,FK%DBG!FK%UND	;[NIC1002] is current fork either the debugger
1)		SKIPLE C,FORK		;[NIC1002]  or the user fork?
1)		 TDNN A,SLFTAB(C)	;[NIC1002] 
1)		  SKIPA			;[NIC1002] 
1)		   JRST NODBG1		;[NIC1002] yes
1)		CALL FINDBG		;[NIC1002] no, look for debugger fork
1)		 SKIPA			;[NIC1002]
1)		  JRST NODBG1		;[NIC1002] found it
1)		MOVE A,DBGNMP		;[NIC1002] can't find one
1)		ERROR <No %1$ debugger fork> ;[NIC1002]
1)	
1)	;[NIC1002] Find Debugger Fork Handle
1)	;[NIC1002]
1)	;[NIC1002]   return: +1		error
1)	;[NIC1002]	    +2	C/ 	fork handle 
1)	;[NIC1002]  note: uses DBGNMP transient variable
1)	FINDBG:	MOVEI A,FRKNMS		;[NIC1002] look in fork names table 
1)		MOVE B,DBGNMP		;[NIC1002] 
1)		TBLUK			;[NIC1002]
1)		TXNE B,TL%NOM!TL%AMB	;[NIC1002] no match, or ambiguous?
1)		 RET			;[NIC1002] yes
1)		HRRZ A,(A)		;[NIC1002] load the handle into C
1)		LOAD C,FKHAN,(A)	;[NIC1002]
1)		MOVX A,FK%DBG		;[NIC1002] is the debugger bit set?
1)		TDNN A,SLFTAB(C)	;[NIC1002]
1)		 RET			;[NIC1002] no 
1)		RETSKP			;[NIC1002] yes
1)	
1)	^L

; SRC:<6-EXEC>EXECP.MAC.16 & EXECP.MAC.1 25-Jul-85 2311	PAGE 29


1)	;FORK <NAME> OR <NUMBER>
LINE 2, PAGE 13
2)	;FORK <NAME> OR <NUMBER>


LINE 25, PAGE 17
1)	IFE STANSW,<
1)		CALL FRKNM0		;CHECK FURTHER ARG
1)		CALLRET CONF		;FORCE CONFIRM AND RETURN HANDLE
1)	>;IFE STANSW
1)	IFN STANSW,<
1)		CONFIRM			;GET CONFIRM FIRST
1)		CALLRET FRKNM0		;THEN RETURN HANDLE
1)	
LINE 25, PAGE 13
2)		CALL FRKNM0		;CHECK FURTHER ARG
2)		CALLRET CONF		;FORCE CONFIRM AND RETURN HANDLE
2)	


LINE 41, PAGE 17
1)	IFE STANSW,<
1)	FRKNM0:
1)	>;IFE STANSW
1)	IFN STANSW,<
1)	FRKNM0::
1)	>;IFN STANSW
1)		CAIN D,.CMKEY		;NAME?
1)		 JRST [	HRRZ C,(B)	;YES, GET ADDRESS OF FORK BLOCK
1)			HLRO A,(B)	;GET POINTER TO NAME
1)			LOAD B,FKHAN,(C);GET FORK HANDLE OR 0
1)			JUMPE B,[ERROR <Fork %1M doesn't exist>]
1)			JRST .+1]
LINE 36, PAGE 13
2)	FRKNM0:	CAIN D,.CMKEY		;NAME?
2)		 JRST [	HRRZ C,(B)	;YES, GET ADDRESS OF FORK BLOCK
2)			HLRO A,(B)	;GET POINTER TO NAME
2)			LOAD B,FKHAN,(C);GET FORK HANDLE OR 0
2)			JUMPE B,[ERROR <Fork %1m doesn't exist>]
2)			JRST .+1]


LINE 74, PAGE 17
1)	IFN STANSW,<
1)		TXNE B,FK%INV		;CM156 INVOKE'd fork?
1)		 ERROR <No such fork>	;CM156 Ignore it
1)	>;IFN STANSW
1)		HLRZ B,.FKOWN(B)	;GET OWNER HANDLE
LINE 63, PAGE 13
2)		TXNE B,FK%INV		;CM156 INVOKE'd fork?
2)		 ERROR <No such fork>	;CM156 Ignore it

; SRC:<6-EXEC>EXECP.MAC.16 & EXECP.MAC.1 25-Jul-85 2311	PAGE 30


2)		HLRZ B,.FKOWN(B)	;GET OWNER HANDLE


LINE 6, PAGE 18
1)	.NAME::	NOISE <OF CURRENT FORK>
1)		WORDX <Name to call fork by>
LINE 6, PAGE 14
2)	.NAME::	NOISE <CURRENT FORK AS>
2)		WORDX <Name to call fork by>


LINE 12, PAGE 18
1)		LDB B,[POINT 7,ATMBUF,6]
LINE 12, PAGE 14
2)		CAIN A,.FHSLF		;CM236 Trying to name .FHSLF?
2)		 ERROR <Illegal to name fork 0>	;CM236 Yes, complain (can't work
2)					; because there is no FRKTAB entry for fork
2)					; 0.  There should be...)
2)		LDB B,[POINT 7,ATMBUF,6]


LINE 16, PAGE 18
1)		MOVEI A,FRKNMS		;FORK NAME TABLE
1)		HRRO B,.FKNAM(Q1)	;POINT TO CURRENT NAME
1)		TBLUK			;LOOK UP NAME IN TABLE
1)		TXNN B,TL%EXM		;MATCH?
1)		 JRST NEWNAM		;NOT IN TABLE, STRANGE
1)		HRRZ Q1,(A)		;GET ADDRESS OF FORK BLOCK
1)		LOAD C,FKFLAG,(Q1)	;GET FLAGS
1)		TXNE C,FN%NAT!FN%ATT	;ARE THERE ATTRIBUTES TO THIS NAME?
1)		 CALLRET SETNAM		;YES. GO DO THE WORK
1)	;
1)	;EITHER THE FORK NAME ISN'T IN THE TABLE, WHICH SHOULDN'T HAPPEN, OR THE
1)	;FORK DOESN'T HAVE ANY ATTRIBUTES WORTH PRESERVING.
1)	;
1)	NEWNAM:	MOVE A,FORK		;GET FORK
1)		MOVE Q1,SLFTAB(A)	;POINT TO FORK DATA BLOCK
1)		CALL DELNAM		;DELETE OLD NAME
LINE 20, PAGE 14
2)		CALL DELNAM		;DELETE OLD NAME


LINE 1, PAGE 19
1)	^L
1)	;CHANGE THE NAME OF A FORK THAT HAS ATTRIBUTES SET. SAVE THE ATTRIBUTES OF
1)	;THE OLD FORK AND THEN CALL DELNAM TO LOSE THE NAME. THEN CALL ADDNAM TO
1)	;PUT THE NEW NAME IN THE TABLE. IF THE NEW NAME MATCHES A FORK NAME THAT
1)	;HAS ATTRIBUTES BUT DOES NOT EXIST, USE THE ATTRIBUTES OF THE NEW NAME AND
1)	;TELL THE USER WHAT THE NEW ATTRIBUTES ARE. IF NOT, RESTORE THE ATTRIBUTES
1)	;OF THE OLD NAME TO THE NEW NAME.
1)	

; SRC:<6-EXEC>EXECP.MAC.16 & EXECP.MAC.1 25-Jul-85 2311	PAGE 31


1)	SETNAM:	STKVAR <OLDATB>
1)		MOVE A,Q1		;GET ADDRESS OF FORK BLOCK IN A
1)		CALL SAVATT		;SAVE ATTRIBUTES OF OLD NAME
1)		MOVEM A,OLDATB		;SAVE ADDRESS OF OLD ATTRIBUTE BLOCK
1)		MOVE A,FORK		;GET FORK
1)		MOVE Q1,SLFTAB(A)	;POINT TO FORK DATA BLOCK
1)		CALL DELNAM		;DELETE OLD NAME
1)		MOVEI A,FRKNMS		;POINT TO TABLE
1)		HRROI B,ATMBUF		;POINT TO NAME
1)		TBLUK			;CHECK EXISTS ALREADY
1)		TXNN B,TL%EXM		;EXACT MATCH?
1)		 JRST NOATT		;NO. THEN IT CAN'T HAVE ATTRIBUTES
1)		HRRZ B,(A)		;GET ADDRESS OF FORK BLOCK
1)		LOAD C,FKFLAG,(B)	;GET FLAGS
1)		LOAD D,FKHAN,(B)	;GET FORK HANDLE
1)		SKIPG D			;IS THE FORK NOT ACTIVE?
1)		 TXNN C,FN%NAT		;AND ARE THERE ATTRIBUTES TO THIS NAME?
1)		  SKIPA			;FORK ACTIVE OR NO ATTRIBUTES
1)		JRST NEWATT		;NOT ACTIVE AND ATTRIBUTES. GO HANDLE
1)	NOATT:	MOVE A,FORK		;GET FORK HANDLE IN A
1)		HRROI B,ATMBUF		;POINT TO NEW NAME
1)		CALL ADDNAM		;ADD IT TO TABLE(S)
1)		MOVE A,OLDATB		;GET ADDRESS OF OLD ATTRIBUTE BLOCK
1)		MOVE B,FORK		;GET CURRENT FORK NUMBER
1)		CALL RSTATT		;RESTORE THEM
1)		RET			;DONE
1)	^L
1)	;HERE IF THE FORK NAME IS ALREADY KEPT (BY 'SET PROGRAM') AND IS NOT YET
1)	;ACTIVE.
1)	
1)	NEWATT:	MOVE A,OLDATB		;GET ADDRESS OF OLD ATTRIBUTE BLOCK
1)		CALL RETATT		;RETURN ATTRIBUTE BLOCK
1)		MOVE A,FORK		;GET FORK HANDLE IN A
1)		HRROI B,ATMBUF		;POINT TO NEW NAME
1)		CALL ADDNAM		;ADD IT TO TABLE(S)
1)		MOVE A,FORK		;GET FORK HANDLE
1)		MOVE A,SLFTAB(A)	;GET ADDRESS OF FORK TABLE
1)		HRRZ A,.FKNAM(A)	;GET ADDRESS OF FORK NAME
1)		HRLI A,440700		;MAKE BYTE POINTER
1)		ETYPE <[Assuming attributes of %1M]>
1)		RET			;DONE
1)	
1)	^L
1)	;SAVATT
1)	;
1)	;SAVE THE ATTRIBUTES OF A FORK IN A FORK BLOCK.
1)	;CALL:
1)	;	A/	ADDRESS OF FORK BLOCK
1)	;RETURNS:
1)	;	+1:	ALWAYS, ADDRESS OF BLOCK IN A
1)	;

; SRC:<6-EXEC>EXECP.MAC.16 & EXECP.MAC.1 25-Jul-85 2311	PAGE 32


1)	SAVATT:	STKVAR <FBLOCK>
1)		MOVEM A,FBLOCK		;SAVE ADDRESS OF BLOCK
1)		CALL PIOFF		;TURN OFF ^C WHILE PLAYING IN FREE SPACE
1)		CALL GETFBK		;GET A NEW FORK BLOCK
1)		HRL B,FBLOCK		;GET ADDRESS OF OLD BLOCK
1)		HRR B,A			;ADDRESS OF NEW BLOCK
1)		BLT B,FKTLEN-1(A)	;SAVE THE OLD BLOCK
1)		CALL PION		;DONE. TURN ^C BACK ON
1)		RET			;AND RETURN
1)	^L
1)	;RSTATT
1)	;
1)	;RESTORES THE ATTRIBUTES OF A FORK BLOCK FROM A GIVEN BLOCK
1)	;CALL:
1)	;	A/	ADDRESS OF BLOCK TO RESTORE FROM
1)	;	B/	FORK
1)	;RETURNS:
1)	;	+1:	ALWAYS
1)	;
1)	RSTATT:	STKVAR <OBLOCK>
1)		MOVEM A,OBLOCK		;SAVE OLD BLOCK ADDRESS
1)		MOVE Q1,SLFTAB(B)	;POINT TO FORK DATA BLOCK
1)		MOVEI A,FRKNMS		;FORK NAME TABLE
1)		HRRO B,.FKNAM(Q1)	;POINT TO NAME
1)		TBLUK			;LOOK UP NAME IN TABLE
1)		TXNN B,TL%EXM		;MATCH?
1)		 JRST REMBLK		;BAD. FORK WILL HAVE NO NAME
1)		HRRZ A,(A)		;GET ADDRESS OF FORK BLOCK
1)		LOAD C,FKHAN,(A)	;REMEMBER FORK HANDLE
1)		HRL B,OBLOCK		;GET ADDRESS OF OLD BLOCK
1)		HRR B,A			;AND ADDRESS OF NEW BLOCK
1)		BLT B,FKTLEN-1(A)	;RESTORE THE ATTRIBUTES
1)		STOR C,FKHAN,(A)	;RESTORE FORK HANDLE
1)		LOAD B,FKFLAG,(A)	;GET FORK FLAGS
1)		TXZ B,FN%NAT		;TURN OFF PERMANENT ATTRIBUTE FLAG
1)		TXO B,FN%ATT		;TURN ON TEMPORARY ATTRIBUTE FLAG
1)		STOR B,FKFLAG,(A)	;RESTORE FLAG WORD
1)	REMBLK:	MOVE A,OBLOCK		;GET ADDRESS OF OLD BLOCK
1)	
1)	;ENTRY POINT TO RELEASE BLOCK WITHOUT RESTORING ATTRIBUTES. TAKES ADDRESS
1)	;OF BLOCK IN A
1)	
1)	RETATT:	MOVEI B,FKTLEN		;GET LENGTH OF BLOCK
1)		CALL RETBUF		;RELEASE IT
1)		RET			;DONE
1)	
1)	^L
1)	;KEEP A FORK
LINE 24, PAGE 14
2)	;KEEP A FORK


; SRC:<6-EXEC>EXECP.MAC.16 & EXECP.MAC.1 25-Jul-85 2311	PAGE 33



LINE 6, PAGE 24
1)		MOVX B,FK%KPT		;LIGHT FLAG SO ANNKEP DOESN'T ANNOUNCE ANYTHING
1)		IORM B,SLFTAB(A)
1)	IFE STANSW,<
1)		CALLRET ANNKEP		;PUT FORK'S NAME IN TABLE OF KEPT FORKS
1)	>;IFE STANSW
1)	IFN STANSW,<
1)		RET			;ONLY AUTO-KEPT GO IN TABLE
1)	>;IFN STANSW
1)	
LINE 28, PAGE 14
2)	CS,<	HLRZ B,SLFTAB(A)	;EM100  Get superior
2)		CAIN B,.FHSLF		;EM100 Should be self...
2)		 ERROR <Can't keep non-top-level fork>> ;EM100
2)		MOVX B,FK%KPT		;LIGHT FLAG SO ANNKEP DOESN'T ANNOUNCE ANYTHING
2)		IORM B,SLFTAB(A)
2)	CS,<	CAME A,UDFORK		;EM85 Is this under a debugger?
2)		 CALLRET ANNKEP		;EM85 Nope... Continue
2)		SKIPLE A,@DBFORK	;EM85 Get debugger fork
2)		 IORM B,SLFTAB(A)>	;EM85 And keep it as well
2)		CALLRET ANNKEP		;PUT FORK'S NAME IN TABLE OF KEPT FORKS
2)	


LINE 11, PAGE 25
1)	$MERGE:	STKVAR <MERJFN,<MERENT,2>,MERSEC,MEROVL>
1)		MOVEM A,MERJFN		;SAVE PROGRAM BEING MERGED
1)		MOVEM B,MERSEC		;AND SECTION NUMBER
1)		MOVEM C,MEROVL		;AND OVERLAY FLAG
1)		SKIPGE D,FORK		;SKIP IF EXEC HAS INFERIOR FORK
1)		JRST $GET2		;NO FORK, CREATE ONE, GET PROG, USE ITS ENTRY.
1)		MOVE A,D		;FORK HANDLE TO A
1)		CALL GETENT		;GET ENTRY VECTOR
LINE 11, PAGE 15
2)	$MERGE:	STKVAR <MERJFN,<MERENT,2>,MERSEC>
2)		MOVEM A,MERJFN		;REMEMBER PROGRAM BEING MERGED
2)		MOVEM B,MERSEC		;REMEMBER SECTION NUMBER
2)		SKIPGE C,FORK		;SKIP IF EXEC HAS INFERIOR FORK
2)		JRST $GET2		;NO FORK, CREATE ONE, GET PROG, USE ITS ENTRY.
2)		MOVE A,C		;FORK HANDLE TO A
2)		CALL GETENT		;GET ENTRY VECTOR


; SRC:<6-EXEC>EXECP.MAC.16 & EXECP.MAC.1 25-Jul-85 2311	PAGE 34



LINE 22, PAGE 25
1)		MOVE C,MEROVL
1)		CALL $GET2		;GET PROGRAM
LINE 21, PAGE 15
2)		CALL $GET2		;GET PROGRAM


LINE 31, PAGE 25
1)	;Returns:	A/ JFN
1)	;		B/ -1 or section to use
1)	;		C/ 0==don't overlay, -1==overlay
1)	
LINE 29, PAGE 15
2)	;Returns:	A/	jfn
2)	;		B/	-1 or section to use
2)	


LINE 40, PAGE 25
1)	IFN STANSW,<
1)		SETZM STAYF		;ASSUME PROGRAM RUNS IN FOREGROUND
1)	>;IFN STANSW
1)		CALL GSWIS		;GET SWITCHES (INTO B AND C)
1)		MOVE A,SGJFN		;RETURN JFN IN A
LINE 37, PAGE 15
2)		CALL GSWIS		;GET SWITCHES
2)		MOVE B,A		;RETURN SECTION IN B
2)		MOVE A,SGJFN		;RETURN JFN IN A


LINE 49, PAGE 25
1)	;Returns:	B/ -1 or special section
1)	;		C/ 0==don't overlay, -1==overlay
1)	
1)	GSWIS:	TRVAR <USESEC,OVERLY>
1)		SETZM OVERLY		;SAY DON'T OVERLAY
1)		SETOM USESEC		;SAY NO SPECIAL SECTION TO USE
1)	GSWIS1:	MOVEI B,[FLDDB. .CMSWI,,GETSWI,,,[
1)			 FLDDB. .CMCFM]]
1)		SKIPL USESEC		;HAS THE USE-SECTION SWITCH BEEN USED?
1)		MOVEI B,[FLDDB. .CMSWI,,GETSW2,,,[
1)			 FLDDB. .CMCFM]] ;YES - DON'T ALLOW IT AGAIN
1)		CALL FLDSKP		;SEE WHAT'S BEING TYPED
1)		 CMERRX
1)		LOAD D,CM%FNC,.CMFNP(C)
1)		CAIE D,.CMSWI		;SWITCH?
1)		JRST GSWIS2		;NO - RETURN WITH THE RIGHT VALUES
1)		CALL GETKEY		;YES - SEE WHICH ONE
1)		CALL (P3)		;EXECUTE THE SWITCH

; SRC:<6-EXEC>EXECP.MAC.16 & EXECP.MAC.1 25-Jul-85 2311	PAGE 35


1)		JRST GSWIS1		;GET MORE INPUT
1)	
1)	GSWIS2:	MOVE B,USESEC		;RETURN -1 OR SECTION IN B
1)		MOVE C,OVERLY		;RETURN OVERLAY/DON'T OVERLAY FLAG
1)		RET
LINE 44, PAGE 15
2)	;Returns:	A/	-1 or special section
2)	
2)	GSWIS:	TRVAR <USESEC>
2)		SETOM USESEC		;SAY NO SPECIAL SECTION TO USE
2)	;**;[718] ADD 3 LINES AT GSWIS:+2L	TAM	30-MAR-82
2)		SKIPE MONVER		;[718] VERSION 5 OR LATER?
2)		JRST [	CONFIRM		;[718] NO, JUST CONFIRM
2)			JRST GET4]	;[718] AND RETURN -1 IN A
2)	GET3:	MOVEI B,[FLDDB. .CMSWI,,GETSWI,,,[
2)			 FLDDB. .CMCFM]]
2)		CALL FLDSKP		;SEE WHAT'S BEING TYPED
2)		 CMERRX
2)		LOAD D,CM%FNC,.CMFNP(C)
2)		CAIN D,.CMSWI		;SWITCH?
2)		JRST [	CALL GETKEY	;YES, SEE WHICH ONE
2)			CALL (P3)	;EXECUTE THE SWITCH
2)			JRST GET3]	;GET MORE INPUT
2)	;**;[718] ADD A LABEL AT GET3:+9L	TAM	30-MAR-82
2)	GET4:	MOVE A,USESEC		;[718] RETURN -1 OR SECTION IN A
2)		RET


LINE 76, PAGE 25
1)	IFN STANSW,<
1)		T BACKGROUND,,GBACK
1)	>;IFN STANSW
1)		T OVERLAY,,GOVER
1)		T USE-SECTION:,,GUSE
1)		TEND
1)	
1)	GETSW2:	TABLE			;SWITCHES WHEN /USE-SEC ALREADY USED
1)	IFN STANSW,<
1)		T BACKGROUND,,GBACK
1)	>;IFN STANSW
1)		T OVERLAY,,GOVER
1)		TEND
1)	
1)	IFN STANSW,<
1)	GBACK:	SETOM STAYF		;STAY AT COMMAND LEVEL
1)		RET			;RETURN TO CALLER
1)	
1)	;R AND RUN RETURN HERE BEFORE JOINING THE MAIN START CODE TO RESET
1)	;THE PRIMARY JFNS IF /BACKGROUND WAS SPECIFIED.  THIS KLUDGE DEPENDS
1)	;UPON STAYF BEING CLEARED BEFORE THE GET SWITCHES ARE PARSED, AND THEN
1)	;NOT BEING CLOBBERED BEFORE REACHING THE START CODE

; SRC:<6-EXEC>EXECP.MAC.16 & EXECP.MAC.1 25-Jul-85 2311	PAGE 36


1)	RNBACK:	SKIPN STAYF		;WANTS TO RUN IN THE BACKGROUND
1)		 JRST ..STRT		;NO, JOIN START CODE NOW
1)		HRLOI Q1,677777		;Q1 CONTAINS JFNS FOR RUNNING IN BACKGROUND
1)		CALL .CONT6		;RESET OUR PRIMARY JFNS
1)		JRST STR1		;JOIN MAIN START CODE HERE
1)	>;IFN STANSW
1)	
1)	GOVER:	SETOM OVERLY		;SAY NEW STUFF CAN OVERLAY THE EXISTING STUFF
1)		RET			;DONE
1)	
LINE 68, PAGE 15
2)		T USE-SECTION:,,GUSE
2)		TEND
2)	


LINE 14, PAGE 26
1)	.R::	NOISE <PROGRAM>
1)	IFN STANSW,<
1)		CONSTG			;DECLARE SOME STORAGE
1)		PUSH P,[RNBACK]		;FIX UP RETURN IN CASE WE RUN IN THE BACKGRND
1)	>;IFN STANSW
1)		MOVEI A,[ASCIZ /SYS:/]
1)		CALL GET1S		;READ PROGRAM NAME AND SWITCHES
1)	IFE STANSW,<
1)		PUSH P,[..STRT]		;SET UP TO START AFTER GET
1)	>;IFE STANSW
1)		JRST GET1		;JOIN GET
LINE 14, PAGE 16
2)	.BR::	PUSH P,[BSTRT]		;EM51
2)		CALL .CBAC2		;EM51
2)		CAIA			;EM51
2)	
2)	.R::	PUSH P,[..STRT]		;EM51 SET UP TO START AFTER GET
2)		NOISE <PROGRAM>
2)		MOVEI A,[ASCIZ /SYS:/]
2)		CALL GET1S		;READ PROGRAM NAME AND SWITCHES
2)		JRST GET1		;JOIN GET


LINE 28, PAGE 26
1)	.RUN::	
1)	IFE STANSW,<
1)		PUSH P,[..STRT]		;SET RETURN TO JOIN "START" COMMAND,
1)					;FALL INTO "GET".
1)	>;IFE STANSW
1)	IFN STANSW,<
1)		CONSTG			;DECLARE SOME STORAGE
1)		PUSH P,[RNBACK]		;FIX UP RETURN IN CASE WE RUN IN THE BACKGRND
1)	>;IFN STANSW
1)	

; SRC:<6-EXEC>EXECP.MAC.16 & EXECP.MAC.1 25-Jul-85 2311	PAGE 37


LINE 26, PAGE 16
2)	.BRUN::	PUSH P,[BSTRT]		;EM51
2)		CALL .CBAC2		;EM51
2)		CAIA			;EM51
2)	
2)	.RUN::	PUSH P,[..STRT]		;SET RETURN TO JOIN "START" COMMAND,
2)					;FALL INTO "GET".
2)	


LINE 51, PAGE 26
1)		SETO C,			;FORCE OVERLAY FLAG
1)		POP P,B			;RESTORE SECTION
LINE 46, PAGE 16
2)		POP P,B			;RESTORE SECTION


LINE 5, PAGE 27
1)	;Accepts:	A/ JFN
1)	;		B/ -1 or special section
1)	;		C/ 0==don't overlay, -1==overlay
1)	
1)	$GET0::	SETO B,			;SPECIAL ENTRY TO FORCE NO SPECIAL SECTION
1)	$GET2::	STKVAR <GETJFN,GETSEC,GETOVL,<GBLK,1+.GBASE>>
1)	
1)	;IF THERE IS NO INFERIOR FORK, CREATE ONE.
1)	
1)		MOVEM A,GETJFN		;SAVE WHICH FILE TO GET
1)		MOVEM B,GETSEC		;AND WHICH SECTION TO USE
1)		MOVEM C,GETOVL		;AND THE OVERLAY FLAG
1)		SKIPL FORK
LINE 5, PAGE 17
2)	;Accepts:	A/	jfn
2)	;		B/	-1 or special section
2)	
2)	$GET0::	HRROI B,-1		;SPECIAL ENTRY TO FORCE NO SPECIAL SECTION
2)	$GET2::	STKVAR <GETJFN,GETSEC,<GBLK,1+.GBASE>>
2)	
2)	;IF THERE IS NO INFERIOR FORK, CREATE ONE.
2)	
2)		MOVEM A,GETJFN		;REMEMBER WHICH FILE TO GET
2)		MOVEM B,GETSEC
2)	   REPEAT 0,<			;ELIMINATE ONE BAD IDEA
2)		CALL PNTMES		;ALWAYS MAKE SURE SYSTEM MESSAGES HAVE
2)			;BEEN PRINTED BEFORE ALLOWING ANY PROGRAMS TO BE RUN.
2)			;THIS PREVENTS PROBLEM OF SYSTEMS THAT START UP SPECIAL
2)			;PROGRAMS FROM NEVER SEEING SYSTEM MESSAGES, BECAUSE
2)			;LOGIN.CMD OR COMAND.CMD RUNS PROGRAM.
2)	   >
2)		SKIPL FORK


; SRC:<6-EXEC>EXECP.MAC.16 & EXECP.MAC.1 25-Jul-85 2311	PAGE 38



LINE 30, PAGE 27
1)		SKIPN GETOVL		;WANT TO PREVENT OVERLAYING EXISTING STUFF?
1)		TXO A,GT%NOV		;YES - SET THAT FLAG
1)		SKIPGE B,GETSEC		;ANY SPECIAL SECTION?
LINE 35, PAGE 17
2)		SKIPGE B,GETSEC		;ANY SPECIAL SECTION?


LINE 10, PAGE 28
1)	IFE STANSW,<
1)		 JRST [	PUSH P,A	;SAVE ERROR CODE
LINE 10, PAGE 18
2)		 JRST [	PUSH P,A	;SAVE ERROR CODE


LINE 17, PAGE 28
1)	>;IFE STANSW
1)	IFN STANSW,<
1)		 ERCAL   [PUSH P,A		; SAVE ERROR CODE
1)			  MOVEI A,.FKSZE
1)			  MOVE B,Q1		; BLOCK ADDRS
1)			  CALL RETBUF		; RETURN BLOCK
1)			  POP P,A		; RESTORE CODE
1)			  JRST JERR]
1)	>;IFN STANSW
1)		MOVEM A,FORK		;SAVE AS CURRENT FORK
LINE 16, PAGE 18
2)		MOVEM A,FORK		;SAVE AS CURRENT FORK


LINE 39, PAGE 28
1)	IFE STANSW,<
1)		SKIPN BATCHF		;DON'T ALLOW ^C UNDER BATCH
LINE 29, PAGE 18
2)	REPEAT 0,<			;CM318
2)		SKIPN BATCHF		;DON'T ALLOW ^C UNDER BATCH


LINE 48, PAGE 28
1)	>;IFE STANSW
1)	IFN STANSW,<
1)		MOVE A,FORK		;GET CURRENT CAPABILITIES
1)		RPCAP
1)		SKIPN BATCHF		;DON'T ALLOW ^C CAPABILITY UNDER BATCH
1)		 SKIPE CCFLAG		;OR IF USER DISALLOWS IT
1)		  TXZ B,SC%CTC
1)	IFE NICSW,<			;[NIC1030] ALWAYS PASS DOWN CAPABILITIES 
1)		SKIPE C,PRVENF		;IF ENABLED, PASS DOWN CAPABILITIES
1)		 SKIPA C,B		;USER IS ENABLED

; SRC:<6-EXEC>EXECP.MAC.16 & EXECP.MAC.1 25-Jul-85 2311	PAGE 39


1)		  TRZ B,-1		;NOT ENABLED, DISALLOW FORK EPCAP
1)	>;IFE NICSW
1)		EPCAP
1)	>;IFN STANSW
1)		MOVSI B,.FHSLF		;FLAG US AS OWNING FORK
1)		MOVEM B,.FKOWN(Q1)
1)		SETOM .FKEDL(Q1)	;NO LOCATION E/D YET
1)		SETOM DDTSA(Q1)		;NO DDT START ADDRESS YET
1)		MOVSI B,ITTYMD		;SET INITIAL MODES
LINE 38, PAGE 18
2)	>				;CM318 end REPEAT 0
2)	
2)		MOVX B,SC%CTC		;CM318 Get ^C cap bit
2)		SKIPE BATCHF		;CM318 Under batch?
2)		ANDCAM B,C2PASS		;CM318 Yes, always disallow ^C
2)		MOVE B,C2PASS		;CM318 Get capabilities to pass to inferior
2)		CAME B,[-1]		;CM318 Pass them all?
2)		JRST [	MOVE A,FORK	;CM318 No, get current capabilities
2)			RPCAP%		;CM318
2)			AND B,C2PASS	;CM318 Restrict the ones he can enable
2)			AND C,C2PASS	;CM318 Likewise restrict the enabled ones
2)			EPCAP%		;CM318
2)			JRST .+1]	;CM318
2)		MOVSI B,.FHSLF		;FLAG US AS OWNING FORK
2)		MOVEM B,.FKOWN(Q1)
2)		SETOM .FKEDL(Q1)	;NO LOCATION E/D YET
2)		MOVSI B,ITTYMD		;SET INITIAL MODES


LINE 79, PAGE 28
1)	IFN STANSW,<
1)	;THAT DOESN'T SEEM TO BE RIGHT.  IT LOOKS LIKE TRAPPING FORK N
1)	;GETS YOU ALL ITS INFERIORS FOR FREE.
1)	;THIS ROUTINE NOW EXPECTS A FORK HANDLE IN AC1
1)	
1)	SETTRP::STKVAR <TRPERR,TRPFRK>
1)		MOVEM A,TRPFRK
1)	>;IFN STANSW
1)	
1)	IFE STANSW,<
1)	SETTRP::STKVAR <TRPERR>
1)	>;IFE STANSW
1)		SETZM TRPERR		;NO ERROR YET
1)		MOVEI C,JSBDEF		;TELL SYSTEM WHERE BIT TABLE IS
1)	IFE STANSW,<
1)		MOVEI A,.FHINF		;TELL SYSTEM WHAT FORK (ALL OUR INFERIORS)
1)	>;IFE STANSW
1)	IFN STANSW,<
1)		MOVE A,TRPFRK
1)	>;IFN STANSW
1)		HRLI A,.TFRAL		;FIRST REMOVE OLD SET SINCE .TFSET "OR"S

; SRC:<6-EXEC>EXECP.MAC.16 & EXECP.MAC.1 25-Jul-85 2311	PAGE 40


LINE 67, PAGE 18
2)	SETTRP::STKVAR <TRPERR>
2)		SETZM TRPERR		;NO ERROR YET
2)		MOVEI C,JSBDEF		;TELL SYSTEM WHERE BIT TABLE IS
2)		MOVEI A,.FHINF		;TELL SYSTEM WHAT FORK (ALL OUR INFERIORS)
2)		HRLI A,.TFRAL		;FIRST REMOVE OLD SET SINCE .TFSET "OR"S


LINE 107, PAGE 28
1)	IFE STANSW,<
1)		MOVEI A,.FHINF		;TELL SYSTEM WHAT FORK (ALL OUR INFERIORS)
1)	>;IFE STANSW
1)	IFN STANSW,<
1)		MOVE A,TRPFRK		;ONLY TRAP ONE FORK
1)	>;IFN STANSW
1)		HRLI A,.TFSPS		;SAY TO SET CHANNEL
LINE 79, PAGE 18
2)		MOVEI A,.FHINF		;TELL SYSTEM WHAT FORK (ALL OUR INFERIORS)
2)		HRLI A,.TFSPS		;SAY TO SET CHANNEL


LINE 87, PAGE 30
1)		TLNE B,37		;GOT AN EXTENDED ADDRESS?
1)		JRST DSFRK0		;YES - USE EXTENDED START
1)		SFORK			;NO - START THE FORK THE OLD WAY
1)		 ERJMP DSFRK1		;FAILED
1)		RET			;SUCCESS - DONE
1)	
1)	DSFRK0:	LSHC B,-^D36		;GET PC INTO AC B AND CLEAR FLAGS IN AC C
1)		XSFRK%			;START THE FORK EXTENDEDLY
1)		 ERJMP DSFRK1		;FAILED
LINE 87, PAGE 20
2)		LSHC B,-^D36		;CLEAR FLAGS AND GET PC INTO C
2)		XSFRK%			;START THE FORK
2)		 ERJMP DSFRK1		;FAILED


LINE 101, PAGE 30
1)		ERROR <Start addresses larger than 18 bits illegal>
1)	
LINE 95, PAGE 20
2)	;**;[717] REPLACE 1 LINE WITH 5 AT DSFRK1:+3L	TAM	30-MAR-82
2)		MOVE A,RUNFK		;[717] FORK TO START
2)		MOVE B,C		;[717] PC INTO B FOR SFORK
2)		SFORK			;[717] START IT
2)		 ERCAL JERR		;[717]
2)		RET			;[717] OK
2)	


; SRC:<6-EXEC>EXECP.MAC.16 & EXECP.MAC.1 25-Jul-85 2311	PAGE 41



LINE 10, PAGE 31
1)		NOISE <on file>
LINE 10, PAGE 21
2)		SKIPGE FORK
2)		ERROR <No program>
2)		NOISE <on file>


LINE 37, PAGE 31
1)		SKIPGE FORK
1)		ERROR <No program>
1)		PUSH Q2,[0]		;TERMINATE TABLE
LINE 39, PAGE 21
2)		PUSH Q2,[0]		;TERMINATE TABLE


LINE 2, PAGE 32
1)	;SAVE (PAGES FROM) N (TO) N, (FROM) N (TO) N ... (ON) FILE
LINE 2, PAGE 22
2)	;CS52 *** Begin ***
2)	
2)	.DUMP::	SAVSTG
2)		SKIPGE A,FORK
2)		ERROR <No program>
2)		MOVEI B,SAVSTK		;Use SAVSTK to store inferior ACS
2)		RFACS%			;Get the inferior's acs
2)		 ERCAL CJERRE		;Lose...
2)		HRROI A,[ASCIZ/BUGACS/]
2)		CALL AVALUE		;Get value of BUGACS symbol
2)		 ERROR <BUGACS not defined>
2)		MOVE Q1,A		;Save the value for later
2)		CALL MAPPF		;Map the appropriate page
2)		 CALL CJERRE		;Quem?
2)		ANDX A,777		;Only want offset part
2)		CAILE A,760		;Make sure the ACs will fit
2)		 ERROR <BUGACS block crosses page boundary>
2)		ADDI A,PAGEN		;Make it a pointer into the mapped page
2)		MOVE B,A		;Make a copy
2)		HRLI A,SAVSTK		;Where the ACs are now
2)		BLT A,20(B)		;Copy ACs into BUGACS in the lower fork (PAGEN)
2)		NOISE <on file>
2)	        CALL SAVNMX
2)		JRST SAV2		;Join regular SAVE code
2)	
2)	;CS52 *** End ***
2)	
2)	;SAVE (PAGES FROM) N (TO) N, (FROM) N (TO) N ... (ON) FILE


; SRC:<6-EXEC>EXECP.MAC.16 & EXECP.MAC.1 25-Jul-85 2311	PAGE 42



LINE 15, PAGE 32
1)		MOVEI B,[FLDDB. .CMFIL,,,,,]
1)		CALL FLDSKP		;READ THE FILE NAME
1)		 CMERRX
1)	
1)		SKIPGE FORK		;PCL
1)		ERROR <No program>
1)		MOVEM B,SAVJFN		;PCL REMEMBER PROGRAM
1)		CALL SETSNM		;SET UP FILESPEC IN SAVFIL FOR CONFIRMATION MSG
1)		MOVEI Q2,-1+SAVSTK	;FORM STACK POINTER TO ARGUMENT LIST
LINE 42, PAGE 22
2)		MOVEI B,$SAVE		;CM156
2)		CALL FLDSKP		;READ THE FILE NAME
2)		 CMERRX
2)		LDB D,[331100,,(C)]	;CM156 See which was parsed
2)		CAIE D,.CMSWI		;CM156 Switch?
2)		JRST SAV1		;CM156 No, a file name
2)		CALL GETKEY		;CM156 Get jump address
2)		JRST (P3)		;CM156 Do specific processing routine
2)	
2)	SAV1:	SKIPGE FORK		;CM156
2)		ERROR <No program>
2)		MOVEM B,SAVJFN		;PCL REMEMBER PROGRAM
2)		CALL SETSNM		;SET UP FILESPEC IN SAVFIL FOR CONFIRMATION MSG
2)	SAV2:				;CS52 "Dump" joins here
2)		MOVEI Q2,-1+SAVSTK	;FORM STACK POINTER TO ARGUMENT LIST


LINE 77, PAGE 32
1)	IFE STANSW,<
1)		CALLRET OPNERR		;ANALYZE ERROR
1)	>;IFE STANSW
1)	IFN STANSW,<
1)		CALL OPNERR
1)		MOVE A,SAVJFN		;ABORT THE FILE
1)		TXO A,CZ%ABT
1)		CLOSF
1)		 NOP
1)		RET
1)	>;IFN STANSW
1)	
LINE 110, PAGE 22
2)		CALLRET OPNERR		;ANALYZE ERROR
2)	


; SRC:<6-EXEC>EXECP.MAC.16 & EXECP.MAC.1 25-Jul-85 2311	PAGE 43



LINE 2, PAGE 33
1)	
LINE 2, PAGE 23
2)	;START
2)	;DECODE AND CHECK SUBROUTINE ALSO USED BY REDIRECT/DETACH
2)	
2)	$START::SKIPGE A,FORK		;HANDLE OF INFERIOR FORK, OR -1
2)		ERROR <No program>
2)		CALL GETENT		;GET ENTRY VECTOR
2)		CAIGE B,1
2)		ERROR <No START address>
2)		RET
2)	


LINE 6, PAGE 33
1)		CONSTG			;ALLOCATE STORAGE
1)		SETZM STAYF
1)		MOVE A,FORK		;SET UP START FORK 
1)		MOVEM A,UFORK		;USE UFORK UNTIL CR SEEN FOR CONFIRMATION
1)	.STA1: 	MOVEI B,$STA1 		;INCLUDES $STA1 AND $CON2
1)		TLOE Z,F1		;FIRST OR SECOND TIME THRU ?
1)		 MOVEI B,$CON2		;SECOND TIME.
1)		MOVEI B,$STA1 		;START COMND FUNCTIONS
1)	 	CALL FLDSKP		;PARSE LINE
1)	IFE STANSW,<
1)		CMERRX
1)	>;IF STANSW
1)	IFN STANSW,<
1)	;PARSE SYMBOLIC ADDRESSES, JUST LIKE WE DID IN THE 5.X EXECS!
1)		IFNSK.
1)		  ADDRX <>		;PARSE A SYMBOLIC START ADDRESS
1)		   ERROR <Invalid address, switch, or not confirmed>	;GIVE AN ERROR
1)		  MOVEM B,STADR		;SAVE START ADDRESS 
1)		  TLO Z,F2		;FLAG THE FACT THAT WE HAVE AN ADDRESS
1)		  JRST .STA1		;JOIN MAIN START CODE
1)		ENDIF.
1)	>;IFN STANSW
1)		LOAD D,CM%FNC,.CMFNP(C)	;GET FUNCTION CODE
1)		CAIN D,.CMCFM		;CR?
1)		 JRST .STRT2		;YES 
1)		CAIN D,.CMCMA		;GOT A COMMA ?
1)		 JRST .STRT3		;YES
1)		CAIN D,.CMSWI		;SWITCH SEEN?
1)		 JRST .STRT1		;YES - CHECK SUBCOMMANDS
1)		MOVEM B,STADR		;SAVE START ADDRESS 
1)		TLO Z,F2		;FLAG THE FACT THAT WE HAVE AN ADDRESS
1)		JRST .STA1
1)	

; SRC:<6-EXEC>EXECP.MAC.16 & EXECP.MAC.1 25-Jul-85 2311	PAGE 44


1)	
1)	;Entries from above:
1)	;
1)	; .STRT1 called when a switch has been typed 
1)	; .STRT2 called when a confirm has been typed.
1)	; .STRT3 called when a comma has been typed.
1)	; .STRT4 called to make subcommands work on the same line as the comma.
1)	
1)	
1)	.STRT1:	CALL .CONT3		;LET THE CONTINUE CODE DISPATCH
1)	.STRT2:	TLNN Z,F2		;USER GIVE A START ADR ?
1)		IFSKP. 
1)		 MOVE A,STADR		;YES
1)		 JRST .GOTO		;DO START THERE.
1)		ENDIF.
1)		CALL $START		;GET ADDRS
1)		JRST STR1
1)	
1)	.STRT3:	CRRX <Carriage return to enter subcommands>
1)		 JRST .STRT4
1)		SUBCOM $CMODE		;MAKES SUBCOMMANDS WORK
1)		CALL .CONT4		;DO THE WORK
1)		JRST .STRT2
1)	
1)	.STRT4:	KEYWD $CMODE		;MAKES COMMA MF-KEYWORD WORK
1)		 0
1)		 CMERRX
1)		CALL 0(P3)		;DO THE SUBCOMMAND
1)		CALL .CONT4		;DO THE WORK
1)		JRST .STRT2
1)	
1)	
1)	
1)	;Decode and check subroutine also used by REDIRECT/DETACH
1)	$START::SKIPGE A,FORK		;HANDLE OF INFERIOR FORK, OR -1
1)		ERROR <No program>
1)		CALL GETENT		;GET ENTRY VECTOR
1)		CAIGE B,1
1)		ERROR <No START address>
1)		RET
1)	
1)	
1)	;"RUN" JOINS HERE. REDIRECT/DETACH (AND) START  JOINS HERE
1)	
LINE 15, PAGE 23
2)		SETZM STAYF
2)		COMMAX <Comma to enter subcommands,
2)	Octal start address
2)	or Confirm with carriage return>
2)		 JRST .STRT0		;NO COMMA
2)		CONSTG			;ALLOCATE STORAGE

; SRC:<6-EXEC>EXECP.MAC.16 & EXECP.MAC.1 25-Jul-85 2311	PAGE 45


2)		MOVE A,FORK		;ASSUME CURRENT FORK UNLESS CHANGED
2)		MOVEM A,UFORK
2)		CALL .CONT3		;HANDLE SUB-COMMANDS (SET MODE)
2)		JRST .STRT1		;COMMON CODE
2)	
2)	.STRT0:	CRRX <Octal start address
2)	or Confirm with carriage return>
2)		 CAIA			;NOT JUST CR TYPED
2)		JRST .STRT1		;JUST CR, START AT REAL START ADDRESS
2)		ADDRX <Octal start address>
2)		 ERROR <Invalid address>
2)		MOVE A,B		;GET START ADDRESS INTO A
2)		CONFIRM
2)		JRST .GOTO
2)	
2)	.STRT1:	CALL $START		;GET ADDRS
2)		JRST STR1
2)	
2)	;Begin EM51 "Brun" joins here
2)	BSTRT:	MOVEI A,.FHSLF
2)		GPJFN
2)		MOVE A,FORK
2)		HRRI B,.SIGIO
2)		SPJFN
2)		MOVX B,FK%BKG+FK%PRI
2)		IORM B,SLFTAB(A)
2)		SETOM STAYF
2)		CAIA
2)	;End EM51
2)	
2)	;"RUN" JOINS HERE
2)	;REDIRECT/DETACH...(AND) START  JOINS HERE
2)	


LINE 102, PAGE 33
1)	WAITR:	
1)	IFN STANSW,<
1)		SKIPE RSPTR		;DON'T RSCAN IF NOT EXPLICITLY SET UP
1)	>;IFN STANSW
1)		CALL CRSCAN
1)	^L
LINE 73, PAGE 23
2)	WAITR:	CALL CRSCAN
2)	^L


; SRC:<6-EXEC>EXECP.MAC.16 & EXECP.MAC.1 25-Jul-85 2311	PAGE 46



LINE 21, PAGE 34
1)		SKIPN STAYF		;DON'T SET PROGRAM MODE IF STAYING AT COMMAND LEVEL
1)		CALL SETPRG		;SAY PROGRAM MODE
1)		TLO Z,RUNF		;MAKE ^C KNOW THAT FORK NEEDS TO BE FROZEN
1)	IFE STANSW,<
1)		SETZM PCWAIT		;PCL Fork has not gotten hungry yet
1)	>;IFE STANSW
1)		MOVE A,RUNFK		;FORK WE ARE REALLY RUNNING
LINE 21, PAGE 24
2)		 ERCAL CJERRE		;CM189 Allow for failure
2)		SKIPN STAYF		;DON'T SET PROGRAM MODE IF STAYING AT COMMAND LEVEL
2)		CALL SETPRG		;SAY PROGRAM MODE
2)		TLO Z,RUNF		;MAKE ^C KNOW THAT FORK NEEDS TO BE FROZEN
2)		MOVE A,RUNFK		;FORK WE ARE REALLY RUNNING


LINE 40, PAGE 34
1)		SKIPN PCWAIT		;PCL Do not wait if we have just received PSI
1)	WFORKX::WFORK			;PCL WAIT.  WFORKX: M-U-S-T BE ON WFORK
1)		FFORK			;FREEZE IT IMMEDIATELY
1)	NOWAIT:
1)	IFN STANSW,<
1)		SETZM PCWAIT		;CM156
1)	>;IFN STANSW
1)		MOVE A,RUNFK		;HANDLE TO A (FORK JUST RUN)
LINE 38, PAGE 24
2)		SKIPN PCWAIT		;CM156 Do not wait if we have just received PSI
2)	WFORKX::WFORK			;PCL WAIT.  WFORKX: M-U-S-T BE ON WFORK
2)		FFORK			;FREEZE IT IMMEDIATELY
2)	NOWAIT:	SETZM PCWAIT		;CM156
2)		MOVE A,RUNFK		;HANDLE TO A (FORK JUST RUN)


LINE 67, PAGE 34
1)	IFE STANSW,<
1)		SKIPN PCPRGR		;PCL Not if controlled program
1)	>;IFE STANSW
1)	IFN STANSW,<
1)		TMNN FK%INV,SLFTAB(A)	;CM156 If not controlled program
1)	>;IFN STANSW
1)		CALL LTTYMD		;..
LINE 62, PAGE 24
2)	;	SKIPN PCPRGR		;PCL Not if controlled program
2)		TMNN FK%INV,SLFTAB(A)	;CM156 If not controlled program
2)		CALL LTTYMD		;..


; SRC:<6-EXEC>EXECP.MAC.16 & EXECP.MAC.1 25-Jul-85 2311	PAGE 47



LINE 77, PAGE 34
1)		MOVEI B,.RFSFL+1	;SET UP FOR LONG FORMAT RFSTS
1)		MOVEM B,LRFSTS+.RFCNT
LINE 68, PAGE 24
2)	CC,<	MOVEI B,.RFSFL+1>	;CS44 Set up for long format RFSTS
2)	CS,<	MOVEI B,.RFSTA+1>	;CS44 Set up for long format RFSTS
2)		MOVEM B,LRFSTS+.RFCNT


LINE 99, PAGE 34
1)	IFE STANSW,<
1)		SKIPE PCPRGR		;PCL Controlled program?
1)	>;IFE STANSW
1)	IFN STANSW,<
1)		TMNE FK%INV,SLFTAB(A)	;CM156 Controlled program?
1)	>;IFN STANSW
1)		RET			;PCL Yes, leave it at that
LINE 91, PAGE 24
2)	;	SKIPE PCPRGR		;PCL Controlled program?
2)		TMNE FK%INV,SLFTAB(A)	;CM156 Controlled program?
2)		RET			;PCL Yes, leave it at that


LINE 111, PAGE 34
1)		CAIGE	C,3		;MIN ARG
1)		JRST	FRKTRN		;IGNORE
1)		HLRZ	A,1+PRBUF	;CHECK HEADER
1)		MOVE	B,PRBUF
LINE 99, PAGE 24
2)		JUMPE C,FRKTRN		;CM224 *** Start ***
2)		HLRZ A,PRBUF		;Check function
2)		JUMPE A,FRKCCL		;CCL function if zero
2)		HRRZ B,PRBUF		;Make sure RH zero
2)		JUMPN B,FRKIGN		;Not an advanced function
2)		CAIE A,1		;Keep fork and halt?
2)		JRST FRKKIL		;No
2)		MOVX B,FK%KPT		;Keep it
2)		SKIPLE A,FORK		;Assuming we have a fork
2)		IORM B,SLFTAB(A)
2)		JRST FRKIGN		;Clear off arguments and return
2)	
2)	FRKKIL:	CAIE A,2		;Kill the fork immediately?
2)		JRST FRKBCK		;No
2)		MOVE A,FORK		;Recover fork handle
2)		CALL KEFORK		;Kill it
2)		CALL NXTFRK		;CM224 Choose a new current fork if possible
2)	FRKKI1:	JRST FRKTRN		;EM47 Return
2)	
2)	FRKBCK:	CAIE A,3		;Continue in background

; SRC:<6-EXEC>EXECP.MAC.16 & EXECP.MAC.1 25-Jul-85 2311	PAGE 48


2)		JRST FRKIGN		;No, incomprehensible
2)		CALL PRCLR		;Clear arguments
2)		MOVSI Q1,.SIGIO		;Change input to signal
2)		SETOM STAYF		;Stay in Exec
2)		CALL .CONT6		;Adjust the fork status
2)		MOVX B,FK%BKG		;Set background
2)		IORM B,SLFTAB(A)	; flag
2)		RFSTS%			;Get PC back
2)		MOVE A,FORK
2)		TXO A,SF%CON		;Set continue bit
2)		SFORK%			;Continue it
2)		MOVE A,FORK		;And resume it
2)		RFORK%
2)		JRST FRKTRN		;Back to command parser
2)					;CM224 *** End ***
2)	FRKCCL:	HLRZ	A,1+PRBUF	;CHECK HEADER
2)		CAIGE	C,3		;MIN ARG
2)		JRST	FRKTRN		;IGNORE
2)		MOVE	B,PRBUF


LINE 131, PAGE 34
1)	FRKTRN:	MOVEI A,CMDIN2		;GO TO START OF PARSER
LINE 154, PAGE 24
2)	FRKIGN:	CALL PRCLR		;CM224 Clean off argument block
2)	FRKTRN:	MOVEI A,CMDIN2		;GO TO START OF PARSER


LINE 135, PAGE 34
1)		HRLI	A,.PRAST
LINE 159, PAGE 24
2)	PRCLR2:				;CM307 Enter here with fork handle in A
2)		HRLI	A,.PRAST


LINE 9, PAGE 35
1)			JRST WAITA]	;NOT EXPIRED, KEEP RUNNING FORK
1)		CAIN C,.RFTRP		;JSYS/UUO TRAP???
1)		 JRST [	MOVE B,LRFSTS+.RFPPC	;LOAD PC FOR USE WITH %Y
1)			ERROR <JSYS or UUO trap at %2Y>]
1)	IFE STANSW,<
1)		CAIN C,.RFIO		;PCL Waiting for I/O?
1)		SKIPN PCPRGR		;PCL Is it a controlled program?
1)		TRNA			;PCL No
1)		RET			;PCL Yes, the usual case
1)	>;IFE STANSW
1)	IFN STANSW,<
1)		TMNE FK%INV,SLFTAB(A)	;CM156 Controlled program
LINE 9, PAGE 25
2)			MOVEI A,WAITF	;NOT EXPIRED, KEEP RUNNING FORK
2)			RET]		;DISPATCH VIA WAITF, CLEANING STACK

; SRC:<6-EXEC>EXECP.MAC.16 & EXECP.MAC.1 25-Jul-85 2311	PAGE 49


2)		CAIN C,.RFTRP		;JSYS/UUO TRAP???
2)		 JRST [	MOVE B,LRFSTS+.RFPPC	;LOAD PC FOR USE WITH %Y
2)			ERROR <JSYS or UUO trap at %2Y>]
2)		TMNE FK%INV,SLFTAB(A)	;CM156 Controlled program


LINE 31, PAGE 35
1)	>;IFN STANSW
1)		CAIE C,.RFFPT		;FORCED TERMINATION (UNENABLED ERROR PSI)
LINE 25, PAGE 25
2)		CAIE C,.RFFPT		;FORCED TERMINATION (UNENABLED ERROR PSI)


LINE 59, PAGE 35
1)	IFE STANSW,<
1)	ERROR <Quota exceeded at %2Y>		;Chan 12
1)	>;IFE STANSW
1)	IFN STANSW,<
1)	ERROR <Disk quota exceeded at %2Y; try EXPUNGE and then CONTINUE>
1)	>;IFN STANSW
1)	ERROR <File error 4 interrupt at %2Y>	;Chan 13 "file condition 4"
LINE 52, PAGE 25
2)	ERROR <Quota exceeded at %2Y>		;Chan 12
2)	ERROR <File error 4 interrupt at %2Y>	;Chan 13 "file condition 4"


LINE 58, PAGE 36
1)		ETYPE <%@%[Fork %2M opening %1M for >
1)		MOVEI A,2		;GET TYPE OF ACCESS
LINE 58, PAGE 26
2)		ETYPE <%@%[Fork %2m opening %1m for >
2)		MOVEI A,2		;GET TYPE OF ACCESS


LINE 105, PAGE 36
1)		LOAD D,YFLD,JINSTR	;GET JSYS NUMBER
1)		LDB C,[POINT 9,JTAB(D),35] ;GET SECONDARY TABLE OFFSET
1)		JUMPE C,JNDF		;JUMP IF JSYS NOT DEFINED
1)		HLRO C,JTAB(C)		;GET POINTER TO JSYS RECORD
1)		AOS C			;INCREMENT TO JSYS NAME
1)		ETYPE <%@[%1M trap %2Y/ %3M Ac's 1-4: > ;TYPE NAME
1)		JRST ACLP
1)	JNDF:	ETYPE <%@[%1M trap %2Y/ JSYS %4a Ac's 1-4: > ;TYPE NUMBER
1)	
1)	ACLP:	MOVSI Q1,-4		;PREPARE TO LOOP FOR 4 AC'S
1)	NO0:	MOVEI A,1(Q1)		;GET AC TO READ CONTENTS OF
1)		CAIE A,1		;SEPARATOR BETWEEN VALUES BUT NOT BEFORE FIRST
1)		TYPE <\ >
1)		CALL RANDOM
LINE 105, PAGE 26
2)		LOAD C,YFLD,JINSTR	;GET JSYS NUMBER

; SRC:<6-EXEC>EXECP.MAC.16 & EXECP.MAC.1 25-Jul-85 2311	PAGE 50


2)		HRRO C,JTAB(C)		;GET POINTER TO NAME OF JSYS
2)		ETYPE <%@[%1m trap %2Y/ %3M Ac's 1-4: >
2)		MOVSI Q1,-4		;PREPARE TO LOOP FOR 4 AC'S
2)	NO0:	MOVEI A,1(Q1)		;GET AC TO READ CONTENTS OF
2)		CAIE A,1		;SEPARATOR BETWEEN VALUES BUT NOT BEFORE FIRST
2)		PRINT "\"
2)		CALL RANDOM


LINE 143, PAGE 36
1)		MOVE A,REALF		;FIX FORK CELL
LINE 137, PAGE 26
2)		MOVE A,JHAN		;CM236 Get back handle of trapped fork
2)		SKIPN SLFTAB(A)		;CM236 One we know about?
2)		RFRKH%			;CM236 No, so free up fork handle
2)		 ERJMP .+1		;CM236 Ignore error
2)		MOVE A,REALF		;FIX FORK CELL


LINE 158, PAGE 36
1)	;HERE ON INFERIOR FORK TERMINATION INTERRUPT
LINE 156, PAGE 26
2)	
2)	;HERE ON INFERIOR FORK TERMINATION INTERRUPT


LINE 191, PAGE 36
1)	INFTR0:	
1)	IFE STANSW,<
1)		STKVAR <<TRFSTS,.RFSFL+1>,SRFPC>
1)	>;IFE STANSW
1)	IFN STANSW,<
1)	;NOTE THAT %Y WILL PRINT THE SYMBOLIC ADDRESS OF THE CURRENT FORK, SO WE
1)	;HAVE TO FOOL IT INTO THINKING THAT THE FORK WE SAY CRASHED IS CURRENT.
1)	;WE ARE A LEVEL 1 INTERRUPT SO WE DON'T HAVE TO WORRY ABOUT ANYONE ELSE
1)	;GETTING CONFUSED BY THE CHANGE...
1)	
1)		STKVAR <<TRFSTS,.RFSFL+1>,SRFPC,SAVFRK>
1)		SETZM SAVFRK		;NO CHANGE TO FORK YET
1)	>;IFN STANSW
1)		MOVSI Q1,-NFRKS		;LOOK AT ALL FORKS
LINE 190, PAGE 26
2)	INFTR0:	STKVAR <<TRFSTS,.RFSFL+1>,SRFPC>
2)		MOVSI Q1,-NFRKS		;LOOK AT ALL FORKS


; SRC:<6-EXEC>EXECP.MAC.16 & EXECP.MAC.1 25-Jul-85 2311	PAGE 51



LINE 239, PAGE 36
1)		MOVEI B,.FHSLF(Q1)	;FORM FORK HANDLE
1)		CAMN B,MICFRK		;IS THIS THE MIC?
1)		 JRST [	TXZ Q2,FK%BKG	;REMOVE FROM BACKGROUND
1)			MOVEM Q2,FRKTAB(Q1) ;STORE UPDATED STATUS
1)			JRST INFTR3]
1)	
1)	INFT2C:	TXZ Q2,FK%BKG		;NO LONGER BACKGROUND
LINE 226, PAGE 26
2)	MIC,<
2)		MOVEI B,.FHSLF(Q1)	;FORM FORK HANDLE
2)		CAMN B,MICFRK		;IS THIS THE MIC?
2)	REPEAT 0,<			;CU107 MIC HALT meants it wants reset
2)		 JRST [	TXZ Q2,FK%BKG	;REMOVE FROM BACKGROUND
2)			MOVEM Q2,FRKTAB(Q1) ;STORE UPDATED STATUS
2)			JRST INFTR3]
2)	   >;REPEAT 0			;CU107
2)		IFNSK.			;CU107 MIC halted, reset it
2)		 PUSH P,Q1		;CU107 save AOBJ pointer
2)		 CALL KMIC		;CU107 Kill MIC process
2)		 POP P,Q1		;CU107 restore handle
2)		 JRST INFTR3		;CU107 and continue the fork scan
2)		ENDIF.			;CU107
2)	>
2)	INFT2C:	TXZ Q2,FK%BKG		;NO LONGER BACKGROUND


LINE 274, PAGE 36
1)	IFN STANSW,<
1)		CAMN A,FORK		;IS IT THE CURRENT FORK?
1)		IFSKP.
1)		  EXCH A,FORK		;NO, SET IT AS CURRENT FORK
1)		  SKIPN SAVFRK		;IF WE HAVEN'T DONE SO ALREADY,
1)		   MOVEM A,SAVFRK	;SAVE OLD CURRENT FORK
1)		  MOVE A,FORK		;GET FORK WE WANT BACK IN A
1)		  SETZM SYMOKF		;AND REMEMBER WE HAVE CHANGED
1)		ENDIF.
1)	>;IFN STANSW
1)		MOVE B,LRFSTS+.RFPPC	;SAVE THIS (%X USES)
LINE 270, PAGE 26
2)		MOVE B,LRFSTS+.RFPPC	;SAVE THIS (%X USES)


; SRC:<6-EXEC>EXECP.MAC.16 & EXECP.MAC.1 25-Jul-85 2311	PAGE 52



LINE 293, PAGE 36
1)	IFN STANSW,<
1)		SKIPN A,SAVFRK		;HAVE WE CHANGED THE CURRENT FORK?
1)		IFSKP.
1)		  EXCH A,FORK		;YES, SET IT BACK
1)		  CAIE A,FORK		;AND IF DIFFERENT
1)		   SETZM SYMOKF		;REMEMBER IT WAS CHANGED
1)		ENDIF.
1)	>;IFN STANSW
1)		RET
LINE 279, PAGE 26
2)		RET


LINE 6, PAGE 37
1)	IFN STANSW,<
1)		MOVE A,FORK		;SAY WHAT FORK TO SET TRAPS ON
1)	>;IFN STANSW
1)		SKIPN TRPOKF		;DON'T SET UP TRAPS UNLESS THEY NEED IT
LINE 6, PAGE 27
2)		SKIPN TRPOKF		;DON'T SET UP TRAPS UNLESS THEY NEED IT


LINE 18, PAGE 37
1)		RET
1)	
LINE 15, PAGE 27
2)		CALL IFORK		;EM85
2)		RET
2)	
2)	;EM85 *** Begin ***
2)	;Prepare inferior fork structure, called by goto and start
2)	
2)	IFORK::	MOVE A,FORK
2)		CAMN A,UDFORK		;If under a debugger
2)		 MOVE A,@DBFORK		;continue the debugger
2)		MOVEM A,RUNFK		;return this  in A
2)		RET
2)	;EM85 *** End ***
2)	


; SRC:<6-EXEC>EXECP.MAC.16 & EXECP.MAC.1 25-Jul-85 2311	PAGE 53



LINE 1, PAGE 38
1)	^L
LINE 119, PAGE 27
2)	
2)	;EM85 *** Begin ***
2)	CS,<
2)	;This code lifted verbatim from CLEXEC
2)	;pa114 begin addition ****************************************
2)	;this code was copied unmodified from V3 except that all references to
2)	;"FRKTAB-400000" were replaced by "SLFTAB"
2)	
2)	; pa150 MIT rewrote this code, so hopefully it will now work (good luck,
2)	; MT!!).  Therefore, extensive changes begin here...
2)	
2)	; "IDDT" COMMAND AND "NO IDDT" COMMANDS
2)	
2)	;F1 IS CLEARED BY MAIN DISPATCH (TO .IDDT) AND SET BY "NO"
2)	
2)	.IDDT::	HRROI A,IDDTNM		;pa201
2)		JRST IDDT0		;pa201
2)	
2)	.NDDT::	HRROI A,NDDTNM		;pa201
2)		JRST IDDT0		;pa201
2)	
2)	IDDT0:	MOVEM A,IDNAME		;pa150 keep somewhere
2)		MOVE A, ATMBUF		;pa150 keep just name (only works since all
2)		MOVEM A, IDNAME+1	;pa150  debuggers have .leq. 4 letter names)
2)		TLNE Z, F1		;pa150 make grammatical
2)		NOISE <over>		;pa150
2)		MOVEI B, [FLDDB. .CMKEY,,FRKNMS,<Fork name,>,,[
2)			  FLDDB. .CMNUM,CM%SDH,10,<Octal fork number>,,[
2)			  FLDDB. .CMCFM,,,,,]]]	;pa150
2)		CALL FLDSKP		;pa150
2)		  CMERRX<Fork name, number, or CR required> ;pa150
2)		LDB D, [POINT 9,.CMFNP(C),8] ;pa150 get parse
2)		CAIN D, .CMCFM		;pa150 just CR?
2)		  JRST IDDTCR		;pa150 Yes,decide whether to continue or create
2)		CONFIRM			;pa150
2)		CALL FRKNM0		;pa150 get a fork handle
2)		TLNE Z, F1		;pa150 Is this "No iddt"?
2)		  JRST IDDTNO		;pa150 Yes, go unsplice
2)	Iddt1:	MOVEM A, UDFORK		;pa150 save it
2)		SETOM A
2)		CALL MAPPF		;UNMAP ANY INFERIOR PAGE
2)		CALL PIOFF		;WHILE THINGS ARE UP IN THE AIR
2)		CALL ECFORK		;pa150 make a fork (sets Fork to handle)
2)		MOVE A, IDNAME		;pa150
2)		CALL LDRUND		;LOAD AND RUN IT, DO CALL PION
2)		JRST WAITF		;pa150 (superceding pa114)

; SRC:<6-EXEC>EXECP.MAC.16 & EXECP.MAC.1 25-Jul-85 2311	PAGE 54


2)	
2)	; Here if no fork id was given
2)	IddtCr:	TLNE Z, F1		;pa150 was this "No iddt"?
2)		  JRST IDDTCN		;pa150 yes
2)		HRROI B, IDNAME+1	;pa150 see if we have right debugger already
2)		MOVEI A, FRKNMS		;pa150
2)		TBLUK%			;pa150
2)		TXNE B, TL%NOM1TL5AMB	;pa150 Found it (+++handle ambiguous better)
2)		  JRST IDDT3		;pa150 Nope, try current fork
2)		HRRZ A, (A)		;pa150 Got one, get its handle
2)		MOVX B, FK%DBG		;pa150 Is it really a debugger?
2)		TDNN B, SLFTAB(a)	;pa150
2)		  JRST IDDT3		;pa150 Nope
2)		MOVEM A, FORK		;pa150 Yes, make it current
2)		MOVEM A, RUNFK		;pa150 and continue it
2)		TYPE <[Continuing]>	;pa150
2)		JRST ..CONT		;pa150
2)	
2)	;"No iddt"
2)	IddtCn:	MOVX B, FK%DBG!FK%UND	;pa150 Debugger or debuggee?
2)		SKIPLE A, FORK		;pa150 for current fork
2)		TDNN B, SLFTAB(a)	;pa150 (7/26/80)
2)		CAIA			;pa150 No
2)		JRST IDDTNO		;pa150 Yes, go unsplice it
2)		HRROI B, IDNAME+1	;pa150 See if we have a debugger fork
2)		MOVEI A, FRKNMS		;pa150
2)		TBLUK%			;pa150
2)		TXNE B, TL%NOM!TL%AMB	;pa150 (+++ handle ambiguous better)
2)		  ERROR<No debugger>	;pa150
2)		HRRZ A, (A)		;pa150 got one, get its handle
2)		MOVX B, FK%DBG		;pa150 Is it really a debugger?
2)		TDNN B, SLFTAB(a)	;pa150
2)		  ERROR<No debugger>	;pa150
2)		JRST IDDTNO		;pa150 Yes, unsplice
2)	
2)	; No fork specified, and no existing debugger
2)	Iddt3:	MOVSI B, (FK%KPT)	;pa150 don't let us debug a kept fork
2)		SKIPLE A, FORK		;pa150 Is the current fork extant?
2)		  TDNE B, FRKTAB-400000	;pa150  and not kept?
2)		  JRST IDDT4		;pa150 No, start a fresh fork
2)		JRST IDDT1		;pa150 yes, go back to regular code
2)	
2)	; Nothing to continue or splice over
2)	Iddt4:	MOVSI A,(GJ%OLD+GJ%SHT)	;pa150 Get a jfn
2)		MOVE B, IDNAME		;pa150
2)		CALL GTJFS		;get a jfn on iddt
2)		  JRST [ MOVE B,IDNAME	;pa150 Get back debugger name
2)			 ERROR<Couldn't find %2M>] ;EM109 and die
2)		PUSH P, A		;pa150 save the jfn
2)		CALL ERESET
2)		POP P, A		;pa150 get it back

; SRC:<6-EXEC>EXECP.MAC.16 & EXECP.MAC.1 25-Jul-85 2311	PAGE 55


2)		CALL $GET2		;load it into a process
2)		MOVE A, FORK		;pa150 Mark new fork as debugger
2)		MOVX B, FK%DBG		;pa150
2)		IORM B, SLFTAB(A)	;pa150
2)		JRST ..STRT		;and start the process
2)	
2)	;******  pa150 end addition  *******
2)	
2)	; "No iddt".   Fork handle in A
2)	IddtNo:	MOVE B, SLFTAB(A)	;pa150 Get fork flags
2)		TXNN B, FK%DBG		;pa150 Is it a debugger?
2)		  JRST [ HLRZ A, .FKOWN(B) ;pa150 No, get its superior
2)			 CAIE A, .FHSLF	;pa150
2)			   JUMPG A, IDDTNO ;pa150  and try again
2)			 ERROR<No debugger> ] ;pa150
2)		MOVEM A, FORK		;pa150
2)		HRRZ B, .FKOWN(B)	;pa150 get inferior
2)		MOVEM B, UDFORK		;pa150
2)		CALLRET USPLIC		;pa150
2)	^L
2)	
2)	;LOAD AND RUN THE DEBUGGER
2)	;	Fork/	Fork handle of debugger
2)	;	udfork/	Fork handle of process to be debugged
2)	;	1/	pointer to ASCIZ file name, or jfn
2)	
2)	
2)	LDRUND:	TLNN B, -1		;pa150 jfn?
2)		  JRST LDRUN1		;pa150 yes
2)		MOVE B, A		;pa150 no, must be string pointer
2)		MOVX A, GJ%OLD+GJ%SHT	;pa150
2)		GTJFN%			;pa150
2)		  JRST [ MOVE A, UDFORK	;pa150
2)			 EXCH A, FORK	;pa150
2)			 KFORK%		;pa150
2)			 JRST CERR ]	;pa150
2)	;2 BEGIN ADDITION
2)	LdRun1:	PUSH P, A		;pa150 save jfn
2)		MOVE A, FORK		;pa150 get fork handle
2)		PUSH P,Q1		;SAVE AN AC
2)		MOVE B,-1(P)		;GET FILE AGAIN
2)		CALL SFKNAM		;SET UP FORK'S NAME
2)		POP P,Q1		;RESTORE AC
2)		POP P,A			;GET BACK FILE
2)	;2 END ADDITION
2)		HRL A, Fork		;pa150 FORM FORK.JFN
2)		GET
2)		MOVE A, Fork		;pa150
2)		GEVEC
2)		HLRZS B			;GET LENGTH
2)		CAIGE B,^D11		;GENERAL SUSPICION

; SRC:<6-EXEC>EXECP.MAC.16 & EXECP.MAC.1 25-Jul-85 2311	PAGE 56


2)		CAIGE B,3
2)		 JRST [	move a, udfork	;pa150
2)			EXCH A, Fork	;pa150
2)			KFORK
2)			UERR [ASCIZ /Bad entry vector/]]
2)	
2)		MOVE A, Fork		;pa150
2)		MOVE B, udfork		;pa150
2)		SKIPE SLFTAB(B)	;8 SET SUP OF INF TO BE THE DEBUGGER'S HANDLE
2)		 HRLM A,@SLFTAB(B)	;8 
2)		SKIPE SLFTAB(A)	;8 SET INF OF DEBUGGER TO BE THE USER FORK
2)		 HRRM B,@SLFTAB(A)	;8 
2)		SPLFK			;MAKE B INFERIOR TO A
2)		 CALL [	PUSH P,A	;SAVE ERROR CODE
2)			SETO A,
2)			EXCH A, Fork	;pa150
2)			KFORK
2)			POP P,A
2)			JRST JERR]	;GO SAY ERROR FROM JSYS
2)		SETZM PAGEN		;DONT CONFUSE FLAGS
2)		MOVEM A,PAGEN+1		;HANDLE BY WHICH DEBUGGER WILL KNOW INF.
2)		MOVEI B,PAGEN
2)		MOVE A, Fork		;pa150
2)		SFACS
2)		CALL PION
2)		MOVE A, Fork		;pa150
2)		MOVEI B,2
2)		SFRKV			;AT SPLICED ENTRY
2)		MOVEM A,RUNFK		;FORK TO RUN IS DEBUGGER
2)	;2 	MOVEI Q1,PTTYMD		;RESTORE TTY MODES
2)	;2	CALL LTTYMD
2)		CALL FTTYMD		;2 
2)		TLO Z,RUNF		;TELL ^C ROUTINE WHAT TO DO
2)		movx b,fk%dbg		;pa114 ;2 SAY FORK IS A DEBUGGER
2)		IORM B,SLFTAB(A)	;2 
2)		move a, udfork		;pa150 Mark debugged fork
2)		movx b, fk%und		;pa150   as under a debugger
2)		iorm b, SlfTab(a)	;pa150
2)		RET
2)	^L
2)	;UNSPLICE
2)	
2)	;	Fork/	Handle of debugger
2)	;	udfork/	Handle of inferior
2)	
2)	USPLIC:	skiple c, Fork		;pa150
2)		skipg b, udfork		;pa150
2)		  call ScrewUp		;pa150 both must be specified
2)		movem b, RunFk		;pa150 Continue will resume inferior
2)		movei a, .fhslf		;pa150  under the Exec
2)		SPLFK

; SRC:<6-EXEC>EXECP.MAC.16 & EXECP.MAC.1 25-Jul-85 2311	PAGE 57


2)		 CALL SCREWUP
2)		hllzs @SlfTab(c)	;pa150 Debugger no longer has inferior
2)		movem b, Fork		;pa150 Make debuggee current fork
2)		movei a, .fhslf		;pa150 Exec is new superior of debuggee
2)		hrlm a, @SlfTab(b)	;pa150
2)		move a, SlfTab(b)	;pa150 Fix some flags
2)		txz a, fk%und		;pa150 No longer under debugger
2)		txo a, fk%run		;pa150 Probably runnable
2)		movem a, SlfTab(b)	;pa150 Put them back (fixed)
2)		move a, c		;pa150
2)		callret KeFork		;pa150
2)	
2)	
2)	; NO command
2)	
2)	.NO::	KEYWD $NO
2)		 T Iddt			;pa201 Default to Iddt for compatability
2)		 JRST CERR
2)		TLO Z,F1		; Prefaced with "NO"
2)		JRST 0(P3)		; And do it
2)	
2)	$NO:	TABLE
2)		T Iddt
2)		T Nddt
2)		TEND
2)	
2)	;Pa114 end addition ****************************************
2)	>;CS
2)	;EM85 *** End ***
2)	^L


LINE 5, PAGE 39
1)	REPH::	PUSH P,[CMDIN2]		;RETURN HERE
1)	STEPH::	MOVEI B,0		;ENTRY VECTOR START OFFSET
1)	REPH1::	STKVAR <PJFN,EVOFF>
1)		MOVEM A,PJFN		;SAVE JFN
LINE 5, PAGE 30
2)	;CM307 *** Begin ***
2)	
2)	;Define a macro to create our local storage since we have so many
2)	; entry points in the code which starts ephemerons:
2)	
2)	DEFINE EPHSTG <
2)		STKVAR <PJFN,EVOFF,PARGFL,PRBSIZ,PRBADR,FINGSW>
2)		SETZM PARGFL		;Default - indicate don't use PRARG% hacks
2)		SETZM FINGSW		;Default - indicate this is not FINGER
2)	>
2)	
2)	;Entry point for FINGER/WHERE:
2)	

; SRC:<6-EXEC>EXECP.MAC.16 & EXECP.MAC.1 25-Jul-85 2311	PAGE 58


2)	STEPHF::EPHSTG			;Create local storage
2)		SETOM FINGSW		;Flag that this is from FINGER
2)	STEF2:	SETOM PARGFL		;Use PRARG (STEPHP enters here)
2)		MOVEI B,0		;Entry vector start offset
2)		JRST REPH2
2)	
2)	;CM307 *** End ***
2)	
2)	CS,<				;CM290 *** Begin ***
2)	STEPHP::EPHSTG			;Create local storage
2)		JRST STEF2		;Join common code
2)	>				;CM290 *** End ***
2)	
2)	REPH::	PUSH P,[CMDIN2]		;RETURN HERE
2)	STEPH::	MOVEI B,0		;ENTRY VECTOR START OFFSET
2)	REPH1:: EPHSTG			;CM307 Create local storage
2)	REPH2:				;CM307 Entry from STEPHP
2)		MOVEM A,PJFN		;SAVE JFN


LINE 12, PAGE 39
1)		CALL PIOFF		;MUST DISABLE ^C TO MUCK WITH EFORK
LINE 39, PAGE 30
2)		TRN			;CM236 Failed. No big deal.
2)		CALL PIOFF		;MUST DISABLE ^C TO MUCK WITH EFORK


LINE 19, PAGE 39
1)		MOVEI A,.FHSLF		;GET CURRENT CAPS (INCLUDING ENABLED)
1)		RPCAP
1)		MOVE A,EFORK		;AND PASS THEM ON
1)	;IFN STANSW,<			;[NIC1030] ALWAYS PASS DOWN CAPABILITIES
1)		SKIPE C,PRVENF		; IF ENABLED, PASS DOWN CAPABILITIES
1)		 SKIPA C,B		; USER IS ENABLED
1)		  TRZ B,-1		; NOT ENABLED, DISALLOW FORK EPCAP
1)	;>;IFN STANSW			;[NIC1030]
1)		EPCAP
LINE 47, PAGE 30
2)		DMOVE B,EXECAP		;CM224 Get current capabilities
2)		AND B,C2PASS		;CM318 Pass only caps we're allowed to pass
2)		AND C,C2PASS		;CM318
2)		MOVE A,EFORK		; AND PASS THEM ON
2)		SKIPE C,PRVENF		;CM236 If enabled, pass all we're allowed to
2)		SKIPA C,B		;CM236
2)		TRZ B,-1		;CM236 Not enabled, disallow capabilities
2)		TXO B,SC%ANA		;CM290 Allow ARPAnet access (in case Finger)
2)		EPCAP


; SRC:<6-EXEC>EXECP.MAC.16 & EXECP.MAC.1 25-Jul-85 2311	PAGE 59



LINE 36, PAGE 39
1)		SETSN
1)		 ERJMP .+1
1)		CALL PION		;RE-ENABLE ^C
1)		MOVEI A,GETILI		;WHERE TO GO ON "GET" ERROR
LINE 64, PAGE 30
2)	CC,<
2)		SKIPE FINGSW		;CM307 From FINGER?
2)		 JRST	[PUSH P,A	;CM307 Save system name
2)			CALL GTCNAM	;CM307 Get command name
2)			CALL GETSIX	;CM307 Convert to SIXBIT
2)			 TRN		;CM307 Ignore error (probably name too long)
2)			MOVE B,A	;CM307 This is SYSTAT name
2)			POP P,A		;CM307 Restore system name
2)			JRST .+1 ]	;CM307
2)	>
2)		SETSN
2)		 ERJMP .+1
2)		CALL PION		;RE-ENABLE ^C
2)	
2)	;CM307 *** Begin ***
2)		SKIPN PARGFL		; USE PRARG ?
2)		 JRST REPH3		; NO
2)		MOVE A,CMRTY		; GET POINTER TO THE CURRENT PROMPT STRING
2)		CALL BCOUNT		; FIND OUT HOW LONG IT IS
2)		MOVEM A,PRBSIZ
2)		SKIPE FINGSW		;From FINGER/WHERE?
2)		JRST [CALL GTCNAM	;Yes, get address of name used (possibly a
2)					; synonym for FINGER/WHERE)
2)		     CALL BCOUNT	;Count it's size
2)		     ADDM A,PRBSIZ	;Make it part of the grand total
2)		     MOVE A,CMPTR	;Get .CMPTR pointer
2)		     MOVE B,CMBFP	;Get pointer to beginning of buffer
2)		     CALL SUBBP		;Compute length of text already parsed
2)		     IDIVI A,5		;Covert bytes to words
2)		     AOS A		;Allow extra word for null and remainder
2)		     ADDM A,PRBSIZ	;Add to running total
2)		     JRST .+1]
2)		MOVE A,CMBFP		; SAME WITH BUFFER
2)		CALL BCOUNT
2)		ADD A,PRBSIZ
2)		AOS A			; ALLOW FOR HEADER WORD
2)		MOVEI B,DICT		; GET SOME TEMPORARY SPACE
2)		CALL GETMEM
2)		 ERROR <EXEC free space exhausted>
2)		MOVEM A,PRBSIZ		;Save amount of memory allocated and
2)		MOVEM B,PRBADR		; its address for later deallocation
2)		HLLZ A,CMFLG		; GET COMND FLAGS
2)		MOVEM A,(B)		; THEY GO IN THE HEADER WORD

; SRC:<6-EXEC>EXECP.MAC.16 & EXECP.MAC.1 25-Jul-85 2311	PAGE 60


2)		AOS B			; GO TO NEXT WORD
2)		HRLI B,440700		; MAKE A BYTE POINTER
2)		MOVE C,CMRTY		; GET POINTER TO THE PROMPT STRING
2)		ILDB A,C		; GET A CHARACTER FROM THE PROMPT STRING
2)		IDPB A,B		; COPY IT INTO THE BUFFER
2)		SKIPE A			; WAS IT A NULL?
2)		 JRST .-3		; NO, THERE'S MORE TO DO
2)		SKIPN FINGSW		;From FINGER/WHERE?
2)		JRST REPH20		;No, skip command name stuff
2)		CALL GTCNAM		;Get adddress of the command name
2)		MOVEM A,C		;Store pointer to command name in C
2)		ILDB A,C		;Get a character from the command name
2)		IDPB A,B		;Copy it into the buffer
2)		SKIPE A			;Was it a null?
2)		 JRST .-3		;No, there's more to do
2)	REPH20:	MOVE C,CMBFP		;Get pointer to the command buffer
2)		ILDB A,C		; GET A CHARACTER FROM THE PROMPT STRING
2)		IDPB A,B		; COPY IT INTO THE BUFFER
2)		SKIPE A			; WAS IT A NULL?
2)		 JRST .-3		; NO, THERE'S MORE TO DO
2)		SKIPN FINGSW		;Finger protocol?
2)		 JRST REPH25		;No, go on
2)		MOVE C,CMBFP		;Yes get pointer to CBUF
2)		DO.
2)		  CAMN C,CMPTR		;Get to end of stuff already parsed?
2)		   JRST ENDLP.		;Yes
2)		  ILDB A,C		;No, get another character
2)		  IDPB A,B		;Copy it into the buffer
2)		  LOOP.			;Do next character
2)		OD.
2)		SETZ A,			;Get a null
2)		IDPB A,B		;Null-terminate the copy
2)	REPH25:	MOVE B,PRBADR		;Get back address of the buffer
2)		MOVE C,PRBSIZ		;Also get back its length
2)		MOVE A,EFORK		; GET THE HANDLE OF THE FORK WE'RE USING
2)		HRLI A,.PRAST		; SAY WE'RE SETTING THE PROCESS ARGS
2)		PRARG%			; SET THE PROCESS ARGUMENTS
2)		 ERJMP .+1		; IGNORE FAILURE
2)		MOVE A,C		; PUT THE LENGTH OF THE BLOCK IN A
2)		MOVEI C,DICT		; SAY THIS IS TEMPORARY SPACE
2)		CALL RETMEM		; RETURN THE BUFFER
2)	REPH3:
2)	;CM307 *** End ***
2)	
2)		MOVEI A,GETILI		;WHERE TO GO ON "GET" ERROR


; SRC:<6-EXEC>EXECP.MAC.16 & EXECP.MAC.1 25-Jul-85 2311	PAGE 61



LINE 57, PAGE 39
1)		MOVEI B,.RFSFL+1	;SET UP FOR LONG FORM RFSTS
1)		MOVEM B,LRFSTS+.RFCNT
LINE 169, PAGE 30
2)	CC,<	MOVEI B,.RFSFL+1>	;CS44 SETUP FOR LONG FORM RFSTS
2)	CS,<	MOVEI B,.RFSTA+1>	;CS44 Set up for long format RFSTS
2)		MOVEM B,LRFSTS+.RFCNT


LINE 65, PAGE 39
1)		 JRST [	MOVE A,EFORK	;YES - JUST KILL IT OFF
1)	IFE STANSW,<
1)			KFORK
1)			SETOM EFORK	;NO MORE EPHEMERON
1)	>;IFE STANSW
1)	IFN STANSW,<
1)			SETOM EFORK	;NO MORE EPHEMERON (AND DO IT BEFORE KFORK
1)			KFORK		;TO AVOID RACES)
1)	>;IFN STANSW
1)			CALLRET PION]	;EXIT (CMDIN2)
1)		TLNE A,077700		;FORK EXISTS?
LINE 178, PAGE 30
2)		 JRST [	SKIPN PARGFL	;CM307 Using PRARG% communications?
2)			IFSKP.		;CM307
2)			  CALL CHKPMT	;CM307 Yes, get values returned by program
2)			ELSE.		;CM307
2)			  MOVE A,[IFIW R] ;CM307 Get default exit
2)			ENDIF.		;CM307
2)			PUSH P,A	;CM307 Save dispatch address
2)			MOVE A,EFORK	;YES - JUST KILL IT OFF
2)			CALL RELIO	;CM224 Close primary JFN's if necessary
2)			KFORK
2)			SETOM EFORK	;NO MORE EPHEMERON
2)			CALL PION	;CM307 EXIT (CMDIN2)
2)			POP P,A		;CM307 Get back dispatch address
2)			JRST (A) ]	;CM307 Go do right thing
2)		TLNE A,077700		;FORK EXISTS?


LINE 2, PAGE 40
1)	IFN STANSW,<
1)	; MAP (SOURCE PAGES) nnn (TO) nnn (OF) FORK/FILENAME (BEGINNING AT PAGE)
1)	;     nnn (OF) FORK/FILENAME (ACCESS) accesses
1)	.MAP::	NOISE <SOURCE PAGES>
1)		DEFX <0>
1)		OCTX <Page number>
1)		 ERROR <Must be an octal number>
1)		SKIPL B
1)		 CAILE B,777

; SRC:<6-EXEC>EXECP.MAC.16 & EXECP.MAC.1 25-Jul-85 2311	PAGE 62


1)		  ERROR <Pages are 0 to 777>
1)		PUSH P,B		;SAVE SOURCE START PAGE
1)		NOISE (TO)
1)		DEFX <777>
1)		OCTX <Page number>
1)		 ERROR <Must be an octal number>
1)		SKIPL B
1)		 CAILE B,777
1)		  ERROR <Pages are 0 to 777>
1)		PUSH P,B		;SAVE SOURCE END PAGE
1)		NOISE <OF>
1)		HRRI Z,CPFN		;PASS THE FILE INPUT ROUTINE AS AN ARG
1)		CALL MPHAND		;GET SOURCE HANDLE INTO A
1)		PUSH P,A		;SAVE SOURCE FORK/FILE HANDLE
1)		NOISE <BEGINNING AT PAGE>
1)		DEFX <0>
1)		OCTX <Page number>
1)		 ERROR <Must be an octal number>
1)		SKIPL B
1)		 CAILE B,777
1)		  ERROR <Pages are 0 to 777>
1)		PUSH P,B		;SAVE BEGINNING DESTINATION PAGE
1)		NOISE <OF>
1)		HRRI Z,COUTFN		;PASS THE FILE INPUT ROUTINE AS AN ARG
1)		CALL MPHAND		;GET DESTINATION HANDLE INTO A
1)		PUSH P,A		;SAVE DESTINATION HANDLE
1)		MOVEI A,400000		;GET FORK BIT
1)		TDNN A,-2(P)		;IS SOURCE FORK?
1)		TDNE A,0(P)		;IS DEST. FORK?
1)		IFSKP.
1)		  ERROR <File to file mapping can't be done>
1)		ENDIF.
1)		NOISE <ACCESS>
1)		MOVX A,PM%RD		;START WITH READ ACCESS
1)		PUSH P,A		;ASSEMBLE BITS ON STACK
1)		DO.
1)		  KEYWD $MAPAC
1)		   0
1)		   JRST [CRRX
1)			  CMERRX <Bad access>
1)			 EXIT.]
1)		  MOVSI B,400000	;GRAB A BIT
1)		  MOVNI C,0(P3)		;AND ITS NUMERIC POSITION
1)		  ROT B,0(C)		;PUT IT THERE
1)		  IORM B,0(P)		;PUT IT IN THE ACCESS WORD
1)		  CRRX <Access specification, or return to confirm>
1)		   LOOP.
1)		ENDDO.
1)		POP P,A			;GET BITS WHERE WE CAN SEE THEM
1)	; NOW WE HAVE PMAP ACCESSES IN LH A, OPENF ACCESSES IN RH A
1)	; (READ, WRITE, EXECUTE FOR OPENF TAKEN FROM PMAP)

; SRC:<6-EXEC>EXECP.MAC.16 & EXECP.MAC.1 25-Jul-85 2311	PAGE 63


1)		LDB B,[POINT 3,A,4]	;GET READ, WRITE, EXECUTE FROM PMAP
1)		DPB B,[POINT 3,A,21]	;GIVE TO OPENF
1)		TRO A,OF%RD		;GOTTA BE ABLE TO READ
1)		TRZ A,OF%APP		;NEVER APPEND (UGH!)
1)		PUSH P,A		;SAVE ACCESSES
1)		MOVE A,-3(P)		;GET SOURCE HANDLE
1)		TRNE A,400000		;IS IT A FILE?
1)		IFSKP.
1)		  HRRZ B,0(P)		;YES, GET THE FILE ACCESS BITS
1)		  CALL $OPENF		;AND OPEN IT
1)		ENDIF.
1)		MOVE A,-1(P)		;GET DESTINATION HANDLE
1)		TRNE A,400000		;IS IT A FILE?
1)		IFSKP.
1)		  HRRZ B,0(P)		;YES, GET THE FILE ACCESS BITS
1)		  CALL $OPENF		;AND OPEN IT
1)		ENDIF.
1)		MOVE A,-5(P)		;BEGINNING SOURCE PAGE
1)		MOVE Q1,-4(P)		;ENDING SOURCE PAGE
1)		SUB Q1,A		;DIFFERENCE
1)		MOVM D,Q1		;MAGNITUDE
1)		IDIV Q1,D		;GET THE INCREMENT (CLOBBERS F)
1)		MOVE Q2,Q1		;INTO F
1)		ADDI D,1		;MAGNITUDE PLUS ONE MAKES COUNT
1)		HRL A,-3(P)		;SOURCE HANDLE
1)		HRL Q1,-1(P)		;DESTINATION HANDLE
1)		HRR Q1,-2(P)		;BEGINNING DESTINATION PAGE
1)		HLLZ C,0(P)		;PMAP ACCESSES
1)		TLZ Z,F2+F3		;F3 SAYS "NOT MAPPED" HEADER PRINTED
1)					;F2 SAYS WE ARE IN BLOCK OF MISSING PAGES
1)		TRZ Z,-1		;RH OF Z IS THE PAGE NUMBER OF THE FIRST
1)					;PAGE IN THIS BLOCK OF NON-EXISTANT PAGES
1)		DO.
1)		  RPACS%		;GET SOURCE PAGE INFO
1)		  IFXE. B,PA%PEX	;DOES IT EXIST?
1)		    TLNN Z,F2		;NO, ARE WE IN MISSING BLOCK?
1)		     HRR Z,1		;NO, SAVE PAGE NUMBER
1)		    TLO Z,F2		;SAY NOW IN BLOCK
1)		  ELSE.
1)		    TLNE Q1,400000	;IS DESTINATION A FORK?
1)		    TRNN Q1,777000	;YES, TRYING FOR PAGE 1000 OR GREATER?
1)		    IFSKP.
1)		      CALL CRIF
1)		       ETYPE <Can't map source page %1P to fork page %5P, quitting>
1)		      TLZ Z,F2		;MAKE SURE MPRINT DOESN'T GET CALLED ON EXIT.
1)		      EXIT.
1)		    ELSE.
1)		      TLZE Z,F2		;ARE(WERE) WE IN MISSING BLOCK?
1)		       CALL MPRINT	;YES, PRINT PAGES SKIPPED (CLOBBERS B)
1)		      MOVE B,Q1		;GET DESTINATION DESCRIPTION
1)		      PMAP%

; SRC:<6-EXEC>EXECP.MAC.16 & EXECP.MAC.1 25-Jul-85 2311	PAGE 64


1)		    ENDIF.
1)		  ENDIF.
1)		  ADD A,Q2
1)		  AOJ Q1,		;NEXT PAGE
1)		  SOJG D,TOP.		;TALLY, DONE?
1)		ENDDO.
1)		TLNE Z,F2		;WERE WE IN MISSING BLOCK?
1)		 CALL MPRINT		;YES, PRINT IT
1)		ADJSP P,-6
1)		CALLRET	RLJFNS
1)	
1)	$MAPAC:	TABLE
1)		T COPY-ON-WRITE,,^D9
1)		T CW,,^D9
1)		T EXECUTE,,4
1)		T READ,,2
1)		T THAWED,,^D25
1)		T TRAP-TO-USER,,^D8
1)		T WRITE,,3
1)		TEND
1)	^L
1)	; THIS ROUTINE GETS A SOURCE/DESTINATION DESIGNATOR INTO AC1
1)	; ADDRESS OF FILE INPUT ROUTINE TO CALL IS IN RH Z
1)	MPHAND:HELPX	<
1)	A specific fork handle, a file name, or >
1)		KEYWD $MPFRK		;SEE IF THEY JUST WANT THE LOWER FORK
1)		 0			;NO DEFAULT
1)		 JRST MPHSF		;NO, SEE IF THEY WANT A SPECIFIC FORK
1)		SKIPG FORK		;YES, DO WE ALREADY HAVE ONE?
1)		 CALL ECFORK		;NO, GET ONE
1)		MOVE A,FORK		;RETURN ITS HANDLE
1)		JRST MPHANZ
1)	 
1)	MPHSF:	CALL MPGFRK		;TRY TO READ FORK NUMBER
1)		 JRST MPHFIL		;NOT FORK, TRY FILE NAME
1)		TRO A,400000		;MAKE NUMBER INTO FORK HANDLE
1)		PUSH P,A
1)		RFSTS%
1)		TLNE A,077700		;DISTINGUISH BETWEEN FROZEN AND UNASSIGN
1)		 ERROR <That fork handle not assigned>
1)		POP P,A
1)		JRST MPHANZ
1)	 
1)	MPHFIL:	PUSH P,B
1)		HRRZ B,Z		;GET ADDR OF FILE INPUT ROUTINE
1)		TRZ Z,-1		;AND CLEAR IT
1)		CAIN B,CPFN		;A KLUDGE IF THERE EVER WAS ONE...
1)		 TDZA A,A		;SOMEBODY SHOULD REWRITE THE CRETINOUS COMMAND
1)		  MOVSI A,-1		;SOMEDAY
1)		CALL 0(B)		;GO THERE
1)		 JRST CERR

; SRC:<6-EXEC>EXECP.MAC.16 & EXECP.MAC.1 25-Jul-85 2311	PAGE 65


1)		POP P,B
1)	 
1)	MPHANZ:	TRZ Z,-1		;CLEAN UP
1)		RET
1)	 
1)	$MPFRK:	TABLE
1)		T FORK,,0
1)		TEND
1)	 
1)	; THIS ROUTINE WILL TRY TO NIN THE FORK OR FILE HANDLE,
1)	; RETURN +1 ERROR
1)	; 	 +2 WITH THE FORK HANDLE IN RH 1
1)	 
1)	; WE HAVE TO USE THIS ROUTINE BECAUSE BOTH "OCTAL" AND "CINFN" GO TO
1)	; CERR ON OUR INPUTS
1)	 
1)	MPGFRK:	PUSH P,B
1)		PUSH P,C
1)		OCTX
1)		 JRST MPGFRZ
1)		SKIPN B
1)		 UERR [ASCIZ/Fork handle must be between 1 and 17/]
1)		ANDI B,17		;SOME LIMIT ON THE FORK NUMBER
1)		HRRZ A,B		;RETURN HANDLE IN 1
1)		AOS -2(P)		;SKIP RETURN
1)	MPGFRZ:	POP P,C
1)		POP P,B
1)		RET
1)	 
1)	;ROUTINE TO PRINT THE PAGES SKIPPED
1)	;TAKES START PAGE FROM RH Z, PAGE AFTER NON-EXISTANT BLOCK IN RH 1,
1)	;"HEADER PRINTED" FLAG (F3).
1)	;CLOBBERS B, CLEARS RH Z
1)	MPRINT:	TLON Z,F3		;WAS THE HEADER PRINTED?
1)		 JRST [	UTYPE [ASCIZ /%Source pages not mapped: / ]
1)			JRST .+2 ]	;SKIP THE COMMA
1)		TYPE <, >		;YES, JUST A COMMA THEN
1)		HRRZ B,Z		;GET START PAGE
1)		TRZ Z,-1		;SAY THIS GROUP PRINTED
1)		ETYPE <%2P>		;PRINT IT
1)		CAIN B,-1(1)		;IS START PAGE THE ONE BEFORE CURRENT?
1)		 RET			;YES, ONLY ONE PAGE SKIPPED, ALL DONE
1)		PRINT "-"
1)		HRRZI B,-1(1)		;NO, GET FINAL SKIPPED PAGE
1)		ETYPE <%2P>		;PRINT IT
1)		RET
1)	^L 
1)	;UNMAP (CORE PAGE) NNN
1)	 
1)	.UNMAP::NOISE <CORE PAGES FROM>
1)		DEFX <0>

; SRC:<6-EXEC>EXECP.MAC.16 & EXECP.MAC.1 25-Jul-85 2311	PAGE 66


1)		OCTX <Starting page number>
1)		 ERROR <Must be an octal number>
1)		SKIPL B
1)		 CAILE B,777
1)		  ERROR	<Core pages are 0 to 777>
1)		PUSH P,B
1)		NOISE (TO)
1)		DEFX <777>
1)		OCTX <Ending page number>
1)		 ERROR <Must be an octal number>
1)		SKIPL B
1)		 CAILE B,777
1)		  ERROR <Core pages are 0 to 777>
1)		SKIPGE A,FORK		;ON MEMSTAT FORK
1)		 ERROR <No program>
1)		CAIN A,.FHSLF
1)		 ERROR <Illegal to UNMAP EXEC>
1)		MOVE C,B		;GET READY TO MAKE COUNT
1)		POP P,B			;GET STARTING PAGE
1)		SUB C,B			;MAKE PAGE DIFFERENCE
1)		ADDI C,1		;MAKE PAGE COUNT
1)		CONFIRM
1)		SETO A,			;SAY UNMAP
1)		HRL B,FORK		;FROM FORK FORK
1)		TXO C,PM%CNT		;SAY COUNT EXISTS
1)		PMAP%			;DO UNMAP
1)		 ERJMP JERR
1)		RET
1)	>;IFN STANSW
1)	^L
LINE 2, PAGE 31
2)					;CM307 *** Begin ***
2)	;Routine to interpret the stuff (if any) returned in the PRARG% block
2)	;by an ephemeron using the Finger/Exec communications protocol.
2)	
2)	CHKPMT:	STKVAR <<PRBUF,PRLEN>>
2)		MOVE A,EFORK		; GET FORK HANDLE
2)		HRLI A,.PRARD		; SET TO READ
2)		MOVEI B,PRBUF		; USE THIS
2)		MOVEI C,PRLEN		; A GOOD MAX
2)		PRARG%			; READ PROCESS ARGS
2)		  ERJMP CHKNON		; IGNORE IF FAILURE
2)		JUMPE C,CHKNON		;No arguments
2)		HRRZ A,PRBUF		;Make sure RH of first word is zero
2)		JUMPN A,[HRRZ A,EFORK	;Get handle of ephemeral fork
2)			 CALL PRCLR2	;Clear its process args
2)			 JRST CHKNON]	;Garbage, pretend nothing found
2)		HLRZ A,PRBUF		;Check function
2)		CAIL A,5		;Legal value?
2)		 CAILE A,7		;...
2)		  TRNA			;Not in current protocol, anyway

; SRC:<6-EXEC>EXECP.MAC.16 & EXECP.MAC.1 25-Jul-85 2311	PAGE 67


2)		  JRST CHGOOD		;Found good return vale, go handle it
2)		CAIN A,4		;No prompt (obsolete)?
2)		 SETOM NOPRMT		;Tell subrs that
2)	CHKNON: MOVEI A,.CHLFD		;CM307 Fake end of line so
2)		DPB A,CMPTR		;CM307  .CMINI works.  This hack "fixes" the
2)					;  problem where if "Finger" or "Bboard" is
2)					;  the last command in a .CMD file than a
2)					;  spurious "missing CRLF" warning is generated
2)					;  because the subsequent .CMINI gets an EOF
2)					;  error instead of depositing a null at the
2)					;  beginning of CBUF and letting the parse at
2)					;  CIN10 get the EOF error...
2)		MOVE A,[IFIW R]		;Go to default place on bad return value
2)		RET
2)	
2)	CHGOOD:	CALL CMDINI		;Initialize SBLOCK
2)		MOVE A,CMBFP		;Get pointer to beginning of CBUF
2)		CALL FIXPT		;Convert -1,,foo to 440700,,foo
2)		MOVE B,1+PRBUF		;Get relative .CMPTR pointer
2)		ADJBP B,A		;Compute new .CMPTR pointer
2)		MOVEM B,CMPTR		;Store it in the state block
2)		MOVN A,1+PRBUF		;Get - relative .CMPTR pointer
2)		ADDM A,CMCNT		;That much less space is left in the buffer
2)		MOVE A,2+PRBUF		;Get COMND% flags
2)		TXZ A,CM%XIF		;Don't want CM%XIF
2)		HLLM A,CMFLG		;Set our COMND% flags
2)		MOVE A,3+PRBUF		;Get .CMINC word
2)		MOVEM A,CMINC		;Store it in our block
2)		MOVEI A,4+PRBUF		;Get address of command text
2)		HRLI A,440700		;Make it a byte pointer
2)		MOVE B,[POINT 7,CBUF]	;Get pointer to command buffer
2)		DO.
2)		  ILDB C,A		;Get a character
2)		  IDPB C,B		;Stash it in CBUF
2)		  SKIPE C		;Null?
2)		   LOOP.		;No, keep going
2)		OD.
2)		HLRZ D,PRBUF		;Get back return code
2)		CAIN D,5		;Success?
2)		 MOVEI A,CSAVE		;EM111 Return via command edit save...
2)	;EM111	 MOVEI A,R		;Yes, return to our caller
2)	;EM111	CAIN D,6		;Error?
2)	;EM111	 MOVEI A,CMDIN2		;Yes, go get another command
2)		CAIE D,6		;EM111 Error?
2)		IFSKP.			;EM111
2)		  CALL CSAVE		;EM111 Save the command buffer first
2)		  MOVEI A,CMDIN2	;EM111 Yes, go get another command
2)		ENDIF.			;EM111
2)		CAIN D,7		;Reparse needed?
2)		 HRRZ A,CMFLG		;Yes, get reparse address (= REPARS in EXECSU)
2)		TXO A,IFIW		;Make nice for indexed jumps

; SRC:<6-EXEC>EXECP.MAC.16 & EXECP.MAC.1 25-Jul-85 2311	PAGE 68


2)		RET			;CM307 *** End ***
2)	^L
2)	;*** CM307 begin addition (entire page) ***
2)	
2)	;Routine to get the name of the command that is currently in
2)	;progress.  If the user used a synonym, the name returned is
2)	;the name of the synonym rather than the name of the actual
2)	;command
2)	;
2)	;Takes:
2)	;	SAVCMD/	value returned by COMND% when the command was
2)	;		parsed (set up in Exec0, so don't worry about it)
2)	;Returns:
2)	;	+1 always
2)	;Outputs:
2)	;	A/	byte pointer to (non-writeable) ASCIZ command name
2)	;Clobbers:
2)	;	A
2)	;
2)	GTCNAM:	SAVEAC <B>		;Get workspace
2)		MOVE A,SAVCMD		;Get value returned by COMND%
2)		HLR A,(A)		;Get address of string
2)		HRLI A,440700		;Make it a byte pointer
2)		MOVE B,A		;Get a copy of it
2)		HRLI B,(POINT 8)	;We want to check out the first 8 bits
2)		ILDB B,B		;Read first byte of the string
2)		CAIN B,1		;Majik value indicating that we really
2)					; have a pointer to a TBLUK% flag word?
2)		 AOS A			;Yes, so string is in the next word
2)		RET
2)	
2)	;*** CM307 end addition ***
2)	^L


LINE 142, PAGE 43
1)	IFE STANSW,<
1)			CAIN C,"."	;END WITH DECIMAL POINT?
1)	>;IFE STANSW
1)	IFN STANSW,<
1)			CAIN D,"."	;END WITH DECIMAL POINT?
1)	>;IFN STANSW
1)			MOVE A,DECVAL	;YES, GET DECIMAL VALUE
LINE 142, PAGE 33
2)			CAIN C,"."	;END WITH DECIMAL POINT?
2)			MOVE A,DECVAL	;YES, GET DECIMAL VALUE


; SRC:<6-EXEC>EXECP.MAC.16 & EXECP.MAC.1 25-Jul-85 2311	PAGE 69



LINE 251, PAGE 43
1)		TXNE A,SCFLD		;DON'T MATCH ON PROGRAM NAMES
1)		CAME D,WS		;IS THIS SYMBOL THE RIGHT NAME?
LINE 246, PAGE 33
2)		CAME D,WS		;IS THIS SYMBOL THE RIGHT NAME?


LINE 323, PAGE 43
1)		MOVX C,PM%RD!PM%CNT!NSMPGS ;READ ACCESS, NUMBER OF SYMBOL PAGES WE HAVE ROOM FOR
1)		PMAP			;ESTABLISH NEW WINDOW INTO SYMBOL TABLE
LINE 317, PAGE 33
2)		MOVX C,PM%RD!PM%CNT!NSMPGS	;READ ACCESS, NUMBER OF SYMBOL PAGES WE HAVE ROOM FOR
2)		PMAP			;ESTABLISH NEW WINDOW INTO SYMBOL TABLE


LINE 354, PAGE 43
1)	IFN STANSW,<
1)		TLNN A,37		;SECTION NUMBER WITH THIS ADDRESS?
1)		IFSKP.
1)		  PUSH P,A
1)		  HLRZS A		;YES, OUTPUT THE SECTION NUMBER FIRST
1)		  ETYPE <%1O,,>
1)		  POP P,A
1)		  HRRZS A		;AND REMOVE THE SECTION NUMBER FROM THE ADDRESS
1)		ENDIF.
1)	>;IFN STANSW
1)		MOVEM A,TYPVAL		;REMEMBER VALUE
LINE 348, PAGE 33
2)		MOVEM A,TYPVAL		;REMEMBER VALUE


LINE 480, PAGE 43
1)		ETYPE <%1M>		;TYPE THE SYMBOL
1)		JRST TYPOP2		;SAY ONLY OPCODE FIELD PRINTED
LINE 464, PAGE 33
2)	;EM26	ETYPE <%1M>		;TYPE THE SYMBOL
2)		ETYPE <%1\>		;EM26 TYPE THE SYMBOL
2)		JRST TYPOP2		;SAY ONLY OPCODE FIELD PRINTED


LINE 487, PAGE 43
1)		SKIPA A,[FLD(1,OPFLD)!FLD(1,ACFLD)] ;YES, DENOTE THAT THESE FIELDS WERE PRINTED
1)	TYPOP2:	MOVX A,FLD(1,OPFLD)	;ONLY OPCODE FIELD PRINTED, SO MARK
LINE 472, PAGE 33
2)		JRST [	MOVX A,FLD(1,OPFLD)!FLD(1,ACFLD) ;YES, DENOTE THAT THESE FIELDS WERE PRINTED
2)			RET]
2)	TYPOP2:	MOVX A,FLD(1,OPFLD)	;ONLY OPCODE FIELD PRINTED, SO MARK


; SRC:<6-EXEC>EXECP.MAC.16 & EXECP.MAC.1 25-Jul-85 2311	PAGE 70



LINE 499, PAGE 43
1)		 SETZ A,		;ASSUME 0
1)		MOVEM A,INSYMP		;REMEMBER POINTER
LINE 485, PAGE 33
2)		 JRST [	MOVEI A,0	;ASSUME 0
2)			JRST .+1]
2)		MOVEM A,INSYMP		;REMEMBER POINTER


LINE 89, PAGE 44
1)	;RCMA, RIND, LPAREN ETC.  ALL ATTEMPT TO READ TOKENS SUCH AS COMMA, AT SIGN,
1)	;LEFT PARENTHESIS, SKIPPING IF THE TOKEN IS SEEN.
1)	
1)	RCMA:	MOVEI B,[FLDDB. .CMTOK,CM%SDH,<-1,,[ASCIZ /,/]>,<Comma>]
1)		CALLRET XSKP		;PARSE THE TOKEN; GIVE SKIP OR ERROR RETURN
1)	
1)	RIND:	MOVEI B,[FLDDB. .CMTOK,CM%SDH,<-1,,[ASCIZ /@/]>,<At sign (@)>]
1)		CALLRET XSKP		;PARSE THE TOKEN; GIVE SKIP OR ERROR RETURN
1)	
LINE 89, PAGE 34
2)	;RCMA, RIND, LPAREN ETC.  ALL ATTEMPT TO READ TOKENS SUCH AS COMMA, ATSIGN,
2)	;LEFT PARENTHESIS, SKIPPING IF THE TOKEN IS SEEN.
2)	
2)	RCMA:	MOVEI B,[FLDDB. .CMTOK,CM%SDH,<-1,,[ASCIZ /,/]>,<Comma>]
2)	R11:	CALLRET XSKP		;PARSE THE TOKEN; GIVE SKIP OR ERROR RETURN
2)	
2)	RIND:	MOVEI B,[FLDDB. .CMTOK,CM%SDH,<-1,,[ASCIZ /@/]>,<Atsign (@)>]
2)		JRST R11
2)	


LINE 101, PAGE 44
1)		CALLRET XSKP		;PARSE THE TOKEN; GIVE SKIP OR ERROR RETURN
1)	
1)	RSPACE:	MOVEI B,[FLDDB. .CMTOK,CM%SDH,<-1,,[ASCIZ / /]>,<Space>]
1)		CALLRET XSKP		;PARSE THE TOKEN; GIVE SKIP OR ERROR RETURN
1)	
LINE 101, PAGE 34
2)		JRST R11		;NO
2)	
2)	RSPACE:	MOVEI B,[FLDDB. .CMTOK,CM%SDH,<-1,,[ASCIZ / /]>,<Space>]
2)		JRST R11
2)	


; SRC:<6-EXEC>EXECP.MAC.16 & EXECP.MAC.1 25-Jul-85 2311	PAGE 71



LINE 117, PAGE 44
1)		CALL RIND		;SEE IF EXPRESSION STARTS WITH AT SIGN
1)		 CAIA 			;IT DOESN'T - TRY A COMMA
1)		JRST HI			;IT DOES - HANDLE INDIRECT
1)		CALL RCMA		;GOT A COMMA?
1)		 JRST NOOPC1		;NO - TRY PARENTHESIS
1)		CALL RCMA		;YES - SEE IF EXPRESSION STARTS WITH TWO COMMAS
1)		 JRST SCOMA		;",FOO" EQUALS ",,FOO"
1)		JRST SCOMA
1)	
1)	NOOPC1:	CALL LPAREN		;TRY A PARENTHESIS
1)		 CMERRX <No opcode seen, and no comma (,) at sign (@) or parenthesis seen either>
1)		SETZM YFLD		;NO Y FIELD
1)		JRST HP			;HANDLE PARENTHESES
1)	
LINE 117, PAGE 34
2)		CALL RIND		;SEE IF EXPRESSION STARTS WITH ATSIGN
2)		 JRST [	CALL RCMA	;NO, TRY COMMA
2)			 JRST [	CALL LPAREN	;NO, TRY PARENTHESIS
2)				 CMERRX <No opcode seen, and no comma (,) atsign (@) or parenthesis seen either>
2)				SETZM YFLD	;NO Y FIELD
2)				JRST HP	]	;HANDLE PARENTHESES
2)			CALL RCMA	;SEE IF EXPRESSION STARTS WITH TWO COMMAS
2)			 JRST SCOMA	;",FOO" EQUALS ",,FOO"
2)			JRST SCOMA]
2)		JRST HI			;HANDLE INDIRECT
2)	


LINE 134, PAGE 44
1)	OPNOAC:	CALL RIND		;TRY "FOO@"
1)		 CAIA			;NO - SKIP
1)		JRST HI			;YES - HANDLE INDIRECT
1)		CALL RCMA		;HOW ABOUT "FOO,"
1)		 JRST OPNAC1		;NO - TRY OTHER THINGS
1)		CALL RCMA		;IT'S "FOO,".  HOW ABOUT "FOO,,"
1)		 JRST OPNAC2		;NO - IT'S JUST "FOO,"
1)		MOVE A,OPPTR		;IT'S "FOO,,ZOT" SO "FOO" ISN'T
1)		MOVEM A,XPTR		; REALLY AN OPCODE
1)		SETZM OPPTR		;MARK THAT THERE'S NO OPCODE
1)		JRST SCOMA
1)	
1)	OPNAC1:	SETZM YPTR		;WE'LL USE OPCODE FOR Y FIELD
1)		CALL LPAREN		;HOW ABOUT "FOO("
1)		 JRST IALL		;IT'S JUST "FOO"
1)		JRST HP			;IT'S JUST "FOO ("
1)	
1)	OPNAC2:	MOVE A,OPPTR		;IT'S JUST "FOO,"
1)		MOVEM A,ACPTR		;SO OPCODE WAS REALLY AN ACCUMULATOR

; SRC:<6-EXEC>EXECP.MAC.16 & EXECP.MAC.1 25-Jul-85 2311	PAGE 72


1)		SETZM OPPTR		;SAY THERE'S NO OPCODE
1)		JRST SCOMA		;HANDLE INDIRECT MAYBE
1)	
LINE 131, PAGE 34
2)	OPNOAC:	CALL RIND			;TRY "FOO@"
2)		 JRST [	CALL RCMA		;NO, HOW ABOUT "FOO,"
2)			 JRST [	SETZM YPTR	;WE'LL USE OPCODE FOR Y FIELD
2)				CALL LPAREN	;HOW ABOUT "FOO("
2)				 JRST IALL	;IT'S JUST "FOO"
2)				JRST HP]	;IT'S JUST "FOO ("
2)			CALL RCMA		;IT'S "FOO,".  HOW ABOUT "FOO,,"
2)			 JRST [	MOVE A,OPPTR	;IT'S JUST "FOO,"
2)				MOVEM A,ACPTR	;SO OPCODE WAS REALLY AN ACCUMULATOR
2)				SETZM OPPTR	;SAY THERE'S NO OPCODE
2)				JRST SCOMA]	;HANDLE INDIRECT MAYBE
2)			MOVE A,OPPTR		;IT'S "FOO,,ZOT" SO "FOO" ISN'T
2)			MOVEM A,XPTR		;REALLY AN OPCODE
2)			SETZM OPPTR		;MARK THAT THERE'S NO OPCODE
2)			JRST SCOMA]
2)		JRST HI				;HANDLE INDIRECT
2)	


LINE 167, PAGE 44
1)		JUMPN A,RSKP		;IF SOMETHING READ GIVE A SKIP RETURN
1)	RSYM1:	MOVEI B,[FLDDB. .CMTOK,CM%SDH,<-1,,[ASCIZ /[\]/]>,<"[\]" to stand for literal>]
LINE 159, PAGE 34
2)		CAIE A,0		;IF NOTHING READ, DON'T SKIP YET
2)		RETSKP
2)	RSYM1:	MOVEI B,[FLDDB. .CMTOK,CM%SDH,<-1,,[ASCIZ /[\]/]>,<"[\]" to stand for literal>]


LINE 204, PAGE 44
1)	
1)	EVAL::	SAVEAC <P1>		;WE NEED A PERMANENT AC
LINE 197, PAGE 34
2)	EVAL::	SAVEAC <P1>		;WE NEED A PERMANENT AC


LINE 241, PAGE 44
1)	EXPNEG:	CALL	TERM		;COLLECT A TERM
LINE 233, PAGE 34
2)	
2)	EXPNEG:	CALL	TERM		;COLLECT A TERM


; SRC:<6-EXEC>EXECP.MAC.16 & EXECP.MAC.1 25-Jul-85 2311	PAGE 73



LINE 4, PAGE 45
1)	TERM:	CALL	FACTOR		;READ IN A FACTOR
LINE 4, PAGE 35
2)	
2)	TERM:	CALL	FACTOR		;READ IN A FACTOR


LINE 13, PAGE 45
1)	TERMML:	PUSH P1,[PUSH	P,A]	;SAVE VALUE
LINE 14, PAGE 35
2)	
2)	TERMML:	PUSH P1,[PUSH	P,A]	;SAVE VALUE


LINE 22, PAGE 46
1)		CAIN C,")"		;CLOSING PARANTHESIS?
1)		RET			;O.K.
1)		CALLRET PARBAD		;NO, INVALID EXPRESSION
1)	^L
LINE 22, PAGE 36
2)		CAIE C,")"		;CLOSING PARANTHESIS?
2)		CALLRET PARBAD		;NO, INVALID EXPRESSION
2)		RET			;O.K.
2)	^L


LINE 66, PAGE 50
1)		JRST PPART2		;YES, GET POSSIBLE SPECIAL LITERAL
1)	PPART1:	CALL EVAL		;GET VALUE OF FIELD
1)		 SETOM PERRF		;COULDN'T, MARK AS ERROR
LINE 66, PAGE 40
2)		JRST [	MOVE B,(A)	;YES, GET POSSIBLE SPECIAL LITERAL
2)			CAME B,[ASCII /[\]/]	;IS IT THE SPECIAL ONE?
2)			JRST .+1	;NO
2)			MOVEI B,0	;YES, GET 0 FOR THIS PART OF MASK
2)			MOVE A,BP00	;GET BYTE POINTER TO INSTRUCTION
2)			HRRI A,INSMSK	;MAKE IT POINT TO MASK
2)			DPB B,A		;CLEAR APPROPRIATE PART OF MASK
2)			RET]		;DONE
2)		CALL EVAL		;GET VALUE OF FIELD
2)		 SETOM PERRF		;COULDN'T, MARK AS ERROR


; SRC:<6-EXEC>EXECP.MAC.16 & EXECP.MAC.1 25-Jul-85 2311	PAGE 74



LINE 74, PAGE 50
1)	PPART2:	MOVE B,(A)		;GET POSSIBLE SPECIAL LITERAL
1)		CAME B,[ASCII /[\]/]	;IS IT THE SPECIAL ONE?
1)		JRST PPART1		;NO - BACK TO THE FLOW
1)		MOVEI B,0		;YES, GET 0 FOR THIS PART OF MASK
1)		MOVE A,BP00		;GET BYTE POINTER TO INSTRUCTION
1)		HRRI A,INSMSK		;MAKE IT POINT TO MASK
1)		DPB B,A			;CLEAR APPROPRIATE PART OF MASK
1)		RET			;DONE
1)	
1)	END
LINE 81, PAGE 40
2)	END
