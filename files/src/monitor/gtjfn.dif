

; GTJFN.MAC.3 & <6-1-MONITOR>GTJFN.MAC.5 18-Mar-89 1423	PAGE 1



LINE 1, PAGE 1
1)	;[SRI-NIC]SRC:<MONITOR>GTJFN.MAC.2, 11-Nov-88 00:01:36, Edit by MKL
1)	; v7 merge 
1)	;   comment out RELRNG kludge below to see if it still happens
1)	;[SRI-NIC]SRC:<6-1-MONITOR>GTJFN.MAC.4, 19-Apr-88 13:06:35, Edit by MKL
LINE 1, PAGE 1
2)	;[SRI-NIC]SRC:<6-1-MONITOR>GTJFN.MAC.4, 19-Apr-88 13:06:35, Edit by MKL


LINE 11, PAGE 1
1)	;<6-1-MONITOR.FT6>GTJFN.MAC.2, 11-Aug-85 19:34:51, Edit by WHP4
1)	;Stanford changes:
1)	; Changes for CWR's attribute lookup code
1)	
1)	; Edit= 8801 to GTJFN.MAC on 17-Mar-88 by RASPUZZI
1)	;Prevent ILMNRFs or RELBADs by having GNJFN% and JFNS% use the JFNLCK when
1)	;dealing with important information in the JFN block. 
1)	; UPD ID= 8524, RIP:<7.MONITOR>GTJFN.MAC.11,   9-Feb-88 15:52:44 by GSCOTT
1)	;TCO 7.1218 - Update copyright date.
1)	; UPD ID= 8413, RIP:<7.MONITOR>GTJFN.MAC.10,   4-Feb-88 12:08:17 by GSCOTT
1)	;TCO 7.1210 - Set NOSPLM normally not dumpable.
1)	; UPD ID= 8332, RIP:<7.MONITOR>GTJFN.MAC.9,  31-Dec-87 08:39:23 by RASPUZZI
1)	;More of TCO 7.1168 - Apparently, .CHWL1 is not defined in a useful place
1)	;                     like MONSYM. Add it here so GTJFN will compile.
1)	; UPD ID= 8331, RIP:<7.MONITOR>GTJFN.MAC.8,  29-Dec-87 11:14:44 by RASPUZZI
1)	;TCO 7.1168 - Prevent ASTJFN BUGHLTs by making GTJFN understand that a
1)	;	      file spec like "foo.boo;*" is illegal. It never worked and
1)	;	      and it never will.
1)	; UPD ID= 223, RIP:<7.MONITOR>GTJFN.MAC.7,  28-Oct-87 14:14:09 by MCCOLLUM
1)	;TCO 7.1095 - Make SETDEV handle parse-only the way it always used to.
1)	; UPD ID= 177, RIP:<7.MONITOR>GTJFN.MAC.6,  21-Oct-87 16:55:41 by MCCOLLUM
1)	;TCO 7.1078 - Don't clear JSUC for parse-only JFNs in SETDEV
1)	; UPD ID= 140, RIP:<7.MONITOR>GTJFN.MAC.5,  25-Sep-87 11:17:24 by GSCOTT
1)	;TCO 7.1064 - That fine VANISH routine broke labeled tapes, it should only
1)	; check to see if the "old" file exists if it is on disk.  Clean up pagination.
1)	; UPD ID= 127, RIP:<7.MONITOR>GTJFN.MAC.4,  23-Sep-87 15:44:16 by MCCOLLUM
1)	;TCO 7.1063 - Make GTJFN% check for STRX10 in SETDEV
1)	; UPD ID= 26, RIP:<7.MONITOR>GTJFN.MAC.3,  29-Jun-87 16:36:43 by RASPUZZI
1)	;TCO 7.1014 - Implement partial file recognition.
1)	; *** Edit 7420 to GTJFN.MAC by RASPUZZI on 6-Mar-87
1)	; Prevent GTJFN% from ITRAPping by modifying edit 7300
1)	; *** Edit 7415 to GTJFN.MAC by RASPUZZI on 10-Feb-87
1)	; Teach routine GCH that "-" CRLF is a continuation of a line and not part of
1)	; the file specification
1)	; *** Edit 7408 to GTJFN.MAC by RASPUZZI on 31-Dec-86, for SPR #21410
1)	; Prevent RELRNG BUGCHKs by cleaning up the RELJFN code and putting back SETZMs
1)	; that edit 7371 moved.
1)	; *** Edit 7401 to GTJFN.MAC by KKLEINER on 20-Nov-86
1)	; At LCCH, don't upper-case characters if we are parsing a userid, password,

; GTJFN.MAC.3 & <6-1-MONITOR>GTJFN.MAC.5 18-Mar-89 1423	PAGE 2


1)	; account, or optional data file attribute. 
1)	; *** Edit 7393 to GTJFN.MAC by RASPUZZI on 18-Nov-86, for SPR #21272
1)	; Finally, restore the use of VANISH and wit for more things to break.
1)	; *** Edit 7386 to GTJFN.MAC by MCCOLLUM on 23-Oct-86
1)	; At ENDALS, make sure FILPRT is > 0, but only supply RH to RELFRE 
1)	; *** Edit 7385 to GTJFN.MAC by MCCOLLUM on 22-Oct-86
1)	; Use only left half of FILPRT when release free space in ENDALS 
1)	; *** Edit 7384 to GTJFN.MAC by MCCOLLUM on 15-Oct-86, for SPR #21288
1)	; Add ASGF2 to FILST1. This bit should ALWAYS shadow the state of ASGF in
1)	; FILSTS 
1)	; *** Edit 7383 to GTJFN.MAC by RASPUZZI on 15-Oct-86
1)	; Remove call to VANISH. It still doesn't want to work with DUMPER 
1)	; *** Edit 7381 to GTJFN.MAC by RASPUZZI on 14-Oct-86
1)	; Prevent PSINSKs and NOSKTRs by not letting VANISH leave us CSKED 
1)	; *** Edit 7380 to GTJFN.MAC by RASPUZZI on 10-Oct-86, for SPR #21272
1)	; Save trashed AC before calling VERLUK 
1)	; *** Edit 7379 to GTJFN.MAC by RASPUZZI on 9-Oct-86, for SPR #21272
1)	; Prevent CSKBUG BUGHLTs by not jumping to GNFAIL from IFNSK.
1)	; *** Edit 7377 to GTJFN.MAC by RASPUZZI on 7-Oct-86, for SPR #21272
1)	; Reinstall edit 7371 with nice things so it works. 
1)	; *** Edit 7373 to GTJFN.MAC by RASPUZZI on 3-Oct-86
1)	; Remove edit 7371 until it works 100%. 
1)	; *** Edit 7371 to GTJFN.MAC by RASPUZZI on 30-Sep-86, for SPR #21272
1)	; Prevent ILMNRFs by checking to see if current file exists before actually
1)	; doing a GNJFN%.
1)	; *** Edit 7345 to GTJFN.MAC by MCCOLLUM on 30-Jul-86, for SPR #21341
1)	; Call ASGJFN in USRJFN if the user-supplied JFN is used and .GJALT specified 
1)	; *** Edit 7300 to GTJFN.MAC by RASPUZZI on 23-May-86, for SPR #21241
LINE 8, PAGE 1
2)	
2)	; *** Edit 7300 to GTJFN.MAC by RASPUZZI on 23-May-86, for SPR #21241


LINE 81, PAGE 1
1)	; *** Edit 7206 to GTJFN.MAC by WAGNER on 4-Dec-85, for SPR #20941
1)	; Fix RELRNG bughlts caused by trying to release non-existant temp storage.
1)	; There is no temp storage when a JFN is transitional. 
1)	; *** Edit 7194 to GTJFN.MAC by LOMARTIRE on 15-Nov-85 (TCO none)
LINE 13, PAGE 1
2)	
2)	;------------------------- Autopatch Tape # 13 -------------------------
2)	; *** Edit 7206 to GTJFN.MAC by WAGNER on 4-Dec-85, for SPR #20941
2)	; Fix RELRNG bughlts caused by trying to release non-existant temp storage.
2)	; There is no temp storage when a JFN is transitional. 
2)	;------------------------- Autopatch Tape # 12 -------------------------
2)	; *** Edit 7194 to GTJFN.MAC by LOMARTIRE on 15-Nov-85 (TCO none)


; GTJFN.MAC.3 & <6-1-MONITOR>GTJFN.MAC.5 18-Mar-89 1423	PAGE 3



LINE 88, PAGE 1
1)	; UPD ID= 2263, SNARK:<6.1.MONITOR>GTJFN.MAC.59,  21-Jun-85 12:20:23 by LOMARTIRE
LINE 23, PAGE 1
2)	;<6-1-MONITOR.FT6>GTJFN.MAC.2, 11-Aug-85 19:34:51, Edit by WHP4
2)	;Stanford changes:
2)	; Add ? handling (see lines marked with SMXGTJ)
2)	; Partial recognition for filenames
2)	; Changes for CWR's attribute lookup code
2)	; Fix random punctuation
2)	;
2)	; UPD ID= 2263, SNARK:<6.1.MONITOR>GTJFN.MAC.59,  21-Jun-85 12:20:23 by LOMARTIRE


LINE 247, PAGE 1
1)	;	COPYRIGHT (c) DIGITAL EQUIPMENT CORPORATION 1976, 1988.
1)	;	ALL RIGHTS RESERVED.
1)	;
1)	;	THIS SOFTWARE IS FURNISHED UNDER A  LICENSE AND MAY BE USED AND  COPIED
1)	;	ONLY IN  ACCORDANCE  WITH  THE  TERMS OF  SUCH  LICENSE  AND  WITH  THE
1)	;	INCLUSION OF THE ABOVE  COPYRIGHT NOTICE.  THIS  SOFTWARE OR ANY  OTHER
1)	;	COPIES THEREOF MAY NOT BE PROVIDED  OR OTHERWISE MADE AVAILABLE TO  ANY
1)	;	OTHER PERSON.  NO  TITLE TO  AND OWNERSHIP  OF THE  SOFTWARE IS  HEREBY
1)	;	TRANSFERRED.
1)	;
1)	;	THE INFORMATION IN THIS  SOFTWARE IS SUBJECT  TO CHANGE WITHOUT  NOTICE
1)	;	AND SHOULD  NOT  BE CONSTRUED  AS  A COMMITMENT  BY  DIGITAL  EQUIPMENT
1)	;	CORPORATION.
1)	;
1)	;	DIGITAL ASSUMES NO  RESPONSIBILITY FOR  THE USE OR  RELIABILITY OF  ITS
1)	;	SOFTWARE ON EQUIPMENT THAT IS NOT SUPPLIED BY DIGITAL.
1)	
1)	^L
1)		SEARCH PROLOG
LINE 1, PAGE 2
2)	^L
2)	
2)	;THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY  BE  USED
2)	;OR COPIED ONLY IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
2)	;
2)	;COPYRIGHT  (C)  DIGITAL  EQUIPMENT  CORPORATION  1976, 1985.
2)	;ALL RIGHTS RESERVED.
2)	
2)	
2)		SEARCH PROLOG


; GTJFN.MAC.3 & <6-1-MONITOR>GTJFN.MAC.5 18-Mar-89 1423	PAGE 4



LINE 11, PAGE 2
1)	.CHWL1==:"*"			;[7.1168] The other wildcard character
1)	
LINE 19, PAGE 3
2)	


LINE 51, PAGE 3
1)	MSKSTR SAWSEM,FLAGS(TXT),1B16		;[7.1168] Saw a semi-colon
1)	^L
LINE 1, PAGE 5
2)	^L


LINE 37, PAGE 6
1)		;..
1)	^L	;..
1)		CC1($COLON)		; Colon
LINE 37, PAGE 8
2)		CC1($COLON)		; Colon


LINE 33, PAGE 8
1)	QBRK::!	CALL QUEST		;[7.1014] (32) ?
1)	WILDC::!CALL PCENT		;[7.1014] (33) Wildcard character
1)	CARRET::!CALL DOCR		; (34) CARRIAGE RETURN
LINE 33, PAGE 9
2)	IFE STANSW,<			; [SMXGTJ]
2)	QBRK:!	ERRLJF (GJFX34)		; (32) ?
2)	WILDC:!	CALL QUEST		;(33) WILD CARD CHARACTER
2)	>;IFE STANSW			; [SMXGTJ]
2)	IFN STANSW,<			; [SMXGTJ]
2)	QBRK:!	CALL QUEST		; (32) ?
2)	WILDC:!	CALL PCENT		;(33) WILD CARD CHARACTER
2)	>;IFN STANSW			; [SMXGTJ]
2)	CARRET::!CALL DOCR		; (34) CARRIAGE RETURN


LINE 7, PAGE 9
1)		TRVAR <INFMOD,<INFCOC,2>,BKGCH,LDPTMP,LDCTMP,CRPTMP,CRCTMP> ;[7.1014]
1)			;INFMOD - SAVED RFMOD OF INPUT FILE IF ANY
1)			;INFCOC - SAVED RFCOC OF INPUT FILE IF ANY
1)			;BKGCH - BACKED UP CHARACTER FROM GCH
1)			;These next four locations are used to preserve the
1)			;TEXTI% context when GTJFN% is processing a "?"
1)			;LDPTMP - Byte pointer used by ILDB's
1)			;LDCTMP - Count of bytes in above string
1)			;CRPTMP - Current byte pointer
1)			;CRCTMP - Count of bytes in above byte pointer

; GTJFN.MAC.3 & <6-1-MONITOR>GTJFN.MAC.5 18-Mar-89 1423	PAGE 5


1)		SETZB TXT,BKGCH		; MARK THAT TXT IS NOT SET UP YET
LINE 7, PAGE 10
2)		TRVAR <INFMOD,<INFCOC,2>,BKGCH>
2)			;INFMOD - SAVED RFMOD OF INPUT FILE IF ANY
2)			;INFCOC - SAVED RFCOC OF INPUT FILE IF ANY
2)			;BKGCH - BACKED UP CHARACTER FROM GCH
2)		SETZB TXT,BKGCH		; MARK THAT TXT IS NOT SET UP YET


LINE 39, PAGE 9
1)		;..
1)	^L
1)		;..
1)		CALL SETINF		;SETUP FILES IF NECESSARY
LINE 33, PAGE 10
2)		CALL SETINF		;SETUP FILES IF NECESSARY


LINE 1, PAGE 11
1)	^L
1)	;INITIALIZATION CONTINUES...SETUP BLOCK TO BE USED BY RDTXT FOR INPUT
LINE 62, PAGE 10
2)	
2)	;INITIALIZATION CONTINUES...SETUP BLOCK TO BE USED BY RDTXT FOR INPUT


LINE 18, PAGE 13
1)		;..
1)	^L
1)	;NOT A STRING. READ THE FILE
LINE 18, PAGE 11
2)	
2)	;NOT A STRING. READ THE FILE


LINE 17, PAGE 15
1)		TMNN <SAWSEM>		;[7.1168] Did we just see a semi-colon?
1)		IFSKP.			;[7.1168] If so,
1)		  CAIE A,.CHWL1		;[7.1168] Is it followed with a *?
1)		  IFSKP.		;[7.1168] If so,
1)		    MOVEI A,GJFX40	;[7.1168] Say undefined attribute
1)		    JRST ERRDO		;[7.1168] And clean up
1)		  ENDIF.		;[7.1168]
1)		ENDIF.			;[7.1168]
1)		TMNE <CNTVF>		; Control-v pending?
LINE 17, PAGE 12
2)		TMNE <CNTVF>		; Control-v pending?


; GTJFN.MAC.3 & <6-1-MONITOR>GTJFN.MAC.5 18-Mar-89 1423	PAGE 6



LINE 30, PAGE 15
1)		;..
1)	^L	;..
1)		MOVX B,SAWSEM		;[7.1168] Check if a semi-colon was typed
1)		CAIE A,73		;[7.1168] Was it?
1)		IFSKP.			;[7.1168] If so,
1)		  IORM B,FLAGS(TXT)	;[7.1168] Say we have seen a semi colon
1)		ELSE.			;[7.1168]
1)		  ANDCAM B,FLAGS(TXT)	;[7.1168] No semi colon this time
1)		ENDIF.			;[7.1168]
1)		MOVX B,SAWCR		;SEE IF JUST SAW A CR
LINE 22, PAGE 12
2)		MOVX B,SAWCR		;SEE IF JUST SAW A CR


LINE 39, PAGE 16
1)	
1)	GTJF21:	XCT CHDTB(B)		; Execute the dispatch table
LINE 52, PAGE 12
2)	GTJF21:	XCT CHDTB(B)		; Execute the dispatch table


LINE 1, PAGE 17
1)	^L
1)	;MAIN STRING EXHAUSTED
LINE 59, PAGE 12
2)	
2)	;MAIN STRING EXHAUSTED


LINE 1, PAGE 20
1)	^L
1)	; Simple characters
1)	
1)	LCCH:	MOVX B,ARBATF		;[7401]Are we collecting an attribute
1)		TDNN B,FLAGS(TXT)	;[7401] argument now?
1)		JRST LCCH1		;[7401]No, go ahead and convert to uppercase
1)		MOVE B,PREFIX(TXT)	;[7401]Yes, find out which attribute
1)		CAIE B,.PFPWD		;[7401]Is it a password?
1)		CAIN B,.PFUDT		;[7401]Or a userid?
1)		JRST UCCH		;[7401]Yes, so don't uppercase it
1)		CAIE B,.PFACN		;[7401]The same goes for network account
1)		CAIN B,.PFOPT		;[7401]Or the optional data
1)		JRST UCCH		;[7401]Yes, so don't uppercase it
1)	LCCH1:	SUBI A,40		;[7401] Convert lower case to upper
1)	UCCH:	TQZ <NUMFF>		; Number is invalid now
LINE 27, PAGE 13
2)	
2)	; Simple characters

; GTJFN.MAC.3 & <6-1-MONITOR>GTJFN.MAC.5 18-Mar-89 1423	PAGE 7


2)	
2)	LCCH:	SUBI A,40		; Convert lower case to upper
2)	UCCH:	TQZ <NUMFF>		; Number is invalid now


LINE 1, PAGE 25
1)	^L
1)	;DEFAULT THE NODE NAME IF GIVEN
LINE 13, PAGE 16
2)	
2)	;DEFAULT THE NODE NAME IF GIVEN


LINE 7, PAGE 26
1)		  TXNN E,-1B17		;[7298] Have JFN block?
1)		  TQNN JFNRD		;EXTENDED JFN BLOCK?
1)		  RETSKP		;NO, DEFAULT NODE NOT PROVIDED
1)		  XCTU [HRRZ A,.GJF2(E)];[7298] Get count in extended GTJFN block
LINE 19, PAGE 16
2)	;**;[7298] Change 1 line at DEFNOD:+3	MDR	22-MAY-86
2)		  TXNN E,-1B17		;[7298] Have JFN block?
2)		  TQNN JFNRD		;EXTENDED JFN BLOCK?
2)		  RETSKP		;NO, DEFAULT NODE NOT PROVIDED
2)	;**;[7298] Add 3 lines at DEFNOD:+6	MDR	22-MAY-86
2)		  XCTU [HRRZ A,.GJF2(E)];[7298] Get count in extended GTJFN block


LINE 13, PAGE 28
1)	ENDSDV:	TQNN <ASTAF,OSTRF>	;[7.1014] Stars allowed?
1)		RETBAD (GJFX31)		;[7.1014] No give bad return
1)		CALL STRDEV		; SET UP FIRST STR IN LIST
LINE 13, PAGE 18
2)	ENDSDV:
2)	IFN STANSW,<			; [SMXGTJ]
2)		TQNN <ASTAF,OSTRF>	; STARS ALLOWED?
2)		 RETBAD (GJFX31)	; NO. GIVE BAD RETURN
2)	>;IFN STANSW			; [SMXGTJ]
2)		CALL STRDEV		; SET UP FIRST STR IN LIST


LINE 1, PAGE 29
1)	^L
1)	;ROUTINE TO CHECK THE SYNTAX OF STARED DEVICE FIELD
LINE 26, PAGE 18
2)	
2)	;ROUTINE TO CHECK THE SYNTAX OF STARED DEVICE FIELD


; GTJFN.MAC.3 & <6-1-MONITOR>GTJFN.MAC.5 18-Mar-89 1423	PAGE 8



LINE 1, PAGE 33
1)	^L
1)	STRDIR:	TQNN <ASTAF,OSTRF>	;[7.1014] Stars allowed?
1)		RETBAD (GJFX31)		;[7.1014] No, give bad return
1)		MOVE A,FLAGS(TXT)	; SEE IF A WILD MASK
LINE 36, PAGE 20
2)	
2)	STRDIR:
2)	IFN STANSW,<			; [SMXGTJ]
2)		TQNN <ASTAF,OSTRF>	; STARS ALLOWED?
2)		 RETBAD (GJFX31)	; NO. GIVE BAD RETURN
2)	>;IFN STANSW			; [SMXGTJ]
2)		MOVE A,FLAGS(TXT)	; SEE IF A WILD MASK


LINE 2, PAGE 37
1)	STARNM:	TQNN <ASTAF,OSTRF>	;[7.1014] Stars allowed?
1)		RETBAD (GJFX31)		;[7.1014] No give bad return
1)		MOVE A,FLAGS(TXT)	; SEE IF A WILD MASK
LINE 2, PAGE 23
2)	STARNM:	
2)	IFN STANSW,<			; [SMXGTJ]
2)		TQNN <ASTAF,OSTRF>	; STARS ALLOWED?
2)		 RETBAD (GJFX31)	; NO. GIVE BAD RETURN
2)	>;IFN STANSW			; [SMXGTJ]
2)		MOVE A,FLAGS(TXT)	; SEE IF A WILD MASK


LINE 1, PAGE 39
1)	^L
1)	ENDEX1:	TQZN <PRTFF>		; Were we collecting a protection
LINE 50, PAGE 24
2)	
2)	ENDEX1:	TQZN <PRTFF>		; Were we collecting a protection


LINE 12, PAGE 40
1)	STREXT:	TQNN <ASTAF,OSTRF>	;[7.1014] Stars allowed
1)		RETBAD (GJFX31)		;[7.1014] No, give bad return
1)		MOVE A,FLAGS(TXT)	; SEE IF A WILD MASK
LINE 61, PAGE 24
2)	STREXT:
2)	IFN STANSW,<			; [SMXGTJ]
2)		TQNN <ASTAF,OSTRF>	; STARS ALLOWED?
2)		 RETBAD (GJFX31)	; NO. GIVE BAD RETURN
2)	>;IFN STANSW			; [SMXGTJ]
2)		MOVE A,FLAGS(TXT)	; SEE IF A WILD MASK


; GTJFN.MAC.3 & <6-1-MONITOR>GTJFN.MAC.5 18-Mar-89 1423	PAGE 9



LINE 1, PAGE 41
1)	^L
1)	ENDEX5:	MOVX A,PREFXF		;GATHERING A PREFIX?
LINE 107, PAGE 24
2)	
2)	ENDEX5:	MOVX A,PREFXF		;GATHERING A PREFIX?


LINE 40, PAGE 42
1)	STRVR1:	CALL GTVER		;[7.1014] (/A) Lookup this version
1)		 JRST STEPLN		; GO TRY TO STEP LOGICAL NAME
1)		MOVX B,VERFF		;[7.1014] No longer looking for version after
1)		ANDCAM B,FLAGS(TXT)	;[7.1014]  we have obtained one
1)		JRST ENDEX0
1)	
1)	STRVER:	TQNN <ASTAF,OSTRF>	;[7.1014] Stars allowed?
1)		RETBAD (GJFX31)		;[7.1014] Nope
1)		TQO <VERSF,STEPF>
LINE 146, PAGE 24
2)	IFE STANSW,<
2)	STRVR1:	CALL VERLUK		; Lookup this version
2)		 JRST STEPLN		; GO TRY TO STEP LOGICAL NAME
2)		HRRM A,FILVER(JFN)
2)		MOVEM B,FILFDB(JFN)	; REMEMBER THE FDB ADDRESS
2)		TQO <VERTF>		; Remember that version was input
2)	>;IFE STANSW
2)	IFN STANSW,<			; [SMXGTJ]
2)	STRVR1:	CALL GTVER		; LOOKUP THIS VERSION (AND CHECK ACCESS)
2)		 JRST STEPLN		; GO TRY TO STEP LOGICAL NAME
2)	>;IFN STANSW			; [SMXGTJ]
2)	IFN STANSW,<			;[CWR] THIS SHOULD PROBABLY BE A BUG FIX, 
2)		MOVX B,VERFF		;[CWR]   AS WE'RE NO LONGER LOOKING FOR A VERSION
2)		ANDCAM B,FLAGS(TXT)	;[CWR]   AFTER WE'VE SAID WE'VE GOTTEN ONE
2)	>;IFN STANSW
2)		JRST ENDEX0
2)	
2)	STRVER:
2)	IFN STANSW,<			; [SMXGTJ]
2)		TQNN <ASTAF,OSTRF>	; STARS ALLOWED?
2)		 RETBAD (GJFX31)	; NO. GIVE BAD RETURN
2)	>;IFN STANSW			; [SMXGTJ]
2)		TQO <VERSF,STEPF>


; GTJFN.MAC.3 & <6-1-MONITOR>GTJFN.MAC.5 18-Mar-89 1423	PAGE 10



LINE 32, PAGE 45
1)		;..
1)	^L	;..
1)	
1)	DEFDV0:	TQZE <DFSTF>
LINE 32, PAGE 27
2)	DEFDV0:	TQZE <DFSTF>


LINE 1, PAGE 47
1)	^L
1)	DEFSDV:	CALL STRDVD		;CHECK SYNTAX OF STAR IN DEVICE FIELD
1)		 RETBAD ()		;ILLEGAL SYNTAX
1)		JRST DFDV0A		;NOW HAVE THE FIRST DEVICE NAME
1)	
1)	DEFDV1:	MOVEI B,3		; Need 3 words TO HOLD STR NAME
LINE 57, PAGE 27
2)	
2)	DEFSDV:	CALL STRDVD		;CHECK SYNTAX OF STAR IN DEVICE FIELD
2)		 RETBAD ()		;ILLEGAL SYNTAX
2)		JRST DFDV0A		;NOW HAVE THE FIRST DEVICE NAME
2)	^L
2)	DEFDV1:	MOVEI B,3		; Need 3 words TO HOLD STR NAME


LINE 1, PAGE 49
1)	^L
1)	DFDVL0:	NOINT			;PUT LOGICAL NAME STRING INTO FILLNM
LINE 24, PAGE 28
2)	
2)	
2)	DFDVL0:	NOINT			;PUT LOGICAL NAME STRING INTO FILLNM


LINE 36, PAGE 52
1)		;..
1)	^L	;..
1)		SETZ B,			;THIS JSB IS MAPPED
LINE 36, PAGE 30
2)		SETZ B,			;THIS JSB IS MAPPED


; GTJFN.MAC.3 & <6-1-MONITOR>GTJFN.MAC.5 18-Mar-89 1423	PAGE 11



LINE 7, PAGE 53
1)		CALL CHKMNT		;[7.1063](T1,T2/T1)Did user mount this structure
1)		IFNSK.			;[7.1063]If not...
1)		  UNLOCK JSSTLK		;[7.1063]Unlock structure info lock in JSB
1)		  OKINT			;[7.1063]Allow interrupts now
1)		  TQNN <ASTF>		;[7.1095]Parse-only?
1)		  RETBAD ()		;[7.1095]Return the error
1)		  SETZ C,		;[7.1095]Yes, structure is ok
1)		  HRRM C,FILIDX(JFN)	;[7.1095]Clear index into device tables
1)		  STOR C,FLUC,(JFN)	;[7.1095]Clear unique code
1)		  MOVEM C,FILDEV(JFN)	;[7.1095]Clear device
1)		  RETSKP		;[7.1095]Return success
1)		ENDIF.			;[7.1063]
1)		UNLOCK JSSTLK		;[7.1063]Unlock structure info lock in JSB
1)		OKINT			;[7.1063]Allow interrupts now
1)		LOAD A,STR,(JFN)	;[7.1063]Get structure number
1)		CALL CKSTOF		;[7.1063](T1/T1)Is structure offline?
1)		 RETBAD ()		;[7.1063]Return "Structure is offline"
1)		RETSKP			;[7.1063]Return +2 to caller
1)	
LINE 41, PAGE 30
2)		CALL CHKMNT		;DID USER MOUNT THIS STRUCTURE
2)		 JRST [ UNLOCK JSSTLK	; NO, FAIL
2)			OKINT		;ALLOW INTERRUPTS NOW
2)			TQNN <ASTF>	;PARSE-ONLY?
2)			RETBAD		;NO
2)			SETZ C,		;YES, STRUCTURE IS OK
2)			HRRM C,FILIDX(JFN) ;CLEAR INDEX INTO DEVICE TABLES
2)			STOR C,FLUC,(JFN) ;CLEAR UNIQUE CODE
2)			MOVEM C,FILDEV(JFN) ;CLEAR DEVICE
2)			RETSKP]
2)		UNLOCK JSSTLK		;UNLOCK STR INFO LOCK IN JSB
2)		OKINT			;ALLOW INTERRUPTS NOW
2)		RETSKP			;RETURN SUCCESSFULLY
2)	


LINE 1, PAGE 60
1)	^L
1)	DEFDI1:	BLCAL. DSKOK,<<FILDEV(JFN)>> ;REAL DISK?
LINE 49, PAGE 36
2)	
2)	DEFDI1:	BLCAL. DSKOK,<<FILDEV(JFN)>> ;REAL DISK?


; GTJFN.MAC.3 & <6-1-MONITOR>GTJFN.MAC.5 18-Mar-89 1423	PAGE 12



LINE 1, PAGE 62
1)	^L
1)	;HERE IF DIRECTORY LOOKUP FAILED
LINE 84, PAGE 36
2)	
2)	;HERE IF DIRECTORY LOOKUP FAILED


LINE 1, PAGE 65
1)	^L
1)	;ROUTINE TO GET THE DIRECTORY # FROM STRING AND UPDATE FILDDN(JFN)
LINE 40, PAGE 37
2)	
2)	
2)	;ROUTINE TO GET THE DIRECTORY # FROM STRING AND UPDATE FILDDN(JFN)


LINE 1, PAGE 69
1)	^L
1)	DFSTRN:	MOVE A,FLAGS(TXT)	; SEE IF A WILD MASK
LINE 43, PAGE 39
2)	
2)	DFSTRN:	MOVE A,FLAGS(TXT)	; SEE IF A WILD MASK


LINE 30, PAGE 73
1)		IFNSK.			;[7.1014]
1)		  TQNN <ASTAF,OSTRF>	;[7.1014] Stars allowed?
1)		  TQNE <ASTF>		;[7.1014] * already seen?
1)		  SKIPA			;[7.1014] Allow it
1)		  RETBAD (GJFX31)	;[7.1014] No, give an error now
1)		  JRST DFSTRV		;[7.1014] Yes, default the version to *
1)		ENDIF.			;[7.1014]
1)		CAMN A,[-2]		;-2 MEANS LOWEST
LINE 30, PAGE 42
2)	IFE STANSW,<			; [SMXGTX]
2)		JRST [	TQNN <ASTAF>	;STARS ALLOWED?
2)	>;IFE STANSW
2)	IFN STANSW,<			; [SMXGTX]
2)		JRST [	TQNN <ASTAF,OSTRF> ;STARS ALLOWED?
2)	>;IFN STANSW
2)			TQNE <ASTF>	;* ALREADY SEEN?
2)			SKIPA		;ALLOW IT
2)			RETBAD (GJFX31)	;NO, GIVE AN ERROR NOW
2)			JRST DFSTRV]	;YES, DEFAULT THE VERSION TO *
2)		CAMN A,[-2]		;-2 MEANS LOWEST


; GTJFN.MAC.3 & <6-1-MONITOR>GTJFN.MAC.5 18-Mar-89 1423	PAGE 13



LINE 43, PAGE 73
1)		;..
1)	^L	;..
1)	DEFVR2:	CALL GTVER		;[7.1014] (/A) Extant?
1)		 JRST STEPLN		;[7.1014]  No, step logical name
1)		MOVE B,A
LINE 46, PAGE 42
2)	IFE STANSW,<			; [SMXGTJ]
2)	DEFVR2:	CALL VERLUK		; Extant?
2)		 JRST STEPLN		; NO, STEP THE LOGICAL NAME
2)		HRRM A,FILVER(JFN)
2)		MOVEM B,FILFDB(JFN)	; REMEMBER THE FDB ADDRESS
2)	>;IFE STANSW			; [SMXGTJ]
2)	IFN STANSW,<			; [SMXGTJ]
2)	DEFVR2:	CALL GTVER		; EXTANT? (AND CHECK ACESS)
2)		 JRST STEPLN		; NO, STEP THE LOGICAL NAME
2)	>;IFN STANSW			; [SMXGTJ]
2)		MOVE B,A


LINE 37, PAGE 75
1)		;..
1)	^L	;..
1)	DEFAT4:	AOS A,DEFATA		;GET ADDRESS OF NEXT ATTRIBUTE
LINE 37, PAGE 43
2)	DEFAT4:	AOS A,DEFATA		;GET ADDRESS OF NEXT ATTRIBUTE


LINE 1, PAGE 77
1)	^L
1)	;ROUTINE TO CHECK IF AN ATTRIBUTE IS ON THE CHAIN ALREADY
LINE 58, PAGE 43
2)	
2)	
2)	;ROUTINE TO CHECK IF AN ATTRIBUTE IS ON THE CHAIN ALREADY


LINE 1, PAGE 79
1)	^L
1)	;ROUTINE TO ADD AN ATTRIBUTE TO THE CHAIN
LINE 72, PAGE 43
2)	
2)	
2)	;ROUTINE TO ADD AN ATTRIBUTE TO THE CHAIN


; GTJFN.MAC.3 & <6-1-MONITOR>GTJFN.MAC.5 18-Mar-89 1423	PAGE 14



LINE 1, PAGE 81
1)	^L
1)	;ROUTINE TO LINK AN ATTRIBUTE ONTO THE ATTRIBUTE LIST
LINE 93, PAGE 43
2)	
2)	
2)	;ROUTINE TO LINK AN ATTRIBUTE ONTO THE ATTRIBUTE LIST


LINE 1, PAGE 83
1)	^L
1)	;ROUTINE TO READ AND PARSE A DEFAULT PREFIX STRING
LINE 108, PAGE 43
2)	
2)	
2)	;ROUTINE TO READ AND PARSE A DEFAULT PREFIX STRING


LINE 53, PAGE 88
1)		;..
1)	^L	;..
1)	REDFL4:	MOVE C,STTSAV		; RESTORE POINTER
LINE 53, PAGE 47
2)	REDFL4:	MOVE C,STTSAV		; RESTORE POINTER


LINE 1, PAGE 90
1)	^L
1)	REDQST:	MOVX C,DWLDF		; SAY SAW A WILD MASK
LINE 85, PAGE 47
2)	
2)	REDQST:	MOVX C,DWLDF		; SAY SAW A WILD MASK


LINE 2, PAGE 92
1)	;ROUTINE TO COPY A LOGICAL NAME DEFAULT INTO THE DEFAULT STRING
LINE 2, PAGE 48
2)	
2)	;ROUTINE TO COPY A LOGICAL NAME DEFAULT INTO THE DEFAULT STRING


; GTJFN.MAC.3 & <6-1-MONITOR>GTJFN.MAC.5 18-Mar-89 1423	PAGE 15



LINE 1, PAGE 94
1)	^L
1)	;ROUTINE TO COMPARE ACCOUNT STRINGS
LINE 18, PAGE 49
2)	
2)	
2)	;ROUTINE TO COMPARE ACCOUNT STRINGS


LINE 15, PAGE 99
1)		IFNSK.			;[7.1014] Extension lookup failed
1)		  POP P,FILOPT(JFN)	;[7.1014] Get FILOPT back
1)		  IFQN. AMBGF		;[7.1014] If ambiguous, recognize what we can
1)		    MOVE B,FILOPT(JFN)	;[7.1014] Our work string
1)		    CALL TSTRQ		;[7.1014] (B/) Do the work
1)		     RET		;[7.1014] Pass error back
1)		  ENDIF.		;[7.1014]
1)		  TQNE <OLDNF>		;[7.1014] If old file desired,
1)		  JRST RFALSE		;[7.1014] Go step logical name
1)		  RET			;[7.1014] Else return
1)		ENDIF.			;[7.1014]
1)		MOVEM A,FILFDB(JFN)	; REMEMBER THE FDB ADDRESS
LINE 15, PAGE 53
2)		 JRST [	POP P,FILOPT(JFN)
2)	IFE STANSW,<
2)			JN AMBGF,,R	;IF AMBIGUOUS...
2)	>;IFE STANSW
2)	IFN STANSW,<			; Partial recognition
2)			IFQN. AMBGF
2)			  MOVE B,FILOPT(JFN)
2)			  CALL TSTRQ	; Recognize what we can
2)			  RET
2)			ENDIF.
2)	> ;IFN STANSW			; Partial recognition
2)			TQNE <OLDNF>	;IF OLD FILE DESIRED,
2)			JRST RFALSE	;GO STEP LOGICAL NAME
2)			RET]
2)		MOVEM A,FILFDB(JFN)	; REMEMBER THE FDB ADDRESS


LINE 15, PAGE 102
1)		IFNSK.			;[7.1014] Name lookup failed
1)		  POP P,FILOPT(JFN)	;[7.1014] Get FILOPT back
1)		  IFQN. AMBGF		;[7.1014] If ambiguous,
1)		    MOVE B,FILOPT(JFN)	;[7.1014] Get working string
1)		    CALL TSTRQ		;[7.1014] (B/) Recognize all that we can
1)		     JRST RFALSE	;[7.1014] The return ambiguous
1)		  ENDIF.		;[7.1014]
1)		  TQNN <OLDNF>		;[7.1014] New files allowed?

; GTJFN.MAC.3 & <6-1-MONITOR>GTJFN.MAC.5 18-Mar-89 1423	PAGE 16


1)		  TQNE <NREC>		;[7.1014] And trying to recognize?
1)		  JRST STEPLN		;[7.1014] Yes, go step logical name
1)		  JRST RFALSE		;[7.1014] No, return ambiguous
1)		ENDIF.
1)		MOVEM A,FILFDB(JFN)	; REMEMBER THE FDB ADDRESS
LINE 15, PAGE 56
2)		 JRST [	POP P,FILOPT(JFN)
2)	IFE STANSW,<
2)			JN AMBGF,,RFALSE ;IF AMBIGUOUS
2)	>;IFE STANSW
2)	IFN STANSW,<			; Partial recognition
2)			IFQN. AMBGF
2)			  MOVE B,FILOPT(JFN)
2)			  CALL TSTRQ	; Recognize what we can
2)			  JRST RFALSE
2)			ENDIF.
2)	> ;IFN STANSW			; Partial recognition	
2)			TQNN <OLDNF>	;NEW FILES ALLOWED?
2)			TQNE <NREC>	;AND TRYING TO RECOGNIZE?
2)			JRST STEPLN	;YES, GO STEP LOGICAL NAME
2)			JRST RFALSE]	;NO, RETURN AMBIG
2)		MOVEM A,FILFDB(JFN)	; REMEMBER THE FDB ADDRESS


LINE 42, PAGE 105
1)		;..
1)	^L	;..
1)		MOVE C,FILCNT(JFN)
LINE 42, PAGE 59
2)		MOVE C,FILCNT(JFN)


LINE 25, PAGE 106
1)		;..
1)	^L	;..
1)		MOVE C,FLAGS(TXT)	;SEE IF GETTING AN ATTRIBUTE
LINE 65, PAGE 59
2)		MOVE C,FLAGS(TXT)	;SEE IF GETTING AN ATTRIBUTE


LINE 37, PAGE 107
1)		;..
1)	^L	;..
1)	ENDAL4:	TQNE <NNAMF>		; NO NAME DEVICE?
LINE 100, PAGE 59
2)	ENDAL4:	TQNE <NNAMF>		; NO NAME DEVICE?


; GTJFN.MAC.3 & <6-1-MONITOR>GTJFN.MAC.5 18-Mar-89 1423	PAGE 17



LINE 49, PAGE 108
1)		;..
1)	^L	;..
1)	ENDAL9:	TXNN F1,DIRSF!NAMSF!EXTSF!VERSF
LINE 147, PAGE 59
2)	ENDAL9:	TXNN F1,DIRSF!NAMSF!EXTSF!VERSF


LINE 12, PAGE 110
1)		  MOVEI B,ACCTSR-1 	;POINT TO ACCOUNT STRING
1)		  MOVN A,ACCTSL
1)		  HRLI B,2(A)		;LOOKUP POINTER TO ACCOUNT
LINE 12, PAGE 60
2)	IFE STANSW,<
2)		  MOVEI B,ACCTSR-1 	;POINT TO ACCOUNT STRING
2)		  MOVN A,ACCTSL
2)	>;IFE STANSW
2)	IFN STANSW,<		;;FOR SOME REASON, ALTHOUGH IN GLOBS, THIS SYMBOL IS
2)				;; UNDEFINED.  MACRO BUG?  -KSL 27-APR-85 
2)		  MOVEI B,ACCTSR##-1 	;POINT TO ACCOUNT STRING
2)		  MOVN A,ACCTSL##
2)	>;IFN STANSW
2)		  HRLI B,2(A)		;LOOKUP POINTER TO ACCOUNT


LINE 38, PAGE 110
1)		;..
1)	^L	;..
1)	ENDALS:	CALL STRUSR		;RETURN FILE NAME TO THE USER
LINE 45, PAGE 60
2)	ENDALS:	CALL STRUSR		;RETURN FILE NAME TO THE USER


LINE 9, PAGE 111
1)		SETZM FILPRT(JFN)	; AND PROTECTION WORD
LINE 52, PAGE 60
2)		SKIPLE B,FILPRT(JFN)
2)		CALL RELFRE		; And protection
2)		SETZM FILPRT(JFN)	; AND PROTECTION WORD


; GTJFN.MAC.3 & <6-1-MONITOR>GTJFN.MAC.5 18-Mar-89 1423	PAGE 18



LINE 30, PAGE 111
1)		SETZRO ASGF2,(JFN)	;[7384]CLEAR ASGF SHADOW BIT
1)		OKINT
LINE 75, PAGE 60
2)		OKINT


LINE 52, PAGE 111
1)		;..
1)	^L	;..
1)	ENDA51: TQNN <OSTRF>		;Real file
LINE 96, PAGE 60
2)	ENDA51: TQNN <OSTRF>		;Real file


LINE 6, PAGE 114
1)		MOVE A,FILCNT(JFN)	;[7.1014] Allow *'s so *? can give directory listing
1)		MOVE B,CNTWRD(TXT)	;GET MAX VALUE
LINE 6, PAGE 62
2)	IFE STANSW,<			; [SMXGTJ]
2)		TQNN <ASTF>		;* ALREADY SEEN?
2)		TQNE <ASTAF>
2)		SKIPA A,FILCNT(JFN)	;ALLOW IT
2)		RETBAD (GJFX31)		; Illegal *
2)	>;IFE STANSW			; [SMXGTJ]
2)	IFN STANSW,<			; [SMXGTJ]
2)		MOVE A,FILCNT(JFN)	; ALLOW STARS SO *? CAN GIVE DIRECTORY LISTING
2)	>;IFN STANSW			; [SMXGTJ]
2)		MOVE B,CNTWRD(TXT)	;GET MAX VALUE


LINE 21, PAGE 114
1)	PCENT:	TQNE <NUMFF>		;[7.1014] FOR WILD CHARS. ON A NUMBER?
1)		RETBAD (GJFX4)		; YES. ILLEGAL CHARACTER THEN
1)		CALL DPST		; SAVE BYTE
1)		 RETBAD()		; NO ROOM
1)		MOVX A,WLDF		; FOR FLAGS
LINE 29, PAGE 62
2)	IFE STANSW,<			; [SMXGTJ]
2)	QUEST:
2)	>;IFE STANSW			; [SMXGTJ]
2)	IFN STANSW,<			; [SMXGTJ]
2)	PCENT:				; MAKE ROUTINE NAME MEANINGFUL
2)	>;IFN STANSW			; [SMXGTJ]
2)		TQNE <NUMFF>		; FOR WILD CHARS. ON A NUMBER?
2)		RETBAD (GJFX4)		; YES. ILLEGAL CHARACTER THEN
2)		CALL DPST		; SAVE BYTE
2)		 RETBAD()		; NO ROOM
2)	IFE STANSW,<			; [SMXGTJ] ALLOW STARS SO *? GIVES DIR LISTING

; GTJFN.MAC.3 & <6-1-MONITOR>GTJFN.MAC.5 18-Mar-89 1423	PAGE 19


2)		TQNN <ASTF>		;* ALREADY SEEN?
2)		TQNE <ASTAF>		; STARS ALLOWED?
2)		IFSKP. <
2)		  RETBAD (GJFX31)>	; NO. GIVE BAD RETURN
2)	>;IFE STANSW			; [SMXGTJ]
2)		MOVX A,WLDF		; FOR FLAGS


LINE 2, PAGE 115
1)	;[7.1014]
1)	; The following routines handle user question mark input. This is entered
1)	; from the input char dispatch table. If the input is NIL, this will return
1)	; immediately. Otherwise, list the candidates for the field currently being
1)	; entered if no previous field had a wild card. If no candidates are found,
1)	; break with GJFX34. Scan for candidates is terminated on last one.
1)	;
1)	;QUEST - Routine dispatched to when "?" is seen.
1)	;
1)	; Called with:
1)	;	TEXTI% context setup
1)	;	CALL through dispatch table when "?" is seen
1)	;
1)	; Returns:
1)	;	+1 - Always
1)	
1)	QUEST:	MOVE A,CURCNT(TXT)	;Get current string
1)		AOS A			;Move one past (should be a null)
1)		CAML A,STRCNT(TXT)	;Was "?" first thing typed?
1)		ERRLJF GJFX34		;Yes, then break on it
1)		TQNE <OSTRF>		;GJ%OFG, parse only?
1)		TQNE <ASTAF>		;GJ%IFG, normal indexable bit?
1)		SKIPA			;No to either
1)		ERRLJF GJFX34		;GJ%OFG and not GJ%IFG, this prevents a loop
1)		CALL INFTST		;(/A) Test for no input JFN
1)		 ERRLJF GJFX34		;None so break out now
1)		MOVEI A,.CHNUL		;Erase the "?"...
1)		DPB A,CURPNT(TXT)	;...by overwriting it with a null
1)		MOVE B,LDPNT(TXT)	;Save TEXTI% context by putting
1)		MOVEM B,LDPTMP		; these variables in the TRVAR
1)		MOVE B,LDCNT(TXT)
1)		MOVEM B,LDCTMP
1)		MOVE B,CURPNT(TXT)
1)		MOVEM B,CRPTMP
1)		MOVE B,CURCNT(TXT)
1)		MOVEM B,CRCTMP
1)		TQNN <DEVF>		;Device specified
1)		CALL DEFDEV		;(/DEV) No, so get default
1)		 HRRZ B,FILDEV(JFN)	;Has to be some flavor of DSK:
1)		CAIE B,DSKDTB		;On disk?
1)		JRST QUEST2		;Nope, ding user and restart
1)		TQO <NREC>		;Turn off recognition

; GTJFN.MAC.3 & <6-1-MONITOR>GTJFN.MAC.5 18-Mar-89 1423	PAGE 20


1)		TQNE <EXTFF>		;Extension being specified?
1)		CALLRET QEXTN		;Yes
1)		TQNN <NAMF>		;Name specified?
1)		CALLRET QNAM		;No, must be entering it
1)		TQNN <VERF>		;Version specified?
1)		CALLRET QVER		;No, must be entering it
1)		JRST QUEST3		;Must be in STR or DIR field, no help
1)	^L
1)	QUEST2:	CALL DING		;(/) Can't help in any later fields
1)	QUEST3:	MOVE A,CRCTMP		;Now restore TEXTI% context from TRVAR
1)		MOVEM A,CURCNT(TXT)
1)		MOVE A,CRPTMP
1)		MOVEM A,CURPNT(TXT)
1)		MOVE A,LDCTMP
1)		MOVEM A,LDCNT(TXT)
1)		MOVE A,LDPTMP
1)		MOVEM A,LDPNT(TXT)
1)		MOVE A,MPP		;Get saved stack pointer
1)		MOVE A,0(A)		;Find out what is there
1)		TXNE A,IMCFLG		;Last call internal?
1)		ERRLJF (GJFX34)		;Yes, return illegal "?" error to COMND%
1)		CALL RETYPE		;(/) Retype the input text
1)		CALL BACKIT		;(/) Backup over the NUL (was the "?")
1)	;	CALLRET RESCAN		;Re-establish TEXTI% context
1)	^L
1)	;RESCAN - Routine to initiate a rescan of the user's input.
1)	;The JFN block is initialized.
1)	;
1)	; Call with:
1)	;	TESTI% arguments setup
1)	;	CALL RESCAN
1)	;
1)	; Returns:
1)	;	+1 - Error,
1)	;	     A/ Error code
1)	;	+2 - Success, String retyped on screen
1)	
1)	RESCAN: STKVAR <TMPFLN>		;Save TEXTI% buffer here
1)		NOINT			;Touching sensitive things
1)		HLRZ A,FILLNM(JFN)	;Preserve TEXTI% buffer info
1)		MOVEM A,TMPFLN		; in this location
1)		HRRZS FILLNM(JFN)	;Now make believe it isn't there
1)		CALL RELJFN		;(JFN/) Go cleanup
1)		CALL ASGJFN		;(/JFN) Go get another JFN
1)		IFNSK.
1)		  MOVEI A,JSBFRE	;None left
1)		  SKIPE B,TMPFLN	;If there is something to release,
1)		  CALL RELFRE		;(B/) The release it
1)		   ERRLJF GJFX3		;Return error to user
1)		ENDIF.
1)		MOVE A,TMPFLN		;Setup old retype stuff

; GTJFN.MAC.3 & <6-1-MONITOR>GTJFN.MAC.5 18-Mar-89 1423	PAGE 21


1)		HRLM A,FILLNM(JFN)
1)		OKINT			;Now we can be interrupted
1)		XCTU [HLLZ F,0(E)]	;Get user flags again
1)		SETZ F1,		; and clear others
1)		MOVE A,STRPNT(TXT)	;Reinitialize pointer to input string
1)		MOVEM A,LDPNT(TXT)
1)		SETZM LDCNT(TXT)	;Zap input count
1)		CALL SETTMP		;(JFN/) Get another temp block and continue
1)		 RETBAD()		;Something is wrong
1)		RETSKP			;Return to GCH loop
1)	^L
1)	;[7.1014]
1)	;QNAM - Routine that is called when a question mark has been entered
1)	;in the file name part of the file spec. This routine is the first
1)	;step when printing out a list of candidates for the name field.
1)	;
1)	; Call with:
1)	;	TEXTI% arguments setup
1)	;	CALLRET QNAM
1)	;
1)	; Returns:
1)	;	JRST QUEST3 - When finished
1)	
1)	QNAM:	TQNN <DIRSF>		;Any directory *'s?
1)		CALL QSNAM		;(/) No, append star and find first file
1)		IFSKP.			;If first one found
1)		  DO.			;Loop through all candidates
1)		    LOAD A,FLNSB,(JFN)	;Print this name
1)		    CALL QNXTL		;(A/) Do the printing
1)		    CALL QVNAM0		;(A/) Now look for next name
1)		     EXIT.		;No more, retype
1)		  LOOP.			;Do next candidate
1)		  ENDDO.
1)		ENDIF.
1)		JRST QUEST3		;No directory match	
1)	^L
1)	;[7.1014]
1)	;QEXTN - Routine that is called when a question mark has been entered
1)	;in the extension part of the file spec. This routine is the first
1)	;step when printing out a list of candidates for the extension field.
1)	;
1)	; Call with:
1)	;	TEXTI% arguments setup
1)	;	CALLRET QEXTN
1)	;
1)	; Returns:
1)	;	JRST QUEST3 - When finished
1)	
1)	QEXTN:	TQNN <DIRSF,NAMSF>	;Any directory or name *'s?
1)		CALL QSEXT		;(/) No, append star and find first file
1)		IFSKP.			;If first one found

; GTJFN.MAC.3 & <6-1-MONITOR>GTJFN.MAC.5 18-Mar-89 1423	PAGE 22


1)		  DO.
1)		    LOAD A,FLESB,(JFN)	;Print this name
1)		    MOVE B,1(A)		;Look at the first word of the string
1)		    TLNE B,774000	;Is first character a NUL?
1)		    IFSKP.		;It is null
1)		      MOVEI A,[ASCIZ /[Null]/] ;It is, so make dummy entry
1)		      SOS A		;Set up as string block
1)		    ENDIF.
1)		    CALL QNXTL		;(A/) Print out string
1)		    CALL QVEXT0		;(A/) Now look for next extension
1)		     EXIT.		;None left, retype
1)		  LOOP.			;Do next candidate
1)		  ENDDO.
1)		ENDIF.
1)		JRST QUEST3		;Stars somewhere or no match
1)	^L
1)	;[7.1014]
1)	;QVER - Routine that is called when a question mark has been entered
1)	;in the version part of the file spec. This routine is the first
1)	;step when printing out a list of candidates for the version field.
1)	;
1)	; Call with:
1)	;	TEXTI% arguments setup
1)	;	CALLRET QVER
1)	;
1)	; Returns:
1)	;	JRST QUEST3 - When finished
1)	
1)	QVER:	TQNN <DIRSF,NAMSF,EXTSF> ;Any dir, name, or extension *'s?
1)		CALL QSVER		;(/) No, make it a star and find first file
1)		IFSKP.			;If found first file
1)		  DO.			;Now loop through all versions
1)		    TMSG </
1)	  />				;Make it neat
1)		    LOAD B,FLVNO,(JFN)	;Get version number
1)		    CALL DNOUT		;(B/) Print decimal version
1)		    CALL QVVER0		;(/) Now get next version
1)		     EXIT.		;None left, retype
1)		  LOOP.			;Do next version
1)		  ENDDO.
1)		ENDIF.
1)		JRST QUEST3		;Stars seen or no match
1)	^L
1)	;[7.1014]
1)	;The following routines are for stepping the name, ext and version fields
1)	;and assuring that at least one file is accessible with the new field
1)	;value.
1)	;
1)	; Called with:
1)	;	no arguments
1)	;	CALL QVNAM (to find first one) 

; GTJFN.MAC.3 & <6-1-MONITOR>GTJFN.MAC.5 18-Mar-89 1423	PAGE 23


1)	;	CALL QVNAM0 (when current name is being stepped)
1)	;	    or
1)	;	CALL QVEXT (to find first one)
1)	;	CALL QVEXT0 (when stepping current extension)
1)	;	    or
1)	;	CALL QVVER (to find first one)
1)	;	CALL QVVER0 (when stepping current version)
1)	;
1)	; Returns:
1)	;	+1 - No file found
1)	;	     A/ Error code
1)	;	+2 - Success, file found
1)	;	     With FLNSB(JFN) setup or
1)	;	     With FLESB(JFN) setup or
1)	;	     With FLVNO(JFN) setup
1)	
1)	QVNAM:	SETZ A,			;Find first name in this directory
1)		JRST QVNAM1
1)	
1)	QVNAM0:	LOAD A,FLNSB,(JFN)	;Step the current name
1)		CALL LKPTR		;(A/A) Need a lookup ptr
1)	QVNAM1:	TQO <NAMSF,STEPF>	;Flag that we are stepping
1)		CALL NAMLKX		;(A/A,B) Find next name
1)		 RETBAD()		;Match is impossible
1)		NOINT			;Match found
1)		HRRZ A,FILTMP(JFN)	;Got one, exchange old name block
1)		LOAD B,FLNSB,(JFN)	;  and new one
1)		STOR A,FLNSB,(JFN)
1)		HRRM B,FILTMP(JFN)
1)		OKINT			;Done touching sensitive areas
1)		CALL SETTMP		;(JFN/) Now reinitialize FILTMP ptr
1)		 RETBAD()		;Error
1)		CALL QVEXT		;(/) Now look for acceptable extension and version
1)		 JRST QVNAM0		;None for this name, step it
1)		RETSKP			;Got one, return
1)	^L
1)	; Step extension field
1)	
1)	QVEXT:	SETZ A,			;Find first extension, this name
1)		JRST QVEXT1
1)	
1)	QVEXT0:	LOAD A,FLESB,(JFN)	;Step current extension
1)		CALL LKPTR		;(A/A) Need a lookup pointer
1)	QVEXT1:	TQO <EXTSF,STEPF>	;Note that we are stepping
1)		CALL EXTLKX		;(A/A,B) Find next one
1)		 RETBAD()		;Pass error back
1)		NOINT			;Can't be interrupted
1)		HRRZ A,FILTMP(JFN)	;Got file, exchange old ext block
1)		LOAD B,FLESB,(JFN)	; and new one
1)		STOR A,FLESB,(JFN)
1)		HRRM B,FILTMP(JFN)

; GTJFN.MAC.3 & <6-1-MONITOR>GTJFN.MAC.5 18-Mar-89 1423	PAGE 24


1)		OKINT			;Back to normal
1)		CALL SETTMP		;(JFN/) Reinitialize FILTMP
1)		 RETBAD()		;Error
1)		CALL QVVER		;(/) Now look for acceptable version
1)		 JRST QVEXT0		;None for this ext, step to next
1)		RETSKP			;Got one
1)	^L
1)	; Step version field
1)	
1)	QVVER:	SETZ A,			;Find the first version
1)		JRST QVVER1
1)	
1)	QVVER0:	LOAD A,FLVNO,(JFN)	;Step current version
1)	QVVER1:	TQO <VERSF,STEPF>	;Note stepping version
1)		CALL GTVER		;(A/) Find next one and check access
1)		 RETBAD()		;There ain't one
1)		RETSKP			;Found one
1)	^L
1)	;GTVER - Routine to locate a file version
1)	;
1)	; Call with:
1)	;	A/ Desired version number
1)	;	Assumes F, F1, DEV, JFN, & STS are setup
1)	;	CALL GTVER
1)	;
1)	; Returns:
1)	;	+1 - Error, file not found
1)	;	+2 - Success, 
1)	;	     A/ version number
1)	
1)	GTVER:	HRRZ B,DEV		;Get device
1)		HRRZ B,NLUKD(B)		;Check for some flavor of DSK:
1)		CAIN B,MDDNAM		;If not MDD device,
1)		JRST GTVER1		; don't call USTDIR
1)		CALL VERLUK		;(B/B) Find file but don't lock
1)		 RET			;Not found, return to caller
1)	GTVER0:	TQO <VERF,VERTF>	;Show version found
1)		HRRM A,FILVER(JFN)	;And put it in JFN block in JSB
1)		RETSKP			;Done
1)	
1)	GTVER1:	CALL VERLKX		;(B/B) Lookup requested version
1)		 RET			;Not there
1)		MOVEM B,FILFDB(JFN)	;Remember FDB address
1)		TQNE <ASTF>		;If output stars, then nothing really done
1)		JRST GTVER0		;Save the version and return
1)		MOVE A,B		;Copy FDB address
1)		PUSH P,.FBGEN(A)	;Save version number too
1)		TQNE <DIRSF,NAMSF,EXTSF,VERSF> ;Stepping anything?
1)		TQNE <NEWF,NEWVF>	;New file or version?
1)		JRST GTVER2		;New file or not stepping
1)		MOVX B,FC%DIR		;Flag

; GTJFN.MAC.3 & <6-1-MONITOR>GTJFN.MAC.5 18-Mar-89 1423	PAGE 25


1)		CALL ACCCHK		;(A,B/) No, do directory list access check
1)		 JRST GTVER3		;Bad news, see if we can try another
1)	
1)	GTVER2:	TQO <VERF,VERTF>	;Show version found and typed
1)		POP P,A			;Recover version number
1)		HLRZS A
1)		STOR A,FLVNO,(JFN)	;And store it
1)		CALL USTDIR		;(/) OK, release the directory
1)		RETSKP			;And return
1)	^L
1)	GTVER3:	CALL USTDIR		;(/) Invalid access, release the directory
1)		POP P,A			;Recover version
1)		HLRZS A
1)		TQNN <DIRSF,NAMSF,EXTSF,VERSF> ;Stepping anything?
1)		RET			;No, just return
1)		TQO <STEPF>		;Yes, step to next file
1)		TQNE <RVERF>		; after installing right target version
1)		SETZ A,			;Get highest version only
1)		TQNE <HVERF>		;Highest only?
1)		MOVEI A,-1		;No, want all
1)		TQNE <LVERF>		;Lowest only?
1)		MOVEI A,-2		;Yes, flag it
1)		JRST GTVER		;Now go try it
1)	^L
1)	;[7.1014]
1)	;QSNAM, QSEXT, QSVER - Routines that append a * to the field currently
1)	;being entered and fakes *'s for the remaining fields. It aids in
1)	;the "?" when parsing a file. There are 3 entry points as noted below.
1)	;
1)	; Call with:
1)	;	no arguments
1)	;	CALL QSNAM - name being entered (returns nam*.*.*)
1)	;	CALL QSEXT - extension being entered (returns nam.ext*.*)
1)	;	CALL QSVER - version being entered (returns nam.ext.*)
1)	;
1)	; Returns:
1)	;	+1 - Error, no files can be recognized
1)	;	+2 - Fake input fields setup
1)	
1)	QSNAM:	CALL QSTAR		;(/) Stuff a * in name
1)		CALL ENDNAM		;(/) Punctuate name field with "."
1)		 RET			;Couldn't do it
1)	QSEXT:	CALL QSTAR		;(/) Stuff * in extension
1)		CALL ENDEX7		;(/) Punctuate this field
1)		 RET			;Shucks
1)	QSVER:	CALL QSTAR		;(/) Jam a * in version
1)		CALL ENDEX7		;(/) and find version
1)		 RET			;Non-existant
1)		RETSKP			;Done
1)	^L
1)	;[7.1014]

; GTJFN.MAC.3 & <6-1-MONITOR>GTJFN.MAC.5 18-Mar-89 1423	PAGE 26


1)	;QSTAR - This routine stuffs a * in for the user (aids in "?" whilest
1)	;parsing a filename).
1)	;
1)	; Call with:
1)	;	partial input in TEXTI% buffers
1)	;	CALL QSTAR
1)	;
1)	; Returns:
1)	;	+1 - Always, * stuffed in input buffers & old file flag set
1)	
1)	QSTAR:	MOVEI A,"*"		;This character
1)		TQO <STARF>		;Note * seen
1)		CALL LTR		;(A/) Put * in FILTMP and set WLDF
1)		 RETBAD()		;Couldn't do it
1)		TQO <ASTAF,OLDNF>	;* allowed, old file only
1)		TQZ <OUTPF,NEWNF>	;Old files only!
1)		TQZ <ASTF>		;Clear bit possibly set due to OSTRF
1)		RET			;Fini
1)	^L
1)	;[7.1014]
1)	;QNXTL - Routine to print out a candidate string
1)	;
1)	; Call with:
1)	;	A/ Address of string block
1)	;	CALL QNXTL
1)	;
1)	; Returns:
1)	;	+1 - Always
1)	;
1)	; Clobbers A,B,C
1)	
1)	QNXTL:	STKVAR <TMPA>		;Place to save A
1)		MOVEM A,TMPA		;Hold onto address of string block
1)		TMSG </
1)	 />				;Neatness counts
1)		MOVE B,TMPA		;Retrieve address of string block
1)		HRROI B,1(B)		;Now convert it into string pointer
1)		CALLRET TSTR1		;Output string, but don't put in buffer
1)	^L
1)	;[7.1014]
1)	;LKPTR - Routine to compute a lookup pointer for a string block
1)	;
1)	; Call with:
1)	;	A/ Address of block
1)	;	CALL LKPTR
1)	;
1)	; Returns:
1)	;	+1 - Always with A/ lookup pointer (-# words,,first word-1)
1)	;
1)	; Clobbers A,B,C
1)	

; GTJFN.MAC.3 & <6-1-MONITOR>GTJFN.MAC.5 18-Mar-89 1423	PAGE 27


1)	LKPTR:	HRRZI B,1(A)		;Address of start of string
1)		HRLI B,(POINT 7,)	;Make it a pointer
1)	LKPTR0:	ILDB C,B		;Find end of string
1)		JUMPN C,LKPTR0
1)		HRRZ C,A		;Start of block
1)		SUBI C,-1(B)		;-Number of words
1)		HRL A,C			;Make A and IOWD
1)		RET			;And away we go
1)	^L
LINE 2, PAGE 63
2)	IFN STANSW,<			; [SMXGTJ]
2)	; Routines to handle user question mark input.  Entered from input char
2)	; dispatch table.  If the input is NIL, returns immediately.  Otherwise,
2)	; list the candidates for the field currently being entered if no 
2)	; previous field had a wild card.  If no candidates are found, break 
2)	; with GJFX34.  Scan for candidates is terminated on last one or on any
2)	; input from the user.
2)	
2)	QUEST:	MOVE A,CURCNT(TXT)	; Was ? first thing typed?
2)		ADDI A,1
2)		CAML A,STRCNT(TXT)
2)		 ERRLJF GJFX34		; Yes, then break on it
2)		TQNE <OSTRF>		; GJ%OFG, parse only?
2)		 TQNE <ASTAF>		; GJ%IFG, normal indexable bit?
2)		  SKIPA
2)		   ERRLJF GJFX34	; GJ%OFG and NOT GJ%IFG, prevent loop
2)		CALL INFTST		; Test for no input JFN
2)		 ERRLJF GJFX34		; None, so break out now
2)		SETZ A,			; Erase the ?
2)		DPB A,CURPNT(TXT)
2)		PUSH P,LDPNT(TXT)	; Save TEXTI context
2)		PUSH P,LDCNT(TXT)
2)		PUSH P,CURPNT(TXT)
2)		PUSH P,CURCNT(TXT)
2)		TQNN <DEVF>		; Device specified?
2)		 CALL DEFDEV		; No, get a default (and set up FILDEV)
2)		HRRZ B,FILDEV(JFN)	; Has to be some flavor of DSK:
2)		CAIE B,DSKDTB
2)		 JRST QUEST2		; Oops, ding him and restart
2)		TQO <NREC>		; Turn off recognition
2)		TQNE <EXTFF>		; Extension being specified?
2)		 JRST QEXT		; Yes
2)		TQNN <NAMF>		; Name specified?
2)		 JRST QNAM		; No, must be entering it
2)		TQNN <VERF>		; Version specified?
2)		 JRST QVER		; No, must be entering it
2)	;	JRST QUEST0		; Fully specified?
2)	^L
2)	QUEST0:	CALL GSIBE		; Anything typed?
2)		 SKIPA			; Yes, eat it
2)		JRST QUEST3		; No, just retype and return

; GTJFN.MAC.3 & <6-1-MONITOR>GTJFN.MAC.5 18-Mar-89 1423	PAGE 28


2)	
2)	QUEST1:	HRRZ D,E
2)		XCTU [HRRZ A,1(D)]	; Something was typed to stop output
2)		CFOBF%			; Clear output buffer
2)		XCTU [HLRZ A,1(D)]	; Something was typed to stop output
2)		BIN%			; Get the input and throw it away
2)	
2)	QUEST2:	CALL DING		; Can't help in any later fields
2)	
2)	QUEST3: POP P,CURCNT(TXT)
2)		POP P,CURPNT(TXT)
2)		POP P,LDCNT(TXT)
2)		POP P,LDPNT(TXT)
2)	
2)	IMCFLG==1B14			;INTERNAL MONITOR CALL FLAG (X FIELD OF PC)
2)	; This causes MRETN to behave differently.
2)	; Note - I'd like a better way to determine this than having to define 
2)	; IMCFLG here
2)		MOVE A,MPP
2)		MOVE A,0(A)
2)		TXNE A,IMCFLG		; Internal call?
2)		 ERRLJF (GJFX34)	; Yes, return illegal ? error to COMND
2)		CALL RETYPE		; Retype the input text
2)		CALL BACKIT		; Backup over the null that was the ?
2)	
2)	; Initiate a rescan of the user's input.
2)	; The JFN block is initialized
2)	
2)	RESCAN:	NOINT
2)		HLRZ A,FILLNM(JFN)	; Preserve TEXTI buffer info
2)		PUSH P,A
2)		HRRZS FILLNM(JFN)	; Now make believe it isn't there
2)		CALL RELJFN		; Go clean up
2)		CALL ASGJFN		; Go get another
2)		IFNSK.
2)		  MOVEI A,JSBFRE	; Oops, no more left
2)		  POP P,B		; Release retype buffer
2)		  SKIPE B
2)		   CALL RELFRE
2)		  ERRLJF GJFX3		; And bomb out
2)		ENDIF.
2)		POP P,A			; Set up old retype stuff
2)		HRLM A,FILLNM(JFN)
2)		OKINT			; Interrupts again
2)		XCTU [HLLZ F,0(E)]	; Fetch his flags again
2)		MOVEI F1,0		; And clear others
2)		MOVE A,STRPNT(TXT)	; Reinit pointer to input string
2)		MOVEM A,LDPNT(TXT)
2)		SETZM LDCNT(TXT)	; Zap the input count
2)		CALL SETTMP		; Get another temp block and continue
2)		 RETBAD()

; GTJFN.MAC.3 & <6-1-MONITOR>GTJFN.MAC.5 18-Mar-89 1423	PAGE 29


2)		RETSKP			; Return to GCH loop
2)	^L; Here we had a ? while entering a name
2)	
2)	QNAM:	TQNN <DIRSF>		; Any directory stars?
2)		CALL QSNAM		; No, append star and find first file
2)		 JRST QUEST2		; Directory stars or no match
2)		DO.
2)		HLRZ A,FILNEN(JFN)	; Print this name
2)		CALL QNXTL
2)		CALL QVNAM0		; Now look for the next name
2)		 JRST QUEST0		; None left, beep and retype
2)		CALL GSIBE		; Anything input?
2)		 JRST QUEST1		; Yes, quit
2)		LOOP.			; go print it
2)		ENDDO.
2)	
2)	; Here we had a ? while entering an extension
2)	
2)	QEXT:	TQNN <DIRSF,NAMSF>	; Any directory or name stars?
2)		CALL QSEXT		; No, append star and find first file
2)		 JRST QUEST2		; Stars or no match
2)		DO.
2)		HRRZ A,FILNEN(JFN)	; Print this name
2)		MOVE B,1(A)		; Look at the first word of the string
2)		TLNE B,774000		; If it is not null (first char 0)
2)		IFSKP.
2)		  MOVEI A,[ASCIZ / [Null]/]  ; Otherwise dummy an entry
2)		  SUBI A,1		   ; Set up as string block
2)		ENDIF.
2)		CALL QNXTL
2)		CALL QVEXT0		; Now look for the next extension
2)		 JRST QUEST0		; None left, beep and retype
2)		CALL GSIBE		; Anything input?
2)		 JRST QUEST1		; Yes, quit
2)		LOOP.			; go print it
2)		ENDDO.
2)	
2)	; Here we had a ? while entering a version
2)	
2)	QVER:	TQNN <DIRSF,NAMSF,EXTSF>  ; Any dir, name, or ext stars?
2)		CALL QSVER		; No, make it a star and find first file
2)		 JRST QUEST2		; Stars or no match
2)		DO.
2)		TMSG </
2)	  />				; No, print this number
2)		HRRZ B,FILVER(JFN)
2)		CALL DNOUT
2)		CALL QVVER0		; Now look for the next version
2)		 JRST QUEST0		; None left, beep and retype
2)		CALL GSIBE		; Anything input?
2)		 JRST QUEST1		; Yes, quit

; GTJFN.MAC.3 & <6-1-MONITOR>GTJFN.MAC.5 18-Mar-89 1423	PAGE 30


2)		LOOP.			; go print it
2)		ENDDO.
2)	^L
2)	; Following are routines for stepping the Name, Ext, and Version
2)	; fields and assuring that at least one file is accessible with the
2)	; new field value.
2)	; Return:  +1 if none is found
2)	;	   +2 if successful
2)	
2)	; Step name field
2)	
2)	QVNAM:	SETZ A,			; Find the first name this dir
2)		JRST QVNAM1
2)	QVNAM0:	HLRZ A,FILNEN(JFN)	; Step the current name
2)		CALL LKPTR		; Need a lookup ptr
2)	QVNAM1:	TQO <NAMSF,STEPF>
2)		CALL NAMLKX		; Find the next one
2)		 RET			; Match is impossible
2)		NOINT			; Match
2)		HRRZ A,FILTMP(JFN)	; Got one, exchange old name block
2)		HLRZ B,FILNEN(JFN)	; and new one
2)		HRLM A,FILNEN(JFN)
2)		HRRM B,FILTMP(JFN)
2)		OKINT
2)		CALL SETTMP		; And reinit FILTMP ptr
2)		 RETBAD
2)		CALL QVEXT		; Now look for acceptable ext and ver
2)		 JRST QVNAM0		; None for this name, step it
2)		RETSKP			; Got one, return +2
2)	
2)	; Step extension field
2)	
2)	QVEXT:	SETZ A,			; Find the first ext this name
2)		JRST QVEXT1
2)	QVEXT0:	HRRZ A,FILNEN(JFN)	; Step the current extension
2)		CALL LKPTR		; Need a lookup ptr
2)	QVEXT1:	TQO <EXTSF,STEPF>
2)		CALL EXTLKX		; Find the next one
2)		 RET			; No more, return +1
2)		NOINT
2)		HRRZ A,FILTMP(JFN)	; Got one, exchange old ext block
2)		HRRZ B,FILNEN(JFN)	; and new one
2)		HRRM A,FILNEN(JFN)
2)		HRRM B,FILTMP(JFN)
2)		OKINT
2)		CALL SETTMP		; And reinit FILTMP ptr
2)		 RETBAD
2)		CALL QVVER		; Now look for acceptable ver
2)		 JRST QVEXT0		; None for this ext, step it
2)		RETSKP			; Got one, return +2
2)	

; GTJFN.MAC.3 & <6-1-MONITOR>GTJFN.MAC.5 18-Mar-89 1423	PAGE 31


2)	
2)	; Step version field
2)	
2)	QVVER:	SETZ A,			; Find the first version this ext
2)		JRST QVVER1
2)	QVVER0:	HRRZ A,FILVER(JFN)	; Step the current version
2)	QVVER1:	TQO <VERSF,STEPF>
2)		CALL GTVER		; Go find next one and check access
2)		 RET			; None, return +1
2)		RETSKP			; Finally we have an acceptable one
2)					; Return +2
2)	^L
2)	; Routine to locate a file version with acceptable access privileges
2)	; Entry:   A = desired version number
2)	;          JFN, F, F1, DEV, and STS are set up appropriately
2)	; Return:  +1 - Error, no accessible file found
2)	;          +2 - Success, A = version number
2)	
2)	GTVER:	HRRZ B,DEV		; Watch for dingle in LH(DEV)
2)		HRRZ B,NLUKD(B)		; Check for some flavor of DSK:
2)		CAIN B,MDDNAM		; If not mdd device, don't call USTDIR
2)		 JRST GTVER1
2)		CALL VERLUK		; No, don't bother leaving it locked
2)		 RET			; Couldn't find it - return +1
2)	GTVER0:	TQO <VERF,VERTF>	; Show version found
2)		HRRM A,FILVER(JFN)	; Install version
2)		RETSKP			; And return +2
2)	
2)	GTVER1:	CALL VERLKX		; Lookup requested version - return FDB
2)		 RET			; Couldn't get one - return +1
2)		MOVEM B,FILFDB(JFN)	; Remember the FDB address
2)		TQNE <ASTF>		; If output stars, nothing really done
2)		 JRST GTVER0		; Save the version and return
2)		MOVE A,B		; Copy FDB addr
2)		PUSH P,.FBGEN(A)	; Save the version number
2)		TQNE <DIRSF,NAMSF,EXTSF,VERSF>	; Stepping anything?
2)		 TQNE <NEWF,NEWVF>	; New file or version?
2)		  JRST GTVER2		; New, or not stepping
2)		MOVX B,FC%DIR		; No, do directory list access check
2)		CALL ACCCHK
2)		 JRST GTVER3		; Bad news, see if we can try another
2)	
2)	GTVER2:	TQO <VERF,VERTF>	; Show version found and typed
2)		POP P,A			; Recover version number
2)		HLRZS A
2)		HRRM A,FILVER(JFN)	; And install it
2)		CALL USTDIR		; OK, release the directory
2)		RETSKP			; And return +2
2)	
2)	GTVER3:	CALL USTDIR		; Invalid access, release directory
2)		POP P,A			; recover this version number

; GTJFN.MAC.3 & <6-1-MONITOR>GTJFN.MAC.5 18-Mar-89 1423	PAGE 32


2)		HLRZS A
2)		TQNN <DIRSF,NAMSF,EXTSF,VERSF>	; Stepping anything?
2)		 RET			; No, return +1
2)		TQO <STEPF>		; Yes, step to the next file
2)		TQNE <RVERF>		; after installing right target version
2)		 MOVEI A,0
2)		TQNE <HVERF>
2)		 MOVEI A,-1
2)		TQNE <LVERF>
2)		 MOVEI A,-2
2)		JRST GTVER		; Now go try it
2)	^L
2)	; Routine to skip if input buffer is empty.
2)	; Entry:   From ? routines
2)	; Call:	   CALL GSIBE
2)	; Return:  +1, input not empty or non TTY
2)	;	   +2, TTY input empty
2)	; Clobbers A
2)	
2)	GSIBE:	CALL INFTST		; Check input JFN
2)		 RET			; Nope, return +1
2)		SIBE
2)		 RET
2)		RETSKP
2)	
2)	; This routine appends a * to the field currently being entered and
2)	; fakes *'s for any remaining fields.
2)	; Entry:   Partial input from user
2)	; Call:	   CALL QSNAM  name being entered
2)	;          CALL QSEXT  extension being entered
2)	;          CALL QSVER  version being entered
2)	; Return:  +1 always, fake input fields set up
2)	
2)	QSNAM:	CALL QSTAR		; Add a star
2)		CALL ENDNAM		; And find a name
2)		 RET
2)	QSEXT:	CALL QSTAR		; Add a star
2)		CALL ENDEX7		; And find an extension
2)		 RET
2)	QSVER:	CALL QSTAR		; Make a star version
2)		CALL ENDEX7		; And find a version
2)		 RET
2)		RETSKP			; Return
2)	
2)	
2)	; Routine to fake a "*" input by user.
2)	; Entry:   Partial input in buffers
2)	; Call:    CALL QSTAR
2)	; Return:  +1 always, * added to input buffers and old file flag set
2)	
2)	QSTAR:	MOVEI A,"*"

; GTJFN.MAC.3 & <6-1-MONITOR>GTJFN.MAC.5 18-Mar-89 1423	PAGE 33


2)		TQO <STARF>		; Set by *
2)		CALL LTR		; Put it in FILTMP, and set WLDF
2)		 RETBAD()		; Can't
2)		TQO <ASTAF,OLDNF>	; Asterisk allowed, old file only
2)		TQZ <OUTPF,NEWNF>	; Only look for old files
2)		TQZ <ASTF>		; Clear bit possibly set due to OSTRF
2)		RET
2)	^L; Routine to print out a candidate string
2)	; Entry:   A = address of string block
2)	; Call:	   CALL QNXTL
2)	; Return:  +1 always
2)	; Clobbers A,B,C
2)	
2)	QNXTL:	PUSH P,A		; Save block adr for now
2)		TMSG </
2)	  />
2)		POP P,B
2)		HRROI B,1(B)		; Convert block adr into string ptr
2)		CALLRET TSTR1		; Output string, but don't put in buffer
2)	
2)	
2)	; Routine to compute a lookup pointer for a string block:
2)	; Entry:   A = Address of block
2)	; Call:	   CALL LKPTR
2)	; Return:  +1, A = lookup pointer:  -# words,,first word - 1
2)	; Clobbers A,B,C
2)	
2)	LKPTR:	HRRZI B,1(A)		; Address of start of string
2)		HRLI B,440700		; Make it a pointer
2)		ILDB C,B		; Find end of string
2)		JUMPN C,.-1
2)		HRRZ C,A		; Start of block
2)		SUBI C,-1(B)		; -number of words
2)		HRL A,C			; Make A an IOWD
2)		RET
2)	
2)	>;IFN STANSW			; [SMXGTJ]
2)	^L


LINE 14, PAGE 131
1)		ANDI A,177		;USE ONLY 7-BIT ASCII
1)		CAIN A,"-"		;[7415] Are we in line continuation?
1)		IFNSK.			;[7415] Possibly...
1)		  UMOVE B,2		;[7415] Preserve the byte pointer from user
1)		  XCTBUU [ILDB A,2]	;[7415] Get next character
1)		  CAIN A,.CHLFD		;[7415] Is it a line feed?
1)		  JRST GCH		;[7415] We have continuation, ignore the continuation characters
1)		  CAIN A,.CHCRT		;[7415] How about a CR then LF?
1)		  IFNSK.		;[7415] Saw CR...
1)		    XCTBUU [ILDB A,2]	;[7415] ...now eat LF

; GTJFN.MAC.3 & <6-1-MONITOR>GTJFN.MAC.5 18-Mar-89 1423	PAGE 34


1)		    JRST GCH		;[7415] And continue
1)		  ENDIF.		;[7415] End of -CRLF combination
1)		  UMOVEM B,2		;[7415] Put user's byte pointer back
1)		  MOVEI A,"-"		;[7415] And restore the right character
1)		ENDIF.			;[7415] End line continuation
1)		SOSG CURCNT(TXT)	;[7415] Will this character fit?
1)		RETBAD (GJFX51)		;[7415] No. Tell the user
1)		IDPB A,CURPNT(TXT)	;YES. STASH IT AWAY
LINE 14, PAGE 71
2)		SOSG CURCNT(TXT)	;YES. WILL THIS ONE FIT?
2)		RETBAD (GJFX51)		;NO. TELL HIM
2)		ANDI A,177		;USE ONLY 7-BIT ASCII
2)		IDPB A,CURPNT(TXT)	;YES. STASH IT AWAY


LINE 29, PAGE 134
1)		  UNLOCK JFNLCK		;[7345]ALREADY IN USE. UNLOCK THE JFN
1)		  OKINT			;[7345]AND GO OKINT
1)		  TQNN <JFNAF>		;[7345]DOES USER WANT TO ASSIGN AN ALTERNATE?
1)		  ERRLJF GJFX2,<MOVEM JFN,ERRSAV> ;[7345]NO. THEN PUNT
1)		  CALL ASGJFN		;[7345](/JFN)YES. GET A DIFFERENT JFN
1)		   ERRLJF(GJFX3)	;[7345]COULDN'T. SAY NO MORE JFNS
1)		ENDIF.
LINE 29, PAGE 74
2)		  UNLOCK JFNLCK
2)		  OKINT
2)		  TQNN <JFNAF>
2)		  ERRLJF GJFX2,<MOVEM JFN,ERRSAV>
2)		ENDIF.


LINE 34, PAGE 135
1)		SETONE ASGF2,(JFN)	;[7384]AND LIGHT ASGF SHADOW BIT
1)		HRRZ A,FORKN		; Get fork number
LINE 34, PAGE 75
2)		HRRZ A,FORKN		; Get fork number


LINE 42, PAGE 135
1)		HLLZS FILIDX(JFN)
LINE 41, PAGE 75
2)		SETZM FILST1(JFN)
2)		HLLZS FILIDX(JFN)


; GTJFN.MAC.3 & <6-1-MONITOR>GTJFN.MAC.5 18-Mar-89 1423	PAGE 35



LINE 18, PAGE 136
1)		MOVE B,FILST1(JFN)	;[7384]GET MORE STATUS BITS
1)		TXNE A,ASGF		;[7384]WAS THIS JFN BEING ASSIGNED?
1)		TXNN B,ASGF2		;[7384]BE SURE ASGF IS LIT, NOT BLKF
1)		SKIPA			;[7384]JFN IS NOT BEING ASSIGNED
1)		JRST RELJF0		;YES, DONT CHECK SPOOLING
LINE 18, PAGE 76
2)		TXNE A,ASGF		;WAS THIS JFN BEING ASSIGNED?
2)		JRST RELJF0		;YES, DONT CHECK SPOOLING


LINE 45, PAGE 136
1)	Action:	See if QUASAR is running and check to see that the system has some
1)		IPCF free space available.
1)	>,,<DB%NND>)			;[7.1210] 
1)	^L
1)	RELJF0:	CALL RELJF3		;RELEASE COMMON STUFF
1)		TXNE B,TRNSF		;[7384]A TRANSITIONAL FILE?
1)		JRST RELJF4		;[7384]NO
1)		MOVE A,FILST1(JFN)	;[7384]GET SECOND STATUS WORD
1)		TXNE B,ASGF		;[7384]WAS THIS BEING CREATED?
1)		TXNN A,ASGF2		;[7384]MAKE SURE ASGF IS LIT, NOT BLKF
1)		JRST RELJF4		;NO. CANT BE A RDTXT BUFFER THEN
LINE 42, PAGE 76
2)	>)
2)	RELJF0:	CALL RELJF3		;RELEASE COMMON STUFF
2)		TXNN B,TRNSF		;A TRANSITIONAL FILE?
2)		TXNN B,ASGF		;WAS THIS BEING CREATED?
2)		JRST RELJF4		;NO. CANT BE A RDTXT BUFFER THEN


LINE 42, PAGE 138
1)		MOVE C,FILST1(JFN)	;[7384]GET ADDITIONAL STATUS BITS
1)		TXNE B,ASGF		;[7384] Was this jfn being assigned?
1)		TXNN C,ASGF2		;[7384]MAKE SURE ASGF LIT, NOT BLKF
1)		IFNSK.			;[7408]
1)		  SETZM FILLFW(JFN)	;[7408] No. Zap this word
1)		  JRST RELJF2		;[7408] Go finish up
1)		ENDIF.			;[7408]
1)		TXNE B,TRNSF		;[7206] WAS THIS JFN TRANSITIONAL?
1)		JRST RELJF2		;[7206][7408] Yes, no TEMP block to release
1)		;..
1)	^L	;..
1)		HRRZ B,FILTMP(JFN)
LINE 42, PAGE 77
2)		TXNN B,ASGF		; Was this jfn being assigned?
2)		JRST [	SETZM FILLFW(JFN) ;NO. ZAP THIS WORD
2)			TXNE B,ASTF	;SCAN ONLY?
2)			JRST RELJF1	;YES. CHECK FOR PROTECTION

; GTJFN.MAC.3 & <6-1-MONITOR>GTJFN.MAC.5 18-Mar-89 1423	PAGE 36


2)			JRST RELJF2]	;GO FINISH UP
2)	;**;[7206] INSERT 2 LINES AT RELJF1:-7.L	DSW	12/04/85
2)		TXNE B,TRNSF		;[7206] WAS THIS JFN TRANSITIONAL?
2)		JRST RELJF1		;[7206] YES, NO TEMP BLOCK TO RELEASE
2)		HRRZ B,FILTMP(JFN)


LINE 7, PAGE 139
1)	;	cain b,1000		;if this value only (?8-bit pointer?)
1)	;	 setz b,		;then don't try to release it
1)	>;ifn nicsw
LINE 55, PAGE 77
2)		cain b,1000		;if this value only (?8-bit pointer?)
2)		 setz b,		;then don't try to release it
2)	>;ifn nicsw


LINE 13, PAGE 139
1)	RELJF2:	SETZM FILDDN(JFN)
LINE 61, PAGE 77
2)	RELJF1:	SKIPLE B,FILPRT(JFN)	;HAVE A PROTECTION STRING?
2)		CALL RELFRE		; Release space for protection block
2)	RELJF2:	SETZM FILDDN(JFN)


LINE 42, PAGE 143
1)		;..
1)	^L	;..
1)	TSTR0A:	ILDB A,B		;GET NEXT CHAR
LINE 42, PAGE 81
2)	TSTR0A:	ILDB A,B		;GET NEXT CHAR


LINE 26, PAGE 144
1)		ERJMP R			;[7300][7420] Catch JSYS error
1)		RET
LINE 66, PAGE 81
2)	;**;[7300] Add 1 line at TSTR1:+8L	MDR	23-MAY-86
2)		ERJMP IOERR		;[7300] Catch JSYS error
2)		RET


LINE 35, PAGE 147
1)		ERJMP R			;[7300][7420] Catch JSYS error
1)		RET
LINE 35, PAGE 84
2)	;**;[7300] Add 1 line at OUTCH1:+7L	MDR	23-MAY-86
2)		ERJMP IOERR		;[7300] Catch JSYS error
2)		RET


; GTJFN.MAC.3 & <6-1-MONITOR>GTJFN.MAC.5 18-Mar-89 1423	PAGE 37



LINE 30, PAGE 149
1)		ERJMP R			;[7300][7420] Catch JSYS error
1)		RET
LINE 30, PAGE 86
2)	;**;[7300] Replace 1 line at ANOUT:+7L	MDR	23-MAY-86
2)		ERJMP IOERR		;[7300] Catch JSYS error
2)		RET


LINE 4, PAGE 150
1)	BACKIT:	SETO A,			;[7.1014] Move over recognition character
1)		ADJBP A,CURPNT(TXT)	;[7.1014] Tail pointer
1)		MOVEM A,CURPNT(TXT)	;SAVE NEW POINTER
LINE 4, PAGE 87
2)	BACKIT:	
2)	IFE STANSW,<			; Partial recognition
2)		MOVE A,CURPNT(TXT)	;TAIL POINTER
2)		BKJFN			;MOVE OVER RECOGNITION CHARACYER
2)		 JFCL
2)	> ;IFE STANSW			; Partial recognition
2)	
2)	IFN STANSW,<			; Partial recognition
2)	; N.B. Beware of TRVARs Clobbering TXT 
2)		SETO T1,		;MOVE OVER RECOGNITION CHARACTER
2)		ADJBP T1,CURPNT(TXT)	;TAIL POINTER 
2)	> ;IFN STANSW			; Partial recognition
2)	
2)		MOVEM A,CURPNT(TXT)	;SAVE NEW POINTER


LINE 1, PAGE 153
1)	^L
1)	;ROUTINE TO SEE IF LONG NAMES ARE ALLOWED. PRESERVES ALL
LINE 45, PAGE 89
2)	
2)	;ROUTINE TO SEE IF LONG NAMES ARE ALLOWED. PRESERVES ALL


LINE 1, PAGE 155
1)	^L
1)	IFN NICSW,<
LINE 59, PAGE 89
2)	
2)	IFN NICSW,<


; GTJFN.MAC.3 & <6-1-MONITOR>GTJFN.MAC.5 18-Mar-89 1423	PAGE 38



LINE 16, PAGE 157
1)		STKVAR <OFILUC,VERNUM>	;[7380] Old STR unique code and version
1)		HRRZ JFN,1
1)	>
1)	IFN NICSW,<
1)		STKVAR <OFILUC,VERNUM,GXFLAG,GXFDB> ;CS82T-TL11 OLD STR UNIQUE CODE,
1)		SETZM GXFLAG		;CS82T-TL11 Indicate came from GNJFN
1)	GNJFN0:	HRRZ JFN,1		;CS82T-TL11
1)	>;IFN NICSW
1)		NOINT			;[8801] Get the lock with no interruptions
1)		LOCK JFNLCK		;[8801] Can't let anyone in
1)		CALL CHKJFN
1)		 RETERR(,<UNLOCK JFNLCK	;[8801] Done with lock
1)			  OKINT>)	;[8801] Interrupts are fine now
1)		 JFCL
1)		 RETERR(DESX4,<UNLOCK JFNLCK ;[8801] Lock finished
1)			       OKINT>)	;[8801] And interrupts are OK
1)		OKINT			;[8801] CHKJFN made us NOINT 1 too many times
1)		TQNE <ASTF>
1)		ERUNLK(DESX7,<UNLOCK JFNLCK>) ;[8801] Output stars not allowed
1)		TQNE <OPNF>
1)		ERUNLK(OPNX1,<UNLOCK JFNLCK>) ;[8801] And file can't be open
1)		LOAD JQ1,FLUC,(JFN)	;GET STRUCTURE UNIQUE CODE AT START
1)		MOVEM JQ1,OFILUC	;SAVE OLD STR UNIQUE CODE
1)		XCTU [HLLZ F1,1]
LINE 16, PAGE 90
2)		STKVAR <OFILUC>		; OLD STR UNIQUE CODE
2)		HRRZ JFN,1
2)	>
2)	IFN NICSW,<
2)		STKVAR <OFILUC,GXFLAG,GXFDB> ;CS82T-TL11 OLD STR UNIQUE CODE,
2)		SETZM GXFLAG		;CS82T-TL11 Indicate came from GNJFN
2)	GNJFN0:	HRRZ JFN,1		;CS82T-TL11
2)	>;IFN NICSW
2)		CALL CHKJFN
2)		 RETERR()
2)		 JFCL
2)		 RETERR(DESX4)
2)		TQNE <ASTF>
2)		ERUNLK(DESX7)		; Output stars not allowed
2)		TQNE <OPNF>
2)		ERUNLK(OPNX1)
2)		LOAD JQ1,FLUC,(JFN)	;GET STRUCTURE UNIQUE CODE AT START
2)		MOVEM JQ1,OFILUC		; SAVE OLD STR UNIQUE CODE
2)		XCTU [HLLZ F1,1]


; GTJFN.MAC.3 & <6-1-MONITOR>GTJFN.MAC.5 18-Mar-89 1423	PAGE 39



LINE 46, PAGE 157
1)		   RETERR (GJFX22,<UNLOCK JFNLCK ;[8801] Release lock
1)				   CALL UNLCKF>) ;[8801] Block too small, and none left
1)		  HRLM A,FILNEN(JFN) 	;NEW STRING POINTER
LINE 41, PAGE 90
2)		   RETERR (GJFX22,<CALL UNLCKF>) ;NOT, AND NO MORE SPACE
2)		  HRLM A,FILNEN(JFN) 	;NEW STRING POINTER


LINE 54, PAGE 157
1)		   RETERR (GJFX22,<UNLOCK JFNLCK ;[8801] Release JFN lock
1)				   CALL UNLCKF>) ;[8801] Block too small and no more
1)		  HRRM A,FILNEN(JFN) 	;NEW STRING
LINE 48, PAGE 90
2)		   RETERR (GJFX22,<CALL UNLCKF>) ;NOT BIG ENOUGH AND NO SPACE
2)		  HRRM A,FILNEN(JFN) 	;NEW STRING


LINE 61, PAGE 157
1)		SETONE ASGF2,(JFN)	;[7384]LIGHT ASGF SHADOW BIT AS WELL
1)		UNLOCK JFNLCK		;[8801] No we have indicated that the JFN is ours
1)		CALL UNLCKF		;DO UNLOCK
1)		;..
1)	^L	;..
1)	GNJFN1:	SETZM FILTMP(JFN)	;[7408]
1)		SETZM FILPRT(JFN)	;[7408]
1)		SETZM FILOPT(JFN)	;[7408]
1)		TQO <STEPF>
LINE 54, PAGE 90
2)		CALL UNLCKF		;DO UNLOCK
2)	GNJFN1:	SETZM FILTMP(JFN)
2)		SETZM FILPRT(JFN)
2)		SETZM FILOPT(JFN)
2)		TQO <STEPF>


LINE 35, PAGE 158
1)		IFNSK.			;[7371]
1)		  MOVEI A,GNJFX1	;[7371] Will fail, give proper return
1)		  JRST GNFAIL		;[7371]
1)		ENDIF.			;[7371]
1)		MOVEM A,VERNUM		;[7380] Save version number
1)		CALL VANISH		;[7393] (JFN/T1) Did file disappear on us?
1)		  RETERR(,<PUSH P,A	;[7393] Save error code
1)			   CALL RELJFX	;[7393] (/T1) Release JFN
1)			   POP P,A>)	;[7393] Tell user the error
1)		SETZM FILTMP(JFN)	;[7371]
1)		SETZM FILPRT(JFN)	;[7371]
1)		SETZM FILOPT(JFN)	;[7371]

; GTJFN.MAC.3 & <6-1-MONITOR>GTJFN.MAC.5 18-Mar-89 1423	PAGE 40


1)		MOVE A,VERNUM		;[7380]
1)		CALL VERLUK
1)	GNFAIL:	 RETERR(,<CAIL A,GJFX36	;ONE OF THE FILE OR DIRECTORY ERRORS?
1)			CAILE A,GJFX40	;STILL?
LINE 88, PAGE 90
2)		SKIPA A,[GNJFX1]	;WILL FAIL, GIVE PROPER RETURN
2)		CALL VERLUK
2)		 RETERR(,<CAIL A,GJFX36	;ONE OF THE FILE OR DIRECTORY ERRORS?
2)			CAILE A,GJFX40	;STILL?


LINE 55, PAGE 158
1)		;..
1)	^L	;..
1)		HRRM A,FILVER(JFN)
LINE 96, PAGE 90
2)		HRRM A,FILVER(JFN)


LINE 30, PAGE 159
1)		;..
1)	^L	;..
1)	GNJFN2:
LINE 124, PAGE 90
2)	GNJFN2:


LINE 106, PAGE 160
1)	GNJFN4:	SETZRO ASGF2,(JFN)	;[7384]CLEAR ASGF SHADOW BIT
1)					;[7384]CALL TO UNLCKF WILL CLEAR ASGF
1)		CALL UNLCKF		;RELEASE JFN AND STR LOCK
1)		SETZ A,
LINE 228, PAGE 90
2)	GNJFN4:	CALL UNLCKF		;RELEASE JFN AND STR LOCK
2)		SETZ A,


LINE 1, PAGE 162
1)	^L
1)	;[7371]
1)	;This routine is called before GNJFN% does its thing. It checks
1)	;to see if the file that we are stepping off of has gone away.
1)	;It could have disappeared via an untimely RENAME or it could 
1)	;have been deleted and expunged. Neither of which is good because
1)	;the LOOKUP routines expect the file to still exist. If this file
1)	;does not exist, then the LOOKUP routines will not set up FILOPT
1)	;correctly and when directories are stepped, we will either hang in
1)	;an infinite loop or we will cause an ILMNRF (because of FILOPT).
1)	;
1)	;Accepts:
1)	;	JFN/	JFN of file to check for existance.

; GTJFN.MAC.3 & <6-1-MONITOR>GTJFN.MAC.5 18-Mar-89 1423	PAGE 41


1)	;
1)	;Returns:
1)	;	+1 if the file in the JFN block of the JSB pointed to by JFN
1)	;	   is no longer there.
1)	;	T1/ Error code
1)	;
1)	;	+2 if the file still exists
1)	
1)	VANISH:	EA.ENT			;[7371] Be in section 0/1
1)		STKVAR <OLDFLG>		;[7371] Keep flags and (TXT) for later
1)		HRRZ T1,FILDEV(JFN)	;[7.1064] Has to be some flavor of DSK:
1)		CAIE T1,DSKDTB		;[7.1064] Is this JFN on a disk file?
1)		RETSKP			;[7.1064] Nope, return OK
1)		MOVEM F1,OLDFLG		;[7371] Put them here
1)		TXZ F1,<GNJFF!DIRSF!ASTF!STRSF!NAMSF!EXTSF!VERSF!STEPF> ;[7393] Don't step anything
1)		HRRZ T1,FILVER(JFN)	;[7393] Get version number
1)		CALL VERLUK		;[7393] (T1/T2) Find that file
1)		 JRST GONE		;[7393] It ain't there
1)		MOVE F1,OLDFLG		;[7371] Get flags back
1)		RETSKP			;[7371] And continue, file is still here
1)	GONE:	MOVEI T1,GNJFX2		;[7371] Return vanished file error
1)		RET			;[7371]
1)	
LINE 32, PAGE 91
2)	
