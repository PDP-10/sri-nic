;MRC:<4-UTILITIES>EDIT.MAC.57 28-Jul-81 00:47:17, Edit by ADMIN.MDP
; Add TEK4023 and DM1520 in front of Ambassador
;ACCT:<UTILITIES.SUBSYS>EDIT.MAC.56 26-Jul-81 11:34:27, Edit by O.O7
; Add VT100, TVI-912, and Ambassador terminal types.
; Make other terminal types agree with current system definitions.
;MRC:<4-UTILITIES>EDIT.MAC.55 10-Mar-81 18:16:25, Edit by ADMIN.MDP
; Add some new terminal types, including Heath-19
;<4-UTILITIES>EDIT.MAC.54, 27-Feb-81 23:30:48, Edit by ADMIN.MRC
; Fix MDP's buggy edit, mismatch broket
;<4-UTILITIES>EDIT.MAC.53, 27-Feb-81 23:27:48, Edit by ADMIN.MRC
;SPR 20-14861 Fix I.-1 if at the first line
;SPR 20-15450 Fix illegal instruction when NO ^C is set and you continue
; from a quota exceeded trap
;MRC:<4-UTILITIES>EDIT.MAC.52 12-Feb-81 21:15:19, Edit by ADMIN.MDP
; ^C M should act like ^C was never trapped. Simulate with STI.
; Changing echo mode should change TERMINAL PAUSE mode accordingly.
;MRC:<4-UTILITIES>EDIT.MAC.51  9-Feb-81 08:50:16, Edit by ADMIN.MDP
; READNM should only copy CRBUF if ESC was typed
;MRC:<4-UTILITIES>EDIT.MAC.50,  5-Feb-81 07:05:55, Edit by ADMIN.MDP
; Removed older fix to jump back over page boundary in alter mode as it was
; inconsistent with newer one.  Both were prior to merge of 16-Aug-80.
;ACCT:<UTILITIES.SUBSYS>EDIT.MAC.1,  4-Jan-81 06:01:54, Edit by O.O7
; Act like B when continued after E.  Fixed: BQ after create gave fjerr.
;ACCT:<UTILITIES.SUBSYS>EDIT.MAC.1, 20-Dec-80 14:46:51, Edit by O.O7
; Add #<columnrange> to F and S commands
;ACCT:<UTILITIES.SUBSYS>EDIT.MAC.1, 20-Dec-80 00:42:30, Edit by O.O7
; Rewrite code near SRC4 and REP4 to parse F and S switches in any order
;ACCT:<UTILITIES.SUBSYS>EDIT.MAC.1, 14-Dec-80 08:56:19, Edit by O.O7
; Make . command default to ^/^ if no arg given
;ACCT:<UTILITIES.SUBSYS>EDIT.MAC.1, 13-Dec-80 17:19:37, Edit by O.O7
; Add % symbol to mean ^/^:*/* wherever full range possible
;ACCT:<UTILITIES.SUBSYS>EDIT.MAC.1, 19-Oct-80 21:24:34, Edit by O.O7
; Hyphen should not bomb help messages.
;ACCT:<UTILITIES.SUBSYS>EDIT.MAC.1, 16-Oct-80 22:03:15, Edit by O.O7
; READNM now searches CRBUF for @ as well as just = and $
;ACCT:<UTILITIES.SUBSYS>EDIT.MAC.1, 12-Oct-80 18:05:32, Edit by O.O7
; Make ESC, ^R, and ^U cooperate.  Flush "Aborted..." message.
; Make it also get along with GTJFN.
; In particular, "*c<range>=<spaces>filname"... works now.
;EDIT.MAC.1,  9-Oct-80 14:50:36, Edit by CSD.PEELER
; Add /TYPE and /NOTYPE to globally allow or disallow Alter auto-type.
; Suppress auto-type initially when Alter reached via X or S,D.
; COMND now prints CRLF if need be before * prompt.
;ACCT:<UTILITIES.SUBSYS>EDIT.MAC.2, 24-Sep-80 14:35:27, Edit by J.JQJOHNSON
; Eliminate control characters in help messages (e.g. ^N in HS).
;SX:<O.O7>EDIT.MAC.1, 24-Aug-80 23:06:18, Edit by O.O7
; Minor fixes to Alter ^ and auto-L.
;SX:<O.O7>EDIT.MAC.1, 24-Aug-80 07:26:51, Edit by O.O7
; Make c128 kbd reps self-consistent and consistent with help msg.
;ACCT:<4-UTILITIES>EDIT.MAC.2, 22-Aug-80 17:36:55, Edit by B.BOMBADIL
; Fixed bugs at READN1+11 and GTJFNX+2 that broke indirect files and
; copy command....and any other uses of long form GTJFN with GJ%OLD set
;SX:<O.O7>EDIT.MAC.1, 22-Aug-80 12:21:10, Edit by O.O7
; Simulate L-command to start each line in Alter.
;SX:<O.O7>EDIT.MAC.1, 22-Aug-80 11:46:50, Edit by O.O7
; Simulate ^R upon continue from EXEC.
;ACCT:<4-UTILITIES>LOTS-EDIT.MAC.1, 16-Aug-80 05:32:05, Edit by O.O7
; Merged our changes into SCORE-EDIT and then merged in DEC-EDIT.
;MRC:<4-UTILITIES>EDIT.MAC.42, 12-Aug-80 22:47:10, Edit by ADMIN.LOUGHEED
; Fix bug introduced by previous edit
;MRC:<4-UTILITIES>EDIT.MAC.41, 12-Aug-80 22:23:39, Edit by ADMIN.LOUGHEED
; Rewrite RGTJFN to fix bug when user types EDIT <RETURN>
;ACCT:<4-UTILITIES>E.MAC.1, 12-Aug-80 07:41:16, Edit by O.O7
; Make ECFLG nonzero when it should be.
;ACCT:<4-UTILITIES>E.MAC.1, 10-Aug-80 10:45:20, Edit by O.O7
; Prevent INCHRW from losing argument to ^C trap during PBIN.
;<4-UTILITIES>EDIT.MAC.40,  3-Aug-80 23:04:50, Edit by ADMIN.MRC
; Turn EXTEND off, per Ralph's request
;ACCT:<4-UTILITIES>E.MAC.1, 3-Aug-80 17:49:21, Edit by O.O7
; Expert need not confirm to write over same version.
;<4-UTILITIES>EDIT.MAC.39, 24-Jul-80 16:37:34, Edit by ADMIN.MRC
; SPR 20-14239 Disallow creating temporary file in exiting
;MRC:<SCRATCH>EDIT.MAC.38, 24-Feb-80 19:09:45, Edit by CSD.LOUGHEED
; install SPR 20-13746.  Check for formfeed as line terminator
;MRC:<SCRATCH>EDIT.MAC.37, 24-Feb-80 18:24:18, Edit by CSD.LOUGHEED
; install SPR 20-13423, edit 197 of DEC Edit; check if DEV:<DIR> is
; the same for input and output files during B command
;SX:<B.BOMBADIL>EDIT.MAC.36,  9-Feb-80 18:57:02, Edit by B.BOMBADIL
; fix handling of Teleray display features
;SX:<B.BOMBADIL>EDIT.MAC.35,  9-Feb-80 17:49:21, Edit by B.BOMBADIL
; merge changes from edits 194 and 195 of DEC Edit
; - keep P command from reprinting the last line printed
; - allow echo on terminal when ^C in alter mode
;SX:<B.BOMBADIL>EDIT.MAC.34, 30-Jan-80 22:14:18, Edit by B.BOMBADIL
; make TEXTI break chars CR, LF, and ESC only -- get rid of BEL, ^Z
;SX:<B.BOMBADIL>EDIT.MAC.32, 30-Jan-80 20:27:19, Edit by B.BOMBADIL
; corrected CURUP codes for HP, Datamedia, and H1500 terminals
;SX:<B.BOMBADIL>EDIT.MAC.31, 29-Jan-80 20:53:57, Edit by B.BOMBADIL
; remove PSOUT at OUTLIN - caused problems with /C128 mode
;SX:<B.BOMBADIL>EDIT.MAC.15,  5-Jan-80 21:10:59, Edit by B.BOMBADIL
; speed up PRINT command by using PSOUT at OUTLIN
;SX:<B.BOMBADIL>EDIT.MAC.14,  5-Jan-80 20:14:21, Edit by B.BOMBADIL
; clean up disk full and help code
;SX:<B.BOMBADIL>EDIT.MAC.14,  5-Jan-80 19:41:22, Edit by B.BOMBADIL
; warn user if EDIT inserts a page mark while loading  buffer
;SX:<B.BOMBADIL>EDIT.MAC.11, 30-Nov-79 19:19:15, Edit by B.BOMBADIL
; add the =columns command
;SX:<B.BOMBADIL>EDIT.MAC.4, 26-Nov-79 20:14:05, Edit by B.BOMBADIL
; add statistics code for determining line length, file size
;SX:<B.BOMBADIL>EDIT.MAC.3, 23-Nov-79 18:59:23, Edit by B.BOMBADIL
; do not require confirming carriage return in the inhelp routine -- 
; alleviate problems when user control-C's out of the alter mode
;SX:<B.BOMBADIL>NEDIT.MAC.68, 20-Nov-79 22:58:26, Edit by B.BOMBADIL
; incorporate statistics gathering code in STATSW switches 
;SX:<B.BOMBADIL>NEDIT.MAC.66, 19-Nov-79 22:01:12, Edit by B.BOMBADIL
; add "Illegal in /READONLY mode" error message.  Clean up list code
;SX:<B.BOMBADIL>NEDIT.MAC.62, 13-Nov-79 19:51:17, Edit by B.BOMBADIL
; add ^W to delete backwards in alter insert mode
;SX:<B.BOMBADIL>NEDIT.MAC.58, 11-Nov-79 21:43:36, Edit by B.BOMBADIL
; ask confirmation if deleting many lines (30) on one page 
;SX:<B.BOMBADIL>NEDIT.MAC.36, 26-Oct-79 16:52:49, Edit by J.JQJOHNSON
; eliminate '\' from EDITHELP messages -- it's the asciz delimiter!
;SX:<B.BOMBADIL>NEDIT.MAC.35, 26-Oct-79 16:21:41, Edit by J.JQJOHNSON
; incorporate most of EDIT.SUPPLEMENT in the code.
;<B.BOMBADIL>EDIT.MAC.196,  23-Oct-79 23:34:10, EDIT BY B.BOMBADIL
; replace EDITHELP with internal help routines
;<B.BOMBADIL>EDIT.MAC.195,  5-Oct-79 21:09:00, EDIT BY B.BOMBADIL
; attempt to rename across structures no longer fatal error
;<B.BOMBADIL>EDIT.MAC.194, 30-Sep-79 14:26:19, EDIT BY B.BOMBADIL
; merged Stanford changes since release 1
;<4.UTILITIES>EDIT.MAC.193,  3-Jul-79 12:38:53, EDIT BY GRADY
;TCO 4.2319 - ALLOW WILDCARDS IN 'HLP:' DEVICE DEFINITION
;<4.UTILITIES>EDIT.MAC.192, 19-Apr-79 15:58:36, EDIT BY GRADY
;TCO 4.2236 - SEE TCO 3.1894 BELOW - PREVENT ILLEGAL INSTRUCTION TRAP
;<4.UTILITIES>EDIT.MAC.191, 10-Mar-79 13:54:40, EDIT BY KONEN
;UPDATE COPYRIGHT FOR RELEASE 4
;<4.UTILITIES>EDIT.MAC.190,  2-Jan-79 16:54:46, EDIT BY DBELL
;TCO 4.2145 - CLEAR UPTOPF ON ERRORS SO P^ DOESN'T GIVE "NO SUCH LINES"
;ERRORS AFTER AN INVALID INSERT COMMAND.
;<4.UTILITIES>EDIT.MAC.189, 20-Dec-78 16:09:24, EDIT BY DBELL
;TCO 4.2127 - CHECK FOR NONEXISTANT OUTPUT FILE AT DELOUT, SO A QUIT
;COMMAND AT THE WRONG TIME DOESN'T BLOW UP.
;<4.UTILITIES>EDIT.MAC.188, 20-Dec-78 13:02:32, EDIT BY DBELL
;REMOVE TEXTI BIT RD%RBF SINCE NOT USED ANYWAY
;<4.UTILITIES>EDIT.MAC.187, 12-Oct-78 14:01:58, EDIT BY DBELL
;TCO 4.2042 - FIX TAB OUTPUT PROBLEM IN "P" AND <LF> COMMANDS
;<4.UTILITIES>EDIT.MAC.186, 10-Oct-78 16:50:46, EDIT BY DBELL
;TCO 4.2040 - DON'T ALLOW WRITING OF TEMPORARY FILES
;<4.UTILITIES>EDIT.MAC.185,  4-Oct-78 11:57:07, EDIT BY DBELL
;TCO 4.2031 - MAKE DISK FULL INTERRUPT CODE CHECK RIGHT PC FOR "CAI"
;<4.UTILITIES>EDIT.MAC.184, 30-Sep-78 21:16:59, EDIT BY DBELL
;TCO 4.2028.  MAKE ALL LINE SEQUENCE FILES USE 36 BIT BYTES.  THIS
;FIXES MANY PROBLEMS CONCERNING THE APPENDING OF TWO LINE SEQUENCE
;NUMBERED FILES TOGETHER.
;<4.UTILITIES>EDIT.MAC.183, 20-Sep-78 15:15:55, EDIT BY DBELL
;TCO 4.2016.  GIVE INFORMATIVE OUT OF ORDER MESSAGE FOR COPY COMMAND.
;<4.UTILITIES>EDIT.MAC.182, 16-Jun-78 11:09:44, Edit by DBELL
;TCO 1923.  FIX /RUN SWITCH TO WORK CORRECTLY
;TCO 1922.  MAKE SURE PRARG BLOCK ALWAYS CONTAINS A NULL BYTE
;<4.UTILITIES>EDIT.MAC.181,  1-Jun-78 11:17:59, Edit by ENGEL
;FIX SFMOD TO USE TT%WAK INSTEAD OF 77B23 (FOR FULL WAKE-UP CHANGES)
;<4.UTILITIES>EDIT.MAC.180, 23-May-78 17:01:54, Edit by HESS
;TCO 1915 - Fix ESC echo on creation first input.
;<4.UTILITIES>EDIT.MAC.179,  3-May-78 11:31:13, Edit by DBELL
;TCO 1894. PREVENT ILLEGAL INSTRUCTION IN COPY COMMAND
;<4.UTILITIES>EDIT.MAC.178,  2-May-78 14:21:28, Edit by DBELL
;TCO 1893.  FIX OBSCURE PROBLEM WHEN A LOGICAL NAME IS DEFINED
;AS A SERIES OF FILE SPECS, AND ONE OF THE FILE SPECS IS PROTECTED.
;<4.UTILITIES>EDIT.MAC.177, 17-Nov-77 01:55:38, EDIT BY DBELL
;TCO 1878.  COPY PROTECTION OF ORIGINAL FILE TO NEW AND BACKUP FILES
;<4.UTILITIES>EDIT.MAC.176, 10-Nov-77 17:43:26, EDIT BY DBELL
;TCO 1877.  DON'T CLOSE INDIRECT FILE ON AN AUTO-SAVE
;<4.UTILITIES>EDIT.MAC.175,  9-Nov-77 14:35:57, EDIT BY DBELL
;TCO 1876.  SET GJ%NS WHEN CHECKING EXISTANCE OF OUTPUT FILE.
;<4.UTILITIES>EDIT.MAC.174, 31-Oct-77 17:42:33, EDIT BY DBELL
;FIX SKPNO1 TO NOT REREAD COMMENT CHARACTER
;<4.UTILITIES>EDIT.MAC.173, 31-Oct-77 15:57:05, EDIT BY DBELL
;IMPLEMENT EK COMMAND WHICH IS SAME AS EU BUT SUPPRESSES FORMFEEDS


;THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY ONLY BE USED
;  OR COPIED IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
;COPYRIGHT (C) 1976,1977,1978,1979 BY DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.

TITLE	EDIT - TOPS20 EDITOR
SUBTTL	DEFINITIONS

WHOEDI==0	;LAST EDITED BY TAH (DEC)
VEREDI==4
PATEDI==0	;PATCH LEVEL
MODEDI==51	;EDIT LEVEL

; EDITOR FOR THE DISK -- WORKS BY RECOPYING FILES USED

SALL				;SUPPRESS MACRO XPANSIONS
.HWFRMT				;READABLE LISTING

IFNDEF .PSECT,<
	.DIRECT .XTABM>

IFNDEF CRYPSW, <CRYPSW==0	;FOR ENCRYPTED FILES>
IFNDEF EXTEND, <EXTEND==1	;FOR EXTENDED FEATURES>
IFNDEF PPNTSW, <PPNTSW==0	;FOR PRETTY PRINT FEATURES>

	SEARCH	MONSYM

IFN STANSW,<
PPNTSW==1			;PRETTY PRINT SWITCH ON
EXTEND==0			;RALPH WANTS THIS OFF
STATSW==0			;NO STATISTICS
WHOEDI==4			;STANFORD EDIT
MODEDI==211			;EDIT LEVEL 211
>;IFN STANSW

IFN CRYPSW, <
	EXTERN CRYPT., CRASZ.
	.REQUIRE ENDECR.REL
>; IFN CRYPSW

OPDEF	OCRLF	[OUTSTR [BYTE (7)15,12]]
OPDEF	CALL	[PUSHJ P,]
OPDEF	RET	[POPJ P,]
OPDEF	RETSKP	[JRST CPOPJ1]
OPDEF	PJRST	[JRST]

IFN 0, <

; MACROS AND COUNTS TO MATCH UP STANSW CONDITIONAL COMPILATION.  -- OO7

DEFINE	PRINT%	(ME,SS,AGE) <
	PRINTX ME'SS'AGE
>

SULEV==0			;IFN STANSW NESTING LEVEL (WANT 0 OR 1)
SUCNT==0			;IFN STANSW COUNT
.SULEV==0			;IFE STANSW NESTING LEVEL
.SUCNT==0			;IFE STANSW COUNT

DEFINE	ONSTAN	<
	SULEV==SULEV+1
	SUCNT==SUCNT+1
	IFG SULEV-1, <PRINT% <?NESTED IFN STANSW, LEVEL >,\SULEV #,\SUCNT>
	IFG .SULEV, <
	    PRINT% <?IFN STANSW IN IFE STANSW, LEVEL >,\SULEV #,\SUCNT>
	IFN STANSW, >

DEFINE	OFFSTAN	<
	IFLE SULEV, <PRINT% <?MISSING IFN STANSW, LEVEL >,\SULEV #,\SUCNT>
	IFG .SULEV, <
	    PRINT% <?END IFN STANSW IN IFE STANSW, LEVEL >,\SULEV #,\SUCNT>
	SULEV==SULEV-1
>

DEFINE	NOSTAN	<
	.SULEV==.SULEV+1
	.SUCNT==.SUCNT+1
	IFG .SULEV-1, <PRINT% <?NESTED IFE STANSW, LEVEL >,\.SULEV #,\.SUCNT>
	IFG SULEV, <
	        PRINT% <?IFE STANSW IN IFN STANSW, LEVEL >,\.SULEV #,\.SUCNT>
	IFE STANSW, >

DEFINE	OKSTAN	<
	IFLE .SULEV, <PRINT% <?MISSING IFE STANSW, LEVEL >,\.SULEV #,\.SUCNT>
	IFG SULEV, <
	    PRINT% <?END IFE STANSW IN IFN STANSW, LEVEL >,\.SULEV #,\.SUCNT>
	.SULEV==.SULEV-1
>

>; IFN 0

;ACS USED

JF=0	;TEMP FLAGS FOR JUSTIFY & PRETTY PRINT
T1=1	;TEMP REGISTERS
T2=2
T3=3
T4=4
T5=5

FL=10		;FLAG REGISTER
FL2=11
ALTP=12		;POINTER FOR ALTER MODE
CS=13		;CHARACTER TABLE BITS
SINDEX=14	;LINE TO FIND, USED ALSO BY THE VARIOUS ROUTINES
PNTR=15		;POINTS AT CURRENT PLACE IN BUFFER
C=16		;CHARACTER RETURNED HERE BY GNCH
P=17		;PUSHDOWN LIST

;FLAGS  (RIGHT HALF)

BOF==1		;NOW ON FIRST RECORD OF FILE
EOF==2		;HAVE READ END OF FILE BUT NOT NECESSARILY BUT IN BUFFER
EOF2==4		;LAST WORD OF FILE IS IN CURRENT BUFFER
ADDL==10	;USED IN COMMAND SCANNING--LINE NUMBER + INC
SUBL==20	;LINE NUMBER - INC
IDF==40		;SCAN HAS SEEN AN IDENTIFIER
NUMF==100	;SCAN HAS SEEN A NUMBER
TERMF==200	;SCAN SAW A TERMINATOR (LF OR ALTMODE)
LINSN==400	;THE COMMAND INPUT ROUTINES SAW A LINE NUMBER
PGSN==1000	;THEY SAW A PAGE NUMBER
NEWFL==2000	;NEW FILE NAME SEEN BY END CODE
ORDF==4000	;LINES OUT OF ORDER (USED BY NUMBER)
BGSN==10000	;BIGGEST PAGE HAS BEEN SEEN
M37F==20000	;THIS IS A MODEL 37
CNTF==40000	;COMMAND USING !
		;100000 - UNUSED
READOF==200000	;THIS FILE IS BEING USED IN READ ONLY MODE
EXTOG==400000	;ON FOR SHORT ERROR MESSAGES

;SPECIAL FLAGS FOR PARSE CODE

F.LAHD==1	;LOOK-AHEAD FLAG

CODMAX==^D20 	;MAX CHARS IN CODE
SFDLVL==6	;MAX SFD LVL

D==PNTR
S1==PNTR		;SPECIAL ACS
S2==SINDEX

;FLAGS (LEFT HALF)

NEGF==1		;SEARCH HAS SEEN A 
DEMCHR==2	;SEARCH MUST SEE ANOTHER CHARACTER
ASSMF==4	;SEARCH HAS ASSUMED SEARCH CONTINUATION
ALTSRF==10	;HE WANTS TO DO A SEARCH AND EDIT
NUMSRF==20	;HE ONLY WANTS NUMBERS OF LINES FOUND
ARBITG==40	;WE ARE DOING ^N CURRENTLY, DO NOT ALLOW ANOTHER
EXCTSR==100	;WANTS TO SEARCH EXACTLY (NOT IGNORE CASE)
COPFIL==200	;WE ARE COPYING FROM ANOTHER FILE
ISCOP==400	;WE ARE DOING A COPY
NOPRN==1000	;DO NOT PRINT WHILE DOING SUBSTITUTE
DECID==2000	;ALLOW USER TO DECIDE IF LINE IS OK
EXCTS1==4000	;ANOTHER EXACT SEARCH FLAG FOR SUBS
QMODF==10000	;DO NOT TREAT ? AS A SPECIAL CASE ON INPUT
GCOM==20000	;DOING A G COMMAND INSTEAD OF E
SRCOP==40000	;DOING A SEARCH OF SECOND FILE
TRANFL==100000	;THIS IS A TRANSFER COMMAND WHICH HAS DELETED LINES
TECOF==200000	;THIS IS A TECO FILE
FSTOPF==400000	;THIS IS THE FIRST READ OP ON THIS FILE

;FLAGS IN FL2 (RIGHT)

STARF==1	;WE HAVE SEEN A * FOR THE LAST LINE
RUBF==2		;WE ARE DOING RUBOUT IN INTRA-LINE EDIT
ALTDUP==4	;DUPLEX CHARACTERS IN ALTER MODE
RUBF2==10	;DOING DELETE TYPE RUBOUT IN ALTER MODE
SVIT==20	;WE ARE DOING A "W" COMMAND (SAVE WORLD)
NONUMF==40	;SUPPRESS LINE NOS FOR P,R,I CMDS
ACONST==100	;ADD CONSTANT FOR R COMMAND
MONOF==200	;MONOTONIC RENUMBERING - NO REST AT P.M.
ALTECH==400	;ECHO ESC FLAG
SUPN==1000	;SUPPRESS LISTING OF LINE NUMBERS
		;OPEN (2000)
IFN STANSW, <
ALTLSF==2000	;ALTER AUTO-L SUPPRESS FLAG  -- OO7
>; IFN STANSW
UPTOPF==4000	;GET NEW LINE AT TOP OF PAGE
QSEPF==10000	;TREAT . % $ AS SEPARATORS
COMFLF==20000	;READ COMMANDS FROM FILE
ADECIF==40000	;SAW A AS RESPONSE TO DECIDE MODE
BADORD==100000	;FILE BECAME OUT OF ORDER DURING COPY COMMAND

;FLAGS IN FL2 (LEFT)

PDECID==1	;PERM DECIDE MODE FOR S
UARWF==2	;UP ARROW (^) SEEN FOR FIRST LINE
SRCWHO==4	;(203) WHO IS SEARCHING ON=F OFF=S
NORENT==10	;DON'T ALLOW REENTER
RENTF==20	;REENTER COMMAND TYPED
BELLF==40	;ALLOW <BELL><BELL>
BELLSN==100	;<BELL> SEEN
AUTOF==200	;AUTO SAVE IN PROGRESS
EXACT==400	;(203) USED FOR EXACT SEARCHES
		;UNUSED (1000)
IFN STANSW, <
ALSOPT==1000	;ALTER AUTO-L SUPPRESS OPTION  -- OO7
>; IFN STANSW
DOENDF==2000	;E CMD REQUESTED
INOPTF==4000	;READING OPTION FILE
INPARS==10000	;DOING INITIAL PARSE
PCHGF==20000	;FILE HAS CHANGED THIS PASS
FCHGF==40000	;FILE HAS CHANGED THIS EDIT
CCHGF==100000	;THIS COMMAND HAS CHANGED THE FILE

ALLCHG==PCHGF!FCHGF!CCHGF	;ALL FLAGS AFFECTING FILE CHANGE

;FLAGS FOR JF (RIGHT)

EJECT==1	;EJECT AFTER PAGES
WAIT==2		;WAIT FOR CR AFTER PAGES
PGNOS==4	;PAGE NUMBERS AT BOTTOM


OPDEF	ERROR	[1B8]	;ERROR UUOS FATAL ERROR
OPDEF	NERROR	[2B8]	;NON-FATAL ERROR
OPDEF	RERROR	[3B8]	;PRINT MESSAGE AND RETURN
OPDEF	JERROR	[4B8]	;JSYS ERROR CALL
OPDEF	FJERR	[5B8]	;FATAL JSYS ERROR
OPDEF	OUTSTR	[6B8]	;OUTPUT STRING TO TERMINAL
OPDEF	OUTCHR	[7B8]	;OUTPUT CHAR TO TERMINAL
OPDEF	INCHRW	[10B8]	;INPUT CHAR TO LOC
	MAXUUO==10

SRBLG==^D200	;NUMBER OF CHRS ALLOWED IN SEARCH STRING
SRNUM==6	;NUMBER OF SEARCH STRINGS ALLOWED
PDLSIZ==200	;PUSHDOWN LIST SIZE
MXWPL==^D500	;MAX NUMBER OF WORDS PER LINE

IBUF0==100000		;INPUT PAGE BUFFER
OBUF0==IBUF0+1000	;OUTPUT PAGE BUFFER
CPYPG0==OBUF0+1000	;COPY INPUT PAGE BUFFER
CPYBUF==CPYPG0+1000	;COPY BROWSE BUFFER
NCPYP==10		;SIZE OF ABOVE
LIBUF==177000		;LINE BUFFER
LIBUF2==176000		;AUX LINE BUFFER
TTIBUF==175000		;TTY INPUT BUFFER
ARBBUF==173000		;2 PAGES FOR PATTERN MATCHING
BUF0==200000		;MAIN EDIT WINDOW
MINPAG==4		;MINIMUM WINDOW SIZE
MAXPAG==377-<BUF0>B44+1	;MAXIMUM WINDOW SIZE
DEFPAG==12		;DEFAULT WINDOW SIZE IF NONE GIVEN
BUFC==400000		;TEMP STORAGE FOR COPY
NCPAGS==677-<BUFC>B44+1	;SIZE OF ABOVE

IFN EXTEND,<LSNUM==3	;NUMBER OF NESTED LINE SEARCHES ALLOWED>
%LPP==^D56		;LINES/PAGE FOR "L" CMD
PGSZ==^D55		;LINES / PAGE
FULLPG==^D65		;LINES TO NEXT PAGE

FILSIZ==^D24		;WORDS/FILESPEC

SUBTTL	REVISION HISTORY

COMMENT \


EDIT #				REASONS
------				-------

1	CHANGED SOS INTO EDIT, CHANGING SYMBOLS, NOT COMMENTS

2	CHANGED BACKUP ROUTINE BACK TO SHORT FILE VERSION

3	ADDED TWO NEW COMMANDS: /? PRINTS ALL THE SETTABLE
	SWITCHES, AND =? PRINTS ALL THE PRINTABLE SWITCHES.

4	RE-INSERTED THE LOCATION SWITCH WHICH SOMEHOW GOT
	LOST.

5	ADDED ? TO THE ALTER COMMAND.  IT PRINTS A LIST
	OF ALL THE VALID ALTER MODE COMMANDS.

6	ADDED THE SUBCOMMAND TO E WHICH PRINTS A VTECO-LIKE
	IDENTIFYING LINE AT THE TOP OF YOUR FILE IF YOU EXIT
	WITH THE OPTION 'I'.  THIS FEATURE IS IN UNDER THE
	FT10X SWITCH.

7	CHANGED THE COMMAND DISPATCHER TO BE GENUINELY
	TABLE-DRIVEN.

10	MADE THE W AND Q COMMANDS TELL THE USER TO GIVE THE
	B AND EQ COMMANDS.  THE _ COMMAND TELLS THE USER TO
	GIVE THE / COMMAND.

11	FIXED A BUG IN THE JOIN LOGIC, AND FIXED ? MESSAGE.

12	CHANGED THE TOPS-20 PARSER.  EDIT MUST BE STARTED
	BY THE TOPS-20 EXEC, WITH THE COMMAND IN THE
	RESCAN BUFFER.  IN ALL OTHER CASES, THE USER GETS:
	?YOU MUST TYPE AN INPUT FILE SPECIFICATION.

13	THE PARAMETER CORSIZ HAS BEEN ADDED.  FOR TOPS-10
	PROGRAMS, THIS PARAMETER SHOULD BE SET TO 3000(8);
	HOWEVER FOR NOW WE ARE SETTING VIRTUAL JOBS AT
	300000(8).  THIS IS THE NUMBER OF WORDS WHICH WILL
	BE IN THE 'CORE MEMORY BUFFER'.  REFER TO THE ROUTINE
	MOCO (FOR GETTING MORE CORE).

14	REMOVED THE ED FEATURE WHICH ALLOWED THE USER TO LOSE
	EVERYTHING IF HE TYPED 'END'.  ALSO REMOVED THE EQ
	COMMAND AND CHANGED THE HELP MESSAGE.

15	PUT MOST OF THE CODE UNDER SETPPN UNDER THE IFE FT10X
	CONDITIONAL.

16	CONVERT TO TOPS20 MONITOR CALLS

17	FIX ^U PROBLEM IN READNM (SAVE PREVIOUS FILESPEC)
	FIX "FILE STILL MAPPED" PROBLEM IN OCOMPL

20	MAKE COPY BROWSE BUFFER 10 PAGES. CLEANUP ^O STUFF.

21	FIX WRAPAROUND ON /RO FILES THAT ARE UNSEQUENCED.
	MINOR FIX TO ^C INT WHEN NORENT IS ON. CHECK CREATF
	BEFORE TRYING TO MAKE A BAK FILE.

22	SET CORRECT FILE DATE AND TIMES UPON EXIT

23	ADD /WINDOW:N TO SPECIFY EDIT WINDOW SIZE, EJ COMMAND
	TO DO D^/^ , EI, ADD K<LF> TO ALTER MODE

24	HANDLE CHL 20 PSI AND OPENF FAILURES FOR DISK FULL OR
	QUOTA EXCEEDED. ADD CLEAR OUTPUT BUFFER ON ^C

25	REDO ERROR MESSAGE MACRO AND CODE ASSIGNMENT

26	SEE TCO FILE FROM NOW ON (ALSO FIRST COMMENT LINES)

\

SUBTTL	USAGE STATISTICS

IFN STATSW,<

;THESE ROUTINES MAP A FILE FROM PS:<SYSTEM>, OPEN FOR FULL WORD, THAWED ACCESS,
;AND RECORD THE FOLLOWING DATA:
;	1.) THE FREQUENCY AT WHICH EVERY EDIT COMMAND IS GIVEN. (NEAR CMND2)
;	2.) THE WORD LENGTH OF EVERY LINE INSERTED INTO THE BUFFER
;	3.) THE SIZE OF THE FILE AS IT IS BEING WRITTEN OUT

;DEFINITIONS

ST.PAG==500			;WE WILL MAP OUR FILE TO THIS PAGE
ST.JFN:	BLOCK 1			;THE JFN FOR OUR FILE
ST.MEM==ST.PAG*1000		;WORD AT WHICH OUR PAGE STARTS
ST.MAX==^D100			;BUCKET SIZE FOR LINE AND FILE DATA
ST.OF1==^D100			;OFFSET INTO DATA FILE FOR LINE LENGTH DATA
ST.OF2==^D300			;OFFSET INTO DATA FILE FOR FILE SIZE DATA



;HERE TO OPEN A STATISTICS FILE AND MAP IT.  CALLED NEAR LOCATION STPT:

ST.OPN:	MOVSI	T1,(GJ%SHT)
	HRROI	T2,[ASCIZ/PS:<SYSTEM>EDIT.STATISTICS.1/]
	GTJFN
	 ERJMP	CPOPJ		;JUST RETURN ON AN ERROR
	MOVEM	T1,ST.JFN	;STORE THE JFN
	HRRZS	T1
	MOVEI	T2,OF%THW!OF%WR!OF%RD	;THAWED AND WRITE ACCESS, FULL WORD
	OPENF
	 ERJMP	ST.ER1		;SOME ERROR
	HRLZ	T1,ST.JFN	;MAP JUST ONE PAGE (NUMBERED ZERO)
	MOVE	T2,[.FHSLF,,ST.PAG]  ;MAP TO ST.PAG
	MOVSI T3,(PM%PLD!PM%RD!PM%WR)  ;MODIFY ACCESS
	PMAP
	 ERJMP	ST.CL1		;RETURN IF ERROR
	RET
ST.ER1:	HRRZ	T1,ST.JFN
	RLJFN
	 JFCL			;SOME ERROR
	RET

;HERE TO UNMAP AND CLOSE THE STATISTICS FILE.  CALLED AT LOCATION ENDEND

ST.CLO:	SETO	T1,-1		;UNMAPPING
	MOVE	T2,[.FHSLF,,ST.PAG]
	MOVEI	T3,0		;A SINGLE PAGE
	PMAP
	 ERJMP	CPOPJ		;IN CASE OF ERROR
ST.CL1:	HRRZ	T1,ST.JFN
	CLOSF			;CLOSE THE FILE
	 JFCL			;IGNORE ANY ERROR
	RET



;HERE TO RECORD THE LENGTH OF A LINE.  CALLED AT INSED:

ST.LIN:	SKIPG	T1,NCNT		;SKIP IF POSITIVE COUNT
	 RET			;JUST RETURN, PROBABLY DELETING A LINE
	CAIGE	T1,ST.MAX	;SKIP IF LESS THAN 100 WORDS LONG
	 AOSA	<ST.MEM+ST.OF1>(T1) ;RECORD IT
	  AOS	<ST.MEM+ST.OF1+ST.MAX> ;HERE FOR SUPER-LONG LINES
	RET



;HERE TO RECORD THE LENGTH OF A FILE.  CALLED NEAR END4:

ST.SIZ:	HRRZ T1,NEWJFN
	SIZEF			;FIND IT'S SIZE
	 JRST ST.SZ1		;AN ERROR, JUST RETURN
	CAIGE	T3,ST.MAX	;SKIP IF LESS THAN 100 PAGES
	 AOSA	<ST.MEM+ST.OF2>(T3) ;RECORD IT
	  AOS	<ST.MEM+ST.OF2+ST.MAX> ;RECORD VERY LARGE FILES HERE
ST.SZ1: HRRZ T1,NEWJFN
	RLJFN			;FLUSH JFN
	 FJERR
	RET			;RETURN


> ;IFN STATSW

SUBTTL	ENTRY VECTOR AND EXEC INTERFACE

EV::	JRST	STPT		;START ADDRS
	JRST	CNCREN		;REENTER ADDRS
	BYTE	(3)WHOEDI (9)VEREDI (6)PATEDI (18)MODEDI


CREFIT:	OCRLF			;INFORM USER ALL IS OK
	MOVEI	T1,1		;COUNT OF ARGS
	MOVEM	T1,LIBUF2	;STASH IN BUFFER
	SKIPN	T2,RUNFIL	;SEE IF FILE GIVEN
	JRST	[SETZM LIBUF2+2	;ZERO MEANS USE LAST LOAD CLASS CMD
		 MOVEI T3,1	;SIZE OF ARG
		 JRST CRFIT1]	;JOIN REST
	HRROI	T1,LIBUF2+2	;COPY STRING
	MOVEI	T3,0
	SOUT
	IBP	T1		;POINT AFTER TERMINATING NULL
	MOVEI	T3,1(T1)	;CALC SIZE
	SUBI	T3,LIBUF2+2	;IN WORDS
CRFIT1:	MOVE	T1,[4B2+17B12+2] ;CODE AND BUFFER OFFSET
	MOVEM	T1,LIBUF2+1	;...
	MOVE	T1,[.PRAST,,.FHSLF]
	MOVEI	T2,LIBUF2	;BUFFER ADDRS
	ADDI	T3,2		;ACCOUNT FOR OVERHEAD
	PRARG			;SET PARAMS
	HALTF			;ALL DONE
	JRST	.-1		;FOREVER

;A CHARACTER TABLE FOR USE ON TYPE IN AND TYPE OUT

;FLAGS USED IN CHARACTER TABLE

OPF==10		;THIS IS A SPECIAL CHARACTER
SNUMF==4	;THIS IS PART OF A NUMBER
LETF==2		;THIS IS A LETTER
TERM==1		;THIS IS A TERMINATOR
M37==400000	;THIS CHR IS PRINTED AS ITSELF ON MODEL 37
NSEPF==200000	;THIS IS NOT A SEPERATOR (USED ON $,%,AND.)


DEFINE CHRS (FLAGS,PALT,INALT,RH)
<BYTE (4) FLAGS (7) PALT,INALT(18)RH>

CTBL:	0
	CHRS	OPF,"!","",""
	CHRS	OPF,42,"",""
	CHRS	OPF,"#",3,3
	CHRS	OPF,"$",4,4
	CHRS	OPF,"%",5,5
	CHRS	OPF,"&",6,6
IFN STANSW, <
	CHRS	OPF,"?",7,7	;USE '? FOR <BELL>  --OO7
>; IFN STANSW
IFE STANSW, <
	CHRS	OPF,"\",7,7
>; IFE STANSW
	CHRS	OPF,<"(">,10,10
	0
	CHRS	OPF!TERM,0,12,12
	CHRS	OPF,0,13,13
	CHRS	OPF,0,14,14
	0
	CHRS	OPF,<")">,16,16
	CHRS	OPF,"*",17,17
	CHRS	OPF,"+",20,20
	CHRS	OPF,54,21,21
	CHRS	OPF,"-",22,22
	CHRS	OPF,".",23,23
	CHRS	OPF,"/",24,24
	CHRS	OPF,"0",25,25
	CHRS	OPF,"1",26,26
	CHRS	OPF,"2",27,27
	CHRS	OPF,"9",30,30
	CHRS	OPF,"6",31,31
	CHRS	OPF,"4",32,32
	CHRS	OPF,"=",33,33
	CHRS	OPF,74,34,34
	CHRS	OPF,76,35,35
	CHRS	OPF,"7",36,36
	CHRS	OPF,"8",37,37
	0
	CHRS	OPF,0,1,"!"
	CHRS	OPF,0,2,42
	CHRS	OPF,0,3,"#"
	CHRS	OPF,0,4,"$"+NSEPF
	CHRS	OPF,0,5,"%"+NSEPF
	CHRS	OPF,0,6,"&"
	CHRS	OPF,"'","'","'"
	CHRS	OPF,0,10,<"(">
	CHRS	OPF,0,16,<")">
	CHRS	OPF,0,17,"*"
	CHRS	OPF,0,20,"+"
	CHRS	OPF,0,21,54
	CHRS	OPF,0,22,"-"
	CHRS	OPF,0,23,"."+NSEPF
	CHRS	OPF,0,24,"/"
	CHRS	SNUMF,0,25,20
	CHRS	SNUMF,0,26,21
	CHRS	SNUMF,0,27,22
	CHRS	SNUMF,0,176,23
	CHRS	SNUMF,0,32,24
	CHRS	SNUMF,0,"5",25
	CHRS	SNUMF,0,31,26
	CHRS	SNUMF,0,36,27
	CHRS	SNUMF,0,37,30
	CHRS	SNUMF,0,30,31
	CHRS	OPF,0,174,":"
	CHRS	OPF,0,73,73
	CHRS	OPF,0,34,74
	CHRS	OPF,0,33,"="
	CHRS	OPF,0,35,76
IFN STANSW, <
	CHRS	OPF,0,7,"?"	;'? MEANS ^G
>; IFN STANSW
IFE STANSW, <
	CHRS	OPF,0,37,"?"
>; IFE STANSW
	CHRS	OPF,0,140,"@"
XXZ=101
REPEAT ^D26,<CHRS	LETF,0,XXZ+40,XXZ-40
XXZ=XXZ+1>
	CHRS	OPF,0,173,<"[">
	CHRS	OPF,7,7,"\"	; CTRL-G PRINTS AS BELL
	CHRS	OPF,0,175,<"]">
IFN STANSW, <
	CHRS	OPF,0,176,"^"	; '^ MEANS TILDE
	CHRS	OPF,0,177,"_"	; '_ MEANS RUBOUT
>; IFN STANSW
IFE STANSW, <
	CHRS	OPF,0,"^","^"
	CHRS	OPF,0,"_","_"
>; IFE STANSW
	CHRS	OPF,100,140,140
XXZ=141
REPEAT ^D26,<CHRS	LETF,XXZ-40,XXZ,XXZ-100
XXZ=XXZ+1>
	CHRS	OPF,<"[">,173,173+M37
	CHRS	OPF,":",174,174+M37
	CHRS	OPF,<"]">,175,175+M37
IFN STANSW, <
	CHRS	OPF,"^",176,176	;DECUS TILDE
	CHRS	OPF,"_",177,177	;'_ MEANS RUBOUT
>; IFN STANSW
IFE STANSW, <
	CHRS	OPF,"3",176,176
	CHRS	OPF,"\",177,177
>; IFE STANSW
	CHRS	OPF,0,0,200

SUBTTL	SCANNER

GNCH:	SKIPN	C,LIMBO		;USE SAVED CHAR IF ANY
	PUSHJ	P,@CHIN		;ELSE GET FRESH CHAR
	SETZM	LIMBO		;AND CLEAR LIMBO
	CAMN	C,ESC		;CHECK ESCAPE CHAR
	MOVEI	C,200		;CONFUSE WITH LEFT CURLY BRACKET
	TLNE	FL,QMODF	;SHOULD WE TREAT ' SPECIALLY
	JRST	GNCH1Y		;NO:
	CAIN	C,"'"		;YES: SHOULD WE USE ALT CHR SET?
	JRST	GNCHA		;YES:
GNCH1Y:	TDNN	FL2,[INOPTF,,COMFLF]
	TLNN	FL2,BELLF		;ALLOWED?
	JRST	GNCHB		;NO: JUST GET BITS
	CAIN	C,7		;YES: SEE IF BELL
	JRST	[TLO FL2,BELLSN	;SAY WE SAW ONE
		 JRST GNCHA]	;AND LOOK AT NEXT
GNCHB:	JUMPE	C,GNCH		;IGNORE NULLS
	MOVE	CS,CTBL(C)	;GET CHARACTER TABLE BITS
	TLNE	CS,LETF_16	;CHECK TO SEE IF A LETTER
	TDC	C,CASEBT	;USE UPPER/LOWER INFO
	POPJ	P,		;AND RETURN

GNCHA:	PUSHJ	P,@CHIN		;GET NEXT CHAR
	JUMPE	C,GNCHA		;SKIP NULLS
	TLZE	FL2,BELLSN	;WAS 1ST BELL SEEN
	JRST	[CAIN C,7	;YES: CHECK FOR 2ND
		 JRST [OCRLF	;2ND SEEN - PUNT
		       CALL CLRBFI
		       JRST COMND]
		 MOVEM C,LIMBO	;SAVE CHAR
		 MOVEI C,7	;RETURN A BELL
		 JRST GNCHB]
	SKIPE	CTBL(C)		;NO CHANGE FOR NULL,SPACE,TAB,CRET
	MOVS	C,CTBL(C)	;GET ALTERNATE CHR FROM CHR TABLE
	ANDI	C,177		;ONLY THE CHR BITS
	JRST	GNCHB		;GO CHECK THINGS

;HERE TO INPUT FROM TTY

TTYCH:	SOSG	TTICNT		;SEE IF MORE CHARS
	CALL	TTYINP		;NO - GET SOME MORE
	ILDB	C,TTIPNT	;GET CHAR
	JUMPE	C,TTYCH		;SKIP OVER NULLS
	TRNE	FL2,ALTECH	;ESC ECHO?
	CAME	C,ESC		;IS IT
	RET			;NO - JUST RETURN
	PUSH	P,T1		;SAVE T1
	MOVEI	T1,"$"
	PBOUT			;DUMP DOLLAR
	PJRST	T1POPJ		;RESTORE T1 & EXIT

TTYINP:	PUSH	P,T1		;SAVE T1
TTYIN0:	HRROI	T1,TTIBUF	;POINT TO BUFFER
	MOVEM	T1,TEXTIB+.RDDBP
IFE STANSW, <
	MOVSI	T1,(RD%TOP!RD%JFN!RD%RND)
>; IFE STANSW
IFN STANSW, <
	MOVSI	T1,(RD%JFN!RD%RND)
>; IFN STANSW
	MOVEM	T1,TEXTIB+.RDFLG	;SET FLAGS
	MOVEI	C,5*MXWPL+2	;COUNT OF CHARS
	MOVEM	C,TEXTIB+.RDDBC
	MOVEI	T1,TEXTIB	;POINT TO ARG BLOCK
	TEXTI			;SNARF SOME
	  FJERR			;FATAL JSYS ERROR
	MOVE	T1,TEXTIB+.RDFLG ;GET FLAGS
	TLNE	T1,(RD%BFE)	;BUFFER EMPTY?
	JRST	TTYNUL		;YES - PROCESS NULL INPUT
	SUB	C,TEXTIB+.RDDBC	;GET CHAR COUNT
	MOVEM	C,TTICNT	;SETUP COUNT
IFN STANSW, <	;ON ESC, COPY TO CRBUF  -- OO7
	LDB	C,TEXTIB+.RDDBP
	CAME	C,ESC		;IF NOT ESC THEN NEVER MIND
	 JRST	TTINOU
	SETOM	ESCFLG		;SET ESC TRUE
	TRNN	FL2,ALTECH	;IF NOT ECHOING ESC, LEAVE TTYINP
	 JRST	TTINOU
	PUSH	P,T2
	MOVE	T1,[POINT 7,CRBUF,6]	;FIND END OF CRBUF
	ILDB	C,T1
	JUMPN	C,.-1
	ADD	T1,[7B5]	;BACK UP ONE
	MOVE	T2,[POINT 7,TTIBUF]	;GET CHARS FROM TTIBUF
	TRNA			;SKIP DEPOSIT, THEN COPY REST
	IDPB	C,T1
	ILDB	C,T2
	CAME	C,ESC		;DONE ON ESC
	 JRST	.-3
DOLLAR:	MOVEI	C,"$"		;INDICATE WITH DOLLAR
	IDPB	C,T1
	SETZ	C,0		;TERMINATE WITH NULL
	IDPB	C,T1
	POP	P,T2
TTINOU:
>; IFN STANSW
	MOVE	T1,[POINT 7,TTIBUF]
	MOVEM	T1,TTIPNT	;RESET POINTER
	PJRST	T1POPJ		;RESTORE T1


;HERE ON EITHER ^U OR RUBOUT BEYOND BEGINNING OF BUFFER

TTYNUL:	PUSH	P,T2		;SAVE EXTRA REG
	MOVEI	T1,.PRIOU	;USE OUTPUT JFN
	RFPOS			;GET POSITION
	MOVE	T1,T2		;COPY TO T1
	POP	P,T2		;RESTORE T2
	TRNE	T1,-1		;LEFT MARGIN?
	JRST	[OUTCHR [7]	;NO - RING BELL AND TRY AGAIN
		 JRST TTYIN0]
IFE STANSW, <
	SKIPE	T1,FSFLG	;IN F/S OR COPY COMMAND
	JRST	[OUTSTR [ASCIZ "Aborted..."]
		 OCRLF
		 JRST COMND]	;RETURN TO COMMAND LOOP
>; IFE STANSW
IFN STANSW, <
	SKIPN	ESCFLG		;PREVIOUS ESC IN THIS LINE  -- OO7
	SKIPE	FSFLG		;IF IN F, S, C, OR L
	 JRST	COMND		;RETURN TO COMMAND LOOP
>; IFN STANSW
	OUTSTR	CRBUF		;OUTPUT PROMPT
	JRST   TTYIN0		;AND TRY AGAIN


CLRBFI:	PUSH	P,T1		;SAVE T1
	MOVEI	T1,.PRIIN	;ONLY CLEAR PRIMARY INPUT
	CFIBF
	PJRST	T1POPJ

NOECHO:	PUSH	P,T3		;SAVE STUFF
	MOVEI	T3,0		;ECHO STATUS FLAGS
	MOVEM	T3,ECFLG	;(194) SET ECHO FLAG
	JRST	ECHOST		;JOIN COMMON CODE

IFN STANSW, <
NOECNF:	PUSH P,T3		;TURN OFF ECHO WITHOUT CHANGING ECHO FLAG
	MOVEI T3,0
	JRST ECHOST
				;THERE DOES NOT SEEM TO BE ANY CODE WHICH
ONECHO:	PUSH	P,T3		;WILL ACTUALLY SET ECFLG!  INSERTING IT INTO
	MOVEI	T3,2		;DOECHO, NOW USE ONECHO TO GET ECHO W/O
	JRST	ECHOST		;SETTING ECFLG.   (OO7)

DOECHO:	PUSH	P,T3		;SAVE T3
	MOVEI	T3,2		;TURN ECHO ON
	MOVEM	T3,ECFLG	;ACTUALLY SET ECHO MODE FLAG  --OO7
ECHOST:	PUSH	P,T1		;SAVE OTHER REGS
	PUSH	P,T2
	MOVEI T1,.PRIOU		;PRIMARY OUTPUT
	MOVEI T2,.MOXOF		;ASSOCIATE TERMINAL PAUSE MODE WITH ECHO MODE
	LSH T3,-1		;TURN ECHO FLAG INTO PAUSE FLAG
	MTOPR%
	LSH T3,1		;TURN FLAG BACK INTO ECHO FLAG
>; IFN STANSW
IFE STANSW,<
DOECHO:	PUSH	P,T3		;SAVE T3
	MOVEI	T3,2		;TURN ECHO ON
ECHOST:	PUSH	P,T1		;SAVE OTHER REGS
	PUSH	P,T2
	MOVEI T1,.PRIOU		;PRIMARY OUTPUT
>; IFE STANSW
	DPB T3,[POINT 2,MODW,25] ;SET FLAGS
	MOVE T2,MODW
	SFMOD			;...
	POP	P,T2		;RESTORE REGS
	POP	P,T1
	POP	P,T3
	RET			;RETURN

;SUBROUTINE TO SCAN NEXT ATOM
;CALL:
;	PUSHJ	P,SCAN
;	<RETURN HERE>
;C(ACCUM) := SIXBIT ATOM
;C(T1)    := ASCII SEQ NUMBER FORM
;C(T2)    := DECIMAL INTEGER
;C(C)     := BREAK CHAR OR SPACE IF IDENT.

SCAN:	TRZ	FL,TERMF!NUMF!IDF ;RESET FLAGS
	SKIPE	CS,SAVCHR	;CHECK TO SEE IF WE LEFT ONE LAST TIME
	JRST	SL1		;YES, IT MUST BE A DELIMITER
	SKIPN	C,SAVC		;BACK UP A CHARACTER?
	JRST	SL10		;NO
	PUSHJ	P,GNCHB		;YES, GET BITS
	TLNN	FL2,INPARS	;HANDLE SPECIAL IF IN PARSE
	JRST	SL11		;NOT IN INITIAL PARSE
	SETZM	SAVC
	SETZM	SAVCHR
	POPJ	P,		;RETURN IF SPACE DELIM
SL10:	PUSHJ	P,GNCH		;GET A CHR
SL11:	SETZM	SAVC
	JUMPE	CS,SL10		;CHECK FOR TAB, SPACE, AND IGNORE
	JUMPL	CS,SL1		;SPECIAL CHARACTER?
	MOVE	T3,[POINT 6,ACCUM] ;SET TO SAVE IDENT
	SETZM	ACCUM
	TLNE	CS,SNUMF_16	;CHECK FOR NUMBER
	JRST	SNUM1		;AND GO RACING OFF TO NUMBER ROUTINE
SL2P:	TRO	FL,IDF		;IT IS AN IDENT
SL2:	TLNE	T3,770000	;HAVE WE STORED ENOUGH?
	IDPB	CS,T3		;NO, ANOTHER (RH OF CHR TABLE HAS SIXBIT)
	PUSHJ	P,GNCH		;CONTINUE
IFN STANSW, <
	CAIN	C,"-"		;HYPHEN A SPECIAL KIND OF LETTER.  -- OO7
	 TDZ	CS,[OPF_16,,40]	;TURN OFF OPF AND CONVERT TO SIXBIT
>; IFN STANSW
	JUMPG	CS,SL2		;CHECK FOR ANOTHER NUMBER OR LETTER
SOK1:	MOVEM	CS,SAVCHR	;SAVE THE CHARACTER (MUST BE A SPECIAL CHR)
	TLNE	FL2,INPARS
	JRST	[MOVEM C,SAVC	;SAVE HERE IF IN PARSE
		 SETZB C,SAVCHR
		 POPJ P,]
	MOVEI	C,0		;ZERO IN C FOR NUMBERS AND IDNETS
	POPJ	P,

SL1:	HRRZ	C,CS		;FOR SPECIAL CHARACTERS, RETURN RH OF CTABLE
	TLNE	CS,TERM_16	;CHECK FOR TERMINATOR
	TRO	FL,TERMF	;AND SET FLAG
	ANDI	C,377		;GET RID OF EXTRA BITS
	SETZM	SAVCHR		;ZERO SAVCHR FOR LATER
	CAIE	C,"."		;CHECK FOR .
	POPJ	P,		;NO RETURN
	MOVE	T1,CLN		;SET UP FOR CURRENT LINE AND PAGE
	MOVE	T2,CPGL
	TRO	FL,NUMF		;CALL IT A NUMBER
	POPJ	P,


SNUM1:	SETZB	T1,T2		;SET NUMBER ACCUMS TO 0
SN1A:	TLNE	T3,770000	;WILL STORE THE SIXBIT FOR FILE NAMES
	IDPB	CS,T3		;BUT ONLY IF LESS THAN 6
SN1B:	TLNE	T1,(<177B7>)	;CHECK FOR 5 CHARS
	JRST	SN1C		;5 ALREADY
	LSH	T1,7		;ACCUMULATE ASCII IN T1
	IOR	T1,C
SN1C:	IMULI	T2,12		;DECIMAL IN T2
	ADDI	T2,-"0"(C)
	PUSHJ	P,GNCH		;GET NEXT AND CONTINUE
	JUMPLE	CS,SOK2		;CHECK FOR END OF NUMBER
	TLNN	CS,SNUMF_16	;CHECK FOR NUMBER
	JRST	SL2P		;MUST BE AN IDENT
	JRST	SN1A		;CONTINUE SCANNING NUMBER

SOK2:	TRO	FL,NUMF		;IT WAS A NUMBER
	LSH	T1,1		;CONVERT TO LINE NUMBER
	IOR	T1,[<ASCII /00000/>!1]
	JRST	SOK1		;SAVE DELIM AND RETURN


SUBTTL	PLACE FINDING ROUTINES

;FIND-- PAGE TO FIND IS IN DPG. NUMBER TO FIND IS IN SINDEX.
;LOADS T1 WITH THE LINE NUMBER FOUND
;IF NO EXACT MATCH WILL FIND NEXT HIGHER NUMBER OR A PAGE MARK.
;IF EOF FOUND, RETURNS 0

FIND:	MOVE	T1,DPG		;GET THE DESIRED PAGE
	CAMLE	T1,CPG		;IS IT GREATER THAN THE PAGE WE ARE ON
	JRST	FWDPG		;YES, SEARCH FORWARD FOR PAGE
	CAML	T1,CPG		;IS IT THE SAME AS THE CURRENT PAGE?
	JRST	FEQPG		;YES, JUST SEARCH FOR LINE NUMER
	SUBI	PNTR,1		;BACK UP A LITTLE (IN CASE POINTED AT PAGE MARK)
FIND1:	PUSHJ	P,CHKREN	;SEE IF REENTER
	JRST	FNDONE		;YES: FINISH UP
	SKIPN	T1,(PNTR)	;GET THE WORD, BUT WATCH FOR START OF BUFFER
	JRST	FINDHD		;WILL HAVE TO FINISH COPY AND START OVER
	CAME	T1,PGMK		;IS IT A PAGE MARK?
	SOJA	PNTR,FIND1	;CONTINUE SEARCHING
	SOS	T1,CPG		;DECREASE THE PAGE WE ARE NOW ON
	CAME	T1,DPG		;IS IT THE RIGHT ONE YET?
	SOJA	PNTR,FIND1	;NO, KEEP SEARCHING
	SUBI	PNTR,1		;BACK OVER PAGE MARK
FIND2:	PUSHJ	P,CHKREN	;REENTER?
	JRST	FNDONE		;YES:
	SKIPN	T1,(PNTR)	;PICK UP WORD AND CHECK FOR START OF BUFFER
	JRST	FINDHD		;HAVE TO DO IT THE HARD WAY
	TRNN	T1,1		;IS IT A SEQUENCE NUMBER?
	SOJA	PNTR,FIND2	;NO, CONTINUE SEARCH
	CAMN	T1,PGMK		;IS IT PERHAPS A PAGE MARK?
	AOJA	PNTR,FNDFW1	;YES, GO FORWARD A LINE AND RETURN IT
	CAMGE	SINDEX,T1	;IS THE LINE WE WANT GREATER OR EQUAL TO THIS ONE
	SOJA	PNTR,FIND2	;NO, KEEP UP THE GOOD WORK
	CAMN	SINDEX,T1	;EXACT MATCH?
	POPJ	P,		;YES, RETURN
	JRST	FNDFW1		;GO FORWARD A LINE TO GET NEXT LARGER
FEQPG:	SKIPN	T1,(PNTR)	;CHECK THE WORD WE ARE POINTING AT
	JRST	FNDFOO		;MUST BE POINTING AT END OF BUFFER OR BUFFER EMPTY
	CAMN	T1,PGMK		;IS IT A PAGE MARK?
	SOJA	PNTR,FIND2	;MUST BE ONE AT END OF PAGE, SEARCH BACKWARDS
FEQPG1:	CAMGE	SINDEX,T1	;COMPARE TO LINE WE WANT
	JRST	FIND2		;WANT A SMALLER ONE, SEARCH BACK
	JRST	FNDFW1		;SEARCH FORWARD

FWDPG:	PUSHJ	P,CHKREN	;REENTER?
	JRST	FNDONE		;YES:
	SKIPN	T1,(PNTR)	;SEARCH FORWARD FOR PAGE
	JRST	FNXRCP		;END OF BUFFER, GET A NEW ONE
	CAME	T1,PGMK		;FOUND A PAGE MARK?
	AOJA	PNTR,FWDPG	;NO, CONTINUE
	AOS	T1,CPG		;ADVANCE CURRENT PAGE COUNT
	CAME	T1,DPG		;AND SEE IF WE ARE THER YET
	AOJA	PNTR,FWDPG	;NUTS, LOOK SOME MORE
	ADDI	PNTR,1		;ADVANCE BEYOND PAGE MARK
FNDFW1:
FIND3:	PUSHJ	P,CHKREN	;REENTER?
	JRST	FNDONE		;YES:
	SKIPN	T1,(PNTR)	;LOOK FOR LINE
	JRST	FNXRC		;END OF RECORD, GET A NEW ONE
	TRNN	T1,1
	AOJA	PNTR,FIND3	;NOT LINE NUMBER
	CAMN	T1,PGMK		;PAGE MARK
	POPJ	P,		;RETURN IT, IT IS BEST MATCH WE CAN FIND
	CAMLE	SINDEX,T1	;ARE WE THERE YET?
	AOJA	PNTR,FIND3	;NO, CONTINUE SEARCH
	POPJ	P,		;YES, FINALLY

FNDFOO:	CAMN	PNTR,BUFP	;ARE WE POINTED TO START OF BUFFER
	JRST	FDFOO1		;YES, BUFFER MUST BE EMPTY
	SUBI	PNTR,1		;NO, MUST HAVE BEEN AT END OF BUFFER
FDFOO2:	SKIPN	T1,(PNTR)	;GET WORD
	ERROR	ICN		;MUST BE CONFUSED, THERE SHOULD BE A LINE NUMBER
	TRNN	T1,1		;SEARCH FOR LINE NUMBER
	SOJA	PNTR,FDFOO2	;KEEP LOOKING
	CAMN	T1,PGMK		;IS IT A PAGE MARK
	AOJA	PNTR,FNDFW1	;YES, SEARCH FORWARD
	JRST	FEQPG1		;GO DO SOMETHING WITH IT
FDFOO1:	TRNE	FL,EOF2		;ARE WE AT END OF FILE?
	JRST	FINDHD		;WILL HAVE TO TRY FROM START
	PUSHJ	P,GETN		;GET THE NEXT BUFFER
	JRST	FEQPG

;HERE TO SAY WE HAVE BEEN INTERUPTED

FNDONE:	JRST	COMND		;JUST GO TO CMD LOOP FOR NOW


FNXRCP:	TRNE	FL,EOF2		;ARE WE AT END OF FILE
	JRST	FNX1		;YES, JUST RESET BGPG AND LOOK AGAIN
	PUSHJ	P,GETN		;GET THE NEXT BUFFER
	JRST	FWDPG		;AND CONTINUE SEARCH
FNX1:	MOVE	T1,CPG		;SET BGPG TO CURRENT PAGE
	MOVEM	T1,BGPG
	TRO	FL,BGSN		;RECORD THAT LARGEST PAGE SEEN
	MOVEI	T1,0		;RETURN 0 FOR EOF
	POPJ	P,

FNXRC:	TRNE	FL,EOF2		;ARE WE AT END OF FILE
	JRST	FNX1		;YES, GIVE HIM BACK THE 0
	PUSHJ	P,GETN		;NO, GET THE NEXT BUFFER
	JRST	FIND3		;AND CONTINUE LOOKING FOR LINE

FINDHD:	TRNE	FL,BOF		;ARE WE AT THE START OF THE FILE
	JRST	FNDFST		;YES, CAN NOT GO BACK JUST GIVE FIRST LINE OF FILE
	TLNE	FL,COPFIL	;IS THIS A COPY?
	JRST	FINDH4		;YES: DON'T RELEAS IN & OUT
	TRNE	FL,READOF	;ALSO HANDLE SPECIAL IF RO
	JRST	FINDH
	PUSHJ	P,OCOMPL	;FINISH COPYING FILE
	TLNN	FL2,PCHGF	;ANY CHANGES THIS PASS?
	JRST	[CALL DELOUT	;DELETE OUTPUT FILE
		 JRST FINDHB]
FINDH:	SKIPE	AUXFLG
	JRST	[MOVE T1,ICRJFN	;CURRENT INPUT JFN
		 CALL DOCLSF	;CLOSE IT (RETAIN JFN)
		 CALL DDELFR	;FLUSH IT
		 SETZM ICRJFN	;ITS GONE
		 JRST .+1]
	TRNE	FL,READOF	;READ-ONLY ?
	JRST	FINDH2		;YES - THIS IS FAST
	SKIPE	T1,ICRJFN	;CLOSE FILE
	CALL	DOCLSR		;...
	PUSHJ	P,OUTFIN	;PURGE BUFFER
	HRROI	T1,[ASCIZ "EDIT-BUFFER.IN"]
	HRROI	T2,ICRASZ
	CALL	MAKTMP		;MAKE TEMP FILE SPEC
	HRROI	T2,ICRASZ	;MAKE PNTR TO NAME
	MOVEM	T2,ICRFIL	;...
	MOVSI	T1,(GJ%SHT!GJ%TMP!GJ%FOU)
	PUSHJ	P,GTJFNX	;GET JFN FOR NEW INPUT
	  FJERR
	SETOM	AUXFLG		;WE HAVE AN AUX FILE
	MOVEM	T1,ICRJFN	;...
	MOVE	T1,OCRJFN	;CURRENT OUTPUT JFN
	MOVE	T2,ICRJFN	;JFN OF DEST FILE
	RNAMF			;RENAME OUTPUT FILE
	  FJERR			;FATAL JSYS ERROR
IFN CRYPSW, <
	MOVE T1,OCRCOD		;INPUT CODE IS NOW
	MOVEM T1,ICRCOD		; OLD OUTPUT CODE
>; IFN CRYPSW
FINDH1:	MOVEI	T1,IBUF0	;SET UP BUFFER PNTR
	MOVEM	T1,CIPBUF
	MOVE	T1,ICRJFN	;INPUT JFN
	MOVEM	T1,CIPJFN	;CORRECT BLOCK
	MOVE	T2,[7B5+OF%RD]
	OPENF			;OPEN IT
	  FJERR			;LOASGE
	PUSH	P,ALTP		;SAVE ALT PNTR
	MOVEI	ALTP,CIPB	;INPUT BLOCK
	CALL	GFSIZE		;NEW INPUT FILE SIZE
	POP	P,ALTP		;RESTORE PNTR
FINDHB:	MOVSI	T1,(GJ%FOU!GJ%TMP!GJ%SHT)
	MOVE	T2,OCRFIL	;PNTR TO FILESPEC
	PUSHJ	P,GTJFNX	;GET NEW JFN
	  FJERR
	MOVEM	T1,OCRJFN	;SAVE
	MOVEI	T2,OF%WR	;OPEN FOR WRITE, FULL WORDS
	MOVEM	T1,OPNJFN	;SAVE FOR OPNERR
	OPENF
	  CALL	OPNERR		;CHECK FAILURE
	SETZM	OPG		;OUTPUT PAGE CNTR
	MOVNI	T1,2
	MOVEM	T1,OPCNT	;OUTPUT FILE PAGE COUNT
	SETZM	OUPNT		;OUTPUT FILE PNTR
FINDH2:	SETOM	CIPCNT		;INIT PAGE CNTR
	SETZM	CIPPNT		;CLEAR BUFFER
	SETZM	CIPBYT		;...


FINDH3:	SETZM	WC		;WC STARTS OUT 0
	TDZ	FL,[TECOF,,EOF!EOF2]
	TDO	FL,[FSTOPF,,BOF]
	TLNN	FL,COPFIL	;DON'T HURT THIS FLAG IF IN COPY
	TLZ	FL2,PCHGF	;NO CHANGES YET
	MOVEI	T1,1		;SET UP INPUT PAGE IN CASE OF
	MOVEM	T1,INPG		;ORDER OR LTL ERRORS ON INPUT
	SETZM	SVWD
	SETZM	OLDLIN		;USED IN CHECKING INPUT ORDER OF LINES
	PUSHJ	P,FILLBF	;FILL UP THE BUFFER
	MOVEI	T1,1
	MOVEM	T1,CPG		;START ON PAGE 1
	MOVE	PNTR,BUFP	;SET PNTR TO START OF WORLD
	JRST	FIND		;AND GO LOOKING

FNDFST:	MOVE	T1,@BUFP	;GET FIRST WORD
FNDFS1:	MOVE	PNTR,BUFP	;SET TO START OF WORLD
	POPJ	P,		;AND DISMISS

FINDH4:	SETOM	AIPCNT		;RESET INPUT PAGE COUNT
	SETZM	AIPPNT		;AND EMPTY BUFFER
	SETZM	AIPBYT		;...
	JRST	FINDH3

;FIND THE NEXT LINE, PAGE MARK, ETC.

FINDN1:	SKIPN T1,(PNTR)
	JRST FINDN2
	TRNN T1,1
FINDN:	AOJA PNTR,FINDN1
	POPJ P,		;RETURN THE LINE

FINDN2:	TRNE FL,EOF2	;IS IT EOF?
	POPJ P,		;YES, RETURN PRESENT T1 (0 FOR EOF)
	PUSHJ P,GETN	;GET NEXT BUFFER
	JRST FINDN1	;GO LOOK SOME MORE



FINDZ1:	SKIPN T1,(PNTR)	;AS FINDN BUT STOPS AT END OF RECORD
	POPJ P,
	TRNN T1,1	;LINE NUMBER?
FINDZ:	AOJA PNTR,FINDZ1
	POPJ P,

IFN STANSW, <
FINBZ1:	SKIPE T1,(PNTR)	;AS FINDB BUT STOPS AT END OF RECORD
	TRNE T1,1	;LINE NUMBER?
	RET		;  (OO7)
FINDBZ:	SOJA PNTR,FINBZ1
>; IFN STANSW


;FIND THE PREVIOUS LINE

FINDB1:	SKIPN T1,(PNTR)	;WATCH OUT FOR START OF BUFFER
	JRST FINDB2
	TRNN T1,1	;LINE NUMBER?
FINDB:	SOJA PNTR,FINDB1	;TRY AGAIN
	CAMN T1,PGMK	;TEST FOR PAGE MARK
	SOS CPG		;NOW ON PREVIOUS PAGE
	POPJ P,		;RETURN LINE NUMBER

FINDB2:	TRNE FL,BOF	;AT START OF FILE?
IFE STANSW,<
	JRST FNDFS1	;YES, GO GET THE FIRST LINE OF FILE
>;IFE STANSW
IFN STANSW,<
	JRST FINDB3	;(210) YES, GO GET THE FIRST LINE OF FILE
>;IFN STANSW
	MOVE T1,1(PNTR)	;GET THE FIRST LINE ON THIS PAGE
	TRNN T1,1	;MAKE SURE THERE IS ONE THERE
	ERROR ICN	;NO, WE ARE CONFUSED
	PUSH P,SINDEX	;SAVE (CALLER MAY NEED IT)
	MOVE SINDEX,T1
	PUSHJ P,FINDHD	;THIS WILL WORK AND WE WILL HAVE A LITTLE SPACE BEFORE
	POP P,SINDEX	;GET THIS BACK
	SOJA PNTR,FINDB1	;GO LOOK BACK AGAIN


IFN STANSW,<
FINDB3:	TRNE	FL,SUBL		;(210) ARE WE SUBTRACTING?
	JRST	FNDFS1		;(210) NO JUST GET FIRST LINE
	CAMN	T1,[<ASCII /00000/>!1] ;(210) DOES LINE 00000 EXIST?
	NERROR	ILR		;(210) YES GIVE ERROR
	CAMLE	T1,TECFST	;(210) NO, IS THIS <= START PARAMETER? ;>
	JRST	[MOVE T1,TECFST
		 JRST FINDB4]	;(210) NO USE LINE = START
	MOVE	T2,[<ASCII /00000/>!1] ;(210) YES GET AVERAGE FOR NEW ONE
	MOVE	T1,SINDEX	;(210) SET TO START LINE
	MOVE	SINDEX,[<ASCII /00000/>!1] ;(210) SET TO LINE 00000
	PUSHJ	P,ASCAV		;(210) AVERAGE 0 AND FIRST LINE
	MOVE	T1,T2		;(210) SAVE AVERAGE IN T1
FINDB4:	MOVE	SINDEX,T1	;(210) SAVE RESULT IN SINDEX
	JRST	FNDFS1		;(210) ALL DONE GET POINTER
>;IFN STANSW
SUBTTL	BUFFER HANDLING ROUTINES

OCOMPL:	TLNN	FL2,PCHGF	;SEE IF NEEDED
	JRST	[MOVEI T2,<IBUF0>B44
		 PJRST UNMAP]	;UNMAP PAGE AND RETURN
OCOMP0:	MOVE	T1,WC		;GET CURRENT WORD COUNT
	ADD	T1,BUFP		;TURN IT INTO A POINTER
	PUSHJ	P,DUMP		;DUMP DUMPS BUFFER FROM BUFP TO (T1)
	SETZM	WC		;TELL IT NO CURRENT WORD COUNT
	TRNE	FL,EOF2		;ALL DONE?
	POPJ	P,
	PUSHJ	P,FILLBF	;FILL UP INPUT BUFFER
	PUSHJ	P,CHKREN	;DID WE REENTER?
	JRST	COMND		;YES: GO TO COMMAND LOOP
	JRST	OCOMP0		;AND GO DUMP THIS ONE TOO



GETWD:	TRNE	FL,EOF
	JRST	RTEOF		;RETURN 0 IF EOF
	PUSH	P,ALTP		;SAVE PNTR
	MOVEI	ALTP,CIPB	;ASSUME CURRENT INPUT BLOCK
	TLNE	FL,COPFIL	;IN A COPY, WE GET FROM SOMEWHERE ELSE
	MOVEI	ALTP,AIPB	;USE ALT INPUT BLOCK
GETWD0:	MOVE	T3,PNT(ALTP)	;GET PNTR
	AOBJP	T3,GETDO	;GET INPUT IF NECESSARY
	MOVEM	T3,PNT(ALTP)	;RESTORE NEW VALUE
GETWD1:	MOVE	T3,0(T3)	;GET NEXT WORD
	JUMPE	T3,GETWD0	;IGNORE 0 WORDS
	POP	P,ALTP		;RESTORE PNTR
	RET			;RETURN

GETDO:	PUSH	P,T1		;SAVE REGS
	PUSH	P,T2
	AOS	T1,CNT(ALTP)	;GET NEXT PAGE #
	HRL	T1,IJFN(ALTP)	;INPUT JFN
	RPACS			;SEE IF PAGE EXISTS
	TLNN	T2,(PA%PEX)	;???
	JRST	GTEOF		;NO - RETURN EOF
	HRRZ	T2,BUF(ALTP)	;BUFFER ADDRS
	LSH	T2,-^D9		;CONVERT TO PAGE #
	HRLI	T2,.FHSLF	;FORK HANDLE
	MOVSI	T3,(PM%RD!PM%CPY) ;READ ACCESS
	PMAP			;GET PAGE
	MOVNI	T3,0(T1)	;- PAGE #
	IMULI	T3,1000		;TIMES WORDS / PAGE
	ADD	T3,FSZ(ALTP)	;INPUT FILE EOF BYTE #
	MOVNS	T3		;- COUNT BEYOND HERE
	CAMGE	T3,[-1000]	;CHECK MAX
	MOVNI	T3,1000		;MAX ALLOWED
	HRLS	T3		;-WC,,0
	HRR	T3,BUF(ALTP)	;POINT TO BUFFER BEGINNING
	MOVEM	T3,PNT(ALTP)	;SAVE
IFN CRYPSW, <
	MOVE T1,PNT(ALTP)	;BUFFER PNTR
	HRRZ T2,CNT(ALTP)	;PAGE #
	MOVE T3,ICRCOD		;ASSUME CURRENT INPUT
	TLNE FL,COPFIL
	MOVE T3,ALTCOD		;NO - USE ALT INPUT
	PUSHJ P,CRYPT.##
	MOVE T3,PNT(ALTP)	;RESTORE PNTR
>; IFN CRYPSW
	POP	P,T2		;RESTORE REGS
	POP	P,T1
	JRST	GETWD1		;GET WORD

GTEOF:	HRRZ	T2,BUF(ALTP)	;GEN BUFFER PAGE #]
	LSH	T2,-^D9
	CALL	UNMAP		;REMOVE BUFFER
	POP	P,T2		;RESTORE REGS
	POP	P,T1		;...
	POP	P,ALTP		;PRUNE THIS ALSO
RTEOF1:	TRO	FL,EOF		;SET EOF FLAG
RTEOF:	MOVEI	T3,0		;RETURN ZERO
	RET			;...

;ROUTINE TO REMOVE PAGE SPECIFIED BY T2

UNMAPL:	PUSH	P,T1		;SAVE T1
	LSH	T2,-^D9		;CONVERT TO PAGE #
	CALL	UNMAP		;UNMAP IT
	POP	P,T1		;RESTORE T1
	RET			;RETURN

UNMAPO:
IFN CRYPSW, <
	MOVE T1,[-1000,,OBUF0]
	HRRZ T2,OPCNT		;LAST PAGE #
	AOS T2			;...
	MOVE T3,OCRCOD
	PUSHJ P,CRYPT.##	;ENCRYPT
>; IFN CRYPSW
	MOVEI	T2,<OBUF0>B44	;OUTPUT BUFFER PAGE
UNMAP:	HRLI	T2,.FHSLF	;FORK HANDLE
	MOVNI	T1,1		;SAY DELETE IT
	MOVEI	T3,0		;NO STATUS
	PMAP			;DO IT
	RET			;RETURN

;CHARACTER INPUT ROUINTE

GCHAR:	TRNE	FL,EOF		;CHECK EOF SEEN
	JRST	RTEOF
	PUSH	P,ALTP		;SAVE PNTR
	MOVEI	ALTP,CIPB	;ASSUME PRIMARY INPUT
	TLNE	FL,COPFIL	;USING ALTERNATE INPUT
	MOVEI	ALTP,AIPB	;YES - USE ALTERNATE
GCHAR0:	SOSLE	BYT(ALTP)	;CHECK CHARS LEFT
GCHAR1:	JRST	[ILDB T3,TXT(ALTP) ;GET ONE
		 JUMPE T3,GCHAR0 ;SKIP OVER NULLS
		 POP P,ALTP
		 RET]		;RETURN
	PUSH	P,T1		;NEED MORE - SAVE REGS
	PUSH	P,T2
	MOVE	T1,IJFN(ALTP)	;JFN TO USE
	HRRO	T2,BUF(ALTP)	;WHERE TO PUT INPUT
	MOVNI	T3,1000*5	;CHARS TO READ (PAGE)
	SIN			;SLURP!
	ADDI	T3,1000*5	;SEE HOW MANY READ
	JUMPE	T3,[POP P,T2	;RESTORE PDL
		    POP P,T1
		    POP P,ALTP
		    JRST RTEOF1]
	MOVEM	T3,BYT(ALTP)	;SAVE COUNT
	HRRZ	T3,BUF(ALTP)	;BUFFER ADDRS
	HRLI	T3,(<POINT 7,0>)	;FORM BP
	MOVEM	T3,TXT(ALTP)	;PNTR TO BUFFER
	POP	P,T2		;PRUNE PDL
	POP	P,T1
	JRST	GCHAR1		;AND EXIT


OUTWDZ:	MOVEI	T3,0		;OUTPUT A WORD OF ZEROES
OUTWD:	PUSH	P,T1		;SAVE T1
	MOVE	T1,OUPNT	;OUTPUT PNTR
	AOBJP	T1,OUTDO	;DUMP IF FULL
OUTWD1:	MOVEM	T3,0(T1)	;LOAD BUFFER
	MOVEM	T1,OUPNT	;RESTORE PNTR
	POP	P,T1		;PRUNE STACK
	RET			;EXIT

OUTDO:	PUSH	P,T2		;SAVE T2
	PUSH	P,T3		;AND WORD
	AOSGE	T1,OPCNT	;OUTPUT PAGE CNT
	JRST	[HRLZ T1,OCRJFN	;INIT PAGE 0
		 JRST OUTDO1]
IFN CRYPSW, <
	MOVE T2,T1		;PAGE #
	MOVE T1,[-1000,,OBUF0]
	MOVE T3,OCRCOD		;OUTPUT CODE
	PUSHJ P,CRYPT.##
	MOVE T1,OPCNT		;RESTORE PAGE #
>; IFN CRYPSW
	AOS	T1		;NEXT PAGE
	HRL	T1,OCRJFN	;OUTPUT JFN
OUTDO1: MOVE T2,[.FHSLF,,<OBUF0>B44]
	MOVSI	T3,(PM%WT)	;WRITE ACCESS
	PMAP			;GET NEXT PAGE FROM FILE
	MOVE	T1,[-1000,,OBUF0]
	POP	P,T3		;RESTORE REGS
	POP	P,T2		;...
	JRST	OUTWD1		;TRY TO DUMP WORD

;ROUTINE TO SET EOF PNTR FOR OUTPUT FILE

OUTFIN:	CALL	UNMAPO		;DELETE OUTPUT BUFFER
	AOS	T3,OPCNT	;# OF PAGES WRITTEN
	AOS	T3		;...
	LSH	T3,^D9		;CVT TO WORDS
	JUMPE	T3,OUTFN1	;HAVE SIZE IF 0
	HLRE	T1,OUPNT	;CHECK PARTIAL PAGE
	MOVNS	T1		;COUNT +1 OF WORDS UNWRITTEN
	SUBI	T3,-1(T1)	;ADJUST WORD COUNT
OUTFN1:	HRRZ	T1,OCRJFN	;GET JFN
	HRLI	T1,.FBSIZ	;SET EOF PNTR IN FILE
	MOVNI	T2,1		;SET MASK
	CHFDB			;SET FDB
	HRLI	T1,.FBBYV	;SET BYTE SIZE FIELD
	MOVSI	T2,(77B11)	;MASK
	MOVSI	T3,(<^D36>B11)	;BYTE SIZE
	CHFDB			;SET IT
	HRRZS	T1		;JFN ONLY
	PJRST	DOCLSF		;CLOSE IT

;ROUTINE TO DUMP BUFFER FROM BUFP TO (T1)

DUMP:	MOVE	T2,BUFP
	CAMGE	T2,T1		;CHECK TO SEE IF WE ARE DUMPING ANYTHING
	TRZ	FL,BOF		;IF SO TURN OFF BOF
	TRNN	FL,READOF	;RETURN IF READ ONLY MODE
DUMP1:	CAML	T2,T1		;MORE TO DO?
	POPJ	P,		;NO, RETURN
	LDB	T3,[POINT 7,OUPNT,17]
	CAIN	T3,176		;LAST WORD OF SECTOR?
	PUSHJ	P,OUTWDZ	;YES - DUMP ZERO
	MOVE	T3,0(T2)	;DUMP FIRST WORD
	CAMN	T3,PGMK		;COUNT PAGES
	AOS	OPG		;FOR =LOC COMMAND
	PUSHJ	P,OUTWD		;...
DUMP2:	SKIPE	T3,1(T2)	;LOOK FOR END
	TRNE	T3,1		; OR SEQUENCE NUMBER?
	AOJA	T2,DUMP1	;ANY END WILL DO
	PUSHJ	P,OUTWD		;DUMP WORD
	AOJA	T2,DUMP2	;LOOP BACK
	JRST	DUMP1		;GO CHECK FOR END

;ROUTINE TO DELETE FILE AND EXPUNGE

DODELF:	TLO	T1,(DF%NRJ) 	;RETAIN JFN
DDELFR:	TLO	T1,(DF%EXP)	;EXPUNGE ALSO
	DELF			;DELETE FILE
	  FJERR
	HRRZS	T1		;RETURN JFN
	RET			;RETURN

;ROUTINE TO CLOSE FILE AND RETAIN JFN

DOCLSF:	TLO	T1,(1B0)	;NO RELEASE JFN
DOCLSR:	CLOSF			;CLOSE
	  FJERR
	HRRZS	T1		;CLEAR LHS
	RET			;RETURN


INSIST:	OUTSTR	[ASCIZ "? You must type either "]
CONFRM:	OUTSTR	[ASCIZ "(y or n): "]
	CALL	INHELP		;GET RESPONSE
	 JRST	INSIST		;HE ASK FOR HELP
	CAIN	T1,"Y"		;IS IT YES?
	JRST	CPOPJ1		;YEP - SKIP RETURN
	CAIN	T1,"N"		;OR NO
	POPJ	P,		;NON-SKIP
	JRST	INSIST		;ELSE GRUMP AT HIM


GETN:	MOVE T1,WC	;GET THE NEXT BUFFER. FIND CURRENT WORD COUNT
	CAMGE T1,HLFWC	;GREATER THAN HALF OF MAX POSSIBLE?
	JRST FILLBF	;NO, JUST REFILL BUFFER
	ASH T1,-1	;YES, TAKE HALF OF IT
	ADD T1,BUFP	;CONVERT TO POINTER
GETN1:	SKIPN T2,(T1)	;LOOK FOR A WORD BOUNDARY
	JRST NOWFL	;WE ARE HERE?
	TRNN T2,1	;SEQUENCE NUMBER?
	SOJA T1,GETN1
NOWFL:	PUSHJ P,DUMP	;DUMP IT
	MOVE T2,T1	;COPY POINTER
	SUB T2,BUFP	;AND FIND OUT HOW MANY DUMPED
	SUB PNTR,T2	;ADJUST POINTER
	EXCH T2,WC	;CALC NEW WORD COUNT
	SUBB T2,WC
	ADD T2,BUFP	;GET POINTER TO END OF BUFFER
	HRLS T1		;SET UP BLT
	HRR T1,BUFP
	BLT T1,(T2)
	JRST FILLBF	;AND FINISH FILLIN BUFFER



FILLBF:	MOVE T1,WC	;GET WORD COUNT
	ADD T1,BUFP	;AND CONVERT TO POINTER TO END OF BUFFER
FILBF3:	CAML T1,FILPT	;FULL ENOUGH?
	POPJ P,		;YES, RETURN
	TLNE FL,TECOF	;SPECIAL READING FOR TECO FILES
	JRST RDTECO
	HRLI T1,-MXWPL-2	;GET A COUNT FOR MAX LINE SIZE
	SKIPN T3,SVWD	;SEE IF THERE IS A WORD LEFT FROM LAST TIME
	PUSHJ P,GETWD	;ELSE GET A NEW ONE
	JUMPE T3,SNEOF	;MUST BE EOF
	CAMN	T3,PGMK		;CHECK FOR PAGE MARKS
	JRST	CKPGMK		;GO FUDGE P/M
	TLZE FL,FSTOPF	;IF FIRST OP
	JRST CKTECO	;CHECK FOR TECO FILE
NOTECO:	MOVEM T3,SVWD2	;SAVE FOR SEQUENCE CHECK
	JRST FILBF4	;GO PUT IT AWAY
FILBF1:	PUSHJ P,GETWD	;ELSE GET A NEW ONE
	JUMPE T3,FILBF2	;0 WORD MUST BE EOF
	TRNE T3,1	;CHECK FOR SEQNUM
	JRST FILBF2	;YES, FINISH PUTTING IT IN
FILBF4:	MOVEM T3,(T1)	;PUT IN THIS WORD
	AOS WC		;AND ADVANCE WORD COUNT
	AOBJN T1,FILBF1	;ADVANCE POINTER AND CHECK COUNT
	JRST INLTL	;LINE IS TOO LONG
FILBF2:	MOVEM T3,SVWD	;SAVE THIS WORD
FILBF0:	SETZM (T1)	;MAKE SURE OF A ZERO WORD
	HRRZS T1	;ELIMINATE COUNT INFO
	MOVE T3,SVWD2	;CHECK ON ORDER OF INPUT LINES
	CAMG T3,OLDLIN	;CHECK FOR CORRECT ORDER
	JRST OUTOFO	;LINES ARE OUT OF ORDER
FILBF5:	MOVEM T3,OLDLIN	;SAVE FOR LATER
	SKIPE SVWD	;CHECK TO SEE IF WAS EOF
	JRST FILBF3	;AND TRY FOR MORE
SNEOF:	SETZM (T1)	;MAKE SURE OF ZERO WORD
	TRO FL,EOF2	;SET EOF FLAG
	MOVE T1,INPG	;GET INPUT PAGE
	MOVEM T1,BGPG	;AND SET LARGEST PAGE
	TRO FL,BGSN
	SETZM SVWD	;ALSO ZERO EXTRA WORD
	POPJ P,		;AND RETURN

CKPGMK:	SETZM	OLDLIN		;RESET LINE LAST INPUT
	AOS	INPG		;INCR INPUT PAGE
	MOVEM	T3,0(T1)	;STASH PGMK
	AOS	WC		;INCR WORD/COUNT
	PUSHJ	P,GETWD		;PASS NEXT WORD
	MOVE	T3,PGMKW2	;GRNTEE CORRECT P/M 2ND WORD
	MOVEM	T3,1(T1)	;STASH
	AOS	WC		;INCR WC
	SETZM	2(T1)		;GRNTEE ZERO WORD
	SETZM	SVWD		;FORCE READ
	MOVEI	T1,2(T1)	;CORRECT PNTR
	JRST	FILBF3		;CHECK FULL

INLTL:	PUSHJ P,GETWD	;FIND THE END OF THE LINE ON INPUT
	JUMPE T3,INLTL2	;THIS IS IT
	TRNN T3,1	;OR MAYBE THIS
	JRST INLTL	;KEEP LOOKING
INLTL2:	MOVEM T3,SVWD	;SAVE IT
	PUSH P,T1	;SAVE POINTER TO END OF IT
	SUBI T1,2	;LAST PART THAT IS IN THE LINE
	MOVEI T2,<BYTE (21)0(7)15,12>	;A CRLF
	DPB T2,[POINT 15,(T1),35]	;MAKE SURE IT ENDS PROPERLY
INLTL1:	SKIPN T2,(T1)	;NOW LOOK FOR THE START OF IT
	ERROR ICN	;SOMETHING HAS GONE WRONG, THERE IS NO LINE 
	TRNN T2,1	;START?
	SOJA T1,INLTL1	;NO, TRY AGAIN
	MOVE T2,INPG	;PRINT HIM THE CURRENT PAGE
	PUSHJ P,PGPRN
	PUSHJ P,OUTLIN	;PRINT THE LINE
	RERROR LTL	;AND THE ERROR MESSAGE
	POP P,T1	;RESTORE POINTER TO END
	SOS WC	;GET WORD COUNT CORRECTED
	SOJA T1,FILBF0	;AND CONTINUE FILL

OUTOFO:	PUSH P,T1	;SAVE THE POINTER
	PUSH P,T3	;SAVE T3 ALSO
	SUBI T1,1	;GET BACK INTO LINE
OUTOF1:	SKIPN T2,(T1)	;LOOK FOR START OF LINE
	ERROR ICN	;HORRIBLE CONFUSION
	TRNN T2,1	;CHECK FOR SEQ NUM
	SOJA T1,OUTOF1	;NOPE, TRY SOME MORE
	MOVE T2,INPG	;PRINT HIM THE PAGE
	PUSHJ P,PGPRN
	PUSHJ P,OUTLIN	;PRINT THE LINE
	RERROR ORDER	;GIVE HIM SOMETHING TO THINK ABOUT
	POP P,T3	;RESTORE
	POP P,T1	;GET SET TO GO ON
	JRST FILBF5	;GO


CKTECO:	TRNE	T3,1		;CHECK FOR A LINE NUMBER
	JRST	NOTECO		;NO ITS NOT A TECO FILE
	TLO	FL,TECOF	;SET WARNING FLAG
	SETZM	SVWD		;GRNTEE USE FIRST SEQ #
	SETZM	SVWD3		;CLEAR THIS (FORCED PM HACK)
	PUSH	P,T1		;SAVE T1
	TLNE	FL,COPFIL	;IS IT ANOTHER FILE?
	JRST	[SETZM AIPBYT	;CLEAR INPUT BYTE COUNT
		 HRRZ T2,AIPBUF	;PAGE TO UNMAP
		 CALL UNMAPL	;...
		 HRRZ T1,AIPJFN	;JFN TO RESET
		 JRST RDTECR]
	TLO	FL2,PCHGF!FCHGF	;SAY WE'VE CHANGED
	SETZM	CIPBYT		;CLEAR INPUT BYTE COUNT
	HRRZ	T2,CIPBUF	;PAGE TO UNMAP
	CALL	UNMAPL		;DO IT
	HRRZ	T1,CIPJFN	;SET UP FOR FILE RESET
RDTECR:	MOVEI	T2,0		;SET PTR TO ZERO
	SFPTR			;...
	  FJERR			;SHOULDNT HAPPEN
	POP	P,T1		;RESTORE T1

RDTECO:	HRRZM	T1,TMPT1	;SAVE THIS FOR A WHILE
	MOVEI	T3,1(T1)	;ZERO OUT A FEW WORDS
	HRL	T3,T1
	SETZM	(T1)
	BLT	T3,MXWPL(T1)
	ADDI	T1,1		;THIS IS WHERE CHRS SHOULD BE PUT
	PUSH	P,T1		;SAVE
	SKIPE	T1,SVWD		;CHECK BEGINNING OF PAGE
	CAIN	T1,1		;...
	JRST	[MOVE T1,TECFST
		 MOVEM T1,SVWD
		 MOVEM T1,SVWD2
		 JRST RDTEC1]
	MOVE	T2,TECINC	;GET INCREMENT
	PUSHJ	P,ASCIAD
	MOVEM	T1,SVWD		;SAVE FOR LATER
	MOVEM	T1,SVWD2	;AND FOR ORDER CHECK
	CAMGE	T1,TECINC	;CHECK WAR
	JRST	INSPG1		;FORCE PAGE INSERT
RDTEC1:	EXCH	T1,(P)		;GET OLD T1 BACK AND SAVE NUMBER
	MOVEI	T2,MXWPL*5-2	;COUNT
	MOVEI	T3,11		;FIRST CHR
	HRLI	T1,(<POINT 7,0>)
	IDPB	T3,T1
	SKIPN	T3,SVWD3	;SEE IF WE ALREADY TOOK CHAR
LINL1:	CALL	GCHAR		;NEXT CHR
LINL1A:	CAIN	T3,15
	JRST	LINL1		;IGNORE RETURNS
	SETZM	SVWD3		;SAY WE GOT IT
	CAIN	T3,14
	JRST	IPGMK		;INSERT PAGE MARK
	JUMPE	T3,EOF1		;MUST BE END OF FILE
	POP	P,-1(T1)	;PUT NUMBER IN PROPER PLACE
	JRST	LP1		;AND READ MORE OF LINE
CLP:	CALL	GCHAR
LP1:	CAIN	T3,15		;IGNORE RETURNS
	JRST	CLP
	CAIE	T3,0		;FOR EOF
	CAIN	T3,12		;OR LINE FEED
	JRST	LINFD		;GO PUT IN RETURN LINE FEED
	CAIN	T3,14
	JRST	LINFD
	IDPB	T3,T1		;ELSE DEPOSIT
	SOJG	T2,CLP		;HAVE WE RUN OUT
	ADD	T1,[XWD 700,0]	;BACK UP POINTER
	TLZ	FL,TECOF	;USE THE ABSENCE AS A FLAG
LP2:	CALL	GCHAR		;(205) GET A CHARACTER
	CAIN	T3,12		;(205) IS IT A LINEFEED?
	JRST	LINFD		;(205) YES
	CAIN	T3,14		;(205) FORMFEED?
	JRST	LINFD		;(205) YES
	JRST	LP2		;(205)
LINFD:	CAIN	T3,14		;(SPR 20-13746) HERE ON A FORMFEED?
	MOVEM	T3,SVWD3	;(SPR 20-13746) YES, SAVE IT
	MOVEI	T3,15
	IDPB	T3,T1
	MOVEI	T3,12
	IDPB	T3,T1
	MOVEI	T1,1(T1)
	MOVE	T3,T1
	SUB	T3,TMPT1	;GET COUNT
	ADDM	T3,WC
	TLOE	FL,TECOF	;IF OFF WE HAD A LTL ERR
	JRST	FILBF0		;THIS WILL FINISH UP
	PUSH	P,T1		;SET UP FOR LTL CODE
	AOS	WC
	AOS	(P)
	SOJA	T1,INLTL1

INSPG1:	POP	P,T1		;RESTORE PNTR
IFN STANSW, <
	OUTSTR	[ASCIZ/
%Too many lines on current input page -- inserting page mark and continuing.
/]
>; IFN STANSW
	PUSHJ	P,MAKPM		;GENERATE PAGE MARK
	CALL	GCHAR		;PEEK AT NEXT CHAR
	CAIN	T3,15		;IGNORE CRS
	JRST	.-2
	CAIN	T3,14		;IF FF THEN SKIP IT
	JRST	FILBF3		; (ALREADY HAVE PM)
	MOVEM	T3,SVWD3	;SAVE FOR LATER
	JRST	RDTECO		;PROCESS NEXT LINE.

IPGMK:	POP	P,0(P)		;CLEAN OFF STACK
	PUSHJ	P,MAKPM		;GENERATE PAGE MARK
	JRST	FILBF3		;FINISH OFF

MAKPM:	MOVEI	T3,1		;SO IT WILL NOT BE EOF
	MOVEM	T3,SVWD		;SO WE START OVER
	MOVE	T3,PGMK
	MOVEM	T3,OLDLIN
	MOVEM	T3,-1(T1)
	MOVEI	T2,2
	ADDM	T2,WC
	MOVE	T3,PGMKW2
	MOVEM	T3,(T1)
	SETZM	1(T1)		;GRNTEE ZERO
	MOVEI	T1,1(T1)	;UPDATE PNTR
	AOS	INPG		;INCR INPUT PAGE
	POPJ	P,		;RETURN

EOF1:	POP	P,T2		;CLEAR STACK
	SOJA	T1,SNEOF


SUBTTL	RANGE SPECIFIER READERS

;ROUTINE TO GET ONE LINE NUMBER FROM INPUT STREAM. HANDLES + AND -

GETLS:	PUSHJ P,SCAN
GETL:	TRZ FL,LINSN!ADDL!SUBL
	TRZ FL2,STARF
	TLZ FL2,UARWF
	CAIN C,"^"
	JRST DOFST
	CAIN C,"*"
	JRST DOLST
IFN EXTEND,<
	CAIN C,200	;DO WE HAVE TO SEARCH FOR IT
	PUSHJ P,LSRCH	;OK THEN HERE WE GO
>; IFN EXTEND
	TRZN FL,NUMF
	POPJ P,		;SCAN DID NOT SEE A NUMBER RETURN (CALLER CAN GIVER ERR)
	MOVEM T1,HILN	;SAVE THE NUMBER HERE
GETL1:	TRO FL,LINSN	;SET A FLAG TO SAY WE SAW THE LINE
	PUSHJ P,SCAN	;SCAN FOR + OR -
	CAIN C,"+"
	JRST ADDNUM
	CAIE C,"-"
	POPJ P,		;NEITHER
	TROA FL,SUBL	;SET SUBTRACT FLAG
ADDNUM:	TRO FL,ADDL	;SET ADD FLAG
	PUSHJ P,SCAN	;SCAN ANOTHER
	TRZN FL,NUMF	;WAS IT A NUMBER
	NERROR ILC	;ANYTHING ELSE IS ILLEGAL
	MOVEM T2,SVINC	;SAVE IT
	JRST SCAN	;RETURN AFTER SCANNING ONE MORE
DOLST:	TRO FL2,STARF
	JRST GETL1
DOFST:	TLO FL2,UARWF
	JRST GETL1

;ROUTINE TO RESOLVE THE + AND - IN THE LINE NUMBER. WE MUST WAIT
;UNTIL THE PAGE HAS BEEN DEFINED BEFORE DOING THIS

ADDSUB:	MOVE SINDEX,HILN	;GET THE NUMBER
	MOVE T1,HIPG	;GET THE REQUIRED PAGE
	MOVEM T1,DPG	;AND SET IT AS THE DESIRED ONE
	TLNE FL2,UARWF
	JRST	[PUSHJ P,EVALUP
		 JRST DOAS]
	TRNN FL2,STARF
	JRST DOAS
	MOVE SINDEX,[<ASCII /99999/>!1]	;FIND A BIG LINE
	PUSHJ P,FIND
	CAME T1,[<ASCII /99999/>!1]	;IF ITS THERE ITS LAST
	PUSHJ P,FINDB		;ELSE BACK UP
	SKIPE T1		;CHECK TO SEE IF EMPTY PAGE
	CAMN T1,PGMK
	SKIPA
	MOVE SINDEX,T1	;OK, USE ONE FOUND, ELSE LEAVE BIG
DOAS:	TRZE FL,ADDL	;DID WE WANT TO ADD?
	JRST ADLIN	;YES, GO ADD
	TRZN FL,SUBL	;OR SUBTRACT?
CPOPJ:	POPJ P,	;NO, RETURN
	PUSHJ P,FIND	;GET THE DESIRED LINE
SUBL1:	SOSGE SVINC	;DO WE WANT TO GO BACK STILL FARTHER
	POPJ P,		;NO, ALL DONE
	PUSHJ P,FINDB	;GET THE PREVIOUS LINE
	SKIPE T1	;0 MUST BE AT START OF BUFFER, QUIT
	CAMN T1,PGMK	;WAS IT A PAGE MARK?
	POPJ P,		;YES, AS FAR AS WE GO, SINDEX HAS CORRECT NUMBER
	MOVE SINDEX,T1	;THIS WILL DO
	JRST SUBL1	;GO TRY FOR MORE
ADLIN:	PUSHJ P,FIND	;GET DESIRED LINE
	CAME T1,PGMK	;WAS IT A PAGE MARK?
	JUMPN T1,ADLIN1	;OR 0 (I.E. END OF FILE)
	POPJ P,		;RETURN WITH ORIGINAL NUMBER
ADLIN1:	CAME T1,HILN	;SEE IF AN EXACT MATCH
	SOS SVINC	;IF NO, ALREADY ARE +1
	MOVE SINDEX,T1	;GET THE WORD WE HAVE FOUND
ADLIN2:	SOSGE SVINC	;NEED TO GO FURTHER
	POPJ P,		;NO, RETURN RESULTS
	PUSHJ P,FINDN	;GET THE NEXT LINE IN SEQUENCE
	CAME T1,PGMK	;PAGE MARK?
	JUMPN T1,.+2	;OR EOF
	POPJ P,		;YES, RETURN
	MOVE SINDEX,T1	;ACCEPT NEW NUMBER
	JRST ADLIN2	;AND LOOK FOR MORE

;EVALUP - ROUTINE THAT ASSIGNS THE CORRECT VALUE TO UP-ARROW
;
;	  UP-ARROW IS THE FIRST LINE FOUND ON THE PAGE,
;	  UNLESS WE ARE IN INSERT MODE.  IN INSERT MODE,
;	  IF 00000 DOES NOT EXIST, UP-ARROW IS A LINE
;	  HALFWAY BETWEEN 00000 AND THE FIRST LINE ON THE PAGE.

EVALUP:	MOVE	SINDEX,[<ASCII /00000/>!1] ;LOOK FOR LINE 00000
	PUSHJ	P,FIND		;PUT IN T1, ELSE GET NEXT LINE
	SKIPE	T1		;FOUND EOF?
	CAMN	T1,PGMK		;NO, BUT IS IT A PAGE MARK?
	JRST	[MOVE T1,TECFST
		 JRST EVALU1]	;USE line = START IF EOF OR PGMK
	TRNN	FL2,UPTOPF	;DO SPECIAL STUFF IF INSERT
	JRST	EVALU1		;GO SAVE WHAT WE GOT
	CAMN	T1,[<ASCII /00000/>!1] ;DID WE FIND LINE 00000 EXISTS?
	 NERROR	ILR		;YES, GIVE ERROR
	CAMLE	T1,TECFST	;No, is this line <= START parameter?
	JRST	[MOVE T1,TECFST
		 JRST EVALU1]	;No, Use line = start 
	MOVE	T2,[<ASCII /00000/>!1] ;Yes, GET READY TO AVERAGE for new one
	PUSHJ	P,ASCAV		;AVERAGE 0 AND FIRST LINE
	MOVE	T1,T2		;PUT ANSWER IN T1
EVALU1:	MOVE	SINDEX,T1	;SAVE RESULT IN SINDEX
	POPJ	P,

;ROUTINE GETS A FULL SEQ NUMBER OF FORM A/B

GETLAS:	PUSHJ P,SCAN
GETLA:	TRZ FL,PGSN	;NO PAGE SEEN YET
	PUSHJ P,GETL	;GET THE LINE NUMBER PART
	MOVE T2,CPGL	;IN CASE LSRCH GOT A NEW PAGE
	TRNE FL,PGSN	;DID LSRCH GET PAGE?
	MOVEM T2,HIPG	;YES, USE IT
	CAIE C,"/"	;IS THIS A PAGE COMING?   
	JRST NOPG	;NO, A LINE NUMBER AT MOST
	PUSHJ P,SCAN	;YES, GET THE PAGE NUMBER
	CAIN C,"*"
	JRST LASTPG		;GET LAST PAGE #
	CAIE C,"^"		;UPARROW MEANS
	JRST GETLPG		;GET PAGE 1
	MOVEI T2,1
	TRO FL,NUMF		;MAKE LIKE NUMBER
GETLPG:	SKIPLE T2	;NUMBERS .LE. 0 LOSE
	TRZN FL,NUMF	;WAS IT A NUMBER
	NERROR ILC	;LOSE LOSE
	TRO FL,PGSN	;YEP, WE SAW IT
	MOVEM T2,HIPG	;SAVE THAT NUMBER
	PUSHJ P,SCAN	;CHECK FOR + OR -
	CAIN C,"+"
	JRST PGPLS
	CAIE C,"-"
	JRST NOPG	;NO, GO DO ADSUB ON LINE NUMBER
	PUSHJ P,SCAN	;GET THE NUMBER
	TRZN FL,NUMF	;MUST BE A NUMBER
	NERROR ILC
	MOVE T1,HIPG
	SUB T1,T2
	MOVEM T1,HIPG	;FILL IN NUMBER
NOPGA:	PUSHJ P,SCAN	;SCAN PAST NUMBER
NOPG:	TRNN FL,LINSN!PGSN	;DID WE SEE A LINE OR A PAGE?
	NERROR ILC	;NO, SOMETHING IS WRONG
	PUSH P,T1	;SAVE (HAVE ALREADY SCANNED)
	PUSH P,T2
	PUSHJ P,ADDSUB	;TAKE CARE OF + AND - FOR LINE
	POP P,T2
	POP P,T1
	MOVEM SINDEX,HILN	;SAVE RESULT
	POPJ P,		;AND RETURN


PGPLS:	PUSHJ P,SCAN	;GET NUMBER TO ADD
	TRZN FL,NUMF	;A NUMBER?
	NERROR ILC	;NO, NERROR
	ADDM T2,HIPG	;ADD IT IN
	JRST NOPGA	;AND CLEAN UP

LASTPG:	TRNE	FL,BGSN		;SEEN LAST
	JRST	LSTPG1		;YES: SKIP CODE
	MOVSI	T1,1
	MOVEM	T1,DPG		;TRY FOR LARGE
	MOVEI	SINDEX,0
	PUSHJ	P,FIND
	TRNN	FL,BGSN		;SHOULD SEE IT NOW
	ERROR	ICN
LSTPG1:	MOVE	T2,BGPG
	TRO	FL,NUMF		;NUMBER SEEN
	JRST	GETLPG



;ROUTINE SETS HIPG IN CASE NONE SEEN BY GETLA, THEN CALLS GETLA

GET1S:	PUSHJ P,SCAN
GET1:	MOVE T3,CPGL
	MOVEM T3,HIPG
	JRST GETLA


;GET A PAIR OF FORM A/B,C/D LOLN IS SET BY CALLER BEFORE CALL

GET2S:	PUSHJ P,SCAN
GET2:	TRZ FL,CNTF	;NOT A ! COMMAND
IFN STANSW,<
	CAIN C,"%"		;SPECIAL NEW SYMBOL TO MEAN ^/^:/* --OO7
	 JRST GETALL
>; IFN STANSW
	PUSHJ P,GET1	;GET A LINE AND PAGE NUMBER PAIR
	MOVE T3,HIPG	;NOW SET LOWER PAGE TO THE ONE SEEN
	MOVEM T3,LOPG
	MOVE T3,HILN	;RESET LOW LINE IS A NUMBER SEEN
	TRNE FL,LINSN
	MOVEM T3,LOLN
GET2HF:MOVE T3,[<ASCII /99999/>!1] ;SET UP A LARGE NUMBER
	TRNN FL,LINSN	;IF NO LINE NUMBER SEEN
	MOVEM T3,HILN
	TRZ FL,PGSN	;SO DELETE CAN DETECT A SECOND PAGE SPEC
	CAIN C,"!"	;IS IT A ! COMMAND?
	JRST GET2CT	;GO TAKE CARE OF IT
	CAIE C,":"	;CHECK FOR SECOND SET
	POPJ P,		;NOPE, RETURN
	MOVEM T3,HILN	;SET HILN ANYWAY
	JRST GETLAS	;AND GO GET THE SECOND PAIR

GET2CT:	TRO FL,CNTF	;SET THE APPROPRIATE FLAG
	PUSHJ P,SCAN	;THERE SHOULD BE A NUMBER HERE
	TRNN FL,NUMF
	NERROR ILC	;LOSE
	MOVEM T2,SVCNT	;HANG ON TO IT
	JRST SCAN	;SCAN NEXT AND RETURN

IFN STANSW,<
;ROUTINE TO EVALUATE RANGE EQUIVALENT TO ^/^:/*, I.E. WHOLE FILE
GETALL:	MOVE T1,[<ASCII /00000/>!1]  ; ^
	MOVEM T1,LOLN
	MOVEI T2,1		;ASSUME PAGE 1 EXISTS
	MOVEM T2,LOPG		; /^
	MOVE T1,[<ASCII /99999/>!1]  ; *
	MOVEM T1,HILN
	TRNE FL,BGSN		;SEEN BIGGEST PAGE YET?
	 SKIPA T2,BGPG		;YES, USE IT
	  MOVSI T2,1		;NO, PICK A HUGE PAGE NUMBER
	MOVEM T2,HIPG		; /*
	JRST SCAN
>; IFN STANSW

SUBTTL	LINE NUMBER SEARCH

IFN EXTEND,<
;SEARCH FOR A LINE AND USE ITS NUMBER INSTEAD OF .
;MOSTLY PLAGIARIZED FROM SEARCH

LSRCH:	PUSH	P,SVINC	;SAVE PREVIOUSLY GATHERED LINE NUMBERS
	PUSH P,SVCNT
	PUSH	P,HIPG
	PUSH	P,LOLN
	PUSH	P,LOPG
	PUSH	P,FL	;SAVE FLAGS IN CASE CALLED WITHIN SEARCH
	PUSH P,FL2
	TLO FL2,SRCWHO		;(203) SEARCH IS LOOKING
	TLZ	FL,ASSMF	;CLEAR ALL FLAGS
	SETZM LOLN	;JUST LIKE EVERYONE ELSE HAS TO
	SETZM LSCNT	;START WITH ZERO
	MOVE T1,[ASCII "L*"]
	MOVEM T1,FSFLG		;SETUP FLAG
	SOSGE	LSBUFN	;GET STRING BUFFER NUMBER
	NERROR	TMS	;NESTING TOO DEEP
	MOVE	T2,LSBUFN	;INDEX IN STRING BUFFER TABLES
	MOVE	T1,LSPTR(T2)	;SET UP BYTE POINTER
	MOVE T3,LSPTT(T2)	;AND POINTER TO BYTE POINTER TABLE
	PUSHJ P,SSTRNG	;GET A SEARCH STRING
	JRST	[MOVE T2,LSBUFN		;INDEX TO POINTERS
		SKIPN @LSPTT(T2)	;WAS STRING SET?
		NERROR NSG	;NO, TELL HIM
		CAIN C,12
		JRST ASLMD1	;SPECIAL CONTINUE MODE
		JRST .+1]	;YES, USE OLD ONE
	TLZ FL,NUMSRF!DECID!EXCTSR	;CLEAR FLAGS
	PUSHJ P,SCAN	;CHECK FOR WHAT COMES AFTER
	TRNN FL,TERMF	;IF TERMINATOR
	CAIN C,","	;OR ,
	JRST ASLMDT	;SET UP LIMITS SPECIALLY
	CAIE C,"!"
	CAIN C,":"
	JRST ASLMDT	;LET HIM SPECIFY 2ND HALF OF RANGE
	PUSHJ P,GET2	;ELSE CALL USUAL LIMIT ROUTINE
LSC4:	MOVE T1,HILN	;SAVE END OF RANGE
	MOVEM T1,LSHILN
	MOVE T1,HIPG
	MOVEM T1,LSHIPG
	CAIE C,","	;ANY MORE ARGUMENTS?
	JRST LSC1	;NO, CHECK TERMINATOR AND PROCEED
	PUSHJ P,SCAN	;YES, SEE WHAT IT IS
	TRNN FL,IDF	;SHOULD BE IDENT OR NUMBER
	JRST LSC2	;NOT IDENT, CHECK FOR NUMBER OF SEARCHES
	MOVS T1,ACCUM	;GET THE IDENT
	CAIN T1,(<SIXBIT /N  />)	;AND FIND OUT WHAT IT IS
	TLO FL,NUMSRF!DECID
	CAIN T1,(<SIXBIT /D  />)
	TLO FL,DECID	;WANTS TO DECIDE ON LINE
	TLNN FL,NUMSRF!DECID	;WAS IT EITHER?
	JRST LSC3	;NO, CHECK E
	PUSHJ P,SCAN	;CONTINUE LOOKING
	CAIE C,","
	JRST LSC1	;NO MORE ARGUMENTS
	PUSHJ P,SCAN	;WELL WHAT KIND IS THIS ONE?
	TRNN FL,IDF	;MORE IDENTS?
	JRST LSC2	;NO, MUST BE NUMBER OF SEARCHES
	MOVS T1,ACCUM
LSC3:	CAIE T1,(<SIXBIT /E  />)
	NERROR ILC	;NO, HE MUST HAVE MADE A MISTAKE
	TLO FL,EXCTSR	;YES, REMEMBER IT
	PUSHJ P,SCAN	;AND CHECK FOR MORE
	CAIE C,","
	JRST LSC1	;NO MORE
	PUSHJ P,SCAN	;ONLY ONE THING IT CAN BE NOW
LSC2:	TRNN FL,NUMF
	NERROR ILC	;NOPE, LOSE
	MOVEM T2,LSCNT	;SAVE AS COUNT OF LINES TO FIND
	PUSHJ P,SCAN	;GET TERMINATOR (WE HOPE)
LSC1:	TRNN FL,TERMF	;ALLS WELL THAT ENDS WELL
	NERROR ILC	;BUT THIS DOSNT
LSCH1A:	MOVE T1,LSBUFN
	MOVE T1,LSPTT(T1)	;GET POINTER TO STRINGS
	PUSHJ P,CODSR	;AND GENERATE CODE


	MOVE T1,LOPG	;GET SET TO HUNT IT
	MOVEM T1,DPG
	MOVEM T1,LSPG	;FLAG TO SAY IF WE SHOULD PRINT PAGE
	MOVE SINDEX,LOLN
	PUSHJ P,FIND
	TRZ FL,LINSN	;NO LINES YET
ONLSC:	PUSHJ P,ONMOV	;CHECK RANGE
	JRST ENDLSC	;DONE
	TLZE FL,ASSMF	;FIRST TIME AND WANT .+1?
	JRST	[CAME T1,LOLN	;IS THERE EXACT MATCH?
		JRST .+1	;NO, THIS IS .+1
		AOS SVCNT	;PRETEND WE DIDNT SEE IT
		JRST LSNXT]	;AND TAKE NEXT
	CAMN T1,PGMK	;PAGES ARE SPECIAL
	JRST LSCPAG	;SO TAKE GOOD CARE OF THEM
	MOVE T2,LSBUFN
	MOVE T2,LSPTT(T2)	;POINTER TO STRINGS
	PUSHJ P,COMSRC	;GO SEARCH THIS LINE
	JRST LSNXT	;LOSER
	MOVE T2,CPG	;GET CURRENT PAGE
	CAME T2,LSPG	;AND SEE IF WE SHOULD PRINT IT
	PUSHJ P,PGPRN	;YES
	MOVE T2,CPG	;NOW SET IT AS CURRENT
	MOVEM T2,CPGL
	MOVEM T2,LSPG	;ALSO RESET FLAG
	MOVE T2,(PNTR)	;ALSO SET LINE
	MOVEM T2,CLN
	TRO FL,LINSN	;WE SAW ONE
	TLNN FL,DECID	;DOES HE WANT OPTION?
	JRST LSNXTC	;NO, GO GET NEXT ONE OR STOP
	TLNE FL,NUMSRF	;DO WE WANT ONLY LINE NUMBERS?
	JRST LSCNUM	;YES
	MOVE T1,PNTR	;GO PRINT LINE
	PUSHJ P,OUTLIN
LSNXT1:
	INCHRW T1
	ANDI T1,177
	OCRLF
	CAIE T1,177	;DID HE SAY RUBOUT(DO NOT USE)?
	JRST LSOUT	;NO, WE'RE THROUGH
LSNXTC:	SOSG LSCNT	;HAVE WE FOUND ENOUGH
	JRST LSOUT	;YES, GIVE UP (WE HAVE SEEN AT LEAST ONE)
LSNXT:	PUSHJ P,FINDN	;GET NEXT LINE TO LOOK A
	JRST ONLSC
LSCNUM:	MOVE T1,(PNTR)	;PRINT SEQUENCE NUMBER
	PUSHJ P,OUTSN
	OCRLF
	JRST LSNXT1	;AND DECIDE
ENDLSC:	TRZN FL,LINSN	;DID WE SEE ONE?
	NERROR NLN	;NULL RANGE
	JRST LSOUT
LSCPAG:	AOS CPG	;JUST ADVANCE PAGE COUNTER
	JRST LSNXT	;AND PROCEED
LSOUT:	POP P,FL2	;RESTORE THE FLAGS WE USED
	POP P,T1
	AND T1,[XWD ASSMF!NUMSRF!EXCTSR!DECID,ADDL!SUBL!CNTF]
	ANDCM FL,[XWD ASSMF!NUMSRF!EXCTSR!DECID,ADDL!SUBL!CNTF]
	IOR FL,T1
	POP P,LOPG	;RESTORE PREVIOUS LINE NUMBERS
	POP P,LOLN
	POP P,HIPG
	POP P,SVCNT
	POP P,SVINC
	MOVE T1,CLN	;LOAD CURRENT LINE AND PAGE WHICH WE FOUND
	MOVE T2,CPGL
	TRO FL, NUMF!PGSN	;AND MAKE LIKE SCAN SAW A NUMBER
	AOS LSBUFN	;GO BACK TO SEARCH STRING ON PREVIOUS LEVEL IF ANY
	POPJ P,		;AND EXIT VICTORIOUS


ASLMD1:	TROA FL,CNTF	;MARK AS KEEP END OF RANGE
ASLMDT:	TRZ FL,CNTF	;JUST IN CASE
	TLO FL,ASSMF	;WE ASSUME .+1
	MOVE T1,CLN	;SET THINGS UP FOR . TO INFINITY
	MOVEM T1,LOLN
	MOVEM T1,HILN	;AS GOOD AS ANYTHING WITH THE PAGE WE WILL
	MOVE T1,CPGL	;USE
	MOVEM T1,LOPG
	TRZE FL,CNTF	;KEEP END?
	JRST LNOSPC	;YES
	CAIE C,":"	;IF A : OR !
	CAIN C,"!"
	JRST HALFLS	;GET THE SECOND HALF (.+1 TO GIVEN)
	MOVSI T1,377777	;GET A LARGE PAGE
	MOVEM T1,HIPG
	JRST LSC4	;BACK INTO THINGS

HALFLS:	MOVEM T1,HIPG	;SET TOP AS /.
	PUSHJ P,GET2HF	;GET THE SECOND HALF
	JRST LSC4	;AND GO

LNOSPC:	MOVE T1,LSHIPG
	MOVEM T1,HIPG	;PUT BACK END
	MOVE T1,LSHILN
	MOVEM T1,HILN
	JRST LSCH1A
>; IFN EXTEND

SUBTTL	INITIALIZE

;HERE IS THE INITIALIZE CODE

STPT:	RESET
	SETZM	RPGSW
	SETZM	ZEROB
	MOVE	T1,[XWD ZEROB,ZEROB+1]
	BLT	T1,IMPEND-1
	MOVE	T1,[BYTE (7) 15,15,15,15,15]
	MOVEM	T1,CRSX		;PUT CR'S IN PLACE
	MOVE	P,[IOWD PDLSIZ,PDL]
	MOVSI	FL,QMODF	;SET FOR ' IS NOT SPECIAL
	MOVEI	FL2,0		;NOTHING IN SECOND FLAG REGISTER
IFE STANSW, <
	SETOM	BAKF		;SET FOR BAK FILE
>; IFE STANSW
IFN STANSW, <
	SETZM	BAKF		; SET FOR NOBAK FILE
>; IFN STANSW
	MOVEI	T1,TTYCH	;SET UP DEFAULT INPUT
	MOVEM	T1,CHIN		;...
	MOVE	T1,[POINT 7,CMDBUF] ;POINT TO COMMAND BUFFER
	MOVEM	T1,P.TEXT	;STORE POINTER FOR READING
	MOVEI	T1,0		;DO RE-READ OF COMMAND
	RSCAN			;...
	  FJERR
	MOVEI	T1,.PRIIN	;USE PRIMARY INPUT
	HRROI	T2,CMDBUF	;WHERE TO PUT IT
	MOVEI	T3,5*^D20-1	;SIZE OF BUFFER
	MOVEI	T4,12		;TERMINATOR
	SIN			;SLURPP!
	MOVEI	T3,12		;GRNTEE PROPER TERMINATOR
	IDPB	T3,T2		;...
	SETOM	RPGSW		;SAY WE HAVE INPUT
	MOVEI	T1,.PRIOU	;CHECK TERMINAL MODE
	RFMOD			;GET MODES
	MOVEM T2,MODW		;SAVE MODE WORD
	RFCOC
	MOVEM T2,COCW1		;SAVE COC WORDS
	MOVEM T3,COCW2		;...
	MOVEI T1,.FHSLF		;SET TO DISABLE COMPAT
	MOVNI T2,1		;BY SETTING EV TO -1
	MOVEI T3,0
	SCVEC			;...
RPGRET:
IFN STATSW, <
	CALL	ST.OPN >	;OPEN STATISTICS FILE AND MAP IT
	MOVE	T1,[CALL ERRHD0] ;SET UP LUUO HANDLER
	MOVEM T1,.JB41##
	CALL	INIPSI		;INIT PSI STUFF
	SETZM	TTICNT		;EMPTY INPUT
	MOVE	T1,[POINT 7,TTOBUF]
	MOVEM	T1,TTOPNT	;SET UP TTY OUTPUT BUFFER
	MOVEI	T1,^D80
	MOVEM	T1,TTOCNT


NOCOM0:	TLNN	FL2,AUTOF
	MOVE	P,[IOWD PDLSIZ,PDL]
	TRNE	FL2,SVIT	;SKIP * IF DOING W COMMAND
	JRST	RPGR1
	TLZ	FL2,INPARS!BELLF ;SAY WE ARE STARTING
IFN STANSW, <
	MOVEI	T1,1		;INITIALIZE PARAMETERS FOR JUSTIFY 
	MOVEM	T1,LMAR
	MOVEM	T1,PMAR
	MOVEI	T1,105
	MOVEM	T1,RMAR
	MOVE	T1,[<ASCIZ/99999/>!1]
	MOVEM	T1,MAXLN
>; IFN STANSW
	SETZM	OPTION		;LOOK FOR DEFAULT
	PUSHJ	P,DOOPT
	  JRST	.+2		;IGNORE NOT FOUND RETURN
	JRST	[OUTSTR	[ASCIZ "? Syntax error in default options"]
		 SETZM RPGSW	;CLR CMD MODE
		 CALL CLRBFI
		 JRST .+1]
NOCOM1:	TLO	FL2,INPARS	;SET FOR PARSE
	PUSHJ	P,PARSE
RPGR1:	TLZ	FL2,INPARS	;PARSE DONE
	MOVE	T1,[ORGBLK,,ICRBLK]
	BLT	T1,ICRBKE	;MOVE INFO TO INPUT BLOCK
	HRROI	T1,[ASCIZ "EDIT-BUFFER.OUT"]
	HRROI	T2,OCRASZ	;OUTPUT BLOCK
	CALL	MAKTMP		;MAKE TEMP FILE SPEC
	HRROI	T1,OCRASZ	;SETUP PNTR
	MOVEM	T1,OCRFIL	;TO FILESPEC
IFN CRYPSW, <
	MOVE T1,ORGCOD		;GET ORIG FILE PSW
	TRNE FL,NEWFL		;DO WE HAVE A NEW FILE?
	MOVE T1,NEWCOD		;YES - USE IT INSTEAD
	MOVEM T1,OCRCOD		;NO - USE ORIG PSW
>; IFN CRYPSW
	SKIPE	T1,CREATF	;WAS FILE FOUND?
	JRST	NOFILE		;NO - TRY CREATE
	MOVEI	T1,IBUF0	;SET UP BUFFER ADDRS
	MOVEM	T1,CIPBUF	;...
	MOVE	T1,ICRJFN	;GET INPUT JFN
	MOVEM	T1,CIPJFN	;SAVE FOR INPUT ROUTINES
	DVCHR			;GET DEVICE CHARACTERISTICS
	LDB	T2,[POINT 9,T2,17]
	CAIE	T2,.DVDSK	;BETTER BE DISK
	JRST	NOTDKI		;NOPE
	MOVE	T1,ICRJFN	;RESTORE JFN
	MOVE	T2,[7B5+OF%RD]	;OPEN FOR READ
	OPENF			;OPEN FILE
	  FJERR			;FATAL JSYS ERROR
	MOVEI	ALTP,CIPB	;BASE PNTR
	CALL	GFSIZE		;GET FILE SIZE IN WORDS
	SETOM	CIPCNT		;INIT PAGE CNTR
	SETZM	CIPPNT		;CLEAR BUFFER
	SETZM	CIPBYT		;...
FILRET:	TRNE	FL,READOF	;READ-ONLY?
	JRST	FILRT1		;YES - SKIP THIS
	MOVSI	T1,(GJ%FOU!GJ%SHT!GJ%TMP)
	MOVE	T2,OCRFIL	;PNTR TO FILESPEC
	PUSHJ	P,GTJFNX	;TRY TO GET A JFN
	 JRST	[CALL CANTOP	;CANT OPEN TEMP FILE
		 CALL CJERR0	; GIVE SYSTEM MESSAGE
		 JRST LOSER]	;T/S
	MOVEM	T1,OCRJFN	;SAVE JFN
	DVCHR			;CHECK ON DISK
	LDB	T1,[POINT 9,T2,17]
	CAIE	T1,.DVDSK
	JRST	NOTDKO		;ULOSE
FILRT1:	MOVEI	T1,BUF0		;START OF EDIT BUFFER
	SETZM	0(T1)		;SAVE A ZERO WORD
	ADDI	T1,1		;NEXT ONE IS START OF
	MOVEM	T1,BUFP		;  BUFFERS


MOCO:	SKIPN	T1,NPAGS	;FIND END OF EDIT WINDOW
	MOVEI	T1,DEFPAG	;USE DEFAULT IF NONE GIVEN
	MOVEM	T1,NPAGS	;...
	LSH	T1,^D9		;SIZE IN WORDS
	ADDI	T1,BUF0-1	;LAST LOC
	PUSH	P,T1		;SAVE AWHILE
	SUBI	T1,2*MXWPL+4	;LEAVE SPACE FOR A COUPLE OF LINES+ 1 PM
	MOVEM	T1,FILPT	;THIS IS HOW FAR TO FILL THE BUFFER
	POP	P,T1		;GET TOP BACK
	SUB	T1,BUFP
	MOVE	T2,T1		;GET A COPY
	SUBI	T2,MXWPL+1	;WHEN TO START DUMPING
	MOVEM	T2,MAXWC
	ASH	T1,-1		;TAKE HALF OF IT
	MOVEM	T1,HLFWC	;SAVE THAT FIGURE
	TRNE	FL2,SVIT
	JRST	NOSV1		;SKIP SOME MORE STUFF IF IN W COMMAND
	MOVEI	T1,.PRIOU	;CHECK TERMINAL MODE
	RFMOD			;GET MODES
	TLNE	T2,(TT%LCA)	;DO WE HAVE LC?
	TRO	FL,M37F		;LC SET SO SAY HE'S M37
	TRO	T2,<.TTATE>B29	;SET NO OUTPUT XLATE
	MOVEM T2,MODW		;SAVE MODE WORD
	SFMOD			;...
	RFCOC
IFN STANSW, <
	TLZ	T2,(3B17)	;SET BACKSPACE TO ON
	TLO	T2,(2B17)
>; IFN STANSW
	TRZ T3,3B19		;FIX ESC PROPERLY
	MOVEM T2,COCW1		;SAVE COC WORDS
	MOVEM T3,COCW2		;...
	SFCOC			;...
	TRO FL2,ALTECH		;TURN ON ESC ECHO
	MOVEI T1,.CTTRM		;CONTROLLING TERMINAL
	GTTYP			;GET TYPE
	CAILE T2,MXTRM		;MAX TYPE
	MOVEI T2,DFTRM		;SUPPLY DEFAULT
	MOVEM	T2,DTYPE	;SAVE IT
	MOVE	T1,[<ASCII /00000/>!1]
	MOVEM	T1,CLN		;SET UP THE CURRENT LINE
	SKIPN	T1,TECINC	;USE STEP IF GIVEN
	MOVE	T1,[<ASCII /00100/>!1] ;AND CURRENT INCREMENT
	MOVEM	T1,INCR
	MOVEM	T1,CURINS	;CURRENT PLACE TO INSERT IF NO ARGS TO I
NOSV1:	MOVEI	T1,1		;AND THE CURRENT PAGE
	MOVEM	T1,CPG
	TRNE	FL2,SVIT	;DO NOT CHANGE LOGICAL PAGE (.)
	JRST	NOSV1A
	MOVEM	T1,CPGL
	MOVEM	T1,IPG		;CURRENT PAGE TO INSERT ON
NOSV1A:	MOVE	PNTR,BUFP	;SET THE BUFFER POINTER
	MOVEI	T1,1		;SET INPUT PAGE
	MOVEM	T1,INPG
	SETZM	SVWD		;O WORDS WAITING
	SETZM	WC		;ZERO WORD COUNT FOR START
	SETZM	OLDLIN		;UESD FOR ORDER CHECKING ON INPUT
	TLNN	FL2,AUTOF	;PRESERVE IF IN AUTO SAVE
	SETZM	ALTSN		;USED FOR ALTMODE SEEN FOR I AND R
	SETZM	AUXFLG		;USED TO FLAG AUXILLARY FILE IN USE
	TRNE	FL2,SVIT	;SAVE WORLD?
	JRST	NOSV2	
	SETZM	SRPNT		;NO SEARCH STRING YET
	SETZM	R1PNT		;ALSO REPLACE STRINGS
	SETZM	R2PNT
	MOVSI	T1,1		;SET BIG PAGE LARGE FOR NOW
	MOVEM	T1,BGPG
	TRNE	FL,READOF	;DONT BOTHER IF READ-ONLY
	JRST	NOSV2
	HRROI T2,LIBUF		;BUILD SPEC HERE
	HRROI T1,[ASCIZ "EDIT-BUFFER.IN"]
	CALL MAKTMP
	MOVSI	T1,(GJ%OLD!GJ%SHT!GJ%TMP)
	HRROI T2,LIBUF		;FILESPEC
	PUSHJ	P,GTJFNX	;EXISTS?
	  JRST	NOSV2		;DON'T CARE
	HRLI	T1,(DF%EXP)	;EXPUNGE ALSO
	DELF			;DELETE FILE
	  FJERR			;LOSE IF CAN'T DELETE
NOSV2:	TLO	FL2,BELLF	;ALLOW BELLS
	PUSHJ	P,ENBINT	;ENABLE ^C INTS
	SKIPE	CREATF		;CHECK IF WE ARE CREATING
	  JRST	CRTOK
	TRNE	FL2,SVIT	;WRAP ON SAVE CMD(W)
	JRST	NOSV3		;YES: DON'T PRINT MSG AGAIN!
	MOVEI	T1,[ASCIZ /Edit: /]
	TRNE	FL,READOF	;CHECK FOR R/O
	MOVEI	T1,[ASCIZ /Read: /]
	OUTSTR	@T1		;PRINT MSG
	OUTSTR	ORGASZ		;GIVE FILE NAME
	OCRLF
NOSV3:	TRNE	FL,READOF
	JRST	NOENT		;DO NOT ENTER
	MOVE	T1,OCRJFN	;GET OUTPUT JFN
	MOVEI	T2,OF%WR	;WRITE MODE
	MOVEM	T1,OPNJFN	;SAVE
	OPENF			;OPEN FILE
	 CALL	[CALL CANTOP
		 JRST OPNERR]	;HANDLE IF OVER QUOTA
	SETZM	OPG		;OUTPUT PAGE CNTR
	SETZM	OUPNT		;CLEAR PNTR
	MOVNI	T1,2
	MOVEM	T1,OPCNT	;OUTPUT PAGE COUNT
NOENT:	TRO	FL,BOF		;IS AT START OF FILE
	TLO	FL,FSTOPF	;FIRST OP
	TLZ	FL2,ALLCHG	;NO CHANGES YET
	PUSHJ	P,FILLBF	;AND FILL UP THE BUFFER
	TLZN	FL2,AUTOF	;SKIP IF AUTO SAVE
	JRST	COMND
	TRZ	FL2,SVIT	;CLR THIS TOO
	MOVE	SINDEX,SVLNUM	;GET BACK TO POINT OF LAST INSERT
	TLZ	FL2,NORENT	;RE-ENABLE FOR REENTER
	JRST	FIND		;EXITS TO CALLER

;ROUTINE TO PARSE A FILE NAME.
;ALTP/ FILE BLOCK
;T1/ GTJFN BITS
;C/ LAST CHARACTER READ. IF ESCAPE, THEN DO RECOGNITION.
;RETURNS:
;.+1 - ERROR FROM GTJFN, MESSAGE PRINTED.
;.+2 - CONTROL-U TYPED BY USER
;.+3 - SUCCESS, FILE BLOCK FILLED.
;	C HAS TERMINATING CHAR

READNM:	MOVEI	T2,0		;NO DEFAULT
READNE:	MOVEM	T2,CJFNBK+.GJEXT
	TRZ	FL2,ALTECH	;TURN OFF ALT ECHO
IFE STANSW, <
	CAIN	C,200		;ESC SEEN?
	OUTSTR	[ASCIZ " (FILE) "]
>; IFE STANSW
IFN STANSW, <
	TLZ	T1,(GJ%MSG)	;NEVER PRINT MESSAGE.  NEVER.  -- OO7
>; IFN STANSW
	TLO	T1,(GJ%FNS!GJ%XTN!GJ%FLG) ;(206) TEST FOR TEMP FILE
	TLNE	FL2,INPARS	;READING FROM CORE?
	TLZ	T1,(GJ%CFM)	;YES, DON'T WANT CONFIRMATION THEN
	MOVEM	T1,CJFNBK	;STORE FLAGS
	MOVS	T1,OPTJFN	;ASSUME READING FROM OPTION FILE
	HRRI	T1,.NULIO	;AND OUTPUT GOING NOWHERE
	TLNN	FL2,INOPTF	;REALLY DOING OPTION FILE?
	MOVE	T1,[.PRIIN,,.PRIOU]	;NO, GET NORMAL JFNS
	TLNE	FL2,INPARS	;READING FROM CORE?
	MOVE	T1,[.NULIO,,.NULIO]	;YES, THEN ONLY USE STRING
	MOVEM	T1,CJFNBK+.GJSRC	;SAVE IN BLOCK
IFN STANSW, <
	SKIPN ESCFLG		; ON NO ESC IGNORE CRBUF STUFF --OO7
	 JRST RDFIGN
	SETZ	C,0		;TRUNCATE CRBUF WITH THIS NULL
	MOVE	T1,[POINT 7,CRBUF,6]	;FIND =, @ OR $
RDFIND:	ILDB	T2,T1		;GET A CHAR
	JUMPE T2,RDFIGN
	CAIE	T2,"="		;EQUALS?
	CAIN	T2,"@"		;INDIRECT?
	 JRST	RDFEND		;YES, GOT IT
	CAIE	T2,"$"		;DOLLAR?
	 JRST	RDFIND		;LOOP IF NOT DOLLAR
	MOVE	T2,[POINT 7,[ASCIZ " (FILE) "]]	;FAKE NOISE IF DOLLAR
	OUTSTR	(T2)
	ILDB	C,T2		;COPY STRING
RDFEND:	IDPB	C,T1
	JUMPN	C,.-2
RDFIGN:
>; IFN STANSW
	TLNE	FL2,INPARS	;READING FROM CORE?
	SKIPA	T2,P.TEXT	;YES, GET STRING FROM COMMAND LINE
	MOVE	T2,TTIPNT	;NO, GET NORMAL INPUT PNTR
	TLNE	FL2,INOPTF	;READING FROM OPTION FILE?
	SETZ	T2,		;YES, NO STRING FROM CORE THEN
READN1:	PUSH	P,FIL(ALTP)	;SAVE IN CASE OF ERROR
	PUSH	P,JFN(ALTP)	;...
IFN STANSW, <
	TLNN	FL2,INOPTF!INPARS	;IF NOT IN OPTION FILE OR PARSE
	 CALL	RDNSKP		;SKIP BLANKS  -- OO7
	MOVEI	T1,CJFNBK	;POINT TO BLOCK
	GTJFN			;GTJFNX RETRIES AND ASSUMES SHORT FORM
>; IFN STANSW
IFE STANSW, <
	MOVEI	T1,CJFNBK	;POINT TO BLOCK
	PUSHJ	P,GTJFNX
>; IFE STANSW
	  JRST	RDNERR		;ANALYSE ERROR RETURN
	TLNE T1,(GJ%TFS)	;(206) TEST FOR TEMP FILE
	 JRST [	TLZ FL2,INPARS	;(206)
		OUTSTR [ASCIZ "
? Illegal to write a temporary file"] ;(206)
		JRST RDNER1]	;(206)
IFN STANSW, <
	ADJSP	P,-2		;CLEAN UP
	HRRZM	T1,JFN(ALTP)	;STASH JFN
>; IFN STANSW
IFE STANSW, <
	SUB	P,[2,,2]	;CLEAN UP (NO LONGER NEEDED)
	MOVEM	T1,JFN(ALTP)
>; IFE STANSW
	PUSH	P,T2		;SAVE PNTR
	HRRZS	T1		;(206) CLEAR FLAGS
	CALL	JFNSTR		;CONVERT TO PROPER STRING
	AOS	-1(P)		;SET FOR SKIP RETURN
	AOS	-1(P)		;DOUBLE SKIP
	TLNE	FL2,INPARS	;READING COMMAND LINE?
	JRST	[POP	P,P.TEXT	;YES, RESTORE NEW POINTER
		 POPJ	P,]	;AND RETURN
	TLNE	FL2,INOPTF	;READING OPTION FILE?
	JRST	[POP	P,(P)	;YES, TRIM STACK
		 POPJ	P,]	;AND RETURN
IFN STANSW, <
	SKIPN ESCFLG		; ON NO ESC IGNORE CRBUF STUFF -OO7
	 JRST RN1IGN
	MOVE	T1,[POINT 7,CRBUF,6]	;FIND END OF CRBUF
	ILDB	C,T1
	JUMPN	C,.-1
	ADD	T1,[7B5]	;BACK UP ONE
	MOVE	T2,[POINT 7,ASZ(ALTP)]	;COPY FILENAME
	ILDB	C,T2
	IDPB	C,T1
	JUMPN	C,.-2
RN1IGN:
>; IFN STANSW
	MOVE	T1,0(P)		;GET NEW BYTE PNTR
	MOVE	T2,TTIPNT	;GET OLD BYTE PNTR
	CALL	SUBBP		;GET SIZE
	EXCH	T1,TTICNT	;CALC NEW REMAINDER
	SUBM	T1,TTICNT	;...
	POP	P,T2		;GET NEW PNTR AGAIN
	LDB	T1,T2		;GET TERMINATING CHAR
	CAME	T1,ESC		;CHECK FOR ESC
	CAIN	T1,0		;  OR NULL
	JRST	RDNSCN		;DO BKJFN ON TERMINAL
	AOS	TTICNT		;ELSE BACKUP INPUT
	ADD	T2,[7B5]
	MOVEM	T2,TTIPNT	;STORE PNTR
	PJRST	SCAN		;AND RETURN THRU SCAN

RDNSCN:	SETZM	TTICNT		;CLEAR INPUT
	HLRZ	T1,CJFNBK+1	;JFN TO BACKUP
	BKJFN			;STEP TO REAR
	  FJERR			;GIANT LOSAGE
	PJRST	SCAN		;EXIT THROUGH SCAN

IFN STANSW, <
RDNSKP:	PUSHJ	P,@CHIN		;SKIP BLANKS  --OO7
	CAIE	C," "
	CAIN	C,"	"	;SPACE OR TAB
	 JRST	RDNSKP
	AOS	TTICNT		;BUFFER ONE CHARACTER FULLER
	MOVSI	T2,(7B5)	;BACK UP ONE, PUTTING TTIPNT INTO T2
	ADDB	T2,TTIPNT
	RET			;SKIPPING DONE
>; IFN STANSW

;HERE ON GTJFN ERROR RETURN - CHECK ^U

RDNERR:	POP	P,JFN(ALTP)	;RESTORE OLD VALUES
	POP	P,FIL(ALTP)	;...
	CAIN	T1,GJFX37	;BUFFER EMPTY RETURN
	JRST	RDNCTU		;YES - CHECK ^U
	PUSH	P,T1		;SAVE CODE
	CALL	RDNSCN		;GET DELIM INTO C
	OUTSTR	[ASCIZ "
?"]
	MOVEI	T1,.PRIOU	;PLACE FOR MESSAGE
	MOVEI	T3,0
	POP	P,T2		;RESTORE ERROR
	HRLI	T2,.FHSLF
	ERSTR			;PRINT MESSAGE
	  JFCL			;CANT HAPPEN
	  JFCL
	OCRLF
	RET			;EXIT

RDNER1:	POP	P,JFN(ALTP)	;(206) RESTORE OLD VALUES
	POP	P,FIL(ALTP)	;(206) ...
IFE STANSW, <			;REALLY DON'T NEED THIS JUNK  -- OO7
	CAIN	T1,GJFX37	;(206) BUFFER EMPTY RETURN
	 JRST	RDNCTU		;(206) YES - CHECK ^U
	OCRLF			;(206) OUTPUT A CRLF
>; IFE STANSW
	RET			;(206) RETURN

;HERE ON BUFFER EMPTY RETURN

RDNCTU:
IFN STANSW, <
	SETZM	TTICNT		;INPUT DELETED  -- OO7
>; IFN STANSW
	HLRZ	T1,CJFNBK+1	;INPUT JFN
	RFPOS			;GET POSITION
	TRNN	T2,-1		;AT LM?
	RETSKP			;YES - GIVE ^U RETURN
	OUTCHR	[7]		;NO - RING BELL
IFE STANSW, <
	MOVEI	T2,0		;BACK TO JFNS ONLY
>; IFE STANSW
	JRST	READN1		;TRY AGAIN

;ROUTINE TO COMPUTE THE DIFFERENCE OF TWO BYTE PNTRS IN CHARS
;C(T1) := ORIG PNTR
;C(T2) := NEW PNTR

SUBBP:	HRRZ	T3,T1
	SUBI	T3,(T2)		;DIFF IN WORDS
	IMULI	T3,5		;CHARS
	LDB	T1,[POINT 6,T1,5] ;GET RESIDUES
	LDB	T2,[POINT 6,T2,5]
	SUBM	T2,T1		;RESULT TO T1
	IDIVI	T1,7		;# OF CHARS
	ADD	T1,T3		;COMBINE RESULT
	RET			;DONE # CHARS IN T1

;ROUTINE TO CALL AFTER READNM (OR WHATEVER) TO PARSE /R/S SWITCHES
;AFTER FILENAME.
;ENTER:
; C/ CHARACTER IMMEDIATELY AFTER
;RETURNS:
; .+1 IF NEITHER /R OR /S
; .+2 IF A SWITCH SEEN, RSW OR SSW -1 AS APPROPRIATE

READSW:	SETZM	RSW		;CLEAR OLD SWITCH FLAGS
	SETZM	SSW
	TLNN	FL2,INOPTF	;NO SWITCHES IN OPTION FILE
	CAIE	C,"/"		;CHECK FOR READ ONLY MODE
	JRST	CPOPJ1		;ALL OK
	PUSHJ	P,SCAN
	TRNN	FL,IDF
	POPJ	P,
	MOVS	T1,ACCUM
	CAIN	T1,'R  '
	SETOM	RSW
	CAIN	T1,'S  '
	SETOM	SSW
	PUSHJ	P,SCAN
	SKIPN	RSW
	SKIPE	SSW
	AOS	(P)
	POPJ	P,

;CREATE A NEW FILE

NOFILE:	JUMPL	T1,NOFIL1	;IF NEG THEN OK
	CALL	CHKCOD		;CHECK ERROR CODE
	  FJERR			;REAL LOSAGE
NOFIL1:	OUTSTR	[ASCIZ /Input: /]
	OUTSTR	ORGASZ		;PRINT FILE NAME
	SETOM	CREATF		;SAY WE ARE CREATING
	SETZM	ICRJFN		;CLEAR INPUT BLOCK
	SETZM	ICRFIL
	JRST	FILRET		;GO OPEN IT

CRTOK:	MOVE	T1,OCRJFN	;OUTPUT JFN
	MOVEI	T2,OF%WR	;WRITE PRIVS
	MOVEM	T1,OPNJFN
	OPENF			;OPEN FILE
	  CALL	OPNERR		;CHECK FAILURE
	SETZM	OPG		;OUTPUT PAGE CNTR
	SETZM	OUPNT		;CLEAR BUFFER
	MOVNI	T1,2
	MOVEM	T1,OPCNT	;INIT PAGE COUNT
	SETZM	(PNTR)		;ZERO FIRST WORD OF BUFFER
	TRZ	FL,READOF	;CREAT AND READOF ARE NOT POSSIBLE
	TRO	FL,BOF!EOF!EOF2	;SAY AT START AND NO MORE TO READ
	TLO	FL2,ALLCHG	;NEW FILE - THEREFORE CHANGES
	MOVEI	T1,1		;SET BGPG
	MOVEM	T1,BGPG
	JRST	CRTINS		;AT LAST


SUBTTL	PARSE CODE

;LOOK FOR SYSTEM COMMAND.

PARSE:	PUSHJ	P,ZERNEW	;CLR OUT FILE BLOCK
	MOVEI	T1,LDCHR	;SET UP CHIN FOR PARSE
	EXCH	T1,CHIN		;SAVE OLD VALUE
	MOVEM	T1,SVPCIN	;...
	SETZM	CREATF		;NO CREATE
	SETZM	PZBEG		;CLEAR PARSE AREA
	MOVE	T1,[PZBEG,,PZBEG+1]
	BLT	T1,PZEND
	MOVE	T1,P.TEXT	;CHECK FOR PROPER EOL
PARS1:	ILDB	T2,T1		;GET CHAR
	CAIE	T2,15
	CAIN	T2,12		;LOOK FOR TERMINATOR
	SKIPA	T2,[12]		;REPLACE WITH LF
	JRST	PARS1		;LOOP TILL DONE
	DPB	T2,T1		;GRNTEE CORRECT CHAR

; Rules for obtaining a file specification:
;	1.  Try to get it from the rescanned command line.
;	2.  If there is none in the command, try to get it from
;	    TMPCOR:EDS. 
;	3.  If there is none in TMPCOR:EDS, give him an error.

PARSEA:	SKIPN RPGSW		;Anything in TMPCOR?
	JRST NOTMP		;No give him an error
PARSAA:	PUSHJ P,RDSKIP		;Get first nonspace chr in C
	ANDI C,137		;FOrce uppercase

; Check the CREATE or EDIT command...
; If: 	There is a "/" in the command, or
;	The character after noise words and spacing is not <LF>
; DO not read the EDS file.

PARSEB:	CAIN C,12		;Is this character a <LF>?
	JRST NOIF		;Yes, use the EDS
	CAIN C,"/"		;Did we see a "/"?
	JRST PARSEI		;Yes, do not use EDS
	CAIE C," "		;If it is a space
	CAIN C,"	"	;or tab
	JRST PARSEC		;next non-spacing better be <LF>
	PUSHJ P,@CHIN		;Get the next character
	JRST PARSEB		;Keep checking

PARSEC:	PUSHJ P,RDSKIP		;Get next non-spacing in C
	PUSHJ P,SKPNOI		;Skip noise, too
	CAIE C,12		;If it:
	JRST PARSEI		;Is not a <LF>, use this line
	JRST NOIF		;Is a <LF>, use the line in EDS

PARSEI:	MOVE T1,[POINT 7,CMDBUF]	;Pointer to command
	MOVEM T1,P.TEXT		;FALL INTO PARSE1...

; 1    2         3      4             5           6
; EDIT /SWITCHES (FROM) INPUT.TYP.GEN (OUTPUT AS) OUTPUT.TYP.GEN [MESSAGE]
; OR   CREATE /SWITCHES (FROM) INPUT.TYP.GEN [MESSAGE]

PARSE1:	TRZ FL,F.LAHD		;SET THE LOOK AHEAD BIT
	PUSHJ P,RDSKIP		;Skip spacing, break chr in C

; Set GTJFN bit according to: C (new), E (existing), S (either)

	SETZ T1,		;Will contain GTJFN flags
	ANDI C,137		;ENSURE UPPER CASE
	CAIN C,"E"		;Is this EDIT?
	MOVSI T1,(GJ%OLD)	;Yes, get an existing file
	CAIN C,"C"		;OR CREATE?
	JRST	[
IFN STANSW, <	  MOVSI T1,(GJ%NEW)
>; IFN STANSW
IFE STANSW, <	  MOVSI T1,(GJ%FOU)	;FILE FOR OUTPUT
>; IFE STANSW
		  SETOM CREATF	;SAY WE ARE CREATING
		  JRST .+1 ]
	CAIE C,"S"		;ALLOW SOS CMD TO DO EITHER
	JUMPE T1,BADTMP		;No bad command
	MOVEM T1,GJBITS		;SAVE FOR GTJFN TO FIND
	MOVEI C,"S"		;Change to S command to make
	DPB C,P.TEXT		;  TMPCOR FILE work

; GET FIRST NON-SPACING CHARACTER AFTER COMMAND NAME

PARS1A:	PUSHJ P,@CHIN		;Get a character
	CAIN C,12		;Or a <LF>?
	JRST BADTMP		;yes there is no file spec
	CAIN C,"/"		;Is it a slash?
	JRST PARS2A		;yes, go process it
	CAIE C," "		;Is it a space?
	CAIN C,"	"	;Or a tab?
	JRST PARSE2		;Yes, get next field
	JRST PARS1A		;No continue

; GOT FIRST CHR. OF 2ND ATOM.

PARSE2:	PUSHJ	P,RDSKIP	;Skip spacing, break chr in C
	CAIN	C,12		;Or a <LF>?
	JRST	BADTMP		;Yes there is no file spec
	CAIN	C,"/"		;IS IT A SWITCH?
PARS2A:	PUSHJ	P,GETSWT	;YES, GET THEM
	PUSHJ	P,SKPNOI	;SKIP SPACES & NOISE
	CAIN	C,"/"		;SWITCH AFTER NOISE VALID
	JRST	PARS2A		;PROCESS
	CAIN	C,12		;Find a <LF>?
	JRST	NOIF		;NO INPUT FILE SPEC.
PARSE4:	MOVEI	ALTP,ORGBLK	;POINT TO DESIRED BLOCK
	MOVE	T1,GJBITS	;GET SAVED BITS
	TLO	T1,(GJ%SHT)	;USE SHORT FORM
	CALL	TRYGTJ		;TRY GTJFN
	  JRST	PARBI		;BAD INPUT FILE SPEC
PRS4A:	PUSHJ P,RDSKIP		;Skip spaces, break chr in C
PARSE5:	PUSHJ P,SKPNOI		;SKIP SPACES & NOISE
	CAIN C,12		;Or <LF>?
	JRST PARSED
	CAIN C,"/"		;Or switch?
	JRST BADSW		;BAD SWITCH PLACEMENT
PARSE6:	MOVEI	ALTP,NEWBLK	;POINT TO NEW BLOCK
	MOVSI	T1,(GJ%FOU!GJ%MSG!GJ%CFM!GJ%SHT)
	CALL	TRYGTJ		;TRY GTJFN
	  JRST	PARBO		;Bad output file
	CALL TSTNEW		;SEE IF THIS IS A "NEW" FILE
PARSED:	SKIPN	NEWFIL		;NEED NEW?
	CALL	DEFNEW		;ASSURE OUTPUT FILE
	JRST	RDEOTX		;FINISH

; SKPNOI - SKIPS SPACES AND NOISE WORDS THEN SPACES

IFN STANSW, <
SKPNO2:	CALL RDSKIP		;RECYCLE SOME CODE HERE.  --OO7
>; IFN STANSW
SKPNOI:	CAIE C,"("
	CAIN C,"["
	JRST SKPNO1
	CAIN C,"!"
	JRST SKPNO1
	RET			;JUST RETURN

SKPNO1:	TRZ FL,F.LAHD		;DON'T REREAD THE CHAR
	PUSHJ P,@CHIN
	CAIN C,12			;CHECK FOR TRICKY <LF>
	RET				;HAH!!!
	CAIE C,")"
	CAIN C,"]"			;OTHER BRACKET
	JRST SKPNO2
	CAIN C,"!"
	JRST SKPNO2
	JRST SKPNO1

IFE STANSW, <
SKPNO2:	CALL RDSKIP		;SKIP SPACES
	CAIE C,"("		;MAKE SURE NOT ANOTHER
	CAIN C,"["
	JRST SKPNO1		;ANOTHER KEEP GOING
	CAIN C,"!"
	JRST SKPNO1
	RET			;NO - RETURN
>; IFE STANSW

;DIDN'T GET A FILE SPECIFICATION

IFE STANSW, <

; Didn't get a file specification, give error and die

PARBI:	SKIPN	CREATF		;TROUBLE IF FAILURE
	PUSHJ P,CHKCOD		;File-not-found-type error?
	 JRST PARBO		;No, Run of the mill error
	TRNE	FL,READOF	;READ-ONLY?
	JRST	PARBO		;YES - LOSAGE THEN
	MOVEM	T1,CREATF	;SAVE ERROR CODE AS FLAG
	OUTSTR	[ASCIZ "
%"]
	CALL	CJERRC		;PRINT MESSAGE
	HRROI T1,[ASCIZ /, Creating New file
/]
	PSOUT
	MOVSI	T1,(GJ%FOU)	;FOR IGNORE DELETED BIT
	MOVEM	T1,GJBITS	;TRY ANY FILE
	JRST	PARSE4		;...
>; IFE STANSW


IFN STANSW, <

; DIDN'T GET A FILE SPEC.  TRY A DIFFERENT EXT, OR GIVE ERROR AND DIE

PARBI:	MOVE T4,T2		;SAVE T2 BECAUSE CHKCOD CLOBBERS IT
	SKIPN	CREATF		;TROUBLE IF FAILURE
	PUSHJ P,CHKCOD		;FILE-NOT-FOUND-TYPE ERROR?
	 JRST PARBO		;NO, RUN OF THE MILL ERROR
	MOVE T5,T1		;SAVE ERROR CODE
	MOVE T2,T4		;RESTORE T2
	MOVE T1,P.TEXT
	ADD T1,[7B5]		;BP TO OLD FILENAME STRING
	MOVEI T3,ASZ(ALTP)	;TEMP BUFFER
;FIND CLOSEST MATCH IF NO FILESPEC
	CALL RGTJFN
	JRST PARBI1
	MOVE T1,T2
	MOVE T2,T4		;GET BACK END PTR
	CALL TRYGT1
	JFCL
	JRST PRS4A

PARBI1:	MOVE T1,T5		;GET BACK ERROR CODE
	TRNE	FL,READOF	;READ-ONLY?
	JRST	PARBO		; YES--GIVE UP.
	MOVEM	T1,CREATF	;SAVE ERROR CODE AS FLAG
	OUTSTR	[ASCIZ "
File not found:  "]
	CALL	PARPF		;PRINT STRING WE'VE BEEN TRYING TO MATCH
	OUTSTR	[ASCIZ "  Use the CREATE command to create a new file.
"]
	JRST	LOSER		;GIVE UP.

;RGTJFN SUBROUTINE.  FIND A REASONABLE JFN GIVEN PARTIAL SPEC.

;CLOBBERS T1,T2,T3, LIBUF
;CALL WITH
;T1 POINTING TO THE FILENAME STRING
;T3 POINTING TO A BUFFER FOR JFNS
;SKIPS IF A REASONABLE ALTERNATIVE WAS FOUND
; JFN OF ALTERNATIVE WILL THEN BE IN T2

RGTJFN:	PUSH P,T4		;SAVE T4
	PUSH P,T3		;SAVE T3 (ADDRESS OF TEMP BUFFER)
	MOVE T2,T1		;T2/ POINTER TO FILE SPEC
	MOVSI T1,(GJ%SHT!GJ%OFG) ;T1/ SHORT FORM, DON'T CHECK EXISTENCE
	GTJFN			;GET A HANDLE ON THE FILE
	 ERJMP .RET		;SOME ERROR, DECLARE A BAD FILE SPEC
	HRRZ T2,T1		;T2/ JFN OF FILE SPEC
	HRRO T1,(P)		;T1/ POINTER TO BUFFER FOR FILE STRING
	MOVSI T3,(1B11)		;T3/ TYPE FIELD ONLY
	SETZB T4,@(P)		;CLEAR BUFFER AND ANY FLAGS IN T4
	JFNS			;WRITE A FILE SPEC STRING
	 ERJMP .RET		;SOME ERROR
	SKIPE @(P)		;SKIP IF NULL EXTENSION
	 JRST [ MOVE T1,T2	;T1/ FILE JFN
		RLJFN		;RELEASE THE JFN; WE CAN'T SECOND GUESS
		 JFCL		; WHAT THE USER TYPED
		JRST .RET ]	;GO TO THE BAD RETURN
	HRRO T1,(P)		;T1/ POINTER TO START OF BUFFER
	MOVE T3,[1B2+1B5+1B8+JS%PAF] ;T3/ PRINT DEVICE, DIR, AND NAME ONLY
	JFNS			;WRITE THE FILE SPEC
	 ERJMP .RET		;SOME ERROR
	MOVEI T3,"."
	IDPB T3,T1
	MOVEI T3,"*"
	IDPB T3,T1
	MOVEI T3,0
	IDPB T3,T1
	MOVE T1,T2		;T1/ JFN OF FILE SPEC
	RLJFN			;RELEASE THE JFN, WE DON'T NEED IT ANY MORE
	 ERJMP .RET		;SOME ERROR
	MOVSI T1,(GJ%IFG!GJ%SHT!GJ%OLD)	;T1/ SHORT FORM, WILDCARDS, OLD FILE
	HRRO T2,(P)		;T2/ POINTER TO BUFFER
	GTJFN			;GET A HANDLE ON THAT FILE
	 ERJMP .RET		;DON'T SEEM TO BE ANY MATCHES
	SETZM SOSO		;NO NEUTRAL FILES YET
				;FALL THROUGH TO NEXT PAGE

;CONTINUED FROM PREVIOUS PAGE

TRYAGN:	PUSH P,T1
	HRRZ T2,T1
	HRRO T1,-1(P)		;BUFFER START
	MOVSI T3,(1B11)		;FILETYPE ONLY
	JFNS
	POP P,T2
	MOVEI T1,77777
	ANDCA T1,@(P)		;CLEAR LOW ORDER BITS
	MOVE T3,GOODT		;GET GOOD PTR
	CAME T1,(T3)
	AOBJN T3,.-1
	JUMPL T3,.WIN		;GOT A SURE WINNER
	MOVE T3,BADT		;GET LOSING PTR
	CAME T1,(T3)
	AOBJN T3,.-1
	JUMPL T3,TRY2		;A SURE LOSER
	SKIPE SOSO		;ALREADY GOT A NEUTRAL?
	JRST TRY2		;YES.
	SETOM SOSO
	PUSH P,T2		;SAVE JFN
	HRRZS T2
	MOVEI T3,
	HRROI T1,LIBUF+20	;SAVE FILNAM SINCE CAN'T SAVE JFN
	JFNS
	POP P,T2
TRY2:	MOVE T1,T2		;GET BACK JFN
TRY1:	GNJFN			;GET NEXT JFN IN GROUP
	JRST .NONE
	EXCH T1,T2		;GET BACK IDXABLE HANDLE
	TLNE T2,(GN%EXT)		;MUST HAVE DIFFERENT FILETYPE
	JRST TRYAGN
	MOVE T2,T1		;COPY IDXABLE HANDLE
	JRST TRY1

.WIN1:	HRROI T2,LIBUF+20
	MOVSI T1,(GJ%OLD+GJ%SHT)
	GTJFN
	JRST .NONE		;STRANGE LOSS
	MOVE T2,T1
.WIN:	HRRZ T2,T2
	AOS -2(P)
	JRST .RET
.NONE:	SKIPE SOSO		;GOT A NEUTRAL?
	JRST .WIN1		;YES
.RET:	POP P,T3
	POP P,T4
	RET


LOSERS:	ASCII/EXE/
	ASCII/REL/
	ASCII/BIN/
	ASCII/SAV/		;TENEX EXE FILES
 	ASCII/FAS/		;LISP FASLOAD FILES
LOSLN==<.-LOSERS>+1
BADT:	-LOSLN,,LOSERS
WINNERS:ASCII/FAI/
	ASCII/MAC/
	ASCII/FOR/
	ASCII/SAI/
	ASCII/LSP/
	ASCII/BLI/
	ASCII/RNO/
	ASCII/BAS/
	ASCII/SPS/
	ASCII/TXT/
	ASCII/PAS/
	ASCII/PGO/
	ASCII/ALG/
	ASCII/MID/
	ASCII/COB/
WINLN==<.-WINNERS>+1
GOODT:	-WINLN,,WINNERS

>; IFN STANSW


PARBO:	OUTSTR	[ASCIZ "
?"]
	CALL	CJERRC		;SYSTEM MESSAGE
	HRROI T1,[ASCIZ / - /]	;Bad output file
	PSOUT
	PUSHJ P,PARPF		;PRINT IT
	JRST LOSER		;AND DIE

PARPF:	MOVE	T2,P.TEXT	;Get pointer
	ADD	T2,[7B5]	;Back it up one
PARP1:	ILDB	T1,T2		;Retrieve a character
	CAIE	T1,"!"		;CHECK COMMENT CHAR
	CAIN	T1,";"
	RET
	CAIE	T1,40		;SPACE OR
	CAIN	T1,11		;  TAB
	RET
	CAIE	T1,12		;EOL
	CAIN	T1,"/"		;OR SWITCH DESIGNATOR
	RET
	PBOUT
	JRST	PARP1

NOIF:
NOTMP:
BADTMP:	TLZ FL2,INPARS		;SAY WE'RE OUT OF THE PARSE
	OUTSTR	[ASCIZ "
?You must type an input file specification."]
	JRST	LOSER		;YOUR FINISHED

BADSW:	TLZ FL2,INPARS		;SAY WE'RE OUT OF PARSE
	OUTSTR	[ASCIZ "
?Type switches immediately after CREATE or EDIT"]
	JRST	LOSER		;BYE-BYE


RDEOTX:	TRZ	FL,F.LAHD	;CLEAR PARSE FLAG
	MOVE	T1,SVPCIN	;RESTORE CHIN
	MOVEM	T1,CHIN
	SKIPN	T1,TECINC	;TECO INCREMENT?
	MOVE	T1,[<ASCII /00100/>!1]
	MOVEM	T1,TECINC	;SET CORRECT ONE UP
	SKIPN	TECFST		;START SEQ # GIVEN?
	MOVEM	T1,TECFST	;NO: USE INCREMENT
	POPJ	P,		;EXIT PARSE

;ROUTINE TO DO GTJFN ON STRING POINTED TO BY P.TEXT
;GTJFN BITS IN T1, FILE BLOCK IN ALTP

TRYGTJ:	MOVE	T2,P.TEXT	;GET TEXT POINTER
	ADD	T2,[7B5]	;BACKUP ONE CHAR
	TLO	T1,(GJ%FLG)	;SET TO GET FLAGS
	PUSHJ	P,GTJFNX	;DO GTJFN
	  RET			;ERROR RETURN
	TLNE	T1,(GJ%TFS)	;SEE IF THIS IS A TEMPORARY FILE SPEC
	  JRST	[TLZ FL2,INPARS	;OUT OF PARSE
		 OUTSTR	[ASCIZ "
?Illegal to write a temporary file"]	;TYPE MESSAGE
		 JRST	LOSER]	;GO DIE
	ANDI	T1,-1		;CLEAR FLAGS
TRYGT1:	MOVEM	T2,P.TEXT	;SAVE UPDATED PNTR
	MOVEM	T1,JFN(ALTP)	;SAVE JFN
	TRO	FL,F.LAHD	;ONE AHEAD
	AOS	(P)		;SET FOR SKIP RETURN
;	PJRST	JFNSTR		;CONVERT JFN TO STRING

;ROUTINE TO CONVERT JFN IN T1 , TO ASCIZ STRING

JFNSTR:	MOVE	T2,T1		;COPY JFN TO T2
	HRROI	T1,ASZ(ALTP)	;POINT TO BLOCK
	MOVEM	T1,FIL(ALTP)	;SAVE PNTR
	MOVEI	T3,0		;DEFAULTS
	JFNS			;GET STRING
	RET			;RETURN

;ROUTINE TO READ THE INITIAL SWITCH LIST FROM THE INITIAL PARSER
;ENTER WITH THE FIRST "/" PARSED, EXIT WITH THE TERMINATOR CHAR
;IN C

GETSWT:	TRZ FL,F.LAHD		;INCREMENT THE POINTER FIRST
	PUSHJ P,RDATOM		;GET SWITCH NAME
	MOVEM D,ACCUM		;LEAVE FOR DOSET
	PUSHJ P,DOSET		;CALL APPROPRIATE SET ROUTINE
	  JRST SWTERR		;ILEEGAL SWITCH, COMPLAIN
	TRO FL,F.LAHD		;ENSURE WE SEE BREAK
	PUSHJ P,RDSKIP		;DISCARD ANY SPACES
	PUSHJ P,@CHIN		;THEN GET THE CHARACTER
	CAIN C,"/"		;ANOTHER SWITCH?
	JRST GETSWT		;YES, KEEP GOING
	TRO FL,F.LAHD		;RETURN TO NO LOOK-AHEAD
	POPJ P,			;NOPE, STOP NOW, RETURN THAT CHARACTER

SWTERR:	HRROI T1,[ASCIZ /?Illegal Switch - /]
	PSOUT			;Give message
	MOVEI T3,6		;Print six characters
	MOVE T2,[POINT 6,D]	;Sixbit pointer
SWTER1:	ILDB T1,T2		;Get sixbit chr.
	ADDI T1,40		;Asciize
	PBOUT			;print it
	SOJG T3,SWTER1		;Only six
	JRST LOSER		;Die ungracefully

;ROUTINE TO ZERO OUT NEWBLK

ZERNEW:	MOVE	T1,[NEWBLK,,NEWBLK+1]
	SETZM	NEWBLK
	BLT	T1,NEWBKE
	POPJ	P,

;ROUTINE TO MAKE OUTPUT FILE BE SAME AS INPUT

DEFNEW:	MOVE	T2,ORGJFN	;ORIGINAL FILE JFN
	HRROI	T1,NEWASZ	;NEW STUFF
	MOVEM	T1,NEWFIL	;SAY WE HAVE SOMETHING
	MOVE	T3,[1B8+1B11+1B35] ;GET FILE SPEC DEFAULTS
	SKIPN	CREATF		;(197) CREATING NEW FILE?
	SKIPE	SAMDEV		;(197) NO, SKIP IF DEV:<DIR> NOT EQUAL
	TLO	T3,(1B2+1B5)	;YES - NEED DEV:<STR> ALSO
	JFNS
	HRROI	T2,NEWASZ	;POINT TO TEXT OF FILESPEC
	MOVSI	T1,(GJ%FOU!GJ%SHT)
	PUSHJ	P,GTJFNX
	  FJERR			;BETTER NOT FAIL
	MOVEM T1,NEWJFN		;SAVE A WHILE
	MOVEI	ALTP,NEWBLK	;POINT TO NEWBLK
	CALL	JFNSTR		;CONVERT TO STRING
;	PJRST TSTNEW		;CHECK IF "NEW" FILE.

;TEST TO SEE IF WE SHOULD TREAT THE OUTPUT FILE AS A "NEW"
;FILE, RATHER THAN THE NEXT HIGHEST GENERATION.

TSTNEW:	HRROI T1,LIBUF		;USE TEMP BUFFER
	MOVE T2,ORGJFN
	MOVE T3,[1B2+1B5+1B8+1B11+1B35]
	JFNS			;GET DEV:<DIR>NAME.EXT
	HRROI T1,LIBUF2		;2ND BUFFER
	MOVE T2,NEWJFN
	JFNS			;GET DEV:<DIR>NAME.EXT (OUTPUT)
	HRROI T1,DEVSTR		;SAVE OUTPUT DEV:<DIR>
	MOVE T3,[1B2+1B5+1B35]
	JFNS
	HRROI T1,LIBUF
	HRROI T2,LIBUF2		;COMPARE THESE 2 FILES
	STCMP			;SAME?
	SKIPE T1		;AC1 := 0 IF EXACT MATCH
	TRO FL,NEWFL		;NO - SET NEW FILE FLAG
	HRROI	T1,DEVST2	;(197) SAVE DEV:<DIR> INPUT
	MOVE	T2,ORGJFN	;(197)
	MOVE	T3,[1B2+1B5+1B35] ;(197)
	JFNS			;(197) GET DEV:<DIR> INPUT
	HRROI	T1,DEVSTR	;(197) COMPARE OUTPUT DEV:<DIR>
	HRROI	T2,DEVST2	;(197) COMPARE INPUT DEV:<DIR>
	SETZM	SAMDEV		;(197)
	STCMP			;(197) SAME?
	SKIPN	T1		;(197) AC1 :=0 IF EXACT MATCH
	SETOM	SAMDEV		;(197) YES THEY ARE EXACT MATCH
	MOVE T1,NEWJFN		;RELEASE THIS HERE
	SETZM NEWJFN
	RLJFN			;...
	 FJERR			;SHOULDN'T HAPPEN
	MOVE T1,ORGCOD		;CHECK PSWS
	CAME T1,NEWCOD
	TRO FL,NEWFL		;NEW FILE IF PSWS DIFFERENT
	MOVE	T1,ORGJFN	;WANT TO GET PROTECTION OF ORIGINAL FILE
	MOVE	T2,[1,,.FBPRT]	;SO READ FROM FDB
	MOVEI	T3,ORGPRT	;INTO STORAGE
	GTFDB			;GET THE INFORMATION
	RET			;RETURN

;COMMAND ERROR ROUTINE

COMERR:	OUTSTR	[ASCIZ /? /]
	OUTSTR	(T1)
	OCRLF
	CALL	CLRBFI		;CLEAR TYPE AHEAD
	SETZM	TTICNT
COMER1:	SETZM	RPGSW		;CLEAR RPG MODE
	TRZ	FL,F.LAHD
	MOVE	T1,SVPCIN	;RESTORE CHIN
	MOVEM	T1,CHIN
	MOVE	P,[IOWD PDLSIZ,PDL] ;RESTORE PDL
	JRST	NOCOM1		;TRY SOME MORE

;CHKCOD - Checks for File-not-found-type GTJFN errors
;Call:  T1/ anything,,error number
;Uses:  T1, and T2

CHKCOD:	HRRZS	T1		;JUST ERROR NUMBER
	MOVSI	T2,-GTJTLN	;- TABLE LEN
	CAME	T1,GTJTAB(T2)	;LOOK IT UP
	AOBJN	T2,.-1		;LOOP
	JUMPGE	T2,CPOPJ	;NOT FOUND
	RETSKP			;FOUND GIVE SKIP RETURN

GTJTAB:	GJFX18			;?No such file name
	GJFX19			;?No such extension
	GJFX20			;?No such generation
	GJFX16
	GJFX17
	GJFX21
	GJFX24			;?File not found
GTJTLN==.-GTJTAB

;ROUTINE TO MAKE FULL FILE SPEC FOR TEMP FILES
;C(T1) := FILE NAME.EXT
;C(T2) := POINTER TO BUFFER

MAKTMP:	PUSH P,T1		;SAVE NAME
	MOVE T1,T2		;POINTER TO T1
	HRROI T2,DEVSTR		;DEVICE STRUCTURE STRING
	MOVEI T3,0
	SOUT
	POP P,T2		;NAME AND EXT
	SOUT
	RET			;DONE

;GET SIZE FOR FILE IN WORDS

GFSIZE:	MOVE	T1,IJFN(ALTP)	;FILE JFN
	MOVE	T2,[2,,.FBBYV]	;BYTE SIZE & COUNT
	MOVEI	T3,T4		;LOAD T4 & T5
	GTFDB
 	LDB	T2,[POINT 6,T4,11] ;FILE BYTE SIZE
	MOVEI	T3,^D36		;BITS / WORD
	IDIV	T3,T2		;BYTES / WORD
	AOS	T1,T5		;# OF BYTES IN FILE
	ADDI	T1,-1(T3)	;ADJUST FOR XTRA WORD
	IDIV	T1,T3		;# OF WORDS IN FILE
	MOVEM	T1,FSZ(ALTP)	;SAVE
	RET			;RETURN

;UTILITY ROUTINES

RDSKIP:	PUSHJ	P,RDSKP1		;SKIP SPACES
	TRO	FL,F.LAHD		;SET LOOK AGAIN
	POPJ	P,

RDSKP1:	PUSHJ	P,@CHIN
	CAIE	C," "
	CAIN	C,"	"	;SPACE OR TAB
	JRST	RDSKP1
	POPJ	P,

RDATOM:	MOVE	T1,[POINT 6,D]
	MOVEI	D,0		;INIT ATOM
RDATO1:	PUSHJ	P,@CHIN
	PUSHJ	P,CKALN		;CHECK ALPHA-NUMERIC
	JRST	RDATO2
	TLNN	T1,770000		;6 YET?
	JRST	RDATO1
	SUBI	C,40
	IDPB	C,T1
	JRST	RDATO1

RDATO2:	CAIE	C," "
	CAIN	C,"	"
	PUSHJ	P,RDSKP1
	PUSHJ	P,CKALN
	POPJ	P,
	MOVEI	C," "		;RETURN A SPACE IF
	TRO	FL,F.LAHD		;ALPHA-NUMERIC
	POPJ	P,

;HERE TO FETCH NEXT CHAR

LDCHR:	SKIPN	RPGSW		;FROM WHERE
	JRST	LDCHR1
	TRZN	FL,F.LAHD
LDCHRA:	IBP	P.TEXT
	LDB	C,P.TEXT
	CAIN	C,15		;PURGE CR'S
	JRST	LDCHRA
	POPJ	P,

LDCHR1:	TRZE	FL,F.LAHD
	SKIPA	C,SVCCIN
LDCHRB:	PUSHJ	P,TTYCH
	CAIN	C,15		;SKIP OVER CR'S
	JRST	LDCHRB
	MOVEM	C,SVCCIN
	POPJ	P,

;CHECK IF CHAR IS ALPHA-NUMERIC

CKALN:	CAIG	C,"z"
	CAIGE	C,"a"
	SKIPA
	SUBI	C,40	;CONVERT TO UPPER
	CAIL	C,"0"
	CAILE	C,"Z"
	POPJ	P,
	CAILE	C,"9"
	CAIL	C,"A"
	AOS	(P)
	POPJ	P,

;SPECIAL ROUTINE CALLED FROM SET OPTION IN INITIAL PARSE

OPTSWT:	TLZ	FL2,INPARS	;TEMP CLR FLAG
	PUSHJ	P,DOOPT		;PARSE OPTION FILE
	  JRST	OPTSE1		;SAY NOT FOUND
	  JRST	OPTSE2		;SAY ERROR IN FILE
	TLO	FL2,INPARS	;TURN BACK ON
	MOVEI	C," "		;PRETEND LAST CHAR WAS A SPACE
	POPJ	P,		;RETURN

OPTSE1:	MOVEI	T1,[ASCIZ /Option not found/]
	JRST	COMERR
OPTSE2:	MOVEI	T1,[ASCIZ /Syntax error in option file/]
	JRST	COMERR

SUBTTL	OPTION FILE HANDLER

;ROUTINE TO EAT AN OPTION FILE IF ANY
;CALL:	PUSHJ	P,DOOPT
;	<OPTION NOT FOUND>
;	<ERROR IN OPTION FILE>
;	<OK RETURN>
; C(OPTION) = SIXBIT OF DESIRED OPTION OR ZERO IF DEFAULT

DOOPT:	TLNE	FL2,INOPTF	;TRYING TO REENTER
	JRST	WRAPUP		;JUST GIVE CURRENT FAILURE
	SETO T1,		;THIS JOB
	HRROI T2,T4		;ONE WORD,,T4
	MOVEI T3,.JILNO		;LOGGED IN DIRECTORY #
	GETJI
	 FJERR
	HRROI T1,LIBUF2		;BUILD STRING HERE
	MOVE T2,T4
	DIRST			;GET STR:<DIR>
	 FJERR
	HRROI	T2,[ASCIZ "SWITCH.INI"]
	MOVEI	T3,0
	SOUT			;COPY STRING
	MOVSI	T1,(GJ%OLD!GJ%PHY!GJ%SHT)
	HRROI	T2,LIBUF2	;POINT TO FILESPEC
	PUSHJ	P,GTJFNX	;GET JFN
	  RET			;SAY NOT FOUND
	MOVEM	T1,OPTJFN	;SAVE JFN
	MOVE	T2,[7B5+OF%RD]	;READ MODE (ASCII)
	OPENF			;OPEN FILE
	  JRST	[MOVE T1,OPTJFN
		 RLJFN		;RELEASE JFN
		   JFCL
		 RET]		;AND RETURN
	MOVEI	T1,OPTCH	;SET UP INPUT ROUTINE
	EXCH	T1,CHIN		;SAVE CURRENT ONE
	MOVEM	T1,SVOCIN
	TLO	FL2,INOPTF	;SAY WE IS IN OPTION FILE
	SETZM	SAVCHR		;CLEAR SCANNER

RDOPT:	PUSHJ	P,SCAN		;FETCH FIRST ATOM OF LINE
	CAIN	C,177		;EOF OR ERROR?
	JRST	WRAPUP		;YES: FINISH UP AND RETURN
	MOVE	T1,ACCUM	;GET WHAT WE FOUND
	CAME	T1,[SIXBIT "EDIT"]
	JRST	SKPEOL		;NOT WHAT WE WANT - TRY NEXT LINE
	PUSHJ	P,SCAN		;FETCH BREAK CHAR
	SKIPN	OPTION		;NEED DEFAULT?
	JRST	DEFOPT		;YES:
	CAIE	C,":"		;LOOK AT BREAK CHAR
	JRST	SKPEOL		;SKIP LINE IF NOT COLON
	PUSHJ	P,SCAN		;GET NEXT ATOM
	TRNE	FL,IDF		;SEE IF IDENT
	JRST	OPTONE		;YES: TRY THIS
	CAIE	C,"("		;COULD BE LEFTPAREN
	JRST	OPTDN1		;NOPE - IT IS TRASH
OPTMOR:	PUSHJ	P,SCAN		;TRY FOR ATOM
	MOVE	T1,ACCUM
	CAMN	T1,OPTION	;IS THIS THE ONE?
	JRST	OPTMR1		;SCAN FOR RT PAREN
	PUSHJ	P,SCAN		;GULP DOWN BREAK CHAR
	CAIN	C,","		;COMMA MEANS MORE COMING
	JRST	OPTMOR
	CAIN	C,")"		;RT PAREN MEANS THAT'S ALL
	JRST	SKPEOL		;TRY NEXT LINE
	JRST	OPTDN1		;TRASHINESS

OPTMR1:	PUSHJ	P,SCAN		;LOOK FOR RT PAREN
	CAIE	C,177		;EOF OR ERROR
	TRNE	FL,TERMF	;EOL
	JRST	OPTDN1
	CAIE	C,")"		;A GOOD THING
	JRST	OPTMR1		;KEEP LOOKING
	JRST	OPTFN0		;GOT IT

OPTONE:	MOVE	T1,ACCUM
	CAME	T1,OPTION	;IS THIS IT?
	JRST	SKPEOL		;NO: KEEP LOOKING
OPTFN0:	AOS	(P)		;ALL ELSE ARE ERRORS OR AOK
OPTFND:	PUSHJ	P,SCAN		;SCAN NEXT
	TRNE	FL,IDF		;IDENTS ARE OK
	JRST	OPTGOT		;GOT ONE - USE IT
OPTNXT:	CAIE	C,"/"		;CHECK LEGAL DELIMS
	CAIN	C,","
	JRST	OPTGET		;NEED TO SCAN AGAIN
	CAIE	C,"-"		;CHECK LINE CONT.
	JRST	OPTDON		;NOPE - CHECK PROPER EOL
	PUSHJ	P,SCAN		;SCAN PAST DASH
	TRNN	FL,TERMF	;PROPER TERM?
	JRST	WRAPUP		;NO: SYNTAX ERROR
	JRST	OPTFND		;CONTINUE LOOKING


OPTGET:	PUSHJ	P,SCAN		;GET NEXT ATOM
	TRNN	FL,IDF		;IDENT?
	JRST	WRAPUP		;NO: LOSE
OPTGOT:	PUSHJ	P,DOSET		;SWITCH IN "ACCUM" - CALL SET ROUTINE
	JRST	WRAPUP		;ILLEGAL ENTRY IN FILE
	JRST	OPTNXT		;CONTINUE

OPTDON:	TRNE	FL,TERMF	;OK IF PROPER TERM
OPTDN1:	AOS	(P)		;GIVE SKIP RETURN
	JRST	WRAPUP		;FINISH UP

DEFOPT:	CAIE	C,":"		;IF COLON JUST SKIP LINE
	JRST	OPTFN0		;ELSE WE HAVE CORRECT LINE
SKPEOL:	PUSHJ	P,GNCH		;GET A CHAR
	CAIN	C,177		;CHECK ON EOF
	JRST	WRAPUP		;DONE IF SO
	TLNN	CS,TERM_16	;TERMINATOR?
	JRST	SKPEOL		;NO: KEEP GOING
	SETZM	SAVCHR		;CLEAR SCANNER
	SETZM	ACCUM		;...
	JRST	RDOPT		;YES: TRY THIS LINE

WRAPUP:	MOVE	T1,OPTJFN	;GET JFN
	CLOSF			;RELEASE
	  JFCL			;DONT CARE
	MOVE	T1,SVOCIN	;RESTORE OLD INPUT ROUTINE
	MOVEM	T1,CHIN
	TLZ	FL2,INOPTF
	POPJ	P,		;RETURN

;UTILITY ROUTINES TO READ OPTION FILE

OPTCH:	PUSH	P,T1		;SAVE REGS
	PUSH	P,T2		;...
OPTCH1:	MOVE	T1,OPTJFN	;OPTION FILE JFN
	BIN			;READ A CHAR
	JUMPE	T2,OPTEOF	;SEE IF EOF
	MOVE	C,T2		;PLACE IN C
POPRET:	POP	P,T2		;RESTORE REGS
	POP	P,T1
	RET			;RETURN

OPTEOF:	GTSTS			;GET FILE STATUS
	TLNN	T2,(GS%EOF)	;AT EOF?
	JRST	OPTCH1		;NO - PURGE ZERO BYTES
	MOVEI	C,177		;GET A RUBOUT
	JRST	POPRET		;AND RETURN


SUBTTL	ERROR ROUTINES

NOTDKI:
NOTDKO:
NODSK:	CALL NOCTRO
	OUTSTR [ASCIZ /
? No DISK available. Please check the DISK you have requested/]
	JRST	LOSER


CANTOP:	CALL NOCTRO
	OUTSTR [ASCIZ "
? Unable to open temporary file (EDIT-BUFFER.OUT) for this edit."]
	RET

;	THE ERROR HANDLER & SPECIAL FILE OPERATIONS

ERRHD0:	PUSH	P,T1		;SAVE T1
	LDB	T1,[POINT 9,40,8]
	CAILE	T1,MAXUUO	;CHECK LEGAL
	ERROR	ILUUO
	XCT	EDISP(T1)	;DO FUNCTION
	  AOS	-1(P)		;NON-SKIP MEANS SKIP
	POP	P,T1		;RESTORE T1
	RET			;RETURN

ERRCON:	CALL	NOCTRO		;TURN OFF ^O
	HRRZ	T1,40		;PICK UP THE ERROR NUMBER
	SKIPE	T1
	CAILE	T1,NUMER
	ERROR	ILUUO		;WRONG ERROR, CALL SELF
	TLNE	FL2,INOPTF!INPARS ;TREAT OPTION FILE AS SPECIAL
	JRST	OPTERR		;...
	PUSH	P,40		;SAVE FOR LATER
	OCRLF
	MOVEM	T1,SVERN	;SAVE FOR =ERROR COMMAND
	MOVE	T1,ETBL-1(T1)	;PNTR TO MESSAGES
	TRNE	FL,EXTOG
	MOVSS	T1		;USE SHORT FORM
	TLO	T1,-1		;DEFAULT BP
	PSOUT			;PRINT MESSAGE
	OCRLF			;TERMINATE WITH CRLF
	TRNN	FL2,COMFLF	;IN COMMAND FILE?
	JRST	ERRHD1		;NO: SKIP OVER LINE PRINT
	HRROI	T1,COMESS	;MSG ADDRS
	PSOUT			;DUMP IT
ERRHD1:	POP	P,40		;RESTORE OLD VALUE
	LDB	T1,[POINT 9,40,8] ;GET UUO
	XCT	ERND(T1)	;DO GOOD THING
	RET			;RERROR WILL FALL THROUGH XCT AND RETURN

ERND:	ERROR	ILUUO		;(0) IS AN ERROR
	JRST	LOSER		;(1) DIE
	JRST	CKIND		;(2) CHECK IND FILE
	POP	P,T1		;(4) RERROR - RESTORE T1

LOSER:	OCRLF
	MOVEI T1,.TICCC		;DISABLE ^C TRAPS
	DTI			;...
	HALTF			;DONE FOR NOW
	JRST	.-1		;I MEANT IT

CKIND:	TRZ	FL2,COMFLF!SUPN!UPTOPF	;RESET SOME FLAGS
	CALL	CLRBFI		;CLEAR OUT THINGS
	SETZM	TTICNT
	JRST	COMND		;GO ON


EDISP:	ERROR	ILUUO		;(0) ILLEGAL
	JRST	ERRCON		;(1) ERROR
	JRST	ERRCON		;(2) NERROR
	JRST	ERRCON		;(3) RERROR
	CALL	CJERR		;(4) JERROR (NON-FATAL JSYS ERROR)
	CALL	FATAL		;(5) FJERR (FATAL JSYS ERROR)
	CALL	TSOUT		;(6) OUTSTR (PSOUT)
	CALL	TBOUT		;(7) OUTCHR (PBOUT)
	CALL	TBIN		;(10) INCHRW (PBIN)

;HERE ON FATAL JSYS LOSSAGE

FATAL:	CALL	NOCTRO		;LET HIM SEE MSG
	OUTSTR	[ASCIZ "
? Fatal JSYS error - "]
	CALL	CJERR1		;PRINT SYSTEM MESSAGE
	JRST	LOSER		;ALL DONE

;NON-FATAL JSYS ERROR , PRINT MESSAGE LIKE NERROR

CJERR:	CALL	CJERR0		;PRINT MESSAGE
	JRST	CKIND		;SIMULATE NERROR

CJERR0:	CALL	NOCTRO		;FLUSH ^O
	OUTSTR	[ASCIZ "
% "]
	CALL	CJERR1		;PRINT SYSTEM MESSAGE
	OCRLF			;TERMINATE LINE
	RET			;RETURN

CJERRC:	SKIPA	T2,T1		;MOVE CODE TO T2
CJERR1:	SETO T2,		;USE LAST ERROR
	MOVEI	T1,.PRIOU	;WHERE TO PUT MSG
	HRLI	T2,.FHSLF
	MOVEI	T3,0		;ERSTR DRESSING
	ERSTR
	  JRST	[OUTSTR [ASCIZ "?Undefined error code."]
		 JRST LOSER]
	  JRST	[OUTSTR [ASCIZ "?ERSTR confused!"]
		 JRST LOSER]
	RET			;RETURN

;ROUTINES TO HANDLE TERMINAL INPUT/OUTPUT

TSOUT:	JSP T1,SETESC		;SET TRUTH IN ESCAPES
	HRRO T1,40		;GET UUO ADDRS
	PSOUT		;DUMP STRING
	RETSKP		;RETURN

TBOUT:	JSP T1,SETESC
	MOVE T1,@40	;GET CHARACTER
	PBOUT		;DUMP IT
	RETSKP		;RETURN

SETESC:	PUSH P,T2	;SAVE T2,T3
	PUSH P,T3
	PUSH P,T1	;SAVE RETURN ADDRS
	MOVEI T1,.PRIOU	;PRIMARY OUTPUT
	MOVE T2,COCW1	;GET COC WORDS
	MOVE T3,COCW2
	TRZ T3,3B19	;SET THIS FOR ACTUAL ESC CODE
	TRO T3,2B19	; TO BE SENT
	SFCOC		;...
	POP P,T1		;REMOVE RETURN ADDRS
	DMOVE T2,-1(P)		;RESTORE T2 & T3
	CALL @T1		;RETURN
	 SOS -2(P)		;NON-SKIP
	MOVEI T1,.PRIOU		;RESET COC WORDS
	MOVE T2,COCW1
	MOVE T3,COCW2
	SFCOC
	POP P,T3
	POP P,T2		;RESTORE REGS
	RETSKP			;RETURN

TBIN:	PUSH	P,T2		;SAVE XTRA REG
	MOVEI	T1,.PRIIN	;PRIMARY INPUT
	MOVE T2,MODW		;GET MODE WORD
	TRO T2,TT%WAK		;WAKE ON EVERYTHING
	SFMOD			;SET IT
IFN STANSW, <
	HRRZ	T2,40		;GET DEST ADDR NOW, DON'T DELAY!!  -- OO7
>; IFN STANSW
	PBIN			;GET A CHAR
IFE STANSW, <
	HRRZ	T2,40		;DEST ADDRS
>; IFE STANSW
	CAIN	T2,T1		;IS IT T1?
	MOVEI	T2,-2(P)	;YES - USE PDL THEN
	MOVEM	T1,@T2		;STORE CHAR
	MOVEI	T1,.PRIIN	;RESET MODES
	MOVE T2,MODW		;...
	SFMOD			;...
	POP	P,T2		;RESTORE REG
	RETSKP			;RETURN

;ROUTINE TO TURN OFF POSSIBLE CTRL-O

NOCTRO:	PUSH	P,T1		;SAVE REGS
	PUSH	P,T2
	MOVEI T1,.PRIOU		;PRIMARY OUTPUT
	MOVE T2,MODW		;GET MODE WORD
	TLZ T2,(TT%OSP)		;CLEAR FLAG
	SFMOD			;SET NEW MODE
	PJRST	POPRET		;RETURN

SUBTTL	CONTROL-C INTERCEPT CODE

OPTERR:	MOVE	T1,-1(P)	;RESTORE T1
	SUB	P,[3,,3]	;UP A LEVEL
	RET			;AND GIVE ERROR RETURN

;CONTROL C INTERCEPT HANDLERS

;ENABLE ALL INTERCEPTS

ENBINT:	PUSH	P,T1		;SAVE T1,T2
	PUSH	P,T2
	MOVEI	T1,.FHSLF	;CURRENT FORK
	MOVSI	T2,(1B<.TICCC>)
	SKIPL	NOCTLC		;NONE?
	STIW			;OK - SET MASK
	MOVE	T2,ONCHAN	;CHANNEL MASK
	SKIPGE	NOCTLC		;^C ALSO?
	TLZ	T2,(1B<.TICCC>)	;NO - CLR CHL #
	AIC			;
	SETOM	CNCLOK		;CLEAR INTERLOCK FOR FIRST TIME
	POP	P,T2		;RESTORE
	POP	P,T1
	POPJ	P,		;

;DISABLE INTERCEPT

DISINT:	PUSH	P,T1		;SAVE T1,T2
	PUSH	P,T2
	MOVEI	T1,.FHSLF	;CURRENT FORK
	MOVEI	T2,0		;CLEAR MASK
	STIW
OFFIN1:	MOVSI	T2,(1B<.TICCC>)	;^C ONLY
	SKIPN	NOCTLC		;CAN CTRL-C BE DISABLED?
	DIC			;YES
	POP	P,T2		;RESTORE
	POP	P,T1
	POPJ	P,		;RETURN

OFFINT:	PUSH	P,T1		;SAVE REGS
	PUSH	P,T2
	MOVEI	T1,.FHSLF	;CURRENT FORK
	JRST	OFFIN1		;DISABLE CHL

;INITIALIZE PSEUDO-INTERRUPT SYSTEM

INIPSI:	SETZM	NOCTLC		;ASSUME OK
	MOVEI	T1,.FHSLF	;THIS FORK
	CIS			;CLEAR PSI SYSTEM
	MOVE	T2,[LEVTAB,,CHNTAB]
	SIR			;SET UP PSI SYSTEM
	RPCAP			;GET CAPABILITIES OF FORK
	TLNN	T2,(1B0)	;CAN WE ENABLE FOR CTRL-C?
	 JRST	[SETOM	NOCTLC	;SET FLAG, CAN'T ENABLE FOR CTRL-C
		 JRST INIPS0]
	TLON	T3,(1B0)	;YES
	EPCAP			;
	MOVE	T1,[.TICCC,,TRPCHN] ;ESTABLISH CTRL-C
	ATI			;
	MOVEI	T1,.FHSLF	;RESTORE T1
INIPS0:	EIR			;ENABLE PSI SYSTEM
	SETOM	CNCLOK		;CLEAR INTERLOCK FOR FIRST TIME
	POPJ	P,		;

;INTERRUPT HANDLER

TRAP:	PUSH	P,T1		;SAVE A REG
	SETZM	CNCLOK		;MARK IN PROGRESS
	TLNE	FL2,NORENT	;ARE WE DISABLED?
	JRST	CNCREN		;YES: JUST RE-ENTER
	CALL	OFFINT		;TURN OFF CHL
	MOVEI	T1,.PRIOU	;PRIMARY OUTPUT
	CFOBF			;CLEAR IT
CNCIN0:	CALL	NOCTRO		;CLEAR ^O
	OUTSTR	[ASCIZ "Yes? "]
	TRNN	FL,EXTOG
	OUTSTR	[ASCIZ "(Type H for help): "]
IFE STANSW, <			;(NOW DONE IN INHELP --OO7)
	SKIPN	ECFLG		;(194) IS ECHO FLAG SET?
	 CALL	DOECHO		;(194) YES, TURN ON ECHO
>; IFE STANSW
	CALL	INHELP		;GET CHAR
	  JRST	CNCHLP		;HE WANTS HELP
	CAIN	T1,"C"
	JRST	CNCCON		;CONTINUE
	CAIN	T1,"M"

IFE STANSW, <
	JRST   MONRET		;PUNT!
>; IFE STANSW

IFN STANSW, <
	JRST   [TRNN FL,EXTOG	;EXPERT?
		 OUTSTR [ASCIZ/
Warning:  the state of your current edit has not been saved.  You may
give EXEC commands (e.g. DELETE or EXPUNGE) and then type CONTINUE to
resume editing at the point you left off, but if you run any other
programs or log out your editing will be lost.
/]
		JRST MONRET ]	;PUNT!
>; IFN STANSW

	CAIN	T1,"E"
	JRST	[MOVEI T1,CNCXIT ;(202) DO "E" COMMAND
		 JRST CNCIN1]	;(202) DISMISS TO NEW PC
	CAIN	T1,"Q"
	JRST	[MOVEI T1,CNCQT	;DO "EQ" COMMAND
		 JRST CNCIN1]	;DISMISS TO NEW PC
	CAIN	T1,"R"
	JRST	CNCREN		;DO LIKE REENTER
	CAIN	T1,"D"
	CALL	CHKDDT		;CHECK DDT ALLOWED
	  JRST	CNCIN0		;TRY AGAIN
	HRRZ	T1,T1
CNCIN1:	MOVEM	T1,RETSAV	;NEW PC FOR DEBRK
	CALL	ENBINT		;RE-ENABLE INTS
	POP	P,T1		;RESTORE T1
	SETOM	CNCLOK		;CLEAR INTERLOCK
	DEBRK			;AND GO TO NEW ROUTINE
	  ERJMP	.+1
	JRSTF	@RETSAV		;DO OUR BEST

;PDL OVERFLOW HANDLER

PDLTRP:	PUSH	P,T1		;SAVE T1
	MOVEI	T1,PDLOV	;WHERE WE WANT TO BE
	MOVEM	T1,RETSAV	;SAVED PC
	POP	P,T1		;RESTORE T1
	DEBRK			;DISMISS
	ERROR	ICN		;NEVER COME HERE

PDLOV:	NERROR	STC		;STRING TOO COMPLEX

;HERE TO DUMMY E CMD

CNCXIT:	TLO	FL2,DOENDF	;SET DO END REQUEST
	MOVEI	T1,12		;(202) FAKE OUT SCANNER
	MOVEM	T1,LIMBO	;(202) SAVE IT
	JRST	ENDIT		;(202) PREPARE FOR EXIT

;HERE TO DUMMY UP EQ

CNCQT:	MOVEI	T1,12		;FAKE OUT SCANNER
	MOVEM	T1,LIMBO
	JRST	QUIT		;AND EXIT

CNCREN:	SKIPGE	CNCLOK		;IS THIS A "REE" CMD?
	JRST	[OUTSTR [ASCIZ "?Cannot REENTER from error."]
		 JRST LOSER]	;SORRY
	POP	P,T1
	CALL	ENBINT		;RE-ENABLE ^C CHL
	MOVEI	T1,ERET		;(202) SET UP TO GO TO COMND
	MOVEM	T1,RETSAV	;(202) SET UP NEW PC
	TLO	FL2,RENTF	;ONLY IF ALLOWED
	DEBRK			;DISMISS
	  ERJMP	.+1
	JRSTF	@RETSAV		;NOT INSIDE INT

;ROUTINE TO CHECK IF WE HAVE REENTERED, SKIP RETURN IF NOT.

CHKREN:	TLNN	FL2,NORENT	;ALLOWED?
	TLZN	FL2,RENTF	;YES: CHECK FLAG
	AOS	(P)		;NO: SKIP RETURN
	POPJ	P,		;NO SKIP IF WE DID

IFN STANSW, <			;SIMULATE ^R.  --OO7
CNCCON:	PUSH P,T2		;SAVE T2
	CALL NOECNF
	MOVEI T1,.PRIIN		;FROM CONSOLE
	MOVEI T2,"R"-100	;^R
	STI%
	SKIPE ECFLG		;IF ECFLG OFF, NO ECHO STILL OK
	 CALL ONECHO		;ECFLG ON, TURN ECHO ON
	POP P,T2		;RESTORE T2
	POP P,T1		;RESTORE T1
>; IFN STANSW
IFE STANSW, <			;(NOW HANDLED BY INHELP --OO7)
CNCCON:	POP	P,T1		;RESTORE T1
	SKIPE	ECFLG		;(194) IS ECHO FLAG SET?
	 CALL	NOECHO		;(194) PUT BACK IN NOECHO MODE
	SETZM	ECFLG		;(194) SET FLAG TO ZERO
>; IFE STANSW
	CALL	ENBINT		;RE-ENABLE ^C CHL
	DEBRK			;AND CONTINUE
	  ERJMP	.+1
	JRSTF	@RETSAV		;NOT INSIDE INT I GUESS

IFE STANSW, <

CNCHLP:	OUTSTR	CNCTXT
	CALL	CHKDDT		;SEE IF OK TO TELL HIM
	  SKIPA			;NO SKIP OVER MSG
	OUTSTR	[ASCIZ "D - transfer to DDT
"]
	JRST	CNCIN0

CNCTXT:	ASCIZ "Type one of (followed by carriage return):
C - to CONTinue automatically
E - to end edit and close file
Q - to quit (delete temporary files)
M - return to MONITOR now
R - to do REEnter (terminate losing search etc.)
"
>; IFE STANSW

IFN STANSW, <

CNCHLP:	OUTSTR	[ASCIZ"
Type one of the following:

C - to Continue as if control-C was not typed
E - to End edit and keep all changes (do an E command)
Q - to Quit and abort changes since last save (do an EQ command)
M - get to Monitor (the Exec) now, as control-C usually would do
R - to Reenter to the EDIT prompt (terminate losing search etc.)
"]
	CALL	CHKDDT		;SEE IF OK TO TELL HIM
	  SKIPA			;NO SKIP OVER MSG
	OUTSTR	[ASCIZ "D - transfer to DDT
"]
	OUTSTR  [ASCIZ "
If you were in the midst of an I command when you hit control-C,
you'll need to hit an escape (ESC) when you use E or Q, before
the command option will take effect.  In other words, hit escape
if EDIT keeps prompting you with line numbers.

"]
	JRST	CNCIN0

>; IFN STANSW

;ROUTINE TO CHECK DDT EXISTANCE

CHKDDT:	PUSH	P,T2		;SAVE T2
	PUSH	P,T3		; & T3
	MOVEI	T1,.FHSLF	;GET CAPABILITIES
	RPCAP
	POP	P,T3		;DON'T CARE
	TRNN	T2,SC%WHL	;WHEEL?
	JRST	NODDT		;NOPE
	MOVE	T1,[.FHSLF,,770] ;PAGE # OF DDT
	RPACS			;CHECK ACCESS
	TLNE	T2,(PA%PEX)	;EXISTS?
	JRST	CHKDD1		;YES - MORE CHECKING
	MOVSI	T1,(GJ%SHT!GJ%OLD)
	HRROI	T2,[ASCIZ "SYS:UDDT.EXE"]
	PUSHJ	P,GTJFNX	;GET JFN
	  JRST	NODDT		;FAIL RETURN
	HRLI	T1,.FHSLF	;INTO OURSELVES
	GET			;GET IT
	  ERJMP	NODDT		;FORGET IT
	HRRZS	T1		;RESET JFN
	RLJFN			;RELEASE IT
	MOVEI	T1,.FHSLF	;RESET ENTRY VECTOR
	MOVE	T2,[3,,EV]
	SEVEC			;...
	MOVE	T1,.JBSYM##	;GET SYMBOL TABLE PNTR
	HRRZ	T2,770001	;PNTR TO PLACE TO PUT IT
	MOVEM	T1,0(T2)	;STORE IT
	MOVE	T1,.JBUSY##	;UNDEF PNTR
	HRRZ	T2,770002
	MOVEM	T1,0(T2)	;STORE IT ALSO
	JRST	DDTOK		;START UP DDT

CHKDD1:	MOVE	T1,770000	;GET FIRST LOC
	CAMN	T1,[JRST 770002] ;CHECK XFER INST
DDTOK:	AOS	-1(P)		;SET FOR SKIP RETURN
	MOVEI	T1,770000	;START ADDRS
NODDT:	POP	P,T2		;RESTORE T2
	RET			;RETURN


SUBTTL	DISK FULL AND QUOTA EXCEEDED HANDLING

;HERE ON OPENF FAILURE FOR WRITE -- CHECK REASON

OPNERR:	CAIE	T1,OPNX10	;DISK QUOTA EXCEEDED
	CAIN	T1,OPNX23	;ENTIRE DISK FULL
	JRST	OPNER1		;YES - HANDLE
	OUTSTR	[ASCIZ "
? Cannot open "]
	MOVEI	T1,.PRIOU
	MOVE	T2,OPNJFN	;JFN THAT FAILED
	MOVEI	T3,0
	JFNS			;PRINT FILESPEC
	OUTSTR	[ASCIZ " because,"]
	CALL	CJERR0		;SYSTEM MESSAGE
	JRST	LOSER		; AND EXIT
OPNER1:	POP	P,T1		;RETURN ADDRS
	SUBI	T1,2		;ADJUST TO OPENF RETRY
	MOVEM	T1,RETSAV	;USE INT LOC
	PUSH	P,OPNJFN	;PUT THIS ON STACK IN CASE EXIT
	CALL	DSKFUL		;COMMON DISK FULL ROUTINE
	CALL	ENBINT		;RE-ENABLE INTS
	POP	P,T1		;CLEAN UP PDL , SET UP JFN
	JRSTF	@RETSAV		;RETRY

;COME HERE ON CHL 20 INTERUPT (DISK IS FULL ETC...)

DSKTRP:	PUSH	P,T1		;SAVE A REG
	HRRZ	T1,RETSAV	;GET PC OF INSTRUCTION WHICH FAILED
	MOVE	T1,1(T1)	;GET INSTRUCTION FOLLOWING
	TLC	T1,(<CAI>)	;COMPARE WITH SPECIAL INSTRUCTION
	TLNN	T1,-1		;IS IT THE ONE?
	MOVEM	T1,RETSAV	;YES, SET RETURN PC AS DESIRED
	CALL	DSKFUL		;DO COMMON CODE
	CALL	ENBINT		;RE-ENABLE
	POP	P,T1		;RESTORE T1
	DEBRK			;DISMISS INT
	ERROR	ICN		;BETTER NOT

IFE STANSW, <			;COMMON DISK FULL ROUTINE -- T1 ALREADY SAVED

DSKFUL:	CALL	NOCTRO		;TURN OFF ^O
	CALL	OFFINT		;DISALLOW ^C
	HRROI	T1,[ASCIZ "
?Disk full or quota exceeded"]
	PSOUT
DSKFL1:	CALL	CLRBFI		;CLEAR TYPEAHEAD
	HRROI	T1,[ASCIZ "
Type one of (M,P,W): "]
	PSOUT
	CALL	INHELP
	  JRST	DSKHLP		;HE WANTS HELP
	CAIN	T1,"M"		;WANT TO QUIT?
	JRST	[SETZM CNCLOK	;GRNTEE CONTINUE
		 POP P,0(P)	;PRUNE RETURN ADDRS
		 JRST MONRET]	;  AND EXIT
	CAIN	T1,"W"		;WAIT TILL WE CAN TRY AGAIN
	JRST	DSKWAT
	CAIE	T1,"P"		;PURGE AND RETRY
	JRST	DSKFL1		;RE-PROMPT
DSKFL2:	PUSH	P,T2		;SAVE SOME REGS
	PUSH	P,T3
	PUSH	P,T4		;...
	GJINF
	PUSH	P,T2		;SAVE CONNECTED DIR
	MOVE	T1,T2		;DIR # TO T1
	GTDAL			;GET CURRENT USAGE
	PUSH	P,T2		;SAVE IT
	MOVEI T1,0
	MOVE T2,-1(P)		;DIR #
	DELDF			;DO EXPUNGE
	  ERJMP	[OUTSTR [ASCIZ "%Expunge failed -- continuing"]
		 OCRLF
		 JRST .+1]
	MOVE	T1,-1(P)	;DIR #
	GTDAL			;CURRENT ALLOCATION
	POP	P,T1		;RESTORE OLD VALUE
	SUB	T1,T2		;TAKE DIFFERENCE
	EXCH	T1,0(P)		;STORE ON PDL
	MOVEI	T1,"["
	PBOUT			;PRINT MESSAGE
	POP	P,T2		;GET VALUE
	CALL	DPRNT		;PRINT DECIMAL
	HRROI	T1,[ASCIZ " Pages freed]"]
	PSOUT
	OCRLF
	POP	P,T4		;RESTORE REGS
	POP	P,T3
	JRST	T2POPJ		;AND RETURN

;ROUTINE TO WAIT FOR DISK SPACE TO APPEAR

DSKWAT:	OUTSTR	[ASCIZ /%Not implemented yet - will wait 1 min.
then continue automatically....waiting.....
/]
	MOVEI	T1,^D60*^D1000
	DISMS
	OUTSTR	[ASCIZ /[OK]
/]
	RET

INHELP:	INCHRW	T1		;GET REPLY
	CAIN	T1,"?"		;CHECK FOR IMMEDIATE HELP
	JRST	[OCRLF		;GIVE CRLF
		 CALL CLRBFI	;CLEAR TYPEAHEAD
		 RET]		;GIVE NON-SKIP RETURN
	PUSH	P,T1		;SAVE IT
	INCHRW	T1		;LOOK AT NEXT CHAR
	CALL	CLRBFI		;CLEAR OUT TTY TYPE AHEAD
	CAIE	T1,15		;CHECK FOR CR
	JRST	[POP P,T1	;PRUNE PDL
		 MOVEI T1,177	;RETURN A RUBOUT
		 JRST INHLPX]	;...
	POP	P,T1		;RESTORE CHAR TYPED
	ANDI	T1,137		;FORCE UPPER CASE
INHLPX:	CAIE	T1,"H"		;CHECK FOR HELP
	AOS	0(P)		;GIVE SKIP
	RET			;RETURN

DSKHLP:	OUTSTR	DSKTXT		;PRINT MSG
	CALL	NOCTRO		;TURN OFF CTRL-O
	JRST	DSKFL1		;TRY AGAIN

DSKTXT:	ASCIZ	\Type one of (followed by carriage return):
M - To exit to the monitor
P - Purge (EXPUNGE) deleted files and try again
W - Wait until space becomes available
\

>; IFE STANSW

;COMMON DISK FULL ROUTINE -- T1 ALREADY SAVED

IFN STANSW, <

DSKFUL:	CALL	NOCTRO		;TURN OFF ^O
	CALL	OFFINT		;DISALLOW ^C
	OUTSTR  [ASCIZ "
?Disk full or quota exceeded.
Try expunging already deleted files? "]
	CALL	CONFRM		;GET YES OR NO
	JRST	DSKFL1		;NO
	JRST	DSKFL2		;YES, GO DO EXPUNGES

DSKFL1:	CALL	CLRBFI		;CLEAR TYPEAHEAD
	OUTSTR	[ASCIZ "
Type one of (M,P) or H for help: "]
	CALL	INHELP
	  JRST	DSKHLP		;HE WANTS HELP
	CAIN	T1,"M"		;WANT TO QUIT?
	JRST	DSKOUT		;YEP
	CAIE	T1,"P"		;PURGE AND RETRY
	JRST	DSKFL1		;RE-PROMPT
DSKFL2:	PUSH	P,T2		;SAVE SOME REGS
	PUSH	P,T3
	PUSH	P,T4		;...
	GJINF
	PUSH	P,T2		;SAVE CONNECTED DIR
	MOVE	T1,T2		;DIR # TO T1
	GTDAL			;GET CURRENT USAGE
	PUSH	P,T2		;SAVE IT
	MOVEI	T1,0
	MOVE	T2,-1(P)	;DIR #
	DELDF			;DO EXPUNGE
	  ERJMP	[OUTSTR [ASCIZ "%Expunge failed -- continuing"]
		 OCRLF
		 JRST .+1]
	MOVE	T1,-1(P)	;DIR #
	GTDAL			;CURRENT ALLOCATION
	POP	P,T1		;RESTORE OLD VALUE
	SUB	T1,T2		;TAKE DIFFERENCE
	EXCH	T1,0(P)		;STORE ON PDL
	MOVEI	T1,"["
	PBOUT			;PRINT MESSAGE
	POP	P,T2		;GET VALUE
	JUMPE	T2,[ OUTSTR [ASCIZ \No pages freed]
Suggestion:  return to the monitor (Exec) by typing "M", delete and
expunge at least one file, then type CONTINUE to resume this edit.
\]
		      POP P,T4
		      POP P,T3
		      POP P,T2
		      JRST DSKFL1 ]
	CALL	DPRNT		;PRINT DECIMAL
	HRROI	T1,[ASCIZ " Pages freed]"]
	PSOUT
	OCRLF
	POP	P,T4		;RESTORE REGS
	POP	P,T3
	JRST	T2POPJ		;AND RETURN

;ROUTINE USED BY CONFRM, ETC., TO RETURN A CHARACTER FROM THE TTY.  
;SINGLE RETURN IF H OR ? TYPED, SKIP RETURN OTHERWISE WITH CHAR IN T1

INHELP:	MOVEI	T1,.PRIIN
	CFIBF			;CLEAR ANY TYPE AHEAD
	CALL	ONECHO		;TURN ON ECHO (WITHOUT SETTING FLAG).  --OO7
	PBIN			;READ CHAR FROM THE TTY
	SKIPN	ECFLG		;IF ECFLG = 0, TURN OFF ECHO
	 CALL	NOECHO
	TRZ	T1,200		;CLEAR ANY PARITY BIT
	CAIN	T1,"?"		;QUESTION MARK?
	MOVEI	T1,"H"		;YES, CONFUSE WITH H
	ANDI	T1,137		;FORCE UPPERCASE
	PUSH	P,T1		;SAVE THE CHARACTER
	MOVEI	T1,.PRIIN	
	CFIBF			;CLEAR ANY TYPE AHEAD
	OCRLF			;AND TYPE A CRLF
	POP	P,T1		;RESTORE THE CHARACTER
	CAIE	T1,"H"		;SINGLE RETURN FOR HELP
	AOS	(P)		;SKIP RETURN OTHERWISE
	RET

;HERE TO EXPLAIN WHAT'S GOING ON IF USER TYPED H OR ?

DSKHLP:	OUTSTR [ASCIZ "
You're using more than your share of disk space, so you need to get rid
of some disk pages.  If you have not expunged your directory recently,
try P (for purge) first.  If this doesn't work, use M to get to the Exec,
delete and expunge some files, then type CONTINUE to resume your Edit.

Type one of:  M - To get to the Exec (You may use CONTINUE later)
	      P - Purge (EXPUNGE) deleted files and continue automatically
"]
	CALL	NOCTRO		;TURN OFF CTRL-O
	JRST	DSKFL1		;TRY AGAIN



;HERE TO RETURN TO THE MONITOR (EXEC) AFTER AN M WAS TYPED

DSKOUT:	SETZM	CNCLOK		;GRNTEE CONTINUE
	POP	P,0(P)		;PRUNE RETURN ADDRESS
	TRNN	FL,EXTOG	;EXPERT?
	OUTSTR	[ASCIZ "

Warning:  the state of your current edit has not been saved.  You may
give EXEC commands (e.g. DELETE or EXPUNGE) and then type CONTINUE to
resume editing at the point you left off, but if you run any other
programs or log out your editing will be lost.
"]
	JRST	MONRET		;OFF TO THE WILD BLUE YONDER


>; IFN STANSW


SUBTTL	ERROR MESSAGES

DEFINE ERRORS <

IFN STANSW, <
WERR (IRO,IRO,<Illegal in /READONLY mode>)
>; IFN STANSW

FERR (ICN,<Internal confusion>,<Internal confusion>)
WERR (ILC,ILC,<Illegal command>)
FERR (ILUUO,ILUUO,<Illegal UUO>)
WERR (LTL,LTL,<Line too long>)
WERR (NLN,NLN,<No such line(s)>)
WERR (NSP,NSP,<No such page>)
WERR (ORDER,ORDER,<Warning -- Sequence numbers out of order, use N command to correct.>)
WERR (ILR,ILR,<Illegal replacement on insert>)
WERR (WAR,WAR,<Wrap around>)
WERR (TMS,TMS,<Too many strings>)
WERR (STL,STL,<String too long>)
WERR (ISS,ISS,<Illegal search string>)
WERR (ILFMT,ILFMT,<Illegal line format>)
WERR (NSG,NSG,<No string given>)
WERR (NEC,SPACE,<Copy exceeds 128 pages>)
WERR (IRS,IRS,<Illegal replacement string>)
WERR (STC,STC,<Search string too complex>)
WERR (ITD,ITD,<Illegal transfer destination>)
WERR (NNN,NNN,<No next line>)
WERR (SRF,SRF,<Search fails>)
WERR (CMEND,CMEND,<End of indirect file>)
WERR (ILDC,ILDC,<Illegal decide character (Type H for help)>)
FERR (NORM,NORM,<No room for identifying line>)
WERR (EMTY,EMTY,<File is empty>)
>

DEFINE FERR (CODE,SHORT,LONG) <ERMS (?,CODE,<SHORT>,<LONG>)>

DEFINE WERR (CODE,SHORT,LONG) <ERMS (%,CODE,<SHORT>,<LONG>)>

DEFINE ERMS (CHAR,CODE,SHORT,LONG) <
	CODE==<%%ERR==%%ERR+1>
	[ASCIZ \CHAR'SHORT\],,[ASCIZ \CHAR'LONG\]
>

%%ERR==0		;INIT COUNTER

ETBL:	ERRORS
NUMER==%%ERR
	PURGE	%%ERR


SUBTTL	COMMAND DECODER AND DISPATCH

ERET:
COMND:	SETZM	SAVCHR		;SCAN SHOULD GET RESET AT THIS POINT
	SETZM	SAVC		;...
	SETZM	FSFLG		;CLEAR F/S FLAG
IFN STANSW, <
	SETZM	ESCFLG		;NO ESC SEEN YET ON THIS LINE
>; IFN STANSW
	TLNE	FL,ISCOP	;THIS CASE IS SPECIAL SINCE WE
	SKIPA	P,COPDL		;SHOULD NOT DESTROY SAVED ITEMS
	MOVE	P,[IOWD PDLSIZ,PDL] ;ALSO PDL (IN CASE OF ERRORS)
	CALL	DOECHO		;TURN ECHO BACK ON JUST IN CASE
	TRNE	FL2,COMFLF	;DON'T BOTHER IF IN CMD FILE
	JRST	CMNDN		;...
	MOVEI T1,.PRIOU
	MOVE T2,MODW		;GET MODES
	TLZ T2,(TT%OSP)		;CLEAR ^O
	TRO T2,<.TTATE>B29	;RESET OUTPUT XLATE
	SFMOD			;...
	TRO	FL2,ALTECH	;GRNTEE $ ECHO
CMNDN:	SKIPN	T1,TEMINC	;TEMP INCR?
	MOVE	T1,INCR		;NO: USE CURRENT ONE
	MOVEM	T1,INCR		;YES: RESOTRE OLD ONE
	SETZM	TEMINC		;CLEAR TEMP
	TLZE	FL2,DOENDF	;NEED END COMMAND?
	JRST	CMDEND		;YES: GO DO IT
	TLNE	FL,SRCOP
	JRST	NOCPCK		;DO NOT GET OUT OF COPY MODE
	TLZE	FL,ISCOP	;IN COPY MODE?
	JRST	COPDON		;YES, DO SPECIAL CLEAR OUT
NOCPCK:	TLZN	FL2,NORENT	;NEED TO CHECK FOR REENTER
	JRST	NORNCK		;NO:
	TLZE	FL2,RENTF	;SEE IF NEED TO REENTER
	JRST	[MOVEI T1,[TLZ FL2,RENTF
			   JRST COMND]
		 MOVEM T1,RETSAV ;HACK SAVED PC
		 JRST TRAP]	;SIMULATE ^C
NORNCK:	TRNN	FL,EXTOG	;SKIP THIS HACK IF IN EXPERT MODE
	SKIPN	T1,DELCNT#	;  OR IF NO DELETIONS
	JRST	CMNDA
	MOVEI	T3,OCHR		;SET UP FOR PRINTER
	PUSHJ	P,DECPR		;PRINT # OF LINES DELETED
	PUSHJ	P,FORCE		;DUMP IT
	OUTSTR	[ASCIZ / Lines (/]
	MOVE	T1,FDELLN#	;GET FIRST LINE DELETED
	MOVEM	T1,LINOUT	;PRINT IT
	OUTSTR	LINOUT
	MOVE	T1,FDELPG#
	PUSHJ	P,DECPR		;AND PAGE #
	PUSHJ	P,FORCE
	MOVE	T2,LDELLN#	;LAST LINE DELETED
	SKIPN	PGDELS		;IF ANY PAGE MARKS DELETED
	CAME	T2,FDELLN	;SAME AS FIRST?
	JRST	[OUTCHR [":"]	;NO: PRINT IT ALSO
		 SETZI T3,
		 OUTSTR T2
		 SKIPN T1,PGDELS
		 JRST .+1
		 ADD T1,FDELPG
		 OUTCHR ["/"]
		 MOVEI T3,OCHR	;ROUTINE TO USE
		 PUSHJ P,DECPR
		 PUSHJ P,FORCE
		 JRST .+1]
	OUTSTR	[ASCIZ /) deleted
/]
CMNDA:	PUSHJ	P,CMDSAV	;CHECK FOR AUTO-SAVE
	  JRST	CMND2		;DO IT
IFN STANSW, <
	TRNE FL2,COMFLF		;DON'T PRINT PROMPT IF IN COMMAND FILE
	 JRST CMNDB
	MOVEI T1,.PRIOU		;MAKE SURE WE ARE AT LEFT MARGIN  --OO7
	RFPOS
	TRNE T2,-1
	 OCRLF
	TLNN FL,SRCOP		;GET APPROPRIATE PROMPT
	 SKIPA T1,[ASCII "*"]	;NORMAL PROMPT
	  MOVSI T1,(<ASCII "C*">)  ;SPECIAL FOR COPY MODE
>; IFN STANSW
IFE STANSW,<
	TRNE	FL2,SUPN!COMFLF	;SUPPRESS * AFTER PRETTY PRINT
	JRST	CMNDB
	MOVE	T1,[ASCII "*"]	;PROMPT
	TLNE	FL,SRCOP	;GIVE XTRA PROMPT IF COPY
	MOVE	T1,[ASCII "C*"]
>; IFE STANSW
	MOVEM	T1,CRBUF	;STORE FOR ^R
	OUTSTR	CRBUF		;AND PRINT IT
CMNDB:	TRZ	FL2,SVIT!SUPN	;TURN OFF SOME BITS
IFN EXTEND,<
	MOVEI	T1,LSNUM	;RESET LINE SEARCH STRINGS
	MOVEM	T1,LSBUFN
>; IFN EXTEND
	TRNN	FL2,COMFLF	;COMMAND FILE?
	JRST	CMND1		;NO
	MOVE	T2,[ASCII /00001/] ;INCREMENT CMD CNT
	MOVE	T1,COMCNT
	PUSHJ	P,ASCIAD	;ASCII ADDDER
	MOVEM	T1,COMCNT	;STORE
CMND1:	PUSHJ	P,GNCH		;READ A CHARACTER
	TLZ	FL2,RENTF	;CLEAR FLAG - HE MAY TRY TO REENTER
	CAIE	C,15
	JUMPE	CS,CMND1	;IGNORE SPACES ETC
	TLNE	CS,LETF_16	;CHECK TO SEE IF LETTER
	TRZ	C,40		;AND CONVERT TO UPPER CASE
CMND2:	MOVSI	T1,-CMDLG	;GET LENGTH OF COMMAND TABLE
	CAME	C,CMD1(T1)	;COMPARE
	AOBJN	T1,.-1		;CHECK FOR MATCH
	SETZM	DELCNT
	SETZM	LDELLN
	SETZM	FDELLN
	SETZM	FDELPG		;INIT DELETE CNTS
IFN STATSW, <
	AOS   	ST.MEM(T1) >	;INCREMENT STATISTICS COUNT
	CAIE	C,"P"		;(195) IS IT A P COMMAND
	SETZM	PNOARG		;(195) NO CLEAR P MEMORY
	JUMPL	T1,@CMD2(T1)	;DISPATCH IF FOUND
	NERROR	ILC		;ELSE ERROR

; THE COMMAND TABLE
;	(NAME,DISPATCH ADDRESS,HELP MESSAGE)
;  OR   (OLD NAME,"NOTHER",NEW COMMAND TO USE)

IFE STANSW, <

DEFINE COMTAB <
X	("?",QUEST,<?>)
X	(12,NXTLIN,<<LF>>)
X	(200,BAKLIN,<<ESC>>)
X	("A",ALTER,<Alter - A>)
X	("B",SVCOD,<Backup - B, BI, BJ, BN, BU>)
X	("C",COPY,<Copy - C>)
X	("D",DELETE,<Delete - D>)
X	("E",ENDIT,<End - E, EI, EJ, EN, EU, EK, EQ>)
X	("F",SEARCH,<Find - F>)
X	("=",GIVE,<Give - =>)
X	("G",GEND,<Go - G, GI, GJ, GN, GU>)
X	("H",HELP,<Help - H>)
X	("@",COMFIL,<Indirect - @>)
X	("I",INSERT,<Insert - I>)
X	("J",JOIN,<Join - J>)
X	("K",KILL,<Kill - K>)
X	("L",LIST,<List - L>)
X	("M",MARK,<Mark - M>)
X	(".",PMOVE,<Move - .>)
X	("N",NUMBER,<Number - N>)
X	("P",PRINT,<Print - P>)
X	("R",REPLAC,<Replace - R>)
X	("/",SET,<Set - />)
X	("S",SUBST,<Substitute - S>)
X	("T",TRANS,<Transfer - T>)
X	("X",XPAND,<eXtend - X>)
X	(15,NULCMD,)
>>; IFE STANSW


IFN STANSW, <

;NOTE THAT THE ENTRY POINTS FOR COMMANDS ARE ALSO USED TO FIND
;HELP TOPICS.  THUS, IF YOU CHANGE THE NAME OF AN ENTRY POINT,
;CHANGE HLPTAB ALSO.

DEFINE COMTAB <
X	("?",QUEST,<? -- Print this list>)
X	(12,NXTLIN,<<LF> - Print next line>)
X	(200,BAKLIN,<<ESC> - Print previous line>)
X	("A",ALTER,<Alter - A>)
X	("B",SVCOD,<Backup - B, BI, BJ, BN, BU>)
X	(";",COMIGN,<Comment - ; or !>)
X	("C",COPY,<Copy - C>)
X	("D",DELETE,<Delete - D>)
X	("E",ENDIT,<End - E, EI, EJ, EK, EN, EU, EQ>)
X	("F",SEARCH,<Find - F>)
X	("=",GIVE,<Give Information - =>)
X	("G",GEND,<Go - G, GI, GJ, GN, GU>)
X	("H",HELP,<Help - H>)
X	("@",COMFIL,<Indirect - @>)
X	("I",INSERT,<Insert - I>)
X	("J",JOINT,<Join - J, Justify - JU, JF, JC, JR, JL>)
X	("K",KILL,<Kill - K>)
X	("L",LIST,<List - L>)
X	("M",MARK,<Mark - M>)
X	(".",PMOVE,<Move - .>)
X	("N",NUMBER,<Number - N>)
X	("P",PRINT,<Print - P>)
X	("R",REPLAC,<Replace - R>)
X	("/",SET,<Set Switch - />)
X	("S",SUBST,<Substitute - S>)
X	("T",TRANS,<Transfer - T>)
X	("V",INVERT,<InVert - V>)
X	("X",XPAND,<eXtend - X>)
X	("!",COMIGN,)
X	(15,NULCMD,)
>
>; IFN STANSW


	DEFINE X(A,B,C) <
	EXP A >
CMD1:	COMTAB
CMDLG==.-CMD1

	DEFINE X(A,B,C) <
	EXP B >
CMD2:	COMTAB

	DEFINE X(A,B,C) <
	[ASCIZ \C\]>
CMD3:	COMTAB

;COME HERE TO DO AUTO SAVE

CMDSAV:	TRNE	FL,READOF	;CHECK RO
	JRST	CPOPJ1		;YES - SKIP THIS
	TLZE	FL2,CCHGF	;DID THIS COMMAND CHANGE THINGS?
	SOSE	SAVEN		;YES -- COUNT DOWN
	JRST	CPOPJ1		;STILL OK
	OUTSTR	[ASCIZ "[Doing auto-save, please wait.]"]
	OCRLF
	MOVEI	C,"B"		;FUDGE UP B COMMAND
	MOVEI	T1,12		;FUDGE UP LINE TERM
	MOVEM	T1,LIMBO
	POPJ	P,		;PROCESS COMMAND

NULCMD:	PUSHJ	P,GNCH		;GRNTEE LF AFTER CR COMMAND
	CAIE	C,12		;IS IT?
	NERROR	ILC		;NO: LOSE
	JRST	COMND		;YES: WIN

CMDEND:	MOVEI	C,"E"		;DUMMY CMD
	TLZ	FL2,RENTF	;CLR FLAG
	MOVEI	T1,12
	TLNN	FL,SRCOP	;NEED DUMMY LF IF NOT COPY
	MOVEM	T1,LIMBO
	JRST	CMND2		;PROCESS


SUBTTL	MOVE, HELP, AND ?

IFE STANSW, <

HELP:	CALL	SCAN		;SCAN TERMINATOR
	TRNN	FL,TERMF	;CHECK EOL
	NERROR	ILC
	MOVSI	T1,(GJ%OLD!GJ%SHT!GJ%IFG)
	HRROI	T2,[ASCIZ "HLP:EDIT.HLP"]
	PUSHJ	P,GTJFNX	;FILE TO TRY FOR
	  JRST	SORROW		;EXIT IF NOTHING
	HRRZ	T1,T1		;CLEAR THE LEFT HAND BITS
	PUSH	P,T1		;SAVE JFN
	MOVE	T2,[7B5+OF%RD]	;OPEN FOR READ
	OPENF
	  JRST	[POP P,T1	;GET JFN
		 RLJFN		;FLUSH
		   JFCL
		 JRST SORROW]	;NOTHING TO DO
HELP1:	MOVE	T1,0(P)		;JFN
	BIN			;CHAR
	JUMPE	T2,HELP2	;CHECK FOR EOF
	MOVE	T1,T2		;COPY CHAR TO T1
	PBOUT			;DUMP ON PRIMARY
	JRST	HELP1		;GET SOMEMORE

HELP2:	GTSTS			;GET DEVICE STATUS
	TLNN	T2,(GS%EOF)	;EOF?
	JRST	HELP1		;NO - TRY NEXT (IGNORE NULLS)
	CLOSF			;YES - FLUSH JFN
	  FJERR
	OCRLF			;XTRA ANYHOW
	JRST	COMND		;AND RETURN TO USER

SORROW:	OUTSTR	[ASCIZ "% I'm sorry I can't help you."]
	OCRLF
	JRST	COMND		;T-S

>; IFE STANSW


IFN STANSW, <

; HELP MACRO.  NOTE THAT THIS VERSION GENERATES THE HELP TEXT IN LINE,
; A TOTAL LOSS.  THE ALTERNATIVE MIGHT BE TO USE PSECTS, OR AN 
; INFORMATION-CARRYING MACRO THAT GOT EXPANDED AT THE END OF THE PROGRAM.
;
; WARNING: BE SURE THIS MACRO IS LOCATED SO THAT THE SURROUNDING CODE DOES NOT
;	   SKIP OR JUMP INTO THE BODY OF THE LITERAL.


DEFINE	HLPMSG (TEXT, %A) <
	XLIST
%A:	ASCIZ \TEXT\
	JUMP	%A
	LIST
>


	HLPMSG <H Command	(Help)
 
H{<topic-string>}
	
	Type a help message for a given topic.  For a list of the available
	help topics, type H ?.  If you haven't had much experience with
	editors, type H introduction for a short introduction to EDIT and
	editors in general.

>
HELP:	CALL	SCAN		;LOOK FOR ARGUMENT
	TRNE	FL,TERMF	;TERMINATOR?
	 JRST	HELP0		;YES, GO FAKE SEEING "HELP"
	CAIN	C,"?"		;TYPED A QUESTION MARK?
	 JRST	HQUEST		;YES, GO LIST THE COMMANDS
	TRNN	FL,IDF		;IDENTIFIER?
	NERROR	ILC		;NO, COMPLAIN ABOUT IT
	CALL	HCODE		;LOOK UP THE IDENTIFIER IN OUR TABLE
	JUMPE	T1,HLPJNK	;NO SUCH ENTRY
	CAIN	T1,-1		;DID THE USER TYPE HELP FOO?
	 JRST	HELP		;YES, PARSE THE LINE AGAIN
	PUSH	P,T1		;SAVE ADDRESS
	CALL	SCAN		;SCAN REST OF COMMAND LINE
	TRNN	FL,TERMF	;TERMINATOR?
	NERROR	ILC		;NO, ILLEGAL COMMAND
	POP	P,T1		;RESTORE THE ADDRESS
	SKIPA
HELP0:	MOVEI	T1,HELP		;IN CASE H<RETURN> WAS TYPED
	SUBI	T1,1		;BACK UP ONE ADDRESS
	HLRZ	T2,@T1		;GET LEFT HALF OF WORD AT THAT ADDRESS
	CAIE	T2,(<JUMP 0>)	;DO WE HAVE A HELP MESSAGE THERE?
	 JRST	HLPNOT		;NO, EXPRESS PROFOUND REGRETS
	HRRO	T1,@T1		;POINTER TO HELP MESSAGE
	PSOUT			;PRINT IT
	JRST	COMND		;BACK TO COMMAND LEVEL


;THIS CODE STOLEN FROM THE XCODE ROUTINE USED TO PARSE PARTIAL STRINGS
;FOR THE SWITCH ROUTINES.  RETURNS DISPATCH ADDRESS IN T1

HCODE:	PUSH	P,S1		;SAVE SPECIAL ACS
	PUSH	P,S2
	MOVE	S1,[S2,,TOPTAB] ;HERE LIVES THE TOPIC TABLE
	MOVSI	S2,-TOPLEN	;LENGTH OF TABLE
	CALL	DECODE		;SEARCH THE TABLE
	HRRZ	T1,ADDTAB(S2)	;GET DISPATCH ENTRY
	POP	P,S2		;RESTORE SPECIAL ACS
	POP	P,S1
	RET

;HERE IF "HELP ?" WAS TYPED
;PRINTS HELP TOPICS IN THREE COLUMNS

HQUEST:	CALL	SCAN		;CHECK REST OF COMMAND LINE
	TRNN	FL,TERMF	;TERMINATED CORRECTLY?
	NERROR	ILC		;NO
	OUTSTR	[ASCIZ "Help is available for: "]
	OCRLF
	MOVSI	T4,-TOPLEN	;AOBJN COUNTER
HQS:	MOVEI	T3,^D25		;FIRST COLUMN, SPACE OVER TO COL. 25
	CALL	HQOUT
	MOVEI	T3,^D49		;SECOND COLUMN, SPACE OVER TO COL. 49
	CALL	HQOUT
	MOVEI	T3,0		;THIRD COLUMN, DON'T SPACE OVER
	CALL	HQOUT
	JRST	HQS		;GO FOR ANOTHER LINE


;HQOUT TAKES A COLUMN NUMBER IN T3, OR 0 IN T3 IF A CRLF IS WANTED

HQOUT:	HLRZ	T1,ADDTAB(T4)	;DO WE WANT TO TYPE THIS OUT?
	JUMPE	T1,HQ1		;GUESS NOT.  GO LOOK AT NEXT TOPIC
	MOVE	T1,HLPLST(T4)	;GET ADDRESS OF ASCIZ STRING
	OUTSTR	(T1)		;PRINT IT
	JUMPE	T3,HQ2		;WANTS JUST A CRLF
	MOVEI	T1,.PRIOU	;READ FROM THE TTY
	RFPOS
	HRRZS	T2		;WANT ONLY THE COLUMN NUMBER
	SUB	T2,T3		;SUBTRACT OFF RIGHT COLUMN
	MOVEI	T1," "		;A SPACE
	PBOUT
	AOJL	T2,.-1		;SPACE OVER
	SKIPA
HQ2:	OCRLF
	AOBJN	T4,CPOPJ	;INCREMENT COUNT AND RETURN
	OCRLF			;FINAL CRLF
	JRST	COMND		;RETURN TO COMMAND LEVEL

HQ1:	AOBJN	T4,HQOUT	;INCREMENT COUNT AND TRY AGAIN
	OCRLF			;FINAL CRLF
	JRST	COMND		;RETURN TO COMMAND LEVEL


;HERE FOR VARIOUS ERROR MESSAGES ASSOCIATED WITH HELP

HLPJNK:	OUTSTR	[ASCIZ "
% No such command or topic.  Type H ? for a list of available help topics.
"]
	JRST	COMIGN		;USE COMMENT COMMAND TO FLUSH BUFFER AND RETURN


HLPNOT:	OUTSTR	[ASCIZ "
% No help available (yet) on that topic.  Please ask a consultant.
"]
	JRST	COMND		;BACK TO COMMAND LEVEL


;HERE IS THE TABLE OF ALL HELP TOPICS WE KNOW ABOUT
;NOTE THAT TOPICS THAT ARE ALSO COMMANDS POINT TO THE ENTRY FOR
;THE COMMAND, FROM THE MAIN COMMAND TABLE (COMTAB).
;FORMAT IS (IDENTIFIER, ADDRESS, PRINT-OUT FLAG)

DEFINE	HLPTOP <
X	(A,ALTER,1)		;ALTER COMMAND
X	(ALTER,ALTER,1)
X	(AUTOSAVE,H.AUTO,1)	;AUTOMATICALLY SAVING YOUR WORK
X	(B,SVCOD,1)		;BACKUP COMMAND
X	(BACKUP,SVCOD,1)
X	(BI,SVCOD,0)
X	(BJ,SVCOD,0)
X	(BN,SVCOD,0)
X	(BU,SVCOD,0)
X	(C,COPY,1)		;COPY COMMAND
X	(COPY,COPY,1)
X	(C128,QON,1)		;C128 MODE
X	(COMMANDS,H.COM,1)	;COMMAND SUMMARY
X	(D,DELETE,1)		;DELETE COMMAND
X	(DELETE,DELETE,1)
X	(DOCUMENTATION,H.DOC,1)	; EDIT DOCUMENTATION
X	(E,ENDIT,1)		;END COMMAND
X	(EI,ENDIT,0)
X	(EJ,ENDIT,0)
X	(ELP,-1,0)		;IF USER TYPED "HELP FOO" INSTEAD OF "H FOO"
X	(EN,ENDIT,0)
X	(END,ENDIT,1)
X	(EU,ENDIT,0)
X	(EK,ENDIT,0)
X	(EQ,ENDIT,0)
X	(EXTEND,XPAND,1)
X	(F,SEARCH,1)		;FIND COMMAND 
X	(FIND,SEARCH,1)
X	(G,GEND,1)		;GO COMMAND
X	(GI,GEND,0)
X	(GJ,GEND,0)
X	(GN,GEND,0)
X	(GO,GEND,1)
X	(GU,GEND,0)
X	(H,HELP,1)		;HELP COMMAND
X	(HELP,HELP,0)		;HELP COMMAND SYNONYM
X	(I,INSERT,1)		;INSERT COMMAND
X	(INDIRECT-FILES,COMFIL,1) ;THE @ COMMAND (PARSER WON'T TAKE THE @)
X	(INIT-FILE,H.INIT,1)	;DOC ON SWITCH.INI 
X	(INSERT,INSERT,1)
X	(INTRODUCTION,H.INTR,1)	;GENERAL INTRO TO EDITING
X	(INVERT,INVERT,1)
X	(J,JOIN,1)		;JOIN COMMAND
X	(JC,JOIN,0)		;JUSTIFY COMMAND
X	(JF,JOIN,0)
X	(JL,JOIN,0)
X	(JOIN,JOIN,1)
X	(JR,JOIN,0)
X	(JU,JOIN,1)		;JUSTIFY COMMAND
X	(JUSTIFY,JOIN,1)
X	(K,KILL,1)		;KILL PAGE MARK COMMAND
X	(KEYBOARD,H.KEY,1)	;KEYBOARD CHARACTER REPRESENTATIONS
X	(KILL,KILL,1)
X	(L,LIST,1)		;LIST COMMAND
X	(LIST,LIST,1)
X	(M,MARK,1)		;MARK PAGE COMMAND
X	(MARK,MARK,1)
X	(MOVE,PMOVE,1)	;THE . COMMAND
X	(N,NUMBER,1)		;RENUMBER COMMAND
X	(NUMBER,NUMBER,1)
X	(P,PRINT,1)		;PRINT COMMAND
X	(PRINT,PRINT,1)
X	(PRINTABLE-SWITCHES,GIVE,1) ;THE = COMMAND
X	(R,REPLAC,1)		;REPLACE COMMAND
X	(RANGE,H.RANG,1)	;GENERAL INTRO TO RANGES
X	(REPLACE,REPLAC,1)
X	(S,SUBST,1)		;SUBSTITUTE COMMAND
X	(SETTABLE-SWITCHES,SET,1) ;THE / COMMAND
X	(SUBSTITUTE,SUBST,1)
X	(SWITCHES,H.SWIT,1)	;ALL SETTABLE AND EXAMINABLE SWITCHES
X	(T,TRANS,1)		;TRANSFER COMMAND
X	(TRANSFER,TRANS,1)
X	(V,INVERT,1)		;INVERT COMMAND
X	(X,XPAND,1)		;EXTEND COMMAND
> ;DEFINE HLPTOP

;HERE ARE THE MACROS THAT EXPAND THE HLPTOP TABLE CORRECTLY


;HERE IS THE TABLE OF SIXBIT STRINGS ASSOCIATED WITH EACH HELP TOPIC.
;NOTE THAT ONLY THE FIRST SIX LETTERS OF EACH TOPIC ARE UNIQUE

DEFINE	X (A,B,C) <EXP <SIXBIT "A">>

TOPTAB:	HLPTOP			;TABLE OF SIXBIT NAMES
TOPLEN==.-TOPTAB



;ON THE LEFT HALF, WE HAVE THE TABLE OF DISPATCH ADDRESSES. THE RIGHT HALF
;IS 0 IF WE DO NOT WANT TO ADMIT THAT THIS TOPIC IS IN HLPTOP,, 1 OTHERWISE.

DEFINE	X (A,B,C) < XWD C,B  >	;TYPE OUT FLAG,,DISPATCH ADDRESS

ADDTAB:	HLPTOP			;TABLE OF DISPATCH ADDRESSES
	EXP 0			;LAST ENTRY IS ZERO, TO DETECT BAD NAME



;HERE IS THE TABLE OF ASCIZ STRINGS PRINTED OUT WHEN H ? IS TYPED

DEFINE  X (A,B,C) < [ASCIZ "A"] >

HLPLST:	HLPTOP			;TABLE OF ASCII HELP TOPICS



;HERE ARE SOME GENERAL HELP TOPICS OF INTEREST THAT ARE NOT
;ASSOCIATED WITH PARTICULAR COMMANDS OR SWITCHES
;EACH HAS A LABEL OF THE FORM H.XXX


	HLPMSG <Documentation on Edit

To obtain listings of the help text, you can use Edit to extract  the
desired passages  from  the file  DOC:EDIT.SUPPLEMENT  . (Use  the  L
command while editing  the file  in readonly  mode, or  CREATE a  new
destination file and  use the file-source  form of the  C command  to
obtain the sections in which you are interested.)

The EDIT  Reference  Manual  available  from  DEC  contains  extended
information on  all commands  available in  the standard  version  of
EDIT.  It does not document such  Stanford extensions as the JU or  V
commands.

The EDIT Users' Card contains  a convenient reference summary of  the
basic edit commands in reference-card  format.  It is available  from
the LOTS Office for 25 cents.
>

H.DOC:


	HLPMSG <Editors in general ("What is an editor?")
Introduction to Edit
 
An editor is your handle on  data contained in files.  A text  editor
then is built to deal  with text files, such  as what you are  seeing
before you now.  The goal of an editor is to help you get what is  on
your mind into the system as quickly and as efficiently as  possible.
Thus, rather than  retyping the modified  version of a  body of  text
which is in  your mind, the  editor seeks  to allow you  to edit,  or
simply change, only the parts of it that are different.

Edit   is  a  line   and  line-number  oriented   text	editor,  with
one-character  commands.    (There   are  also	 some	two-character
commands.)  It supplies removable  line numbers to files which do not
already  have them.  If  you are  creating a file  from scratch, Edit
supplies a number for each  line you input.  For example, to remove a
line you specify "d" for delete  plus a line number.  To insert a new
line,  you can specify "i"  for insert plus a  number that places the
new line where you want  it in relation to the existing line numbers.
Edit also features intraline editing (changing some of the characters
within	a line	without retyping the  whole line),  string search and
substitution  (changing misspelling "integre" to  "integer" once or a
hundred  times, hyphen-less text justification	(making an even right
hand  margin  like  a  book or	a  newspaper  column),	copying  from
secondary files  (duplicating a  program  you have  a written  as  an
example in a writeup on programming), and more.
 
Edit is started via one  of the Exec EDIT and CREATE commands. CREATE
is used to start a new	file, and EDIT to work with an existing file.
For an existing  file, the line numbers will be  the same as the last
time you  edited  the file  unless you	removed  the numbers  in  the
meantime,  in which  case  fresh  ones will  be  assigned,  generally
starting at 100 and increasing by 100 from line to line.
 
When Edit  starts up after an EDIT command,  it will signal readiness
to  accept an  edit command  by typing the  prompt "*"	to you, after
which you  can type any command  to it.  If you are  ever in doubt of
which  file Edit is  working on, type  "=NAME" to the  "*". Errors in
typing can be corrected  by backspacing, CTRL/W (delete one full word
back), CTRL/R  (retype the current line -- useful  if it gets screwed
up by a message from the system or another user), and CTRL/U (restart
the current line).
 
When  Edit is started  up with a  CREATE command, since  there are no
lines in the new file, and hence none to edit, it is assumed that you
will want to insert lines.  You are immediately put into insert mode,
as if an automatic "I" command had been done.
 
Many commands in Edit use a line-number range as part of their syntax
to specify  which part of the  file to work on.   The simple cases of
the range for a beginning user are shown in the following:
 
	100:800		for  "lines 100 through 800"
	10!7		for  "7 lines beginning at line 10"
 
For a summary of all the Edit commands, see the help topic "commands".
Further information on the individual commands may be obtained by
typing the command name or letter as a help topic.  A list of all help
topics may be obtained by typing a question mark as a help topic.
>

H.INTR:


	HLPMSG <Auto save to prevent grief when the system crashes

If you are creating a new file, it is very painful to have the system
crash and lose the file.  There  are two simple ways of  automaticaly
protecting  yourself  from   this  needless   source  of   additional
frustration.  One way is to force saves of the updated file based  on
the number of inserted lines, and the other way is to do so based  on
the number of times an editing command has been issued.

*/ISAVE:20

This is an example of forcing a backup of the file
every twenty inserted lines.  20 could be replaced
by anything.

*/SAVE:10

This is an example of forcing a save each time ten
commands have been issued that resulted in additions
to the file.
>

H.AUTO:


	HLPMSG <Switches
 
name	     set  print  default value		what
 
  .	      n     y	    --- 	   current <position>
  ?	      n     y	    --- 	   /? list settable switches
					   =? list printable switches
BAK	      y     y	    off 	   create backup file <.Qxx>
BIG	      n     y	    --- 	   largest page number
C64	      y     CASE    on		   64 character set
C128	      y     CASE    off 	   128 character set
CASE	      n     CASE    C64 ADM3 UPPER display case and terminal type
COLUMNS	      n	    y       ---		   display columns	
DECIDE	      y     y	    off 	   auto ",D" for "S" command
EXPERT	      y     n	    off 	   Q.E.D.
INCREMENT     y     y	    100 	   default line increment
INSERT	      n     y	    --- 	   location of next I<CR>
ISAVE	      y     y	    0		   controls auto-save on inserts
LMAR	      y	    y	    1		   left margin for justify
LOCATION      n     y	    --- 	   first line in edit buffer
LOWER	      y     CASE    off 	   default lower case
NAME	      y     y	    --- 	   output file spec
NOBAK	      y     n	    on		   no backup file
NODECIDE      y     n	    on		   no auto ",D"
NONSEPARATORS y     CASE    on		   %,$,. are not alphanumerics
NONUMBER      y     n	    off 	   don't print line numbers
NOTYPE	      y	    n	    off		   alter won't type automatically
NOVICE	      y     n	    on		   normal mode
NUMBER	      y     n	    on		   print line numbers on terminal
OLD	      y     n	    off 	   create backup file (.Zxx)
OPTION	      n     n	    --- 	   read 'SWITCH.INI' file
PLINES	      y     y	    16		   used by "P<CR>
PMAR	      y     y	    1		   paragraph margin for justify
R	      Same as RONLY
READONLY      Same as RONLY
RMAR	      y     y	    69		   right margin for justify
RONLY	      y     n	    off 	   read-only file
RUN	      y     y	    LOAD-class	   set run spec
SAVE	      y     y	    0		   controls auto-save on commands
SEPARATORS    y     n	    off 	   treat %,$,. as alphanumeric
SEQUENCE      y     y	    on		   sequence output file
START	      y     y	    100 	   starting sequence #
STEP	      y     y	    100 	   default line increment
STRING	      n     y	    --- 	   current F & S strings
TYPE	      y	    y	    on		   alter will type automatically
UNSEQUENCE    y     n	    off 	   unsequence output file
UPPER	      y     CASE    on		   default upper case
WINDOW	      y     y	    10		   size of edit file window
 
Parameters may be set via a '/' command, e.g.
	*/c128
and examined via a '=' command, e.g.
	*=case

All settable parameters may be  specified as switches in the  initial
command string.
>

H.SWIT:


	HLPMSG <Ranges of lines
 
A RANGE is defined as:
 
<range>    ::= % or <subrange>

<subrange> ::= <position>[!<number> or
		     :<position>]
 
<position> ::= [<line>][/<page>]
 
<line>	   ::= [<number> or
		. or * or ^][(+-)<number>]
 
<page>	   ::= [<number> or
		. or * or ^][(+-)<number>]
 
<number>   ::= a positive integer

Positions (use in range specifications):
	^    first line or page
	*    last line or page
	.    present line or page

Special range:
	%    whole file, equivalent to ^/^:*/*

Typical range specifications:
	400:700		lines 400 through 700 on current page
	^:*-3		the first line on the page through 3 from the end
	^!10		10 lines starting at the beginning of the page
	400/10		line 400 on page 10
>

H.RANG:


	HLPMSG <Summary of EDIT commands
 
note:	Parameter formats are given following "::" and "{}" surrounds
	any optional  parameters.  Meta-notions  defined in  "Syntax"
	are given surrounded by "<>" brokets.
 
A    Alter		::<range>
B    Backup - (same as E but leaves you at EDIT command level)
 BI  Do an EI command, without ending
 BJ  Do an EJ command, without ending
 BN  Do an EN command, without ending
 BU  Do an EU command, without ending
C    Copy		::<dest-position>,<range>
		or	::<dest-position>=<filespec>,<range>
		or	::<dest-position>=<filespec>/S
D    Delete		::<range>
E    End (Exit to EXEC level)	::{$<filespec>}
 EN  Suppress ".Qxx/.Zxx" file creation
 EI  Insert identifying line before ending
 EJ  Delete first line of file and do an EI command
 EQ  Quit (while you're ahead)
 EU  Unsequence output file (ie. remove line numbers)
F    Find		::<string>${<range>}{,<foptions>}
G    Go (Exit and do last LOAD-class command)
 GI  Do an EI command, and then go
 GJ  Do an EJ command, and then go
 GN  Do an EN command, and then go
 GU  Do an EU command, and then go
H    Help (enter help mode)
I    Insert		::<position>
			::<position>,<increment>
			::<position>!<line-count>
J    Join		::<position>
JU   Justify		::<range>,<local lmar>,<local rmar>,<local pmar>
 JC  Center
 JF  Fill--JU w/o padding to right margin
 JL  Left
 JR  Right
K    Kill page mark	::/<page number>
L    List (on LPT)	::<range>{,S}
M    Mark		::<position>
N    Number		::{<increment>}{,<range>{,<start>}}
 NA  Add <increment> to <range>
 NP  Preserve line numbers over page marks
P    Print		::{<range>{poptions}}
R    Replace		::{<range>,{<increment>}}
S    Substitute		::<old string>$<new string>${<range>}{,<soptions>}
T    Transfer		::<dest-position>,<range>
V    inVert case	::<range>
 VV  ditto--upper to lower and vice versa
 VL  make all letters lowercase
 VU  make all letters uppercase
X    eXtend		::<range>
?    Types list of available commands
<LF> Same as P.+1
$ [<ESC>] Same as P.-1
.    Move pointer	::<position>
@<filespec>	Indirect command file
=<switch>	print <switch> setting
/<on-off-switch>		set <on-off-switch> (turn it on)
/<value-switch>:<number>	set <value-switch> to <number>
>

H.COM:


	HLPMSG <Keyboard character representations
 
		  Stanford
Ascii	'x  ^x	  AI Lab name		Comments
-----	--  --	  ---------------	--------
   0		  nul			ignored
   1	'!  ^A	  down-arrow
   2	'"  ^B	  alpha
   3	'#  ^C	  beta			*
   4	'$  ^D	  and
   5	'%  ^E	  not			**
   6	'&  ^F	  member,epsilon
   7	'?  ^G	  pi			bell character, same as '<backslash>
  10	'(  ^H	  lambda		*,backspace character
  11	    ^I	  tab
  12	    ^J	  linefeed		becomes <cr><lf>
  13	    ^K	  vertical tab		ignored
  14	    ^L	  formfeed		ignored
  15	    ^M	  carriage return	becomes <cr><lf>
  16	')  ^N	  infinity		**
  17	'*  ^O	  del			*,**
  20	'+  ^P	  horseshoe-right	*
  21	',  ^Q	  horseshoe-left	*
  22	'-  ^R	  horseshoe-down	*
  23	'.  ^S	  horseshoe-up		*
  24	'/  ^T	  for-all		*,**
  25	'0  ^U	  there-exists		*
  26	'1  ^V	  circlex
  27	'2  ^W	  iff			*
  30	'9  ^X	  underline		*
  31	'6  ^Y	  right-arrow
  32	'4  ^Z	  tilde
  33	'=  ^[	  not-equals		*,<esc>
  34	'<  	  <=
  35	'>  ^]	  >=
  36	'7  ^^	  equivalence		**
  37	'8  ^_	  or,<eol>		37 from KB becomes <cr><lf>
 ...					'8 from KB stored as 37
 140	'@  `	  accent breve
 ...
 173	'[  {	  left-curly-bracket
 174	':  |	  vertical stroke	**
 175	']  }	  right-curly-bracket
 176	'^   	  (Decus tilde)		or '3,	prints as '^ not '3
 177	'_	  rubout		*
 
*  These are  EDIT  or	Tops-20  control characters  for  editing  or
	interrupts;  to enter any of them into text, the 'x form must
	be typed.
 
** These have special meaning in Find or Substitute command-strings:
	'% not;  ') any #;  '* meta;  '/ any ch;  '7 quote;  | any sep.
>

H.KEY:


	HLPMSG <Init-file

When EDIT starts up, it looks for a file "SWITCH.INI" in the logged in
directory.  This file contains various settable switches that the user
has deemed useful.  Below is an example of a command line.

edit /expert /window:20 /save:30 /isave:50

>

H.INIT:



COMIGN:	PUSHJ P,SCAN		;IGNORE TOTALLY!
	TRNN FL,TERMF		;CHECK FOR VALID TERMINATOR
	JRST COMIGN		;KEEP PASSING
	JRST COMND


	HLPMSG <. Command	(Move pointer)
 
.<position>

Assumes ^/^ (the very beginning) if <position> is not specified.

>
>; IFN STANSW

PMOVE:	SETZM LOLN
IFN STANSW,<
	CALL SCAN
	TRNE FL,TERMF		;DEFAULT TO ^/^ INSTEAD OF ERROR --OO7
	 JRST PMVTOP
	CALL GET1
>; IFN STANSW
IFE STANSW,<
	PUSHJ P,GET1S		;GET A POS.
>; IFE STANSW
	TRNE FL,TERMF		;CHECK ARG
	SKIPN HILN
	NERROR ILC
	MOVE T1,HIPG
	MOVEM T1,DPG
	MOVE SINDEX,HILN	;PERFORM SEARCH
	PUSHJ P,FIND
	MOVE T2,CPG		;FIND THE ONE WE WANT
	CAME T2,HIPG
	NERROR NSP
	CAME T1,HILN
	NERROR NLN
	MOVEM T1,CLN		;MAKE IT CURRENT
	MOVEM T2,CPGL
	JRST COMND

IFN STANSW,<			;IN CASE
PMVTOP:	MOVEI T2,1		;/^ IS PAGE 1
	MOVEM T2,DPG		;SEARCH FOR ^ ON PAGE 1
	CALL EVALUP
	MOVEM T1,CLN		;MAKE IT CURRENT
	MOVE T2,CPG		;SET CURRENT PAGE
	MOVEM T2,CPGL
	JRST COMND
>; IFN STANSW

QUEST:	PUSHJ P,SCAN		;CHECK FOR VALID TERMINATOR
	TRNN	FL,TERMF
	NERROR	ILC		;GIVE ERROR IF HE DESERVES IT
	OUTSTR	[ASCIZ / Commands are:/]
	MOVSI	T1,-CMDLG	;GET LENGTH OF COMMAND TABLE
QUEST1:	MOVE	T2,CMD3(T1)	;GET LOCATION
	OCRLF
	OUTSTR	(T2)		;PRINT THE STRING
QUEST2:	AOBJN	T1,QUEST1	;KEEP GOING
	JRST	COMND
 

SUBTTL	PRINT

;PRINT LINES SPECIFIED

IFN STANSW, <
	JUMP	[ASCIZ "
P	Print - <range>,S,W,E,F - Print the specified lines on the terminal.

		If ,S is specified, omit (suppress) the line numbers.
		If ,W is specified, pause before each page (e.g. while
		  you change paper); resume by typing Q (to abort), G
		  (to resume printing with no more pauses), <RETURN>
		  (to print the next page).
		If ,E is specified, simulate formfeeds at end of each page.
		Specifying ,F is equivalent to ,E,W,S.

"]

	HLPMSG <P Command	(Print)
 
P{<range>}{,S}{,W}{,E}{,N}
 
Print  the specified  lines.   If  ,S  is specified,  omit  the  line
numbers. If  ,W is specified, pause before each  page (e.g. while you
change paper);  resume by typing Q (to abort),  G (to resume printing
with  no more pauses), <RETURN>  (to print the next  page).  If ,E is
specified, simulate formfeeds at  end of each page.  Specifying ,F is
equivalent to ,E,W,S.

>
>; IFN STANSW
PRINT:	SETZM LOLN	;AS A FLAG IN CASE OF /C OR /A,/C
	TRZ	FL2,SUPN
IFN PPNTSW, <
	MOVEI	JF,0		;CLEAR SPECIAL FLAGS
	MOVEI T2,1
	MOVEM T2,LSTCNT
	SETZM LOGPG		;CLEAR COUNTERS AND THINGS
>; IFN PPNTSW
	PUSHJ P,SCAN
	CAIE C,","	;IS THERE A SWITCH?
	JRST PRNT5	;NO
	PUSHJ P,PRNSCN	;SCAN FOR SWITCHES
PRNT5:	TRNE FL,TERMF
	JRST	[MOVE T1,CLN	;MAKE P WITH NO ARGS DO P.!<PLINES>
		 MOVEM T1,LOLN
		 MOVE T1,CPGL
		 MOVEM T1,LOPG
		 MOVE T1,PLINES
		 MOVEM T1,SVCNT
		 MOVEI T1,1	;(195) FLAG FOR PNOARG IF NEEDED
		 SKIPE PNOARG	;(195) DO WE NEED TO SKIP?
		 MOVEM T1,PNOARG;(195) YES, SET FLAG SO WE DO	
		 TRO FL,CNTF
		 MOVE T1,DTYPE		;TERMINAL TYPE
		 XCT CURUP(T1)		;CURSOR UP FCN
		 OUTCHR [15]
		 JRST PRCNT]
	PUSHJ P,GET2	;GET A DOUBLE STRING
	CAIN C,","	;(195) IS THERE A SWITCH?
	PUSHJ P,PRNSCN	;(195) YES, LOOK AT THEM
	TRNN FL,TERMF	;(195) DID IT END WITH A TERMINATOR
	NERROR ILC	;(195) NO, ILLEGAL
	SETZM PNOARG	;(195) NOT P WITH NO ARGS
PRCNT:	TRZ FL,LINSN	;USE THIS AS A FLAG TO CHECK FOR NULL RANGE
	TRNE	FL2,NONUMF	;NEED TO SUPPRESS NUMBERS
	TRO	FL2,SUPN	;YES:
IFN PPNTSW, <
	TRNE	JF,EJECT!WAIT
	PUSHJ P,PGWT	;WAIT FOR USER!
>; IFN PPNTSW


RPGPRN:	MOVE T1,LOPG	;FIND THE FIRST LINE WANTED
	MOVEM T1,DPG	;SET IT AS THE ONE WE WANT
	MOVE SINDEX,LOLN	;PICK UP THE LINE
	PUSHJ P,FIND	;GO GET IT
	SKIPLE PNOARG	;(195) SKIP THIS LINE (ALREADY PRINTED)
	JRST PRNT4	;(195) YES START WITH NEXT
	SKIPE LOLN	;DID WE WANT TO PRINT AN ENTIRE PAGE
	JRST PRNT1	;NO, GO CHECK BOUNDS
	MOVE T2,CPG	;WHICH ONE ARE WE ON
	MOVEM T2,CPGL
	TRNN	FL2,SUPN
	PUSHJ P,PGPRN	;PRINT THE PAGE HEADER
	TRO FL,LINSN	;THIS CAN COUNT AS A LINE
PRNT1:	PUSHJ P,ONMOV	;CHECK TO SEE IF STILL IN RANGE
	JRST EPRNT	;NO, END
	TRO FL,LINSN	;WE HAVE SEEN ONE
	CAMN T1,PGMK	;IS IT A PAGE MARK?
	JRST PRNT3	;YES, DO SOMETHING SPECIAL
	MOVEM T1,CLN
	MOVEM T2,CPGL	;SAVE PAGE TOO
	MOVE T1,PNTR	;GET THE POINTER TO IT
	PUSHJ P,OUTLIN	;AND PRINT
IFN PPNTSW, <
	AOSN LSTCNT
	PUSHJ P,PAGEND	;END OF PAGE
>; IFN PPNTSW
PRNT4:	PUSHJ P,FINDN	;GET THE NEXT LINE
	JRST PRNT1	;AND CONTINUE
PRNT3:	MOVEM T2,CPGL
IFN PPNTSW, <
	SOS LSTCNT	;ADJUST FOR PAGE MARK
	PUSHJ P,PAGEND	;DO END OF PAGE ROUTINE
	SETZM LOGPG	;RESET LOGICAL PAGE COUNTER
>; IFN PPNTSW
	TRNE	FL2,NONUMF	;SPECIAL HACK IF NONUM MODE
	OUTCHR	[14]		;WON'T HE BE ...
	TRNN	FL2,SUPN	;UNLESS PRINTING A CLEAN COPY,
	PUSHJ	P,PGPRN		;GO PRINT A PAGE HEADER
	AOS	CPG
	MOVE	T2,[<ASCII /00000/>!1]
	MOVEM	T2,CLN		;SET LINE TO FIRST ON THAT PAGE
	JRST	PRNT4		;AND CONTINUE
EPRNT:	TRZN	FL,LINSN	;DID WE PRINT SOMETHING
	NERROR	NLN		;NO, ERROR
IFN PPNTSW, <
	PUSHJ	P,PAGEJT >	;EJECT PAGE
	TRNE	FL2,NONUMF
	TRZ	FL2,SUPN	;TURN IT OFF IF IN NONUM MODE
	JRST COMND	;YES, RETURN FOR COMMAND

;CHECK TO SEE IF OUT OF LIMITS SKIP RETURN IF OK

ONMOV:	JUMPE T1,CPOPJ	;0, MUST BE EOF SO ALL DONE
	PUSHJ	P,CHKREN	;CHECK REENTER
	POPJ	P,		;YES: SAY WE ARE THROUGH
ONMOV1:	MOVE T2,CPG	;GET THE CURRENT PAGE
	CAMN T1,PGMK	;ARE WE AT A PAGE MARK?
	ADDI T2,1	;YES, TREAT AS NEXT PAGE
	TRNE FL,CNTF	;IS THIS A ! TYPE COMMAND?
	JRST ONCNT
	CAMLE T2,HIPG	;HOW DOES IT COMPAGE WITH UPPER LIMIT
	POPJ P,		;HIGHER, ALL DONE
	CAME T1,PGMK	;IF PAGE MARK, DO NOT COMPARE LINE
	CAME T2,HIPG	;OR IF NOT ON LAST PAGE
	SKIPA
	CAMG T1,HILN	;ARE WE OUT OF LINES?
	AOS (P)	;SKIP RETURN ALL OK
	POPJ P,		;GO

ONCNT:	CAMN T1,PGMK	;DO NOT COUNT PAGE MARKS
	SKIPG SVCNT	;IF PAGE MARK, GIVE UP IF DONE
	SOSL SVCNT	;ARE WE OUT
	AOS (P)		;SKIP RETURN FOR OK
	POPJ P,

;HERE TO EJECT PAGE

IFN PPNTSW, <
PAGEJT:	TRNN	JF,EJECT	;EJECTING?
	POPJ P,		;NO: JUST RETURN
	MOVE T5,LSTCNT
	ADD T5,PAGESZ	;GET COUNT LEFT
	SUBI T5,FULLPG	;EJECT TO TOP OF PAGE
	TRNN	JF,WAIT		;IF NOT WAITING
	SUBI T5,1	;ONE MORE LINE
	SUBI T5,1	;HANDLE ZERO CASE
	MOVEI C,15	;PUT OUT CR
	PUSHJ P,OCHR
	JRST PUTLN1

PUTLN:	MOVEI C,12
	PUSHJ P,OCHR	;OUTPUT LF'S
PUTLN1:	CAMN T5,[-11]	;A BIT WEIRD
	PUSHJ P,PUTPG
	AOJL T5,PUTLN
	AOS LOGPG	;INCR LOGICAL PAGE
	PUSHJ	P,FORCE		;OUTPUT
	POPJ P,

;HERE TO WAIT FOR BOTTOM OF PAGE

PAGEWT:	TRNN	JF,WAIT	;WAITING?
	JRST NOWAIT	;NOPE!
PGWT:
	OUTSTR [BYTE (7)10,10,10,10,0]
READ1:	PUSHJ P,GNCH	;GET NEXT CHAR
	CAIE C,"G"
	CAIN C,"g"
	TRZ	JF,WAIT
	CAIE C,"Q"
	CAIN C,"q"
	JRST QPRINT
	CAIE C,12	;LF?
	JRST READ1
NOWAIT:	MOVN T5,PAGESZ	;RESET LINE COUNT
	MOVEM T5,LSTCNT
	POPJ P,

QPRINT:	PUSHJ P,GNCH
	CAIE C,12	;SKIP TO LF
	JRST QPRINT
	JRST COMND
	;;;; STILL IN IFN PPNTSW

;HERE ON END OF PAGE

PAGEND:	PUSHJ P,PAGEJT	;EJECT A PAGE
	JRST PAGEWT	;AND GO WAIT

;ROUTINE TO OUTPUT FUNNY PAGE NUMBERS

PUTPG:	TRNN	JF,PGNOS	;ARE WE?
	POPJ P,
	MOVE T1,RMAR
	ADD T1,LMAR
	ASH T1,-1	;PUT OUT (R+L)/2 BLANKS
PUTPG1:
	OUTCHR [" "]
	SOJG T1,PUTPG1
	OUTCHR ["-"]
	MOVE T2,CPG		;CURRENT PAGE
	PUSHJ P,DPRNT
	MOVE T2,LOGPG		;LOGICAL PAGE
	JUMPE T2,PUTPG2
	OUTCHR ["."]
	PUSHJ P,DPRNT		;SUB-PAGE
PUTPG2:
	OUTSTR [BYTE (7)"-",15]
	POPJ P,
>	;;; END IFN PPNTSW

;PRINT SWITCH SCANNER

IFN PPNTSW, <
PRNSCN:	PUSHJ P,SCAN		;GET NEXT CHAR
	MOVS T1,ACCUM
	CAIN T1,(<SIXBIT /N  />)
	TRO	JF,PGNOS
	CAIN T1,(<SIXBIT /S  />)
	TRO	FL2,SUPN
	CAIN T1,(<SIXBIT /W  />)
	TRO	JF,WAIT
	CAIN T1,(<SIXBIT /E  />)
	TRO	JF,EJECT
	CAIN T1,(<SIXBIT /F  />)
	JRST	[TRO JF,EJECT!WAIT
		 TRO FL2,SUPN
		 JRST .+1]
	PUSHJ P,SCAN		;SCAN PAST IT
	TRNE FL,TERMF		;TERMINATOR
	JRST	[TRNN	JF,EJECT!WAIT!PGNOS
		 TRNE	FL2,SUPN
		 POPJ P,
		 NERROR ILC]
	CAIE C,","		;MORE?
	NERROR ILC
	JRST PRNSCN		;YES - GET EM
>; IFN PPNTSW

IFE PPNTSW, <
PRNSCN:	PUSHJ	P,SCAN		;GET NEXT ATOM
	MOVS	T1,ACCUM
	CAIE	T1,(<SIXBIT /S  />)
	NERROR	ILC		;ONLY LEGAL SW IS S
	PUSHJ	P,SCAN		;SCAN PAST IT
	TRNN	FL,TERMF	;MUST BE END
	NERROR	ILC
	TRO	FL2,SUPN	;SET FLAG
	POPJ	P,		;RETURN
>; IFE PPNTSW


PGPRN:	PUSH	P,T2		;SAVE PAGE #
	MOVE	T2,DTYPE	;GET TERMINAL TYPE
	XCT	CRLF(T2)	;CRLF BY TYPE
	OUTSTR	[ASCIZ /Page /]
	POP	P,T2		;RESTORE #
	PUSHJ P,DPRNT	;PRINT THE NUMBER IN T2
	OCRLF
	AOS LSTCNT
	AOS LSTCNT		;PAGE N - TAKES 2 LINES
	POPJ P,

;THE USUAL NUMBER PRINTER

DPRNT:	PUSH	P,T1		;SAVE T1
	MOVEI	T1,.PRIOU	;USE PRIMARY OUTPUT
	MOVEI	T3,^D10		;DECIMAL #
	NOUT
	  JRST	[MOVE T1,T3	;ERROR CODE TO T1
		 FJERR]
	JRST	T1POPJ		;RESTORE & RETURN


;CHARACTER OUTPUT

OCHR:	JUMPE	C,CPOPJ		;IGNORE NULLS
	MOVE	CS,CTBL(C)	;GET THE MAJIC BITS
	TLNE	CS,LETF_16	;CHECK FOR LETTER
	TDC	C,CASEBT	;AND CHANGE CASE AS NECESSARY
	TRNE	FL2,SUPN	;IS THIS A PRETTY PRINT? IF SO NO ' CONVERSION
	JRST	OCH2
	PUSH	P,C		;SAVE THE CHARACTER
	LDB	C,[POINT 7,CTBL(C),10]	;GET PRINT EQUIV.
	JUMPE	C,OCH1		;NONE, PRINT ORIGINAL
	TDNE	CS,[XWD LETF_16,M37]	;IS THIS A LETTER OR SPECIAL
	TRNN	FL,M37F		;AND A MODEL 37
	TLNE	FL,QMODF
	JRST	[MOVE C,(P)	;GET ORIG CHAR
		 CAIL C,40	;CHECK FOR CONTROL CHAR
		 JRST OCH1	;NO - JUST PRINT IT
		 ADDI C,100
		 MOVEM C,(P)	;CONVERT TO PRINTING CHAR
		 MOVEI C,"^"
		 JRST OCH0]
	MOVEM	C,(P)		;SAVE IN STACK
	MOVEI	C,"'"
OCH0:	PUSHJ	P,OCH2		;PUT OUT CHR
OCH1:	POP	P,C		;GET CHAR TO PRINT
OCH2:	SOSG	TTOCNT
	PUSHJ	P,FORCE
	IDPB	C,TTOPNT
	POPJ	P,		;AND RETURN


OUTLIN:	TRNE	FL2,SUPN!NONUMF	;ARE WE SUPPRESSING LINE NUMBERS?
	AOS	T1		;YES, SKIP IT
	HRLI	T1,(<POINT 7,0>);GET SET TO PRINT A LINE
	TRNE	FL2,SUPN!NONUMF	;IF SUPPRESSING LINE NUMBERS
	IBP	T1		;ALSO SUPPRESS THE TAB WHICH FOLLOWS
	SETOM	PNOARG		;(195) REMEMBER FOR LATER
OUTL1:	ILDB	C,T1		;GET A CHR
	JUMPE	C,FORCE		;QUIT ON NUL
	PUSHJ	P,OCHR		;AND PRINT IT
	CAIN	C,14		;(205) FORMFEED?
	JRST	FORCE		;(205) YES
	CAIE	C,12		;IS IT LINE FEED
	JRST	OUTL1		;NO, CONTINUE
		;;;		;FALLIN FORCE

;ROUTINE TO DUMP TTY BUFFER AND SET UP FOR NEXT

FORCE:	PUSH	P,C		;SAVE CURRENT CHAR
	MOVEI	C,0		;GRNTEE NULL
	IDPB	C,TTOPNT	;AT END OF STRING
	OUTSTR	TTOBUF		;DUMP IT
	MOVEI	C,^D80		;NEW COUNT
	MOVEM	C,TTOCNT
	MOVE	C,[POINT 7,TTOBUF]
	MOVEM	C,TTOPNT	;AND PNTR
	POP	P,C		;RESTORE C
	POPJ	P,		;AND RETURN


SUBTTL	END ROUTINE

;CODE TO FINISH OFF EDIT

ASVINS:	SKIPA	T1,HILN		;LAST LINE INSERTED
ASVREP:	MOVE	T1,LOLN		;...
	MOVEM	T1,SVLNUM	;SAVE FOR RESTART
	TLO	FL2,AUTOF	;SET TO DO AUTO SAVE
	SKIPE	ALTSN		;NEED CRLF?
	OCRLF			;YEP
	OUTSTR	[ASCIZ "[Doing auto-save, please wait.]"]
	OCRLF

IFN STANSW, <
	JRST	SVCOD		;SKIP OVER THE IN-LINE LITERAL
	HLPMSG <B Command	(Backup)
 
variations on the basic command:
 BI  Do an EI command, without ending
 BJ  Do an EJ command, without ending
 BN  Do an EN command, without ending
 BU  Do an EU command, without ending
 
This command is  the same as E but leaves  you at EDIT command level.
It  is used to write  your file out to	the disk in so	you save your
typing	and editing if the  system should crash or  you should make a
big mistake of some unforseen kind.
 
However  if you  have  already	made  the  big mistake,  you  may  be
unwittingly writing  out  a  file that	has  less  use than  the  one
currently on the disk. If you  have not logged off on any terminal in
the  meantime, and you	also have not "expunged"  deleted disk files,
you can still undelete the earlier versions and save your work.
 
Alternatively, you might want to  use the C command to copy a section
out  of the version that  is still available in  your directory as it
was before you started editing.
>
>; IFN STANSW
SVCOD:	TLNE	FL,SRCOP	;IF INSIDE COPY
	JRST	DSCOP		;TREAT LIKE AN E
	TRO	FL2,SVIT	;SET TO DO A SAVE
	MOVE	T1,SSAVEN	;RESET ALL CNTRS
	MOVEM	T1,SAVEN
	MOVE	T1,SISAVN	;RESET ISAVE PARAM
	MOVEM	T1,ISAVEN	;...
	PUSH	P,UNSEQF	;SAVE CURRENT VALUE
	SKIPN	UNSEQF		;CHECK FOR UNSEQ
	JRST	SVCOD1		;PROCEDE
	TRNN	FL,EXTOG	;ONLY PRINT IF NOVICE
	OUTSTR	[ASCIZ "[WARNING: Sequence numbers preserved.]
"]
	SETZM	UNSEQF
SVCOD1:	TRNN	FL,READOF	;READ-ONLY MODE?
	JRST	END0		;NO - CONTINUE
	MOVE	T1,[ORGBLK,,NEWBLK]
	BLT	T1,NEWBKE	;YES - SET UP NEWBLK THEN
	JRST	END0		;CONTINUE CMD


IFN STANSW, <
	HLPMSG <G Command	(Go  [Exit and do last LOAD-class command])
 
G{$<filespec>}
 
variations on the basic command:
 GI  Do an EI command, and then go
 GJ  Do an EJ command, and then go
 GN  Do an EN command, and then go
 GU  Do an EU command, and then go
 
N	Ends the editing  session,  saves  the	results  in  the  file
	name.typ,  then  executes your last COMPILE, LOAD, EXECUTE, or
	DEBUG command.	 G (or GU or GN, etc.) followed by ESC prompts
	you  for a  new file name,  and uses  that name instead of the
	name you specified on the CREATE or EDIT command.
>
>; IFN STANSW
IFE STANSW, <
GEND:	TLOA	FL,GCOM		;GO
>; IFE STANSW

IFN STANSW, <
GEND:	TLO	FL,GCOM		;GO
	JRST	END0		;SKIP OVER LITERAL IN HLPMSG
	HLPMSG <E Command	(End Edit and Exit to Exec level)
 
E{$<filespec>}		[here $ denotes ESC]
 EN  Suppress ".Qxx/.Zxx" file creation if earlier requested
 EI  Insert identifying line before ending
 EJ  Delete first line of file and do an EI command
 EK  Remove line numbers and kill page marks, then end Edit	
 EQ  Quit and do not save any changes made in current Edit session
 EU  Unsequence output file, i.e., remove line numbers
>
>; IFN STANSW
ENDIT:	TLZ	FL,GCOM		;NORMAL TYPE END
END0:	TLNE	FL,SRCOP
	JRST	DSCOP		;FINISH UP THE COPY COMMAND
	TLO	FL2,NORENT	;DISABLE REENTER
	TLZ	FL2,RENTF
	TRNE	FL,READOF	;IF READ ONLY
	JRST	ENDRO		;DO SPECIAL END CODE
	TLZ	FL2,BELLF	;DISABLE <BELL><BELL>
	PUSHJ	P,NSCAN		;SETUP NEWBLK
	NERROR	ILC		;BAD SYNTAX
	SKIPN	UNSEQF
	TRNE	FL,NEWFL
	TLO	FL2,PCHGF!FCHGF	;CHANGED IF UNSEQ OR NEW NAME
	TLNN	FL2,FCHGF
	JRST	[OCRLF
		 OUTSTR [ASCIZ "[No changes.]"]
		 OCRLF
		 CALL RLSINP	;RELEASE INPUT
		 CALL DELOUT	;DELETE OUTPUT FILE
		 JRST ENDEND]
	JRST	END1

;CODE TO HANDLE 'E' COMMANDS IN R/O MODE

ENDRO:	PUSHJ	P,GNCH		;GET A CHAR
	ANDI	C,137		;FORCE UPPER
	CAIE	C,"Q"		;QUIT OK ALSO
	MOVEM	C,SAVC		;BACKUP IF NOT Q
	PUSHJ	P,SCAN		;CHECK FOR EOL
	TRNN	FL,TERMF
	NERROR	ILC
	CALL	RLSINP		;RELEASE INPUT
	JRST	ENDEND		;JUST QUIETLY EXIT


END1:	PUSHJ	P,OCOMPL	;COMPLETE FILE COPY
	SKIPE	T1,ICRJFN	;CLOSE INPUT FILE
	CALL	DOCLSR		;  AND RELEASE JFN
	SETZM	ICRJFN		;RESET INFO
	SKIPE	AUXFLG		;IF NO AUX FILE
	TLNE	FL2,PCHGF	; AND NO CHANGES
	JRST	[PUSHJ P,OUTFIN	;PURGE OUTPUT BUFFERS
		 RLJFN		;RELEASE JFN
		   FJERR
		 SETZM OCRJFN	;SAY NONE
		 JRST END1A]
	SETZM	AUXFLG		;NO AUX FILE ANYMORE
	CALL	DELOUT		;DELETE OUTPUT FILE NOW
	HRROI	T1,OCRASZ
	HRROI	T2,ICRASZ
	MOVEI	T3,0
	SOUT			;REAL FILE NAME IN OCRBLK


END1A:	TRNE	FL,NEWFL	;OUTPUTTING TO NEW <DIR>FIL.EXT?
	JRST	END2		;YES, SEE IF OUTPUT FILE EXISTS
	SKIPN	CREATF		;NO BACKUP REQUIRED IF CREATING
	SKIPN	BAKF		;/BAK SET?
	JRST	END4		;NO, JUST RENAME AND EXIT
	MOVE	T2,ORGFIL	;INPUT FILE (IF PRESENT)
	MOVSI	T1,(GJ%OLD!GJ%SHT)
	PUSHJ	P,GTJFNX	;PEEK
	  JRST	END4		;GIVE UP
	MOVEM	T1,ORGJFN	;SAVE JFN
	MOVE	T2,T1		;COPY TO T2
	MOVE	T3,[2B2+2B5+1B8+1B35]
	HRROI	T1,LIBUF2	;PLACE TO BUILD NAME
	JFNS			;GET DEV:<DIR>NAME
	MOVE	T5,T1		;SAVE PNTR IN T5
	HRLI	T3,(1B11)	;BIT FOR EXTN
	JFNS			;GET IT
	EXCH	T1,T5		;SAVE PNTR GET OLD
	IBP	T1		;ADVANCE OVER .
	MOVEI	T2,"Q"		;ASSUME /BAK
	SKIPLE	BAKF		;UNLESS ITS /OLD
	MOVEI	T2,"Z"		;...
	IDPB	T2,T1		;CHANGE TO .QXX
	EXCH	T1,T5		;SAVE THIS AND RESTORE END PNTR
	MOVEI	T2,0		;GRNTEE NULL EVEN IF ALREADY THERE
	IBP	T1
	IDPB	T2,T1		;...
	SKIPG	BAKF		;IF /OLD THEN DO IT THE HARD WAY
	JRST	END1B		;EASY IF /BAK
	HRROI	T2,LIBUF2	;FILESPEC
	MOVSI	T1,(GJ%OLD!GJ%SHT)
	PUSHJ	P,GTJFNX	;SEE IF .ZXX EXISTS
	  JRST	END1B		;NO - GENERATE .ZXX
	RLJFN			;YES - RELEASE JFN
	  JFCL
	MOVE	T1,T5		;RESTORE BP
	MOVEI	T2,"Q"		;AND CHANGE EXT TO .QXX
	DPB	T2,T1		;...
END1B:	HRROI	T2,LIBUF2	;DESIRED FILESPEC
	MOVSI	T1,(GJ%FOU!GJ%SHT)
	PUSHJ	P,GTJFNX	;GET OUTPUT SPEC
	  FJERR			;CAN'T HAPPEN
	PUSH	P,T1		;SAVE IT TEMPORARILY
	HRLI	T1,.FBPRT(CF%NUD) ;WANT TO CHANGE PROTECTION
	MOVEI	T2,-1		;ONLY THE RIGHT HALF
	MOVE	T3,ORGPRT	;GET PROTECTION OF ORIGINAL FILE
	CHFDB			;SET PROTECTION OF THIS FILE TO IT
	  ERJMP	.+1		;IGNORE ERROR
	POP	P,T2		;RESTORE JFN
	MOVE	T1,ORGJFN	;OLD SPEC JFN
	RNAMF			;RENAME IT
	  JRST	[OUTSTR [ASCIZ "%Backup file protected - ignored."]
		 OCRLF
		 JRST END4]
	MOVE	T1,T2		;COPY JFN
	RLJFN			;FLUSH IT
	  JFCL
	JRST	END4		;FINISH UP


END2:	TLO	FL2,NORENT	;GRNTEE NO ^C
	TLZ	FL2,RENTF
	MOVSI	T1,(GJ%SHT!GJ%OLD!GJ%NS)
	MOVE	T2,NEWFIL	;NEW FILE NAME
	PUSHJ	P,GTJFNX	;TRY FOR IT
	 JRST	END4		;ASSUME NOT THERE
	RLJFN			;RELEASE JFN NOW
	  FJERR
IFN STANSW, <
	TRNE	FL,EXTOG	;NO CONFIRM FROM EXPERT.  --OO7
	 JRST	END4
>; IFN STANSW
	TLZ	FL2,NORENT	;ALLOW ^C
	OUTSTR	[ASCIZ /
Output file exists - delete? /]
	PUSHJ	P,CONFRM	;ASK HIM IF OK
	  JRST	ASKNAM		;HE SAID NO - ASK FOR NEW NAME
	TLO	FL2,NORENT	;OFF ^C
	TLZ	FL2,RENTF
	JRST	END4		;NOW TREAT IT AS NOT THERE


END4:	MOVSI	T1,(GJ%SHT!GJ%OLD!GJ%TMP)
	MOVE	T2,OCRFIL	;FILE WE WANT
	PUSHJ	P,GTJFNX	;TRY FOR IT
	  FJERR			;LOSAGE
	MOVEM	T1,OCRJFN	;SAVE JFN
	MOVSI	T1,(GJ%SHT)
	MOVE	T2,NEWFIL	;NEW FILE NAME
	PUSHJ	P,GTJFNX	;GET ONE
	  FJERR			;BETTER WIN
	MOVEM	T1,NEWJFN	;SAVE JFN
	HRLI	T1,.FBPRT(CF%NUD) ;GET INDEX OF PROTECTION WORD IN FDB
	MOVEI	T2,-1		;CHANGE ONLY RIGHT HALF
	MOVE	T3,ORGPRT	;GET PROTECTION OF ORIGINAL FILE
	TRNN	FL,NEWFL	;CREATING NEW VERSION?
	CHFDB			;YES, SET PROTECTION TO ORIGINAL
	  ERJMP	.+1		;IGNORE ERRORS
	SKIPE	UNSEQF		;SKIP IF NOT UNSEQUENCING
	JRST	UNSEQ		;GO UNSEQUENCE
IFE STANSW, <
	PUSHJ	P,ENDNAM	;PRINT FINAL NAME
>; IFE STANSW
	MOVE	T2,NEWJFN	;FOR RENAME
	MOVE	T1,OCRJFN	;GET JFN OF EXISTING FILE
	RNAMF			;RENAME IT
IFN STANSW, <
	 JRST	[ CAIE	T1,RNAMX1 ;DID USER TRY TO RENAME ACROSS DEVICES?
		  FJERR		;NO, SOMETHING ELSE, SO DIE
		  OUTSTR [ASCIZ "%Cannot rename files across structures"]
		  OCRLF
		  OUTSTR [ASCIZ "Please specify another file name "]
		  JRST	ASKNAM ];PROMPT AT TTY FOR NEW FILE NAME
	PUSHJ	P,ENDNAM	;PRINT FINAL NAME
>; IFN STANSW
IFE STANSW, <
	 FJERR			;BETTER NOT
>; IFE STANSW
	GTAD			;GET CURRENT DATE/TIME
	MOVEM	T1,LIBUF2	;TEMP STORAGE
	MOVEM	T1,LIBUF2+1	;CREATION/WRITTEN
	SETZM	LIBUF2+2	;NEVER READ
	MOVE	T1,T2		;COPY JFN TO T1
	MOVEI	T2,LIBUF2	;POINT TO BLOCK
	MOVEI	T3,3		;3 WORDS LONG
	SFTAD			;SET STUFF
	  ERJMP	.+1		;IGNORE IF FAILURE
IFN STATSW, <
	CALL ST.SIZ >		;RECORD FILE SIZE
IFE STATSW,<
	RLJFN			;FLUSH JFN
	 FJERR >
	JRST	ENDEND		;AND FINISH UP

ENDNAM:	OUTSTR	[ASCIZ "
["]
	OUTSTR	NEWASZ		;PRINT NEW FILE NAME
	OUTSTR	[ASCIZ "]
"]
	RET

;ROUTINE TO DELETE CURRENT OUTPUT FILE

DELOUT:	SKIPN	OCRJFN		;ANY OUTPUT FILE?
	RET			;NO, DO NOTHING THEN
	CALL	UNMAPO		;UNMAP XTRA PAGE
	MOVE	T1,OCRJFN	;OUTPUT JFN
	CALL	DOCLSF		;CLOSE IT FIRST
	PJRST	DDELFR		;DELETE, EXPUNGE & RELEASE JFN

;ROUTINE TO RELEASE INPUT FILE

RLSINP:
	MOVEI	T2,<IBUF0>B44	;DELETE PAGE
	CALL	UNMAP
	MOVE	T1,ICRJFN	;CURRENT INPUT JFN
	PJRST	DOCLSR		;CLOSE & RELEASE


ENDEND:
IFN STATSW, <
	CALL	ST.CLO >	;UNMAP AND CLOSE STATISTICS FILE
	SKIPE	AUXFLG		;AUX FILE IN USE?
	PUSHJ	P,DELAUX	;YES: DETLETE IT
	MOVNI	T1,1		;SAY DELETE PAGE
	MOVE	T2,[.FHSLF,,<BUF0>B44]
	MOVE	T3,NPAGS	;GET SIZE OF WINDOW
	TLO	T3,(PM%CNT)	;SET FLAG
	PMAP			;CLEAR EDIT WINDOW
	PUSHJ	P,CLSALL	;CLOSE OFF THE FILES
	TRNE	FL2,SVIT	;CHECK FOR SAVE COMMAND
	JRST	RESTRT		;YES - GO RESTART
	TLNE	FL,GCOM		;IS THIS A 'GO'?
	JRST	CREFIT		;YES - DO RUN UUO
MONRET:	MOVEI T1,.TICCC		;DISABLE ^C TRAPS
	DTI
IFN STANSW,<
	CALL ONECHO
	SKIPL CNCLOK		;HERE ON ^C?
	 JRST CCJOB		;YES, GO DO ^C WITHOUT TRAPPING THIS TIME
	HALTF%
	JRST RESTRT		;RESTART ON CONTINUE --OO7

CCJOB:	PUSH P,T2		;ON ^C, INSTEAD OF DOING HALTF
	MOVEI T1,.PRIIN		;JUST PRETEND NEVER TRAPPED ^C
	MOVEI T2,"C"-100	;I.E. SIMULATE THE TYPING OF ^C
	STI%
	STI%
	POP P,T2
	MOVEI T1,^D2000		;HOPE 2 SECONDS IS LONG ENOUGH, ELSE WE WILL
	DISMS%			;BE CAUGHT TRAPPING ^C AGAIN.  SIGH...
>; IFN STANSW
IFE STANSW,<
	HALTF			;RETURN TO EXEC
	SKIPGE	CNCLOK		;SEE IF FROM ^C M OPTION
	JRST	MONRET
>; IFE STANSW
	MOVE T1,[.TICCC,,TRPCHN] ;RE-ENABLE ^C
IFN STANSW,<
	SKIPL	NOCTLC		;(211) SKIP IF NO ^C SET
>;IFN STANSW
	ATI
	JRST	CNCCON		;OK - IF FROM ^C

;ROUTINE TO DELETE AUX FILE IF ANY

DELAUX:	SETZM	AUXFLG		;SAY ITS GONE
	HRROI	T1,[ASCIZ "EDIT-BUFFER.IN"]
	HRROI	T2,LIBUF	;BUILD SPEC HERE
	CALL	MAKTMP		;...
	MOVSI	T1,(GJ%OLD!GJ%SHT!GJ%TMP)
	HRROI	T2,LIBUF
	PUSHJ	P,GTJFNX	;THERE?
	  RET			;DONT SWEAT IT
	TLO	T1,(DF%EXP)	;SET TO EXPUNGE ALSO
	DELF			;BLAT
	  JFCL			;DONT CARE
	RET			;RETURN

;HERE TO START WORLD OVER AFTER 'W'

RESTRT:	POP	P,UNSEQF	;NOW RESTORE ALL GOOD THINGS
	SETZM	RPGSW
	TDZ	FL,[TECOF,,BOF!EOF!EOF2!NEWFL]
	TLNN	FL2,FCHGF	;IFF THERE WERE CHANGES
	JRST	RSTRT1		;NO CHANGES
	MOVE	T1,[NEWBLK,,ORGBLK]
	BLT	T1,ORGBKE	;SET UP INPUT FILE NAME
	HRROI	T1,ORGASZ	;FORM PNTR
	MOVEM	T1,ORGFIL	;...
RSTRT1:	MOVE	T2,ORGFIL	;PNTR TO NAME
IFN STANSW,<
	TRO	FL2,SVIT	;TELL WORLD CONTINUE, NOT STARTUP --OO7
	SKIPN	QUITF		;IF REVERTED, CREATF UNCHANGED
	SETZM	CREATF		;DEFINITELY NOT CREATING
	SETZM	QUITF		;STOP QUITTING
	SKIPE	CREATF		;CREATING?
	SKIPA	T1,[GJ%SHT]	;YES
>; IFN STANSW
	MOVSI	T1,(GJ%OLD!GJ%SHT)
	PUSHJ	P,GTJFNX	;GET JFN OF INPUT
	  FJERR
	MOVEM	T1,ORGJFN	;SAVE
	PUSHJ	P,DEFNEW	;STEP TO NEXT GENERATION
IFE STANSW,<
	SETZM	CREATF		;NOT ANY MORE
>; IFE STANSW
	JRST	RPGRET		;AND START OVER


;ROUTINE TO CLOSE OFF ALL JFNS, EXCEPT POSSIBLY FOR THE INDIRECT
;FILE.

CLSALL:	TRNE	FL2,COMFLF	;READING FROM AN INDIRECT FILE?
	JRST	CLSAL2		;YES, HAVE TO WORK SOME
	SETO	T1,		;NOPE, CAN CLOSE ALL FILES
	CLOSF			;DO IT
	JFCL			;FORGET ERRORS
	POPJ	P,		;RETURN

CLSAL2:	SKIPE	T1,ORGJFN	;GET JFN IF ANY
	CLOSF			;CLOSE IT
	JFCL
	SKIPE	T1,NEWJFN	;GET JFN IF THERE
	CLOSF			;CLOSE
	JFCL
	SKIPE	T1,ICRJFN
	CLOSF
	JFCL
	SKIPE	T1,OCRJFN
	CLOSF
	JFCL
	SKIPE	T1,ALTJFN	;LAST ONE (DON'T CLOSE INDJFN)
	CLOSF
	JFCL
	POPJ	P,		;RETURN


NSCAN:	TLNE	FL2,AUTOF	;SPECIAL IF AUTO MODE
	RETSKP			;SKIP IF AUTO MODE
NSCAN0:	PUSHJ	P,GNCH		;LOOK FOR ARGS
	CAIE	C,200		;IF ESC , RIGHT TO FILE
	CAIN	C,":"		;IS IT A COLON
	JRST	NSCAN2		;YES: GO LOOK FOR FILE NAME
	ANDI	C,137		;FORCE UPPER CASE
	MOVEI	T1,0		;INITIAL VALUE
	MOVE	T2,[POINT 7,[ASCIZ "BQUKNIJ"]]
NSCNA:	ILDB	T3,T2		;GET CHAR
	JUMPE	T3,NSCAN3	;NOT FOUND IF NULL
	CAIE	C,(T3)		;MATCH?
	AOJA	T1,NSCNA	;NO -- TRY NEXT
	XCT	ENDTBL(T1)	;IF SW SEEN - DO ROUTINE
	JRST	NSCAN0		;LOOK FOR MORE

NSCAN2:	SKIPE	CREATF		;(196) ARE YOU CREATING A FILE?
	JRST	NSCNA2;  JUMPA? NSCNA2	;(196) YES SO SKIP THIS RTN
	MOVEI	ALTP,NEWBLK	;DATA FOR NEW OUTPUT SPEC
	MOVSI	T1,(GJ%FOU!GJ%MSG!GJ%CFM) ;WANT OUTPUT SPEC
	CALL	READNM		;GET NEW NAME
	  JRST	CKIND		;ERROR - MESSAGE PRINTED
	  JRST	COMND		;^U TYPED
	CALL	CKTERM		;GRNTEE EOL
	  RET			;ERROR RETURN
	TRO	FL,NEWFL	;SET NEW FILE
	MOVE	T1,NEWJFN	;JFN
	RLJFN			;DON'T WANT THIS
	  FJERR
	SETZM	NEWJFN		;...
NSCNA2:	RETSKP			;SKIP RETURN

NSCAN3:	MOVEM	C,SAVC		;BACK UP SCANNER
	PUSHJ	P,SCAN
	TRNE	FL,TERMF	;CHECK FOR TERM
	AOS	(P)		;PROPER - GIVE SKIP RETURN
	POPJ	P,		;NO TERM - LOSE


ENDTBL:
IFE STANSW, <
	SETZM	BAKF		;'B'
>; IFE STANSW
IFN STANSW, <
	SETOM	BAKF		;'B' - FORCE BACKUP FILE
>; IFN STANSW
	JRST	QUIT		;'Q'
	SETOM	UNSEQF		;'U'
	HRRZM	P,UNSEQF	;'K' - SET FLAG POSITIVE
	SETZM	BAKF		;'N'
	CALL	EIDENT		;'I'
	CALL	EJDENT		;'J'

ASKNAM:	SETZM	SAVCHR		;RESET SCAN
	CALL	CLRBFI
	SETZM	TTIPNT		;CLEAR INPUT
	MOVEI	C,200		;MAKE READNM ALLOW RECOGNITION
	MOVEI	ALTP,NEWBLK	;WHERE TO PUT INFO
	MOVSI	T1,(GJ%FOU!GJ%MSG!GJ%CFM)
	CALL	READNM		;GET NAME
	  JRST	ASKNAM		;ERROR - TRY AGAIN
	  JRST	ASKNAM		;^U - TRY AGAIN
	TRO	FL,NEWFL	;NEW FILENAME
	MOVE	T1,NEWJFN	;JFN
	RLJFN			;FLUSH IT
	  FJERR
	JRST	END2		;TRY AGAIN

;CODE FOR 'EQ' COMMAND. JUST DELETE TEMPS AND EXIT

QUIT:	POP	P,0(P)		;PRUNE PDL
	PUSHJ	P,SCAN		;MAKE SURE NO ARGS
	TRNN	FL,TERMF
	NERROR	ILC
	SKIPE	ICRJFN		;IF INPUT JFN
	CALL	RLSINP		;FLUSH INPUT FILE
	TRNN	FL,READOF	;DONT BOTHER IF R/O
	CALL	DELOUT		;DELETE OUTPUT FILE
IFN STANSW,<
	SETOM	QUITF		;DON'T ASSUME CREATF FALSE --OO7
>; IFN STANSW
IFE STANSW,<
	TRNN	FL2,SVIT	;CHECK FOR WQ
	JRST	ENDEND		;NO - JUST EXIT
>; IFE STANSW
	MOVE	T1,[ORGBLK,,NEWBLK]
	BLT	T1,NEWBKE	;FAKE OUT WORLD
	HRROI	T1,NEWASZ	;SET PNTRS
	MOVEM	T1,NEWFIL	;...
	JRST	ENDEND

;HERE TO DO UNSEQUENCING

UNSEQ:	MOVE	T1,[OCRBLK,,ICRBLK]
	BLT	T1,ICRBKE	;SETUP CURRENT INPUT
	MOVE	T1,ICRJFN	;GET JFN
	MOVEM	T1,CIPJFN	;SET UP CIP BLOCK
	MOVE	T2,[7B5+OF%RD]
	OPENF			;OPEN FILE
	  FJERR			;FATAL
	SETZM	CIPBYT		;CLEAR INPUT
	MOVEI	T1,IBUF0	;GRNTEE BUFFER
	MOVEM	T1,CIPBUF	;...
	MOVE	T1,NEWJFN	;OUTPUT JFN
	MOVE	T2,[7B5+OF%WR]
	MOVEM	T1,OPNJFN	;SAVE FOR ERROR
	OPENF			;OPEN FOR WRITE
	  CALL	OPNERR		;MAY BE DISK FULL
	CALL	UNSQO1		;SET UP COUNTS,PNTR ETC
	AOS	OPCNT		;ACCOUNT FOR XTRA SOSG
IFN CRYPSW, <
	MOVE	T1,NEWCOD	;GET CORRECT PSWS
	EXCH	T1,OCRCOD
	MOVEM	T1,ICRCOD	;...
>; IFN CRYPSW
	TDZ	FL,[COPFIL,,EOF];CLR FLAGS

UNSEQL:	CALL	GCHAR		;FETCH CHARACTER
	JUMPE	T3,UNSEQD	;DONE IF ZERO RETURNED
	SKIPLE	UNSEQF		;DOING EK INSTEAD OF EU?
	CAIE	T3,14		;AND CHAR IS A FORMFEED?
	JRST	.+2		;NO, NOTHING SPECIAL
	JRST	UNSEQL		;YES, EAT THE FORMFEED
	SOSG	OPCNT		;DECREMENT
	CALL	UNSEQO		;DUMP BUFFER
	IDPB	T3,OUPNT	;DEPOSIT CHAR
	JRST	UNSEQL		;LOOP UNTIL DONE

UNSEQD:	MOVE	T1,ICRJFN	;SET TO DELETE INPUT
	CALL	DOCLSF		;CLOSE FILE & RETAIN JFN
	CALL	DDELFR		;DELETE FILE & JFN
UNSQDR:	MOVE	T1,NEWJFN	;GET JFN
	HRROI	T2,OBUF0	;POINT TO BUFFER
	MOVNI	T3,1000*5+1	;- SIZE - 1
	ADD	T3,OPCNT	;CHRS LEFT +1
	JUMPGE	T3,UNSQD1	;SKIP OUTPUT IF EMPTY
	SOUT			;DUMP PARTIAL
	  CAI	UNSQDR		;RE-TRY ADDRS
UNSQD1:
IFN STATSW,<
	HRLI T1,(CO%NRJ) >	;STILL WANT THE JFN AROUND FOR ST.SIZ
	CALL	DOCLSR		;CLOSE OUTPUT FILE
IFN STATSW, <
	CALL	ST.SIZ >	;RECORD FILE SIZE
	CALL	UNMAPO		;RELESE PAGE
	CALL	ENDNAM		;PRINT FINAL NAME
	JRST	ENDEND

;ROUTINE TO DUMP OUTPUT BUFFER USING SOUT

UNSEQO:	PUSH	P,T3		;SAVE RET
UNSQOR:	MOVE	T1,NEWJFN	;JFN
	HRROI	T2,OBUF0	;WHERE ITS AT
	MOVNI	T3,1000*5	;1 PAGE OF CHARS
	SOUT			;SLURPP!
	  CAI	UNSQOR		;RETRY ADDRS
	POP	P,T3		;RESTORE
UNSQO1:	MOVEI	T1,1000*5	;SHOW EMPTY BUFFER
	MOVEM	T1,OPCNT	;...
	MOVE	T1,[POINT 7,OBUF0]
	MOVEM	T1,OUPNT
	RET			;RETURN

; 'EJ' - LIKE EI BUT DOES D^/^ FIRST

EJDENT:	MOVEI	T1,1		;TRY TO FIND FIRST LINE OF FILE
	MOVEM	T1,DPG
	MOVE	SINDEX,[<ASCII /00000/>!1]
	CALL	FIND		;...
	SKIPE	T1		;IF EOF
	CAMN	T1,PGMK		; OR PAGE-MARK
	JRST	EIDENT		;  THEN OK TO INSERT
	CALL	DODEL		;ELSE DELETE THE LINE
	SETZM	DELCNT		;SO NO MSG
;	JRST	EIDENT		;GO INSERT THE LINE

; 'EI' - Writes an identifying line at the top of the file
;	 before exiting.

EIDENT:	PUSHJ	P,GETIDN	;Write the line in LIBUF
	MOVEI	T1,1		;We want the first page
	MOVEM	T1,DPG		;To contain the line
	MOVE	SINDEX,[<ASCII /00000/>!1]
	PUSHJ	P,FIND		;See what line is first
	CAMN	T1,[<ASCII /00000/>!1] ;DOES 0 ALREADY EXIST
	NERROR	NORM		;Sorry, no room
	CAIN	T1,0		;Did we find EOF?
	 JRST [ RERROR	EMTY
		JRST EIDEN0]
	CAIE	T1,PGMK		;Is Page 1 empty?
	JRST	EIDEN1		;No
EIDEN0:	MOVE	T3,[<ASCII /00100/>!1] ;Yes, use 100
	JRST	EIDEN2		;And skip the bit twiddling
EIDEN1:	MOVE	T3,T1		;Move line number to T3
	PUSHJ	P,NUMCON	;Convert line number to int.
	CAILE	T1,^D100	;Is it .gt. 100 ?
	MOVEI	T1,^D101	;Yes, let's use 100 instead
	SUBI	T1,1		;Subtract one
	PUSHJ	P,ASCON		;Convert to line number
EIDEN2:	MOVEM	T3,LIBUF	;And put it first in the line
	PUSH	P,PNTR		;SAVE PNTR
	MOVEI	PNTR,LIBUF	;POINT TO BUFFER
	PUSHJ	P,GETLTH	;GET LENGTH OF LINE
	POP	P,PNTR		;RESTORE PNTR
	MOVEM	T1,NCNT		;Here is the new count
	SETZM	OCNT		;Set the old count to 0
	PUSHJ	P,INSED		;Go insert into buffer
	POPJ	P,		;Return to caller

; GETIDN - Subroutine to put the line in LIBUF

GETIDN:	CALL	ZBUF		;ZERO LIBUF AND RETURN BP IN T1
	MOVEI	C,11		;INSERT TAB
	IDPB	C,T1		;...
	MOVEI	C,";"		;First chr. is ;
	IDPB	C,T1		;Put it there
	PUSH	P,T1		;Save the pointer
	MOVSI	T1,(GJ%FOU!GJ%SHT) ;Get a JFN on output file
	MOVE	T2,NEWFIL	;NEW FILESPEC
	PUSHJ	P,GTJFNX	;GET A JFN FOR JFNS
	 JRST [ POP P,T1
		HRROI T2,[ASCIZ /?Unknown name?/]
		SETZ T3,
		SOUT
		OUTSTR [ASCIZ "%FILE NAME NOT AVAILABLE"]
		OCRLF
		JRST GETID5]
	MOVE	T2,T1		;Get the JFN
	POP	P,T1		;Retrieve the pointer
	PUSH	P,T2		;But, save the JFN
	MOVE	T3,[2B2+1B5+1B8+1B11+1B14+1B35] ; Print it right
	JFNS			;Send it to LIBUF2
	MOVE	T2,T1		;Save the pointer in T2
	POP	P,T1		;Retrieve the JFN
	RLJFN			;Release the JFN
	  FJERR
	MOVE	T1,T2		;Get the pointer
GETID5:	HRROI	T2,[ASCIZ /, /]
	SETZ	T3,
	SOUT
	SETO	T2,
	SETZ	T3,
	ODTIM			;Output the date and time
	HRROI	T2,[ASCIZ /, Edit by /]
	SETZ	T3,
	SOUT			;And the next phrase
	PUSH	P,T1
	GJINF			;Get logged-in directory no.
	MOVE	T2,T1		;Put in T2 for DIRST
	POP	P,T1
	DIRST			;Write user name
	 JRST [ HRROI T2,[ASCIZ /Unknown user/]
	        SETZ T3,
		SOUT
		JRST .+1]
	HRROI	T2,[ASCIZ /
/]
	SETZ	T3,
	SOUT			;Finish with <CR><LF>
	RET


SUBTTL	SOME GENERAL PURPOSE STUFF

;SOME MORE GENERAL ROUTINES


RDLIN:	CALL	ZBUF		;CLEAR LIBUF AND RETURN T1
	MOVEI	T2,5*MXWPL-2	;SET FOR AVAILABLE SPACE
	MOVEI	C,11		;START WITH A TAB
	JRST	RDL3
RDL1:	PUSHJ	P,GNCH		;GET ANOTHER CHARACTER
	CAIN	C,15		;IGNORE RETURN
	JRST	RDL1
	CAIN	C,14		;FF - TREAT AS SPECIAL
	JRST	[OCRLF		;GIVE CRLF
		 CAIN T2,5*MXWPL-3
		 IDPB C,T1	;SAVE IT IF EMPTY LINE
		 JRST RDL2]
	CAIN	C,12		;LINE FEED IS THE ONLY PROPER END
	JRST	RDL2
	CAIE	C,200		;ALTMODE IS A SPECIAL CASE
	JRST	RDL3		;NOT ALTMODE
	SETOM	ALTSN		;FLAG ALTMODE SEEN FOR I AND R
	CAIE	T2,5*MXWPL-3
	JRST	RDL2		;DO END OF LINE STUFF
	POPJ	P,		;EMPTY LINE RETURN

RDL3:	IDPB	C,T1		;PUT IT IN THE BUFFER
	SOJGE	T2,RDL1		;CHECK FOR OVERFLOW AND CONTINUE
	RERROR	LTL		;LINE IS TOO LONG
	POPJ	P,		;NON-SKIP RETURN

RDL2:	MOVEI	C,15		;PUT IN A CR-LF
	IDPB	C,T1
	MOVEI	C,12
	IDPB	C,T1
	HRRZS	T1		;NOW GET THE SIZE
	SUBI	T1,LIBUF-1
	AOS	(P)		;SKIP RETURN IF OK
	POPJ	P,		;AND RETURN

;ROUTINE TO CLEAR LIBUF AND RETURN BP IN T1

ZBUF:	SETZM	LIBUF+1		;FIRST WORD TO CLEAR
	MOVE	T1,[LIBUF+1,,LIBUF+2]
	BLT	T1,LIBUF+MXWPL+1 ;ZOT
	MOVE	T1,[POINT 7,LIBUF+1]
	POPJ	P,		;RETURN

;ROUTINE TO RETURN LENGTH OF LINE IN T1

GETLTH:	MOVE	T1,PNTR		;GET THE LENGTH OF THE LINE POINTED AT
	ADDI	T1,1
GETLN1:	SKIPN	T2,(T1)		;ANY END IS GOOD ENOUGH
	JRST	GETLN2
	TRNN	T2,1		;SEQ-NUM?
	AOJA	T1,GETLN1
GETLN2:	SUB	T1,PNTR		;FIND LENGTH
	POPJ	P,		;AND RETURN

;OUTPUT SEQUENCE NUMBER-TAB HACK

OUTSN:	MOVEM	T1,SQBUF	;PUT IT IN SPACE FOLLOWED BY A TAB
	OUTSTR	SQBUF
	POPJ	P,


ASCIAD:	AND	T2,K2A		;CONVERT TO NUMBERS
	IOR	T1,K4A		;MAKE SURE THIS IS IN DIGIT FORM
	ADD	T1,K1A		;GET EACH DIGIT IN RANGE 166 TO 177 FOR CARRY
	ADD	T2,T1		;SUM
	AND	T2,K3A		;GET RID OF 100 BITS IF THERE
	MOVE	T1,K4A		;FIND OUT WHICH ONES NEED SUBTRACTING
	AND	T1,T2
	ASH	T1,-3		;CONVIENIENTLY THEY NEED 6 SUBTRACTED
	SUBM	T2,T1		;SO DO IT
	IOR	T1,K4A		;AND RECONVERT TO DIGITS
	POPJ	P,		;WE HAVE ADDED THE ASCII IN T1 AND T2 RESULT IN T1

K1A:	BYTE (7) 106,106,106,106,106
K2A:	BYTE (7) 17,17,17,17,17
K3A:	BYTE (7) 77,77,77,77,77
K4A:	<ASCII /00000/>!1
K5A:	BYTE (7) 7,7,7,7,7
K6A:	BYTE (1) 1 (7) 77,77,77,77,77
K7A:	BYTE (1) 0 (7) 106,106,106,106,106

ASCAV:	AND	T2,K2A
	IOR	T1,K4A		;THIS ROUTINE AVERAGES 2 ASCII NUMERS
	LSH	T1,-1
	ADD	T1,K7A		;IT WORKS MOSTLY BY MAJIC
	LSH	T2,-1
	ADD	T2,T1
	AND	T2,K6A
	MOVE	T1,T2
	ANDCM	T1,K3A
	AND	T2,K3A
	MOVE	T3,T2
	LSH	T3,-3
	AND	T3,K2A
	AND	T2,K5A
	SUB	T2,T3
	LSH	T1,-4
	ADD	T2,T1
	LSH	T1,-2
	ADD	T2,T1
	IOR	T2,K4A
	POPJ	P,

;CHECK TO SEE IF BUFFER TOO FULL AND DUMP IF NEEDED

FILLB:	MOVE T1,WC	;GET WORD COUNT
FILLB3:	CAMGE T1,MAXWC	;AND COMPARE WITH MAX PERMISSIBLE
	POPJ P,		;OK, SO RETURN
	MOVE T1,BUFP	;GET BUFFER POINTER
	ADDI T1,1
FILLB1:	SKIPN T2,(T1)	;FIND END OF FIRST LINE
	JRST FILLB2
	TRNN T2,1
	AOJA T1,FILLB1
FILLB2:	PUSHJ P,NOWFL	;PART OF GETN WILL DUMP AND ADJUST POINTERS
	JRST FILLB	;SEE IF IN LIMITS NOW



;INSERT A LINE (IN LIBUF) INTO PLACE POINTED AT BY PNTR
;WORD COUNT OF OLD LINE IN OCNT. OF NEW LINE IN NCNT

INSED:	TLO FL2,ALLCHG	;CHANGES
IFN STATSW, <
	CALL ST.LIN >	;RECORD LINE SIZE
	MOVE T1,NCNT	;SEE HOW THE COUNTS DIFFER
	SUB T1,OCNT
	JUMPE T1,NOBLT	;THEY ARE SAME, NO MOVING NECESSARY
	JUMPG T1,BBLT	;NEW IS LARGER, BLT WILL NOT DO
	MOVE T2,PNTR	;SET UP BLT POINTER FROM PNTR+OCNT
	ADD T2,OCNT
	HRLS T2
	HRR T2,PNTR	;TO PNTR+NCNT
	ADD T2,NCNT
	ADDB T1,WC	;ADJUST WC TO OLD WORD COUNT +NCNT-OCNT
	ADD T1,BUFP	;LAST TRANSFERED IS BUFP+WC+NCNT-OCNT
	BLT T2,(T1)
NOBLT:	SKIPN T1,NCNT	;CHECK FOR 0 NEW COUNT (WE ARE DELETING)
	POPJ P,		;IF SO DONE
	MOVE T2,PNTR	;GET THE POINTER POSITION FOR BLT
	HRLI T2,LIBUF	;FROM LIBUF TO PNTR
	ADD T1,PNTR	;STOP AT PNTR+NCNT-1
	BLT T2,-1(T1)
	POPJ P,		;AND ALL DONE
BBLT:	MOVE T2,BUFP	;FAKE BACKWARDS BLT FROM BUFP+WC
	ADD T2,WC
	ADDB T1,WC	;TO BUFP+WC+NCNT-OCNT (ALSO FIX WC)
	ADD T1,BUFP
BBLT1:	CAMGE T2,PNTR	;STOP HERE (COULD STOP SOONER BUT THIS IS EASIER)
	JRST NOBLT	;AND GO MOVE IN NEW STUF
	MOVE T3,(T2)	;TRANSFER A WORD
	MOVEM T3,(T1)
	SUBI T1,1
	SOJA T2,BBLT1	;AND KEEP IT UP

;SUBROUTINE TO DO A GTJFN.  THIS CODE HANDLES THE PROBLEMS OF MULTIPLE
;FILE SPECS IN A LOGICAL NAME WHICH CAUSE PROBLEMS AS FOLLOWS:
;@DEFINE DSK: DSK:, PS:<RANDOM>
;@EDIT FOO.BAR
;WHERE FOO.BAR DOESN'T EXIST, AND THE DIRECTORY <RANDOM> IS PROTECTED.
;CURE: FIRST TRY THE GTJFN AS SPECIFIED, IF THAT FAILS THEN TRY IT AGAIN
;USING ONLY THE FIRST LOGICAL NAME DEFINITION.


GTJFNX:	TLNE	T1,(GJ%NEW+GJ%NS+GJ%OFG)	;SPECIAL CASES?
	JRST	GTJFNZ		;YES, NO NEED TO TRY TWICE
IFE STANSW, <
	HLLOS	CJFNBK		;(206) SET FOR GENERATION
>; IFE STANSW
	DMOVEM	T1,TEMPS	;SAVE THE AC'S
	GTJFN			;TRY THE GTJFN AS SPECIFIED
	SKIPA			;FAILED, GO ANALYSE ERROR
	RETSKP			;IT WORKED, SKIP RETURN
	CAIN	T1,GJFX24	;FILE NOT FOUND ERROR?
	RET			;YES, RETURN NOW
	DMOVE	T1,TEMPS	;NO, RESTORE ORIGINAL AC'S
	TLO	T1,(GJ%NS)	;SET TO ONLY LOOK AT FIRST LOGICAL SPEC

GTJFNZ:	GTJFN			;TRY THE GTJFN AGAIN
	RET			;FAILED
	RETSKP			;SUCCEEDED

SUBTTL	INSERT ROUTINE

;INSERT A LINE

CRTINS:	OCRLF
	MOVEI	T1,1		;SET TO START INSERTING AT LINE 100 PAGE 1
	MOVEM	T1,HIPG
	SKIPN	T1,TECFST	;USE START IF GIVEN
	MOVE	T1,[<ASCII /00100/>!1]
	MOVEM	T1,HILN
	JRST	INSGO		;AND AWAY WE GO


IFN STANSW, <
	HLPMSG <I Command	(Insert)
 
I<position>
I<position>,<increment>
I<position>!<line-count>
I Command (Insert)
 
Special functions of the "I" command:
 
I<CR>	    default is set to end of last:
	       Replace, except at end of page
	       Insert, except wrap around or out of space
 
I/<page>    does insert page mark at end of <page> followed by Istart,
	    where start is the value of the START switch (Originally,
	    the START switch is set at 100).
 
I<pos>!n    allows insertion of n lines; calculates increment from
	    table of aesthetic values.
 
I^	    inserts a line at the top of the page, halfway between line
	    0 and the first line.
 
I<position>{,<increment>}
	inserts new  text from the keyboard starting at <line number>
	and numbering by <increment>, until either all available lines
	counting by  <increment> are  filled or	until an  escape   is
	typed  in.  If no increment  is specified t is	assumed to be
	the value of the switch INCREMENT, or 100 by default.
 
>
>; IFN STANSW


INSERT:	TRNE	FL,READOF	;ERROR IF READ-ONLY
IFE STANSW, <
	NERROR	ILC
>; IFE STANSW
IFN STANSW, <
	NERROR	IRO
>; IFN STANSW
	PUSHJ	P,SCAN
	TRNE	FL,TERMF	;CHECK FOR NO ARGUMENTS
	JRST	[MOVE  T1,IPG
		 MOVEM T1,HIPG
		 MOVE  T1,CURINS
		 MOVEM T1,HILN
		 SKIPG ISVINC
		 JRST  INSGO
		 MOVE  T1,ISVINC
		 EXCH  T1,INCR
		 MOVEM T1,TEMINC
		 JRST  INSGO]	;IF NONE, GO BACK INSERTING 
				; WHERE YOU WERE
	SETOM	ISVINC		;SET FLAG SO CANNOT USE ISVINC
	TRO	FL2,UPTOPF	;^ =NEW LINE AT TOP OF PAGE
	PUSHJ	P,GET1		;GET ONE LINE/PAGE NUMBER
	TRZ	FL2,UPTOPF	;^ =EXISTING LINE AT TOP OF PAGE
	TRNN	FL,LINSN	;WAS /N GIVEN
	JRST	INSMK		;YES: TREAT SPECIAL
	PUSHJ	P,INSINC	;GET INCR IF ANY
INSGO:	PUSHJ	P,DOINS		;DO THE INSERTS
	JRST	COMND		;RETURN

INSINC:	CAIE	C,","		;GIVING AN INCREMENT WITH COMMA?
	CAIN	C,";"		;OR SEMICOLON (AS BEFORE EDIT 136)?
	SKIPA	T1,INCR		;YES
				;NO, CHECK FOR !<# OF LINES>
	JRST	[CAIN C,"!"
		 JRST ININC1
		 JRST NOINC]	;IF NO ; , OR !, USE DEFAULT
	PUSHJ	P,GNCH		;ALLOW OLD FORMAT I<POS>;!<#>
	CAIE	C,"!"		;IS NEXT CHR. A !
				;NO, BACK UP SCANNER
	JRST	[MOVEM C,SAVC
		 JRST  GETINC]
ININC1:	MOVE	T1,INCR		;SAVE CURRENT INREMENT
	SETOM	INCR		;YES, HE'S SAID # OF LINES TO INSERT

GETINC:	MOVEM	T1,TEMINC	;SAVE THE CURRENT INCREMENT
	PUSHJ	P,SCAN		;GET THE NUMBER
	TRNE	FL,NUMF		;IS IT REALLY A NUMBER?
	CAMN	T1,[<ASCII /00000/>!1]  ;AND NOT EQUAL TO 0?
	NERROR	ILC		;NO, HE IS CONFUSED
	MOVEM	T2,NLIN1	;YES, SAVE AS DECIMAL NUMBER
	SKIPGE	INCR		;MUST WE COMPUTE AN INCREMENT?
	JRST	GTINC1		;YES, DON'T SET INCREMENT YET
	MOVEM	T1,INCR		;NO, SET THE INCREMENT
	MOVEM	T1,ISVINC	; AND SAVE FOR USE WITH I<CR>
GTINC1:	PUSHJ	P,SCAN		;LOOK FOR TERMINATOR
NOINC:	TRNN	FL,TERMF	;FOUND ONE?
	NERROR	ILC		;NO, ILLEGAL COMMAND
	SETZM	ALTSN		;YES, CLEAR ALTMODE FLAG
	POPJ	P,		;RETURN


DOINS:	MOVE	T1,HIPG		;GET THE PAGE TO GO TO
	MOVEM	T1,DPG		;AND SET IT UP
	MOVE	SINDEX,HILN	;ALSO LINE
	PUSHJ	P,FIND		;GO GET UM
	MOVE	T2,CPG		;DEMAND CORRECT PAGE MATCH
	CAME	T2,HIPG
	NERROR	NSP
	SKIPL	INCR		;NEED TO COMPUTE ONE?
	JRST	INSTRY		;NO -- JUST TRY TO INSERT
	MOVE	T2,HILN		;YES -- SET UP FOR CALL
	MOVE	T3,NLIN1
	PUSHJ	P,GETDIF	;GET BEST FIT
	  NERROR ILR		;WHOOPS
	MOVEM	T1,HILN		;USE THESE VALUES
	MOVEM	T2,INCR		;SAVE THE INCREMENT FOR NOW
	MOVEM	T2,ISVINC	;AND FOR USE WITH LATER I<CR>
	JRST	INSLP
INSTRY:	CAME	T1,HILN		;DO THEY MATCH?
	JRST	INSLP		; YES - GO AHEAD
	MOVE	T2,INCR		; NO - GO INVENT A NEW LINE
	PUSHJ	P,FIXLIN
	  EXP	HILN
	 NERROR	ILR		;NO ROOM
	MOVEM	T2,HILN		;STORE NEW NUMBER
INSLP:	SETZM	OCNT
	SKIPE	ALTSN		;ALTMODE SEEN?
	JRST	LVINS		;YES: DONE
	MOVE	T1,HILN		;TELL HIM THE LINE HE IS INSERTING
	MOVEM	T1,LIBUF	;AND PUT IT IN THE BUFFER
	SETZM	CRBUF		;INCASE NONUMBER
	TRNN	FL2,COMFLF!NONUMF	;IGNORE SQ # IF IN CMD FILE
	CALL	[MOVEM T1,CRBUF	;PUT IT IN ^R BUFFER
		 MOVSI T2,(11B6)
		 MOVEM T2,CRBUF+1
		 PJRST OUTSN]	;DUMP SEQ # AND RETURN
	PUSHJ	P,RDLIN		;READ A LINE
	JRST	LVINS		;YES, GET OUT OF INSERT MODE
	MOVEM	T1,NCNT		;HERE IS THE COUNT OF THE NEW ONE
	PUSHJ	P,INSED		;GO INSERT
	SOSN	ISAVEN		;TIME TO SAVE?
	PUSHJ	P,ASVINS	;YES: GO DO IT
	PUSHJ	P,FINDN		;MOVE UP A LINE
	PUSHJ	P,FILLB		;AND DUMP SOME IF NECESSARY
	MOVE	T1,CPG		;SET CURRENT LINE AND PAGE TO LAST
	MOVEM	T1,CPGL		;ONE REALLY INSERTED
	MOVEM	T1,IPG		;(199) UPDATE PAGE COUNTER
	MOVE	T1,HILN
	MOVEM	T1,CLN
	MOVEM	T1,CURINS	;(199) UPDATE INSERT COUNTER
	MOVE	T2,INCR		;GET NEXT LINE TO INSERT
	PUSHJ	P,ASCIAD
	CAMG	T1,INCR		;HAVE WE WRAPED AROUND
	JRST	LVINS1		;YES -- STOP
	MOVEM	T1,HILN		;STORE FOR REFERENCE
	SKIPN	T1,(PNTR)	;GET THE LINE POINTED TO
	JRST	INSLP		;ALWAYS INSERT AT END OF FILE
	CAME	T1,PGMK		;OR AT END OF PAGE
	CAMLE	T1,HILN		;HAVE WE FOUND A MATCH OR PASSED OVER A LINE?
	JRST	INSLP		;NO, INSERT
	JRST	LVINS1		;RETURN TO COMMAND LEVEL


LVINS:	MOVE	T1,HILN
	MOVEM	T1,CURINS	;SET PLACE TO INSERT NEXT TIME
	MOVE	T1,CPG
	MOVEM	T1,IPG
	TRNE	FL2,COMFLF	;CMD FILE?
	JRST	LVINS2		;YES SKIP CR
LVINS1:	SKIPE	ALTSN		;ALT SEEN?
	OCRLF			;YES -- OUTPUT CRLF
LVINS2:	SETZM	ALTSN		;CLEAR ALTMODE FLAG
	POPJ	P,		;RETURN

;ROUTINE TO COMPUTE INCREMENT
; AS DIFFERENCE OF TWO LINES / # OF LINES TO INSERT
;CALL:
;	MOVE	T1,<RESULT OF FIND>
;	MOVE	T2,<LINE TYPED(DESIRED)>
;	MOVE	T3,<# OF LINES TO INSERT>
;	PUSHJ	P,GETDIF
;	  <ERROR RETURN (IE NO ROOM)>
;	<OK RETURN>
;	  C(T2) := COMPUTED INCR
;	  C(T1) := WHERE TO START INSERTING

GETDIF:	PUSH	P,T3		;SAVE ARGS
	PUSH	P,T2
	PUSH	P,T1		;SAVE RESULT OF FIND
	CAMN	T1,T2		;ALREADY HAVE NEXT IF NOT EQUAL
	PUSHJ	P,FINDN		;LOOK FOR NEXT LINE
NOFND:	SKIPE	T3,T1		;NONE IF EOF
	CAMN	T1,PGMK		;  OR PAGE MARK
	SKIPA	T1,[^D100000]	;USE HIGHEST + 1
	PUSHJ	P,NUMCON	;NEXT LINE # IN T1
NONXT:	PUSH	P,T1		;SAVE IT
	MOVE	T3,-2(P)	;GET WHAT WAS TYPED
	CAMN	T3,-1(P)	;DOES IT EXIST?
	SOS	0(P)		;YES - ALLOW FOR IT
	PUSHJ	P,NUMCON	;CONVERT ARG
	MOVE	T2,T1		;MOVE RESULT TO T2
	POP	P,T1		;RESTORE <NEXT>
	SUB	T1,T2		;GET DIFFERENCE
	IDIV	T1,-2(P)	;(<NEXT>-<CURR>)/N
	JUMPE	T1,GOTZER	;DON'T FIT IF ZERO
	CAIGE	T1,3		;IF 1 OR 2 ITS THE BEST
	JRST	GOTIT
	MOVE	T2,[-6,,[DEC 2,5,10,20,50,100,100001]]
	CAML	T1,1(T2)	;LOOK FOR ITEM .GT. T1
	AOBJN	T2,.-1
	JUMPGE	T2,GOTZER	;CAN'T HAPPEN
	MOVE	T1,0(T2)	;GET AESTHETIC INCR
GOTIT:	PUSHJ	P,ASCON		;CONVERT TO INCR FORM
	MOVE	T2,T3		;GET INTO CORRECT AC
	POP	P,T1		;GET BACK ARG
	MOVEM	T2,-1(P)	;STORE COMPUTED INCR
	CAME	T1,0(P)		;FIGURE OUT START POINT
	JRST	GETRET		;OK IF NOT FOUND
	PUSHJ	P,ASCIAD	;ELSE ADD INCR TO IT
	MOVEM	T1,0(P)		;  AND USE IT
GETRET:	POP	P,T1		;STARTING LINE #
	POP	P,T2		;INCR
	JRST	CPOPJ1		;GIVE GOOD RETURN

GOTZER:	SUB	P,[3,,3]	;PRUNE PDL
	POPJ	P,		;ERROR RETURN

;USE THIS ENTRY IF THERE IS NO NEXT LINE KNOWN

GETDF1:	PUSH	P,T3		;SAVE ARGS
	PUSH	P,T2
	PUSH	P,T1
	MOVEI	T1,^D100000	;USE LARGEST + 1
	JRST	NONXT		;ENTER GETDIF

;ROUTINE TO GUESS AT A GOOD PLACE TO INSERT IF CURRENT LINE EXISTS
;CALL:
;	MOVE	T1,<CURRENT POSITION>
;	MOVE	T2,<INCREMENT TO USE>
;	PUSHJ	P,FIXLIN
;	<LOC OF HIGH BOUND>
;	  <ERROR RETURN>
;	<OK RETURN>		;NEW NUMBER IN T2

FIXLIN:	AOS	T4,0(P)		;SKIP OVER ARG
	PUSHJ	P,ASCIAD	;ADD
	PUSH	P,T1		;SAVE RESULT
	PUSHJ	P,FINDN		;GET THE NEXT ONE
	POP	P,T2
	CAMG	T2,@-1(T4)	;IS THERE A WAR PROBLEM
	JRST	FIXBAD		;YES, WE MUST TRY TO COMPUTE ONE
	JUMPE	T1,CPOPJ1	;END OF FILE, ANY INC IS OK
	CAME	T1,PGMK		;ALSO OK IF A PAGE MARK
	CAMGE	T2,T1		;OR IN CORRECT ORDER
	JRST	CPOPJ1
FIXBAD:	CAME	T1,PGMK
	SKIPN	T1
	MOVE	T1,[<ASCII /9999:/>!1]	;ONE OVER THE TOP OF THE WORLD
	MOVE	T2,@-1(T4)	;GET CURRENT
	PUSHJ	P,ASCAV		;FIND AVERAGE
	CAME	T2,@-1(T4)	;THERE MAY HAVE ONLY BEEN A DIF OF 1
	AOS	0(P)		;SKIP RETURN
	POPJ	P,


SUBTTL	DELETE ROUTINE

;DELETE A LINE, A NUMBER OF LINES, OR A PAGE MARK

IFN STANSW, <
	HLPMSG <D Command	(Delete)
 
D<range>
 
D deletes the lines in the range and prints a message telling
how many lines were deleted unless you are in /EXPERT mode.
>
>; IFN STANSW

DELETE:	SETZM	LOLN		;JUST AS A START
	SETZM	PGDELS		;NO PAGES DELETED
	TRNE	FL,READOF	;NOT PERMITTED IN READ ONLY
IFE STANSW, <
	NERROR	ILC
>; IFE STANSW
IFN STANSW, <
	NERROR  IRO
>; IFN STANSW
	PUSHJ	P,GET2S		;GET TWO PAGE-LINE PAIRS
	TRZ	FL,LINSN	;FOR NOW
	CAIE	C,","		;CHECK SWITCH
	JRST	DELT1
	PUSHJ	P,SCAN
	MOVS	T1,ACCUM
	TRNE	FL,IDF
	CAIE	T1,(<SIXBIT /Y  />)
	NERROR	ILC
	TRO	FL,LINSN	;DON'T ASK
	PUSHJ	P,SCAN
DELT1:	TRNN	FL,TERMF	;CHECK FOR TERMINATOR
	NERROR	ILC
	PUSHJ	P,DELSUB	;DO SOME DELETING
	SKIPN	PGDELS		;NEED TO DO ORDER CHECK
	JRST	COMND		;NO - ALL OK
	JRST	ORDCHK		;YES - DO IT

;SUBROUTINE TO DELETE LINES FROM A FILE - COUNTS NUMBER OF
;PAGE MARKS DELETED IN PGDELS

DELSUB:	TRNN	FL,PGSN		;CHECK FOR MASSIVE DELETE
	SKIPN	LOLN
	JRST	[TRNN FL,EXTOG
		 TRNE FL,LINSN
		 JRST .+1
		 OUTSTR [ASCIZ /Massive delete ok? /]
		 PUSHJ P,CONFRM
		 JRST COMND	;NO:
		 JRST .+1]	;YES:
IFN STANSW, <
	CALL	DELCHK		;CHECK IF DELETING A LOT ON ONE PAGE
>; IFN STANSW
	TRZ	FL,LINSN	;NONE SEEN YET
	MOVE	T1,LOPG		;GET THE PAGE NUMBER
	MOVEM	T1,DPG
	MOVE	SINDEX,LOLN	;AND LINE
	PUSHJ	P,FIND
	MOVE	T2,CPG		;SEE WHERE WE ARE
	CAME	T2,LOPG		;IS THIS OK
	NERROR	NSP
	SKIPN	LOLN		;WANT WHOLE PAGE?
	TRO	FL,LINSN	;YES - SAY WE DID IT
DELSB1:	PUSHJ	P,ONMOV		;CHECK FOR RANGE
	JRST	DELEND
	TRO	FL,LINSN	;SEEN SOMETHING
	CAMN	T1,PGMK		;PAGE MARK
	JRST	DELPAG		;YES - DELETE PAGE
	MOVEM	T1,CLN		;SAVE CURRENT LINE
	PUSHJ	P,DODEL		;GO DO A LINE DELETE
DELSB2:	PUSHJ	P,FINDN1	;FIND NEXT BUT ACCEPT LINE IF ALREADY THERE
	JRST	DELSB1		;GO DO NEXT

DELPAG:	MOVEI	T1,2		;SET TO DELETE PAGE
	MOVEM	T1,OCNT
	SETZM	NCNT		;NEW SIZE IS 0
	PUSHJ	P,INSED		;ZAP
	AOS	PGDELS		;INCR COUNT OF PAGES GONE
	AOS	CPG		;BEWARE!!!
	SETZM	LDELLN		;NO LINES ON THIS PAGE YET
	JRST	DELSB2		;CONTINUE

DELEND:	TRNN	FL,LINSN	;DO ANYTHING?
	NERROR	NLN		;NO - GIVE ERROR
	MOVE	T1,LOPG		;YES - SET CURRENT PAGE
	MOVEM	T1,CPG		;AS THE ONE HE ASKED FOR
	MOVEM	T1,CPGL		;...
	MOVN	T1,PGDELS	;GET NEG # OF PAGES DELETED
	ADDM	T1,BGPG		;ADJUST CNTRS
	ADDM	T1,INPG		;TO SHOW CORRECT # OF PAGES
	POPJ	P,		;RETURN

;ROUTINE TO ASK IF A USER REALLY WANTS TO DELETE A LARGE NUMBER
;OF LINES ON A SINGLE PAGE.  CAN BE FOOLED IF THE LINES ARE NOT
;NUMBERED WITH THE INCREMENT GIVEN IN TECINC

IFN STANSW, <

DELCHK:	TRNN	FL,PGSN		;RETURN IF PAGE SEEN
	TRNE	FL,EXTOG	;RETURN IF EXPERT
	 RET
	MOVE	T3,HILN		;GET HIGH LINE NUMBER
	CAMN	T3,LOLN		;COMPARE WITH LOW LINE NUMBER
	 RET			;EQUAL, DELETING JUST ONE LINE
	CALL	NUMCON		;CONVERT FROM ASCII TO DECIMAL
	PUSH	P,T1		;SAVE RESULT
	MOVE	T3,LOLN		;GET LOW LINE NUMBER
	CALL	NUMCON		;CONVERT
	POP	P,T2		;RESTORE HIGH LINE NUMBER
	SUB	T2,T1		;DIFFERENCE BETWEEN HIGH AND LOW IN T2
	PUSH	P,T2		;SAVE DIFFERENCE
	MOVE	T3,TECINC	;INCREMENT
	CALL	NUMCON		;CONVERT
	POP	P,T2		;RESTORE DIFFERENCE
	IDIV	T2,T1		;DIVIDE BY INCREMENT
	CAIGE	T2,^D30		;SKIP IF DELETING MANY LINES
	 RET
	HRROI	T1,[ASCIZ "Massive delete okay? "]
	PSOUT
	CALL	CONFRM		;WELL?
	JRST	COMND		;NO, BACK TO COMMAND LEVEL
	RET			;YES, JUST RETURN

>; IFN STANSW
 

;DELETE A PAGE MARK

IFN STANSW, <
	HLPMSG <K Command	(Kill page mark)
 
K/<page number>
 
Removes the page mark before the <page number>th page.
>
>; IFN STANSW

KILL:	SETZM	LOLN	;A GOOD THING
	TRNE	FL,READOF
IFE STANSW, <
	NERROR	ILC
>; IFE STANSW
IFN STANSW, <
	NERROR	IRO
>; IFN STANSW
	PUSHJ	P,GET1S
	TRZN	FL,LINSN
	TRNN	FL,TERMF
	NERROR	ILC
DELPG:	MOVE T1,HIPG	;GET THE DESIRED PAGE TO DELETE
	MOVEM T1,DPG	;SET IT
	SOJLE T1,DELER	;DO NOT TRY PAGE 1
	MOVEI SINDEX,0	;GUARANTEED TO FIND LINE IMMEDIATELY AFTER PAGE MARK
	PUSHJ P,FIND	;GET IT
	MOVE T2,CPG	;CHECK FOR MATCH
	CAME T2,HIPG
DELER:	NERROR NSP	;NO SUCH PAGE
	PUSHJ P,FINDB	;GO BACK ONE
	CAME T1,PGMK	;IS IT A PAGE MARK?
	NERROR ICN		;CONFUSED, GIVE FATAL ERROR
	MOVEI T1,2	;COUNT IS 2
	MOVEM T1,OCNT
	SETZM NCNT	;AND NEW IS 0
	PUSHJ P,INSED
	MOVE	T1,HIPG		;GET HIGH PAGE
	CAMG	T1,CPGL		;CPG GTR CPGL?
	SOS	CPGL		;NO, CPGL=CPGL-1
	SOS BGPG	;MAX PAGE IS NOW 1 LOWER
	SOS INPG
ORDCHK:	PUSHJ P,FINDN1	;GET THE NEXT LINE
	JUMPE T1,COMND	;IF EOF THERE IS NO ORDER ERROR
	CAMN T1,PGMK	;OR IF A PAGE MARK
	JRST COMND
	MOVEM T1,SVSEQN		;SAVE IT FOR COMPARE
	PUSHJ P,FINDB		;FIND THE PREVIOUS ONE
	JUMPE T1,COMND		;START OF FILE, ALL OK
	CAME T1,PGMK		;ANOTHER PAGE MARK
	CAMGE T1,SVSEQN		;CHECK THE ORDER
	JRST COMND		;ALL OK
	NERROR ORDER		;ALL WRONG

SUBTTL	INSERT PAGE MARK

;INSERT A PAGE MARK AT DESIGNATED LINE

IFN STANSW, <
	HLPMSG <M Command	(Mark)
 
M<position>
 
Inserts a page mark before the line specified.
>
>; IFN STANSW
MARK:	SETZM	HILN		;IN CASE OF /A
	TRNE FL,READOF		;NOT PERMITTED IN READ ONLY
IFE STANSW, <
	NERROR ILC
>; IFE STANSW
IFN STANSW, <
	NERROR IRO
>; IFN STANSW
	PUSHJ P,GET1S		;GET ONE LINE/PAGE NUMBER
	TRNN FL,TERMF		;CHECK FOR TERMINATOR
	NERROR ILC
	PUSHJ	P,MARK0		;INSERT PAGE MARK
	JRST	COMND		;RETURN TO COMMAND LEVEL

MARK0:	MOVE T1,HIPG		;GO LOOK FOR IT
	MOVEM T1,DPG
	MOVE SINDEX,HILN	;AND THE LINE
	PUSHJ P,FIND		;GET IT
	MOVE T1,CPG
	CAME T1,HIPG		;PAGE MUST MATCH
	NERROR NSP		;MUST MATCH
	AOS T1,CPG		;WILL BE ON HIGHER PAGE WHEN DONE
	MOVEM T1,CPGL		;SET UP LOGICAL PAGE
	AOS BGPG		;THERE IS NOW ONE MORE
	AOS INPG	
	MOVE T1,TECFST		;USE THE START PARAMETER
	MOVEM T1,CLN		;FIRST LINE ON THAt PAGE
	MOVE T1,PGMK		;PUT A PAGE MARK IN LIBUF
	MOVEM T1,LIBUF
	MOVE	T1,PGMKW2	;TEXT OF A PAGE MARK
	MOVEM T1,LIBUF+1
	SETZM OCNT		;THIS IS A STRAIGHT INSEET
	MOVEI T1,2		;OF 2 WORDS
	MOVEM T1,NCNT
	PUSHJ P,INSED		;GO DO IT
	PUSHJ P,FINDN		;SINCE FILLB MAY WANT TO DUMP THIS LINE
	JUMPE T1,FILLB		;SKIP IF EOF SEEN
	CAME T1,PGMK		;CHECK IF EMPTY
	MOVEM T1,CLN		;NO; USE THIS LINE
	JRST	FILLB		;FILL BUFFER

INSMK:	TRNN	FL,TERMF	;GRNTEE TERM
	NERROR	ILC
	SETZM	ALTSN		;NO ESC SEEN YET
	MOVE	T1,[<ASCII /9999:/>!1]
	MOVEM	T1,HILN		;ONE PAST END OF WORLD
	PUSHJ	P,MARK0		;INSERT PAGE-MARK
	MOVE	T1,CLN		;GET CURRENT LINE
	MOVEM	T1,HILN
	MOVE	T1,CPG		;AND CURRENT PAGE
	MOVEM	T1,HIPG		;SET UP FOR INSERT
	JRST	INSGO		;GO


SUBTTL	RENUMBER

;RENUMBER SELECTED LINES

IFN STANSW, <
	HLPMSG <N Command	(Number)
 
N{<increment>}{,<range>{,<start>}}
 
variations on the basic command:
 NA  Add <increment> to <range>
 NP  Preserve line numbers over page marks
 
Renumbers  the specified range  of lines starting  with the specified
value and  adding  the specified  increment  in generating  the  line
number for  each succeeding  line.  If  you do  not give  a  starting
number, the system uses the value of the START parameter (the default
is 100). If you do not  give a range, the system renumbers the entire
file. If  you do not specify an increment,  the system uses the value
of the  INCREMENT parameter (the default is  100). The system assigns
the starting  number to the first line on  each page and numbers each
succeeding line by adding the  increment, unless you add the letter P
to the N command. This stops the system from reseting to the starting
number at the beginning of each page. If you want to add an increment
to a range of lines, use the following command:
 *NAincrement,range.
>
>; IFN STANSW
NUMBER:	MOVE T1,TECINC		;USE DEFAULT INCR
	MOVEM T1,REINC		;WE WILL USE 100
	MOVE T1,TECFST		; AND DEFAULT START
	MOVEM T1,INCST
	MOVEM T1,REFST		;SAVE FOR NEW PAGE
	SETZM LOLN		;GET THIS SET TO START THINGS OFF
	TRNE FL,READOF		;NOT PERMITTED IN READ ONLY
IFE STANSW, <
	NERROR	ILC
>; IFE STANSW
IFN STANSW, <
	NERROR  IRO
>; IFN STANSW
	TRZ	FL2,ACONST!MONOF
	PUSHJ	P,GNCH		;GET NEXT CHAR
	MOVEM	C,SAVC		;SAVE IN CASE WE NEED IT
	ANDI	C,137		;FORCE UPPER
	CAIN	C,"A"
	TRO	FL2,ACONST	;ADD CONSTANT
	CAIN	C,"P"
	TRO	FL2,MONOF	;NO RESET ON PAGE MARK
	TRNE	FL2,ACONST!MONOF
	SETZM	SAVC		;GOT ONE - DON'T BACK UP SCANNER
	PUSHJ	P,SCAN		;GET THE RENUMBER INCREMENT
	TRNE FL,NUMF	;WAS IT A NUMBER
	CAMN T1,[<ASCII /00000/>!1]	;NO 0 RENUMBER INCR
	JRST NUMBC	;NO NUMBER, CHECK FOR COMMA
	MOVEM T1,REINC	;THE INCREMENT TO USE
	MOVEM T1,INCST	;LINE TO START WITH
	MOVEM	T1,REFST
	PUSHJ P,SCAN	;SCAN PAST NUMBER
NUMBC:	CAIN C,","	;AND CHECK FOR COMMA
	JRST NUMB1	;GET A RANGE
	MOVEI T1,1	;NO RANGE, DO WHOLE FILE
	MOVEM T1,LOPG	;FROM PAGE 1
	MOVSI T1,1	;TO IMPOSSIBLY HIGH
	MOVEM T1,HIPG
	TRZ FL,CNTF	;MAKE SURE THIS IS OFF
	JRST NUMBL	;AND CHECK FOR TERMINATOR
NUMB1:	PUSHJ P,GET2S	;GET A RANGE
	CAIE C,","	;SEE IF THERE IS A FOURTH ARGUMENT
	JRST NUMBL	;NO
	PUSHJ P,SCAN	;YES, GET IT
	TRNN	FL2,ACONST	;ILLEGAL IF ADD MODE
	TRNN FL,NUMF	;IS IT A NUMBER?
	NERROR ILC	;HE WOULD HAVE BEEN BETTER OFF WITHOUT IT
	MOVEM	T1,REFST
	MOVEM T1,INCST	;USS AS STARTING NUMBER
	PUSHJ P,SCAN	;SCAN PAST IT
NUMBL:	TRNN FL,TERMF	;ENDS PROPERLY?
	NERROR ILC	;LOSE
IFN STANSW, <
RENMBR:				;LABEL FOR JUSTIFY COMMAND 
>; IFN STANSW
	MOVE T1,LOPG	;GET PLACE TO START
	MOVEM T1,DPG
	MOVE SINDEX,LOLN	;AND LINE
			;FALL THRU


	PUSHJ P,FIND	;GET IT
	TRZ FL,LINSN!ORDF	;SET TO NONE SEEN AND NO ORDER ERROR
	PUSHJ P,FINDB	;BACK UP AND SEE HOW ORDER LOOKS
	JUMPE T1,NUMB5	;START OF FILE IT MUST BE OK
	CAME T1,PGMK	;ALSO IF A PAGE MARK
	CAMGE T1,INCST	;OR IF IN CORRECT ORDER
	SKIPA
	TRO FL,ORDF	;WRONG SET FLAG
NUMB5:	PUSHJ P,FIND	;GET THE CORRECT LINE BACK
NUMB2:	PUSHJ P,ONMOV	;CHECK RANGE
	JRST NUMB3
	CAMN T1,PGMK	;PAGE MARK?
	JRST NUMB4	;SPECIAL TREATMENT
	MOVE	T1,1(PNTR)	;CHECK SPECIAL P.M.
	CAMN	T1,[BYTE (7)11,14,15,12,0]
	JRST	NUMBP		;HANDLE AS WIERD PAGE MARK
	TRNE	FL2,ACONST	;JUST ADD CONSTANT
	JRST	[MOVE T1,(PNTR)	;YES - USE OLD LINE #
		 TRO FL,LINSN	;SAY WE'VE SEEN ONE
		 JRST NUMB2A]
	MOVE T1,INCST	;GET STAATING NUMBER
NUMB2A:	MOVE T2,REINC	;AND INCREMENT
	TRON FL,LINSN	;WAS A LINE SEEN?
	JRST FSTLIN	;NO, FIRST ONE IS SPECIAL
	PUSHJ P,ASCIAD	;SKIP THIS THE FFRST TIME
	CAMGE T1,REINC	;HAVE WE WRAPED
	JRST	[RERROR WAR	;TELL HIM HE LOST
		MOVE T2,CPG	;PRINT THE PAGE
		PUSHJ P,PGPRN
		JRST .+1]	;RETURN
FSTLIN:	MOVEM T1,INCST	;SAVE FOR NEXT LINE
	MOVEM T1,CLN	;AND THE CURRENT LINE
	MOVEM T1,(PNTR)	;PUT IT IN
	PUSHJ P,FINDN	;GET NEXT
	JRST NUMB2	;AND GO RANGE CHECK

NUMB3:	TRNN FL,LINSN	;DONE, WAS THERE SOMETHING THERE?
	NERROR NLN	;NO,  NULL RANGE ERROR
	TLO	FL2,ALLCHG	;CHANGES
	MOVE T2,CPG	;SET UP CURRENT PAGE
	MOVEM T2,CPGL
	TRNE FL,ORDF	;WAS THERE AN ORDER ERROR?
	NERROR ORDER	;YES, FLAG IT
	JUMPE T1,COMND	;CHECK TO SEE IF LOSAGE NOW
	CAME T1,PGMK
	CAMLE T1,INCST
	JRST COMND
	NERROR ORDER


NUMBP:	MOVE	T1,PGMK		;CONVERT TO PAGE MARK
	MOVEM	T1,0(PNTR)
	MOVE	T1,PGMKW2	;REST
	MOVEM	T1,1(PNTR)	;...
	AOS	BGPG		;INCR ALL GOOD STUFF
	AOS	INPG
	AOS	HIPG		;FAKE OUT ONMOV
NUMB4:	AOS	CPG		;NOW ON A HIGHER PAGE
	MOVE	T1,[<ASCII /00000/>!1]
	MOVEM	T1,CLN		;SET TO FIRST LINE ON PAGE
	TRO	FL,LINSN	;WE SAW ONE
	PUSHJ	P,FINDN		;GET NEXT LINE
	PUSHJ	P,ONMOV	;IN RANGE?
	  JRST	NUMB3		;NO - FINISHED
	CAMN	T1,PGMK		;ANOTHER P. M.
	JRST	NUMB4
	MOVE	T1,REFST	;FIRST LINE #
	TRNN	FL2,ACONST!MONOF
	JRST	FSTLIN		;IF NOT SPECIAL
	MOVE	T1,REINC	;ELSE GET INC
	TRNN	FL2,MONOF
	SKIPA	T2,(PNTR)	;CURRENT LINE FOR "NA"
	MOVE	T2,INCST	;ELSE LAST LINE FOR "NP"
	PUSHJ	P,ASCIAD	;DO ARITHMETIC
	JRST	FSTLIN		;STASH NUMBER


SUBTTL	ALTER COMMAND

	DEFINE OFFRUB
<	TRZE FL2,RUBF2
	OUTSTR [ASCIZ /\\/]
	TRZE FL2,RUBF
	OUTCHR ["\"]>

	DEFINE ONRUB
<	TRZE FL2,RUBF2
	OUTSTR [ASCII /\\/]
	TRON FL2,RUBF
	OUTCHR ["\"]>

IFN STANSW, <
	HLPMSG <A command 	(Alter)
 
A<range>
 
	Subcommands
 
	  ?		Print list of alter commands
	 nC<ch>		Change n characters
	-nD		Delete next/last characters
	  E		Finish with no printing
	-nF<ch>		Find the nth next/previous occurrence of <ch>
	 nI<text>	Insert with temp increment n
	  J		Break line and stick rest at front of next
	-nK<ch>		Delete to n occurrences of <ch>
	  L		Print line and recycle
	  P		Print line and recycle to current position
	  Q		Quit ALTER (restore original line)
	-nR<text>	nD then 0I
	-nW		Skip forward n words
	 -X<text>	Delete word then 0I
	-nV		Invert case of next n characters
	  T		Transpose next two characters
	-n<SP>		Space forward/backward n characters
	  <CR>		Finish and print rest of line
	 n<RUB>		Backspace n characters
	 n<BS>		Backspace n characters
	 -<TAB>		Skip to end/start of line
	  ^U		Quit and restart ALTER
	  ^		Finish alter, jump to previous line
	  <LF>		Finish alter, jump to next line
	  <		Finish alter, jump to previous w/out printing
	  >		Finish alter, jump to next w/out printing
 
 
[Use CTRL/O now if you just wanted the summary]
 
Following is a description of the command to enter Alter mode,
and the function of the Alter mode subcommands:
 
 
A<range>
	Starts	Alter mode for	the specified range  of lines.	Alter
	mode allows  you  to edit  a  line, character  by  character.
	After  giving the A command,  give any one of  the Alter mode
	commands.   When you  terminate editing for  the current line
	(by  pressing the RETURN  key or giving the  E command), EDIT
	enters	Alter mode for the  next line until all  lines in the
	range have been altered.
 
 
			       Table of
			 Alter Mode Commands
 
     Some Alter mode commands are preceded by an  optional minus  sign
     which reverses the direction of the command.  Other commands have
     an optional argument n, which defaults  to  1  if	omitted.   The
     arguments in angle brackets (such as <space>) identify a specific
     key you are required to press.
 
     Command		      Function
 
     ?		    Prints a list of the Alter mode commands.
 
     nCchars	    Deletes  n	characters,  then  lets  you  type   n
		    characters	 (or   press   the  ESC  key  to  stop
		    inserting).
 
     -nD	    Deletes the next/last n characters.
 
     E		    Ends Alter mode for the current line, but does not
		    print the rest of the line on your terminal.
 
     -nFc	    Finds the next/last occurrence of the character c.
 
     nItext$	    Lets you insert  text,  starting  at  the  current
		    position,  until  you press the RETURN key (to end
		    Alter mode for the line) or the ESC  key  (to  end
		    just  the insert).	If you insert a linefeed,  the
		    rest of your line is inserted on a	new line  with
		    increment n.   If you omit n, the system uses 100.
 
     J		    Places  the  rest  of  the	current  line  at  the
		    beginning of the next line in the file.
 
     -nKc	    Deletes all the  characters  ahead/back  from  the
		    current  position  up  to  n  occurrences  of  the
		    character c.
 
     L		    Prints the rest of	the  line  and starts  at  the
		    beginning of the line again.
 
     P		    Print the rest of the line and  the  beginning  of
		    the  line,	leaving  you at your current position.
		    This command is useful  for  viewing  the  correct
		    contents of the line.
 
     Q		    Ends Alter mode for this range, without saving the
		    changes for this line.
 
     -nRtext$	    Deletes the next/last n characters, then given  an
		    automatic I command.
 
     -nW	    Skips forward/backward n words.
 
     -Xtext$	    Deletes the current or previous  word, then  gives
		    an automatic I command.
 
     -nV	    InVerts the case of the next n characters.	Lower
		    case becomes upper, and vice versa; all other
		    characters are unchanged.
 
      T		    Transposes the positions of the next two characters.
 
     -n<space>	    Skips forward/backward n characters.
 
     <RETURN>	    Ends Alter mode for this line and prints the  rest
		    of the line.
 
     n<backspace>   Skips backward n characters.
 
     -<tab>	    Skips to the beginning/end of the line.
 
     <CTRL/U>	    Restores the original  line,  but  leaves  you  in
		    Alter mode.
      <LF>	    Ends alter on this line, and skips to the next line.

      ^             Ends alter on this line, and skips to previous.

      <		    Ends alter without printing, and skips to previous.

      >		    Ends alter without printing, and skips to next line.
>
>; IFN STANSW


ALTER:	SETZM LOLN	;FOR START OF PAGE
	TRZ FL2,ADECIF	;THIS IS NOT DECIDE MODE ALTER
	PUSHJ P,GET2S	;GET THE RANGE
	TRNN FL,TERMF	;CHECK FOR PROPER END
	NERROR ILC	;UNEND
	MOVE T1,LOPG	;START TO PROCESS
	MOVEM T1,DPG
	MOVE SINDEX,LOLN
	PUSHJ P,FIND	;GO GET IT
	TRZ FL,LINSN	;NOT SEEN YET
ALT1:	PUSHJ P,ONMOV	;CHECK FOR IN RANGE
	JRST ALT2	;NO, FINISH UP
	TRO FL,LINSN	;WE DID SEE SOMETHING
	CAMN T1,PGMK	;CHEC FOR A PAGE
	JRST ALT3	;DO NNT TRY TO CHANGE THIS
	MOVEM T1,CLN	;NOW, IN CASE WE SAID ALTMODE
	MOVE T1,CPG	;SAME FOR PAGE
	MOVEM T1,CPGL
	PUSHJ P,ALTLIN	;GO DO THE ALTER
	JRST LEVINS	;HE SAID ALTMODE
	PUSHJ P,INSED	;GO INSERT
ALT4:	PUSHJ P,FINDN	;GET THE NEXT LINE
	PUSHJ P,FILLB	;AND CHECK FOR BUFFER OVERFLOW
	MOVE T1,(PNTR)	;GET LINE FOR ONMOV
	JRST ALT1	;CONTINUE LOOP
ALT3:	AOS T2,CPG	;WE ARE ON A LATER PAGE NOW
	MOVEM T2,CPGL	;SAVE AS .
	TRNN	FL2,NONUMF	;SKIP IF IN NONUMBER MODE
	PUSHJ P,PGPRN	;PRINT HIM A MESSAGE
	MOVE T1,[<ASCII /00000/>!1]	;SET TO FIRST? LINE
	MOVEM T1,CLN	;FOR .
	JRST ALT4	;CONTINUE PAST IT
ALT2:	TRNN FL,LINSN	;WAS THERE ANYTHING THERE?
	NERROR NLN	;NO, GIVE ERROR
	MOVE T1,CPG	;|ET CURRENT PAGEE
	MOVEM T1,CPGL	;SAVE AS .
	JRST COMND	;GO


IFE STANSW, <

ALTLIN:	PUSHJ P,SETALT	;SET UP LINE FOR ALTERATION

ALTN1:
ALTLP2:	MOVEI T2,0	;ZERO REPEAT COUNT
	TLZ FL,NEGF	;TURN OFF "-" SEEN FLG
ALTLP:	TRZ FL2,ALTDUP	;TURN DUPLEXING BACK OFF
	PUSHJ P,GNCH1	;GET ON CHR IN DDT SUBMODE
	TLNE CS,LETF_16	;CHECK FOR LETTER
	TRZ C,40	;AND CONVERT TO UPPER CASE
	MOVSI T1,-ALTLG	;GET LENGTH OF COMMAND TABLE
	CAME C,ALTAB1(T1)	;CHECK FOR EQUAL
	AOBJN T1,.-1	;NO, TRY AGAIN
	JUMPGE	T1,[CAIN C,15		;IGNORE CR'S
		    JRST ALTLP
		    JRST ALTBEL]
	MOVE	T1,ALTAB2(T1)	;GET TABLE ENTRY IN T1
	JUMPL	T1,ALTDSP	;"-" ALLOWED IF NEG.
	TLNN	FL,NEGF		;NO: IS IT SET?
	JRST	ALTDSP		;OK TO EXECUTE COMMAND
ALTBEL:	OUTCHR	[7]		;BONG A GONG
	CALL	CLRBFI		;CLEAR TYPE AHEAD
	JRST	ALTLP2		;TRY AGAIN

ALTDSP:	TLNN	T1,(1B1)	;OK IN ALL MODES?
	TRNN	FL,READOF	;NO -- CHECK R/O
	SKIPA			;YES -- DISPATCH
	JRST	ALTBEL		;R/O RING BELL
	PUSHJ	P,0(T1)		;DISPATCH
	JRST	ALTLP2		;RESET REPEAT COUNT AND GET NEW COMMAND
	JRST	ALTLP		;SKIP RETURN FROM DIGITS NO COUNT RESET

ALTAB1:	EXP " ","I","D","F","K","Q",12
	EXP "C",177,"U"-100,"W","X","R"-100
	EXP "R","L","P","J","E","-",10,11,"?"
	EXP "0","1","2","3","4","5","6","7","8","9","0"
ALTLG=.-ALTAB1

ALTAB2:	EXP <3B1+ALTSP>,ALTIN
	EXP <1B0+ALTDL>,<3B1+ALTSR>,<1B0+ALTKL>
	EXP <1B1+ALTALT>,<1B1+ALTFN>,ALTCN
	EXP <1B1+ALTBS>,<1B1+ALTCU>,<1B1+ALTWD>,ALTWX
	EXP <1B1+APRINR>,<1B0+ALTRP>
	EXP <1B1+ALTLN>,<1B1+APRINT>,AJOIN,<1B1+ALTEX>
	EXP <1B1+ALTNEG>,<1B1+ALTBS>,<3B1+ALTTB>,<1B1+AQUES>
	REPEAT ^D10,<<3B1+ALTDG>>

; ? PRINTS ALL THE LEGAL ALTER MODE COMMANDS

AQUES:	OFFRUB
	OUTSTR	[ASCIZ "
Alter commands are: C, D, E, I, J, K, L, P, Q, R, F, W, 
X, space, <CR>, Rubout, Backspace, Tab, and CTRL/U.
"]
APRINR:	PUSH	P,ALTCNT	;Save the current place
	PUSHJ	P,ALTLN1	;Print sequence number + tab
	POP	P,T2		;Retrieve current place
	CAILE	T2,0		;Print if greater then 0
	JRST	ALTSP
	POPJ	P,

ALTNEG:	TLO FL,NEGF
	JRST CPOPJ1

>; IFE STANSW


IFN STANSW, <

ALTLIN:	PUSHJ	P,SETALT	;SET UP LINE FOR ALTERATION
ALTN1:
ALTLP2:	MOVEI	T2,0		;ZERO REPEAT COUNT
	TLZ	FL,NEGF		;TURN OFF "-" SEEN FLG
ALTLP:	TRZ	FL2,ALTDUP	;TURN DUPLEXING BACK OFF
	PUSHJ	P,GNCH1		;GET ON CHR IN DDT SUBMODE
	TLNE	CS,LETF_16	;CHECK FOR LETTER
	TRZ	C,40		;AND CONVERT TO UPPER CASE
	PUSH	P,T2
	MOVSI	T1,-ALTLG	;GET LENGTH OF COMMAND TABLE
	LDB	T2,[POINT 7,ALTAB1(T1),17]
	CAME	C,T2
	AOBJN	T1,.-2		;NO, TRY AGAIN
	POP	P,T2
	MOVE	T1,ALTAB1(T1)	;GET TABLE ENTRY IN T1
	JUMPL	T1,ALTDSP	;"-" ALLOWED IF NEG.
	TLNE	FL,NEGF		;NO: IS IT SET?
	MOVEI	T1,ALTBEL	;YES.  THIS RATES A BELL
ALTDSP:	TLNN	T1,(1B1)	;OK IN ALL MODES?
	TRNN	FL,READOF	;NO -- CHECK R/O
	SKIPA			;YES -- DISPATCH
	MOVEI	T1,ALTBEL	;R/O FILE.  RING A BELL
	PUSHJ	P,0(T1)		;DISPATCH
	JRST	ALTLP2		;RESET REPEAT COUNT AND GET NEW COMMAND
	JRST	ALTLP		;SKIP RETURN FROM DIGITS NO COUNT RESET


;FLAGS:	2 IFF NEGATIVE REPEAT COUNT IS ALLOWED
;	1 IFF COMMAND IS VALID IN ALL MODES

DEFINE ALTCTM <
XX	(3,<" ">,ALTSP,<Space - Move cursor right>)
XX	(0,"I",ALTIN,<I  - Insert characters. Terminate with ESC>)
XX	(2,"D",ALTDL,<D  - Delete character>)
XX	(3,"F",ALTSR,<Fx - Find next "x">)
XX	(3,"S",ALTSR,<>)
XX	(2,"K",ALTKL,<Kx - Delete until next "x">)
XX	(1,"Q",ALTALT,<Q  - Quit without having changed anything>)
XX	(1,15,ALTFNZ,<RETURN - Finish this line>)
XX	(0,"C",ALTCN,<Cx - Change next character to "x">)
XX	(1,177,ALTBS,<BackSpace or RubOut - Move cursor left>)
XX	(1,"U"-100,ALTCU,<^U - erase all changes and start over>)
XX	(3,"W",ALTWD,<W  - Move cursor past next/previous word>)
XX	(1,"W"-100,ALTWBK,<>)
XX	(2,"X",ALTWX,<X  - Delete next word and enter Insert mode>)
XX	(2,"R",ALTRP,<R  - Delete next character and enter Insert mode>)
XX	(1,"L",ALTLN,<L  - Type rest of the line and start over>)
XX	(1,"P",APRINT,<P  - Like L but reposition cursor>)
XX	(1,"R"-100,APRINR,<>)
XX	(0,"J",AJOIN,<J  - Join characters at the right to next line>)
XX	(1,"E",ALTEX,<E  - Finish line - don't print>)
XX	(0,"T",ALTTSP,<T  - Transpose next two characters>)
XX	(2,"V",ALTINV,<V  - InVert the case of the next character>)
XX	(1,"^",AJMPUP,<^  - Jump to previous line>)
XX	(1,12,AJMPDO,<LINEFEED - Jump to next line>)
XX	(1,74,AJMPBK,<>)
XX	(1,76,AJUMP,<>)
XX	(1,"-",ALTNEG,<>)
XX	(3,11,ALTTB,<^I - Move cursor to end of line>)
XX	(1,"?",AQUES,<?  - This list>)
XX	(3,"0",ALTDG,<any digit - set repeat count for next command>)
XX	(3,"1",ALTDG,<>)
XX	(3,"2",ALTDG,<>)
XX	(3,"3",ALTDG,<>)
XX	(3,"4",ALTDG,<>)
XX	(3,"5",ALTDG,<>)
XX	(3,"6",ALTDG,<>)
XX	(3,"7",ALTDG,<>)
XX	(3,"8",ALTDG,<>)
XX	(3,"9",ALTDG,<>)
>;END OF ALTCTM

DEFINE XX(A,B,C,D)
<<BYTE (2)A(16)B>+C>

ALTAB1:	ALTCTM
ALTLG=.-ALTAB1
	300000,,ALTBEL		;CATCH ERRORS HERE

DEFINE XX(A,B,C,D)
<IFDIF <>,<D>,<[ASCIZ\D
\]>>

ALTQS1:	ALTCTM
	0

; ? PRINTS ALL THE LEGAL ALTER MODE COMMANDS

AQUES:	OUTSTR	[ASCIZ/
Alter mode commands follow.  "x" following a command character (e.g.,
Cx) means the command must be followed by a letter that is an
argument to the command.  Thus "CJ" means change the next character
to "J", etc.  Repeat counts may precede some commands.
/]
	MOVEI	T1,ALTQS1
AQUES1:	OUTSTR	@(T1)
	ADDI	t1,1
	SKIPE	(T1)
	JRST	AQUES1
	JRST	APRINR		;REPRINT BEGINNING OF LINE

ALTNEG:	TLO FL,NEGF
	JRST CPOPJ1

ALTBEL:	OUTCHR	[7]		;BONG A GONG
	CALL	CLRBFI		;CLEAR TYPE AHEAD
	POPJ	P,

>; IFN STANSW


SETALT:	SETZM LIBUF	;ZERO OUT INTERNAL LINE BUFFER
	MOVE T1,[XWD LIBUF,LIBUF+1]
	BLT T1,LIBUF+MXWPL+1
	MOVEI T1,LIBUF	;SET POINTER TO TRANSFER
	MOVE T2,PNTR
	MOVE T3,(T2)	;GET THE FIRST WORD (SEQ NUM)
	JRST SALT3
SALT2:	SKIPE T3,(T2)	;PICK UP A WORD AND CHECK FOR 0
	TRNE T3,1	;CHECK FOR SEQ NTM
	JRST SALT1	;END OF THIS LINE
SALT3:	MOVEM T3,(T1)	;SAVE IT AWAY
	ADDI T1,1	;INCREMENT POINTERS
	AOJA T2,SALT2
SALT1:	MOVE ALTP,[POINT 7,LIBUF+1,13]	;SET UP POINTER
	SETZM ALTCNT	;SO FAR WE ARE 0 CHRS INTO LINE
	SUBI T1,LIBUF	;GET COUNT OF OLD LINE
	HRRZM T1,OCNT	;AND SAVE IT FOR INSED
	CALL	NOECHO		;TURN OFF ECHO
	TRZ FL2,RUBF!ALTDUP!RUBF2   ;TURN OFF IN RUBOUT FALG AND NO DUPLEXING
	SETZM ALTFLG	;NOTHING INSERTED SO FAR
	TRNE	FL2,NONUMF	;SKIP IF NORMAL
	POPJ	P,		;ELSE RETURN
	MOVE T1,LIBUF
IFN STANSW, <			;PRINT THE LINE  --OO7
	CALL	OUTSN		;LINE NUMBER AND TAB
	TLNN	FL2,ALSOPT	;ANY AUTO-L SUPPRESSION?
	TRZE	FL2,ALTLSF	;ZERO THIS TEMP FLAG WHILE WE ARE AT IT.
	 RET			;RET IF EITHER SUPPRESSOR IS ON.
	JRST	ALTLN		;GOT GO-AHEAD ON AUTO-L.  SIMULATE L COMMAND.
>; IFN STANSW
IFE STANSW, <
	JRST	OUTSN
>; IFE STANSW

RPSALT=SALT1


GNCH1A:	TRNE FL2,COMFLF	;DO RDCHAR IF CMD FILE NOT ANSWERING
			;A TO DECIDE MODE
	JRST	[TRNE FL2,ADECIF
		 JRST .+1
		 PUSHJ P,RDCHAR
		 JRST GNCH1C]
	INCHRW C
	ANDI C,177
GNCH1C:
IFN STANSW, <
	CAIN C,10	;TREAT A BACKSPACE
	MOVEI C,177	;AS A RUBOUT
>; IFN STANSW
	CAME C,ESC	;NEVER DUPLEX ESC
	TRNN FL2,ALTDUP	;AND NOT UNLESS DESIRED
	POPJ P,
	CAIE C,12	;NOT LINE FEED
	CAIN C,15	;OR RETURN
	POPJ P,
	CAIN C,177	;AND FINALLY IGNORE RUBOUT
	POPJ P,
	OFFRUB		;IF WE ARE DUPLEXING WE ARE NOT DELETING
	OUTCHR C	;TYPE
	POPJ P,

GNCH1:	PUSHJ P,GNCH1A	;GET A CHR IN DDT MODE
	CAMN C,ESC	;CONVERT ALTMODE TO 200
	MOVEI C,200
	TLNN FL,QMODF
	CAIE	C,"'"	;CHECK FOR QUOTE
	JRST GNCH1B	;NO, THIS CHR IS OK
	PUSHJ P,GNCH1A	;GET ANOTHER
	SKIPE CTBL(C)	;IF 0 HN CTBL, KEEP IT
	MOVS C,CTBL(C)	;GET ALTERNATE CODE
	ANDI C,177	;GET RID OF EXTRA BITS
GNCH1B:	MOVE CS,CTBL(C)	;LOAD CS
	TLNE CS,LETF_16	;CHECK FOR LETTER
	TDC C,CASEBT	;AND APPLY CASE CONVERRION
	POPJ P,		;ALL DONE


ALTDG:	IMULI T2,^D10	;ACCUMULATE REPEAT COUNT
	ADDI T2,-"0"(C)
	JRST CPOPJ1	;SKIP RETURN SO AT NOT TO 0 RPT. CNT.

ALTTB:	MOVEI	T2,MXWPL*5+100	;LOTS OF SPACES
ALTSP:	TLNE FL,NEGF	;CHECK BACKWARDS
	JRST ALTBS	;YES: BACK SPACE
	OFFRUB

ALTSP2:	LDB C,ALTP	;GET THE CHR WE ARE POINTING AT
	CAIN C,15	;IF RETURN THEN AS FAR AS CAN GO
	JRST ALTSP1	;SO QUIT
	TRNN FL2,SUPN	;SPECIAL HACK FOR XTEND
	PUSHJ P,OCHR	;PRINT IT
	IBP ALTP	;ADVANCE POINTER
	AOS ALTCNT	;AND COUNT
	SOJG T2,ALTSP2	;DO CORRECT NUMBER OF TIMES
ALTSP1:	TRNN FL2,SUPN
	PUSHJ	P,FORCE		;DUMP IT
	POPJ P,

IFN STANSW, <

;MOVE CURSOR TO THE LEFT

ALTBS:	PUSHJ	P,ALTBAK	;GET PREVIOUS CHAR
	JUMPE	T3,ALTCBS	;JUMP IF DONE
	SOS	ALTCNT		;DECREASE COUNT
	MOVE	T1,DTYPE	;GET OUR TTY TYPE
	SKIPN	LFD(T1)		;SKIP IF WE AREN'T A DPY TTY
	JRST	ALTBS1		;GO DO A DISPLAY BACKSPACE
	ONRUB
	MOVE	C,T3
	PUSHJ	P,OCHR
	JRST	ALTBS2

ALTBS1:	CAIGE	T3,40		;SKIP IF BACKING OVER A NON-CONTROL CHAR
	JRST	[ CALL APRINR	;BACK OVER CONTROL CHARS BY REPRINTING LINE
		  JRST ALTBS2 ]
	OUTSTR	[BYTE(7) 10,40,10] ;DO A BACKSPACE
ALTBS2:	SOJG	T2,ALTBS	;MORE,MORE
	PUSHJ	P,FORCE
	POPJ	P,

>; IFN STANSW


ALTIN:	TRO FL2,ALTDUP		;TURN ON DUPLEXING
	MOVEM T2,ALTINC		;SAVE IN CASE HE INSERTS A RETURN
ALTIN1:	PUSHJ P,GNCH1		;GET A CHARACTER
	CAIN C,"R"-100		;CONTROL-R
	 JRST [	OFFRUB
		CALL APRINR	;PRINT LINE OVER
		JRST ALTIN1]	;CONTINUE INSERT
	CAIN C,"U"-100		;CONTROL-U
	 JRST ALTCU		;ABORT AND START OVER
IFN STANSW, <
	CAIN C,"W"-100		;CONTROL-W?
	 JRST ALTINW		;YES, GO ERASE A WORD
>; IFN STANSW
	CAIN C,15		;FINISH ON CR
	JRST ALTFNZ
	CAIN C,12
	JRST INSCR		;GO INSERT A CRLF
	CAIN C,200		;FINISH ON ALTMODE
	POPJ P,			;GO AWAY
	CAIN C,177	;CHECK FOR BACKSPACE
	JRST ALTIBS	;AND DELETE CHR TO LEFT
	MOVE T3,ALTP	;GET SET TO SHIFT THINGS
	PUSH P,ALTCNT	;SAVE THIS FOR LATER
	LDB T1,T3	;GET CHR FROM LINE
ALTIN2:	DPB C,T3	;SHIFT LINE
	JUMPE C,ALTIN3	;DONE
	AOS ALTCNT	;COUNT IT
	ILDB C,T3
	DPB T1,T3
	JUMPE T1,ALTIN3	;DONE
	AOS ALTCNT	;COUNT
	ILDB T1,T3
	JRST ALTIN2
ALTIN3:	MOVE T2,ALTCNT	;SEE IF OVERFLOW HAPPENED
	CAIL T2,MXWPL*5
	NERROR LTL	;YES
	POP P,ALTCNT	;RESTORE OLD COUNT
	IBP ALTP	;ADVANCE POINTER
	AOS ALTCNT	;AND COUNT
	JRST ALTIN1	;GO GET MORE


IFN STANSW, <

;HERE IS THE CODE THAT FAKES A CONTROL-W WHILE IN THE INSERT MODE 

ALTINW:	CALL	ALTWB0		;FIND A WORD DELIMITER
	JRST	ALTNW		;SUCCESS. NOW FAKE A CONTROL-W
	MOVEI	T1,7		;FAILURE, PROBABLY END OF LINE
	PBOUT			;RING A BELL
	JRST	ALTIN1		;AND CONTINUE INSERTION

ALTNW:	TLO	FL,NEGF		;WE ARE DELETING BACKWARDS
	HRRZ	T2,T2		;THIS IS THE CHARACTER COUNT
	CALL	ALTDL		;DELETE
	TLZ	FL,NEGF		;WE ARE DONE WITH THE BACKWARDS STUFF
	JRST	ALTIN1		;CONTINUE INSERTION

>; IFN STANSW


INSCR:	OFFRUB
	OCRLF
	SKIPN T1,ALTINC	;DID HE SPECIFY AN INCREMENT?
	SKIPA T3,INCR	;NO, USE STANDARD
	PUSHJ P,ASCON	;CONVERT TO ASCII
	MOVE T1,T3	;FIND THE NEW LINE NUMBER
	MOVE T2,LIBUF	;CURRENT ONE
	PUSHJ	P,FIXLIN
	  EXP	LIBUF
	JRST	[RERROR ORDER
		 PUSHJ P,FINDB	;GET BACK WHERE WE BELONG
		 PUSHJ P,ERCOR	;TYPE OUT LINE TO CURRENT POINT
		 JRST ALTIN1]	;AND CONTINUE INSERT
	MOVEM	T2,LIBUF2	;SAVE IT
	MOVEM T2,CLN	;AND SET AS CURRENT LINE
	PUSHJ P,FINDB	;BACK UP TO WHERE WE BELONG
	MOVE T1,[XWD LIBUF+1,LIBUF2+1]
	BLT T1,LIBUF2+MXWPL+1	;SAVE OLD BUFFER
	PUSH P,ALTP	;SAVE POINTER
	MOVEI C,15
	DPB C,ALTP	;AND TERMINATE THIS LINE
	MOVEI C,12
	IDPB C,ALTP
	MOVEI C,0	;FILL OUT LINE WITH NULLS
AINSC2:	TLNN ALTP,760000
	JRST AINSC3
	IDPB C,ALTP
	JRST AINSC2
AINSC3:	SUBI ALTP,LIBUF-1	;FIND COUNT
	HRRZM ALTP,NCNT
	PUSHJ P,INSED	;REPLACE OLD LINE
	PUSHJ P,FINDN	;MOVE UP TO NEXT
	PUSHJ P,FILLB	;AND DUMP IF OVERFLOW
	SETZM OCNT	;THIS IS A NEW LINE GOING IN
	MOVE T1,LIBUF2	;MOVE LINE NUMBER OVER
	MOVEM T1,LIBUF
	SETZM LIBUF+1
	MOVE T1,[XWD LIBUF+1,LIBUF+2]
	BLT T1,LIBUF+MXWPL+1	;ZERO OUT REST
	POP P,T2		;RESTORE POINTER TO REST OF LINE
	MOVE ALTP,[POINT 7,LIBUF+1] ;DEST POINTER
	ADD T2,[XWD 70000,LIBUF2-LIBUF]	;ADJUST INPUT POINTER
	TLZ T2,17		;CLEAR CARRY
	MOVEI C,11		;AND SET UP THE TAB
MOVNEW:	IDPB C,ALTP
	CAIN C,12
	JRST DONNEW		;FINISHED MOVING REST OF LINE
	ILDB C,T2		;PICK UP ONE
	JRST MOVNEW


DONNEW:	SUBI ALTP,LIBUF		;GET COUNT
	MOVEI ALTP,1(ALTP)	;USED TO BE - MOVEI AC,1-LIBUF(AC)
	MOVEM ALTP,NCNT
	PUSH P,ALTP		;AND SAVE
	PUSHJ P,INSED		;INSERT
	MOVE ALTP,[POINT 7,LIBUF+1,13]	;SET UP FOR ALTER
	SETZM ALTCNT
	POP P,OCNT		;SET FOR OLD COUNT
	MOVE T1,LIBUF
	TRNN	FL2,NONUMF	;SKIP IF NOT PRINTING
	PUSHJ P,OUTSN
	SETOM ALTFLG		;WE HAVE INSERTED AND ALTALT SHOULD CALL FILLB
	JRST ALTIN1		;AND CONTINUE INSERTING

;DELETE BACKWARDS ONE CHARACTER  - CALLED BY ALTIN

ALTIBS:	MOVEI T2,0		;SET COUNT TO 0
	MOVEM ALTP,SVALTP	;SAVE POINTER
	PUSHJ P,ALTBS		;DO A BACKSPACE
	EXCH ALTP,SVALTP	;GET BACK AND SAVE CURRENT
	PUSHJ P,ALTDL3		;DELETE THAT CHR
	JRST ALTIN1		;GET MORE



IFN STANSW, <

;CASE INVERSION -- V COMMAND

ALTINV:	OFFRUB
	TLNE	FL,NEGF		;BACKWARDS?
	 JRST	ALTIV3		;YES
ALTIV1:	LDB	C,ALTP
	CAIN	C,15		;END ON CR.
	JRST	ALTSP1
	MOVE	CS,CTBL(C)
	TLNE	CS,LETF_16
	TRC	C,40		;IS A LETTER.  INVERT IT.
	DPB	C,ALTP
	PUSHJ	P,OCHR
	IBP	ALTP
	AOS	ALTCNT
ALTIV2:	SOJG	T2,ALTIV1
	JRST	ALTSP1

ALTIV3:	CALL	ALTBAK		;BACK UP ONE
	JUMPE	T3,ALTSP1	;AT BEGINNING
	SOS	ALTCNT
	LDB	C,ALTP		;GET EXISTING CHAR.
	MOVE	CS,CTBL(C)
	TLNE	CS,LETF_16	;IS IT A LETTER?
	 TRC	C,40		;YES
	DPB	C,ALTP		;PUT IT BACK
	CALL	ALTDPB		;PRINT IT
	SOJG	T2,ALTIV3	;MORE TO DO?
	JRST	ALTSP1		;NO

;TRANSPOSE TWO LETTERS -- T COMMAND

ALTTSP:	OFFRUB
ALTTP1:	LDB	T1,ALTP
	CAIN	T1,15
	JRST	ALTSP1		;END IF FIRST IS NULL
	MOVE	T3,ALTP
	ILDB	C,T3		;GET SECOND CHARACTER
	CAIN	C,15
	JRST	ALTTP2		;IS CR.  JUST MOVE OVER T1
	PUSHJ	P,OCHR		;OUTPUT SECOND CHARACTER
	DPB	C,ALTP		;AND STORE IT IN THE LINE
	IBP	ALTP
	AOS	ALTCNT		;MOVE CURSOR PAST IT
ALTTP2:	MOVE	C,T1		;FIRST CHARACTER
	PUSHJ	P,OCHR
	DPB	C,ALTP
	IBP	ALTP
	AOS	ALTCNT
	SOJG	T2,ALTTP1
	JRST	ALTSP1
>; IFN STANSW



ALTDL:	TLNE FL,NEGF		;BACKWARDS?
	JRST ALTBDL		;YES:
	MOVEM ALTP,SVALTP	;SAVE CURRENT POINTER POSITHON
ALTDL1:	LDB C,ALTP		;GET CURRENT CHR
	CAIN C,15		;AT END OF LINE?
	JRST ALTDL5		;YES, GO FINISH OFF
	TRNN	FL,EXTOG	;PRINT ONLY IF NON-EXPERT
	PUSHJ P,ALTDPN		;YES: PRINT CHAR
	IBP ALTP		;ADVANCE POINTER
	SOJG T2,ALTDL1		;CHECK COUNT AND CONTINUE
ALTDL5:	PUSHJ	P,FORCE		;FORCE OUTPUT

IFE STANSW, <
ALTDL3:	MOVE T3,SVALTP		;GET BACK POINTER
ALTDL4:	LDB C,ALTP		;MOVE LINE DOWN
	DPB C,T3
	JUMPE C,ALTDL2		;DONE?
	IBP ALTP		;ADVANCE POINTERS
	IBP T3
	JRST ALTDL4
ALTDL2:	MOVE ALTP,SVALTP	;RESTORE POINTER AGAIN
	POPJ P,			;AND LEAVE


APRINT:	PUSH P,ALTCNT		;SAVE CURRENT COUNT
	PUSHJ P,ALTLN		;PRINT REST OF LINE AND START OVER
	POP P,T2		;GET BACK COUNT
	CAILE T2,0		;AND SPACE IF NOT 0
	JRST ALTSP
	POPJ P,

ALTDPN:	PUSH P,C
	MOVEI C,"\"
	TRNN FL2,RUBF2
	PUSHJ P,OCHR
	TRZE FL2,RUBF
	PUSHJ P,OCHR
	TRON FL2,RUBF2
	PUSHJ P,OCHR
	POP P,C
	JRST OCHR

>; IFE STANSW


IFN STANSW, <

ALTDL3:	MOVE T3,SVALTP		;GET BACK POINTER
	LDB C,ALTP		;MOVE LINE DOWN
	DPB C,T3
	JUMPE C,ALTDL2		;DONE?
ALTDL4:	ILDB C,ALTP		;SHIFT LINE, ONLY ONE CHAR. AT A TIME
	IDPB C,T3
	JUMPN C,ALTDL4		;DONE?
ALTDL2:	MOVE ALTP,SVALTP	;RESTORE POINTER AGAIN
	POPJ P,			;AND LEAVE


;DISPLAY DELETION, DEPENDING ON TERMINAL TYPE

ALTDPB:	MOVE	T1,DTYPE	;GET OUR TTY TYPE
	SKIPE	LFD(T1)		;SKIP IF WE ARE A DPY TTY
	JRST	ALTDP1		;JUMP TO THE NON-DPY BACKSPACE ROUTINE
	CAIGE	C,40		;SKIP IF BACKING OVER NON-CONTROL CHAR
	JRST	APRINR		;BACK OVER CONTROL CHAR BY REPRINTING LINE
	OUTSTR	[BYTE(7) 10,40,10] ;BACK OVER IT 
	RET

ALTDPN:	MOVE	T1,DTYPE	;GET TTY TYPE
	SKIPN	LFD(T1)		;ARE WE A DPY TTY?
	RET			;YES, RETURN
	TRNE	FL,EXTOG	;ARE WE EXPERTS?
	RET			;YES, RETURN
ALTDP1:	PUSH P,C
	MOVEI C,"\"
	TRNN FL2,RUBF2
	PUSHJ P,OCHR
	TRZE FL2,RUBF
	PUSHJ P,OCHR
	TRON FL2,RUBF2
	PUSHJ P,OCHR
	POP P,C
	JRST OCHR

>; IFN STANSW


ALTSR:	OFFRUB
	PUSHJ P,GNCH1	;GET THE CHARACTER TO SEARCH FOR
ALTSR1:	PUSH P,T2	;SAVE NUMBER OF TIMES TO SEARCH
	PUSHJ P,ALTCS	;CALL COMMON SEARCH ROUTINE
	PUSH P,C	;SAVE THE CHARACTER
	PUSHJ P,ALTSP	;GO SPACE CORRECT NUMBER
	POP P,C		;RESTORE CHR
	POP P,T2	;AND COUNT
	SOJG T2,ALTSR1	;CONTINUE
	POPJ P,

ALTCS:	MOVEI T2,1	;CREATE A REPEAT COUNT
	TLNE FL,NEGF	;BACKWARDS?
	JRST ALTBCS	;YES: SEARCH BACKWARDS
	LDB T3,ALTP	;CHEC TO SEE IF AT END OF LINE
	CAIN T3,15
	POPJ P,
	MOVE T1,ALTP	;GET A COPY OF THE POINTER
ALTCS1:	ILDB T3,T1	;GET A CHARACTER
	CAIE T3,15	;DONE IF END OF LINE
	CAMN T3,C	;OR A MATCH
	POPJ P,
	AOJA T2,ALTCS1	;ELSE KEEP COUNT AND KEEP LOOKING

ALTKL:	PUSHJ P,GNCH1	;ALMOST LINE ALTSR
	CAIE	C,12		;CHECK FOR K<LF>
	JRST	ALTKL1		;NO - REGULAR CASE THEN
	MOVEI	T2,MXWPL*5+100	;YES - DO SOME DELETING
	JRST	ALTDL		;...

ALTKL1:	PUSH P,T2
	PUSHJ P,ALTCS
	CAIE T3,0	;OFF FRONT END - SKIP
	CAIN T3,15	;BUT GIVE UP IF CHR NOT FOUND
	JRST T2POPJ
	PUSH P,C
	PUSHJ P,ALTDL	;DELETE THAT NUMBER
	POP P,C
	POP P,T2
	SOJG T2,ALTKL1
	POPJ P,
T2POPJ:	POP P,T2	;NEED TO CLEAR STACK
	POPJ P,


ALTALT:	OFFRUB
	SKIPN ALTFLG	;SHOULD WE DO A FILLB?
	JRST ALTAL1
	PUSHJ P,FINDN
	PUSHJ P,FILLB		;YES, WE HAVE INSERTED SOMETHING
ALTAL1:
	CALL	DOECHO		;DUMPLEXING BACK ON
T1POPJ:	POP	P,T1		;RESTORE T1
	RET			;  AND RETURN

;FINISH THIS LINE -- CR

ALTFNZ:	PUSHJ P,GNCH1
ALTFN:	MOVEI T2,MXWPL*5+100	;FINISH UP LINE
	PUSHJ P,ALTSP		;BY PRINTING A LARGE NUMBER OF SPCAES
ALTFNX:	OCRLF
	CALL	DOECHO		;GET OUT OF NON-DUPLEX MODE
ALTFN1:	ILDB C,ALTP		;LOOK ONE CHR OVER
	CAIE C,12		;THIS SHOULD BE THE LINE FEED
	NERROR ILFMT		;SOMETHING IS WRONG
	MOVEI C,0		;ZERO REMAINDER OF LINE
ALTFN2:	TLNN ALTP,760000	;ALL DONE?
	JRST ALTFN3		;YES
	IDPB C,ALTP		;NO, PUT IN ANOTHER 0
	JRST ALTFN2
ALTFN3:	SUBI ALTP,LIBUF-1	;GET SIZE OF NEW LINE
	HRRZM ALTP,NCNT		;AND SAVE FOR INSED
	AOS -1(P)		;SET FOR SKIP RETURN
	JRST T1POPJ		;RETURN TO CALLER OF ALTLIN


ALTCU:	OFFRUB
	OUTSTR [ASCIZ /^U
/]
	JRST SETALT		;GO RESTART LINE AND FORGET EDIT SO FAR

ALTRP:	PUSHJ P,ALTDL		;REPLACE IS DELETE THEN INSERT
	TLZ	FL,NEGF
	MOVEI T2,0
	JRST ALTIN


ALTCN:	OFFRUB
	TRO FL2,ALTDUP	;TURN ON DUPLEXING
ALTCN2:	LDB C,ALTP	;AT END OF LINE?
	CAIN C,15
	POPJ P,		;YES, STOP
ALTCN1:	PUSHJ P,GNCH1	;GET A CHARACTER
	CAIE C,177	;DO NOT LET HIM INSERT A RUBOUT
	CAIN C,15	;IGNORE CRET
	JRST ALTCN1
	CAIE C,200	;STOP ON ALTMODE AND LINE FEED
	CAIN C,12
	POPJ P,
	DPB C,ALTP	;REPLACE IT
	IBP ALTP	;ADVANCE POINTER
	AOS ALTCNT	;AND COUNT
	SOJG T2,ALTCN2	;CONTINUE
	POPJ P,



ALTEX:	OFFRUB
ALTEX1:	LDB C,ALTP
	CAIN C,15
	JRST ALTFNX
	IBP ALTP
	AOS ALTCNT
	JRST ALTEX1


AJOIN:	OFFRUB
	PUSHJ P,FINDN		;GO SEE IF NEXT LINE IS REALLY THERE
	CAME T1,PGMK
	SKIPN T1
	JRST ILCER		;MAKE IT ILLEGAL IF NO LINE THERE
	MOVEM T1,LIBUF2		;SAVE ITS NUMBER
	SETZM LIBUF2+1
	MOVE T1,[XWD LIBUF2+1,LIBUF2+2]
	BLT T1,LIBUF2+MXWPL+1	;CLEAR OUT REST OF BUFFER
	PUSH P,ALTP		;SAVE POINTER TO THIS LINE
	ADD ALTP,[XWD 70000,0]	;BACK IT UP
	MOVE T2,[POINT 7,LIBUF2+1]
	MOVEI C,11
	MOVEI T1,6		;COUNT THE CHARACTERS
MOVLIN:	IDPB C,T2
	ILDB C,ALTP
	CAIE C,15		;END OF LINE?
	AOJA T1,MOVLIN		;KEEP COUNT
	MOVEI ALTP,1(PNTR)	;GET POINTER TO SECOND LINE
	HRLI ALTP,(<POINT 7,0,6>)
ATRN1:	ILDB C,ALTP
	IDPB C,T2
	ADDI T1,1
	CAIL T1,MXWPL*5+6	;CHECK SIZE
	JRST LTLER
	CAIE C,12
	JRST ATRN1		;NOT DONE YET
	EXCH T2,(P)		;SAVE OUTPUT POINTER AND GET OLD ALTP BACK
	SUBI ALTP,-1(PNTR)	;GET OLD COUNT OF SECOND LINE
	PUSH P,ALTP		;AND SAVE IT
	MOVEI C,15		;FINISH CURRENT LINE
	DPB C,T2
	MOVEI C,12
	IDPB C,T2
	MOVEI C,0
INSC2:	TLNN T2,760000
	JRST INSC3		;FILL WITH NULLS
	IDPB C,T2
	JRST INSC2


INSC3:	SUBI T2,LIBUF-1		;GET COUNT
	HRRZM T2,NCNT
	PUSHJ P,FINDB		;BACK UP TO POINT TO IT
	PUSHJ P,INSED
	PUSHJ P,FINDN
	PUSHJ P,FILLB
	POP P,OCNT		;OLD COUNT
	HRRZS OCNT
	POP P,ALTP		;GET OUTPUT POINTER BACK
	SUBI ALTP,LIBUF2-1
	HRRZM ALTP,NCNT
	MOVE T1,[XWD LIBUF2,LIBUF]
	BLT T1,LIBUF+MXWPL+1
	PUSHJ P,INSED
	SETOM ALTFLG		;MARK AS NEED TO DO FILLB
	MOVE T1,NCNT		;GET THE COUNT JUST USED
	MOVEM T1,OCNT		;AND SET AS THE OLD COUNT
	MOVE ALTP,[POINT 7,LIBUF+1,13]	;SET UP
	SETZM ALTCNT
	OCRLF
	MOVE T1,LIBUF
	MOVEM T1,CLN		;SET UP CURRENT LINE
	TRNE	FL2,NONUMF	;SKIP IF NORMAL
	POPJ	P,
	JRST OUTSN		;AND PRINT NUMBER

LTLER:	RERROR LTL
	POP P,ALTP		;RESTORE ALTP
	SKIPA
ILCER:	RERROR NNN
	PUSHJ P,FINDB		;MOVE BACK TO RIGHT PLACE
ERCOR:	PUSH P,ALTCNT		;SAVE COUNT
	SETZM ALTCNT
	MOVE ALTP,[POINT 7,LIBUF+1,13]	;SET BACK TO START
	PUSHJ P,ALTCBS		;PRINT LINE NUMBER
IFN STANSW, <
	CALL NOECHO
>; IFN STANSW
	POP P,T2		;COUNT
	JUMPN T2,ALTSP		;AND SPACE OVER
	POPJ P,			;NO SPACES TO DO


IFE STANSW, <

ALTWD:	OFFRUB
ALTWD1:	PUSH P,T2	;SAVE COUNT IF ANY
	PUSHJ P,ALTWS	;SKIP OVER WORD
	ANDI T2,-1	;CLR FLAG IN CASE
	PUSHJ P,ALTSP	;SPACE CORRECTLY
	POP P,T2	;RESTORE COUNT
	SOJG T2,ALTWD1	;CONTINUE

;ROUTINE TO SKIP OVER NEXT WORD

ALTWS:	HRROI T2,0	;SET FLG AND COUNT
	MOVE T1,ALTP	;GET POINTER
	LDB T3,T1	;AND FIRST CHAR
	JRST .+2	;CHECK FOR CR & GO
ALTWS1:	ILDB T3,T1	;GET A CHARACTER
	CAIN T3,15	;DONE IF END OF LINE
ALTWS2:	POPJ P,
	MOVE T3,CTBL(T3);FETCH CHARATER TABLE ENTRY
	JUMPE T3,ALTWS4	;SKIP BLANKS ETC...
	ANDI T2,-1	;CLR FLAG
	JUMPG T3,ALTWS3	;SKIP LETTERS & NUMBERS
	TRNN FL2,QSEPF	;SEPARATORS
	TRNN T3,NSEPF	;TODAY
	POPJ P,		;REAL BREAK - QUIT!
ALTWS3:	AOJA T2,ALTWS1	;KEEP COUNT AND CONTINUE
ALTWS4:	JUMPL T2,ALTWS3	;FIRST BLNKS
	AOS T2
ALTWS5:	ILDB T3,T1
	CAIE T3,15	;QUIT ON CR
	SKIPE CTBL(T3)	;OR FIRST NON-BLANK
	POPJ P,
	AOJA T2,ALTWS5

ALTWX:	PUSHJ P,ALTWS	;SKIP WORD
	ANDI T2,-1	;CLR FLAG
	PUSHJ P,ALTDL	;DELETE CHARS
	MOVEI T2,0
	JRST ALTIN	;DO INSERT


ALTBS:	PUSHJ P,ALTBAK	;GET PREVIOUS CHAR
	JUMPE T3,ALTCBS	;JUMP IF DONE
	ONRUB
	MOVE C,T3
	PUSHJ P,OCHR
	SOS ALTCNT	;DECREASE COUNT
	SOJG T2,ALTBS	;MORE,MORE
	PUSHJ	P,FORCE
	POPJ P,

ALTCBS:	PUSHJ	P,FORCE	;FINISH BUFFER
	OFFRUB		;NO MORE RUB
	OCRLF
	TRNE	FL2,NONUMF ;MORE NONUMBER STUFF
	POPJ	P,
	MOVE T1,LIBUF	;ALSO PRINT SEQ NUM
	JRST OUTSN


ALTLN:	MOVEI T2,1000	;FINISH PRINTING THE LINE
	PUSHJ P,ALTSP
ALTLN1:	MOVE ALTP,[POINT 7,LIBUF+1,13]	;POINTER TO START
	SETZM ALTCNT	;RESET COUNT
	JRST ALTCBS	;AND PRETEND A BACKSPACE

>; IFE STANSW


IFN STANSW, <

; NW COMMANDS

ALTWBK:	TLO	FL,NEGF		; ^W IS EQUIVALENT TO -W.  GO BACKWARD
ALTWD:	TLNE	FL,NEGF		;BACKWARDS?
	JRST	ALTWB		;GO BACKWARD
	OFFRUB			;SKIP TO THE RIGHT, BY WORDS.
ALTWD1:	PUSH	P,T2		;SAVE COUNT IF ANY
	PUSHJ	P,ALTWS		;SKIP OVER WORD
	SETZM	(P)		;END OF LINE IMPLIES ALL DONE
	ANDI	T2,-1		;CLR FLAG IN CASE
	PUSHJ	P,ALTSP		;SPACE CORRECTLY
	POP	P,T2		;RESTORE COUNT
	SOJG	T2,ALTWD1	;CONTINUE
	RET			;ALL DONE

ALTWS:	HRROI	T2,0		;SET FLG AND COUNT
	MOVE	T1,ALTP		;GET POINTER
	LDB	T3,T1		;AND FIRST CHAR
	JRST	.+2		;CHECK FOR CR & GO
ALTWS1:	ILDB	T3,T1		;GET A CHARACTER
	CAIN	T3,15		;DONE IF END OF LINE
ALTWS2:	POPJ	P,
	MOVE	T3,CTBL(T3)	;FETCH CHARATER TABLE ENTRY
	JUMPE	T3,ALTWS4	;SKIP BLANKS ETC...
	ANDI	T2,-1		;CLR FLAG
	JUMPG	T3,ALTWS3	;SKIP LETTERS & NUMBERS
	TRNN	FL2,QSEPF	;SEPARATORS
	TRNN	T3,NSEPF	;TODAY
	RETSKP			;REAL BREAK - QUIT!
ALTWS3:	AOJA	T2,ALTWS1	;KEEP COUNT AND CONTINUE
ALTWS4:	JUMPL	T2,ALTWS3	;FIRST BLNKS
	AOS	T2
ALTWS5:	ILDB	T3,T1
	CAIN	T3,15		;QUIT ON CR
	 RET
	SKIPE	CTBL(T3)	;OR FIRST NON-BLANK
	 RETSKP
	AOJA	T2,ALTWS5

;SKIP TO LEFT BY WORDS. COUNT OF WORDS IN T2

ALTWB:	PUSH	P,T2		;SAVE COUNT IF ANY
	CALL	ALTWB0		;GO DO IT
	CALL	ALTBS		;SPACE CORRECTLY
	POP	P,T2		;RESTORE COUNT
	SOJG	T2,ALTWB	;LOOP TILL DONE
	RET

ALTWB0:	PUSH	P,ALTP		;SAVE POINTER
	CALL	ALTBAK		;ARE WE NOW AT THE BEGINNING?
	JUMPE	T3,ALTWBX	; YES--GIVE UP NOW
	MOVEI	T2,1		;SET COUNTER
ALTWB1:	MOVE	T3,CTBL(T3)	;FETCH CHARACTER TABLE ENTRY
	JUMPN	T3,ALTWB2	;NON-BLANK?
	CALL	ALTBAK		;BACK UP ONE
	JUMPE	T3,ALTWBR	;BEGINNING OF BUFFER?
	AOJA	T2,ALTWB1	; NO--KEEP GOING
ALTWB2:	JUMPG	T3,ALTWB3	;LETTER?
	TRNN	FL2,QSEPF	;SEPARATORS
	TRNN	T3,NSEPF	;HERE
	JRST	ALTWBR		; YES
ALTWB3:	CALL	ALTBAK		; NO--BACK UP MORE
	JUMPE	T3,ALTWBR	;BEGINNING OF BUFFER?
	MOVE	T3,CTBL(T3)	;FETCH CHARACTER TABLE ENTRY
	JUMPE	T3,ALTWBR	;BLANK?
	AOJA	T2,ALTWB2	; NO--KEEP GOING
ALTWBX:	AOS	-1(P)		;ADJUST RETURN ADDRESS
ALTWBR:	POP	P,ALTP		;RESTORE OLD ONE
	RET

;X COMMAND -- DELETE A WORD THEN INSERT
;REPEAT COUNT IS NOT PRESENTLY USED

ALTWX:	TLNE	FL,NEGF		;DELETE BACKWARDS?
	 JRST	[PUSHJ P,ALTWB0	;YES
		JRST ALTWX1
		JRST ALTBEL]	;CAN'T BACK OFF THE START OF LINE
	PUSHJ P,ALTWS		;SKIP WORD
ALTWX1:	HRRZ	T2,T2		;RETAIN ONLY THE COUNT
	PUSHJ	P,ALTDL		;DELETE CHARS
	MOVEI	T2,0		;NO ARGUMENT FOR THE INSERT PART
	TLZ	FL,NEGF		;DON'T CALL INSERT WITH NEGF SET
	JRST    ALTIN		;DO INSERT

;LINE PRINTING ROUTINES -- L AND P

ALTLN:	MOVEI T2,1000		;FINISH PRINTING THE LINE
	PUSHJ P,ALTSP
ALTLN1:	MOVE ALTP,[POINT 7,LIBUF+1,13] ;POINTER TO START
	SETZM ALTCNT		;RESET COUNT
	PUSHJ P,FORCE		;FINISH BUFFER
	OFFRUB
	OCRLF
	JRST ALTCB1		;PRINT SEQ. NUMBER FOR LINE

APRINT:	PUSH P,ALTCNT	;SAVE CURRENT COUNT
	PUSHJ P,ALTLN	;PRINT REST OF LINE AND START OVER
	POP P,T2	;GET BACK COUNT
	CAILE T2,0	;AND SPACE IF NOT 0
	JRST ALTSP
	POPJ P,


;REPRINT FIRST PART OF CURRENT LINE

APRINR:	PUSH	P,T2		;SAVE COUNT, IF ANY
	PUSH	P,ALTCNT	;SAVE THE CURRENT PLACE
	MOVE	ALTP,[POINT 7,LIBUF+1,13]
	SETZM ALTCNT
	PUSHJ	P,ALTCBS	;PRETEND A BS AT START OF LINE
	POP	P,T2		;RETRIEVE CURRENT PLACE
	CAILE	T2,0		;PRINT IF GREATER THAN 0
	 PUSHJ	P,ALTSP2
	POP	P,T2		;RESTORE COUNT FOR CALLER
	POPJ	P,


ALTCBS:	PUSHJ	P,FORCE		;FINISH BUFFER
	OFFRUB			;NO MORE RUB
	OUTCHR [15]		;PRINT A CR
	MOVE T1,DTYPE		;GET TERMINAL TYPE
	XCT CRLF(T1)		; AND PRINT THE APPROPRIATE CRLF, OR NOTHING
ALTCB1:	TRNE	FL2,NONUMF	;MORE NONUMBER STUFF
	POPJ	P,
	MOVE T1,LIBUF		;ALSO PRINT SEQ NUM
	JRST OUTSN

;JUMP COMMANDS -- LINE SWITCHING

;LF COMMAND -- JUMP NEXT, PRINTING
AJMPDO:	PUSH P,ALTCNT		;IN CASE FINDN BOMBS, REMEMBER SPOT. --OO7
	CALL ALTTB		;PRINT REST OF LINE
	POP P,ALTCNT
	JRST AJUMP		;DO JUMP-NEXT

;^ COMMAND = -LF -- JUMP PREVIOUS, PRINTING
AJMPUP:	PUSH P,ALTCNT		;IN CASE FINDB BOMBS, REMEMBER SPOT. --OO7
	CALL ALTTB
	POP P,ALTCNT		;FALLIN DO JUMP-PREVIOUS

;< COMMAND -- JUMP PREVIOUS WITHOUT PRINTING
AJMPBK:	TLO FL,NEGF		;SET TO JUMP BACKWARDS

;> COMMAND -- JUMP NEXT WITHOUT PRINTING
AJUMP:	OFFRUB
	PUSHJ P,[PUSHJ P,ALTEX]	;NOTE SCREWY ALTFN LINKAGE
	JRST ERCOR		;ERROR RETURN
	PUSHJ P,INSED		;REPLACE THIS LINE BEFORE MOVING ON.
	TLZE FL,NEGF		;TURN IT OFF AFTER LOOKING AT IT.  --OO7
	 JRST AJUMPB		;BACK
	PUSHJ P,FINDN		;FORWARD, IF POSSIBLE
	CAME T1,PGMK		;NO LINE THERE IS ILLEGAL
	SKIPN T1
	 JRST ILCER
	MOVEM T1,CLN		;CURRENT LINE
	JRST SETALT

AJUMPB:	CALL FINDBZ		;LOOK, BUT NOT PAST TOP OF PAGE.  --OO7
	CAME T1,PGMK		;NO LINE THERE IS ILLEGAL
	SKIPN T1
	JRST [	RERROR NLN
		CALL FINDN	;MOVE BACK TO THE RIGHT PLACE
		JRST ERCOR]
	MOVEM T1,CLN		;UPDATE CURRENT LINE NUMBER
	JRST SETALT

>; IFN STANSW

;COMMON ROUTINES TO MAKE LINE BACKUP

ALTBAK:	CAMN	ALTP,[POINT 7,LIBUF+1,13]
	JRST	ALTRTZ		;RETURN ZERO IF AT BEGINNING
	ADD	ALTP,[POINT 0,0,28]
	TLNE	ALTP,(<1B0>)	;CHECK WORD OVERFLOW
	SUB	ALTP,[POINT 0,1,0]
	LDB	T3,ALTP		;GET CHAR
	POPJ	P,

ALTRTZ:	MOVEI	T3,0		;RETURN 0
	POPJ	P,

ALTBCS:	PUSH	P,ALTP		;SAVE PNTR
ALTBC1:	PUSHJ	P,ALTBAK	;PREV CHAR
	JUMPE	T3,APOPJ	;END OF LINE
	CAMN	T3,C		;MATCH?
	JRST	APOPJ		;YES: RETURN
	AOJA	T2,ALTBC1	;NO: COUNT AND CONTINUE

APOPJ:	POP	P,ALTP		;RESTORE PNTR
	POPJ	P,		;RETURN

IFE STANSW, <

ALTBDL:	MOVEM	ALTP,SVALTP	;SAVE PNTR
ALTBD1:	PUSHJ	P,ALTBAK	;BACK A CHAR
	JUMPE	T3,ALTBD2	;DONE IF NO MORE
	MOVE	C,T3		;FOR PRINTING
	TRNN	FL,EXTOG	;PRINT IF NON-EXPERT
	PUSHJ	P,ALTDPN
	SOS	ALTCNT		;(198) DECREMENT COUNTER FOR ^R
	SOJG	T2,ALTBD1
ALTBD2:	PUSHJ	P,FORCE		;FORCE PRINTING
	PUSH	P,ALTP		;SAVE NEW PNTR
	MOVE	T3,SVALTP	;GET SET TO MOVE LINE
ALTBD3:	LDB	C,T3
	DPB	C,ALTP		;MOVE CHAR
	JUMPE	C,APOPJ		;DONE IF ZERO
	IBP	T3		;ADVANCE PNTRS
	IBP	ALTP
	JRST	ALTBD3
>; IFE STANSW

IFN STANSW, <

ALTBDL:	MOVEM	ALTP,SVALTP	;SAVE PNTR
ALTBD1:	PUSHJ	P,ALTBAK	;BACK A CHAR
	SOS	ALTCNT		;UPDATE COUNT
	JUMPE	T3,ALTBD2	;DONE IF NO MORE
	MOVE	C,T3		;FOR PRINTING
	PUSHJ	P,ALTDPB	;GO PRINT IT
	SOS	ALTCNT		;(198) DECREMENT COUNTER FOR ^R
	SOJG	T2,ALTBD1
ALTBD2:	PUSHJ	P,FORCE		;FORCE PRINTING
	PUSH	P,ALTP		;SAVE NEW PNTR
	MOVE	T3,SVALTP	;GET SET TO MOVE LINE
	LDB	C,T3
	DPB	C,ALTP		;MOVE CHAR
	JUMPE	C,APOPJ		;DONE IF ZERO
ALTBD3:	ILDB C,T3		;MOVE LINE VERY SLOWLY
	IDPB C,ALTP
	JUMPN C,ALTBD3
	JRST APOPJ		;DONE IF C IS ZERO

>; IFN STANSW

SUBTTL	INVERT

INVUP==1
INVLOW==2

IFN STANSW, <
	HLPMSG <V Command	(inVert case)
 
V<range>	   upper case becomes lower and vice versa
 
variations on the basic command:
 VV  same as V--upper to lower and vice versa
 VL  make all letters lowercase
 VU  make all letters uppercase
>
INVERT:	SETZM LOLN		;TREAT RANGES LIKE /. CORRECTLY
	PUSHJ	P,GNCH
	TRZ	JF,INVUP!INVLOW
	CAIE	C,"V"
	CAIN	C,"V"+40
	 JRST	INVG2S		;PERMIT VV... TO MEAN JUST V... .
	CAIE	C,"U"
	CAIN	C,"U"+40
	 TRO	JF,INVUP	;FORCE UPPERCASE.
	CAIE	C,"L"
	CAIN	C,"L"+40
	 TRO	JF,INVLOW	;FORCE LOWERCASE.
	TRNN	JF,INVUP!INVLOW
	 MOVEM	C,SAVC		;IF NEITHER, SIMPLE INVERT, SO RE-SCAN.
INVG2S:	PUSHJ	P,GET2S
	TRNN	FL,TERMF
	 NERROR	ILC
INVFND:	MOVE	T1,LOPG		;LOOK FOR FIRST LINE.
	MOVEM	T1,DPG
	MOVE	SINDEX,LOLN
	PUSHJ	P,FIND
	TRZ	FL,LINSN	;TO CHECK FOR NULL RANGE.
INVLP:	PUSHJ	P,ONMOV
	 JRST	NOMORE		;OUT OF RANGE NOW.
	CAMN	T1,PGMK
	 JRST	INVNXP		;IF A PAGEMARK, JUST JUMP OVER.
	TRO	FL,LINSN	;AT LEAST ONE LINE BEING WORKED ON.
	MOVEM	T1,CLN
	MOVEM	T2,CPGL		;UPDATE ./.,
	MOVE	T1,PNTR		;  THEN GET ACTUAL POINTER TO LINE.
	ADDI	T1,1
	HRLI	T1,(<POINT 7,,6>)
INVLP2:	ILDB	C,T1
	CAIN	C,CR
	 JRST	INVNXT		;END OF A LINE, SKIP TO NEXT.
	CAIL	C,"A"
	CAILE	C,"Z"+40
	 JRST	INVLP2		;ELIMINATE NON-ALPHA FROM INVERSION.
	CAIG	C,"Z"
	 JRST	INVUC
	CAIL	C,"A"+40
	 JRST	INVLC
	JRST	INVLP2		;AND CONTINUE TO <CR>.

INVUC:	TRNN	JF,INVUP	;HAVE AN UPPERCASE LETTER, WHAT TO DO...
	 TRO	C,40
	DPB	C,T1
	JRST	INVLP2

INVLC:	TRNN	JF,INVLOW	;DITTO, LOWERCASE...
	 TRZ	C,40
	DPB	C,T1
	JRST	INVLP2

INVNXP:	AOSA	CPG
INVNXT:	 HRRZM	T1,PNTR		;UPDATE TO AVOID REWORKING LINE.
	PUSHJ	P,FINDN
	JRST	INVLP

NOMORE:	TRZN	FL,LINSN
	 NERROR	NLN
	TLO	FL2,ALLCHG	;NOTE THAT WE'VE MADE CHANGES
	JRST	COMND

>; IFN STANSW

SUBTTL	THE / COMMAND

IFN STANSW, <
	HLPMSG </ Command	(set switch value)
 
/<on-off-switch>		set <on-off-switch> (turn it on)
/<value-switch>:<number>	set <value-switch> to <number>
 
See the topic SWITCHES for a list of settable and showable switches.
>
>; IFN STANSW
SET:	PUSHJ	P,SCAN		;GET THE THING TO SET TO
	CAIN	C,"?"		;IF ITS ?, GIVE LIST
	JRST	GVSTSW		;OF SETTABLE SWITCHES
	TRNN	FL,IDF		;MUST BE AN IDENT
	NERROR	ILC
	PUSHJ	P,DOSET		;CALL SUBROUTINE TO DO SET COMMAND
	NERROR	ILC		;ERROR RETURN
	JRST	COMND		;OK RETURN

DOSET:	PUSHJ	P,XCODE		;FETCH DISPATCH ARG
	TLZ	T1,477777	;CLEAR GIVE ADDRS
	PUSH	P,T1		;SAVE DISPATCH
	TLNN	FL2,INPARS	;SKIP TERM CHECK IF PARSE
	PUSHJ	P,SCAN		;AND CHECK FOR TERMINATOR
	CAIE	C,":"		;COLON OK ALSO
	CAIN	C,200		;IS IT AN ESC?
	JRST	SETVAR		;YES: SET SOMETHING
	POP	P,T1		;GET DISPATCH ADDR
	TLNN	T1,(1B1)	;BETTER NOT REQUIRE ARG
	PUSHJ	P,CKTERM	;CHECK LEGAL TERM
	POPJ	P,
	HRRZ	T1,T1
	JUMPE	T1,CPOPJ
	PUSHJ	P,0(T1)		;DO ROUTINE
	JRST	CPOPJ1		;GIVE OK RETURN

SETM33:	TRZA	FL,M37F		;MODEL 33
SETM37:	TRO	FL,M37F
	POPJ	P,

CLRSEQ:	TDZA	T1,T1
SETSEQ:	MOVNI	T1,1
	MOVEM	T1,UNSEQF
	POPJ	P,

SETRED:	TLNN	FL2,INPARS	;ILLEGAL IF NOT INITIAL
	NERROR	ILC
	TRO	FL,READOF
	POPJ	P,

SETDPY:	POPJ	P,		;NO-OP NOW


IFN STANSW, <
	HLPMSG <C128 mode (/C128 switch)
 
 
There  are 128 characters  that can be in  files.  Unfortunately, not
all of them have a  separate printing symbol.  So, to represent those
which  do not have their  own symbol, a combination  of two others is
used.  The first  of  these is always the apostrophe  or single quote
character (').  See the topic "Keyboard representation" for a list.
 
It is entirely possible for one  to never use /C128 mode and still be
satisfied  with  the  editor,	but  it  is  of  course  useful.   In
particular,  the  special  features described  in  the	help  section
"Special characters" need C128 mode to work.
 
To get out of /C128 mode, use the /C64 switch command.
 
When   in  C128  mode,	each   apostrophe  "swallows"  the  following
character, and	then the two of them  represent one single character.
So to  enter an  apostrophe, you  have to  type two,  with the	first
"swallowing"  the second to end  up represent what would  be a single
apostrophe in c64 mode.
>
>; IFN STANSW
QON:	TLZA	FL,QMODF
QOFF:	TLO	FL,QMODF
	POPJ	P,

SETDCD:	TLOA	FL2,PDECID
CLRDCD:	TLZ	FL2,PDECID
	POPJ	P,

SETOLD:	MOVEI	T1,1
	JRST	STOBAK
CLRBAK:	TDZA	T1,T1
SETBAK:	MOVNI	T1,1
STOBAK:	MOVEM	T1,BAKF
	POPJ	P,

QSON:	TROA	FL2,QSEPF
QSOFF:	TRZ	FL2,QSEPF
	POPJ	P,

SETNOV:	TRZA	FL,EXTOG
SETEXP:	TRO	FL,EXTOG
	POPJ	P,

SETUPP:	TDZA	T1,T1
SETLOW:	MOVEI	T1,40
	MOVEM	T1,CASEBT
	POPJ	P,


SETNUM:	TRZA	FL2,NONUMF
CLRNUM:	TRO	FL2,NONUMF
	POPJ	P,

SETVAR:	TLNN	FL2,INPARS
	JRST	SETV0		;SKIP OVER EXTRA IF NOT PARSE
	TRZ	FL,F.LAHD	;CLEAR LOOK-AHEAD
	SETZM	SAVCHR		;...
	SETZM	SAVC		;...
SETV0:	MOVE	T3,0(P)		;GET WHAT TO DO
	TLNN	T3,(1B1)	;NEED ARG
	JRST	SETV2		;NO: ERROR
	TLNN	T3,(1B2)	;NEED NUMERIC ARG?
	JRST	SETV1		;NO: JUST DISPATCH
	PUSHJ	P,SCAN		;GO GET NUMBER
	TRNN	FL,NUMF		;IS IT?
	JRST	SETV2		;NOPE - LOSE
	TLNE	FL2,INPARS
	JRST	SETV1		;SKIP TERM CHECK IN PARSE
	PUSH	P,T2		;SAVE IT
	PUSH	P,T1		;IN BINARY AND ASCII
	PUSHJ	P,SCAN		;CHECK FOR TERMINATOR
	POP	P,T1	;GET BACK ASCID
	POP	P,T2	;BINARY
	PUSHJ	P,CKTERM	;WHICH HAD BETTER BE THERE
	JRST	SETV2
SETV1:	POP	P,T3		;GET DISPATCH
	HRRZ	T3,T3
	JUMPE	T3,CPOPJ
	PUSHJ	P,0(T3)		;DISPATCH
	JRST	CPOPJ1		;AND RETURN TO CMD LOOP

SETV2:	POP	P,0(P)		;PRUNE PDL
	POPJ	P,		;AND GIVE ERROR RETURN

SETPLN:	MOVEM	T2,PLINES	;PLINES FOR P
	POPJ	P,

SETINC:	MOVEM	T1,INCR		;PERM INCREMENT
	MOVEM	T1,TECINC	;SETUP OTHER INCR
	POPJ	P,

SETSAV:	MOVEM	T2,SSAVEN	;STORE IN RESET PLACE TOO
	MOVEM	T2,SAVEN
	POPJ	P,


SETISV:	MOVEM	T2,SISAVN
	MOVEM	T2,ISAVEN
	POPJ	P,
IFN PPNTSW, <
SETLEN:	MOVEM	T2,PAGESZ
	POPJ	P,
>

IFN STANSW, <

;FOR THE JUSTIFY COMMANDS

SETLMR:	MOVEM	T2,LMAR		;SET LMAR
	POPJ	P,
SETPMR:	MOVEM	T2,PMAR		;SET PMAR
	POPJ	P,
SETRMR:	MOVEM	T2,RMAR		;SET RMAR
	POPJ	P,
SETMXL:	MOVEM	T1,MAXLN	;SET MAXLN (A LINE NUMBER)
	POPJ	P,

;THE /TYPE AND /NOTYPE SWITCHES  --OO7

ALSON:	TLOA	FL2,ALSOPT
ALSOFF:	TLZ	FL2,ALSOPT
	RET

>; IFN STANSW

;ROUTINES TO INPUT PASSWORDS

IFN CRYPSW, <

SETPAS:	TLNN FL2,INPARS		;MUST BE IN PARSE
	NERROR ILC
	CALL NOECHO		;TURN OFF ECHO
	SETZM ORGCOD		;INIT TO NULL
	SETZM NEWCOD		; CODES
	HRROI T3,[ASCIZ "INPUT PASSWORD: "]
	CALL GETPAS		;GET A PASSWORD
	 JRST [	OUTCHR ["-"]
		JRST SETPS1]	;ESC TYPED - NO PASSWORDS
	MOVEM T1,ORGCOD		;SAVE ORG SEED
	HRROI T3,[ASCIZ "OUTPUT PASSWORD: "]
	CALL GETPAS
	 JRST [	OUTSTR [ASCIZ "(SAME AS INPUT)"]
		MOVE T1,ORGCOD	;SAME AS INPUT IF ESC TYPED
		JRST .+1]
	MOVEM T1,NEWCOD		;SAVE NEW SEED
SETPS1:	OCRLF			;OUTPUT CRLF
	JRST DOECHO		;RESTORE ECHO

GETPAS:	PUSH P,T3		;SAVE MSG
GETPS1:	MOVE T3,0(P)		;GET MESSAGE TO PRINT
	OCRLF			;OUTPUT CR
	OUTSTR (T3)		;PRINT PROMPT
	HRROI T1,CODBUF		;POINT TO CODE BUFFER
	MOVE T2,[RD%BRK!RD%BEL+^D39]
	RDTTY
	 FJERR
	TLNN T2,(RD%BTM)	;VALID BREAK?
	JRST GETPS1
	POP P,T3		;RESTORE T3
	LDB T1,[POINT 7,CODBUF,6]
	CAIN T1,33		;SEE IF FIRST CHAR IS ESCAPE
	RET			;YES - RETURN NOW
	HRROI T1,CODBUF		;POINT TO STRING
	CALL CRASZ.##	;GET A SEED INTO T1
	JRST CPOPJ1
>; IFN CRYPSW


SETNAM:	MOVEI	ALTP,NEWBLK
	MOVSI	T1,(GJ%FOU!GJ%MSG!GJ%CFM);OUTPUT FILE
	CALL	READNM		;GET FILE SPEC
	  JRST	CKIND		;ERROR - MSG PRINTED
	  JRST	COMND		;^U RETURN
	CALL	CKTERM		;GRNTEE EOL
	  NERROR ILC		;SORRY FOLKS
	TRO	FL,NEWFL	;NEW FILE NAME SEEN
	PJRST	RLSRET		;RELEASE AND RETURN

SETRUN:	MOVEI	ALTP,RUNBLK	;DATA FOR NEW RUN SPEC
	MOVSI	T1,(GJ%OLD!GJ%CFM) ;EXISTING FILE
	HRROI	T2,[ASCIZ "EXE"] ;DEFAULT EXTN
	CALL	READNE		;GET SPEC
	  JRST	[TLNN	FL2,INPARS!INOPTF	;ERROR, FROM TTY INPUT?
		 JRST	CKIND		;YES
		 POPJ	P,]		;NO, JUST RETURN
	  JRST	COMND		;^U TYPED
	TLNE	FL2,INOPTF	;IN OPTION FILE?
	  JRST	[MOVE	T1,OPTJFN	;YES, GET JFN
		 BKJFN			;BACK UP TO PREVIOUS CHAR
		 JFCL			;LOSE
		 PUSHJ	P,GNCH		;READ IT
		 TLNE	CS,TERM_16 	;END OF LINE?
		 IORI	FL,TERMF	;YES, REMEMBER THAT
		 JRST	.+1]		;BACK TO MAIN CODE
	CALL	CKTERM		;GRNTEE EOL
	 NERROR	ILC
RLSRET:	MOVE	T1,JFN(ALTP)	;JFN
	RLJFN			;RELEASE  IT NOW
	  JFCL
	RET			;EXIT

;ROUTINE TO CHECK PROPER TERMINATION

CKTERM:	TLNE	FL2,INOPTF	;CHECK IF OPTION FILE
	JRST	CKTRM1
	TLNE	FL2,INPARS	;SEE IF CMD STRING
	JRST	CPOPJ1		;ALWAYS SAY PROPER TERM - PARSE WILL CHECK
CKTRM0:	TRNE	FL,TERMF	;PROPER LINE TERM?
	AOS	(P)		;YES
	POPJ	P,		;NON-SKIP IF NO

CKTRM1:	CAIE	C,"/"		;ALLOW SPECIAL CHARS
	CAIN	C,","		;IF IN OPTION FILE
	JRST	CPOPJ1
	CAIN	C,"-"		;IF NO SPEC CHRS FOUND
	JRST	CPOPJ1
	JRST	CKTRM0		;ALSO CHECK EOL

;HANDLE OPTION FILES

SETOPT:	PUSHJ	P,SCAN		;GET OPTION REQUESTED
	TRNE	FL,IDF		;CHECK FOR IDENT
	SKIPN	T1,ACCUM	;AND NON-ZERO ATOM
	NERROR	ILC
	MOVEM	T1,OPTION	;SET UP OPTION
	TLNE	FL2,INPARS	;INITIAL
	JRST	OPTSWT		;YES: USE SPECIIAL ROUTINE
	PUSHJ	P,SCAN		;CHECK TERM
	PUSHJ	P,CKTERM
	NERROR	ILC		;LOSE
	PUSHJ	P,DOOPT
	JRST	SETOP1		;NOT FOUND
	JRST	SETOP2		;GROSS ERROR
	POPJ	P,		;OK RETURN

SETOP1:	OUTSTR	[ASCIZ /? Option not found
/]
	POPJ	P,
SETOP2:	OUTSTR	[ASCIZ /? Syntax error in option file
/]
	POPJ	P,

SETSTP:	MOVEM	T1,TECINC	;SET UP INCRS
	MOVEM	T1,INCR
	POPJ	P,

SETFST:	MOVEM	T1,TECFST	;SET UP START
	POPJ	P,

SETNPG:	CAIG	T2,MAXPAG	;CHECK BOUNDS
	CAIGE	T2,MINPAG
	MOVEI	T2,DEFPAG	;USE DEFAULT IF NG
	MOVEM	T2,NPAGS	;SET WINDOW
	RET			;RETURN


SUBTTL	= COMMAND

IFN STANSW, <
	HLPMSG <= Command	(show switch setting)
 
=<switch>
 
See the topic SWITCHES for a list of settable and showable switches.
>
>; IFN STANSW
GIVE:	PUSHJ P,SCAN		;FIND OUT WHAT HE WANTS TO KNOW
	CAIN C,"."		;CURRENT LINE/PAGE?
	JRST GVDOT		;YES
	CAIN	C,"?"		;LIST OF PRINTABLE SWITCHES?
	JRST	GVPRSW		;YES
	TRNN FL,IDF		;IF NOT, MUST BE AN IDENT
	NERROR ILC
	PUSHJ P,XCODE		;FETCH ACTUAL SIXBIT ARG
	HLRZ	T1,T1		;GET GIVE ADDRS
	TRZ	T1,3B20		;CLEAR FUNNY BITS
	JUMPE	T1,XERR
	PUSH	P,T1		;SAVE DISPATCH
	PUSHJ P,SCAN		;CHECK FOR TERM
	TRNN FL,TERMF
	NERROR ILC
	POP P,T1		;NOW FIND OUT WHAT HE WANTS
	PUSHJ	P,0(T1)		;GIV INFO
	JRST	COMND		;AND RETURN


IFN STANSW, <

;HERE TO GIVE JUSTIFICATION SETTINGS

GIVLMR:	SKIPA	T1,LMAR
GIVPMR:	MOVE	T1,PMAR
	JRST	GIV2
GIVRMR:	MOVE	T1,RMAR
	JRST	GIV2

;ROUTINE TO PRINT OUT COLUMN NUMBERS ACCORDING TO TERMINAL WIDTH
;AND THE SETTING OF THE NONUMF FLAG.

GIVCOL:	MOVEI	T1,.PRIOU
	RFMOD			;READ TERMINAL MODE WORD
	HLRZ	T3,T2		;REPOSITION THE MODE WORD
	TRZ	T3,777000	;MASK OUT ALL BUT TTY WIDTH
	TRNE	FL2,NONUMF	;SUPPRESSING LINE NUMBERS?
	 JRST	GVCOL		;YES, DON'T FIDDLE WITH TABS, ETC
	MOVEI	T1,11		;NO,
	PBOUT			;OUTPUT A TAB
	SUBI	T3,10		;ADJUST LENGTH OF COLSTR
GVCOL:	MOVEI	T1,.PRIOU
	HRROI	T2,[ASCIZ "123456789-123456789-123456789-123456789-123456789-123456789-123456789-123456789-123456789-123456789-123456789-123456789-123456789"]
	MOVNS	T3		;THIS IS ITS LENGTH
	SOUT			;PRINT IT
	RET			;RETURN

;HERE TO TELL WHETHER ALTER AUTO-L COMMAND SIMULATION IS ON (/TYPE SWITCH).
; -- OO7

GIVALS:	MOVEI	T1,[ASCIZ "Alter mode will type out lines automatically"]
	TLNE	FL2,ALSOPT
	MOVEI	T1,[ASCIZ "Alter mode will not type out lines automatically"]
	OUTSTR	@T1
	RET

>; IFN STANSW


GIVBIG:	TRNE FL,BGSN		;HAVE WE SEEN THAT PAGE
	JRST GVBG1		;YES, ALL IS OK
	MOVSI T1,1		;WILL HAVE TO SEARCH FOR IT
	MOVEM T1,DPG
	MOVEI SINDEX,0
	PUSHJ P,FIND
	TRNN FL,BGSN		;SHOULD HAVE SEEN IT NOW
	ERROR ICN		;WE ARE IN TROUBLE
GVBG1:	MOVE T1,BGPG		;GET IT
GIV2:	MOVEI T3,OCHR		;ROUTINE FOR DECIMAL PRINTER TO OUTPUT TO
	PUSHJ P,DECPR		;PRINT DECIMAL
GIV3:	PUSHJ	P,FORCE		;FORCE OUTPUT
GIV1:
	OCRLF
	POPJ	P,

GVCASE:
	MOVE T1,DTYPE		;TERMINAL TYPE CODE
	OUTSTR @TTYPE(T1)
	OUTCHR [" "]
	TLNE FL,QMODF
	OUTSTR [ASCIZ /C64 /]
	TRNE FL2,QSEPF
	OUTSTR [ASCIZ /Separators /]
	MOVEI T1,[ASCIZ /Lower
/]
	SKIPN CASEBT
	MOVEI T1,[ASCIZ /Upper
/]
	;PRINT CURRENT CASE
	OUTSTR @T1
	POPJ	P,
GIVER:	SKIPN	T1,SVERN
	SKIPA	T1,[-1,,[ASCIZ "No previous error."]]
	HRRO	T1,ETBL-1(T1)	;LONG FORM OF MSG
	PSOUT			;DUMP IT
	OCRLF
	RET
IFN PPNTSW, <
GVPG:	MOVE T1,PAGESZ
	JRST GIV2
>
GVPLN:	MOVE	T1,PLINES
	JRST	GIV2

GVSAV:	SKIPGE	T1,SAVEN	;SAVE LEFT
	MOVEI	T1,0
	JRST	GIV2
GVISAV:	SKIPGE	T1,ISAVEN	;ISAVE LEFT
	MOVEI	T1,0
	JRST	GIV2


GIVDCD:	TLNN	FL2,PDECID
	OUTSTR	[ASCIZ "No "]
	OUTSTR	[ASCIZ "auto decide
"]
	POPJ	P,

GIVBAK:	SKIPN	BAKF
	OUTSTR	[ASCIZ "No "]
	OUTSTR	[ASCIZ "backup file will be created
"]
	POPJ	P,

GIVSEQ:	SKIPE	UNSEQF
	OUTSTR	[ASCIZ "No "]
	OUTSTR	[ASCIZ "sequence numbers will be on output file
"]
	POPJ	P,

GVINC:	MOVE T1,INCR		;GET CURRENT INCREMENT
	PUSHJ P,OUTSN		;GO PRINT IT
	JRST GIV1		;AND A CRRET

GVDOT:	PUSHJ	P,SCAN		;SEE IF A TERMINATOR IS THERE
	TRNN	FL,TERMF
	NERROR	ILC		;NO TERMINATOR
	MOVE	T2,CLN		;GET CURRENT LINE
	MOVE	T1,CPGL		;AND CURRENT PAGE
GVDOT1:	MOVEM	T2,LINOUT
	OUTSTR	LINOUT		;PRINT IT
	PUSHJ	P,GIV2		;PRINT PAGE
	JRST	COMND		;AND RETURN

OCTPR:	SKIPA CS,[^O10]
DECPR:	MOVEI CS,^D10
RDXPR:	IDIVI T1,0(CS)
	HRLM T2,(P)
	SKIPE T1
	PUSHJ P,RDXPR
	HLRZ C,(P)
	ADDI C,"0"
	JRST (T3)		;EXCEPT HAS ARBITRARY OUTPUT ROUTINE


GVSTR:	MOVEI T1,SRPNT		;GET THE POINTER TO POINTER BLOCK
	HRLI T1,-SRNUM		;SET COUNT
	OUTSTR [ASCIZ /	Find:
/]
	PUSHJ P,GVSTR3
	MOVEI T1,R2PNT
	HRLI T1,-SRNUM
	OUTSTR [ASCIZ /	Substitute:
/]
	PUSHJ P,GVSTR3
	MOVEI T1,R1PNT
	HRLI T1,-SRNUM
	OUTSTR [ASCIZ /	For:
/]
	PUSHJ P,GVSTR3
IFN EXTEND,<
	OUTSTR [ASCIZ /	Line-contents:
/]
	MOVEI T4,0
	MOVEI T5,LSNUM
	MOVEI T3,OCHR
GVST1:	MOVEI T1,1(T4)
	PUSHJ P,DECPR
	MOVEI C,":"
	PUSHJ P,OCHR
	PUSHJ	P,FORCE
	OCRLF
	MOVEI T1,-1(T5)
	IMULI T1,SRNUM
	ADDI T1,LSPNT
	HRLI T1,-SRNUM
	PUSHJ P,GVSTR3
	ADDI T4,1
	SOJG T5,GVST1
>
	POPJ	P,

GIVFST:	MOVE	T1,TECFST	;GET CURRENT START
	PUSHJ	P,OUTSN		;PRINT IT
	JRST	GIV1		;CRLF AND RETURN

GIVSTP:	MOVE	T1,TECINC	;GET INPUT INCR
	PUSHJ	P,OUTSN		;PRINT
	JRST	GIV1		;AND RETURN

GIVLOC:	MOVE	T2,BUFP		;GIVE HIM FIRST LOC IN BUFFER
	SKIPN	T2,0(T2)	;IF ANYTHING THERE
	MOVE	T2,[ASCII /00000/]
	MOVE	T1,OPG		;OUTPUT PAGE -1
	AOJA	T1,GVDOT1

GIVNPG:	SKIPGE	T1,NPAGS	;GET SIZE
	MOVEI	T1,DEFPAG	;DEFAULT IF NONE
	JRST	GIV2		;DECIMAL # AND EXIT


GVSTR3:	SKIPN T2,(T1)		;IS THERE ONE THERE?
	POPJ P,			;NO, DONE
GVSTR2:	ILDB C,T2		;NEXT CHR
	JUMPE C,GVSTR1		;DONE
	PUSHJ P,OCHR		;PRINT IT
	JRST GVSTR2		;AND CONTINUE
GVSTR1:	PUSHJ	P,FORCE		;CLEAR OUTPUT DEVICE
	OCRLF
	AOBJN T1,GVSTR3		;IF THERE IS ONE
	POPJ P,

GVNAM:	MOVEI	T4,ORGBLK
	SKIPE	NEWFIL		;NEW NAME GIVEN?
	MOVEI	T4,NEWBLK	;YES - USE IT
GVNM1:	OUTSTR	ASZ(T4)		;DUMP STRING
	JRST	GIV1

GVRUN:	SKIPN	RUNFIL		;NEW NAME GIVEN?
	JRST	GVRUN1		;NO - JUST TELL HIM OLD INFO
	MOVEI	T4,RUNBLK	;YES - USE NEW INFO
	JRST	GVNM1		;PRINT & RETURN

GVRUN1:	OUTSTR	[ASCIZ "Last LOAD class command"]
	JRST	GIV1

; Give location of next insert

GVPLAC:	MOVE	T1,CURINS	;GET LINE NUMBER WHERE I STARTS
	MOVEM	T1,LINOUT	;PUT IN LINE NO. OUTPUT LOC.
	OUTSTR	LINOUT		;OUTPUT LINE NUMBER AND SLASH
	MOVE	T1,IPG		;GET CORRESPONDING PAGE NUMBER
	JRST	GIV2		;OUTPUT NUMBER AND FORCE OUTPUT

; GIVE THE NAMES OF ALL THE SWITCHES

GVPRSW:	SETZ	T5,		;WE ARE GIVING PRINT SWITCHES
	SKIPA
GVSTSW:	SETO	T5,		;WE ARE GIVING SETTABLE SWITCHES
	PUSHJ	P,SCAN		;SEE IF A TERMINATOR IS THERE
	TRNN	FL,TERMF
	NERROR	ILC		;IF NOT, IT'S ILLEGAL
	MOVEI	T1,NAMASC	;GET BEGINNING OF NAME TABLE
	MOVEI	T2,NAMLEN	;GET ITS NEGATIVE LENGTH
	MOVEI	T3,NAMDSP	;GET LOC OF DISPATCH TABLE
GVSW:	JUMPE	T5,GVSW1	;IF GIVING PRINT SWITCHES, JUMP
	HRRZ	T4,(T3)		;RETRIEVE SET BITS
	SKIPA
GVSW1:	HLRZ	T4,(T3)		;RETRIEVE PRINT BITS
	PUSH	P,T5		;SAVE T5 ON STACK
	MOVE	T5,(T1)		;OBTAIN THE ADDRESS OF STRING
	JUMPE	T4,NOSW		;IF THEY ARE 0, NO PRINT
	OUTSTR	(T5)		;PRINT WHAT'S POINTED TO
	OCRLF			;AND A <CR><LF>
NOSW:	AOS	T1		;INCREMENT THE POINTERS
	AOS	T3		;CONTINUE
	POP	P,T5		;RESTORE T5
	SOJG	T2,GVSW		;DO ANOTHER SWITCH
	JRST	COMND		;THEN FINISH

COMMENT ! THIS HERE IS THE UNIQUE INITIAL SEGMENT DECODER
   STOLEN FROM THE PDP10 T-S MONITOR (SEE COMCON).
   IT TAKES THE ARGUMENT IN LOC 'ACCUM' AND RETURNS THE
   FULL SIXBIT VALUE IN SAME. !

DECODE:	MOVE T1,ACCUM		;FETCH ARG
	MOVNI T2,1		;SET MASK ALL ONES
	LSH T2,-6		;CLEAR OUT ONE MORE CHAR
	LSH T1,6		;SHIFT 1 COMMAND CHAR OFF
	JUMPN T1,.-2		;LUP UNTIL ALL GONE
	EXCH T2,ACCUM		;FETCH ARG IN T2 & SAVE MASK
	MOVNI T3,1		;CLEAR FOUND COUNT
LUP:	MOVE T4,@S1		;FETCH TABLE ENTRY
	TDZ T4,ACCUM		;MASK OUT CHARS NOT TYPED
	CAMN T2,@S1		;EXACT MATCH?
	JRST FOUND		;YES: THIS IS IT
	CAME T2,T4		;CLOSE MATCH?
	JRST LNEXT		;NO: KEEP TRYING
	AOJG T3,LNEXT		;FIRST TIME?
	HRRZ T5,S2		;YES: REMBER INDEX

LNEXT:	AOBJN S2,LUP		;NO: KEEP LOOKING
	SKIPN T3		;FIND ONLY ONE?
	MOVE S2,T5		;YES: OK TO USE SAVED VALUE
FOUND:	POPJ P,			;RETURN

XCODE:	PUSH	P,S1		;SAVE SPECIAL ACS
	PUSH	P,S2
	MOVE	S1,[S2,,NAMTAB]
	MOVSI	S2,-NAMLEN
	PUSHJ	P,DECODE
	MOVE	T1,NAMDSP(S2)	;GET DISPATCH ENTRY
	POP	P,S2		;RESTORE SPECIAL ACS
	POP	P,S1
	POPJ	P,

;THIS IS THE FULL NAME TABLE

	DEFINE NAMES <
X	(BAK,SETBAK,GIVBAK,0)
X	(BIG,0,GIVBIG,0)
X	(C128,QON,0,0)
X	(C64,QOFF,0,0)
X	(CASE,0,GVCASE,0)
IFN STANSW, <
X	(COLUMNS,0,GIVCOL,0)
>; IFN STANSW
X	(DECIDE,SETDCD,GIVDCD,0)
X	(DPY,SETDPY,0,0)
X	(ERROR,0,GIVER,0)
X	(EXPERT,SETEXP,0,0)
X	(INCREMENT,SETINC,GVINC,XNUMF)
X	(INSERT,0,GVPLAC,0)
X	(ISAVE,SETISV,GVISAV,XNUMF)
IFN PPNTSW, <
X	(LENGTH,SETLEN,GVPG,XNUMF)
>
IFN STANSW, <
X	(LMAR,SETLMR,GIVLMR,XNUMF)
>; IFN STANSW
X	(LOCATION,0,GIVLOC,0)
X	(LOWER,SETLOW,0,0)
X	(M33,SETM33,0,0)
X	(M37,SETM37,0,0)
X	(NAME,SETNAM,GVNAM,XVARF)
X	(NOBAK,CLRBAK,0,0)
X	(NODECIDE,CLRDCD,0,0)
X	(NONSEPARATORS,QSOFF,0,0)
X	(NONUMBER,CLRNUM,0,0)
IFN STANSW, <
X	(NOTYPE,ALSON,0,0)	; --OO7
>; IFN STANSW
X	(NOVICE,SETNOV,0,0)
X	(NUMBER,SETNUM,0,0)
X	(OLD,SETOLD,0,0)
X	(OPTION,SETOPT,0,0)
IFN CRYPSW, <
X	(PASSWORD,SETPAS,0,0)
>
X	(PLINES,SETPLN,GVPLN,XNUMF)
IFN STANSW, <
X	(PMAR,SETPMR,GIVPMR,XNUMF)
>; IFN STANSW
X	(R,SETRED,0,0)
X	(READONLY,SETRED,0,0)
IFN STANSW, <
X	(RMAR,SETRMR,GIVRMR,XNUMF)
>; IFN STANSW
X	(RONLY,SETRED,0,0)
X	(RUN,SETRUN,GVRUN,XVARF)
X	(SAVE,SETSAV,GVSAV,XNUMF)
X	(SEPARATORS,QSON,0,0)
X	(SEQUENCE,CLRSEQ,GIVSEQ,0)
X	(START,SETFST,GIVFST,XNUMF)
X	(STEP,SETSTP,GIVSTP,XNUMF)
X	(STRING,0,GVSTR,0)
IFN STANSW, <
X	(TYPE,ALSOFF,GIVALS,0)	; -- OO7
>; IFN STANSW
X	(UNSEQUENCE,SETSEQ,0,0)
X	(UPPER,SETUPP,0,0)
X	(WINDOW,SETNPG,GIVNPG,XNUMF)
>


	DEFINE	X(A,B,C,D) <
	EXP	<SIXBIT /A/>>

NAMTAB:
	NAMES

NAMLEN==.-NAMTAB

	DEFINE	X(A,B,C,D) <
	D+C,,B
>

XNUMF==3B20		;SET NEEDS NUMERIC ARG
XVARF==1B19		;SET NEEDS ARG

NAMDSP:
	NAMES

	XERR,,XERR

XERR:	NERROR	ILC

	DEFINE	X(A,B,C,D) <
	EXP	<[ASCIZ /A/]>>

NAMASC:
	NAMES


SUBTTL	LIST COMMAND

IFN STANSW, <
	HLPMSG <L Command	(List [on LPT:])
 
L<range>{,S}

Prints the  specified range  on the  line printer.   If no  range  is
specified,  prints the entire  file.  If the ,S  switch is specified,
the range is printed without line numbers or heading.
>
>; IFN STANSW
LIST:	TRZ FL2,SUPN		;ASSUME WE ARE GOING TO LIST LINE NUMBERS
	SETZM LOLN		;FOR START OF PAGE
	PUSHJ P,SCAN		;GET SOME INFORMATION
	CAIE C,","		;IS THERE A SWITCH?
	JRST LIST9		;NO
	PUSHJ P,SCAN		;YES, SCAN FOR IT
	MOVS T1,ACCUM
	CAIE T1,(<SIXBIT /S  />) ;IS IT S?
	NERROR ILC		;NO, LOSE
	TRO FL2,SUPN		;YES, SUPPRESS LINE NUMBERS
	PUSHJ P,SCAN		;AND SCAN PAST IT
LIST9:	TRNN FL,TERMF		;JUST A TERMINATOR
	JRST LIST7		;NO, GO LOOK FOR A COMMAND STRING
	MOVEI T1,1		;LIST ENTIRE FILE
	MOVEM T1,LOPG
	MOVSI T1,1		;FROM 1 TO IMPOSSIBLY HIGH
	MOVEM T1,HIPG
	TRZ FL,CNTF		;MAKE SURE THAT THIS FLAG IS OFF
IFN STANSW, <
	TRNE	FL,EXTOG	;EXPERT?
	 JRST	LIST8		;YES
	HRROI	T1,[ASCIZ/List entire file on Printer? /]
	PSOUT
	CALL	CONFRM		;WELL?
	 JRST	COMND		;NO
>; IFN STANSW
	JRST	 LIST8		;GO START WORK

LIST7:	PUSHJ P,GET2		;HAVE ALREADY SCANNED, GET 2 NUMBERS
	CAIE C,","		;IS THERE A SWITCH?
	JRST LIST10		;NO
	PUSHJ P,SCAN		;YES, SCAN FOR IT
	MOVS T1,ACCUM
	CAIE T1,(<SIXBIT /S  />) ;IS IT S?
	NERROR ILC		;NO, LOSE
	TRO FL2,SUPN		;YES, SUPPRESS LINE NUMBERS
	PUSHJ P,SCAN		;AND SCAN PAST IT
LIST10:	TRNN FL,TERMF		;END OK?
	NERROR ILC


LIST8:	
IFN STANSW, <
	HRROI	T1, [ASCIZ/[Listing to line printer]
/]
	PSOUT
>; IFN STANSW
	TRZ FL,LINSN		;NONE SEEN YET
	MOVE	T2,[POINT 7,LIBUF2] ;GRAB A RANDOM BUFFER
	SKIPA	T1,[POINT 7,[ASCIZ "LPT:"]]
	IDPB	T3,T2		;STASH CHAR
	ILDB	T3,T1		;GET CHAR
	JUMPN	T3,.-2		;STORE IF NON-NULL
	SKIPN	T1,NEWFIL	;NEW FILE NAME?
	MOVE	T1,ORGFIL	;NO - USE ORIGINAL
	HRLI	T1,(POINT 7,,)	;MAKE BP
STUFF:	ILDB	T3,T1		;GET A BYTE
	IDPB	T3,T2		;STUFF IT INTO BUFFER
	CAIE	T3,"."		; UNTIL . IS SEEN
	JRST	STUFF		;
	MOVE	T1,[POINT 7,[ASCIZ "LPT"]] ;EXTN
	ILDB	T3,T1		;GET A BYTE
	IDPB	T3,T2		; AND STUFF INTO LIBUF2
	JUMPN	T3,.-2		;LOOP TILL NULL
	HRROI	T2,LIBUF2	;PTR FOR GTJFN
	MOVSI	T1,(GJ%FOU!GJ%SHT)
	PUSHJ	P,GTJFNX	;GET LPT JFN
	  JERROR		;LOSSAGE
	MOVE	T2,[7B5+OF%WR]	;OPEN FOR WRITE
	OPENF			;...
	  JERROR		;MILD ANNOYANCE
	MOVEM	T1,LPTJFN	;SAVE JFN


	SETOM LOGPG		;LOGICAL PAGE TO 0
	MOVE T1,LOPG		;GET SET TO PRINT
	MOVEM T1,DPG
	MOVE SINDEX,LOLN
	PUSHJ P,FIND		;GO FIND IT
	SETZM LSTCNT		;COUNT OF NUMBER OF LINES PER PAGE
LST2:	PUSHJ P,ONMOV		;CHECK RANGE
	JRST LST6		;FINISH UP
	TRO FL,LINSN		;YEP, WE HAVE SEEN ONE
	CAMN T1,PGMK		;CHECK FOR PAGE MARK AND HANDLE SPECIAL
	JRST LST4
IFN STANSW, <
	MOVE T5,[POINT 7,LIBUF2]	;POINTER TO OUTPUT BUFFER
>; IFN STANSW
	MOVEM T1,CLN		;THE CURRENT LINE
	MOVEI T2,0		;COUNT OF NUMBER OF CHRS SEEN
	SOSLE	LSTCNT		;CHECK TO SEE IF RUN OUT
	JRST	LST2A		;NO - PROCEED
IFE STANSW, <
	MOVEI	C,14		;OUTPUT A FORM-FEED
	PUSHJ	P,POCHR
>; IFE STANSW
	PUSHJ	P,HDPRNT	;GO PRINT HEADING
LST2A:	MOVE T1,PNTR		;GET THE POINTER
	TRNN FL2,SUPN		;DO WE WANT TO SUPPRESS LINE NUMBERS?
	JRST LST3A		;NO
	AOS T1			;YES, SKIP A WORD
	HRLI T1,(<POINT 7,0,6>)	;AND A CHARACTER
	ADDI T2,6		;AND TELL PEOPLE WE HAVE DONE SO
	JRST LST3		;BEFORE GOING ON OUR WAY
LST3A:	HRLI T1,(<POINT 7,0>)	;AND SET UP BYTE POINTER
LST3:	ILDB C,T1		;GET CHR
	CAIGE	C,11		;CHECK ALL SPECIAL CASES
	JRST	LST3B
	CAIGE	C,15
	JRST	SPHD
	CAIN	C,15
	JRST	LST5
	CAIE	C,"'"
	CAIGE	C,40
	JRST	LST3B
	CAIGE	C,140
	JRST	LST5
LST3B:	TLNE	FL,QMODF	;CHECK QUOTE MODE
	JRST	LST5
	PUSH	P,C
	MOVEI	C,"'"
	PUSHJ	P,POCHR
	ADDI	T2,1
	POP	P,C
	LDB	C,[POINT 7,CTBL(C),10]
LST5:	PUSHJ	P,POCHR		;PRINT IT
	AOJA	T2,LST3		;COUNT AND CONTINUE


SPHD:	CAIN C,12		;LINE FEED IS END OF LINE
	JRST	[PUSHJ P,POCHR	;PRINT IT
IFN STANSW, <	PUSHJ P,POLIN	;OUTPUT THE LINE
>; IFN STANSW
		PUSHJ P,FINDN	;GET NEXT
		JRST LST2]	;AND GO
	CAIN C,11		;COUNT SPECIAL FOR TAB
	JRST	[ADDI T2,10
		ANDCMI T2,7
		PUSHJ P,POCHR
		JRST LST3]
	CAIN C,14
IFN STANSW, <
	JRST	[PUSHJ P,POLIN	;PRINT THE LINE
		 PUSHJ P,HDPRNT
		 JRST LST3]
>; IFN STANSW
IFE STANSW, <
	JRST	[PUSHJ P,POCHR	;FORM FEED GETS A HEADING
		PUSHJ P,HDPRNT
		JRST LST3]
>; IFE STANSW
	CAIN C,"\"		;NEEDS DELETE,DELETE
	JRST	[MOVEI C,177
		PUSHJ P,POCHR
		JRST LST5]	;AND AGAIN
	CAIE C,13		;VERT.TAB
	ERROR ICN		;CONFUSED
IFE STANSW, <
	PUSHJ P,POCHR
>; IFE STANSW
	MOVE T3,LSTCNT
	CAIG T3,<%LPP+2>/3
IFN STANSW, <
	JRST	[PUSHJ P,POLIN
		 PUSHJ P,HDPRNT
		 MOVE T5,[POINT 7, LIBUF2]
		 JRST LST3]
>; IFN STANSW
IFE STANSW, <
	JRST	[PUSHJ P,HDPRNT
		 JRST LST3]
>; IFE STANSW
	CAIG T3,<2*<%LPP+2>>/3
	MOVEI T3,<%LPP+2>/3
	CAIL T3,<2*<%LPP+2>>/3
	MOVEI T3,<2*<%LPP+2>>/3
	MOVEM T3,LSTCNT
IFN STANSW, <
	PUSHJ P,POCHR		; INSERT A VERTICAL TAB
>; IFN STANSW
	JRST LST3

LST4:
IFE STANSW, <
	MOVEI C,14		;PRINT A FORM FEED
	PUSHJ P,POCHR
>; IFE STANSW
	AOS T1,CPG		;GET PAGE CORRECTLY
	MOVEM T1,CPGL
	SETOM LOGPG		;ZERO LOGICAL PAGE AGAIN
	MOVEI T2,0		;THIS MUST BE ZERO SO GET IT THAT WAY
	PUSHJ P,HDPRNT		;PRINT A HEADER
	AOS LSTCNT		;INCREASE BY 1 TO MAKE IT COME OUT RIGHT
	PUSHJ P,FINDN		;ADVANCE
	JRST LST2		;AND CONTINUE

LST6:	MOVE	T1,LPTJFN	;RELEASE JFN
	CLOSF			;...
	  JERROR		;GRUMP
	TRZ FL2,SUPN		;TURN THIS OFF SO * PRINTS
	TRNN FL,LINSN		;WERE ANY SEEN?
	NERROR NLN		;NO, ERROR
	MOVE T1,CPG		;SET UP PAGE
	MOVEM T1,CPGL
	JRST COMND		;AND GET MORE COMMANDS


IFE STANSW, <
POCHR:	PUSH	P,T1		;SAVE REGS
	PUSH	P,T2
	MOVE	T1,LPTJFN	;JFN FOR LPT
	MOVE	T2,C		;COPY CHAR
	BOUT			;DUMP IT
	JRST	POPRET		;PRUNE AND EXIT
>; IFE STANSW

IFN STANSW, <
POCHR:	IDPB	C,T5
	RET

POLIN:	PUSH	P,T1		;SAVE REGS
	PUSH	P,T2
	PUSH	P,T3
	SETZ	T3,
	IDPB	T3,T5		;TIE OFF STRING
	MOVE	T1,LPTJFN	;JFN FOR LPT
	MOVE	T2,[POINT 7,LIBUF2] ;SOURCE
	SOUT			;DUMP THE STRING
	POP	P,T3
	JRST	POPRET		;PRUNE AND EXIT

>; IFN STANSW

HDPRNT:	PUSH	P,T1		;SAVE REGS
	PUSH	P,T2
	PUSH	P,T3
	MOVEI	T3,0		;INITIAL VALUE
	MOVE	T1,LPTJFN	;SET UP JFN
	TRNE	FL2,SUPN	;IF PRETTY PRINTING
IFE STANSW, <
	JRST HDPR3		;WE DON'T REALLY WANT TO DO THIS
	HRROI	T2,[BYTE (7) 15,11,11,11,0]
>; IFE STANSW
IFN STANSW, <
	JRST [MOVEI T2,14
	      BOUT		;SEND A CONTROL/L INSTEAD OF A HEADER
	      JRST  HDPR3 ]
	HRROI	T2,[BYTE (7)14,15,11,11,11,0]
>; IFN STANSW
	SOUT			;DUMP STRING (POSITION)
	MOVE	T2,ORGFIL	;FILE STRING PNTR
	SOUT			;PRINT IT
	MOVEI	T2,11		;SEPARATE WITH A TAB
	BOUT
	MOVNI	T2,1		;POLISH OFF WITH DATE AND TIME
	ODTIM
	HRROI	T2,[ASCIZ "	Page "]
	SOUT			;PAGE HEADING
	MOVE	T2,CPG		;GET CURRENT PAGE
	MOVEI	T3,^D10		;RADIX TO USE
	NOUT			;PRINT
	  FJERR
	AOSG	T2,LOGPG	;SEE IF OK TO PRINT
	JRST	HDPR3
	MOVEI	T2,"-"
	BOUT			;OUTPUT SEPARATOR
	MOVE	T2,LOGPG
	NOUT			;DUMP MINOR PAGE #
	  FJERR
HDPR3:	MOVEI	T3,0		;RESTORE T3
	HRROI	T2,[BYTE (7)15,12,12]
	SOUT			;DUMP RET AND 2 LFDS
	MOVEI	T3,%LPP		;RESET LINE COUNT
	MOVEM	T3,LSTCNT
	MOVE	T3,-1(P)	;GET COPY OF CHAR COUNT
	JUMPE	T3,HDPXIT	;IF 0 THEN ALL OK
	MOVEI	T2," "		;PRINT CORRECT NUMBER OF SPACES
	BOUT
	SOJG	T3,.-1
HDPXIT:	POP	P,T3		;RESTORE REGS
	JRST	POPRET		;AND EXIT


SUBTTL	REPLACE COMMAND

;RE-TYPE (REPLACE) COMMAND

IFN STANSW, <
	HLPMSG <R Command	(Replace)
 
R<range>{,<increment>}
 
Replace the specified lines.   Note:  This command is destructive, as
it first deletes (as if a  D were used) and then allows insertion (as
if an I were done).
>
>; IFN STANSW
REPLAC:	SETZM	LOLN		;I REALLY SHOULD PUT THIS ELSEWHERE
	SETZM	PGDELS		;INIT PAGE DELETED COUNTER
	SETOM	ISVINC		;DO NOT LET I<CR> USE ISVINC
	TRNE	FL,READOF	;NOT PERMITTED IN READ ONLY
IFE STANSW, <
	NERROR	ILC
>; IFE STANSW
IFN STANSW, <
	NERROR	IRO
>; IFN STANSW
	PUSHJ	P,GET2S		;WHAT DO WE WANT TO REPLACE?
	TRZ	FL,LINSN	;CLR FOR NOW
	PUSHJ	P,INSINC	;GO GET INCR
	PUSHJ	P,DELSUB	;DELETE SOME STUFF
	SKIPN	T1,LOLN		;WHERE TO START INSERTING
	MOVE	T1,[<ASCII /00100/>!1]
	MOVEM	T1,HILN		;SET UP FOR INSERT CODE
	MOVE	T2,LOPG
	MOVEM	T2,HIPG		;...
	SKIPE	PGDELS		;OK IF NONE DELETED
	SKIPN	T1,(PNTR)	;OR AT EOF
	JRST	REPLC1
	CAME	T1,PGMK		;ALSO END OF PAGE
	CAMLE	T1,FDELLN	;OR REALLY IN ORDER
	JRST	REPLC1
	AOS	CPG		;INSERT PAGE MARK TO PREVENT INSANITY
	AOS	INPG		;ADJUST PAGE COUNTERS
	AOS	BGPG
	MOVE	T1,PGMK		;SET UP PAGE MARK TO INSERT
	MOVEM	T1,LIBUF
	MOVE	T1,PGMKW2
	MOVEM	T1,LIBUF+1
	SETZM	OCNT		;STUFF FOR INSED
	MOVEI	T1,2
	MOVEM	T1,NCNT
	PUSHJ	P,INSED		;PUT IT IN
	PUSHJ	P,FINDN		;CREEP PAST IT
	PUSHJ	P,FILLB		;IN CASE OVERFLOW
	OUTSTR	[ASCIZ /%Page mark inserted to prevent order error
/]
REPLC1:	PUSHJ	P,DOINS		;LET HIM TYPE FOR A WHILE
	JRST	COMND		;RETURN

;SUBROUTINE TO DELETE THE LINE POINTED TO BY PNTR

DODEL:	SETZM	NCNT		;NEW IS 0
	MOVEM	T1,LDELLN
	PUSHJ	P,GETLTH	;OLD LENGTH
	MOVEM	T1,OCNT
	AOS	DELCNT		;COUNT OF LINES DELETED
	SKIPE	FDELLN		;FIRST TIME HERE
	JRST	INSED		;NO: GO INSERT AND RETURN
	MOVE	T1,LDELLN	;YES: SET UP FIRST LINE ETC.
	MOVEM	T1,FDELLN
	MOVE	T1,CPG
	MOVEM	T1,FDELPG
	JRST	INSED		;AND GO INSERT


SUBTTL	COMMON SEARCH ROUTINES FOR F AND S

COMMENT ! SOME COMMON ROUTINES FOR SEARCHING FILES!

COMMENT ! THIS ROUTINE GENERATES CODE FOR FINDING A MATCH
FOR THE FIRST CHARACTER OF A SEARCH STRING. THE POINTER
TO A SET OF BYTE POINTERS FOR SEARCH STRINGS IS IN T1 !



CODSR:	CALL CHKXCT	;(203) GET EXACT MATCH BIT SET UP
	MOVEI T2,CODEBF	;SET UP POINTER TO PLACETO PUT CODE
	MOVEI ALTP,0	;THE NUMBER OF THE CURRENT STRING
	HRLI T1,-SRNUM	;THE NUMBER OF STRINGS
CODS5:	TLZ FL,NEGF!DEMCHR	;TURN OFF THE  SEEN FLAG
	MOVE T3,(T1)	;GET A POINTER
	JUMPE T3,ENDCOD	;A ZERO BYTE POINTER IS END OF CODE
READCD:	ILDB C,T3	;PICK UP A CHARACTER IN STRING
	JUMPE C,[TLNE FL,DEMCHR	;DID WE REALLY WANT ONE
		NERROR ISS	;YES, LOSE
		SUBI T2,2	;NO, ALWAYS MATCH
		JRST COMXCT]
	CAIN C,""	;ARBIRARY NUMBER OF SOMETHING
	JRST ARBCD
	CAIN C,24	;ANY CHARACTER
	JRST ANYCD
	CAIN C,""	;NOT THIS ONE
	JRST	[TLC FL,NEGF
		TLO FL,DEMCHR	;WE REALLY JEED IT
		JRST READCD]
	CAIN C,"|"	;SEPERATOR
	JRST SEPCD
	CAIN C,""	;QUOTE THE NEXT CHARACTER
	JRST QUOTE
COMLET:	MOVE CS,CTBL(C)	;GET THE MAJIC BITS
	TLNN FL2,EXACT	;(203) EXACT SEARCH?
	TLNN CS,LETF_16	;OR NOT A LETTER
	JRST NORMCR	;YES JUST THE TEST
	HRLI C,(<CAIE C,>)	;DO A CAIE
	MOVEM C,(T2)
	XOR C,[XWD 4000,40]	;CAIN .XOR. CAIE = 4000,,0
	MOVEM C,1(T2)
	TLNE FL,NEGF	; THAT CHR
	JRST GENSKP	;GENERATE A SKIPA
COMXCT:	MOVE C,[XCT JSPR]	;THE CALL TO SEARCH FURTHER
	DPB ALTP,[POINT 4,C,12]	;AC FIELD GIVES STRING NUMBER
	MOVEM C,2(T2)
	ADDI T2,3	;ADVANCE OUTPUT POINTER
ENDSTR:	ADDI ALTP,1	;NEXT STRING
	AOBJN T1,CODS5	;IF ANY
ENDCOD:	MOVE C,[JRST COMSRT]	;A RETURN
	MOVEM C,(T2)
	POPJ P,


SEPCD:	MOVE C,[SKIPG CS,CTBL(C)]	;GET BITS
	MOVEM C,(T2)
	MOVE C,[TRNE CS,NSEPF]	;CHECK FOR %,$,OR .
	TRNE FL2,QSEPF		;SEPARATORS?
	MOVSI C,(<SKIPA>)	;YES;
	MOVEM C,1(T2)
	TLNE FL,NEGF	;SKIPA IN NORMAL CASE
	JRST COMXCT
GENSKP:	MOVSI C,(<SKIPA>)
	MOVEM C,2(T2)
	AOJA T2,COMXCT	;SO XCT WILL GO IN RIGHT PLACE

QUOTE:	ILDB C,T3	;GET NEXT CHR
	JUMPE C,[NERROR ISS]	;END OF STRING IS ILLEGAL
	JRST COMLET	;TREAT AS NORMAL CHARACTER

NORMCR:	HRLI C,(<CAIN C,>)	;EXACT OR NOT LETTER
	TLNE FL,NEGF
	TLC C,4000		;CAIN .XOR. CAIE = 4000,,0
NORMC1:	MOVEM C,(T2)
	SOJA T2,COMXCT	;MAKE THE XCT GO IN RIGHT PL@CE

ANYCD:	MOVE C,[CAIE C,15]	;SPECIAL FOR EOL
	TLNE FL,NEGF
	TLC C,4000		;CAIN .XOR. CAIE = 4000,,0
	JRST NORMC1

ARBCD:	ILDB C,T3	;GET NEXT
	CAIN C,""	;JUST CHECK VALIDITY
	JRST ARBCD
	CAIN C,""
	ILDB C,T3
	JUMPE C,[NERROR ISS]	;END OF STRING ERROR
	JRST READCD	;LOOK FOR FIRST OTHER CHR

JSPR:	JSP T1,SRCRET	;CALL CONTINUE SEARCH


;READ INTHE STRING TO SEARCH FOR
;T3 HAS PLACE TO PUT POINTERS T1 A BYTE POINTER FOR STRINGS


SSTRNG:	MOVEI T2,SRBLG	;THE PERMISSIBLE LENGTH
	HRLI T3,-SRNUM	;T3 HAS POINTER TO PLACE BYTE POINTERS
SSTR0:	MOVEM T1,SVPT	;SAVE THE POINTER FOR END OF STRING
SSTR1:	PUSHJ P,GNCH	;GET A CHR
	CAIN C,200	;ALTMODE TERMINATES
	JRST SSTEND
	CAIN C,15	;IGNORE RETURNS
	JRST SSTR1
	CAIN C,12	;LINE FEED IS END OF ONE STRING
	JRST SSTR2
	IDPB C,T1	;PUT IN OUTPUT STRING
	SOJG T2,SSTR1
SSTR3:	RERROR STL	;THE STRING WAS TOO LONG
SSTR4:	HRLZ T1,T3	;ZERO OUT FIRST POINTER
	MOVNS T1
	ADDI T1,-SRNUM(T3)	;FIND START
	SETZM (T1)
	JRST COMND
SSTR2:	CAMN T1,SVPT	;NULL STRING?
	JRST	[HLRZ C,T3	;FIRST ONE?
		CAIE C,-SRNUM	;WELL?
		JRST .+1	;NO
		MOVEI C,12	;RETURN A LINE FEED
		POPJ P,]
RETSTR:	MOVEI C,0	;TERMINATE STRING WITH 0
	IDPB C,T1
	SOJLE T2,SSTR3
	MOVE C,SVPT	;SET UP POINTER
	MOVEM C,(T3)
	AOBJN T3,[MOVE C,FSFLG	;GET F/S PROMPT
		  MOVEM C,CRBUF	;TO ^R BUFFER
		  OUTSTR CRBUF	;DUMP PROMPT
		  JRST SSTR0]	;IF ROOM FOR MORE, GET THEM
	RERROR TMS	;TOO MANY GIVEN
	JRST SSTR4
SSTEND:	CAIN T2,SRBLG	;DID WE SEE ANY?
	POPJ P,		;NO, RETURN
	MOVEI C,0	;YES, TERMINATE LAST
	IDPB C,T1
	MOVE T1,SVPT
	MOVEM T1,(T3)	;SET POINTER
SSTR5:	AOBJP T3,CPOPJ1	;ZERO OUT OTHER POINTERS
	SETZM (T3)
	JRST SSTR5

IFN STANSW,<			;--OO7
GCOLS:	MOVNI T3,1		;DEFAULT COLUMN RANGE IS -1 TO INFINITY
	MOVEM T3,LOCOL
	TLZ T3,(1B0)
	MOVEM T3,HICOL
	CAIE C,"#"		;COLUMNS SPACEIFIED?
	 RET			;NOOP, NO OP
	CALL GCNUM		;SET LOCOL TO NUMBER SPECIFIED LESS 1
	MOVEM T2,LOCOL
	MOVEM T2,HICOL		;AND NOW DEFAULT TO EXACTLY ONE COLUMN
	CALL SCAN		;CHECK FOR HIGH COLUMN SPECIFICATION
	CAIN C,":"
	 JRST GHICOL
	CAIE C,"!"
	 RET
	CALL GCNUM		;HICOL TO BE LOCOL+NUMBER SPECIFIED LESS 1
	ADD T2,LOCOL
	JRST CKHICL
GHICOL:	CALL GCNUM		;SET HICOL TO NUMBER SPECIFIED LESS 1
CKHICL:	CAMGE T2,LOCOL		;CHECK FOR CONSISTENCY
	 NERROR ILC
	MOVEM T2,HICOL
	PJRST SCAN

GCNUM:	CALL SCAN
	TRNN FL,NUMF		;BETTER BE A NUMBER
	 NERROR ILC
	SOJA T2,CPOPJ		;RETURN 1 LESS THAN NUMBER SPECIFIED
>; IFN STANSW

CHKXCT:	TLZ FL2,EXACT	;(203) RESET EXACT MATCH BIT
	TLNN FL,EXCTS1!EXCTSR ;(203) EXACT MATCH WANTED?
	RET		;(203) NO, JUST RETURN
	TLNN FL2,SRCWHO	;(203) WHO CALLED US?
	JRST CHKXC1	;(203) SET MEANS SUBST
	TLNE FL,EXCTSR	;(203) DID SEARCH SET HIS BIT?
	TLO FL2,EXACT	;(203) YES
	RET		;(203) RETURN
CHKXC1:	TLNE FL,EXCTS1	;(203) DID SUBST SET HIS BIT?
	TLO FL2,EXACT	;(203) YES WANT EXACT MATCH
	RET		;(203) RETURN

;THE SEARCH ITSELF

COMSRC:	CALL CHKXCT	;(203) SET UP EXACT MATCH
	MOVEM T2,BUFSAV	;SAVE THE POINTER TO STRINGS
	MOVNI T3,1	;THE COUNT OF HOW FAR INTO LINE WE ARE
	MOVEI ALTP,1(PNTR)	;SET BYTE POINTER
	HRLI ALTP,(<POINT 7,0,6>)
	MOVEI C,15	;START WITH A LINE DELIMITER
IFN STANSW,<			;--OO7
	JRST COMSR1
COMSRT:	CAIN C,"	"	;IS IT A TAB?
	 TRO T3,7
	ILDB C,ALTP		;YES, GET NEXT COLUMN
	CAIE C,15		;STOP ON CR
	 CAML T3,HICOL		;TOO HIGH
	  RET			;SEARCH FAILED BECAUSE LINE TOO SHORT
	ADDI T3,1
COMSR1:	CAMGE T3,LOCOL
	 JRST COMSRT		;CHECK NEXT COLUMN
>; IFN STANSW
	JRST CODEBF	;GO SCAN
IFE STANSW,<
COMSRT:	ILDB C,ALTP	;WE RETURN HERE IF NO MATCH FOR THIS ONE
	CAIE C,15	;DONE?
	AOJA T3,CODEBF	;NO, GO ON
	POPJ P,		;YES, NON-MATCH RETUNR
>; IFE STANSW

SRCRET:	PUSH P,T1	;SAVE THE RETURN ADDRESS
	PUSH P,ALTP	;AND THE STRING POINTER
	PUSH P,C	;AND THE CHARACTER
	LDB T1,[POINT 4,-1(T1),12]	;GET STRING NUMBER
	ADD T1,BUFSAV	;POINT TO BYTE POINTER
	SKIPN T1,(T1)	;GET IT
	ERROR ICN	;THERE SHOULD BE ONE THERE
	MOVE T2,[POINT 7,ARBBUF]	;SET UP ARBIT MATCH
	MOVEI T4,MXWPL*^D10	;POINTER AND COUNT
	SETZM ARBCNT	;THE NUMBER OF ARBITRARY MATCHES SEEN
	TLZ FL,ARBITG	;OFF AT START
	PUSHJ P,LINMAT	;GO CHECK FOR MATCH
	JRST LOSE	;WE LOSE, CONTINUE SCAN
	MOVEM ALTP,SRCALP	;POINTER TO END OF STRING
	POP P,C	;RESTORE
	POP P,ALTP
	POP P,T1
CPOPJ1:	AOS (P)	;SKIP RETURN
	POPJ P,
LOSE:	POP P,C	;RESTORE
	POP P,ALTP
	POPJ P,	;AND CONTINUE SEARCH


NXTCHR:	CAIN C,12	;WAS THAT LAST OF LINE?
	POPJ P,	;YES, LOSE 
	ILDB C,ALTP	;NO, TRY NEXT
LINMAT:	PUSHJ P,CHRMAT	;CHECK FOR MATCH
	POPJ P,	;NONE, RETURN
	CAIE CS,0	;IS SO ALL DONE
	JRST NXTCHR	;NO, TRY MORE
	JRST CPOPJ1	;SKIP RETURN


CHRMAT:	TLZ FL,NEGF!DEMCHR	;NO  SEEN AND CHR CAN BE 0
READCH:	ILDB CS,T1	;GET NEXT
	JUMPE CS,MATCH	;END OF STRING IS USUALLY GOOD
	CAIN CS,""	;CHEC FOR NEGATE
	JRST	[TLC FL,NEGF
		TLO FL,DEMCHR	;MUST BE FOLLOWED BY A CHR
		JRST READCH]
	CAIN CS,"|"	;SEPERATOR?
	JRST SEP
	CAIN CS,""	;ARBITRARY NUMBER
	JRST ARBIT
	CAIN CS,24	;ANY?
	JRST ANY
	CAIN CS,""	;QUOTE NEXT?
	JRST	[ILDB CS,T1
		JUMPN CS,.+1	;MUST HAVE ONE THERE
		NERROR ISS]	;ELSE ILLEGAL
	CAMN C,CS	;ARE THEY THE SAME
	JRST ISTRU1	;YES, CHECK NEGF
	MOVE T5,CTBL(CS)	;GET BITS
	TLNN FL2,EXACT		;(203) EXACT SEARCH?
	TLNN T5,LETF_16	;OR NOT LET
	JRST ISFALS	;NO MATCH
	XORI CS,40	;CHECK OTHER CASE
	CAMN C,CS
	JRST ISTRU1
	JRST ISFALS	;LOSE


MATCH:	TLNE FL,DEMCHR	;DID WE NEED A CHARACTER THERE?
	NERROR ISS	;YES, ILLEGAL STRING
	JRST CPOPJ1	;OK RETURN

ANY:	CAIE C,15
	JRST ISTRU	;YES THIS IS ANY CHR
ISFALS:	CAIN C,15	;IS IT A RETURN
	AOSA T4	;ADJUST COUNT AND ENTER A NULL STRING
	IDPB C,T2	;SAVE IN ARBIT
	MOVEI T5,0
	IDPB T5,T2
	SUBI T4,2	;COUNT THEM
	JUMPLE T4,ILFMTR	;THIS LINE MUST HAVE ILLEGAL FORMAT
	AOS ARBCNT	;ONE MORE SEEN
ISFAL1:	TLNE FL,NEGF	;WAS NEG FLAG ON?
	AOS (P)	;YES, A MATCH
	POPJ P,

SEP:	MOVE T5,CTBL(C)		;GET TABLE ENT
	JUMPG T5,ISFALS		;NOT A SEP
	TRNN FL2,QSEPF		;CHECK . % $
	TRNN T5,NSEPF		;CHECKING - DO WE HAVE ONE?
	JRST ISTRU		;NO: SEP
	JRST ISFALS		;YES: NOT A SEP
ISTRU:	CAIN C,15
	AOSA T4
	IDPB C,T2	;SAVE CHR
	MOVEI T5,0
	IDPB T5,T2
	SUBI T4,2
	JUMPLE T4,ILFMTR
	AOS ARBCNT
ISTRU1:	TLNN FL,NEGF	;NEGATE?
	AOS (P)	;NO, MATCH
	POPJ P,

ILFMTR:	MOVE T2,CPG	;GIVE HIM AN ERROR MESSAGE AND PAGE
	PUSHJ P,PGPRN	;AND LINE
	MOVE T1,(PNTR)
	PUSHJ P,OUTSN
	NERROR ILFMT


ARBIT:	TLNN FL,NEGF	;THIS HAS NO MEANING
	TLOE FL,ARBITG	;ARE WE SEEING 
	NERROR ISS	;YES, ILLEGAL STRING
	PUSH P,T1	;SAVE SEARCH POINTER
	MOVEI T5,0	;SET ARBITRARY STRING TO NULL
	IDPB T5,T2
	SOJLE T4,ILFMTR
	AOS ARBCNT
	PUSH P,ARBCNT	;SAVE IN CASE WE COME BACK WITH NO MATCH
	PUSH P,T2
	PUSH P,T4
	PUSH P,C
CHKTHS:	TLO FL,DEMCHR	;NEED A CHARACTER NOW
	PUSHJ P,READCH	;CALL SELF RECURSIVELY
	JRST PROCED	;THIS COULD NOT MATCH JUST SCAN ON
	MOVE T2,-3(P)	;RESTORE ARBIT COUNT
	MOVEM T2,ARBCNT
	MOVE T4,-1(P)	;AND ARBIT CHR COUNT
	MOVE T2,-2(P)	;AND POINTER
	PUSH P,ALTP	;SAVE CHR POINTER
	TLZ FL,ARBITG	;CAN SEE ANOTHER  NOW
	PUSHJ P,LINMAT	;A MATCH
	JRST RECUR	;NO, TRY FOR ANOTHER OF THAT CHR
	SUB P,[XWD 7,7]	;GET ALL THAT JUNK OFF STACK
	JRST CPOPJ1 	;AND RETURN TO CALLER OF LINMAT
RECUR:	POP P,ALTP	;GET BACK POINTER
	POP P,C	;AND CHR
	MOVE T4,-2(P)	;RESTORE COUNT
	MOVEM T4,ARBCNT
	POP P,T4
	POP P,T2	;ALSO CHR COUNTER AND POINTER
	DPB C,T2	;PUT IN THAT CHR
	MOVEI T5,0	;AN@ TERMINATOR
	IDPB T5,T2
	SOJLE T4,ILFMTR
	PUSH P,T2
	PUSH P,T4	;RESAVE
	MOVE T1,-3(P)	;RESTORE SEARCH POINTER
	ILDB C,ALTP	;GET ANOTHER CHR
	PUSH P,C	;SAV IT
	TLZ FL,NEGF	;TURN THIS OFF FOR RECURSION
	CAIE C,12	;END OF WORLD?
	JRST CHKTHS
	SUB P,[XWD 5,5]	;RECUCE STACK
	POPJ P,	;AND ERROR RET
PROCED:	TLZ FL,ARBITG!NEGF	;JUST GO ON
	POP P,C
	POP P,T4
	POP P,T2
	POP P,ARBCNT
	POP P,(P)	;GET RID OF EXTRA POINTER
	JRST CHRMAT	;CONTINUE MATCH SCANNING


SUBTTL	FIND COMMAND (SEARCHES)

;DO A SEARCH OF A FILE

IFN STANSW, <
	HLPMSG <F Command	(Find)
 
F<string>${<range>}{#<columns>}{,<foptions>}{,<occurrences>}
	Finds  the  next  occurrence  of  the  specified   string   of
	characters  and prints the line containing it.	If you give an
	F command without any arguments, it uses the arguments to  the
	last  F  command.  You can print these arguments by giving the
	=STRING command.  You can also find the line(s) containing any
	one of several strings.  Consult the Edit manual for details.
 
columns::

	#<col>		Match must begin in column <col>
	#<col1>:<col2>	Match must begin between <col1> and <col2>
	#<col>!<len>	Match must begin within <len> after <col>

foptions::
 
	,E	Match upper/lower case characters Exactly
	,N	Do not print contents of line (print line number only)
	,A	Enter ALTER mode

occurrences::

	,<n>	find next n lines with <string>, then stop.
 
Special characters:
  174  ':  |	match any "separator" (non- number|letter|.|%|$);
   24  '/	match any character;
    5  '%  ^E	not-match next character, or match everything else;
   36  '7  ^^	quote next character;
   16  ')  ^N	"any number of" whatever follows, (0 or more).
>
>; IFN STANSW
SEARCH:	TLZ FL,ASSMF	;CLEAR ALL FLAGS
	TLO FL2,SRCWHO	;(203) SEARCH IS LOOKING
	SETZM LOLN	;JUST LIKE EVERYONE ELSE HAS TO
	SETZM SRCNT	;START WITH ZERO
	MOVE T1,[ASCII "F*"]
	MOVEM T1,FSFLG	;PROMPT FOR FIND CMD
	MOVE T1,[POINT 7,SRBUF]	;SET UP BYTE POINTER
	MOVEI T3,SRPNT	;AND POINTER TO BYTE POINTER TABLE
	PUSHJ P,SSTRNG	;GET A SEARCH STRING
	JRST	[SKIPN SRPNT	;WAS STRING SET?
		NERROR NSG	;NO, TELL HIM
		CAIN C,12
		JRST ASSMD1	;SPECIAL CONTINUE MODE
		JRST .+1]	;YES, USE OLD ONE
	TLZ FL,NUMSRF!ALTSRF!EXCTSR	;CLEAR FLAGS
	PUSHJ P,SCAN	;CHECK FOR WHAT COMES AFTER
	TRNN FL,TERMF	;IF TERMINATOR
	CAIN C,","	;OR ,
	JRST ASSMDT	;SET UP LIMITS SPECIALLY
	CAIE C,"!"
	CAIN C,":"
	JRST ASSMDT	;LET HIM SPECIFY 2ND HALF OF RANGE
IFN STANSW,<
	CAIN C,"#"		;ALSO IF # USE SPECIAL LIMITS
	 JRST ASSMDT
>; IFN STANSW
	PUSHJ P,GET2	;ELSE CALL USUAL LIMIT ROUTINE
SRC4:	MOVE T1,HILN	;SAVE END OF RANGE
	MOVEM T1,SRHILN
	MOVE T1,HIPG
	MOVEM T1,SRHIPG
IFN STANSW,<			;--OO7
	CALL GCOLS
SRC5:
>; IFN STANSW
	CAIE C,","	;ANY MORE ARGUMENTS?
	JRST SRC1	;NO, CHECK TERMINATOR AND PROCEED
	PUSHJ P,SCAN	;YES, SEE WHAT IT IS
	TRNN FL,IDF	;SHOULD BE IDENT OR NUMBER
	JRST SRC2	;NOT IDENT, CHECK FOR NUMBER OF SEARCHES
	MOVS T1,ACCUM	;GET THE IDENT
	CAIN T1,(<SIXBIT /N  />)	;AND FIND OUT WHAT IT IS
IFN STANSW,<			;--OO7
	 JRST [ TLO FL,NUMSRF	;PRINT THE NUMBER ONLY
		JRST SRC6 ]
	CAIN T1,(<SIXBIT /A  />)  ;ALTER LINES?
	 JRST [ TRNE FL,READOF	;CAN'T ALTER READONLY LINES
		 NERROR IRO
		TLO FL,ALTSRF
		JRST SRC6 ]
	CAIE T1,(<SIXBIT /E  />)  ;EXACT MATCH?
	 NERROR ILC		;GIVE UP
	TLO FL,EXCTSR
SRC6:	CALL SCAN
	JRST SRC5
>; IFN STANSW
IFE STANSW,<
	TLO FL,NUMSRF
	CAIN T1,(<SIXBIT /A  />)
	TLO FL,ALTSRF	;FIRST CHECK FOR A OR N
	TRNE FL,READOF	;IF READ ONLY AND ALTER
	TLNN FL,ALTSRF
	SKIPA
	NERROR ILC	;WE DO NOT PERMIT IT
	TLNN FL,NUMSRF!ALTSRF	;WAS IT EITHER?
	JRST SRC3	;NO, CHECK E
	PUSHJ P,SCAN	;CONTINUE LOOKING
	CAIE C,","
	JRST SRC1	;NO MORE ARGUMENTS
	PUSHJ P,SCAN	;WELL WHAT KIND IS THIS ONE?
	TRNN FL,IDF	;MORE IDENTS?
	JRST SRC2	;NO, MUST BE NUMBER OF SEARCHES
	MOVS T1,ACCUM
SRC3:	CAIE T1,(<SIXBIT /E  />)
	NERROR ILC	;NO, HE MUST HAVE MADE A MISTAKE
	TLO FL,EXCTSR	;YES, REMEMBER IT
	PUSHJ P,SCAN	;AND CHECK FOR MORE
	CAIE C,","
	JRST SRC1	;NO MORE
	PUSHJ P,SCAN	;ONLY ONE THING IT CAN BE NOW
>; IFE STANSW
SRC2:	TRNN FL,NUMF
	NERROR ILC	;NOPE, LOSE
	MOVEM T2,SRCNT	;SAVE AS COUNT OF LINES TO FIND
	PUSHJ P,SCAN	;GET TERMINATOR (WE HOPE)
SRC1:	TRNN FL,TERMF	;ALLS WELL THAT ENDS WELL
	NERROR ILC	;BUT THIS DOSNT
SRCH1A:	MOVEI T1,SRPNT	;GET POINTER TO STRINGS
	PUSHJ P,CODSR	;AND GENERATE CODE


	MOVE T1,LOPG	;GET SET TO HUNT IT
	MOVEM T1,DPG
	MOVEM T1,SRPG	;FLAG TO SAY IF WE SHOULD PRINT PAGE
	MOVE SINDEX,LOLN
	PUSHJ P,FIND
	TRZ FL,LINSN	;NO LINES YET
	SETZM FNDFLG	;NO MATCHES EITHER
ONSRC:	PUSHJ P,ONMOV	;CHECK RANGE
	JRST ENDSRC	;DONE
	TLZE FL,ASSMF	;FIRST TIME AND WANT .+1?
	JRST	[CAME T1,LOLN	;IS THERE EXACT MATCH?
		JRST .+1	;NO, THIS IS .+1
		AOS SVCNT	;PRETEND WE DIDNT SEE IT
		JRST SRNXT]	;AND TAKE NEXT
	TRO FL,LINSN	;WE SAW ONE
	CAMN T1,PGMK	;PAGES ARE SPECIAL
	JRST SRCPAG	;SO TAKE GOOD CARE OF THEM
	MOVEI T2,SRPNT	;POINTER TO STRINGS
	PUSHJ P,COMSRC	;GO SEARCH THIS LINE
	JRST SRNXT	;LOSER
	SETOM FNDFLG	;FOUND!
	MOVEM T3,SVCCNT	;SAVE AWAY THE CHARACTER COUNT
	MOVE T2,CPG	;GET CURRENT PAGE
	TRNN	FL2,NONUMF	;DON'T PRINT IF NONUMBER MODE
	CAMN	T2,SRPG		;SEE IF WE SHOULD PRINT IT
	SKIPA
	PUSHJ	P,PGPRN		;YES
	MOVE T2,CPG	;NOW SET IT AS CURRENT
	MOVEM T2,CPGL
	MOVEM T2,SRPG	;ALSO RESET FLAG
	MOVE T2,(PNTR)	;ALSO SET LINE
	MOVEM T2,CLN
	TLNE FL,ALTSRF	;ARE WE GOING TO EDIT?
	JRST SRCALT	;YES, GO SET THINGS UP
	TLNE FL,NUMSRF	;DO WE WANT ONLY LINE NUMBERS?
	JRST SRCNUM	;YES
	MOVE T1,PNTR	;GO PRINT LINE
	PUSHJ P,OUTLIN
SRNXTC:	SOSG SRCNT	;HAVE WE FOUND ENOUGH
	JRST SRFND	;YES, GIVE UP (WE HAVE SEEN AT LEAST ONE)
SRNXT:	PUSHJ P,FINDN	;GET NEXT LINE TO LOOK A
	JRST ONSRC
SRCNUM:	MOVE T1,(PNTR)	;PRINT SEQUENCE NUMBER
	PUSHJ P,OUTSN
	OCRLF
	JRST SRNXTC	;AND GO
ENDSRC:	TRZN FL,LINSN	;DID WE SEE ONE?
	NERROR NLN	;NULL RANGE
SRFND:	SKIPN FNDFLG	;FIND ANY?
	RERROR SRF	;NO: TELL HIM
	JRST COMND
SRCPAG:	AOS CPG	;JUST ADVANCE PAGE COUNTER
	JRST SRNXT	;AND PROCEED


SRCALT:	PUSHJ P,SETALT	;SET THINGS UP
	SKIPLE T2,SVCCNT	;GET COUNT (DO NOT CALL IF 0
	PUSHJ P,ALTSP	;SPACE OVER CORRECTLY
	PUSHJ P,ALTN1	;GO ALTER
	JRST LEVINS	;HE SAID ALTMODE
	PUSHJ P,INSED	;INSERT IT
	PUSHJ P,FINDN
	PUSHJ P,FILLB	;MAKE SURE WE HAVE NOT GOTTEN TOO BIG
	MOVE T1,(PNTR)	;GET POINTER BACK
	SOSG SRCNT
	JRST COMND	;DONE
	JRST ONSRC	;GO ON

ASSMD1:	TROA FL,CNTF	;MARK AS KEEP END OF RANGE
ASSMDT:	TRZ FL,CNTF	;JUST IN CASE
	TLO FL,ASSMF	;WE ASSUME .+1
	MOVE T1,CLN	;SET THINGS UP FOR . TO INFINITY
	MOVEM T1,LOLN
	MOVEM T1,HILN	;AS GOOD AS ANYTHING WITH THE PAGE WE WILL
	MOVE T1,CPGL	;USE
	MOVEM T1,LOPG
	TRZE FL,CNTF	;KEEP END?
	JRST NOSPC	;YES
	CAIE C,":"	;IF A : OR !
	CAIN C,"!"
	JRST HALFSP	;GET THE SECOND HALF (.+1 TO GIVEN)
	MOVSI T1,377777	;GET A LARGE PAGE
	MOVEM T1,HIPG
	JRST SRC4	;BACK INTO THINGS

HALFSP:	MOVEM T1,HIPG	;SET TOP AS /.
	PUSHJ P,GET2HF	;GET THE SECOND HALF
	JRST SRC4	;AND GO

NOSPC:	MOVE T1,SRHIPG
	MOVEM T1,HIPG	;PUT BACK END
	MOVE T1,SRHILN
	MOVEM T1,HILN
	JRST SRCH1A

LEVINS:	OCRLF			;YES - PUT OUT CRLF
	SETZM	ALTSN		;CLEAR FLAG
	JRST	COMND


SUBTTL	ALTMODE AND LINE FEED COMMANDS

NXTLIN:	PUSHJ	P,NBFIND	;GET CURRENT LINE
	CAMN T1,CLN	;DID WE REALLY FIND IT
	PUSHJ P,FINDN	;YES, GET NEXT ELSE WE ALREADY HAVE IT
	JUMPE T1,[NERROR NLN]	;EOF AND NOT FOUND
	MOVE T2,DTYPE	;TERMINAL TYPE
	XCT CURUP(T2)
	OUTCHR [15]
NXTL1:	CAMN T1,PGMK	;IS THIS A PAGE MARK?
	JRST NXTPG	;TREAT SPECIALLY
NBPRNT:	MOVEM T1,CLN	;SET AS CURRENT
	MOVE T1,PNTR	;GET THE CURRENT POINTE
	TRNE	FL2,NONUMF
	TRO	FL2,SUPN
	PUSHJ	P,OUTLIN	;AND PRINT
	TRZ	FL2,SUPN
	JRST	COMND		;DONE

NXTPG:	AOS T2,CPG	;WE ARE ON THE NEXT PAGE
	MOVEM T2,CPGL
	TRNN	FL2,NONUMF
	PUSHJ P,PGPRN	;TELL HIM
	PUSHJ P,FINDN	;FIND A LINE ON IT
	JUMPN T1,NXTL1	;THERE IS ONE THERE, PRINT IT
	MOVE T1,[ASCII /00000/]	;END OF FILE, SET TO THAT PAGE
	MOVEM T1,CLN
	JRST COMND


BAKLIN:	PUSHJ	P,NBFIND	;GET CURRENT LINE
	TRNE FL,BOF	;IF NOT AT START OF FILE
	CAME PNTR,BUFP	;OR NOT AT START OF BUFFER
	SKIPA
	NERROR NLN
IFE STANSW, <
	OUTCHR	[15]
	MOVE T2,DTYPE
	OUTCHR LFD(T2)
>; IFE STANSW

IFN STANSW, <
	MOVE T2,DTYPE
	SKIPE LFD(T2)
	OUTSTR [BYTE(7) 15,"*",0]
>; IFN STANSW
BAK1:	PUSHJ P,FINDB
	CAME T1,PGMK
	JRST	NBPRNT
	MOVE T2,CPG
	MOVEM T2,CPGL
	TRNN	FL2,NONUMF
	PUSHJ P,PGPRN
	TRNE FL,BOF	;CHECK FOR START OF WORLD
	CAME PNTR,BUFP
	JRST BAK1	;OK, BACK UP SOME MOR
	MOVE T1,[<ASCII /00000/>!1]
	MOVEM T1,CLN
	JRST COMND

NBFIND:	MOVE	T1,CPGL		;CURRENT PAGE
	MOVEM	T1,DPG
	MOVE	SINDEX,CLN	;AND CURRENT LINE
	JRST	FIND		;GO FETCH


SUBTTL	COPY AND TRANSFER COMMANDS

IFN STANSW, <
	HLPMSG <T Command	(Transfer)
 
T<dest-position>,<range>
 
Transfer the specified range to the specified position.  The lines no
longer exist where once they were.   Use the C command if you want to
duplicate a range.
>
>; IFN STANSW

IFE STANSW, <
TRANS:	TLOA FL,TRANFL	;SET AS TRANSFER COMMAND
>; IFE STANSW

IFN STANSW, <
TRANS:	TLO  FL,TRANFL		;KLUDGE TO AVOID STEPPING ON LITERAL
	JRST COPY+1
>; IFN STANSW

IFN STANSW, <
	HLPMSG <C Command	(Copy)
 
C<dest-position>,<range>
C<dest-position>=<filespec>,<range>
C<dest-position>=<filespec>/S
 
C  duplicates a range  of lines so  that the first  line being copied
starts at  the specified position, or  immediately thereafter if that
line already  exists.  It is possible to take  the lines being copied
from a file on disk instead if the one being edited.
 
Following are some examples of the C (copy) command:
 
*C<position>,<range>
*C600,100:200
	This is the simplest case.  For example, lines 100 through
	200 are duplicated at or following line 600.
 
*C<dest-position>=<filespec>,<range>
*C600=myfile.for,100:9999
	Copies a range of lines from the specified file, so  that  the
	first line being copied starts at the specified position.
 
*C<dest-position>=<filespec>/S
*C600=myfile.for/s
	Lets you search through the specified file before  giving  the
	range of lines to transfer.  In this mode, the ready character
	is C* and you may give F and P commands only.	When  you  are
	finished  examining the file, give an E command and the system
	prints SOURCE LINES=.  Type the appropriate  range  of	lines.
	If  you do not want to copy any lines, to end search mode give
	the EQ command instead of the E command.
>
>; IFN STANSW
COPY:	TLZ FL,TRANFL	;JUST TO MAKE SURE
	TRZ FL2,BADORD	;CLEAR BAD ORDER FLAG
	SETZM HILN	;THIS, TOO MAY PROVE USEFUL
	SETZM LOLN	;A GOOD THING TO DO
	TRNE FL,READOF	;DO NOT LET HIM IN READ ONLY MODE
IFE STANSW, <
	NERROR ILC
>; IFE STANSW
IFN STANSW, <
	NERROR IRO
>; IFN STANSW
	PUSHJ P,GET1S	;GET PLACE TO PUT LINES
	MOVE T1,HIPG	;STORE IT AWAY FOR LATER
	MOVEM T1,DESTPG
	MOVE T1,HILN
	MOVEM T1,DESTLN
	CAIE C,200	;...
	CAIN C,"="	;DOES HE WANT TO COME FROM ANOTHER FILE?
	JRST	OTHERF	;OTHER FILE REQUESTED
	TLZ FL,COPFIL	;NO, MAKE SURE FLAG IS OFF
COPY1:
	CAIE C,","	;SHOULD BE COMMA EVEN IF FROM ALTFIL
	NERROR ILC	;HE MUST SAY WHERE TO PUT IT
	PUSHJ	P,COPYP		;PARSE RANGE ARGS
COPY2:	SETOM NLIN1	;LINES ON FIRST PAGE
	SETZM NLIN2	;LINES ON LAST PAGE
	TLO	FL2,NORENT	;AND REE-ENTER
	TLZ	FL2,RENTF	;IN CASE HE HAS
	MOVEM P,COPDL	;SAVE STACK POINTER FOR NOW
	TLO FL,ISCOP	;SO WE WILL DO SPECIAL RESET IF ERROR
	MOVE	ALTP,[-1000*NCPAGS,,BUFC-1]
				;PNTR FOR COPY BUFFER
	SETZM LSTPG	;HAVE SEEN NO PAGES YET
	MOVE T1,LOPG	;LOOK FOR SOURCE
	MOVEM T1,DPG
	MOVE SINDEX,LOLN
	PUSHJ P,FIND


	TRZ FL,LINSN	;AND NO LINES
	TLNN FL,TRANFL	;IS THIS A TRANSFER COMMAND?
	JRST GOCOP	;NO, IGNORE ALL THIS SPECIAL STUFF
	HRRZM ALTP,STARTD	;SAVE THE START OF DELETED CODE
	HRRZM ALTP,ENDD	;AND THE END
	MOVE T1,CPG	;GET THE PAGE ON WHICH DELETION STARTS
	MOVEM T1,TRANST	;AND SAVE IT
	SKIPN -1(PNTR)	;ARE WE AT THE START OF THE BUFFER
	TRNN FL,BOF	;AND OF THE WORLD
	SKIPA
	JRST BEGFIL	;YES, DO NOT LOOK BACK
	PUSHJ P,FINDB	;GET THE PREVIOUS LINE
	CAMN T1,PGMK	;A PAGE IS SPECIAL
	JRST SPCPG
	MOVEM T1,BOTLIN	;SAVE IT FOR LATER
	PUSHJ P,FINDN	;GO FORWARD AGAIN
	JRST GOCOP
SPCPG:	SKIPE LOLN	;DO WE INTEND TO ABSORD THIS ONE
	JRST BEGFIS	;MOVE FORWARD AND RECORD
	SKIPN -1(PNTR)	;CHECK FOR START OF WORLD AGAIN
	TRNN FL,BOF
	SKIPA
	JRST BEGFIS
	PUSHJ P,FINDB	;BACK UP
	AOS CPG		;FIX PAGE COUNT
	PUSH P,T1	;SAVE THAT LINE
	PUSHJ P,FINDN
	PUSHJ P,FINDN	;AND GO BACK WHERE WE BELONG
	POP P,T1	;GET LINE NUMBER BACK
	CAMN T1,PGMK	;THERE'S THAT PAGE AGAIN
	JRST BEGFIA
	MOVEM T1,BOTLIN	;SAVE LINE NUMBER
	JRST GOCOP
BEGFIS:	AOSA CPG
BEGFIA:	AOSA CPG
BEGFIF:	PUSHJ P,FINDN
BEGFIL:	SETOM BOTLIN	;A VERY SMALL NUMBER
GOCOP:	SETZM PGDELS	;TOTAL NUMBER OF PAGES DELETED IS 0
	SKIPE LOLN	;DID HE ASK FOR THE WHOLE PAGE
	JRST NOISTP	;NO
	MOVE T1,PGMK	;YES, PUT IN THE PAGE MARK
	MOVEM T1,1(ALTP)
	MOVE	T1,PGMKW2	;2ND WORD
	MOVEM T1,2(ALTP)
	HRRZM ALTP,LSTPG
	ADD ALTP,[XWD 2,2]
	SETZM NLIN1	;NO LINES ON FIRST PAGE
	TLNN FL,TRANFL	;IS THIS A TRANSFER
	JRST NOISTP	;NO, START TRANSFER OF DATA
	MOVE T1,CPG	;CHECK TO SEE IF WE SHOULD REALLY DELETE
	CAIN T1,1	;NOT IF PAGE 1
	JRST RSTSTP
	PUSHJ P,FINDB	;GET THAT PAGE
	SETZM NCNT	;DELETE
	MOVEI T1,2
	MOVEM T1,OCNT
	PUSHJ P,INSED
	PUSHJ P,FINDN1	;MAKE SURE WE ARE AT THE LINE WE WERE AT
	AOS CPG		;KEEP COUNT STRAIGHT
	AOSA PGDELS	;ONE DELETED
RSTSTP:	HRRZM ALTP,STARTD	;RESET START IF NONE DELETED
	HRRZM ALTP,ENDD	;RESET END


NOISTP:	MOVE T1,(PNTR)	;MAKE SURE WE HAVE THAT JUNK BACK
ONCOPY:	PUSHJ P,ONMOV	;STILL IN RANGE?
	JRST ENDCOP	;NO, START INSERTING
	TRO FL,LINSN	;WE SAW ONE
	CAMN T1,PGMK	;IS IT A PAGE?
	JRST MOVPG	;YES, TREAT SPECIAL
	AOS	NLIN2		;INCR LINE SEEN
MOVLCT:	MOVE T1,PNTR	;START TRANSFER
	MOVE T2,(T1)	;PICK UP FIRST WORD (SEQ NUM)
	MOVEM T2,LSTLN	;SAVE FOR INC CALC
TRLIN:	MOVEM T2,1(ALTP)	;PUT LINE AWAY
	AOBJP ALTP,RESTCR	;NEED MORE CORE?
TRLIN1:	SKIPN T2,1(T1)	;END OF LING?
	JRST NXTLCT
	TRNN T2,1
	AOJA T1,TRLIN	;NO MOVE NEXT WORD
NXTLCT:	TLNN FL,TRANFL	;IS THIS TRANSFER?
	JRST NXTLCP	;NO, DON'T DELETE
	HRRZM ALTP,ENDD	;SAVE END OF DELETED TEXT
	SETZM NCNT
	SUBI T1,-1(PNTR)	;GET LENGTH
	MOVEM T1,OCNT
	PUSHJ P,INSED
	PUSHJ P,FINDN1	;MAKE SURE A LINE IS THERE
	SKIPA		;SKIP THE FINDN
NXTLCP:	PUSHJ P,FINDN	;YES, GET NEXT
	JRST ONCOPY

MOVPG:	AOS CPG	;WE ARE ON NEXT PAGE
	MOVE T1,NLIN2
	SKIPGE NLIN1	;PUT ON FIRST PAGE IF NOT SOME ALREADY THERE
	MOVEM T1,NLIN1
	SETZM NLIN2
	HRRZM ALTP,LSTPG	;SAVE RECORD OF WHERE SEEN
	AOS PGDELS	;RECORD ONE MORE PAGE DELETED
	JRST MOVLCT	;NOW MOVE IT

RESTCR:	NERROR NEC
;	JRST	TRLIN1		;WHERE TO GO IF MORE AVAIL

ENDCOP:	TRNN FL,LINSN	;WERE THERE ANY THERE?
	NERROR NLN	;NO LOSE
	SETZM 1(ALTP)	;MAKE SURE THERG IS AN END FLAG THERE
	TLZE FL,COPFIL	;ARE WE COMMING OFF A FILE
	PUSHJ P,RSCOP	;YES, RESET POINTERS
	MOVE T1,DESTPG	;LOOK FOR DESTINATION
	MOVEM T1,DPG


	TLNN FL,TRANFL	;IS IT A TRANSFER?
	JRST DOINS1	;NO, PUT THE COPIED TEXT IN
	SETZM PGINSD	;NO EXTRA PAGE MARK INSERTED YET
	SKIPN T2,(PNTR)	;ARE WE AT EOF
	JRST NOPGIN	;YES, DO NOT INSERT A PAGE MARK
	CAME T2,PGMK	;ALSO NOT IF PAGE MARK
	CAMLE T2,BOTLIN	;OR GREATER THAN LINE LEFT OVER
	SKIPA
	SETOM PGINSD	;WE WILL HAVE TO INSERT ONE
NOPGIN:	MOVN T2,PGDELS	;GET MINUS NUMBER OF PAGES DELETED
	SUB T2,PGINSD	;ONE LESS IF A PAGE MARK INSERTED
	CAMGE T1,TRANST	;(T1 HAS DEST. PAGE) IF SMALLER THAN START
	JRST DOSUB	;EVERYTHING IS OK
	CAMN T1,TRANST	;IS IT SAME?
	JRST DSEQTR	;SPECIAL CHECK REQUIRED
	CAMGE T1,CPG	;INSIDE RANGE DELETED?
	NERROR ITD	;LOSE BIG
	CAMN T1,CPG	;SAME AS TOP PAGE?
	JRST DSEQCP
	ADDM T2,DESTPG	;ADJUST PGE WE ARE TO FIND
	ADDM T2,DPG
DOSUB:	ADDM T2,CPG	;ADJUST FOR REMOVED PAGES
	ADDM T2,INPG
	ADDM T2,BGPG
	SKIPN PGINSD	;SEE IF WE WANT TO INSERT ONE
	JRST DOINS1
	MOVE T1,PGMK
	MOVEM T1,LIBUF
	MOVE	T1,PGMKW2
	MOVEM T1,LIBUF+1
	SETZM OCNT
	MOVEI T1,2
	MOVEM T1,NCNT
	PUSHJ P,INSED
	PUSHJ P,FINDN	;ADVANCE OVER IT
	PUSHJ P,FILLB	;IN CASE OF OVERFLOW
	OUTSTR [ASCIZ /%Page mark inserted to prevent order error
/]
	JRST DOINS1
ALLSAM:	SKIPN LOLN
	SKIPE PGINSD	;IF DID NOT DELETE PAGE OR INSERTED ONE
	JRST DOSUB	;ALL OK
	SKIPE T1,(PNTR)	;ELSE MUST BE IN UPPER PART
	CAMN T1,PGMK
	NERROR ITD	;THERE IS NO UPPER PART
	CAMLE T1,DESTLN
	NERROR ITD
	SOS T1,DESTPG	;THIS WILL BE ON A LOWER PAGE
	MOVEM T1,DPG
	JRST DOSUB


DSEQTR:	CAMN T1,CPG	;IS IT ALL ON SAME PAGE?
	JRST ALLSAM	;YES, SPECIAL CHECKING
	SKIPN LOLN	;DID WE START WITH A PAGE
	NERROR ITD	;YES, LOSE
	SKIPE PGINSD	;WAS THERE A PAGE INSERTED?
	JRST DOSUB	;YES, ALL OK
	SKIPE T1,(PNTR)	;FIND OUT WHAT THE NEXT LINE IS
	CAMN T1,PGMK
	JRST DOSUB	;THIS WILL BE OK
	CAMG T1,DESTLN	;SEE IF WE ARE IN TROUBLE
	NERROR ITD
	JRST DOSUB	;OK
DSEQCP:	SKIPE PGINSD	;WAS ONE INSERTED
	JRST AOSTRA	;SET PAGE PROPERLY
	MOVE T1,DESTLN
	CAMG T1,BOTLIN
	NERROR ITD
	SKIPA T1,TRANST
AOSTRA:	AOS T1,TRANST
	MOVEM T1,DESTPG
	MOVEM T1,DPG	;ALSO SET THIS
	JRST DOSUB
DOINS1:	MOVE SINDEX,DESTLN
	PUSHJ P,FIND
	PUSH P,T1	;SAVE LINE FOUND
	MOVE T1,CPG
	CAMN	T1,DESTPG	;PAGES MUST MATCH
	JRST	DOINS2
	TLNN	FL,TRANFL	;ONLY TRANSFER
	NERROR	NSP		;ERROR IF COPY
	MOVE	T1,PGMK
	MOVEM	T1,LIBUF
	MOVE	T1,PGMKW2
	MOVEM	T1,LIBUF+1
	SETZM	OCNT
	MOVEI	T1,2
	MOVEM	T1,NCNT
	PUSHJ	P,INSED
	PUSHJ	P,FINDN
	PUSHJ	P,FILLB
	AOS	CPG
	AOS	INPG
	AOS	BGPG
	OUTSTR	[ASCIZ /%Text inserted at end of file
/]
	MOVE	T1,CPG

DOINS2:	MOVEM	T1,CPGL		;SET THIS AS CURRENT PAGE
	POP	P,T1		;RETRIEVE LINE FOUND
	MOVE	T2,[<ASCII /00100/>!1]
	MOVEM	T2,CLN		;AND THIS AS CURRENT LINE
	MOVEM	T2,SVLNUM
	MOVEI	ALTP,BUFC-1	;POINT TO START OF LINES TO COPY
	TLZ	FL,TRANFL	;THIS FLAG NO LONGER NEEDED


TWOSET:	SKIPGE	NLIN1		;DID WE SEE ANY PAGE MARKS?
	JRST	ONSET		;NO -- JUST NEED ONE INCR
	MOVEM	T1,HIGH1	;SAVE THIS FOR LATER
	JUMPE	T1,[MOVE T2,[<ASCII /00100/>!1]
		    MOVEM T2,SINCR ;USE THIS IF EOF
		    MOVE T3,NLIN1  ;SET UP FOR GETDIF
		    JRST ONST0]    ;GO COMPUTE FIRST INCR
	MOVE	T3,NLIN2	;NUMBER OF LINES ON LAST PG
	MOVE	T2,[<ASCII /00000/>!1]
	MOVE	T1,HIGH1	;RESULT OF FIND
	CAMN	T1,DESTLN	;SAME AS DESTINATION?
	MOVE	T1,T2		;YES - COMPUTE CORRECT INCR
	PUSHJ	P,GETDIF	;CALL ROUTINE
	  JRST	[IORI FL2,BADORD	;ORDER PROBLEM
		 JRST OKINC2]		;CONTINUE
	MOVEM	T1,START2	;PLACE TO START FOR LAST PAGE
	SKIPN	SINCR		;DID HE SAY ONE
	JRST	[MOVE T1,LSTLN	;LAST LINE SEEN
		 CAML T1,(PNTR)	;HOW'S IT LOOK?
		 JRST ONST3	;NOT GOOD ENOUGH
		 JRST OKINC2]
	CAML	T2,SINCR	;SEE WHOSE IS BETTER
	JRST	OKINC2		;WE'LL USE HIS
ONST3:	MOVEM	T2,SINCR	;OURS IS BETTER
	MOVEM	T2,PRNTO2	;INFOR HIM OF THE CHANGE
	OUTSTR	ASCIZ2

OKINC2:	MOVE	SINDEX,DESTLN	;INCASE WE NEED TO FIND IT
	MOVE	T1,HIGH1	;RESULT OF PREVIOUS FIND
	CAMGE	SINDEX,T1	;BEFOR 1ST LINE OF PAGE?
	PUSHJ	P,FIND		;YES - NEED TO REPOSITION
				;T1 HAS CORRECT RESULT
	SKIPG	T3,NLIN1	;CHECK FOR P/M ONLY
	JRST	INSL2		;ALL SET FIRST THING IS P/M
	MOVE	T2,DESTLN	;WHAT HE WANTED
	PUSHJ	P,GETDF1	;DON'T LOOK AT NEXT LINE
	  JRST	[IORI FL2,BADORD	;ORDER PROBLEM WILL FOLLOW
		 JRST INSL2]		;CONTINUE
	MOVEM	T1,CLN		;SET UP GOOD THINGS
	MOVEM	T1,SVLNUM
	CAML	T2,FINCR	;WHICH IS BETTER
	JRST	INSL2		;HIS
	MOVEM	T2,FINCR	;OURS
	JRST	ONST1		;TELL HIM WE CHANGED HIS MIND


ONSET:	SKIPG	T3,NLIN2	;GO ANYTHING TO WORRY ABT
	JRST	INSL2		;NO -- DO OUR WORST
ONST0:	MOVE	T2,DESTLN	;HIS DESIRED PLACE
	MOVEM	T2,SVLNUM	;AS GOOD AS ANY IF ORDER ERROR
	PUSHJ	P,GETDIF	;SEE WHAT THERE IS TO SEE
	  JRST	[IORI FL2,BADORD	;ORDER PROBLEMS, SET FLAG
		 JRST INSL2]		;AND CONTINUE
	MOVEM	T1,SVLNUM	;SET THE GOOD S--T
	MOVEM	T1,CLN
	CAML	T2,FINCR	;THE MOMENT OF TRUTH
	JRST	INSL2		;THAT CRAFTY FELLOW
	MOVEM	T2,FINCR	;TELL HIM HE BLEW IT
ONST1:	MOVEM	T2,PRNTO1	;PUT IN IN PRINT POSITION
	OUTSTR	ASCZ1
	JRST	INSL2		;HE HAS BEEN TOLD


;CONVERT INTEGER IN T1 TO SEQ # IN T3

ASCON:	MOVSI	T3,400000	;WILL BECOME LOW ORDER BIT
ASCO2:	IDIVI	T1,^D10
	ADDI	T2,"0"
	LSHC	T2,-7
	TRNN	T3,1		;HAS IT GOTTEN THERE?
	JRST	ASCO2
	POPJ	P,

;CONVERT SEQ # IN T3 TO INTEGER IN T1

NUMCON:	MOVEI	T1,0
	TRZ	T3,1		;GET RID OF LOW ORDER BIT
NUMC1:	MOVEI	T2,0
	LSHC	T2,7
	IMULI	T1,^D10
	ADDI	T1,-"0"(T2)
	JUMPN	T3,NUMC1
	POPJ	P,


INSLN:	MOVE T2,FINCR	;GENERATE NEW SEQUENCE NUMBER
	SKIPN T1,SVLNUM	;BUT ONLY IF WE ARE SUPPOSED TO
	JRST INSL2
	PUSHJ P,ASCIAD
	MOVEM T1,SVLNUM	;PUT EITHER NGW OR 0 BACK
INSL2:	SETZM LIBUF	;ZERO OUT PLACE TO PUT LINE
	MOVE T1,[XWD LIBUF,LIBUF+1]
	BLT T1,LIBUF+MXWPL+1
	MOVEI T1,LIBUF	;SET UP OUTPUT POINTER
	SKIPN T2,1(ALTP)	;AT END?
	JRST INSDON	;FINISHED
INS1:	MOVEM T2,(T1)	;PUT IT AWAY
	ADDI ALTP,1	;NEXT
	SKIPN T2,1(ALTP)	;CHECK FOR END OF LING
	JRST INS2
	TRNN T2,1	;BY EITHER METHOD
	AOJA T1,INS1	;GO ON WITH TRANSFER
INS2:	SUBI T1,LIBUF-1	;GET COUNT
	MOVEM T1,NCNT	;AND SET AS NEW
	SETZM OCNT	;OLD IS ZERO
	MOVE T1,LIBUF	;GET SEQ NUM
	CAMN T1,PGMK	;CHECK FOR PAGE
	JRST INSPG	;AND DO SPECIAL
	SKIPN T1,SVLNUM	;IF A NON-ZERO NUMBER THEN REPLACE
	MOVE T1,LIBUF
	MOVEM T1,LIBUF
NOINCR:	MOVEM T1,CLN	;SET AS CURRENV LINE
	PUSHJ P,INSED	;INSERT IT
	PUSHJ P,FINDN	;GET NEXT
	PUSHJ P,FILLB	;AND DUMP IF NEEDED
	JRST INSLN	;GO PUT IN MORE

INSPG:	AOS T3,CPG	;WE ARE ON THE NEXT PAGE
	MOVEM T3,CPGL	;SET AS CURRENV
	MOVE T1,[<ASCII /00000/>!1]	;SET TO SAY LINE 0
	AOS BGPG	;ONE MORE PAGE IN FILE
	AOS INPG
	SETZM SVLNUM	;DO NOT DO ANY MORE SEQUENCE REPLACEMENT
	MOVEI T2,-2(ALTP)	;SINCE WE HAVE ALREADY GONE PAST
	CAMN T2,LSTPG	;UNLESS STARTING LAST PAGE
	SKIPN T3,SINCR	;ANF SECOND SEQUENCE NUMBER GIVEN
	JRST NOINCR
	MOVEM T3,FINCR	;SET UP INCREMENT
	MOVE	T3,START2	;GET LAST PAGE START
	MOVEM	T3,SVLNUM
	MOVEM	T1,CLN
	PUSHJ	P,INSED		;INSERT IT
	PUSHJ	P,FINDN		;TO NEXT
	PUSHJ	P,FILLB		;SLURP
	JRST	INSL2		;GO DO IT


INSDON:
COPDON:	SKIPN	ALTJFN		;SKIP THIS IF NO JFN
	JRST	NOCPF		;NO FILE OPEN
	MOVEI	T2,<CPYPG0>B44	;RELEASE THIS PAGE
	CALL	UNMAP		;...
	MOVE	T1,ALTJFN	;RELEASE JFN HERE
	CLOSF			;...
	  JFCL			;DONT CARE NOW
NOCPF:	TLZE	FL,COPFIL	;ARE WE COPYING FROM A FILE (ERRORS ONLY)
	PUSHJ	P,RSCOP		;YES, CLEAN UP POINTERS
	TLZ	FL,ISCOP	;RESET COPY FLAG
	TLNN	FL,TRANFL	;IF TRANSFER, WE MUST REINSERT
	JRST	COPD1		;NO
	MOVE	ALTP,STARTD
REINXT:	MOVEI	T1,LIBUF
	CAMN	ALTP,ENDD
	JRST	COPD1		;ALL DONE
	MOVE	T2,1(ALTP)
	JRST	REINWD

REINS:	MOVE	T2,1(ALTP)
	CAME	ALTP,ENDD
	TRNE	T2,1
	JRST	ENDLIN		;DONE WITH THIS LINE
REINWD:	MOVEM	T2,(T1)
	ADDI	T1,1
	AOJA	ALTP,REINS

ENDLIN:	SETZM	OCNT
	SUBI	T1,LIBUF
	MOVEM	T1,NCNT
	PUSHJ	P,INSED		;INSERT LINE
	PUSHJ	P,FINDN
	PUSHJ	P,FILLB		;IN CASE OF OVERFLOW
	JRST	REINXT

COPD1:	MOVNI	T1,1		;REMOVE PAGES
	MOVE	T2,[.FHSLF,,<CPYBUF>B44]
	MOVE	T3,[PM%CNT+NCPYP]
	PMAP			;ZAP
	HRRI	T2,<BUFC>B44	;MORE STUFF TO REMOVE
	HRRI	T3,NCPAGS
	PMAP			;BYE BYE
	TRZE	FL2,BADORD	;WAS THE ORDER BAD SOMEPLACE?
	 NERROR	ORDER		;YES, COMPLAIN
	JRST	COMND		;CONTINUE EDITING


OTHERF:	TLZE	FL,TRANFL	;GIVE WARNING IF TRANSFER
	OUTSTR	[ASCIZ /% WARNING - Copy assumed
/]
	SETZM	ALTJFN		;NONE YET
	SETOM	FSFLG		;SPECIAL ^U FLAG
	MOVSI	T1,(GJ%OLD!GJ%CFM)
	MOVEI	ALTP,ALTBLK
	CALL	READNM
	  JRST	CKIND		;ERROR RETURN
	  JRST	COMND		;^U RETURN
	PUSHJ	P,READSW	;READ /R OR /S
	 NERROR ILC
	SKIPE	RSW		;/R ILLEGAL
	NERROR	ILC
	MOVE	T1,ALTJFN	;GET JFN
	MOVEM	T1,AIPJFN	;SAVE
	MOVE	T2,[7B5+OF%RD]
	OPENF			;OPEN FILE
	  JERROR		;USER LOSAGE
	MOVEI	ALTP,AIPB	;POINT TO BLOCK
	CALL	GFSIZE		;GET INPUT FILE SIZE
	PUSH	P,SAVEN		;TURN OFF AUTO-SAVE
	SETZM	SAVEN
	SETOM	AIPCNT		;CLEAR INPUT PNTRS
	SETZM	AIPPNT
	MOVEI	T1,CPYPG0	;BUFFER ADDRS
	MOVEM	T1,AIPBUF	;...


	MOVEI	T1,<CPYBUF+1000*NCPYP>-1
	SUBI T1,2*MXWPL+2	;SET UP THE VARIOUS POINTERS
	PUSH P,FILPT	;SEE STPT FOR MORE INFO
	MOVEM T1,FILPT
	MOVEI T1,1
	PUSH P,CPGL
	MOVEM T1,CPGL
	MOVE T1,[<ASCII /00000/>!1]
	PUSH P,CLN
	MOVEM T1,CLN
	MOVEI	T1,CPYBUF
	SETZM (T1)
	ADDI T1,1
	PUSH P,BUFP
	MOVEM T1,BUFP
	MOVEI	T1,<CPYBUF+1000*NCPYP>-1
	SUB T1,BUFP
	MOVE T2,T1
	SUBI T2,MXWPL+1
	PUSH P,MAXWC
	MOVEM T2,MAXWC
	ASH T1,-1
	PUSH P,HLFWC
	MOVEM T1,HLFWC
	MOVEI T1,1
	PUSH P,CPG
	PUSH P,INPG
	MOVEM T1,CPG
	MOVEM T1,INPG
	PUSH P,PNTR
	MOVE PNTR,BUFP
	PUSH P,SVWD
	SETZM SVWD
	PUSH P,OLDLIN
	SETZM OLDLIN
	PUSH P,WC
	SETZM WC
	MOVSI T1,1
	PUSH P,BGPG
	MOVEM T1,BGPG
	MOVE T1,FL	;SAVE SELECTED FLAGS
	AND T1,[XWD TECOF+FSTOPF,READOF!BOF!EOF!EOF2!BGSN]
	PUSH P,T1
	TRZ FL,EOF!EOF2
	TRO FL,READOF!BOF
	TLZ FL,TECOF
	TLO FL,FSTOPF
	MOVEM P,COPDL	;SAVE PDL FOR LATER
	TLO FL,COPFIL+ISCOP	;WE ARE USING OTHER FILE POINTERS
	PUSHJ P,FILLBF
	SKIPN SSW
	JRST COPY1


	TRNN FL,TERMF	;MUST END HERE
	NERROR ILC
	TLO FL,SRCOP	;SET THINGS UP
	JRST COMND	;AND GO GET COMMANDS

DSCOP:	PUSHJ	P,GNCH		;GET NEXT CHAR
	ANDI	C,137		;FORCE UPPER
	CAIN	C,"Q"		;CHECK FOR SPECIAL
	JRST	NOCOP		;YES - DO NOTHING
	MOVEM	C,SAVC		;BACK UP SCANNER
	PUSHJ	P,SCAN
	TRNN	FL,TERMF
	NERROR	ILC
	OUTSTR	[ASCIZ /Source lines=/]
	SETZM	LOLN		;THIS MAY HAVE GOTTEN RESET
	SETZM	SAVCHR		;CLEAR THINGS OUT
	SETZM	SSW		;FORGET THIS SWITCH
	PUSHJ	P,COPYP		;GET SOURCE LINES
	TLZ	FL,SRCOP	;TURN OFF FLAG
	JRST	COPY2		;CONTINUE

COPYP:	PUSHJ	P,GET2S		;GO GET PLACE TO FIND LINES
	MOVE	T1,INCR		;SEV INCREMENT AS CURRENT
	MOVEM	T1,FINCR
	SETZM	SINCR		;SET NO SECOND INCREMENT
	CAIE	C,","		;CHECK FOR MORE ARGUMENTS
	JRST	COPYP1		;NO, LOOK FOR TERMINATOR
	PUSHJ	P,SCAN
	CAME	T1,[<ASCII /00000/>!1]	;AVOID 0 INCREMENTS
	TRNN	FL,NUMF		;SHOULD BE INCREMENT, MUST BE NUMBER
	NERROR	ILC
	MOVEM	T1,FINCR
	PUSHJ	P,SCAN
	CAIE	C,","
	JRST	COPYP1
	PUSHJ	P,SCAN
	CAME	T1,[<ASCII /00000/>!1]
	TRNN	FL,NUMF
	NERROR	ILC
	MOVEM	T1,SINCR
	PUSHJ	P,SCAN
COPYP1:	TRNN	FL,TERMF
	NERROR	ILC		;DID NOT END PROPERLY, LOSE
	POPJ	P,		;RETURN

NOCOP:	PUSHJ	P,SCAN		;CHECK EOL
	TRNN	FL,TERMF
	NERROR	ILC
	TLZ	FL,SRCOP	;TURN OFF COPY
	JRST	COPDON


RSCOP:	POP P,T2
	MOVE P,COPDL	;GET PDL BACK
	POP P,T1
	TRZ FL,READOF!BOF!EOF!EOF2!BGSN	;RESTORE SELECTED FLAGS
	TLZ FL,TECOF!FSTOPF
	IOR FL,T1
	POP P,BGPG
	POP P,WC
	POP P,OLDLIN
	POP P,SVWD
	POP P,PNTR
	POP P,INPG
	POP P,CPG
	POP P,HLFWC
	POP P,MAXWC
	POP P,BUFP
	POP P,CLN
	POP P,CPGL
	POP P,FILPT
	POP P,SAVEN		;RESTORE AUTO-SAVE
	JRST (T2)	;NOW RETURN


SUBTTL	SUBSTITUTE COMMAND (REPLACES THINGS)

IFN STANSW, <
	HLPMSG <S Command	(Substitute)
 
S<old string>$<new string>${<range>}{#<columns>}{,<soptions>}{,<occurrences>}
S		continue substitution on rest of range

Substitutes the  new string of characters for  all occurrences of the
existing  string of characters contained  within the specified range.
If you  do not give a range, the  S command performs the substitution
for the next occurrence of  the existing string.  Should you give the
S  command  a  second  consecutive  time,  the  system  performs  the
substitution  on the rest of  the file.  You can  also match multiple
strings. Consult the Edit manual for details.
 
columns::

     #<col>		Match must begin in column <col>
     #<col1>:<col2>	Match must begin between <col1> and <col2>
     #<col>!<len>	Match must begin within <len> after <col>

soptions::
 
     ,D   Decide on each substitution
     ,E   Match upper/lower case characters Exactly
     ,N   Do not print contents of line

occurrences::
 
     ,<n> Stop after n lines containing <old-str> found, even if none
	  accepted.
 
When in "Decide" mode you can give:
   <del>|<bs> 		to reject substituting for this line;
   Q | E		to reject, and quit these substitutions here;
   A			to enter Alter-mode on line (any # of times);
   G			turn off D -- accept all remaining subst's;
   <space>		accept the line as printed, and continue.
   H			print an option list
 
Special characters:  ( to use, you must set /C128 )
 
   24  '/   	match any character;
  174  ':   |	match any "separator" (non- number|letter|.|%|$);
    5  '%  ^E	not-match next character, or match everything else;
   16  ')  ^N	"any number of" whatever follows, (0 or more);
   36  '7  ^^	quote next character;
   17  '*  ^O	meta-symbol for nth-partial-string, in the form of:
		'*<n>'* in the <new-str>, to refer to nth-portion
		or segment found of the <old-str>.  Use "'*" form.
    3  '"  ^B	next matching string.
 
**  A solitary ') or ') in a substitute command may surprise you, e.g.
doing  S').$ $	on the text ".A..B...C"  gives *LINE TOO LONG*
because ') means zero-or-more of the next character.
A better form of the command is  S.').$ $  to anchor it.
>
>; IFN STANSW


SUBST:	TLZ FL,ASSMF	;DO NOT ASSUME ANYTHING YET
	TLZ FL2,SRCWHO	;(203) SUBST IS DOING THE SEARCH
	TRNE FL,READOF
IFE STANSW, <
	NERROR ILC
>; IFE STANSW
IFN STANSW, <
	NERROR IRO
>; IFN STANSW
	SETZM LOLN	;A GOOD THING
	SETZM PARCNT	;ZERO COUNT FOR SEQUENTIAL PARTIALS
	HRLOI T1,377777	;SET FOR LOTS
	MOVEM T1,RPCNT
	MOVE T1,[ASCII "S*"]
	MOVEM T1,FSFLG		;PROMPT FOR SUBST CMD
	MOVE T1,[POINT 7,R1BUF]
	MOVEI T3,R1PNT
	PUSHJ P,SSTRNG	;THIS CODE IS JUST LIKE SEARCH
	JRST	[SKIPE R2PNT	;BOTH STRINGS MUST HAVE BEEN GIVEN
		SKIPN R1PNT
		NERROR NSG	;ELSE THERE HAS BEEN AN ERROR
		CAIN C,12	;CHECK FOR JUST A CRRET
		JRST ASBMD1	;AND DO A CONTINUE
		JRST NOSTR]	;THERE IS NO STRING
	MOVE T1,[POINT 7,R2BUF]	;GET STRING TO REPLACE BY
	MOVEI T3,R2PNT
	PUSHJ P,SSTRNG
	JRST	[CAIN C,12
		JRST	[PUSH P,[.]	;SET UP RETURN
			JRST RETSTR]	;AND READ MORE (FISRT NULL)
		MOVEM T1,R2PNT	;NULL STRING MEANS DELETE
		MOVEI T2,0		;SO SET A REAL NULL STRING
		IDPB T2,T1
		JRST .+1]
	SUBI T3,R2PNT	;GENERATE NUMBER OF REPLACEMENT STRINGS
	MOVEM T3,RSTRCT	;AND SAVE FOR LATER
NOSTR:	TLZ FL,NOPRN!DECID!EXCTS1	;CLEAR FLAGS
	PUSHJ P,SCAN	;AND START LOOKING FOR MORE JUNK
	TRNN FL,TERMF	;NOTHING
	CAIN C,","	;OR JUST A COMMA
	JRST ASBMDT	;THEN SEARCH FROM HERE TO ETERNITY
	CAIE C,"!"	;HE ONLY WANTS TO GIVE A STOPPING POINT
	CAIN C,":"
	JRST ASBMDT
IFN STANSW,<
	CAIN C,"#"		;ALSO IF # USE SPECIAL LIMITS
	 JRST ASBMDT
>; IFN STANSW
	PUSHJ P,GET2	;GO GET A RANGE
REP4:	MOVE T1,HILN	;SAVE FOR POSSIBLE CONTINUE
	MOVEM T1,RPHILN
	MOVE T1,HIPG
	MOVEM T1,RPHIPG
IFN STANSW,<			;--OO7
	CALL GCOLS
REP5:
>; IFN STANSW
	CAIE C,","	;IS THERE MORE?
	JRST REP1	;NO
	PUSHJ P,SCAN	;SEE WHAT IT IS
	TRNN FL,IDF	;POSSIBLY AN IDENT
	JRST REP2	;NO MAYBE A NUMBER OF TIMES
	MOVS T1,ACCUM
	CAIN T1,(<SIXBIT /N  />)
IFN STANSW,<
	 JRST [ TLO FL,NOPRN	;SET FOR NO PRINTING
		JRST REP6 ]
	CAIN T1,(<SIXBIT /D  />)  ;DECIDE MODE?
	 JRST [ TLO FL,DECID
		JRST REP6 ]
	CAIE T1,(<SIXBIT /E  />)  ;EXACT MATCH?
	 NERROR ILC		;GIVE UP
	TLO FL,EXCTS1
REP6:	CALL SCAN
	JRST REP5
>; IFN STANSW
IFE STANSW,<
	TLO FL,NOPRN	;SET FOR NO PRINTING
	CAIN T1,(<SIXBIT /D  />)
	TLO FL,DECID	;HE WANTS TO BE ABLE TO DECIDE
	TLNN FL,DECID!NOPRN	;IF NEITHER
	JRST REP3	;THEN TRY FOR E SWITCH
	PUSHJ P,SCAN	;SEE IF THERE IS MORE
	CAIE C,","
	JRST REP1	;END OF LINE
	PUSHJ P,SCAN	;LOOK FOR STILL MORE
	TRNN FL,IDF
	JRST REP2
	MOVS T1,ACCUM
REP3:	CAIE T1,(<SIXBIT /E  />)	;IS IT THE EXACT SEARCH SWITCH
	NERROR ILC	;NO,LOSAGE
	TLO FL,EXCTS1
	PUSHJ P,SCAN	;ONE LAST TRY
	CAIE C,","
	JRST REP1	;GO CHECK TERMINATOR
	PUSHJ P,SCAN	;ONLY ONE THING LEFT
>; IFE STANSW
REP2:	TRNN FL,NUMF
	NERROR ILC	;BUT IT WAS NOT
	MOVEM T2,RPCNT	;SAVE IT AWAY
	PUSHJ P,SCAN
REP1:	TRNN FL,TERMF	;ALLS WELL THAT ENDS WELL
	NERROR ILC	;BUT NOT THIS ONE
REP1A:	MOVEI T1,R1PNT	;GET THE SEARCH CODE
	PUSHJ P,CODSR
	MOVE T1,LOPG
	MOVEM T1,DPG
	MOVEM T1,RPPG	;FOR PRINT OUTS
	MOVE SINDEX,LOLN
	PUSHJ P,FIND	;GET THAT LINE
	TRZ FL,LINSN	;NOTHING YET
	SETZM FNDFLG	;NO HOW
	TLNE	FL2,PDECID
	TLO	FL,DECID	;SET IF PERM MODE ON
ONREP:	PUSHJ P,ONMOV	;CHECK FOR STILL IN RANGE
	JRST ENDREP	;FINALLY
	TLZE FL,ASSMF	;SHOULD WE START WITH .+1
	JRST 	[CAME T1,LOLN	;IS IT THE ONE WE ASKED FOR
		JRST .+1	;NO, USE IT
		AOS SVCNT	;JUST IN CASE A ! TYPE OF RANGE
		JRST RPNXT]
	TRO FL,LINSN	;THIS LINE IS GOOD ENOUGH
	CAMN T1,PGMK
	JRST RPPAG	;GO TAKE CARE OF PAGE MARKS
	MOVEI T2,R1PNT	;DO THE SEARCH
	PUSHJ P,COMSRC
	JRST RPNXT
	SETOM FNDFLG	;FOUND
	SKIPGE T3	;PROTECT AGAINS SPECIAL KILLING TAB
	IBP ALTP
	PUSH P,T3	;SAVE COUNT OF HOW FAR INTO LINE
	MOVE T3,(PNTR)	;SET UP CURRENT LINE
	MOVEM T3,CLN
	MOVE T3,CPG
	MOVEM T3,CPGL
	MOVE T2,[XWD LIBUF,LIBUF+1]	;CLEAR IT OUT
	SETZM LIBUF
	BLT T2,LIBUF+MXWPL+1	;WE WILL DO REPLACE HERE


	MOVE T2,PNTR	;GET THE POINTER TO THE LINE
	MOVE T3,(T2)	;PICK UP THE FIRST WORD
	MOVEI T4,LIBUF	;THE PLACE TO PUT IT
	JRST SBALT3	;TRANSFER
SBALT2:	SKIPE T3,(T2)
	TRNE T3,1	;IS IT THE END OF THE LINE
	JRST SBALT1
SBALT3:	MOVEM T3,(T4)	;PUT IT AWAY
	ADDI T4,1
	AOJA T2,SBALT2

SBALT1:	SUBI T4,LIBUF	;GET SIZE LINE USED TO BE
	MOVEM T4,OCNT
	POP P,CCNT	;GET THE NUMBER OF CHRS INTO LINE
	SKIPGE CCNT	;MUST BE .GE. 0
	SETZM CCNT
	SUBI ALTP,(PNTR)	;CONVERT POINTER TO LIBUF
	ADD ALTP,[XWD 70000,LIBUF]	;AND BACK UP ONE
NXTRPL:	SETZM PARCNT	;ZERO FOR NEXT REP
	LDB T1,[POINT 4,-1(T1),12]	;GET STRING NUMBER
	CAMLE T1,RSTRCT	;IS IT LARGER
	MOVE T1,RSTRCT	;THEN USE LAST
	MOVE T1,R2PNT(T1)
	MOVSI T4,70000	;DECREMENT POINTER
	ADDM T4,SRCALP
REPSTR:	ILDB C,T1	;GET THE NEXT CHR
	JUMPE C,ENDRP	;THE END OF THE REPLACE STRING
	CAIN C,""	;DOES HE WANT ONE OF THE PARTIAL THINGS
	JRST PARSTR	;YES, GO HANDLE THAT
	CAIN C,""	;CHECK FOR QUOTING NEXT CHR
	JRST INSQT
	CAIN C,""	;SEQUENTIAL PARTIAL
	JRST PARORD	;YES, GO HANDLE
PUTSTR:	IDPB C,ALTP	;PUT IN THE REPLACEMENT
	AOS C,CCNT	;ADVANCE COUNT
	CAIL C,MXWPL*5	;CHECK AGAINST MAX
	NERROR LTL	;AND LOSE
	JRST REPSTR
ENDRP:	MOVE T3,CCNT	;GET COUNT SO SEARCH CAN GO ON
	PUSH P,ALTP	;SAVE REPLACE POINTER
	PUSH P,SRCALP	;AND THE END OF INPUT POINTER
	MOVE ALTP,SRCALP	;CONTINUE FROM HERE
	ILDB T1,SRCALP	;SEE WHAT CHAR WE STOPPED ON
	CAIE T1,12	;HAVE WE GONE TOO FAR?
	PUSHJ P,COMSRT	;THIS WILL CONTINUE
	JRST FINLIN	;ALL DONE WITH MATCHES, FINISH UP
	CAIL T3,MXWPL*5	;ARE THERE TOO MANY?
	NERROR LTL
	POP P,T2
DOMOV:	ILDB C,T2	;MOVE THE CHRS THAT DID NOT MATCH
	CAMN T2,ALTP	;HAVE WE GOTTEN TO THE NEXT MATCH
	JRST DONMOV	;YES
	IDPB C,(P)	;THE BYTE POINTER IS STILL IN THE STACK
	JRST DOMOV
DONMOV:	MOVEM T3,CCNT	;PUT THE COUNT BACK IN CORE
	POP P,ALTP	;THIS IS NOW THE DEPOSIT POINTER
	JRST NXTRPL	;GO DO A REPLACE


FINLIN:	POP P,SRCALP	;GET SET TO MOVE TO END
	POP P,ALTP
	ILDB C,2(P)	;WE JUST HAPPEN TO KNOW ITS STILL THERE
	CAIE C,12	;IF SO WE HAVE EATEN A RETURN
	JRST ENDFIN	;ALL IS OK
FINL2:	MOVEI C,15
	SKIPA	;SO PUT IT IN
ENDFIN:	ILDB C,SRCALP
	IDPB C,ALTP
	AOS CS,CCNT
	CAIL CS,MXWPL*5
	NERROR LTL
	CAIE C,12
	JRST ENDFIN	;DONE WHEN WE SEE THE LINE FEED
	MOVEI T1,0	;ZERO OUT REST OF THIS LINE
DOZER:	TLNN ALTP,760000	;POINTER AT END OF LINE?
	JRST ZEROD
	IDPB T1,ALTP
	JRST DOZER
ZEROD:	SUBI ALTP,LIBUF	;MOVEI AC,1-LIBUF(AC)
	MOVEI ALTP,1(ALTP)	;GET COUNT
	MOVEM ALTP,NCNT
	TLNE FL,NOPRN	;DID HE WANT PRINTING SUPRESSED
	JRST NOPLIN
	MOVE	T2,CPG		;GET CURRENT PAGE
	TRNN	FL2,NONUMF	;DON'T PRINT IF NONUMBER
	CAMN	T2,RPPG		;OR PAGES MATCH
	SKIPA
	PUSHJ	P,PGPRN
	MOVE	T2,CPG
	MOVEM	T2,RPPG		;SET AS CURRENT PAGE
NOVCMD:	MOVEI T1,LIBUF		;PRINT THE LINE
	PUSHJ P,OUTLIN
	TLNN FL,DECID		;DOES HE WANT THE OPTION OF SAYING NO
	JRST NOPLIN		;NO, INSERT IT
NOVCM1: 
IFN STANSW, <
	OUTSTR [ASCIZ/D*/]
>; IFN STANSW
	INCHRW	T1		;WAIT FOR HIM TO TYPE SOMETHING
IFN STANSW, <
	CAIN	T1,"?"		;CONFUSE QUESTION MARK...
	MOVEI	T1,"H"		;WITH HELP
>; IFN STANSW
	ANDI	T1,177
	OCRLF
	CAIN	T1,177		;DID HE SAY RUBOUT(DON'T INSERT)?
	JRST	RPNXT1		;YES, JUST IGNORE THIS LINE
	CAIN	T1," "		;SPACE MEANS USE IT
	JRST	NOPLIN
	ANDI	T1,137		;FORCE UPPER CASE
	CAIE	T1,"Q"
	CAIN	T1,"E"		;DOES HE WANT OUT
	JRST	ENDREP		;YES: QUIT
 	CAIN	T1,"A"
	JRST	RPALT
	CAIN	T1,"G"		;GET OUT OF DECIDE MODE
	JRST	[TLZ FL,DECID	;LEAVE DECIDE MODE
		 JRST NOPLIN]
IFN STANSW, <
	CAIE	T1,37		;HELP MESSAGE WANTED?
>; IFN STANSW
	CAIN	T1,"H"
	JRST	[OUTSTR	DECIDT
		 JRST NOVCMD]
	PUSH	P,FL2		;TEMP HACK
	TRZ	FL2,COMFLF	;SAY WE NEVER WANT IND CMND #
	RERROR	ILDC		;ILLEGAL CHARACTER
	POP	P,FL2		;RESTORE FLAGS
	OUTCHR	[7]		;DING
	CALL	CLRBFI		;CLEAR HIM OUT
	TRNE	FL,EXTOG	;SHORT ERROR MESSAGES?
	JRST	NOVCM1		;YES, WAIT FOR INPUT
	JRST	NOVCMD		;NO, TRY IT ALL AGAIN

	
DECIDT:	ASCIZ "Type one of:
SPACE bar  - To accept this substitution.
DELETE key - To reject this substitution.
A          - To do this substitution, then enter Alter mode.
E          - To return immediately to command mode without
             making the substitutions.
G          - To make this substitution, and further ones, 
             automatically.
H          - To type this help text.
"

NOPLIN:	PUSHJ	P,INSED		;ANYTHING ELSE IS OK
	PUSHJ	P,FINDN		;GET NEXT
	PUSHJ	P,FILLB		;IN CASE IT GOT LONGER
	SOSG	RPCNT		;SEE IF OUT OF COUNT
	JRST	COMND
	MOVE	T1,(PNTR)	;GET POINTER BACK
	JRST	ONREP

IFE STANSW, <
RPALT:	TRO	FL2,ADECIF	;SAY THIS IS AN "A" ANSWER
>; IFE STANSW
IFN STANSW, <
RPALT:	TRO	FL2,ADECIF!ALTLSF	;SAY "A" & LINE WAS PRINTED. --OO7
>; IFN STANSW
	MOVE	T1,OCNT		;SAVE COUNT
	ADDI	T1,LIBUF	;FAKE OUT SETALT
	PUSHJ	P,RPSALT
	PUSHJ	P,ALTN1		;DO ALTER
	JRST	ENDREP		;QUIT
	JRST	NOPLINE		;USE IT NOW


ASBMD1:	TROA FL,CNTF	;MARK AS KEEP END OF RANGE
ASBMDT:	TRZ FL,CNTF	;JUST IN CASE
	TLO FL,ASSMF	;WE ASSUME .+1
	MOVE T1,CLN
	MOVEM T1,LOLN	;SET FOR HERE TO ETERNITY
	MOVEM T1,HILN
	MOVE T1,CPGL
	MOVEM T1,LOPG
	TRZE FL,CNTF	;KEEP END?
	JRST NOSPSB
	CAIE C,":"	;IF A : OR A !
	CAIN C,"!"
	JRST HALFSB	;GET THE SECOND HALF (.+1 TO GIVEN)
	MOVSI T1,377777	;GET A LARGE PAGE
	MOVEM T1,HIPG
	MOVEI T1,1	;SET FOR ONLY ONE
	MOVEM T1,RPCNT
	JRST REP4	;ONWARD
HALFSB:	MOVEM T1,HIPG	;SET TO AS /.
	PUSHJ P,GET2HF	;GET THE SECOND HALF
	JRST REP4	;AND GO

NOSPSB:	MOVE T1,RPHIPG
	MOVEM T1,HIPG
	MOVE T1,RPHILN
	MOVEM T1,HILN
	JRST REP1A


INSQT:	ILDB C,T1	;GET NEXT CHR
	JUMPN C,PUTSTR	;MUST NOT BE 0
	NERROR IRS	;THIS STRING IS ILLEGAL

PARSTR:	MOVEI CS,0	;FIND OUT THE NUMBER
PARST1:	ILDB C,T1	;GET A CHR
	CAIN C,""	;CHECK FOR END
	JRST ENDNUM
	CAIL C,"0"	;MUST BE A DIGIT
	CAILE C,"9"
	NERROR IRS
	IMULI CS,^D10	;CONVERT
	ADDI CS,-"0"(C)
	JRST PARST1
ENDNUM:	CAILE CS,0
	CAMLE CS,ARBCNT	;IS IT IN RANGE
	NERROR IRS	;NO SUCH PARTIAL STRING
	MOVE T4,[POINT 7,ARBBUF]	;START LOOKING FOR IT
	SOJLE CS,FNDRST	;STARTS WITH STRING 1
NXTST:	ILDB C,T4
	JUMPN C,NXTST	;0 IS END OF A PARTIAL STRING
	SOJG CS,NXTST	;LOOK FOR CORRECT STRING
FNDRST:	ILDB C,T4	;NOW INSERT THAT STRING
	JUMPE C,REPSTR	;GO FINISH THE REPLACEMENT STRING
	IDPB C,ALTP
	AOS C,CCNT
	CAIL C,MXWPL*5
	NERROR LTL
	JRST FNDRST

PARORD:	AOS CS,PARCNT	;GET NEXT PARTIAL
	JRST ENDNUM

RPNXT1:	SOSG RPCNT
	JRST RPFND
RPNXT:	PUSHJ P,FINDN
	JRST ONREP	;CONTINUE LOOKING AT LINES

ENDREP:	TRZN FL,LINSN	;WERE THERE ANY?
	NERROR NLN
RPFND:	SKIPN FNDFLG	;FIND ANY?
	RERROR SRF	;NOPE
	JRST COMND	;GO ON

RPPAG:	AOS CPG	;JUST ADVANCE PAGE COUNTER
	JRST RPNXT


SUBTTL	XPAND COMMAND

IFN STANSW, <
	HLPMSG <X Command	(eXtend)
 
X<range>
 
Extend the  specified  range by  entering Alter  mode  as with	an  I
subcommand to add characters onto the end of the lines.
>
>; IFN STANSW
XPAND:	SETZM LOLN		;AS USUAL, A GOOD THING
	TRNE	FL,READOF	;CHECK R/O
IFE STANSW, <
	NERROR	ILC
>; IFE STANSW
IFN STANSW, <
	NERROR IRO
>; IFN STANSW
	SETZM SSW		;CLEAR SWITCH
	PUSHJ P,GET2S		;THE RANGE
	CAIE C,","		;SWITCH
	JRST XPAND0
	PUSHJ P,SCAN
	MOVS T1,ACCUM
	CAIE T1,(<SIXBIT /S  />)
	NERROR ILC
	SETOM SSW		;SET TO SUPPRESS TYPEOUT
	PUSHJ P,SCAN
XPAND0:	TRNN FL,TERMF
	NERROR ILC
	TRZ FL,LINSN
	MOVE T1,LOPG
	MOVEM T1,DPG
	MOVE SINDEX,LOLN
	PUSHJ P,FIND
XPND1:	PUSHJ P,ONMOV		;STILL IN RANGE?
	JRST EXPEND
	TRO FL,LINSN
	CAMN T1,PGMK		;IGNORE THESE
	JRST PAGE
	SKIPE SSW		;SUPPRESS?
	TRO FL2,SUPN		;YES:
	MOVEM T1,CLN
	MOVE T1,CPG
	MOVEM T1,CPGL		;SET LINE AND PAGE
IFN STANSW, <
	TRO FL2,ALTLSF		;SUPPRESS AUTO-L.  --OO7
>; IFN STANSW
	PUSHJ P,SETALT		;SET THINGS UP
	MOVSI T2,1		;A LARGE COUNT
	PUSHJ P,ALTSP		;SPACES
	TRZ FL2,SUPN		;RESET SWITCH
	MOVEI T2,0
	PUSHJ P,[PUSHJ P,ALTIN
		 PUSHJ P,ALTN1
		 JRST LEVINS
		 AOS (P)
		 POPJ P, ]
	JRST LEVINS
	PUSHJ P,INSED		;PUT IN CHANGED LINE
EXPND2:	PUSHJ P,FINDN
	PUSHJ P,FILLB		;IN CASE OF OVERFLOW
	MOVE T1,(PNTR)		;GET BACK NEXT LINE
	JRST XPND1
PAGE:	AOS T2,CPG
	MOVEM T2,CPGL
	PUSHJ P,PGPRN		;SEE ALTER COMMAND
	MOVE T1,[<ASCII /00000/>!1]
	MOVEM T1,CLN
	JRST EXPND2
EXPEND:	TRNN FL,LINSN
	NERROR NLN
	JRST COMND


SUBTTL	JOIN COMMAND

IFN STANSW, <
	HLPMSG <J Command	(Join -or- Justify [2 commands])
 
Join:
 
J<position>
 
To the end of the specified line, transfer the characters of the entire
line following it, removing that line.
 
Justify:
 
JU<range>,<local lmar>,<local rmar>,<local pmar>
 
variations of the basic command:
 JC  Center
 JF  Fill--JU w/o padding to right margin
 JL  Left
 JR  Right
 
Specifiable page characteristics are: PMAR (paragraph margin), LMAR
(left margin), RMAR (right margin).  The / and = commands are used to
set and examine these variables.
>
>; IFN STANSW


JOIN:	SETZM	LOLN		;AS USUAL
	TRNE	FL,READOF
IFE STANSW, <
	NERROR	ILC
>; IFE STANSW
IFN STANSW, <
	NERROR	IRO
>; IFN STANSW

JOIN1:	PUSHJ P,GET1S		;GET LINE NUMBER
	TRNN FL,TERMF
	NERROR ILC
	MOVE T1,HIPG
	MOVEM T1,DPG
	MOVE SINDEX,HILN	;FIND THE CORRECT LINE
	PUSHJ P,FIND
	MOVE T2,CPG
	MOVE T1,(PNTR)
	CAMN T2,HIPG
	CAME T1,HILN
	NERROR NLN
	MOVEM T2,CPGL
	MOVEM T1,CLN
	SETZM LIBUF		;TO ELIMINATE GARBAGE AT END OF LINE
	MOVE T1,[XWD LIBUF,LIBUF+1]
	BLT T1,LIBUF+MXWPL+1
	MOVE T2,PNTR		;GET THE POINTER TO THE LINE
	MOVE T3,(T2)		;PICK UP THE FIRST WORD
	MOVEI T4,LIBUF		;THE PLACE TO PUT IT
	JRST JSALT3		;TRANSFER
JSALT2:	SKIPE T3,(T2)
	TRNE T3,1		;IS IT THE END OF THE LINE
	JRST JSALT1
JSALT3:	MOVEM T3,(T4)		;PUT IT AWAY
	ADDI T4,1
	AOJA T2,JSALT2


JSALT1:	MOVEI T1,(T4)		;MOVEI T1,-LIBUF(T4)
	SUBI T1,LIBUF
	MOVEM T1,OCNT
	IMULI T1,5		;GET COUNT OF CHRS
	SUBI T1,6		;WE WILL HAVE TO FIND THE TRUE END
	SUBI T4,2
	HRLI T4,(<POINT 7,0,27>) ;SET UP POINTER
FEND1:	ILDB T2,T4
	CAIE T2,15
	AOJA T1,FEND1
	PUSH P,T1
	PUSHJ P,FINDN		;GET THE LINE TO JOIN IT TO
	CAME T1,PGMK
	SKIPN T1
	NERROR NNN		;NO LINE THERE TO CONNECT TO
	POP P,T2		;COUNT
	MOVEI T1,1(PNTR)
	HRLI T1,(<POINT 7,0,6>)	;SET TO POINT THERE
	ADD T4,[XWD 70000,0]
TRN1:	ILDB T3,T1
	IDPB T3,T4
	ADDI T2,1
	CAIL T2,MXWPL*5+6
	NERROR LTL
	CAIE T3,12
	JRST TRN1
	SUBI T1,-1(PNTR)
	PUSH P,OCNT
	HRRZM T1,OCNT		;SIZE OF OLD SECOND LINE
	SETZM NCNT
	PUSHJ P,INSED
	PUSHJ P,FINDB		;BACK UP
	POP P,OCNT		;GET ITS SIZE
	SUBI T4,LIBUF-1
	HRRZM T4,NCNT
	PUSHJ P,INSED
	JRST COMND


SUBTTL	JUSTIFY ROUTINES

IFN STANSW, <

JFFLG==	1			;JF, distinguished from JU.
JRFLG==	2			;Right justify.
JCFLG==	4			;Centering.
JLFLG==	10			;Left justify.
JFILL==	20			;Fill
JBLF==	40			;Saw a space.
JPER==	100			;Saw a period (or : or ? or !).

TAB==11
CR==15
LF==12

JOINT:	TRZ	JF,177
	CALL	GNCH		;GET A CHARACTER
	MOVEM	C,LIMBO		;PUT CHARACTER BACK IN CASE THIS IS JOIN
	CAIL	C,"A"+40	;TEST FOR LOWERCASE
	CAILE	C,"Z"+40
	JRST	.+2
	TRZ	C,40
	CAIN	C,"R"
	TRO	JF,JRFLG	;R FOR RIGHT
	CAIN	C,"L"
	TRO	JF,JLFLG	;L FOR LEFT
	CAIN	C,"C"
	TRO	JF,JCFLG	;C FOR CENTER
	CAIN	C,"U"		;U FOR JUSTIFY
	TRO	JF,JFILL	;  Fills and justifies line, versus
	CAIN	C,"F"		;F for fill only.
	TRO	JF,JFFLG!JFILL
	TRNN	JF,JRFLG!JLFLG!JCFLG!JFILL
	 JRST	JOIN		;MUST BE LINE NUMBER FOR JOIN
	SETZM	LOLN		;for ranges like /.
	SETZM	LIMBO		;FLUSH CHAR WE SAVED IN CASE OF JOIN

	CALL	GET2S		;GET RANGE
	MOVE	T1,LMAR		;Set default margins for him...
	MOVEM	T1,JUSTLM
	MOVE	T1,RMAR
	MOVEM	T1,JUSTRM
	MOVE	T1,PMAR
	MOVEM	T1,JUSTPM
	CAIE	C,","
	JRST	JCKTRM
	CALL	SCANUM		;<local LM> {,<local RM> {,<local PM>}}
	MOVEM	T2,JUSTLM
	MOVEM	T2,JUSTPM	;  set both same, when locals.
	CALL	SCAN
	CAIE	C,","
	JRST	JCKTRM
	CALL	SCANUM
	MOVEM	T2,JUSTRM
	CALL	SCAN
	CAIE	C,","
	JRST	JCKTRM
	CALL	SCANUM
	MOVEM	T2,JUSTPM
	CALL	SCAN
JCKTRM:	TRNN	FL,TERMF	;THIS HAD BETTER BE A TERMINATOR
	 NERROR	ILC		;HE REALLY BLEW IT.
	MOVE	T1,JUSTRM
	CAILE	T1,MXWPL*5-3
	 NERROR	ILC
	CAMLE	T1,JUSTLM
	CAMG	T1,JUSTPM
	 NERROR	ILC
	MOVE	T1,LOPG		;GET SET TO FIND LINE
	MOVEM	T1,DPG
	MOVE	SINDEX,LOLN
	MOVEM	SINDEX,LIBUF	;ALSO SET NEW FIRST LINE TO SAME
	CALL	FIND		;FIND IT
	SETZM	NLIN2		;None on this page yet.
	SETZM	LWRD		;(Just in case...NLN.)
	CALL	INITOL		;SET IT UP -- if NLN, goes straight to JSTEND.
	MOVEM	T1,LIBUF	;SET NEW LINE NUMBER SAME AS OLD
	SKIPE	LOLN		;Do whole page /n ?
	 MOVEM	T1,LOLN		;  No, save for JSTEND incr calc.
	CALL	INITNL		;AND SET UP THE NEW ONE
	SETZM	TPNT		;TELL JGET THERE IS NOTHING IN LIBUF2
	MOVE	T1,JUSTLM	;SET LEFT MARGIN.
	TRNE	JF,JFILL	;IF FILLING
	 MOVE	T1,JUSTPM	;  MAKE THIS START OF PARAGRAPH.
	SOS	T1
	MOVEM	T1,INDNT	;FOR INDENTATION
	MOVEM	T1,LINL		;AND LINE LENGTH
	MOVE	T1,PNTR
	ILDB	T1,T1
	CAIE	T1,TAB
	 JRST	JGET
	SETZM	INDNT		;If a <tab> starts this PARA,
	SETZM	LINL		;  no special indentation.

;JGET - GET A CHARACTER FROM THE OLD LINE

JGET:	SKIPN	TPNT		;IS THERE ANY UNPROCESSED TAIL?
	 JRST	JGET1		;NO, GET A CHARACTER
	MOVE	T1,ELIN		;ARE WE AT END OF LINE?
	CAMN	T1,TPNT
	 JRST	JGET2		;YES, START GETTING FROM OLD LINE
	ILDB	T1,TPNT		;NO, GET A CHARACTER
	JRST	JPUT		;AND PUT.

JGET2:	SETZM	TPNT		;END OF TAIL
JGET1:	ILDB	T1,PNTR		;LOAD A CHARACTER
	AOS	OCNT1		;STEP CHARACTER COUNT
	CAIE	T1,CR		;IS THIS A CR?
	 JRST	JGET3		;NO,TEST FOR END OF LINE
	TRNN	JF,JFILL	;ARE WE FILLING?
	 JRST	JGET4		;  NO, WE'RE THROUGH
	MOVEI	T1," "		;  YES, MAKE IT A BLANK
	JRST	JPUT		;AND GO PUT

JGET3:	CAIE	T1,LF		;END OF LINE?
	 JRST	JPUT		;NOT YET, SO GO PUT
JGET4:	HRRZ	T1,PNTR		;CURRENT WORD IN BUFFER FOR DELETION
	SUB	T1,OPTR		;- START OF OLD LINE
	AOS	T1		;+1 = WORD COUNT OF OLD LINE
	MOVEM	T1,OCNT		;FOR INSED
	TRNN	JF,JFILL	;IF WE ARE NOT FILLING
	 JRST	JGETE		;DO WHAT WE HAVE TO DO
	SETZM	NCNT		;OTHERWISE WE DELETE OLD LINE
	MOVE	PNTR,OPTR	;WHICH STARTS  HERE
	CALL	INSED		;USING INSED
	CALL	FINDN1		;MAKE SURE WE'RE AT START OF NEXT ONE
	CALL	INITOL		;DO SETUP ON IT AND CHECK RANGE
	ILDB	T1,PNTR		;GET FIRST CHARACTER
	AOS	OCNT1		;STEP CHARACTER COUNT
	CAIE	T1,TAB		;IS IT A TAB
	CAIN	T1,CR		;OR CR?
	 JRST	PARA		;  YES, START A NEW PARAGRAPH
	JRST	JPUT		;  NO, GO PUT.

JGETE:	MOVE	T1,LINL		;LINE LENGTH
	MOVEM	T1,WRDL		;TO WRDL BECAUSE CR AS BLANK WAS DELETED
	MOVEM	ALTP,LWRD	;ALSO STORE POINTER TO END OF LINE
	CAMLE	T1,JUSTRM	;IF LINE WAS TOO LONG,
	 RERROR	LTL		;TELL HIM SO
	CALL	JSUB		;CLEAN UP NEW LINE AND PUT IT OUT
	CALL	INITOL		;SET UP NEXT LINE
	MOVEM	T1,LIBUF	;SET NEW LINE NUMBER SAME AS OLD
	SETZM	TPNT		;NOTHING IN LIBUF2
	JRST	JGET2		;START MUNCHING

;JPUT - PUT A CHARACTER INTO THE NEW LINE

JPUT:	CAIN	T1," "		;IS THIS A SPACE/BLANK?
	 JRST	JPUTSP		;  YES, PROCESS IT.
	CAIE	T1,042		;IS THIS A DOUBLE-QUOTE?
	CAIN	T1,")"		;     OR A RIGHT-PAREN?
	 JRST	JPUTQT		;  YES, PROCESS IT.
				;  NO-- TREAT AS ORDINARY CHAR...
JPUTN:	TRZ	JF,JBLF!JPER	;NOT A BLANK
	CAIE	T1,"."		;IS IT A PERIOD
	CAIN	T1,":"		;OR COLON
	 TRO	JF,JPER
	CAIE	T1,"?"		;OR QUESTION MARK
	CAIN	T1,"!"		;OR EXCLAMATION?
	 TRO	JF,JPER	;  IF SO PERMIT EXTRA BLANKS
JPUTN1:	MOVE	T2,LINL		;LENGTH SO FAR
JPUT1:	IDPB	T1,ALTP		;DEPOSIT CHARACTER
	ADD	T2,@WTBL	;WIDTH OF CHARACTER
	CAIE	T1,TAB		;WAS THAT A TAB?
	 JRST	JPUT2		;NO
	TRZE	T2,7		;YES.  IF LAST 3 BITS ARE NONZERO
	 ADDI	T2,10		;WE WERN'T AT TAB POSITION
	SETZM	WCNT		;RESET WORDCOUNT
	SETZM	LWRD		;LAST WORD LOCATION
	MOVEM	ALTP,BLIN	;AND LOGICAL BEGINNING OF LINE FOR JSUB
	TRNE	JF,JFILL	;IF FILLING
	 TRO	JF,JBLF		;DELETE A FOLLOWING BLANK
JPUT2:	MOVEM	T2,LINL		;STORE NEW LENGTH
	CAMLE	T2,JUSTRM	;ARE WE OVER THE END?
	 JRST	JPUTEL		;YES, END LINE WE ARE NOW ON
	CAME	ALTP,[POINT 7,LIBUF2+MXWPL,34]	;NO, HAVE WE FILLED BUFFER?
	 JRST	JGET		;NOT YET, GET ANOTHER
JPUTEL:	SKIPE	LWRD		;ANY WORDS YET?
	 JRST	JPUTE		;YES, PUT OUT LINE
	RERROR	LTL		;NO, TELL HIM LINE TOO LONG
	MOVE	T2,JUSTRM	;SAY LINE IS LONG ENOUGH
	MOVEM	T2,WRDL
JPUTE:	TRNE	JF,JFILL	;UNLESS WE'RE NOT FILLING (IN WHICH CASE THIS IS A MISTAKE)
	 CALL	JSUB		;MOVE OUT A NEW LINE, AFTER JUSTIFYING IT
	JRST	JGET		;THEN GET ANOTHER CHARACTER

JPUTSP:	TRNE	JF,JPER		;IF WE HAVE SEEN A PERIOD OR SOMETHING
	TRNN	JF,JBLF		;AND THIS IS NOT THE FIRST BLANK
	JRST	.+2		;no period or period & no blank
	 JRST	[TRZ  JF,JPER	;  IF SECOND BLANK, PERMIT, BUT NO MORE.
		 JRST JPUTN1 ]
	TROE	JF,JBLF		;WAS THERE ONE BEFORE IT?
	 JRST	JGET		;  YES; WE DON'T WANT IT.
	TRNN	JF,JFILL	;ARE WE FILLING?  (i.e. justifying)
	 TRZ	JF,JBLF		;NO, PERMIT AN EXTRA BLANK.
	AOS	WCNT		;STEP WORDCOUNT
	MOVE	T2,LINL		;GET LENGTH SO FAR
	MOVEM	T2,WRDL		;AND SAVE IT FOR JSUB
	MOVEM	ALTP,LWRD	;AND STORE POINTER TO END OF WORD
	JRST	JPUT1		;THEN PUT BLANK IN BUFFER

JPUTQT:	TRNN	JF,JPER		;SAW A " OR SOMETHING...AFTER A PERIOD?
	 JRST	JPUTN		;  NO, ORDINARY CHAR AS IS.
	TRNN	JF,JBLF		;  YES, SEEN A bLANK IN NEIGHBORHOOD?
	 JRST	JPUTN1		;    NOT YET:  ."  OR  .""  ETC, SO FAR.
	JRST	JPUTN		;    YES, AS:  .b"  OR  ."b"  ETC,
				;WOULD PREFER TO FORCE IN A 2ND BLANK, PERHAPS,
				;  BUT KEEP AS IS: START OF NEW SENTENCE.

;THIS PUTS OUT A NEW LINE 

NLOUT:	AOS	NLIN2		;One more done on this page.
	MOVEI	T1,CR		;ADD A CR
	IDPB	T1,ALTP
	MOVEI	T1,LF		;AND A LF
	IDPB	T1,ALTP
	HRRZ	T1,ALTP		;LAST WORD OF LINE
	SUBI	T1,LIBUF	;-FIRST
	AOS	T1		;+1=WORDCOUNT
	MOVEM	T1,NCNT		;FOR INSERTION INTO BUFFER
	TRNE	JF,JFILL	;IF FILLING
	 SETZM	OCNT		;INSERT BEFORE
	MOVE	PNTR,OPTR	;ELSE REPLACE, THE OLD LINE
	CALL	INSED		;DONE BY INSED
	CALL	FINDN		;FIND OLD LINE
	CALL	FILLB		;AND KEEP FROM LOSING IT
	TRNN	JF,JFILL	;IF NOT FILLING
	 JRST	INITNL		;SET UP NEW LINE ON THE WAY BACK
	MOVE	T2,INCR		;INCR FOR LINE NUMBERS
	MOVE	T1,LIBUF	;OLD LINE NUMBER
	CALL	ASCIAD		;ADD TO MAKE NEW ONE
	MOVEM	T1,LIBUF	;AND STORE IT AWAY
	CAML	T1,INCR		;Too high (wrap-around)?, or		*****
	CAMLE	T1,MAXLN		;Too many?
	 CALL	NPOUT		;  Yes, need a  fresh page.
	MOVE	T1,OCNT1	;CHARACTERS PROCESSED SO FAR
	MOVEM	PNTR,OPTR	;REMEMBER WHERE WE ARE
	AOS	PNTR		;SKIP LINE NUMBER
	HRLI	PNTR,440700	;MAKE BYTE POINTER
	IBP	PNTR		;TO MOVE PNTR BACK
	SOJGE	T1,.-1		;TO WHERE WE FOUND IT
	JRST	INITNL		;THEN SET UP NEW LINE ON WAY BACK

NPOUT:	CALL	INSEDP
	AOS	INPG
	AOS	BGPG
	AOS	T1,CPG		;NOW NEW PAGE
	MOVEM	T1,CPGL		;AND LOGICAL PAGE
	AOS	HIPG		;Bump range-end also.
	CALL	FINDN		;MOVE PAST IT
	CALL	FILLB		;FILL BUFFER TO KEEP FROM LOSING IT
	MOVE	T2,INCR		;INCR AGAIN
	MOVEM	T2,LIBUF	;TO MAKE FIRST LINE NUMBER
	OUTSTR	[ASCIZ/Page Mark Inserted
/]
	SETZM	NLIN2		;None on this page yet.
	RET

;INITOL		;THIS SETS UP A NEW OLD LINE FOR GET

INITOL:	CALL	FINDN1		;MAKE SURE WE ARE AT START OF LINE
INITO1:	HRRZM	PNTR,OPTR	;SAVE POINTER TO START OF LINE
	CALL	ONMOV		;CHECK RANGE
	 JRST	JSTEND		;FINISHED
	CAMN	T1,PGMK		;IS IT A PAGEMARK?
	 JRST	INITOP		;  YES.
	MOVEM	T1,CLN		;  NO, SET CURRENT LINE.
	MOVE	T2,CPG		;AND PAGE
	MOVEM	T2,CPGL
	SETZM	OCNT1		;NO CHARACTERS YET
	SETZM	TCHR		;NOT KNOWN TO BE START OF PARAGRAPH
	AOS	PNTR		;SKIP LINE NUMBER
	HRLI	PNTR,(<POINT 7,0>)  ;MAKE BYTE POINTER
	IBP	PNTR		;SKIP INITIAL TAB
	RET			;EXIT

INITOP:	TRNE	JF,JFILL	;FOUND a page mark.  ARE WE FILLING?
	 JRST	INITOD		;  YES, DELETE IT.
	AOS	T2,CPG		;  NO, WE ARE ON NEW PAGE.
	MOVEM	T2,CPGL
	CALL	FINDN		;FIND NEXT LINE
	CALL	FILLB		;HANG ON TO IT
	MOVE	T1,(PNTR)	;Restore the FINDN pnt.
	JRST	INITO1		;AND SEE WHAT'S THERE

INITOD:	CALL	INSEDX		;DEL PGMK.
	SOS	BGPG		;NOW HAVE ONE LESS PAGE
	SOS	INPG
	SOS	HIPG
	JRST	INITOL		;LOOK AT NEXT LINE

;THIS RESETS LIBUF AND FLAGS FOR NEW LINE...

INITNL:	SETZM	LIBUF+1		;CODE TO ZERO THE LINE BUFFER
	MOVE	T1,[XWD LIBUF+1,LIBUF+2]
	BLT	T1,LIBUF+MXWPL+1
	MOVE	ALTP,[POINT 7,LIBUF2]  ;POINT ALTP AT START OF LIBUF2
	MOVEI	T1,TAB		;TAB TO START LINE
	IDPB	T1,ALTP		;SO INSERT IT
	MOVEM	ALTP,BLIN	;AND SAVE LOGICAL BEGINNING OF LINE
	TRO	JF,JBLF		; KEEP FROM INSERTING LEADING BLANKS
	TRZ	JF,JPER
	MOVE	T1,JUSTLM	;SET LEFT MARGIN
	SOS	T1		;MARGIN -1 = EXTRA BLANKS
	MOVEM	T1,LINL		;FOR EXTRA LINE LENGTH
	MOVEM	T1,INDNT	;AND INDENTATION
	SETZB	T1,WCNT		;AND THERE ARE NO WORDS YET
	SETZM	WRDL		;NOR CHARACTERS, FOR THAT MATTER
	EXCH	T1,LWRD		;RESET POINTER TO LAST WORD
	MOVEM	T1,TPNT		;BUT SAVE IT TO GET TAIL
	RET			;RETURN

;THIS STARTS A NEW PARAGRAPH

PARA:	MOVEM	T1,TCHR		;STORE TERMINATING CHARACTER
	SKIPE	LWRD		;ANY WORDS YET?
	 CALL	JSUB		;YES, GET RID OF OLD LINE
	MOVE	T1,TCHR		;GET TERMINATOR BACK
	SETZM	TCHR		;DON'T CONFUSE PEOPLE
	SETZM	TPNT		;TELL JGET NOTHING REMAINS IN LIBUF2
	SETZM	INDNT		;IF TAB, NO SPECIAL INDENTATION
	SETZM	LINL
	CAIN	T1,TAB		;IS IT A TAB?
	 JRST	JPUT		;  YES, PUT IT IN NEW LINE.
	CALL	JSUB		;MUST HAVE BEEN BLANK LINE
	MOVE	T1,JUSTPM	;SET PARAGRAPH MARGIN
	SOS	T1
	MOVEM	T1,INDNT
	MOVEM	T1,LINL
	JRST	JGET		;SO GET NEW CHARACTER

;THIS FINISHES EVERYTHING UP
JSTEND:	SETOM	TCHR		;FAKE END OF PARAGRAPH
	SKIPE	LWRD		;ANYTHING LEFT?
	 CALL	JSUB		;YES, GET RID OF IT
	MOVE	PNTR,OPTR	;GET BACK OLD POINTER
	SKIPE	T1,(PNTR)
	CAMN	T1,PGMK		;Any need to check order?
	 JRST	JSTEN2		;  No, at EOP or EOF.
	SKIPN	NLIN2		;Any seen on last page (or at all)?
	 JRST	JSTEN1		;  No, ok to stop.
	SETZB	SINDEX,DESTLN	;Default check is 0:.
	MOVE	T1,INCR
	MOVEM	T1,FINCR	;Default inc.
	MOVE	T1,LOLN
	MOVE	T2,CPG
	CAMN	T2,LOPG		;If still on same page,
	 MOVEM	T1,DESTLN	;  restrict check to LOLN:.
	MOVEM	T2,LOPG		;  (If renumber).
	MOVEM	T2,HIPG
	CALL	DOFINC
	SKIPN	T1,DESTLN	;See if need to do fixups?
	 JRST	JSTEN0		;  No.
	MOVEM	T1,LOLN		;  Yes, this should work with FIND.
	MOVEM	T1,INCST	;Set up for renumbering,
	MOVE	T1,FINCR	;  or just PGMK insert.
	MOVEM	T1,REINC
	MOVE	T1,NLIN2
	MOVEM	T1,SVCNT
	TRO	FL,CNTF		;(rather than use HILN when OOO).
	JRST	RENMBR		;Back to COMND from there.

JSTEN0:	CALL	FINDB
JSTEN1:	MOVEM	T1,CLN
	JRST	COMND		;All done, no order problems.

JSTEN2:	CALL	FINDB		;See if NPOUT left unnecessary mark...
	JUMPE	T1,COMND	;  BOF -- actually NLN, but forgive.
	CAME	T1,PGMK
	 JRST	JSTEN1		;  LOLN-1 also NLN (first loop anyway).
	CALL	INSEDX
	SOS	INPG
	SOS	BGPG
	SOS	CPGL		;BACKED OVER A PGMK IN THE FINDB.
	JRST	JSTEN2		;REMOVE MORE BLANK PAGES -- USER MIGHT PREFER NOT TO??

;JSUB		;AT LAST!  THE JUSTIFICATION OF ALL THIS STUFF!

JSUB:	MOVEM	ALTP,ELIN	;SAVE END OF LINE FOR GET
	MOVE	ALTP,[POINT 7,LIBUF+1]	;WHERE TO DEPOSIT
	MOVE	T4,[POINT 7,LIBUF2]	;WHERE TO LOAD
JSUB1:	ILDB	T1,T4		;GET A CHARACTER
	IDPB	T1,ALTP		;AND MOVE IT
	CAME	T4,BLIN		;WAS THAT THE LAST TAB?
	 JRST	JSUB1		;NO, MOVE ANOTHER
	SKIPN	T5,LWRD		;IF NO WORDS THERE
	 MOVE	T5,ELIN		;THIS IS WHERE TO STOP
	SKIPN	WRDL		;IF NOTHING IS THERE AT ALL
	 JRST	NLOUT		;PUT OUT BLANK LINE
	SETZB	T2,BPW		;NOW WE COMPUTE NUMBER OF BLANKS TO INSERT, IF ANY
	SETZM	REM
	MOVEI	T1," "
	TRNE	JF,JLFLG!JFFLG	;IF LEFT JUSTIFYING or simple-fill
	 JRST	JSUBM1		;WE DON'T WANT ANY
	MOVE	T2,JUSTRM	;DESIRED LENGTH
	SUB	T2,WRDL		;-LENGTH WE HAVE = WHAT WE WANT
	JUMPE	T2,JSUBM1	;IF ZERO, GO MOVE REST OF LINE
	IDIV	T2,@WTBL	;/WIDTH OF BLANK = BLANKS WE NEED
	TRNE	JF,JCFLG	;IF CENTERING
	 ASH	T2,-1		;WE ONLY WANT HALF AS MANY
	TRNE	JF,JRFLG!JCFLG	;IF NOT JUSTIFYING BOTH MARGINS
	 JRST	JSUBM1		;GO PUT IN SOME BLANKS
	SOSLE	WCNT		;IF LESS THAN 2 WORDS
	SKIPE	TCHR		;OR END OF PARAGRAPH
	 JRST	JSUBM		;DON'T BOTHER
	HRLZS	T2		;Prepare for fractional arithmetic...
	IDIV	T2,WCNT		;= (#Blanks/Word)^18
	MOVEM	T2,BPW
	ADDI	T2,400400	;Round up
	HLRZM	T2,REM		;Save integer-portion.
	MOVEI	T2,1
	MOVEM	T2,WCNT		;Prepare word-count for justifying...
JSUBM:	SETZM	T2
			;MOVE LINE, INSERTING BLANKS
JSUBM1:	ADD	T2,INDNT	;DO INDENTATION
JSUBM3:	SOJL	T2,JSUBM2	;QUIT IF NONE
	IDPB	T1,ALTP		;ELSE DEPOSIT
	SOJGE	T2,.-1		;AND TRY AGAIN
JSUBM2:	CAMN	T4,T5		;WAS IT THE LAST?
	 JRST	NLOUT		;  YES, PUT OUT NEW LINE.
	ILDB	T1,T4		;GET ANOTHER CHARACTER
	IDPB	T1,ALTP		;DEPOSIT IT
	SKIPN	TCHR		;AT END OF PARAGRAPH WE DO NOT LOOK FOR BANKS
	TRNN	JF,JFILL	;ARE WE LOOKING FOR BLANKS?
	 JRST	JSUBM2		;  NO, MOVE ANOTHER.
	CAIE	T1," "		;  YES, IS IT A BLANK?
	 JRST	JSUBBN		;    NO.
	TROE	JF,JBLF		;YES, DID WE JUST SEE ONE?
	 JRST	JSUBM2		;      YES, MOVE ANOTHER.
	AOS	T3,WCNT		;Bump word-count.
	IMUL	T3,BPW		;How many should we have?
	ADDI	T3,400400	;Round up.
	HLRZ	T2,T3		;Integer-part to T2.
	SUB	T2,REM		;  - # we have already done...
	HLRZM	T3,REM		;Save new integer-part.
	JRST	JSUBM3		;Put in T2 more spaces.

JSUBBN:	TRZ	JF,JBLF	;NOT A BLANK
	JRST	JSUBM2		;GET ANOTHER

;DOFINC - DO FIRST INCREMENT -  SIMILAR TO ONSET in COPY

DOFINC:	SKIPG	T3,NLIN2		;Were there any?
	NERROR	NLN			;no.  lose now.
	MOVE	T2,DESTLN		;his desired place
	MOVEM	T2,SVLNUM		;as good as any if there's error
	PUSHJ	P,GETDIF		;compute new increment
	JRST	DOFIN1			;order error
	MOVEM	T1,SVLNUM
	MOVEM	T1,CLN
	CAML	T2,FINCR
	POPJ	p,
	MOVEM	T2,FINCR		;tell him he blew it
DOFIN0:	MOVEM	T2,PRNTO1
	OUTSTR	ASCZ1
	POPJ	P,

DOFIN1:	MOVE	T2,[ASCII /ORDER/]
	JRST	DOFIN0

;MISCELLANEOUS SUBROUTINES USED ONLY BY THE JUSTIFY CODE

SCANUM:	CALL	SCAN
	TRNE	FL,NUMF		;NUMBER SEEN?
	CAMN	T1,[<ASCII/00000/>!1]
	NERROR	ILC
	CAILE	T2,0
	CAILE	T2,^D99999
	NERROR	ILC
	RET


INSEDX:	MOVEI	T1,2		;COUNT IS 2
	MOVEM	T1,OCNT
	SETZM	NCNT		;AND NEW IS 0
	JRST	INSED


INSEDP:	MOVE	T1,PGMK		;PUT A PAGE MARK IN LIBUF
	MOVEM	T1,LIBUF
	MOVE	T1,PGMKW2	;TEXT OF A PAGE MARK
	MOVEM	T1,LIBUF+1
	SETZM	OCNT		;THIS IS A STRAIGHT INSEET
	MOVEI	T1,2		;OF 2 WORDS
	MOVEM	T1,NCNT
	JRST	INSED

>; IFN STANSW


SUBTTL	INDIRECT COMMAND

;INPUT ROUTINE FOR COMMAND FILE

RDCHAR:	PUSH	P,T1		;SAVE REGS
	PUSH	P,T2
RDCHR1:	MOVE	T1,INDJFN	;GET INPUT JFN
	BIN			;READ CHAR
	JUMPE	T2,INDEOF	;CHECK EOF
	MOVE	C,T2		;CHAR TO C
	JRST	POPRET		;COMMON EXIT

INDEOF:	GTSTS			;GET FILE STATUS
	TLNN	T2,(GS%EOF)	;REAL EOF?
	JRST	RDCHR1		;NO - SKIP NULLS
	MOVE	T1,SVCCIN	;RESTORE INPUT ROUTINE
	MOVEM	T1,CHIN
	TRZ	FL2,COMFLF	;NO LONGER INDIRECT
	MOVE	T1,INDJFN	;RELEASE WORLD
	CLOSF
	  FJERR
	NERROR	CMEND		;DONE

;HANDLE @ COMMAND - READ COMMANDS FROM FILE

IFN STANSW, <
	HLPMSG <@ Command	(take commands from a file)
 
@<filespec>
>
>; IFN STANSW
COMFIL:	TRNE	FL2,COMFLF	;TRYING TO NEST?
	NERROR  ILC
	CALL	GNCH		;PEEK AT NEXT CHAR
	CAIN	C,200		;AOK IF ESC
	JRST	COMFL1		;...
	AOS	TTICNT		;NO - BACK UP PNTRS
	MOVE	T1,TTIPNT
	ADD	T1,[7B5]
	MOVEM	T1,TTIPNT
COMFL1:	MOVSI	T1,(GJ%OLD!GJ%CFM) ;EXISTING FILE ONLY
	MOVEI	ALTP,INDBLK	;POINT TO BLOCK
	HRROI	T2,[ASCIZ "CMD"] ;DEFAULT EXTN
	CALL	READNE		;FILL IT
	  JRST	COMND		;ERROR
	  JRST	COMND		;^U RETURN
	CALL	CKTERM		;GRNTEE EOL
	 NERROR	ILC
	MOVE	T1,INDJFN	;USE JFN
	MOVE	T2,[7B5+OF%RD]	;OPEN FOR INPUT
	OPENF
	  JERROR		;JSYS LOSAGE
	MOVE	T1,[ASCII /00000/]	;SET UP CMD COUNT
	MOVEM	T1,COMCNT
	TRO	FL2,COMFLF
	MOVEI	T1,RDCHAR	;SET UP INPUT ROUTINE
	EXCH	T1,CHIN		;AND SAVE CURRENT
	MOVEM	T1,SVCCIN
	JRST	COMND


SUBTTL	DISPLAY TERMINAL INFO

;CURSOR UP FUNCTION

CURUP:
	REPEAT 5,<			;NON-DPY
	JFCL
>
	OUTSTR [BYTE (7)"Z"-100]	;DATAMEDIA
	OUTSTR [BYTE (7)33,"A"]		;HP26
;
;COULD NOT MAKE THE HAZ AND TOPS-20 COOPERATE WITH SENDING THE TILDE-FF
;TO THE TTY.  SUBSITUTING A JFCL INSTEAD - KSL.
;	OUTSTR [BYTE (7)176,14]		;HAZELTINE
;
	JFCL				;HAZELTINE 1500
	JFCL				;8
	JFCL				;9
	OUTSTR [BYTE (7)32,177,177,177] ;VT05
	OUTSTR [BYTE (7)33,"A"]		;VT50
	JFCL				;LA30
	OUTSTR [BYTE (7)32,177,177,177]	;GT40 (VT05)
	JFCL				;LA36
	OUTSTR [BYTE (7)33,"A"]		;VT52
IFE STANSW,<
	JFCL				;M43
	OUTSTR [BYTE (7) 30 ]		;TAC
	OUTSTR [BYTE (7) 4 ]		;NEW HAZELTINE
>; IFE STANSW
IFN STANSW,<
	OUTSTR [BYTE (7)33,"[","A"]	;VT100
	JFCL				;LA38
	JFCL				;LA120
>; IFN STANSW
	JFCL
	JFCL
IFE STANSW,<
	JFCL
>; IFE STANSW
IFN STANSW,<
	OUTSTR [BYTE (7)"D"-100]	;GILLOTINE
>; IFN STANSW
	OUTSTR [BYTE (7)33,"A"]		;TELERAY
IFN STANSW,<
	OUTSTR [BYTE (7)34,"U","P",";"]	;TEKTRONIX 4025
	OUTSTR [BYTE (7)"N"-100]	;ANN ARBOR
	OUTSTR [BYTE (7)33,"A"]		;HEATH 19
	OUTSTR [BYTE (7)33,";"]		;CONCEPT 100
	OUTSTR [BYTE (7)33,"A"]		;IBM 3101
	OUTSTR [BYTE (7)"K"-100]	;TELEVIDEO 912
	JFCL				;TEKTRONIX 4023
	OUTSTR [BYTE (7)"_"-100]	;DATAMEDIA 1520
	OUTSTR [BYTE (7)33,"[","A"]	;AMBASSADOR
>; IFN STANSW

;CRLF IF NOT A DPY

CRLF:	REPEAT 4,<
	OCRLF
  >
	JFCL				;ADM3
	JFCL				;DATAMEDIA
	JFCL				;HP2645A
	JFCL				;HAZELTINE
	OCRLF
	OCRLF
	JFCL				;VT05
	JFCL				;VT50
	OCRLF				;LA30
	JFCL				;GT40
	OCRLF				;LA36
	JFCL				;VT52
IFE STANSW,<
	OCRLF				;M43
	JFCL				;TAC
	JFCL				;NEW HAZELTINE
>; IFE STANSW
IFN STANSW,<
	JFCL				;VT100
	OCRLF				;LA38
	OCRLF				;LA120
>; IFN STANSW
	JFCL
	JFCL
	JFCL
	JFCL
	JFCL				;TELERAY
IFN STANSW,<
	REPEAT 6,<
	JFCL
>
	OCRLF				;TEK4023
	REPEAT 2,<
	JFCL
>
>; IFN STANSW

;LINE-FEED IF NOT A DPY

LFD:	REPEAT 4,<
	12
  >
	0				;ADM3
	0				;DATAMEDIA
	0				;HP2645A
	0				;HAZELTINE
	12
	12
	0				;VT05
	0				;VT50
	12				;LA30
	0				;GT40
	12				;LA36
	0				;VT52
IFE STANSW,<
	12				;MODEL 43
	0				;TAC
	0				;NEW HAZELTINE
>; IFE STANSW
IFN STANSW,<
	0				;VT100
	12				;LA38
	12				;LA120
>; IFN STANSW
	12
	12
IFE STANSW,<
	12
>; IFE STANSW
IFN STANSW,<
	0				;GILLOTINE
>; IFN STANSW
	0				;TELERAY
IFN STANSW,<
	REPEAT 6,<
	0
>
	12				;TEKTRONIX 4023
	REPEAT 2,<
	0
>
>; IFN STANSW
 
;TERMINAL TYPE NAME TABLE

TTYPE:	[ASCIZ "M33"]
	[ASCIZ "M35"]
	[ASCIZ "M37"]
	[ASCIZ "TI"]
	[ASCIZ "ADM3"]
IFE STANSW,<
	[ASCIZ "Datamedia"]
>; IFE STANSW
IFN STANSW,<
	[ASCIZ "Datamedia-2500"]
>; IFN STANSW
	[ASCIZ "HP2645a"]
	[ASCIZ "Hazeltine 1500"]
	[ASCIZ "DEFAULT"]
	[ASCIZ "IDEAL"]
	[ASCIZ "VT05"]
	[ASCIZ "VT50"]
	[ASCIZ "LA30"]
	[ASCIZ "GT40"]
	[ASCIZ "LA36"]
	[ASCIZ "VT52"]
IFE STANSW,<
	[ASCIZ "M43"]
	[ASCIZ "TAC"]
	[ASCIZ "NH1500"]
	[ASCIZ "DEFAULT"]
>; IFE STANSW
IFN STANSW,<
	[ASCIZ "VT100"]
	[ASCIZ "LA38"]
	[ASCIZ "LA120"]
	[ASCIZ "M43"]
>; IFN STANSW
	[ASCIZ "DEFAULT"]
IFE STANSW,<
	[ASCIZ "DEFAULT"]
>; IFE STANSW
IFN STANSW,<
	[ASCIZ "Gillotine"]
>; IFN STANSW
	[ASCIZ "Teleray"]
IFN STANSW,<
	[ASCIZ "Tektronix-4025"]
	[ASCIZ "Ann-Arbor"]
	[ASCIZ "Heath-19"]
	[ASCIZ "Concept-100"]
	[ASCIZ "IBM-3101"]
	[ASCIZ "Televideo-912"]
	[ASCIZ "Tektronix-4023"]
	[ASCIZ "Datamedia-1520"]
	[ASCIZ "Ambassador"]
>; IFN STANSW
MXTRM=.-TTYPE-1				;MAX TERMINAL TYPE
DFTRM=10				;DEFAULT

SUBTTL	LITERALS

XLIST
LIT		;CLEAR ALL LITERALS
LIST

SUBTTL	IMPURE AREA

;IMPURE SECTION IS DIVIDED INTO TWO AREAS
;1) DATA WHICH IS SEMI CONSTANT
;2) DATA WHICH IS INITIALLY ZEROED

DATAB:

IFE STANSW, <
TEXTIB:	EXP	6		;LENGTH OF BLOCK
	RD%TOP!RD%JFN		;FLAGS
	.PRIIN,,.PRIOU		;INPUT,,OUTPUT
	-1,,TTIBUF		;BUFFER PNTR
	5*20			;CHAR COUNT
	-1,,TTIBUF		;TOP OF BUFFER
	-1,,CRBUF		;CONTROL-R BUFFER
>; IFE STANSW

IFN STANSW, <
TEXTIB:	EXP	7		;LENGTH OF BLOCK
	RD%TOP!RD%JFN		;FLAGS
	.PRIIN,,.PRIOU		;INPUT,,OUTPUT
	-1,,TTIBUF		;BUFFER PNTR
	5*20			;CHAR COUNT
	-1,,TTIBUF		;TOP OF BUFFER
	-1,,CRBUF		;CONTROL-R BUFFER
	[ 1B10+1B13+1B27	;BREAK CHARS ARE LF,CR, AND ESC
		0		;NO OTHER BREAK CHARS...
		0 
		0	]	;...
>; IFN STANSW


CJFNBK:	Z			;BLOCK FOR GTJFN
	.PRIIN,,.PRIOU		;JFNS
	Z			;DEVICE
	Z			;DIRECTORY
	Z			;NAME
	Z			;EXTENSION
	Z			;PROTECTION
	Z			;ACCOUNT
	Z			;DESIRED JFN
	G1%RBF!G1%RND+4		;FLAGS,,LEN
	Z			;COPY BUFFER PNTR
	Z			;COPY BUFFER COUNT
	-1,,CRBUF		;^R BUFFER
	-1,,TTIBUF		;TOP OF BUFFER

IFN EXTEND,<
LSBUFN: 	LSNUM
LSPTR:
	I==0
REPEAT LSNUM,< POINT 7,LSBUF+<SRBLG/5+2>*I
	I==I+1
>
LSPTT:
	I==0
REPEAT LSNUM,< EXP LSPNT+SRNUM*I
	I==I+1
>
>; IFN EXTEND
PGMK:	<ASCII /     />!1
PGMKW2:	BYTE (7)15,14,0,0,0
SQBUF:	BLOCK 1
	ASCII /	/

ASCZ1: ASCII /INC1=/
PRNTO1: EXP	0
	ASCIZ /
/
ASCIZ2: ASCII /Inc2=/
PRNTO2: EXP	0
	ASCIZ /
/

;STUFF FOR JUSTIFICATION

PAGESZ:	EXP	PGSZ
PLINES:		20	;DEFAULT VALUE FOR P CMD
ESC:		33	;DEFAULT ESCAPE CHAR
COMESS: ASCII /COMMAND # /
COMCNT:  EXP	0
	BYTE (7) 15,12
LINOUT:  EXP	0
	  ASCIZ ./.

;CONTROL BLOCK FOR CNTRL C TRAPPING

CNCLOK:	-1		;INTERLOCK FOR RE-ENTRANT HANDLING

;PSI TABLES

RETSAV:	0		;INTERRUPT PC

LEVTAB:	0,,RETSAV	;PSI-LEVEL TABLE
	0
	0

CHNTAB:	BLOCK 3		;0 TO 2
TRPCHN==.-CHNTAB
	1,,TRAP		;CTRL-C HAS OWN CHANNEL
	BLOCK 5		;4 TO 8
	1,,PDLTRP	;9-PDL OVERFLOW
	BLOCK 2		;10 - 11
	1,,DSKTRP	;12 - QUOTA EXCEEDED
	BLOCK 7		;13 - 19
	1,,DSKTRP	;20-MACHINE SIZE EXCEEDED (QUOTA ALSO)
	BLOCK	^D15	;21 TO 35

ONCHAN:	1B<TRPCHN>+1B<.ICPOV>+1B<.ICQTA>+1B<.ICMSE> ;CHANNELS TO BE ACTIVATED

;MACRO TO GENERATE FILE-SPEC BLOCKS

JFN==0		;JFN ASSIGNED TO THIS SPEC
FIL==1		;POINTER TO FILESPEC
COD==2		;ENCRYPTION PSW
ASZ==3		;ASCIZ STRING FOR FILESPEC

	DEFINE FILDES (F) <
	IRP F,<
F'BLK==.
F'JFN:	BLOCK	1
F'FIL:	BLOCK	1
F'COD:	BLOCK	1
F'ASZ:	BLOCK	FILSIZ
F'BKE==.-1>>

;REST IS RANDOM VARIABLES AND BUFFERS

IFN STANSW, <
QUITF:	0	;-1 IF WE REVERTED FILE, MEANING OLD CREATF STILL HOLDS --OO7

SOSO:	0	;-1 IF HAVE A NEUTRAL FNAME TO EDIT

;FOR JUSTIFY COMMANDS
LMAR:	1
PMAR:	1
RMAR:	105
MAXLN:	<ASCII /99999/>!1
JUSTLM:	BLOCK 1
JUSTPM:	BLOCK 1
JUSTRM:	BLOCK 1
WTBL:	0,,WTBL1
WTBL1:	0,,1

;VARIABLES FOR JUSTIFY STUFF
INDNT:	BLOCK	1
OCNT1:	BLOCK	1
LWRD:	BLOCK	1
BPW:	BLOCK	1
ELIN:	BLOCK	1
WCNT:	BLOCK	1
LINL:	BLOCK	1
WRDL:	BLOCK	1
REM:	BLOCK	1
TPNT:	BLOCK	1
BLIN:	BLOCK	1
OPTR:	BLOCK	1
TCHR:	BLOCK	1

>; IFN STANSW

ZEROB==.
PNOARG:	BLOCK	1	;(195) 0=LAST CMND NOT P W/ NO ARGS
			;(195) NOT 0= WAS P/W NO ARGS
BAKF:	BLOCK	1	;0 := NOBACKUP , -1 := BAK , +1 := OLD
CREATF:	BLOCK	1
SVWD:	BLOCK	1
SVWD2:	BLOCK	1
SVWD3:	BLOCK	1
SVSEQN:	BLOCK	1		;SAVED SEQUENCE NUMBER FOR ORDCHK
TMPT1:	BLOCK	1
MODW:	BLOCK	1	;PLACE TO SAVE TERMINAL MODE WORD (RFMOD)
COCW1:	BLOCK	1	;PLACE TO SAVE RFCOC WORDS
COCW2:	BLOCK	1	;...
UNSEQF:	BLOCK	1
RPGSW:	BLOCK	1
PZBEG==.
IFN CRYPSW, <
CODBUF: BLOCK	10 >
FILDES <ORG,NEW,ICR,OCR,IND,ALT>

PZEND==.-1
FILDES <RUN>

ORGPRT:	BLOCK	1		;PROTECTION OF ORIGINAL FILE
GJBITS:	BLOCK	1	;BITS FOR GTJFN OF INPUT FILE
OPNJFN:	BLOCK	1	;SAVED JFN FOR OPENF RECOVERY
LPTJFN:	BLOCK	1		;JFN FOR L COMMAND
OPTJFN:	BLOCK	1		;JFN FOR OPTION FILE
NOCTLC:	BLOCK	1		;CTRL-C ON/OFF FLAG
ERCOD:	BLOCK	1	;LAST JSYS LOSAGE
DTYPE:	BLOCK	1	;TERMINAL TYPE CODE
BUFP:	BLOCK	1	;POINTER TO CURRENT LOC IN EDIT BUFFER
SSW:	BLOCK	1
RSW:	BLOCK	1
CORTOP:	BLOCK	1
FILPT:	BLOCK	1
MAXWC:	BLOCK	1	;MAX FULL POINT IN EDIT BUFFER
HLFWC:	BLOCK	1	;HALF FULL POINT IN EDIT BUFFER
CLN:	BLOCK	1	;CURRENT LINE
INCR:	BLOCK	1
ISVINC:	BLOCK	1	;SAVED TEMPORARY INCR. FOR INSERT
CURINS:	BLOCK	1
CPG:	BLOCK	1	;CURRENT PAGE
CPGL:	BLOCK	1	;LOGICAL CURRENT PAGE "/."
IPG:	BLOCK	1	;INSERT PAGE
INPG:	BLOCK	1	;CURRENT INPUT PAGE SEEN
OPG:	BLOCK	1	;COUNT OF PAGES OUTPUT
WC:	BLOCK	1	;WORD COUNT IN EDIT BUFFER
OLDLIN:	BLOCK	1
SSAVEN:	BLOCK	1
SAVEN:	BLOCK	1
SISAVN:	BLOCK	1
ISAVEN:	BLOCK	1
ALTSN:	BLOCK	1	;ALTMODE SEEN FLAG (I&R)
ALTINC:	BLOCK	1	;ALTER MODE I CMD INCR
ALTFLG:	BLOCK	1
CASEBT:	BLOCK	1
BGPG:	BLOCK	1
ACCUM:	BLOCK	1
SVERN:	BLOCK	1
SAVCHR:	BLOCK	1
TECINC:	BLOCK	1
TECFST:	BLOCK	1
TEMINC:	BLOCK	1
REINC:	BLOCK	1
INCST:	BLOCK	1
REFST:	BLOCK	1
ALTCNT:	BLOCK	1
LOGPG:	BLOCK	1
LSTCNT:	BLOCK	1
SVCCNT:	BLOCK	1
SAVC:	BLOCK	1
IFN EXTEND,<
LSHIPG:	BLOCK	1
LSHILN:	BLOCK	1
LSCNT:	BLOCK	1
LSPG:	BLOCK	1
LSBUF:	BLOCK	<SRBLG/5+2>*LSNUM
LSPNT:	BLOCK	SRNUM*LSNUM
>; IFN EXTEND
LIMBO:	BLOCK	1	;LIMBO CHAR AFTER BELL
CHIN:	BLOCK	1	;INPUT PNTR
SVCCIN:	BLOCK	1	;SAVED INPUT ROUTINE FOR @ CMDS
SVPCIN:	BLOCK	1	;SAVED INPUT ROUTINE FOR PARSE
TTOBUF:	BLOCK	^D200/5+1
TTOCNT:	BLOCK	1	;OUTPUT CNTR
TTOPNT:	BLOCK	1	;OUTPUT PNTR
TTICNT:	BLOCK	1	;INPUT CNTR
TTIPNT:	BLOCK	1	;INPUT PNTR
IFN STANSW, <
CRBUF:	BLOCK	1000	;CONTROL-R BUFFER  -- OO7
ESCFLG:	BLOCK	1	;INDICATES ESC HAS BEEN TYPED ON THIS COMMAND LINE
>; IFN STANSW
IFE STANSW, <
CRBUF:	BLOCK	2	;CONTROL-R BUFFER
>; IFE STANSW
FSFLG:	BLOCK	1	;PROMPT INFO/FLAG FOR F & S COMMANDS

AIPB:			;ALT INPUT BLOCK
AIPJFN:	BLOCK	1	;JFN
AIPCNT:	BLOCK	1
AIPBYT:	BLOCK	1
AIPTXT:	BLOCK	1
AIPPNT:	BLOCK	1
AIPFSZ:	BLOCK	1
AIPBUF:	BLOCK	1

CIPB:
CIPJFN:	BLOCK	1
CIPCNT:	BLOCK	1
CIPBYT:	BLOCK	1
CIPTXT:	BLOCK	1
CIPPNT:	BLOCK	1
CIPFSZ:	BLOCK	1
CIPBUF:	BLOCK	1

IJFN==0
CNT==1
BYT==2
TXT==3
PNT==4
FSZ==5
BUF==6

OUPNT:	BLOCK	1	;OUTPUT BUFFER PNTR
OPCNT:	BLOCK	1	;OUTPUT PAGE # CNTR
AUXFLG:	BLOCK	1
PDL:	BLOCK	PDLSIZ+1	;PUSHDOWN LIST
P.TEXT: BLOCK	1
NPAGS:	BLOCK	1		;EDIT WINDOW SIZE
DEVSTR:	BLOCK	20		;BUFFER FOR OUTPUT DEV:<STR>
DEVST2:	BLOCK   20		;(197)
SAMDEV:	BLOCK	1		;(197)
TEMPS:	BLOCK	2		;VERY TEMPORARY STORAGE
CMDBUF==LIBUF			;COMMAND BUFFER
CRSX==LIBUF+777		;PLACE FOR CR'S
SVPT:	BLOCK	1
CODEBF:	BLOCK	4*SRNUM+2
BUFSAV:	BLOCK	1
ARBCNT:	BLOCK	1
SRHIPG: BLOCK	1
SRHILN: BLOCK	1
SRCNT:	BLOCK	1
SRBUF:	BLOCK	SRBLG/5+2
SRPG:	BLOCK	1
SRPNT:	BLOCK	SRNUM
BOTLIN:	BLOCK	1
PGDELS:	BLOCK	1
STARTD:	BLOCK	1	;WHERE TO START TO DELETE ON TRANSFER
ENDD:	BLOCK	1	;WHERE TO END DELETING ON TRANSFER
TRANST:	BLOCK	1
PGINSD:	BLOCK	1
DESTLN:	BLOCK	1
DESTPG:	BLOCK	1
FINCR:	BLOCK	1
SINCR:	BLOCK	1
SVLNUM:	BLOCK	1
LSTPG:	BLOCK	1
COPDL:	BLOCK	1
HIGH1:	BLOCK	1
NLIN1:	BLOCK	1	;# OF LINES ON FIRST PAGE OF C/T
NLIN2:	BLOCK	1	;# OF LINES ON LAST PAGE OF C/T
START2:	BLOCK	1	;STARTING LINE # FOR LAST PG OF C/T
LSTLN:	BLOCK	1	;LAST LINE # SEEN DURING C/T
PARCNT:	BLOCK	1
RPPG:	BLOCK	1
RPCNT:	BLOCK	1
FNDFLG:	BLOCK	1
R1BUF:	BLOCK	SRBLG/5+2
R2BUF:	BLOCK	SRBLG/5+2
RPHILN:	BLOCK	1
RPHIPG:	BLOCK	1
R1PNT:	BLOCK	SRNUM
R2PNT:	BLOCK	SRNUM
CCNT:	BLOCK	1
RSTRCT:	BLOCK	1
SVOCIN:	BLOCK	1
OPTION:	BLOCK	1
SVALTP:	BLOCK	1
DPG:	BLOCK	1
SVINC:	BLOCK	1
SVCNT:	BLOCK	1
OCNT:	BLOCK	1	;OLD WC FOR INSED
NCNT:	BLOCK	1	;NEW WC FOR INSED
SRCALP:	BLOCK	1
VAR		;IF ANY (I HOPE THIS WORKS)
ZEROE==.-1
HILN:	BLOCK	1	;RESULTS OF RANGE PARSE
HIPG:	BLOCK	1	; <LOLN>/<LOPG>:<HILN>/<HIPG>
LOLN:	BLOCK	1
LOPG:	BLOCK	1
IFN STANSW,<
LOCOL:	BLOCK	1	;RESULTS OF COLUMN RANGE PARSE
HICOL:	BLOCK	1	; #<LOCOL>:<HICOL>
>; IFN STANSW
ECFLG:	BLOCK	1	;(194) ECHO FLAG
EPAT::
IMPEND:


	END	3,,EV		;POINT TO ENTRY VECTOR
