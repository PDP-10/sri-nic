

; TCPJFN.MAC.1 & <BBN-MONITOR>TCPJFN.MAC.1 20-Aug-87 0007	PAGE 1



LINE 1, PAGE 1
1)	;SRC:<6.1.MONITOR.STANFORD>TCPJFN.MAC.17,  5-Nov-86 13:33:21, Edit by BILLW
1)	; Make sure we pick a local host address on an UP interface... (NTNCTS)
1)	; better buffer managment at TCSQI5
1)	;PS:<6-1-MONITOR>TCPJFN.MAC.15, 13-Feb-86 01:28:12, Edit by BILLW
1)	; make TCPBSZ slightly bigger
1)	;PS:<6-1-MONITOR>TCPJFN.MAC.13, 22-Nov-85 01:00:43, Edit by BILLW
1)	; Bob Knight's ILMNRF bugfix
1)	;<6-1-MONITOR.FT6>TCPJFN.MAC.6, 27-Aug-85 10:39:41, Edit by WHP4
1)	;Stanford changes
1)	; MRC's fix for DTCSPC to allow urgent signals to work (better)
1)	; use GTHST% in HSTPRT lookup
1)	; Schilit's fix to HSTNLK
1)	; Release prototype TCB in TCPOP5.
1)	; Fix to TCPSQI to prevent ILLUUO's
1)	;
1)	; UPD ID= 2196, SNARK:<6.1.MONITOR>TCPJFN.MAC.10,   5-Jun-85 11:21:04 by MCCOLLUM
1)	;TCO 6.1.1406  - Update copyright notice.
1)	; UPD ID= 1705, SNARK:<6.1.MONITOR>TCPJFN.MAC.9,  31-Mar-85 13:16:59 by PAETZOLD
1)	;TCO 6.1.1301 - Fix ;local-host and ;foreign-host by fixing HSTHST.
1)	; UPD ID= 1420, SNARK:<6.1.MONITOR>TCPJFN.MAC.8,  29-Jan-85 11:37:57 by PAETZOLD
1)	;TCO 6.1.1161 - Do not leave JFN locked in a few places.
1)	; UPD ID= 1254, SNARK:<6.1.MONITOR>TCPJFN.MAC.7,   1-Jan-85 16:48:51 by PAETZOLD
1)	;Fix major case of EBD where not using index register when playing with TCDPU 
1)	;and TCDUR in some cases.
1)	; UPD ID= 1085, SNARK:<6.1.MONITOR>TCPJFN.MAC.6,  16-Nov-84 16:27:01 by PAETZOLD
1)	;More TCO 6.1041 - Make the GTOKM conditional
1)	; UPD ID= 1042, SNARK:<6.1.MONITOR>TCPJFN.MAC.5,  12-Nov-84 15:26:48 by PAETZOLD
1)	;TCO 6.1041 - Move ARPANET to XCDSEC
1)	; UPD ID= 290, SNARK:<TCPIP.5.4.MONITOR>TCPJFN.MAC.10,  24-Sep-84 13:55:47 by PURRETTA
1)	;Update copyright notice.
1)	; UPD ID= 275, SNARK:<TCPIP.5.4.MONITOR>TCPJFN.MAC.9,   7-Sep-84 17:34:25 by PAETZOLD
1)	;Zero FILTCB after ABORT%s.
1)	;Make TCPNAM and TCPEXT use one error return.
1)	;Fix range check for type of service atttribute value.
1)	; UPD ID= 270, SNARK:<TCPIP.5.4.MONITOR>TCPJFN.MAC.8,   5-Sep-84 16:14:37 by PAETZOLD
1)	;Use correct index register in dispatch in IPOPAP.
1)	; UPD ID= 235, SNARK:<TCPIP.5.4.MONITOR>TCPJFN.MAC.7,  16-Aug-84 11:09:52 by PAETZOLD
1)	;Use RETBAD instead of RETERR for TCPX35 in TCPOPN.  
1)	;Be NOINT during IPOPR% functions.
1)	; UPD ID= 228, SNARK:<TCPIP.5.4.MONITOR>TCPJFN.MAC.6,   7-Aug-84 22:28:05 by PAETZOLD
1)	;TCO 6.2164 - Use an index register when setting timeouts in ATTTIM
1)	; UPD ID= 187, SNARK:<TCPIP.5.4.MONITOR>TCPJFN.MAC.5,  16-Jun-84 15:40:10 by PAETZOLD
1)	;Conditional for non release 6 based monitors.
1)	;Easier to put an EA.ENT in TCPOTS than to fix all ENTSKDers for section one 
1)	; UPD ID= 179, SNARK:<TCPIP.5.4.MONITOR>TCPJFN.MAC.4,  10-Jun-84 15:28:02 by PAETZOLD
1)	;Make NI IPOPRs give TCPX44 error if no NI code.
1)	; UPD ID= 108, SNARK:<TCPIP.5.4.MONITOR>TCPJFN.MAC.3,  12-May-84 18:11:06 by PAETZOLD
1)	;fix typo

; TCPJFN.MAC.1 & <BBN-MONITOR>TCPJFN.MAC.1 20-Aug-87 0007	PAGE 2


1)	; UPD ID= 106, SNARK:<TCPIP.5.4.MONITOR>TCPJFN.MAC.2,  12-May-84 17:46:56 by PAETZOLD
1)	;Add code for NI IPOPRs.
1)	; UPD ID= 3940, SNARK:<6.MONITOR>TCPJFN.MAC.13,  18-Mar-84 13:09:49 by PAETZOLD
1)	;More TCO 6.1733 - Fix bugs dealing with FX and TCPOTS and FKSTA2.
LINE 1, PAGE 1
2)	;[F.BBN.COM]REL5:<5-4-NET>TCPJFN.MAC.24, 28-Apr-87 16:12:55, Edit by RBASCH
2)	; Push out buffered bytes before closing, in TCPCLZ and DTCSFN
2)	;Merged CMU and BBN code
2)	;[F.BBN.COM]CWL:<5-4-NET>TCPJFN.MAC.29, 26-Nov-85 12:07:25, Edit by RBASCH
2)	; Fix ERTRAN to handle case where it's passed a positive BBN error code
2)	;<MONITOR.CMU>TCPJFN.MAC.4, 15-Nov-85 16:48:26, Edit by VAF
2)	;CS92 Fix SETCH1 macro definition.
2)	;<MONITOR.CMU>TCPJFN.MAC.3, 21-Aug-85 17:10:20, Edit by VAF
2)	;CS150 Add .IPLHL function - get local host list.
2)	;<MONITOR.CMU>TCPJFN.MAC.1, 13-Aug-85 08:38:58, Edit by VAF
2)	;Merge CMU changes into new BBN TCP version:
2)	; CS62	Use our version of ERTRAN - it works much better.
2)	; CS62	Don't do GETOK here - assume that OPEN% jsys will do it later.
2)	;------
2)	;Fix parsing bugs in ;persist, add ;flags: attribute
2)	;REL6 fix tcpset returns to be +2 & +3 for rel 5
2)	; UPD ID= 3940, SNARK:<6.MONITOR>TCPJFN.MAC.13,  18-Mar-84 13:09:49 by PAETZOLD
2)	
2)	;More TCO 6.1733 - Fix bugs dealing with FX and TCPOTS and FKSTA2.


LINE 66, PAGE 1
1)	;gets  set correctly. Clear TCDCW in TCPABT. Rearrange port privilege check to
1)	;OPENF from GTJFN. Implement TCPOTS scheduler test. Fix CZ%ABT hanging CLOSF%.
LINE 33, PAGE 1
2)	;gets  set correctly. Clear TCDCW in TCPABO. Rearrange port privilege check to
2)	;OPENF from GTJFN. Implement TCPOTS scheduler test. Fix CZ%ABT hanging CLOSF%.


LINE 75, PAGE 1
1)	;<TCPIP.5.3.MONITOR>TCPJFN.MAC.20,  7-Dec-83 00:31:32, Edit by PAETZOLD
LINE 42, PAGE 1
2)	;[BBNF]<TAPPAN.MERGE>TCPJFN.MAC.3, 26-Jan-84 12:02:28, Edit by: TAPPAN
2)	; Merge stanford changes, take out testing of HSTSTS since
2)	; it is no longer resident, and there is probably a better
2)	; way to get the same effect (eg. asynchronous signaling
2)	; of the TCP when the ICMP comes in)
2)	;<5-3-MONITOR>TCPJFN.MAC.51, 19-Jan-84 05:25:44, Edit by MRC
2)	; Re-think out edits 48-50:
2)	; Restore part of GTJFN% port test.  OPENF% port test is only for small ports
2)	;<5-3-MONITOR>TCPJFN.MAC.50, 18-Jan-84 17:13:46, Edit by MRC
2)	; Typo in previous edit
2)	;<5-3-MONITOR>TCPJFN.MAC.49, 18-Jan-84 17:06:47, Edit by MRC
2)	; Improved OPENF% test
2)	;<5-3-MONITOR>TCPJFN.MAC.48, 18-Jan-84 16:53:37, Edit by MRC
2)	; Remove port privilege check from GTJFN%, add to OPENF%.  Only validate

; TCPJFN.MAC.1 & <BBN-MONITOR>TCPJFN.MAC.1 20-Aug-87 0007	PAGE 3


2)	; port number if passive connection; active is alright
2)	;<5-3-MONITOR>TCPJFN.MAC.47, 14-Jan-84 06:38:06, Edit by MRC
2)	; Fix typo in TCPOTS HS%UP test
2)	;<5-3-MONITOR>TCPJFN.MAC.46, 14-Jan-84 03:06:36, Edit by MRC
2)	; Make sure FX set up in mainline call to TCPOTS
2)	;<5-3-MONITOR>TCPJFN.MAC.45, 13-Jan-84 14:14:48, Edit by MRC
2)	; Define FX
2)	;<5-3-MONITOR>TCPJFN.MAC.44, 13-Jan-84 13:22:39, Edit by MRC
2)	; Commentary for disgusting FRKHST kludge
2)	;<5-3-MONITOR>TCPJFN.MAC.43, 13-Jan-84 12:38:03, Edit by MRC
2)	; More edit 42: use disgusting FRKHST kludge until I think of a better way
2)	;<5-3-MONITOR>TCPJFN.MAC.42, 13-Jan-84 12:12:03, Edit by MRC
2)	; Remove TCPOPT, rewrite TCPOTS
2)	;<5-3-MONITOR>TCPJFN.MAC.41, 13-Jan-84 08:31:50, Edit by MRC
2)	; TCPOPT is required to run in section 1
2)	;<5-3-MONITOR>TCPJFN.MAC.40, 13-Jan-84 06:26:40, Edit by MRC
2)	; Minor bogons in edit 39
2)	;<5-3-MONITOR>TCPJFN.MAC.39, 13-Jan-84 05:42:05, Edit by MRC
2)	; Return OPNX20 immediately if network says host is down
2)	;<5-3-MONITOR>TCPJFN.MAC.38, 12-Jan-84 21:14:56, Edit by MRC
2)	; Fix improper fail return to user in ATNVT% code
2)	;<5-3-MONITOR>TCPJFN.MAC.37,  9-Jan-84 05:12:41, Edit by MRC
2)	; More free storage buffer tracing...
2)	;<5-3-MONITOR>TCPJFN.MAC.36,  9-Jan-84 00:17:20, Edit by MRC
2)	; Merge Kirk's read EOF patches
2)	;<5-3-MONITOR>TCPJFN.MAC.35,  8-Jan-84 23:33:34, Edit by MRC
2)	; Fix assembly error
2)	;<5-3-MONITOR>TCPJFN.MAC.34,  8-Jan-84 23:11:08, Edit by MRC
2)	; Routines to debug free storage loss problems
2)	;<5-3-MONITOR>TCPJFN.MAC.33,  6-Jan-84 19:40:35, Edit by MRC
2)	; Fix for hanging CZ%ABT CLOSF%
2)	;<5-3-MONITOR>TCPJFN.MAC.32,  6-Jan-84 07:03:44, Edit by MRC
2)	; More ATNVT%
2)	;<5-3-MONITOR>TCPJFN.MAC.31,  6-Jan-84 04:39:55, Edit by MRC
2)	; Save JFN in TVTJFN
2)	;<5-3-MONITOR>TCPJFN.MAC.30,  6-Jan-84 04:32:48, Edit by MRC
2)	; Unlock JFN on successful ATNVT%
2)	;<5-3-MONITOR>TCPJFN.MAC.29,  4-Jan-84 00:56:05, Edit by MRC
2)	; Fix up edit 27 - restore error code, clear TDEC in TCB not JCN!
2)	;<5-3-MONITOR>TCPJFN.MAC.28,  4-Jan-84 00:15:59, Edit by MRC
2)	; More of edit 25's changes
2)	;  Use .TCPBS instead of <.TCPBO-.TCPBF+1>
2)	;  Do SETZM of .TCPBI word as well as .TCPBO word
2)	;<5-3-MONITOR>TCPJFN.MAC.27,  3-Jan-84 23:51:08, Edit by MRC
2)	; Clear DEC bit for JCN in ATNVT% code so BBNCHK doesn't object to it
2)	;<5-3-MONITOR>TCPJFN.MAC.26,  3-Jan-84 21:35:36, Edit by MRC
2)	; Make sure JFN vanilla in ATNVT% code
2)	; Clear DEC buffers during OPENF% as well
2)	;<5-3-MONITOR>TCPJFN.MAC.25,  3-Jan-84 20:47:22, Edit by MRC
2)	; Fix bogus setting of IP parameters
2)	;<5-3-MONITOR>TCPJFN.MAC.24,  3-Jan-84 20:30:24, Edit by LOUGHEED

; TCPJFN.MAC.1 & <BBN-MONITOR>TCPJFN.MAC.1 20-Aug-87 0007	PAGE 4


2)	; TVTJFN routine to attach a TCP: JFN to a TVT
2)	;<5-3-MONITOR>TCPJFN.MAC.23,  3-Jan-84 00:36:41, Edit by MRC
2)	; Fix bad local port validation in HSTPR4
2)	;<5-3-MONITOR>TCPJFN.MAC.22, 29-Dec-83 19:00:40, Edit by MRC
2)	; Zero DEC TCB cells in TCPBFD so later users aren't confused
2)	;<5-3-MONITOR>TCPJFN.MAC.21, 14-Dec-83 23:16:03, Edit by MRC
2)	;Stanford changes:
2)	; .GOANA function sends foreign host and port info to ACJ
2)	; Disallow wildcards in GTJFN% (actual fix is to HSTPRT)
2)	;<TCPIP.5.3.MONITOR>TCPJFN.MAC.20,  7-Dec-83 00:31:32, Edit by PAETZOLD


LINE 3, PAGE 2
1)	;THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY  BE  USED
1)	;OR COPIED ONLY IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
1)	;
1)	;COPYRIGHT  (C)  DIGITAL  EQUIPMENT  CORPORATION  1976, 1985.
1)	;ALL RIGHTS RESERVED.
1)	
1)	
LINE 3, PAGE 2
2)	;THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY ONLY BE USED
2)	;  OR COPIED IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
2)	;
2)	;COPYRIGHT (C) 1982,1983,1984,
2)	;BY DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
2)	


LINE 16, PAGE 2
1)	TCP code developed by Bolt, Beranek, and  Newman.  
1)	
LINE 15, PAGE 2
2)	TCP code developed by Bolt, Beranek, and  Newman.
2)	


LINE 26, PAGE 2
1)		IFNDEF NOTYET,<NOTYET==0>
LINE 25, PAGE 2
2)		IFNDEF RFSP,<RFSP==1>
2)		IFNDEF NOTYET,<NOTYET==0>


; TCPJFN.MAC.1 & <BBN-MONITOR>TCPJFN.MAC.1 20-Aug-87 0007	PAGE 5



LINE 33, PAGE 2
1)		TCB=Q1			;not the same as TCB in other modules
1)		FX=Q3
1)	
LINE 33, PAGE 2
2)		TCB=Q1
2)		FX=Q3			;must agree with PROLOG, PAGEM, SCHED
2)	


LINE 39, PAGE 2
1)	IFN STANSW,<;;; Redfeine TCPBSZ so that a full packet will fit into
1)		;;;	The two buffers that are allocated.
1)		TCPBSZ== <<^D576/4>/2>+.TCPBS
1)	>;IFN STANSW
1)	
1)	
1)	^L	SUBTTL TCP Device DTB
1)	
1)		SWAPCD
1)	
LINE 39, PAGE 2
2)	
2)	^L	SUBTTL TCP Device DTB
2)	
2)		SWAPCD ;PS
2)	


LINE 10, PAGE 3
1)		DTBDSP TCPVER		;*Version lookup
1)		DTBBAD (DESX9)		; Protection insertion
LINE 10, PAGE 3
2)		DTBDSP TCPVRS		;*Version lookup
2)		DTBBAD (DESX9)		; Protection insertion


LINE 15, PAGE 3
1)		DTBDSP TCPQI		;*Byte input
1)		DTBDSP TCPQO		;*Byte output
1)		DTBDSP TCPCLZ		;*Close file
LINE 15, PAGE 3
2)		DTBDSP TCPSQI		;*Byte input
2)		DTBDSP TCPSQO		;*Byte output
2)		DTBDSP TCPCLZ		;*Close file


; TCPJFN.MAC.1 & <BBN-MONITOR>TCPJFN.MAC.1 20-Aug-87 0007	PAGE 6



LINE 28, PAGE 3
1)		DTBDSP TCPQF 		;*Force record out, (soutr jsys)
1)		DTBDSP RFTADN 		; Read file time and date
1)		DTBDSP SFTADN 		; Set file time and date
1)		DTBDSP TCPFI 		;*Set jfn for input
1)		DTBDSP TCPFO 		;*Set jfn for output
1)		DTBDSP TCPATR		;*Check attribute
LINE 28, PAGE 3
2)		DTBDSP TCPSQF 		;*Force record out, (soutr jsys)
2)		DTBDSP RFTADN 		; Read file time and date
2)		DTBDSP SFTADN 		; Set file time and date
2)		DTBDSP TCPSFI 		;*Set jfn for input
2)		DTBDSP TCPSFO 		;*Set jfn for output
2)		DTBDSP TCPATR		;*Check attribute


LINE 8, PAGE 4
1)	IFN REL6,<XSWAPCD>
1)	IFE REL6,<TCPSET:>
1)	IFN REL6,<XNENT TCPSET>
1)					;directory setup
1)		SKIPE DECOK		;DEC TCP calls allowed?
1)	         CALL SKTCPU		;TCP up?
1)		  RETBAD (TCPX16)	;no
1)		TQNE <STEPF,DIRSF,NAMSF,EXTSF,VERSF> ;any wildcards?
1)		RETBAD(GJFX17)		;yes...error
1)		NOINT			;stop psi's
LINE 8, PAGE 4
2)	TCPSET:				;directory setup
2)		MOVE CX,TCPSW		;Get TCP switches
2)		TXNE CX,DECOK		;DEC TCP calls allowed?
2)	         CALL SKTCPU		;TCP up? No is error
2)		  RETBAD (TCPX16,<IFE REL6,<AOS (P)>>)	;if release 5.1 then +2 return
2)		TQNE <STEPF,DIRSF,NAMSF,EXTSF,VERSF> ;any wildcards? yes...error
2)		  RETBAD(GJFX17,<IFE REL6,<AOS (P)>>)	;if release 5.1 then +2 return
2)		NOINT			;stop psi's


LINE 23, PAGE 4
1)		RETBAD (TCPXX1,<OKINT>)	;no so return with an error
1)		MOVEM T1,FILTCB(JFN)	;save the DCB address
1)		MOVE TCB,FILTCB(JFN)	;get the TCB AC set up for later use
1)		MOVX T2,TCBSIZ		;get the size again
1)		CALL CLRBLK		;clear out the TCB
1)		STOR JFN,TJFN,(TCB)	;tell the TCB which JFN it belongs too
1)		JRST TCP2RT		;tell upper level stuff we suceeded
LINE 21, PAGE 4
2)		 RETBAD (TCPXX1,<OKINT	;no so return with an error
2)				IFE REL6,<AOS (P)>>)

; TCPJFN.MAC.1 & <BBN-MONITOR>TCPJFN.MAC.1 20-Aug-87 0007	PAGE 7


2)		MOVEM T1,FILTCB(JFN)	;save the TCB address
2)		MOVE TCB,FILTCB(JFN)	;get the TCB AC set up for later use
2)		MOVX T2,TCBSIZ		;get the size again
2)		CALL CLRBLK		;clear out the TCB
2)		STOR JFN,TJFN,(TCB)	;tell the TCB to which JFN it belongs
2)		SETOM TCPIC(TCB)	; Set interrupt channel word to -1
2)		SETONE TCDFS,(TCB)	; Default to Forced Sync. (Active)
2)		MOVX CX,^D30		; Default to 30 second Persist
2)		STOR CX,TPRS1,(TCB)
2)		MOVX CX,^D5		; Default to 5 second Persist Interval
2)		STOR CX,TPRS2,(TCB)
2)		MOVX CX,^D<30*1000>	; Default to 30 second Timeout
2)		STOR CX,TSTO,(TCB)
2)		JRST TCP2RT		;tell upper level stuff we suceeded


LINE 3, PAGE 5
1)	IFE REL6,<TCPNAM:>
1)	IFN REL6,<XNENT TCPNAM>
1)					;decode gtjfn name string
1)		SKIPN TCB,FILTCB(JFN)	;get the TCB address
LINE 3, PAGE 5
2)	TCPNAM:				;decode gtjfn name string
2)		SKIPN TCB,FILTCB(JFN)	;get the TCB address


LINE 16, PAGE 5
1)		JE TLH,(TCB),OKRET	;default local host?
1)		LOAD T1,TLH,(TCB)	;get the local host
1)		CALL NTNCTS		;get out address on that net
1)		 RETBAD (TCPXX2)
1)		LOAD T2,TLH,(TCB)	;get the local host address
1)		CAME T2,T1		;legit address?
1)		 JRST TCPNM3		;no
1)	OKRET:				;here on success return
LINE 14, PAGE 5
2)		LOAD T1,TLH,(TCB)	;get the local host
2)		IFN. T1			;Is local host wild?
2)		  CALL LCLHST		;No, is it one of our addresses?
2)		    JRST TCPNM3		;no
2)		ENDIF.
2)	;cwl shouldn't label be on TQNE, as its used in TCPEXT and TCPVRS routines?
2)	OKRET:				;here on success return


; TCPJFN.MAC.1 & <BBN-MONITOR>TCPJFN.MAC.1 20-Aug-87 0007	PAGE 8



LINE 29, PAGE 5
1)	TCPNM3:				;here on error from HSTPRT
LINE 26, PAGE 5
2)	
2)	TCPNM3:				;here on error from HSTPRT


LINE 35, PAGE 5
1)	IFE REL6,<TCPVER:>
1)	IFN REL6,<XNENT TCPVER>
1)					;decode GTJFN version spec
1)		SKIPN T1		;any version stuff?
1)		 JRST OKRET		;no so return
1)		MOVEI T1,TCPXX4		;get error code
LINE 33, PAGE 5
2)	
2)	
2)	TCPVRS:				;decode GTJFN version spec
2)		TQNE <OUTPF>		;if output and
2)		 CAME T1,[-1]		; next highest generation, or
2)		  SKIPN T1		;any version stuff?
2)		   JRST OKRET		;no so return
2)		MOVEI T1,TCPXX4		;get error code


LINE 3, PAGE 6
1)	IFE REL6,<TCPEXT:>
1)	IFN REL6,<XNENT TCPEXT>
1)					;decode GTJFN extension string
1)		SKIPN TCB,FILTCB(JFN)	;get the TCB address
LINE 3, PAGE 6
2)	TCPEXT:				;decode GTJFN extension string
2)		SKIPN TCB,FILTCB(JFN)	;get the TCB address


LINE 17, PAGE 6
1)		JN TLH,(TCB),OKRET	;non default local host?
1)		LOAD T1,TFH,(TCB)	;get the foreign host address
1)		CALL NTNCTS		;get our address on the net
1)		 JRST TCPEX1		;we do not have one
1)		STOR T1,TLH,(TCB)	;save the new local host number
1)		STOR T1,TOPLH,(TCB)
1)		SETONE TCDGE,(TCB)	;flag so we do not do this again
1)		JRST OKRET		;everything is fine
1)	TCPEX1:				;here when we have no adr on that net
1)		MOVE T1,DEFADR		;get out default address
1)		STOR T1,TLH,(TCB)	;this is now our local address
1)		STOR T1,TOPLH,(TCB)
1)		SETONE TCDGE,(TCB)	;flag so we do not do this again

; TCPJFN.MAC.1 & <BBN-MONITOR>TCPJFN.MAC.1 20-Aug-87 0007	PAGE 9


1)		JRST OKRET		;and return to caller
1)	TCPEX2:				;here on error from hstprt
LINE 15, PAGE 6
2)		SETONE TCDGE,(TCB)	;flag so we do not do this again
2)		JRST OKRET		;everything is fine
2)	
2)	TCPEX2:				;here on error from hstprt


LINE 3, PAGE 7
1)	IFE REL6,<TCPATR:>
1)	IFN REL6,<XNENT TCPATR>
1)		 			;here to check attributes from gtjfn
1)		TRVAR <TCPATP>		;temporary storage
LINE 3, PAGE 7
2)	TCPATR: 			;here to check attributes from gtjfn
2)		TRVAR <TCPATP>		;temporary storage


LINE 34, PAGE 7
1)		ATRLEN==.-ATRTBL	;number of attributes
LINE 32, PAGE 7
2)		.PFFLG,,ATTFLG		;flags
2)		ATRLEN==.-ATRTBL	;number of attributes


LINE 10, PAGE 8
1)		   RETSKP		;legit value
1)	
LINE 10, PAGE 8
2)		RETSKP			;legit value
2)	


LINE 1, PAGE 9
1)	^L	SUBTTL GTJFN Connection Attribute
LINE 21, PAGE 8
2)	ATTR24:				;routine to read a legal twenty-four bit number
2)		MOVEI T3,10		;octal
2)		NIN%			;get the parameter
2)		 RET
2)		SKIPL T2		;positive?
2)		 CAMLE T2,[77777777]	;legit value?
2)		  RET			;non-legit value
2)		RETSKP			;legit value
2)	
2)	^L	SUBTTL GTJFN Connection Attribute


; TCPJFN.MAC.1 & <BBN-MONITOR>TCPJFN.MAC.1 20-Aug-87 0007	PAGE 10



LINE 7, PAGE 11
1)		STOR T2,TFH,(TCB)	;save the foreign host number
1)		STOR T2,TOPFH,(TCB)
1)		RETSKP			;return success
LINE 7, PAGE 10
2)		STOR T1,TFH,(TCB)	;save the foreign host number
2)		STOR T1,TOPFH,(TCB)
2)		RETSKP			;return success


LINE 14, PAGE 11
1)		RETBAD (TCPXX8)		;failure so get error code
1)		STOR T2,TLH,(TCB)	;save the local host number
1)		STOR T2,TOPLH,(TCB)
1)		MOVE T1,T2		;get host number into correct place
1)		CALL NTNCTS		;get our NCT on that net
1)		RETBAD (TCPXX8) 	;no address
1)		LOAD T2,TLH,(TCB)	;get the address user wants
1)		CAME T1,T2		;same?
1)		 RETBAD (TCPXX8)	;no
1)		RETSKP			;return success
LINE 14, PAGE 10
2)		 RETBAD (TCPXX8)	;failure so get error code
2)		STOR T1,TLH,(TCB)	;save the local host number
2)		STOR T1,TOPLH,(TCB)
2)		SKIPN T1		;have a host number
2)		IFSKP.			;it isn't wild so
2)		  CALL LCLHST		;is it one of our addresses?
2)		    RETBAD (TCPXX8)	;no
2)		ENDIF.
2)		RETSKP			;return success


LINE 31, PAGE 11
1)		ILDB T2,T1		;get the next byte
1)		CAIE T2,","		;is it a comma
LINE 30, PAGE 10
2)		LDB T2,T1		;get the break character
2)		CAIE T2,","		;is it a comma


; TCPJFN.MAC.1 & <BBN-MONITOR>TCPJFN.MAC.1 20-Aug-87 0007	PAGE 11



LINE 14, PAGE 12
1)					;TCPTCP does not know how to do this yet
1)		MOVE T1,TCPATP		;get the attribute pointer
LINE 14, PAGE 11
2)		MOVE T1,TCPATP		;get the attribute pointer


LINE 20, PAGE 12
1)		 CAILE T2,377		;legit value?
1)		  RETBAD (TCPX11)	;give error
LINE 19, PAGE 11
2)		 CAILE T2,377		;legit value?	
2)		  RETBAD (TCPX11)	;give error


LINE 30, PAGE 12
1)		RETSKP			;return success
LINE 29, PAGE 11
2)	;	SETONE TSCR,(TCB)	;need security option
2)		RETSKP			;return success


LINE 4, PAGE 13
1)					;TCPTCP does not know how to do this yet
1)		MOVE T1,TCPATP		;get the attribute pointer
1)		CALL ATTR16		;get a legal sixteen bit number
1)	         RETBAD (TCPX13)	;give error
1)		RETSKP			;return success
1)	
1)	ATTHND:				;handling-restrictions attribute
1)					;TCPTCP does not know how to do this yet
1)		MOVE T1,TCPATP		;get the attribute pointer
1)		CALL ATTR16		;get a legal sixteen bit number
1)		 RETBAD (TCPX14)
1)		RETSKP			;return success
1)	
1)	ATTTRC:				;transmission-control attribute
1)					;TCPTCP does not know how to do this yet
1)		MOVE T1,TCPATP		;get the attribute pointer
1)		CALL ATTR16		;get a legal sixteen bit number
1)	         RETBAD (TCPX15)	;give error
1)		RETSKP			;return success
1)	
1)	^L	SUBTTL CLOSF and ABORT Handling
1)	
1)	IFE REL6,<TCPCLZ:>
1)	IFN REL6,<XNENT TCPCLZ>
1)					;here on a closf
1)		SAVEAT			;save most acs

; TCPJFN.MAC.1 & <BBN-MONITOR>TCPJFN.MAC.1 20-Aug-87 0007	PAGE 12


LINE 4, PAGE 12
2)		MOVE T1,TCPATP		;get the attribute pointer
2)		CALL ATTR16		;get a legal sixteen bit number
2)	         RETBAD (TCPX13)	;give error
2)		STOR T2,TSSCP,(TCB)	;save the compartment
2)		SETONE TSCR,(TCB)	;need security option
2)		RETSKP			;return success
2)	
2)	ATTHND:				;handling-restrictions attribute
2)		MOVE T1,TCPATP		;get the attribute pointer
2)		CALL ATTR16		;get a legal sixteen bit number
2)		 RETBAD (TCPX14)	;give error
2)		STOR T2,TSSHR,(TCB)	;save the handling-restrictions
2)		SETONE TSCR,(TCB)	;need security option
2)		RETSKP			;return success
2)	
2)	ATTTRC:				;transmission-control attribute
2)		MOVE T1,TCPATP		;get the attribute pointer
2)		CALL ATTR24		;get a legal twenty-four bit number
2)	         RETBAD (TCPX15)	;give error
2)		STOR T2,TSSTC,(TCB)	;save transmission-control
2)		SETONE TSCR,(TCB)	;need security option
2)		RETSKP			;return success
2)	
2)	^L
2)	
2)	ATTFLG:				;flags attribute
2)	ATTSIZ==4			; Words in attribute
2)		STKVAR <ATTPTR,<ATTEMP,ATTSIZ>>
2)		MOVE T1,TCPATP		; Get the attribute pointer
2)		MOVEM T1,ATTPTR
2)		DO.
2)		  MOVE T1,ATTPTR	; Get working pointer
2)		  MOVX T2,<POINT 7,ATTEMP>
2)		  MOVX T3,<5*ATTSIZ-1>
2)		  ILDB T4,T1		; Get next byte
2)		  SKIPN T4		; End of string?
2)		    RETSKP		; Yes, return success
2)		  DO.
2)		    IDPB T4,T2		; Copy byte
2)		    ILDB T4,T1		; Get next
2)		    IFN. T4		; Not end of string
2)		      MOVEM T1,ATTPTR	; Save updated pointer
2)		      CAIN T4,":"	; Separator?
2)		      ANSKP.		; No, more text
2)		        SOJG T3,TOP.	; Back to copy it
2)		        RETBAD (TCPXX5)	; Too long, give error	    
2)		    ENDIF.		; End of keyword
2)		  ENDDO.
2)		  SETZ T4,
2)		  IDPB T4,T2		; End string

; TCPJFN.MAC.1 & <BBN-MONITOR>TCPJFN.MAC.1 20-Aug-87 0007	PAGE 13


2)		  XMOVEI T1,ATTFLT	; Table address
2)		  HRROI T2,ATTEMP	; Get the attribute pointer
2)		  TBLUK%		; Lookup flag name
2)		  ERJMP .+2
2)		   TXNN T2,TL%EXM+TL%ABR ; Find match?
2)		    RETBAD (TCPXX5)	; No, give error
2)		  HRRZ T1,(T1)		; Routine address
2)		  CALL (T1)		; Call it
2)		  LOOP.			; Back for more
2)		ENDDO.
2)	
2)	ATTFLT:	3,,3
2)		[ASCIZ /TCP%FR/],,[SETONE TSFR,(TCB)
2)				   RET]
2)		[ASCIZ /TCP%PT/],,[SETONE TERRT,(TCB)
2)				   RET]
2)		[ASCIZ /TCP%RX/],,[SETONE TSRX,(TCB)
2)				   RET]
2)	
2)	
2)	^L	SUBTTL CLOSF and ABORT Handling
2)	
2)	TCPCLZ:				;here on a closf
2)		SAVEAT			;save most acs


LINE 12, PAGE 14
1)		JE TSUOP,(TCB),TCPABT	;if never opened then abort
1)		JE TSOPN,(TCB),TCPABT	;if never got opened then abort
1)		UMOVE T2,1		;get users AC 1
1)		TXNE T2,CZ%ABT		;abort?
1)	 	 JRST TCPABT		;yes
1)		JN TCDCW,(TCB),TCPCLW	;if in close wait get to it
LINE 10, PAGE 14
2)		JE TSUOP,(TCB),TCBABO	;if never opened or closed then abort
2)		JE TSOPN,(TCB),TCBABO	;if never got opened then abort
2)		TMNE TCDOB,(TCB)	; Check if any bytes left to send
2)		 CALL TCSQOU		; Yes, queue them for output
2)		  NOP			; Ignore error for now (CLOSE% should flag it)
2)		LOAD T1,TJCN,(TCB)	;get the JCN for this connection
2)		TXO T1,TCP%JS		;this is a JCN
2)		UMOVE T2,1		;get users AC 1
2)		TXNE T2,CZ%ABT		;abort?
2)	 	 JRST TCBABO		;yes
2)		JN TCDCW,(TCB),TCPCLW	;if in close wait get to it


; TCPJFN.MAC.1 & <BBN-MONITOR>TCPJFN.MAC.1 20-Aug-87 0007	PAGE 14



LINE 35, PAGE 14
1)		LOAD T1,TJCN,(TCB)	;get the JCN
LINE 38, PAGE 14
2)	;cwl should wait til gets to time-wait or not.not state
2)		LOAD T1,TJCN,(TCB)	;get the JCN


LINE 3, PAGE 15
1)	TCPABT:				;here on an ABORT close (CZ%ABT on)
1)		SETZRO TCDCW,(TCB)	;no more CLOSF block
LINE 3, PAGE 15
2)	TCBABO:				;here on an ABORT close (CZ%ABT on)
2)		SETZRO TCDCW,(TCB)	;no more CLOSF block


LINE 8, PAGE 15
1)		RETSKP			;success return
LINE 8, PAGE 15
2)	;cwl
2)		SETONE <ERRF>		;Flag an error
2)		RETSKP			;success return


LINE 3, PAGE 16
1)	IFE REL6,<TCPRJF:>
1)	IFN REL6,<XNENT TCPRJF>
1)					;here on a release jfn
1)		SAVEAT
LINE 3, PAGE 16
2)	TCPRJF:				;here on a release jfn
2)		SAVEAT


LINE 16, PAGE 16
1)		LOAD T1,TJCN,(T1)	;get the JCN for this connection
LINE 14, PAGE 16
2)	;cwl should wait til gets to time-wait or not.not state
2)		LOAD T1,TJCN,(T1)	;get the JCN for this connection


LINE 3, PAGE 17
1)	IFE REL6,<TCPOPN:>
1)	IFN REL6,<XNENT TCPOPN>
1)					;perform openf
1)		SAVEAT
LINE 3, PAGE 17
2)	TCPOPN:				;perform openf
2)		SAVEAT


; TCPJFN.MAC.1 & <BBN-MONITOR>TCPJFN.MAC.1 20-Aug-87 0007	PAGE 15



LINE 20, PAGE 17
1)		LDB T1,[POINT 6,FILBYT(JFN),11] ;get byte size user wants
1)		CAIE T1,^D32		;is it 32 bit bytes?
LINE 18, PAGE 17
2)		LDB T1,PBYTSZ		;get byte size user wants
2)		CAIE T1,^D32		;is it 32 bit bytes?


LINE 31, PAGE 17
1)	         JRST TCPOP3		;yes so illegal connection
1)		LOAD T1,IOMODE		;get the mode user asked for
LINE 29, PAGE 17
2)	;cwl	  JRST TCPOP3		;yes so illegal connection
2)		  RETBAD (TCPXX2)	;Unable to decode local specification
2)		LOAD T1,IOMODE		;get the mode user asked for


LINE 36, PAGE 17
1)					;here to ask the almighty ACJ if this is OK
1)		LOAD T1,TFH,(TCB)	;get the foreign host number
1)		LOAD T2,TFP,(TCB)	;get the foreign port number
1)		IFN REL6,<S1XCT <GTOKM (.GOANA,<T1,T2>,[RETBAD()])>> ; ask acj for its blessing
1)		IFE REL6,<GTOKM (.GOANA,<T1,T2>,[RETBAD()])> ; ask acj for its blessing
1)					;Everything is OK.  Fall through.
1)	
LINE 35, PAGE 17
2)	
2)		LOAD T3,TLP,(TCB)	;get the local port number
2)		SKIPN ACJFN		; ACJ (Access Control Job) fork present?
2)		IFSKP.			; Yes...
2)					;here to ask the almighty ACJ if this is OK
2)		  LOAD T1,TFH,(TCB)	;get the foreign host number
2)		  LOAD T2,TFP,(TCB)	;get the foreign port number
2)		  TMNE TCDFS,(TCB)	;is Active flag set?
2)		    TXO T3,TCP%FS	;active - set flag for ACJ
2)		  LOAD T4,TLH,(TCB)	;get the local host number
2)		  GTOKM (.GOANA,<T1,T2,T3,T4>,[RETBAD(NTWZX1)]) ; ask acj for its blessing
2)					;Everything is OK.
2)		ELSE.			; No, ACJ not present, do our own check
2)		  TMNN TCDFS,(TCB)	;is Active flag set?
2)		   CAILE T3,377		;Not active - special low port?
2)		  ANSKP.		;Yes, require privs
2)		    MOVX T1,<SC%WHL!SC%OPR!SC%NWZ!SC%NAS>
2)		    TDNN T1,CAPENB	;Required privs?
2)		     RETBAD(NTWZX1)	;Indicate must be network wizard
2)		ENDIF.			;Everything is OK.
2)	
2)		MOVEI T1,1+TCPBCB	;locate connection block
2)		SETZM -1(T1)		;clear first word

; TCPJFN.MAC.1 & <BBN-MONITOR>TCPJFN.MAC.1 20-Aug-87 0007	PAGE 16


2)		HRLI T1,-1(T1)		;build blt pointers
2)		BLT T1,.TCPCS-1+TCPBCB	;clear the rest
2)					;Fall through.
2)	


LINE 6, PAGE 18
1)		TMNN TCDFS,(TCB)	;is Active flag set?
1)		 CAILE T1,377		;Not active - special low port?
1)		IFSKP.
1)		  MOVX T1,<SC%WHL!SC%OPR!SC%NWZ!SC%NAS>
1)		  TDNN T1,CAPENB	;Required privs?
1)		   RETBAD(NTWZX1)	;Indicate must be network wizard
1)		ENDIF.
1)		LOAD T1,TLH,(TCB)	;get the local host number
LINE 6, PAGE 18
2)		LOAD T1,TLH,(TCB)	;get the local host number


LINE 19, PAGE 18
1)		IFN. T1			;don't do this if no specific host
1)		  CALL HSTHSH		;find hash index for host
1)		ANSKP.
1)		  MOVX T1,HS%VAL!HS%UP	;have an index, clear valid and up until
1)		  ANDCAM T1,HSTSTS(T2)	; network indicates something better
1)		ENDIF.
1)		SETZM .TCPIP+TCPBCB	;no IP parameters, please
1)		SETZM .TCPOP+TCPBCB	;clear the reserved word out
1)		MOVEI T1,TCPBCB		;get the connection block address
1)		SETZB T2,T3		;clear other acs
1)		TMNE TCDFS,(TCB)	;Active flag?
1)		 TXO T1,TCP%FS		;yes so force sync
1)		TMNE TCDPS,(TCB)	;persist?
1)		 TXO T1,TCP%PS		;yes so set persist flag
1)		TMNE TCDPS,(TCB)	;persist?
1)		 LOAD T2,TPRS1,(TCB)	;yes so get the timeout time
1)		OPEN%			;open up the connection
LINE 12, PAGE 18
2)		MOVEI T1,TCPBCB		;get the connection block address
2)		SETZB T2,T3		;clear other acs
2)		MOVE T4,TCPIC(TCB)	; Get Interrupt Channel word
2)		CAMN T4,[-1]		; -1?
2)		IFSKP.			; No, set the initial interrupt channels
2)		  MOVEM T4,.TCPIC(T1)	;  in the CDB
2)		  TXO T1,TCP%IC		; Set the flag
2)		ENDIF.
2)		TMNE TCDFS,(TCB)	;Active flag?
2)		 TXO T1,TCP%FS		;yes so force sync
2)		IFQN. TCDPS,(TCB)	;persist?
2)		 TXO T1,TCP%PS		;yes so set persist flag
2)		 LOAD T2,TPRS1,(TCB)	;get the timeout time, "n"

; TCPJFN.MAC.1 & <BBN-MONITOR>TCPJFN.MAC.1 20-Aug-87 0007	PAGE 17


2)		 LOAD T3,TPRS2,(TCB)	;get the retransmission interval and
2)	IFE <TRXPI&1>,<LSH T3,<^D35-POS(TRXPI)>> ;justify it
2)		 ANDX T3,TRXPI		;just the field
2)		 SKIPE T3		;if "m" was specified,
2)		  IORX T3,<FLD(1,TRXPN)+FLD(1,TRXPD)> ;fill in constant retransmissions
2)		ENDIF.
2)	;	IF??. ???,???		; Copy TCP%ET
2)	;	  TXO T1,TCP%ET
2)	;	ENDIF.
2)		IFQN. TSFR,(TCB)	; Copy TCP%FR
2)		  TXO T1,TCP%FR
2)		ENDIF.
2)		IFQN. TERRT,(TCB)	; Copy TCP%PT
2)		  TXO T1,TCP%PT
2)		ENDIF.
2)		IFQN. TSRX,(TCB)	; Copy TCP%RX
2)		  TXO T1,TCP%RX
2)		ENDIF.
2)	;cwl ought to build options here
2)		OPEN%			;open up the connection


LINE 40, PAGE 18
1)		MOVE TCB,JCNTCB(TCB)	;get the real TCB address
1)		SETSEC TCB,INTSEC	;TCB is in INTSEC
1)		MOVEM TCB,FILTCB(JFN)	;save the real TCB address
1)		MOVE T2,T1		;get prototype TCB address
1)		MOVE T3,TCB		;get real TCB address
1)	TCPOP2:				;prototype to real TCB copying routine
LINE 49, PAGE 18
2)		LOAD TCB,JCNTC,(TCB)	;get the real TCB address
2)		MOVEM TCB,FILTCB(JFN)	;save the real TCB address
2)		MOVE T2,T1		;get prototype TCB address
2)		MOVE T3,TCB		;get real TCB address
2)		SETZRO TSTO,(T3)	;make copy below work
2)	TCPOP2:				;prototype to real TCB copying routine


LINE 6, PAGE 19
1)		MKWAIT TCPOTS		;make the MDISMS word
1)		MOVE FX,FORKX		;get our fork number.
1)		LOAD T3,TFH,(TCB)	;get the foreign host number
1)		MOVEM T3,FKSTA2(FX)	;save host address fork is blocked on
1)		CALL DISTST		;should we dismiss?
LINE 6, PAGE 19
2)		MKWAIT INTOOT		;make the MDISMS word
2)		CALL DISTST		;should we dismiss?


; TCPJFN.MAC.1 & <BBN-MONITOR>TCPJFN.MAC.1 20-Aug-87 0007	PAGE 18



LINE 19, PAGE 19
1)		IFE. T1			;if error code zero
1)		  LOAD T1,TOPNF,(TCB)	;get the open wait bit
1)		  JUMPE T1,RSKP		;beware bit 0
1)		  IDIVI T1,^D36		;separate into word and bit number
1)		  MOVE T2,BITS(T2)	;get the bit
1)		  TDNN T2,INTWTB(T1)	;connection open?
1)		   RETBAD(OPNX20)	;no, return "host is not up"
1)		  LOAD T1,TFH,(TCB)	;get the Foreign host number
1)		  IFN. T1		;don't do this if no specific host
1)		    CALL HSTHSH		;find hash index for host
1)		  ANSKP.
1)		    MOVE T1,HSTSTS(T2)	;found it, get its current status
1)		  ANDXE. T1,HS%VAL	;have valid status?
1)		    MOVX T1,HS%VAL!HS%UP ;no, set valid and up since we appear to
1)		    IORM T1,HSTSTS(T2)	; have made a connection with the host
1)		  ENDIF.
1)		  RETSKP		;yes, return success
1)		ENDIF.
1)		MOVEM T1,TCPOER		;not zero so save the error code
LINE 16, PAGE 19
2)		JUMPE T1,RSKP		;if zero then success return
2)		MOVEM T1,TCPOER		;not zero so save the error code


LINE 49, PAGE 19
1)	IFN STANSW,<
1)	;;; Note that this routine must never be called at any point other than
1)	;;;the ERJMP from the OPEN%.  In particular, it assumes that FILTCB has
1)	;;;no relation to any JCN that OPEN% may have made!!
1)		HRRZM T1,TCPOER		;save error code
1)		LDB T2,[POINT 5,T1,35]	;get just error byte
1)		LDB T1,[POINT 17,T1,17]	;and possible JCN (without 400000 bit?)
1)		IFN. T1			;have a JCN
1)		  CAIN T2,^D6		;already exists?
1)		ANSKP.			;no
1)		  TXO T1,TCP%JS		;it is a JCN
1)		  ABORT%		;release it
1)		   ERJMP .+1
1)		ENDIF.
1)		SKIPE T1,FILTCB(JFN)	;get TCB prototype address (should never skip)
1)		 CALL RETBLK		;return it to Internet free storage
1)		MOVE T1,TCPOER		;error code
1)	>;IFN STANSW
1)		SETZRO <BLKF>		;not blocking now
LINE 29, PAGE 19
2)		HRRZM T1,TCPOER		;save error code
2)		HRRZ T2,T1		;error code
2)		ANDI T2,37

; TCPJFN.MAC.1 & <BBN-MONITOR>TCPJFN.MAC.1 20-Aug-87 0007	PAGE 19


2)		HLRZS T1		;possible JCN
2)		ANDI T1,377777
2)		IFN. T1			;have a JCN
2)		  CAIN T2,^D6		;already exists?
2)		  ANSKP.		;no
2)		    TXO T1,TCP%JS	;it is a JCN
2)		    ABORT%		;release it
2)		      ERJMP .+1
2)		ENDIF.
2)		SKIPE T1,FILTCB(JFN)	;prototype TCB address
2)		  CALL RETBLK		;release it
2)		HRRZ T1,TCPOER		;error code
2)		SETZRO <BLKF>		;not blocking now


LINE 1, PAGE 20
1)	^L	SUBTTL OPENF Scheduler Test
1)	
1)	;TCPOTS - Scheduler test for open waits
1)	;T1/ <TOPNF>B26+<TERRF>B35
1)	;FX/ our fork handle
1)	;JSP T4,TCPOTS
1)	;Returns: +1: connection not open and no error
1)	;Returns: +2: otherwise
1)	
1)		RESCD
1)	
1)	TCPOTS:	PUSH P,T4		;save return PC on stack (RET(SKP) will fix it)
1)		IFE REL6,<EA.ENT>	;force us into section one if needed
1)		JSP T4,INTOOT		;check TOPNF/TERRF first
1)		 CAIA			;neither are set
1)		  RETSKP		;one or the other is set, unblock caller
1)		SKIPE T1,FKSTA2(FX)	;get host address fork is blocked on
1)		IFE REL6,<CALL HSTHSH> 	;find hash index
1)		IFN REL6,<CALLX (XCDSEC,HSTHSH)> ;find hash index
1)		  RET			;no host, new, or no room
1)		MOVE T1,HSTSTS(T2)	;get status of this host
1)		TXNE T1,HS%VAL		;have valid host status?
1)		 TXNE T1,HS%UP		;yes, is host up?
1)		  RET			;no valid status or host up
1)		RETSKP			;valid status and down
1)	
1)	IFE REL6,<SWAPCD>
1)	IFN REL6,<XSWAPCD>
1)		
1)	^L	SUBTTL OPENF Flag Setting Code
LINE 1, PAGE 20
2)	^L	SUBTTL OPENF Flag Setting Code


; TCPJFN.MAC.1 & <BBN-MONITOR>TCPJFN.MAC.1 20-Aug-87 0007	PAGE 20



LINE 3, PAGE 23
1)	IFE REL6,<TCPFI:>
1)	IFN REL6,<XNENT TCPFI>
1)					;Switch to INPUT
1)		TMNE FILINP		;allready doing input?
LINE 3, PAGE 22
2)	TCPSFI:				;Switch to INPUT
2)		TMNE FILINP		;allready doing input?


LINE 13, PAGE 23
1)	IFE REL6,<TCPFO:>
1)	IFN REL6,<XNENT TCPFO>
1)	 				;Switch to OUTPUT
1)		TMNE FILOUP		;allready doing output?
LINE 11, PAGE 22
2)	TCPSFO: 			;Switch to OUTPUT
2)		TMNE FILOUP		;allready doing output?


LINE 35, PAGE 23
1)		MOVE FX,FORKX		;get our fork number.
1)		LOAD T3,TFH,(TCB)	;get the foreign host number
1)		MOVEM T3,FKSTA2(FX)	;save host address fork is blocked on
1)		LOAD T1,TOPNF,(TCB)	;no so get the open wait bit
1)		LOAD T2,TERRF,(TCB)	;also get the error wait bit
1)		MKWAIT TCPOTS		;make the MDISMS word
1)		CALL DISTST		;should we dismiss?
LINE 31, PAGE 22
2)		LOAD T1,TOPNF,(TCB)	;no so get the open wait bit
2)		LOAD T2,TERRF,(TCB)	;also get the error wait bit
2)		MKWAIT INTOOT		;make the MDISMS word
2)		CALL DISTST		;should we dismiss?


LINE 3, PAGE 24
1)		RESCD
1)	
LINE 3, PAGE 23
2)		RESCD ;PS
2)	


; TCPJFN.MAC.1 & <BBN-MONITOR>TCPJFN.MAC.1 20-Aug-87 0007	PAGE 21



LINE 11, PAGE 24
1)	IFE REL6,<SWAPCD>
1)	IFN REL6,<XSWAPCD>
1)	
LINE 11, PAGE 23
2)		SWAPCD ;PS
2)	


LINE 17, PAGE 24
1)		MOVX T1,<.RESP3,,TCPBSZ> ;get the buffer size and priority
LINE 16, PAGE 23
2)	IFE RFSP,<
2)		MOVEI T1,TCPBSZ		;get buffer size
2)		CALL ASGSWP		;get some swappable free space
2)	>
2)	IFN RFSP,<
2)		MOVX T1,<.RESP3,,TCPBSZ> ;get the buffer size and priority


LINE 25, PAGE 24
1)		JRST TCPGT2		;error
LINE 29, PAGE 23
2)	>
2)		JRST TCPGT2		;error


LINE 31, PAGE 24
1)		MOVEI T1,^D1000		;wait 1 seconf
1)		CALL SETBKT		;compute wait
LINE 36, PAGE 23
2)		MOVEI T1,^D1000		;wait 1 second
2)		CALL SETBKT		;compute wait


LINE 40, PAGE 24
1)		CALL RELRES		;release resident free space
1)		OKINT			;allow interrupts
1)		SETZ T1,		;help TCPBFD - lets EXCH work
1)		RET			;and return to caller
1)	
1)	TCPBFD::       			;routine to discard all buffers from
1)					;TCB addressed by T1
LINE 45, PAGE 23
2)	IFE RFSP,<
2)		MOVEI T2,TCPBSZ		;length of the block
2)	 	CALL RELSWP		;release swappable free space
2)	>
2)	IFN RFSP,<

; TCPJFN.MAC.1 & <BBN-MONITOR>TCPJFN.MAC.1 20-Aug-87 0007	PAGE 22


2)		CALL RELRES		;release resident free space
2)	>
2)		OKINT			;allow interrupts
2)	
2)		SETZ T1,		;help TCPBFD - lets EXCH work
2)		RET			;and return to caller
2)	
2)	TCPBFD::			;routine to discard all buffers from
2)					;TCB addressed by T1


LINE 3, PAGE 25
1)	IFE REL6,<TCPQI:>
1)	IFN REL6,<XNENT TCPQI>
1)					;Byte Input
1)		SAVEAT			;save most acs
LINE 3, PAGE 24
2)	TCPSQI:				;Byte Input
2)		SAVEAT			;save most acs


LINE 10, PAGE 25
1)		CALL TCPSIO		;set things up (like TCB)
1)		 RET			;pass down any problems or errors
1)		JE TCDIB,(TCB),TCSQI1	;if we need an input buffer go get it
1)					;here when high throughput and buffer exists
1)		SKIPG FILBCI(JFN)	;any bytes left in this buffer?
LINE 8, PAGE 24
2)		 CALL TCPSIO		;set things up (like TCB)
2)		  RET			;pass down any problems or errors
2)		JE TCDIB,(TCB),TCSQI1	;if we need an input buffer go get it
2)					;here when TJIBE input buffer has(d) valid data
2)		SKIPG FILBCI(JFN)	;any bytes left in this buffer?


LINE 38, PAGE 25
1)		 LSH T1,-2		;yes so four bytes per word
1)		MOVEM T1,FILBCI(JFN)	;save the number of bytes available
LINE 36, PAGE 24
2)	;cwl there is go guarentee that the other end will cooperate by only
2)	;sending packets with multiples of 4 octets!
2)		 LSH T1,-2		;no so four bytes per word
2)		MOVEM T1,FILBCI(JFN)	;save the number of bytes available


; TCPJFN.MAC.1 & <BBN-MONITOR>TCPJFN.MAC.1 20-Aug-87 0007	PAGE 23



LINE 12, PAGE 26
1)		JRST TCSQI0		;and try to output this byte again
1)	
LINE 12, PAGE 25
2)		JRST TCSQI0		;and try to input this byte again
2)	


LINE 3, PAGE 27
1)	TCSQI5:				;here when the input buffer is done
1)		SETZRO TCDIB,(TCB)	;no more input buffer
1)		MOVE T1,TJIBE(TCB)	;get the buffer address
1)		SETZM TJIBE(TCB)	;no more emptying buffer
1)	IFE STANSW,<
1)		CALL TCPRLB		;release the buffer space
1)		CALL TCPGIB		;get another input buffer
1)		 RET			;pass down errors and blocks
1)	>;IFE STANSW
1)	IFN STANSW,<
1)		CALL TCPIS1		;clear buffer headers, etc
1)		 TRN			; cant possibly return here.
1)		CALL TCPGI1		;get the buffer filled up
1)		 RET			;pass down errors and blocks
1)	>;IFN STANSW
1)		JRST TCSQI0		;go try to input this character again
1)	
1)	TCSQI6:				;here when we finished the buffer
1)		SAVEAC <T1>
LINE 3, PAGE 26
2)	TCSQI5:				;here when the input buffer is done, w/o data
2)		SETZRO TCDIB,(TCB)	;no more input buffer
2)		MOVE T1,TJIBE(TCB)	;get the buffer address
2)		SETZM TJIBE(TCB)	;no more emptying buffer
2)		CALL TCPRLB		;release the space the buffer used up
2)		CALL TCPGIB		;get another input buffer
2)		 RET			;pass down errors and blocks
2)		JRST TCSQI0		;go try to input this character again
2)	
2)	TCSQI6:				;here when we finished the buffer, w/ data byte
2)		SAVEAC <T1>


; TCPJFN.MAC.1 & <BBN-MONITOR>TCPJFN.MAC.1 20-Aug-87 0007	PAGE 24



LINE 25, PAGE 27
1)	IFE STANSW,<
1)		CALL TCPRLB		;release the buffer space
1)		CALL TCPGIB		;get another input buffer
1)		 NOP			;pass down errors and blocks
1)	>;IFE STANSW
1)	IFN STANSW,<
1)		CALL TCPIS1		;clear buffer headers, etc
1)		 TRN			; cant possibly return here.
1)		CALL TCPGI1		;get the buffer filled up
1)		 SETZRO <BLKF>		;don't block now.
1)	>;IFN STANSW
1)		RET			;and return to caller
LINE 17, PAGE 26
2)		CALL TCPRLB		;release the buffer space
2)		CALL TCPGIB		;get another input buffer
2)		 NOP			;pass down errors and blocks
2)		SETZRO <BLKF,ERRF>	;got a byte, return it w/o complaining
2)		RET			;and return to caller


LINE 42, PAGE 27
1)		MOVE T2,.TCPBC(T1)	;get the byte count
LINE 27, PAGE 26
2)	;cwl this doesn't work as .TCPBC isn't updated until the buffer is returned,
2)	;not as it is being filled.  have to check load BCNT,c(TRCB(TCB))
2)		MOVE T2,.TCPBC(T1)	;get the byte count


LINE 54, PAGE 27
1)		SKIPN T1,TJIBE(TCB)	;do we have a buffer to empty?
LINE 41, PAGE 26
2)	;cwl only way to get here is via non-zero TJIBE at TCSQI1
2)		SKIPN T1,TJIBE(TCB)	;do we have a buffer to empty?


LINE 7, PAGE 28
1)	IFN STANSW,<TCPGI0:> ;;; entry for reusing buffer in T1
1)		MOVEM T1,TCGIBB		;save the buffer address
LINE 7, PAGE 27
2)		MOVEM T1,TCGIBB		;save the buffer address


; TCPJFN.MAC.1 & <BBN-MONITOR>TCPJFN.MAC.1 20-Aug-87 0007	PAGE 25



LINE 12, PAGE 28
1)		LOAD T3,TSTO,(TCB)	;get the timeout word
LINE 11, PAGE 27
2)	;cwl RECV% doesn't take anything in T3 or T4
2)		LOAD T3,TSTO,(TCB)	;get the timeout word


LINE 21, PAGE 28
1)		SETZM TJIBA(TCB)	;yes so no more active buffer
1)		MOVEM T2,TJIBE(TCB)	;old active buffer is now the emptying buffer
1)		MOVEM T1,TJIBA(TCB)	;and new buffer is the active buffer
1)		RETSKP			;and return
1)	IFN STANSW,<;;; like TCPGIB, but reuse a buffer address in T1
1)	TCPGI1:	STKVAR <TCGIBB>
1)		JRST TCPGI0	
1)	>;IFN STANSW
1)	
1)	
LINE 21, PAGE 27
2)		MOVEM T2,TJIBE(TCB)	;old active buffer is now the emptying buffer
2)		MOVEM T1,TJIBA(TCB)	;and new buffer is the active buffer
2)		RETSKP			;and return
2)	


LINE 39, PAGE 28
1)	TCGIBR:				;here on an error from the RECV%
LINE 33, PAGE 27
2)	
2)	TCGIBR:				;here on an error from the RECV%


LINE 47, PAGE 28
1)		  SKIPE TJIBE(TCB)	;yes. skip if no emptying buffer
LINE 42, PAGE 27
2)	; next line may be necessary
2)	;;;	  SETZRO TERR,(TCB)	; Clear error (checked in call to TCPSIO)
2)		  SKIPE TJIBE(TCB)	;yes. skip if no emptying buffer


LINE 52, PAGE 28
1)		  SETZM TJIBA(TCB)	;no more active buffer
1)		  RETSKP		;return success always
LINE 49, PAGE 27
2)		  SETZM TJIBA(TCB)	;no more active buffer	
2)		  RETSKP		;return success always


; TCPJFN.MAC.1 & <BBN-MONITOR>TCPJFN.MAC.1 20-Aug-87 0007	PAGE 26



LINE 57, PAGE 28
1)	
1)	TCPIST:				;here to setup the input buffer in T1
1)		CALL TCPGTB		;get a buffer
1)		 RET			;pass down blocks and errors
1)	IFN STANSW,<TCPIS1:> ;;; entry for reusing buffer in ac1
1)		SETZM .TCPBF(T1)	;zero the flags word
1)		MOVEI T2,<<TCPBSZ-.TCPBS>_2> ;get number of octets possible
LINE 1, PAGE 28
2)	^L
2)	TCPIST:				;here to setup the input buffer in T1
2)		CALL TCPGTB		;get a buffer
2)		 RET			;pass down blocks and errors
2)		SETZM (T1)		;zero the buffer header
2)		HRL T2,T1
2)		HRRI T2,1(T1)
2)		BLT T2,.TCPBS-1(T1)
2)		MOVEI T2,<<TCPBSZ-.TCPBS>_2> ;get number of octets possible


LINE 67, PAGE 28
1)		SETZM .TCPBO(T1)	;zero the option word
1)		SETZM .TCPBI(T1)	;zero the IP parameter word
1)		RETSKP			;return success
LINE 13, PAGE 29
2)		RETSKP			;return success


LINE 3, PAGE 29
1)	IFE REL6,<TCPQO:>
1)	IFN REL6,<XNENT TCPQO>
1)					;byte Output
1)		SAVEAT			;save most acs
LINE 3, PAGE 30
2)					; Note: this is called from DTCPSH to do
2)					; a PUSH and DTCSUD to do an URGENT, but
2)					; there is no data character
2)	TCPSQO:				;byte Output
2)		SAVEAT			;save most acs


; TCPJFN.MAC.1 & <BBN-MONITOR>TCPJFN.MAC.1 20-Aug-87 0007	PAGE 27



LINE 29, PAGE 29
1)	TCSQO2:				;here when buffer full coming in
1)		CALL TCSQOU		;try to output the buffer
LINE 30, PAGE 30
2)	TCSQO2:				;here when buffer full coming in, or PUSHing
2)		CALL TCSQOU		;try to output the buffer


LINE 5, PAGE 30
1)		SOSGE TCPBCO(TCB)	;buffer allready full?
1)		 JRST TCSQO2		;yes so try to output it
LINE 5, PAGE 31
2)		SOSGE TCBCO(TCB)	;buffer allready full?
2)		 JRST TCSQO2		;yes so try to output it


LINE 21, PAGE 30
1)	TCSQO5:				;here to start possibly full buffer
1)		SKIPGE TCPBCO(TCB)	;buffer full now?
1)		 CALL TCSQOU		;yes so start outputing it
LINE 21, PAGE 31
2)	;cwl something seems wrong - first time through no active or filling buffer,
2)	;which appears to mean that the first packet will not be sent until (push
2)	;or) all 100 bytes have been used??
2)	
2)	TCSQO5:				;here to start possibly full buffer
2)	;cwl only way here left TCBCO GE zero, perhapse SKIPG?
2)		SKIPGE TCBCO(TCB)	;buffer full now?
2)		 CALL TCSQOU		;yes so start outputing it


LINE 27, PAGE 30
1)	TCSQOU:				;here to queue an output buffer
LINE 32, PAGE 31
2)	
2)	TCSQOU:				;here to queue an output buffer


LINE 33, PAGE 30
1)		RET			;pass down errors and blocks
1)		RETSKP			;success return
LINE 39, PAGE 31
2)		 RET			;pass down errors and blocks
2)		RETSKP			;success return


; TCPJFN.MAC.1 & <BBN-MONITOR>TCPJFN.MAC.1 20-Aug-87 0007	PAGE 28



LINE 14, PAGE 32
1)		 MOVEM T1,TCPBCO(TCB)	;yes save number of bytes available
1)		MOVE T1,TJOBF(TCB)	;get the address of the buffer
1)		SETZM .TCPBF(T1)	;zero flag word
1)		MOVEI T2,.TCPBS(T1)	;get address of first data word
1)		MOVEM T2,.TCPBA(T1)	;save the data word address
1)		SETZM .TCPBC(T1)	;zero the byte count
1)		SETZM .TCPBO(T1)	;zero the option word
1)		SETZM .TCPBI(T1)	;zero the IP parameter word
1)		TMNE TCDB8,(TCB)	;8 bit bytes?
LINE 14, PAGE 33
2)		 MOVEM T1,TCBCO(TCB)	;yes save number of bytes available
2)		MOVE T1,TJOBF(TCB)	;get the address of the buffer
2)		SETZM (T1)		;zero the buffer header
2)		HRL T2,T1
2)		HRRI T2,1(T1)
2)		BLT T2,.TCPBS-1(T1)
2)		MOVEI T2,.TCPBS(T1)	;get address of first data word
2)		MOVEM T2,.TCPBA(T1)	;save the data word address
2)		TMNE TCDB8,(TCB)	;8 bit bytes?


LINE 13, PAGE 33
1)		MOVEM T2,TJOBA(TCB)	;old fill buffer is now the active buffer
LINE 13, PAGE 34
2)	;cwl shouldn't TCDOQ be cleared here
2)		MOVEM T2,TJOBA(TCB)	;old fill buffer is now the active buffer


LINE 3, PAGE 34
1)	IFE REL6,<TCPQF:>
1)	IFN REL6,<XNENT TCPQF>
1)					;Force record out
1)		SAVEAT			;save most acs
LINE 3, PAGE 35
2)	TCPSQF:				;Force record out
2)		SAVEAT			;save most acs


LINE 11, PAGE 34
1)		CALL TCSQO1		;join the normal byte output code
LINE 9, PAGE 35
2)	;should this be TCPSQO for cleanness? (also, TCSQO1 does a CALL TCPSIO)
2)		CALL TCSQO1		;join the normal byte output code


; TCPJFN.MAC.1 & <BBN-MONITOR>TCPJFN.MAC.1 20-Aug-87 0007	PAGE 29



LINE 18, PAGE 34
1)	IFE REL6,<TCPGTD:>
1)	IFN REL6,<XNENT TCPGTD>
1)					;GDSTS Handling
1)		SAVEAT			;save most acs
1)		MOVE TCB,FILTCB(JFN)	;get the TCB address
1)		LOAD T1,TRSYN,(TCB)	;get the receive state
1)		LOAD T2,TSSYN,(TCB)	;get the send state
1)		HRL T1,T2		;receive in the left half,  send in the right
LINE 17, PAGE 35
2)	TCPGTD:				;GDSTS Handling
2)		SAVEAT			;save most acs
2)		MOVE TCB,FILTCB(JFN)	;get the TCB address
2)		LOAD T1,TSSYN,(TCB)	;get the send state
2)		LOAD T2,TRSYN,(TCB)	;get the receive state
2)		HRL T1,T2		;receive in the left half,  send in the right


LINE 16, PAGE 35
1)	IFE STANSW,<
1)		STKVAR <HSTPT1,HSTPT2,HSTPHN,HSTPOT,HSTPDP,HSTPPP> ;LOCAL STORAGE
1)	>;IFE STANSW
1)	IFN STANSW,<
1)		STKVAR <HSTPT1,HSTPT2,HSTPHN,HSTPOT,HSTPDP,HSTPPP,HSTSCH,HSTSPR> ;LOCAL STORAGE
1)		SETZM HSTSCH		;zero saved character 
1)		SETZM HSTSPR		;zero saved character pointer
1)	>;IFN STANSW
1)		SETZM HSTPHN		;zero the host number
LINE 16, PAGE 36
2)		STKVAR <HSTPT1,HSTPT2,HSTPHN,HSTPOT,HSTPDP,HSTPPP> ;LOCAL STORAGE
2)		SETZM HSTPHN		;zero the host number


LINE 32, PAGE 35
1)		 TXO T4,HSTF%F		;yes so set the flag
1)	HSTLP1:				;loop looking for terminator for field
LINE 25, PAGE 36
2)		 TXO T4,<HSTF%F+HSTF%A>	;yes so set the flag & don't allow #
2)	HSTLP1:				;loop looking for terminator for field


; TCPJFN.MAC.1 & <BBN-MONITOR>TCPJFN.MAC.1 20-Aug-87 0007	PAGE 30



LINE 38, PAGE 35
1)	 	TXNE T4,HSTF%A		;have we allready had one?
1)		 RET			;yes so this is an error
1)		TXO T4,HSTF%A		;flag that we have seen one
1)		JRST HSTLP1		;and look for more characters
1)	HSTLP2:				;here on characters not quoted by ^v
1)		CAIL T2,"A"		;is it an alpha character?
LINE 31, PAGE 36
2)	 	TXOE T4,HSTF%A		;have we allready had one? now have one
2)		 RET			;yes so this is an error
2)		JRST HSTLP1		;and look for more characters
2)	HSTLP2:				;here on characters not quoted by ^v
2)	;cwl first-level ^v are gone, what is the above comment?
2)	;cwl following shouldn't be needed except for the "-", let GTHST% check
2)		CAIL T2,"A"		;is it an alpha character?


LINE 55, PAGE 35
1)		CAIE T2,"-"		;is it our favorite delimitor?
1)		 JRST HSTPR2		;no
1)		MOVEM T3,HSTPDP		;save the latest dash pointer
1)		JRST HSTLP1		;keep looking
LINE 49, PAGE 36
2)		CAIN T2,"."		;is it a domain prefix?
2)		  JRST HSTLP1		;yes, keep looking
2)		CAIE T2,"["		;funny characters for GTHST%
2)		 CAIN T2,"]"
2)		  JRST HSTLP1		;yes, keep looking
2)		CAIE T2,"-"		;is it our favorite delimitor?
2)		 JRST HSTPR2		;no
2)		MOVEM T3,HSTPDP		;save the latest (pre-) dash pointer
2)		JRST HSTLP1		;keep looking


LINE 5, PAGE 36
1)		CAMN T1,HSTPT1		;same as initial pointer?
1)		 RET			;yes error
1)		SKIPN HSTPDP		;do we have a host name or number?
LINE 5, PAGE 37
2)		SKIPN T2		;not parse whole string, or
2)	;cwl this can never be equal, t1 was incremented; maybe t3?
2)		 CAMN T1,HSTPT1		;same as initial pointer?
2)		  RET			;yes error
2)		SKIPN HSTPDP		;do we have a host name or number?


; TCPJFN.MAC.1 & <BBN-MONITOR>TCPJFN.MAC.1 20-Aug-87 0007	PAGE 31



LINE 17, PAGE 36
1)	IFE STANSW,<
1)		MOVE T1,HSTPT1		;get the byte pointer
1)		CALL HSTNLK		;go look up the name
1)	         RET			;not found
1)		MOVEM T1,HSTPHN		;save the host number
1)	>;IFE STANSW
1)	IFN STANSW,<
1)		SKIPN T2,HSTPDP		;did we see a "-"?
1)		IFSKP.			;yes, 
1)		 ILDB T1,T2		;get the char
1)		 MOVEM T1,HSTSCH	;save it
1)		 MOVEM T2,HSTSPR	;and where it lives
1)		 SETZM T1		;put a null there instead
1)		 DPB T1,T2
1)		ENDIF.
1)		MOVE T2,HSTPT1		;get the byte pointer to string
1)		MOVEI T1,.GTHSN		;translate string to number
1)		PUSH P,T4		;save T4 since GTHST% trashes it
1)		GTHST%
1)		IFJER.
1)		 SETZM T3		;failure, flag by using address of 0.0.0.0
1)		ENDIF.
1)		POP P,T4		;restore T4 after GTHST% trashed it
1)		MOVEM T3,HSTPHN		;save address
1)		SKIPN T1,HSTSPR		;did we fiddle with string?
1)		IFSKP.			;yes, put it back how we found it
1)		 MOVE T2,HSTSCH
1)		 DPB T2,T1
1)		ENDIF.
1)		SKIPN HSTPHN		;Did we find anything?
1)		 RET			;no, failure return
1)	>;IFN STANSW
1)	HSTPR4:				;here to check for port number
LINE 19, PAGE 37
2)		MOVE T1,HSTPT1		;get the byte pointer
2)		MOVE T2,HSTPDP		;pointer before "-" ending name
2)		CALL HSTNLK		;go look up the name
2)	         RET			;not found
2)		MOVEM T1,HSTPHN		;save the host number
2)	HSTPR4:				;here to check for port number


; TCPJFN.MAC.1 & <BBN-MONITOR>TCPJFN.MAC.1 20-Aug-87 0007	PAGE 32



LINE 59, PAGE 36
1)		MOVEI T3,12		;we use decimal for ports
1)		NIN%			;read in the port number
1)		 ERJMP HSTPR5		;on error there is no port number
1)		MOVEM T2,HSTPOT		;save the port number
LINE 34, PAGE 37
2)	;cwl better checking
2)		MOVE T3,T1		; Copy pointer
2)		ILDB T2,T3		; First character
2)		CAIL T2,"0"		; Is it a digit?
2)		 CAILE T2,"9"
2)		  RET			; No, bad syntax
2)		MOVEI T3,12		;we use decimal for ports
2)		NIN%			;read in the port number
2)		 ERJMP R		;on error bad syntax
2)		MOVEM T2,HSTPOT		;save the port number


LINE 70, PAGE 36
1)		  LDB T3,T1		;yes to either, get the next character
1)		  CAIE T3,"#"		;is it the special port delimiter?
LINE 51, PAGE 37
2)		  LDB T3,T1		;yes to either, get the break character
2)		  CAIE T3,"#"		;is it the special port delimiter?


LINE 75, PAGE 36
1)		  JE <SC%WHL,SC%OPR,SC%NAS,SC%NWZ>,CAPENB,R
1)		ENDIF.
LINE 56, PAGE 37
2)	;cwl wait for ACJ at open
2)	repeat 0,<
2)		  JE <SC%WHL,SC%OPR,SC%NAS,SC%NWZ>,CAPENB,R
2)	>
2)		ENDIF.


LINE 4, PAGE 37
1)		AOS T2,JOBUNI		;get next unique number for this job
LINE 4, PAGE 38
2)	;cwl shouldn't this be before checks above?
2)		AOS T2,JOBUNI		;get next unique number for this job


; TCPJFN.MAC.1 & <BBN-MONITOR>TCPJFN.MAC.1 20-Aug-87 0007	PAGE 33



LINE 7, PAGE 38
1)	;T2/ 32 bit host number right justified
1)	
LINE 7, PAGE 39
2)	;T1/ 32 bit host number right justified
2)	


LINE 24, PAGE 38
1)		LDB T2,T1		;no so get the next character
1)		CAIE T2,"."		;better be a dot
LINE 24, PAGE 39
2)		LDB T2,T1		;no so get the break character
2)		CAIE T2,"."		;better be a dot


LINE 29, PAGE 38
1)		MOVE T2,HSTHSN		;get the host number
1)		RETSKP			;and return success
LINE 29, PAGE 39
2)		MOVE T1,HSTHSN		;get the host number
2)		RETSKP			;and return success


LINE 5, PAGE 39
1)	;Non-skip return for error
LINE 5, PAGE 40
2)	;T2/ Byte pointer before "-" ending name
2)	;Non-skip return for error


LINE 11, PAGE 39
1)		STKVAR <HNLKPT,HNLKP1,HNLKP2>
1)		MOVEM T1,HNLKPT		;save the pointer
1)		HRLZ T1,MHOSTS		;get the AOBJN ac
1)	HSTNL1:				;name chasing loop
1)		MOVE T2,HNLKPT		;get the string pointer
1)		MOVEM T2,HNLKP1		;save it where we can use it
1)		HRRZ T2,T1		;get the index out of the AOBJN AC
1)		SETSEC T2,INTSEC	;make sure we touch the proper section
1)		LOAD T2,HSTNMP,(T2)	;get the address of a name string
1)		ADD T2,[INTSEC,,HSTNAM]	;get the entire address
1)		MOVX T3,<POINT 7,0(T2)>	;make a byte pointer
1)		MOVEM T3,HNLKP2		;save the second pointer
1)	HSTNL2:				;loop for checking out a host name
1)		ILDB T4,HNLKP2		;get a byte of the second string
1)	IFE STANSW,<
1)		JUMPE T4,HSTNL3		;if this is a null byte we have success
1)		ILDB T3,HNLKP1		;get a byte of the first string

; TCPJFN.MAC.1 & <BBN-MONITOR>TCPJFN.MAC.1 20-Aug-87 0007	PAGE 34


1)		JUMPE T3,HSTNL3		;if this is a null byte we have success
1)	>;IFE STANSW
1)	IFN STANSW,<
1)		ILDB T3,HNLKP1		;get a byte of the first string
1)		SKIPN T4		;run out on second string?
1)		 JUMPE T3,HSTNL3	;if this also null we have success
1)	>;IFN STANSW
1)		CAIN T3,(T4)		;bytes match?
1)		 JRST HSTNL2		;yes so keep checking
1)					;here when current host name did not match
1)		AOBJN T1,HSTNL1		;go check out the next host
1)		RET			;we did not find a host name
1)	HSTNL3:				;here when we found the host name
1)		SETSEC T1,INTSEC	;reference proper section
1)		LOAD T1,HSTIDX,(T1)	;get the HOSTNN index
1)		SETSEC T1,INTSEC	;reference proper section
1)		MOVE T1,HOSTNN(T1)	;get the host number
1)		RETSKP			;and success return
1)	
1)	^L	SUBTTL TCOPR JSYS
1)	
1)		SWAPCD
1)	
1)	.TCOPR::
1)		MCENT			;jsys entry macro
LINE 12, PAGE 40
2)	REPEAT 1,<STKVAR <HNLKND,HNLKBT,HNLKDT> >
2)	REPEAT 0,<STKVAR <HNLKPT,HNLKND,HNLKBT,HNLKDT,HNLKP1,HNLKP2> >
2)		MOVEM T2,HNLKND		;save ending pointer
2)		ILDB T3,T2
2)		MOVEM T3,HNLKDT		;save terminator
2)		SETZ T3,
2)		DPB T3,T2		;terminate with nul
2)	REPEAT 1,<
2)		MOVE T2,T1		;starting pointer
2)		MOVX T1,.GTHSN		;string to number
2)		GTHST%			;it knows how to do it
2)		 TRNA			;not found
2)		  AOS (P)		; found
2)	> ; End of REPEAT 1
2)	REPEAT 0,<
2)		MOVEM T1,HNLKPT		;save the pointer
2)		HRLZ T1,MHOSTS		;get the AOBJN ac
2)		DO.			;name chasing loop
2)		  MOVE T2,HNLKPT	;get the string pointer
2)		  MOVEM T2,HNLKP1	;save it where we can use it
2)	
2)		  MOVE T4,[HOSTN]	;Table location
2)	REPEAT HOSTNW,<	ADDI T4,(T1)>	;Index into table
2)		  LOAD T2,HSTNMP,(T4)	;get the address of a name string
2)		  MOVX T3,<POINT 7,0(T2)> ;make a byte pointer

; TCPJFN.MAC.1 & <BBN-MONITOR>TCPJFN.MAC.1 20-Aug-87 0007	PAGE 35


2)		  MOVEM T3,HNLKP2	;save the second pointer
2)		  DO.			;loop for checking out a host name
2)		    ILDB CX,HNLKP2	;get a byte of the second string
2)		    ILDB T3,HNLKP1	;get a byte of the first string
2)		    CAIE T3,(CX)	;bytes match?
2)		      EXIT.		;no, try next entry
2)		    JUMPN T3,TOP.	;if this is not a null byte, look further
2)					;if one is zero, both are, have match
2)		    LOAD T1,HSTIDX,(T4)	;get the HSTNML address of host's number list
2)	;cwl ought to find best address in list instead of taking the first ...
2)		    MOVE T3,(T1)	;get the (first) host number
2)		    AOS (P)		;and success return
2)		    SETZ T1,		;to exit both loops
2)		  ENDDO.		;here when current host name did not match
2)		  AOBJN T1,TOP.		;go check out the next host
2)		ENDDO.
2)	> ; End of REPEAT 0
2)		MOVE T2,HNLKDT		;terminator
2)		IDPB T2,HNLKND		;back to string
2)		MOVE T1,T3		;maybe the (first) host number
2)		RET
2)	
2)	^L	SUBTTL TCOPR JSYS
2)	
2)	.TCOPR::			;tcp operations
2)		MCENT			;jsys entry macro


LINE 13, PAGE 40
1)		SKIPE T1		;t1 should be zero
1)		 JRST TCOPRE		;if not zero then error
1)		XCTU [SKIPE T1]		;users t1 must be zero
1)		 JRST TCOPRE		;it is not so give an error
1)		UMOVE T1,T3		;get users argument
LINE 11, PAGE 41
2)		SKIPN T1		;t1 should be zero
2)		 XCTU [SKIPE T1]	;users t1 must be zero
2)		  JRST TCOPRE		;it is not so give an error
2)		UMOVE T1,T3		;get users argument


LINE 23, PAGE 40
1)		 JRST TCOPRB		;non skip return means error
1)		OKINT			;allow interrupts
LINE 20, PAGE 41
2)		  JRST TCOPRB		;non skip return means error
2)		OKINT			;allow interrupts


; TCPJFN.MAC.1 & <BBN-MONITOR>TCPJFN.MAC.1 20-Aug-87 0007	PAGE 36



LINE 21, PAGE 41
1)		 RETBAD (TCPX21)	;no so give an error return
1)		RETSKP			;success return
LINE 21, PAGE 42
2)		  RETBAD (TCPX21)	;no so give an error return
2)		RETSKP			;success return


LINE 9, PAGE 42
1)		 JRST TCOPRB		;pass on error
1)		 JRST TCOPRE		;no tty's
1)		 JRST TCOPRE		;no byte pointers
1)		CAIN P3,TCPDTB		;make sure it is the tcp device
1)		 JRST TCOPR2		;it is the tcp device
1)		CALL UNLCKF		;unlock the jfn
LINE 9, PAGE 43
2)		  JRST TCOPRB		;pass on error
2)		  JRST TCOPRE		;no tty's
2)		  JRST TCOPRE		;no byte pointers
2)		CAIN P3,TCPDTB		;make sure it is the tcp device
2)		  JRST TCOPR2		;it is the tcp device
2)		CALL UNLCKF		;unlock the jfn


LINE 18, PAGE 42
1)		RETERR 			;give an error
1)	
1)	TCOPR2:				;here when we have the jfn and it is tcp
1)		SKIPN TCB,FILTCB(JFN)	;get the TCB address
1)		 RETERR(TCPX36,<CALL UNLCKF>) ;can not reopen a TCP JFN
1)		UMOVE T1,T2		;get the function code back
1)		UMOVE T2,T3		;get the parameter from the user
1)		CALL @TCOPDD(T1)	;dispatch to the routine
1)		 JRST TCOPRR		;error return..pass it along to the user
1)		CALL UNLCKF		;unlock the jfn
LINE 18, PAGE 43
2)		ITERR 			;give an error
2)	
2)	TCOPR2:				;here when we have the jfn and it is tcp
2)		SKIPN TCB,FILTCB(JFN)	;get the TCB address
2)		  ITERR (TCPX36,<CALL UNLCKF>)  ;can not reopen a TCP JFN
2)		UMOVE T1,T2		;get the function code back
2)		UMOVE T2,T3		;get the parameter from the user
2)		CALL @TCOPDD(T1)	;dispatch to the routine
2)		  JRST TCOPRR		;error return..pass it along to the user
2)		CALL UNLCKF		;unlock the jfn


; TCPJFN.MAC.1 & <BBN-MONITOR>TCPJFN.MAC.1 20-Aug-87 0007	PAGE 37



LINE 34, PAGE 42
1)		RETERR			;and return the error
1)	
LINE 34, PAGE 43
2)		ITERR			;and return the error
2)	


LINE 24, PAGE 43
1)	TCOPDN==.-TCOPDD-1	;max offset for dispatch
LINE 24, PAGE 44
2)		IFIW!DTCRTC	;read a block of TCP data
2)	TCOPDN==.-TCOPDD-1	;max offset for dispatch


LINE 9, PAGE 44
1)		 RET			;yes pass along error
1)		JUMPE T2,DCSPA2		;passive?
LINE 9, PAGE 45
2)		  RET			;yes pass along error
2)		JUMPE T2,DCSPA2		;passive?


LINE 18, PAGE 44
1)		CALL STCBNO		;TCB Open
1)		 RET			;yes pass along error
1)		HLRZ T1,T2		;(m) put second parameter in convienent place
LINE 18, PAGE 45
2)	;cwl delete 2 to allow changes after OPENF
2)	;	CALL STCBNO		;TCB Open
2)	;	  RET			;yes pass along error
2)		HLRZ T1,T2		;(m) put second parameter in convienent place


LINE 32, PAGE 44
1)		RETSKP			;success return
LINE 33, PAGE 45
2)	;cwl not set persist flag (?)
2)		STOR T2,TSTO,(TCB)	;set timeout too
2)		IFN. T1
2)	IFE <TRXPI&1>,<LSH T1,<^D35-POS(TRXPI)>> ;justify it
2)		  ANDX T1,TRXPI		;just the field
2)		  IORX T1,<FLD(1,TRXPN)+FLD(1,TRXPD)> ;fill in constant retransmissions
2)		  STOR T1,TRXP,(TCB)	;set retransmission rate
2)		ELSE.
2)		  SETZRO TRXP,(TCB)	;default algorithm
2)		ENDIF.
2)		RETSKP			;success return


; TCPJFN.MAC.1 & <BBN-MONITOR>TCPJFN.MAC.1 20-Aug-87 0007	PAGE 38



LINE 23, PAGE 45
1)		SETONE TCDPU,(TCB)	;set the push flag
1)	IFE STANSW,< ; Bob Knight's ILMNRF bugfix
1)		CALL TCSQO1		;go do the push
1)	>;IFE STANSW
1)	IFN STANSW,< ; Bob Knight's ILMNRF bugfix
1)		IFE REL6,<CALL TCSQO1>
1)		IFN REL6,<CALLX (XCDSEC,TCSQO1)>	; Do the push
1)	>;IFN STANSW	
1)		TMNE <ERRF>		;error?
LINE 23, PAGE 46
2)		SETONE <TCDPU>,(TCB)	;set the push flag
2)		CALL TCPSQO		;go do the push
2)		TMNE <ERRF>		;error?


LINE 2, PAGE 46
1)	
1)	DTCSPC:				;set PSI channels
LINE 2, PAGE 47
2)	DTCSPC:				;set PSI channels


LINE 9, PAGE 46
1)	IFE STANSW,<
1)		LDB T3,[POINTR T1,TC%TPU] ;get the urgent channel
1)		STOR T3,TPICU,(TCB)	;store away the urgent channel
1)		LDB T3,[POINTR T1,TC%TER] ;get the error channel
1)		STOR T3,TPICE,(TCB)	;store away the error channel
1)		LDB T3,[POINTR T1,TC%TSC] ;get the state change channel
1)		STOR T3,TPICX,(TCB)	;store away the state change channel
1)	>;IFE STANSW
1)	IFN STANSW,<	
1)		MOVE FX,FORKX		;get fork number
1)		LDB T3,[POINTR T1,TC%TPU] ;get the urgent channel
1)		CAIN T3,77		;making any change?
1)		IFSKP.
1)		  STOR T3,TPICU,(TCB)	;no, store away the urgent channel
1)		  STOR FX,TPIFU,(TCB)	;set the urgent fork handle
1)		ENDIF.
1)		LDB T3,[POINTR T1,TC%TER] ;get the error channel
1)		CAIN T3,77		;making any change?
1)		IFSKP.
1)		  STOR T3,TPICE,(TCB)	;store away the error channel
1)		  STOR FX,TPIFE,(TCB)	;set the error fork handle
1)		ENDIF.
1)		LDB T3,[POINTR T1,TC%TSC] ;get the state change channel
1)		CAIN T3,77		;making any change?
1)		IFSKP.

; TCPJFN.MAC.1 & <BBN-MONITOR>TCPJFN.MAC.1 20-Aug-87 0007	PAGE 39


1)		  STOR T3,TPICX,(TCB)	;store away the state change channel
1)		  STOR FX,TPIFX,(TCB)
1)		ENDIF.
1)	>;IFN STANSW
1)		RETSKP			;return success
1)	
1)	DTSPC2:				;here when bad bits were on
1)		RETBAD (TCPX41)		;get an error of return it
1)	
1)	DTCRTW:				;read a word from the TCB
LINE 8, PAGE 47
2)		MOVE T4,P		; Save stack fence
2)	
2)	; Macro to process each instance of a channel from the TCOPR Channel Word
2)	; N.B.  This call pushes each channel assignment on the stack.  The
2)	; arguments must correspond in REVERSE order to the channels given in
2)	; the SETCH. macro call.
2)	DEFINE CHKCH.(lst) <
2)		IRP lst,<
2)		LDB T3,[POINTR T1,lst]  ;; Get the channel
2)		CALL CHKCHN		;; Check the channel
2)		  JRST DTSPC3		;; Error, return
2)		PUSH P,T3		;; Save on Stack
2)		>
2)	> ; End DEFINE CHKCH.
2)	
2)	; Macro to set each channel in the TCB
2)	; N.B.  This call pops each channel assignment off the stack.  The
2)	; arguments must correspond in REVERSE order to the channels given in
2)	; the CHKCH. macro call.
2)	DEFINE SETCH.(lst) <
2)		IRP lst,<SETCH0(lst)>
2)	> ; End DEFINE SETCH.
2)	
2)	DEFINE SETCH0(lst)<SETCH1(lst)>
2)	
2)	; Process each instance of the <Channnel,Fork> structure name pair
2)	DEFINE SETCH1(chan,fork)<
2)		POP P,T3		;; Recover channel
2)		CAIN T3,77		;; Change wanted?
2)		IFSKP.			;; Yes
2)		  MOVE T2,FORKX		;;CS92 Get fork to set
2)		  CAIN T3,76		;;CS92 Deletion wanted?
2)		    SETOB T2,T3		;;CS92 Yes - indicate no channel, no FORKX
2)		  STOR T3,chan,(TCB)	;; Store away the channel
2)		  STOR T2,fork,(TCB)	;; Store away the FORKX
2)		ENDIF.
2)	> ; End DEFINE SETCH1
2)	
2)		;;;;	St.Ch.,Error ,Urgent
2)		CHKCH.(<TC%TSC,TC%TER,TC%TPU>)	; Check and push them

; TCPJFN.MAC.1 & <BBN-MONITOR>TCPJFN.MAC.1 20-Aug-87 0007	PAGE 40


2)	;CS82 *** Delete 1 line ***
2)	;	MOVE T2,FORKX		; This fork gets the interrupts
2)		;;;;	 Urgent	     , Error	   , State Change
2)		SETCH.(<<TPICU,TPIFU>,<TPICE,TPIFE>,<TPICX,TPIFX>>) ; Pop and set them
2)		RETSKP			; Return success
2)	^L
2)	DTSPC2:				;here when bad bits were on
2)		RETBAD (TCPX41)		;get an error of return it
2)	
2)	DTSPC3:				; Here when bogus interrupt channel given
2)		MOVE P,T4		; Restore stack fence
2)		RETBAD (TCPX34)		; Return error
2)	
2)	; Check channel assignments for TCP events
2)	;
2)	;Call:
2)	;T3/	Channel number
2)	;	CALL CHKCHN
2)	;
2)	; Returns: +1: bad channel number
2)	;	   +2: no change wanted (channel = 77) OR
2)	;	       delete the current channel assignment (channel = 76) OR
2)	;	       channel valid ((0 le channel le 5) or (24 le channel le 35))
2)	CHKCHN:	TRC T3,76		; No change or Delete wanted?
2)		TRCN T3,76
2)		IFSKP.			; Change wanted...
2)		  CAIG T3,5		; Less than or equal to 5?
2)		  IFSKP. 		; No...
2)		    CAIL T3,^D24	; Between 24 and 35?
2)		      CAILE T3,^D35
2)		    ANNSK.		; No, bogus number
2)		      RET		; Return +1
2)		  ENDIF.
2)		ENDIF.
2)		RETSKP			; Valid or 77 or 76, skip return
2)	
2)	^L
2)	DTCRTW:				;read a word from the TCB


LINE 55, PAGE 46
1)		SETONE TCDUR,(TCB)	;set the urgent flag
1)		SETONE TCDPU,(TCB)	;set the push flag
1)	IFE REL6,<CALL TCSQO1>		;go do the push
1)	IFN REL6,<CALLX (XCDSEC,TCSQO1)> ;go do the push
1)		TMNE <ERRF>		;error?
LINE 14, PAGE 49
2)		SETONE <TCDUR>,(TCB)	;set the urgent flag
2)		SETONE <TCDPU>,(TCB)	;set the push flag
2)		CALL TCPSQO		;go do the push
2)		TMNE <ERRF>		;error?

; TCPJFN.MAC.1 & <BBN-MONITOR>TCPJFN.MAC.1 20-Aug-87 0007	PAGE 41




LINE 6, PAGE 47
1)		LOAD T1,TJCN,(TCB)	;get the JCN for this connection
1)		TXO T1,TCP%JS		;this is a JCN
1)		JE TSUOP,(TCB),RSKP	;if never opened do not bother
1)		JE TSOPN,(TCB),RSKP	;if never got opened do not bother
1)		CLOSE%			;close down the connection
LINE 6, PAGE 50
2)		JE TSUOP,(TCB),RSKP	;if never opened do not bother
2)		JE TSOPN,(TCB),RSKP	;if never got opened do not bother
2)		TMNE TCDOB,(TCB)	; Check if any bytes left to send
2)		 CALL TCSQOU		; Yes, queue them for output
2)		  NOP			; Ignore error for now (CLOSE% should flag it)
2)		LOAD T1,TJCN,(TCB)	;get the JCN for this connection
2)		TXO T1,TCP%JS		;this is a JCN
2)		CLOSE%			;close down the connection


LINE 1, PAGE 48
1)	^L	SUBTTL IPOPR JSYS
1)	
1)	IFE REL6,<SWAPCD>
1)	IFN REL6,<XSWAPCD>
1)	
1)	IFE REL6,<.IPOPR::>
1)	IFN REL6,<XNENT .IPOPR,G>
1)		MCENT			;jsys entry macro
1)		CAIG T1,IPOPDN		;legit function?
1)		 SKIPGE T1		;legit function?
1)		  RETERR (TCPX23)	;no so give error
1)		MOVX T2,<SC%WHL!SC%OPR!SC%NWZ!SC%MNT> ;get mask of needed privs
1)		TDNN T2,CAPENB		;correct privs set?
1)		 RETERR (TCPX24)	;no so return with error
1)		UMOVE T2,T2		;get users ac 2
1)		UMOVE T3,T3		;get users ac 3
1)		NOINT			;No PSIs during these functions
1)		CALL @IPOPDD(T1)	;dispatch on the function code
1)		 RETERR (,<OKINT>)	;return error in ac 1
1)		OKINT			;PSIs are ok now
LINE 18, PAGE 50
2)	
2)	DTCRTC:				;read a block of TCP data
2)		MOVE T1,TCB		;invoked by TCOPR%, not IPOPR%
2)		CALL TCSTAT		;return requested data, arg 1, arg block U3
2)		CAIN T1,MNTX00		;all ok?
2)		  AOS (P)		;yes, skip return
2)		RET			;no, will itrap
2)	
2)	^L	SUBTTL IPOPR JSYS
2)	

; TCPJFN.MAC.1 & <BBN-MONITOR>TCPJFN.MAC.1 20-Aug-87 0007	PAGE 42


2)	IPOP%V==1B2			; Flag functions which require privledges
2)	
2)	.IPOPR::			;ip operations
2)		MCENT			;jsys entry macro
2)		CAIG T1,IPOPDN		;legit function?
2)		 SKIPGE T1		;legit function?
2)		  ITERR (TCPX23)	;no so give error
2)		MOVX T2,<SC%WHL!SC%OPR!SC%NWZ!SC%MNT> ;get mask of needed privs
2)		MOVX T3,IPOP%V		;requires privledges flag
2)		TDNN T2,CAPENB		;correct privs set?
2)		 TDNN T3,IPOPDD(T1)	;no, need them?
2)		  TRNA			;not required or have privledges
2)		   ITERR (TCPX24)	;no so return with error
2)		XCTU [DMOVE T2,2]	;get user's ac2 & 3
2)		NOINT			;No PSIs during these functions
2)		CALL @IPOPDD(T1)	;dispatch on the function code
2)		  ITERR (,<OKINT>)	;instruction trap, error in ac 1
2)		OKINT			;PSIs are ok now


LINE 24, PAGE 49
1)		NCTDSP IPOPSN		;set network state
1)		NCTDSP IPOPRN		;read network state
1)		NCTDSP IPOPRI		;initialize host table
1)		NCTDSP IPOPGW		;initialize gateway table
1)		NCTDSP IPOPRB		;read state of internet bypass
1)		NCTDSP IPOPSB		;set state of internet bypass
1)		NCTDSP IPOPIP		;control internet portal
1)		NCTDSP IPOPAP		;control arp portal
1)		NCTDSP IPOPIG		;reinitialize GHT
1)		NCTDSP IPOPRG		;return GHT
1)		NCTDSP IPOPIC		;return internet portal counters
1)		NCTDSP IPOPAC		;return arp portal counters
1)		IPOPDN==.-IPOPDD-1	;max function code
1)	
1)	IPOPSN:				;set network state
LINE 24, PAGE 51
2)		IFIW!IPOPSN!IPOP%V	;set network state
2)		IFIW!IPOPRN		;read network state
2)		IFIW!IPOPHT!IPOP%V	;initialize host table
2)		IFIW!IPOPGW!IPOP%V	;initialize gateway table
2)		IFIW!IPOPRB		;read state of internet bypass
2)		IFIW!IPOPSB!IPOP%V	;set state of internet bypass
2)		IFIW!IPOPIP		;control internet portal
2)		IFIW!IPOPAP		;control arp portal
2)		IFIW!IPOPIG		;reinitialize GHT
2)		IFIW!IPOPRG		;return GHT
2)		IFIW!IPOPIC		;return internet portal counters
2)		IFIW!IPOPAC		;return arp portal counters
2)		IFIW!IPOPSA!IPOP%V	;initialize local network interfaces
2)		IFIW!IPOPRI		;read a block of IP information

; TCPJFN.MAC.1 & <BBN-MONITOR>TCPJFN.MAC.1 20-Aug-87 0007	PAGE 43


2)		IFIW!IPOCKS		;compute ip-flavor 16-bit checksum
2)		IFIW!IPOPDM!IPOP%V	;initialize domain tables
2)		IFIW!IPOLHL		;CS150 Get local host number list
2)	 IPOPDN==.-IPOPDD-1		;max function code
2)	^L
2)	IPOPSN:				;set network state


LINE 42, PAGE 49
1)		 NOP			;ignore errors
1)		RETSKP			;return success
1)	
LINE 6, PAGE 52
2)		JRST IPOPX		;common exit
2)	


LINE 48, PAGE 49
1)		 NOP			;ignore errors
1)		UMOVEM T2,3		;save result in users t3
1)		RETSKP			;success return
1)	
1)	IPOPRB:				;read state of internet bypass
1)		MOVE T1,INTBYP		;get state of the bypass
1)		UMOVEM T1,2		;save result in users T2
LINE 11, PAGE 52
2)		CAIN T1,MNTX00		;error?
2)		  UMOVEM T2,3		;no, return the value to users t3
2)		JRST IPOPX		;common exit
2)	
2)	IPOPHT:				;initialize host table
2)		CALL HSTINI		;init the host table
2)		JRST IPOPX		;common exit
2)	
2)	IPOPGW:				;initialize gateway table
2)		CALL GWYINI		;reinitialize the gateway tables
2)		JRST IPOPX		;common exit
2)	
2)	IPOPRB:				;read state of internet bypass
2)		MOVE T1,LUPNCT		;Loopback NCT
2)		MOVE T1,NETON(T1)	;ON(-1)/OFF(0) state
2)		UMOVEM T1,2		;save result in users T2


; TCPJFN.MAC.1 & <BBN-MONITOR>TCPJFN.MAC.1 20-Aug-87 0007	PAGE 44



LINE 58, PAGE 49
1)		SKIPE T2		;non zero?
1)		 SETO T2,		;yes make it all ones
1)		MOVEM T2,INTBYP		;set the new state
1)		RETSKP			;success return
1)	
1)	^L
1)	
1)	IPOPRI:				;initialize host table
1)		CALL HSTINI		;init the host table
1)		 NOP			;ignore errors
1)		RETSKP			;return success
1)	
1)	IPOPGW:				;initialize gateway table
1)		CALL GWYINI		;reinitialize the gateway tables
1)		RETSKP			;success return
1)	
LINE 30, PAGE 52
2)		MOVE T1,LUPNCT		;Loopback NCT
2)		SKIPE T2		;non zero?
2)		 SETO T2,		;yes make it all ones
2)		MOVEM T2,NETON(T1)	;set the new state
2)		CALL MNTWAK		;Get Multinet to notice it
2)		RETSKP			;success return
2)	
2)	IPOPSA:				;initialize local network interfaces
2)		CALL ADRINI		;reinitialize local network interfaces
2)		CAIE T1,MNTX00		;error? (interfaces are OFF)
2)		  JRST IPOPX		;yes, common exit
2)		CALL MNETON		;no, turn interfaces on
2)		MOVX T1,MNTX00		;restore error code
2)		JRST IPOPX		;common exit
2)	^L
2)	IPOPDM:				; (Re)initialize domain tables
2)		MOVX T1,DMC%KL		; Assume off
2)		SKIPE T2		; Correct?
2)		  MOVX T1,DMC%IN	; No, on
2)		IORM T1,DOMSRV		; Request
2)		HLLZS DOMSRV		; Forget last error code
2)		MOVX CX,<1B0>
2)		IORM CX,MNTFLG+1	; Wake up utility fork to do it
2)		MOVE T1,[XWD DOMSRV,DISB18]
2)		MDISMS			; Wait until done
2)		HRRZ T1,DOMSRV		; Get error code
2)		JRST IPOPX		; Common exit
2)	
2)		RESCD	;ps Scheduler test
2)	
2)	; Wait until 1B18 is set ...

; TCPJFN.MAC.1 & <BBN-MONITOR>TCPJFN.MAC.1 20-Aug-87 0007	PAGE 45


2)	IFE <.ERBAS&1B18>,<PRINTX ? Fix DISB18>
2)	
2)	DISB18:	MOVE T2,(T1)		; Get word
2)		TRNN T2,1B18		; Error code been set?
2)		  JRST 0(T4)		; No, Wait
2)		JRST 1(T4)		; Yes, Run
2)	
2)		SWAPCD	;ps End of scheduler test
2)	
2)	IPOPRI:				;read a block of IP information
2)		SETO T1,		;invoked by IPOPR%, not TCOPR%
2)		CALL TCSTAT		;return requested data, arg block U2
2)		JRST IPOPX		;Common exit
2)	
2)	IPOPX:	ADJSP P,-1		;drop return
2)		OKINT
2)		CAIN T1,MNTX00		;all ok?
2)		  JRST MRETN		;yes
2)		ITERR ()		;no, will itrap
2)	
2)	;CS150 *** Begin ***
2)	
2)	;New function to read local host list
2)	;	T2/ -Length,,block address
2)	;Returns:
2)	;	T2/ -Actual length,,block address is returned to user
2)	
2)	IPOLHL:
2)		SETZ T1,		; Count entries here
2)		DO.
2)		  SKIPE T3,NLHOST(T1)	;Get an entry
2)		   CAMN T3,[-1]		;End of list?
2)		    EXIT.		;Yes - done
2)		  UMOVEM T3,(T2)	;Give it to the user
2)		  AOBJP T2,ENDLP.	;If user block empty...
2)		  AOJA T1,TOP.		; Increment # entries, go to next
2)		ENDDO.
2)		MOVN T2,T1		; Get neg. number entries
2)		XCTU [HRLM T2,T2]	;Give it back to the user
2)		RETSKP			;Done.
2)	;CS150 *** End ***
2)	
2)	IPOCKS:	CALL GENCKU		;Compute checksum
2)		UMOVEM T1,1		;2/ini, 3/adr, 4/byt -> 1/checksum
2)		RETSKP
2)	


; TCPJFN.MAC.1 & <BBN-MONITOR>TCPJFN.MAC.1 20-Aug-87 0007	PAGE 46



LINE 18, PAGE 50
1)	
1)	IPOPIP:				;control internet portal
LINE 1, PAGE 54
2)	^L
2)	IPOPIP:				;control internet portal


LINE 33, PAGE 50
1)		 RETBAD(TCPX44)		;no
1)		XMOVEI T1,ARPINI	;assume we are turning it on
1)		SKIPN T2		;are we enabling it?
1)		 XMOVEI T1,ARPKIL	;no
1)		CALL 0(T1)		;enable or disable ARP
1)		 RETBAD()		;pass down the error
1)		RETSKP			;success return
LINE 16, PAGE 55
2)		  ITERR (TCPX44)	;no
2)		XMOVEI T1,ARPINI	;assume we are turning it on
2)		SKIPN T2		;are we enabling it?
2)		  XMOVEI T1,ARPKIL	;no
2)		CALL 0(T1)		;enable or disable ARP
2)		  ITERR ()		;pass down the error
2)		RETSKP			;success return


LINE 43, PAGE 50
1)		 RETBAD(TCPX44)		;no
1)		RETBAD (TCPX23)		;for now return an error
1)	
1)	^L
1)	
1)	IPOPIC:				;return internet portal counters
1)		SKIPN [IPNIN]		;do we have IP on the NI code?
1)		 RETBAD(TCPX44)		;no
1)		MOVEI T1,1		;get a positive number
1)		MOVEM T1,NIPSRQ		;request to read IP counters
1)		AOS INTFRK		;ask for the internet fork to run
1)		MOVEI T1,NICTRS		;get the request down word adr
LINE 26, PAGE 55
2)		  ITERR (TCPX44)	;no
2)		ITERR (TCPX23)		;for now return an error
2)	
2)	
2)	IPOPIC:				;return internet portal counters
2)		SKIPN [IPNIN]		;do we have IP on the NI code?
2)		  ITERR (TCPX44)	;no
2)		MOVEI T1,1		;get a positive number
2)		MOVEM T1,NIPSRQ		;request to read IP counters

; TCPJFN.MAC.1 & <BBN-MONITOR>TCPJFN.MAC.1 20-Aug-87 0007	PAGE 47


2)		AOS INTFLG		;ask for the internet fork to run
2)		MOVEI T1,NICTRS		;get the request down word adr


LINE 16, PAGE 51
1)		 RETBAD(TCPX44)		;no
1)		MOVEI T1,1		;get a postive number
1)		MOVEM T1,ARPSRQ		;request to read ARP counters
1)		AOS INTFRK		;ask for the internet fork to run
1)		MOVEI T1,ARPTRS		;get the request done word adr
LINE 43, PAGE 55
2)		  ITERR (TCPX44)	;no
2)		MOVEI T1,1		;get a postive number
2)		MOVEM T1,ARPSRQ		;request to read ARP counters
2)		AOS INTFLG		;ask for the internet fork to run
2)		MOVEI T1,ARPTRS		;get the request done word adr


LINE 5, PAGE 52
1)	;Returns to user +1 failure, T1/ error code
1)	;		 +2 success, T1/ terminal designator
1)	
1)	;Note that the error codes need to be updated for the TCP: device
1)	
1)		SWAPCD
1)	
1)	TVTJFN::STKVAR <ATNJFN,ATNJCN,ATNERR>
1)		XCTU [HRRZ JFN,1]	;get user's JFN without flags
LINE 5, PAGE 56
2)	; ACs setup as by CHKJFN
2)	;Returns to user +1 failure, T1/ error code
2)	;		 +2 success, T1/ terminal designator
2)	; 
2)	;Note that the error codes need to be updated for the TCP: device
2)	
2)	TVTJFN::STKVAR <ATNJFN,ATNJCN,ATNERR>
2)	REPEAT 0,<
2)		;; This is all done by .ATNVT
2)		XCTU [HRRZ JFN,1]	;get user's JFN without flags


LINE 18, PAGE 52
1)		MOVEM JFN,ATNJFN	;save internal JFN
1)		HRRZ T1,FILDEV(JFN)	;get DTB
1)		CAIE T1,TCPDTB		;is it the TCP: device?
1)		 ERUNLK(ATNX10)		;no, "Send JFN is not a NET connection"
1)		TQNN OPNF		;JFN is open?
LINE 19, PAGE 56
2)		HRRZ T1,FILDEV(JFN)	;get DTB
2)		CAIE T1,TCPDTB		;is it the TCP: device?
2)		 ERUNLK(ATNX10)		;no, "Send JFN is not a NET connection"

; TCPJFN.MAC.1 & <BBN-MONITOR>TCPJFN.MAC.1 20-Aug-87 0007	PAGE 48


2)	>
2)		MOVEM JFN,ATNJFN	;save internal JFN index
2)		TQNN OPNF		;JFN is open?


LINE 39, PAGE 52
1)		IFE REL6,<CALL TATTVT>	;try to attach to a TVT
1)		IFN REL6,<CALLX (XCDSEC,TATTVT)> ;try to attach to a TVT
1)		IFNSK.
LINE 41, PAGE 56
2)		CALL TATTVT		;try to attach to a TVT
2)		IFNSK.


LINE 67, PAGE 52
1)	
1)	^L	SUBTTL String Length Subroutine
1)	
1)	IFE REL6,<SWAPCD>
1)	IFN REL6,<XSWAPCD>
1)	
LINE 1, PAGE 57
2)	^L	SUBTTL String Length Subroutine
2)	


LINE 31, PAGE 53
1)		SKIPE TCPON		;tcp on?
1)		 SKIPN TCPIFG		;and tcp initialized?
1)		  RET			;no so no skip return
LINE 28, PAGE 58
2)		SKIPL TCPON		;tcp on?
2)		  RET			;no so no skip return


LINE 4, PAGE 54
1)					;from release 5 and release 6
LINE 4, PAGE 59
2)	;cwl noint here or not??
2)					;from release 5 and release 6


LINE 38, PAGE 54
1)		TXZ T1,<777777,,777740> ;turn off unwanted bits
1)		CAILE T1,ERTMAX 	;error code we know about?
1)		 SETZ T1,		;no so fix it up
1)		MOVE T1,ERTABL(T1)	;get the new error code
1)		RET			;and return to caller
1)	
1)	ERTABL:	EXP TCPX25,TCPX25,TCPX25,TCPX30,TCPX20,TCPXX3,TCPX19,TCPX31
1)		EXP TCPX25,TCPX32,TCPX25,TCPX25,TCPX33,TCPXX8,TCPX25,TCPX25

; TCPJFN.MAC.1 & <BBN-MONITOR>TCPJFN.MAC.1 20-Aug-87 0007	PAGE 49


LINE 39, PAGE 59
2)		CAIL T1,600000		; Already a Tops-20 error code?
2)		 CAILE T1,607777
2)		IFNSK.			; No, must translate
2)		  TXZ T1,<777777,,777740> ;turn off unwanted bits
2)		  CAILE T1,ERTMAX 	;error code we know about?
2)		   SETZ T1,		;no so fix it up
2)		  MOVE T1,ERTABL(T1)	;get the new error code
2)		ENDIF.
2)		RET			;and return to caller
2)	
2)	ERTABL:	EXP TCPX25,TCPX25,TCPX47,TCPX30,TCPX20,TCPXX3,TCPX19,TCPX31
2)		EXP TCPX25,TCPX32,TCPX25,TCPX25,TCPX33,TCPXX8,TCPX25,TCPX25


LINE 52, PAGE 54
1)	IFE STANSW,<
1)		CALL NETNCT		;lookup the host number
1)	>;IFE STANSW
1)	IFN STANSW,<;;; Make sure we pick an interface tha tis UP
1)		CALL FNDNCT		;lookup the host number
1)	>;IFN STANSW
1)		 RET			;error return
LINE 57, PAGE 59
2)		CALL NETNCT		;lookup the host number
2)		 RET			;error return


LINE 64, PAGE 54
1)	
1)	LINE 64, PAGE 59
2)	