

; TCPBBN.MAC.1 & <BBN-MONITOR>TCPBBN.MAC.1  9-Mar-88 1334	PAGE 1



LINE 1, PAGE 1
1)	;PS:<6-1-MONITOR>TCPBBN.MAC.13,  9-Mar-86 17:16:16, Edit by BILLW
1)	; undo TSOPS bit setting.
1)	;PS:<6-1-MONITOR>TCPBBN.MAC.11, 24-Oct-85 03:47:00, Edit by BILLW
1)	; In SEND, set the "a packet has been sent" bit (TSOPS)
1)	;PS:<6-1-MONITOR>TCPBBN.MAC.10, 23-Oct-85 21:11:45, Edit by BILLW
1)	; initialize TSMRT time in ACTTCB
1)	;<6-1-MONITOR.FT6>TCPBBN.MAC.3, 12-Aug-85 18:01:49, Edit by WHP4
1)	;Stanford changes:
1)	; Use global job numbers in TOWNR
1)	;
1)	; UPD ID= 2194, SNARK:<6.1.MONITOR>TCPBBN.MAC.8,   5-Jun-85 11:11:23 by MCCOLLUM
1)	;TCO 6.1.1406  - Update copyright notice.
1)	; UPD ID= 1747, SNARK:<6.1.MONITOR>TCPBBN.MAC.7,  10-Apr-85 10:46:46 by PAETZOLD
1)	;Document BUGxxx's
1)	; UPD ID= 1569, SNARK:<6.1.MONITOR>TCPBBN.MAC.6,  26-Feb-85 17:17:24 by PAETZOLD
1)	;Document BUGxxx's
1)	; UPD ID= 1086, SNARK:<6.1.MONITOR>TCPBBN.MAC.5,  16-Nov-84 16:27:28 by PAETZOLD
1)	;More TCO 6.1041 - Make the GTOKM conditional
1)	; UPD ID= 1040, SNARK:<6.1.MONITOR>TCPBBN.MAC.4,  12-Nov-84 15:26:32 by PAETZOLD
1)	;TCO 6.1041 - Move ARPANET to XCDSEC
1)	; UPD ID= 288, SNARK:<TCPIP.5.4.MONITOR>TCPBBN.MAC.2,  24-Sep-84 13:55:27 by PURRETTA
1)	;Update copyright notice.
1)	; UPD ID= 4024, SNARK:<6.MONITOR>TCPBBN.MAC.11,  31-Mar-84 16:21:36 by PAETZOLD
1)	;TCO 6.2019 - Use ADJSPs
1)	; UPD ID= 3916, SNARK:<6.MONITOR>TCPBBN.MAC.10,  13-Mar-84 08:06:34 by PAETZOLD
LINE 1, PAGE 1
2)	;Merge CMU and BBN code
2)	;<MONITOR.CMU>TCPBBN.MAC.3, 14-Aug-85 05:57:20, Edit by VAF
2)	;CS147 Add an MNTM5 where needed.
2)	;<MONITOR.CMU>TCPBBN.MAC.2, 18-Jul-85 13:33:01, Edit by VAF
2)	; CS62	Restrict listening ports even if ACJ OK's. This is necessary because
2)	;	ACJ cannot know if the connection is active or not.
2)	;	Return real errors for ACJ denial and Net Wizard required
2)	;-------
2)	;Pass open flags to ACJ
2)	; UPD ID= 3916, SNARK:<6.MONITOR>TCPBBN.MAC.10,  13-Mar-84 08:06:34 by PAETZOLD


LINE 36, PAGE 1
1)	;<TCPIP.5.3.MONITOR>TCPBBN.MAC.5,  6-Dec-83 23:58:40, Edit by PAETZOLD
1)	;Add an ACJ call in .OPEN
1)	;Make HISTOGRAM symbols conditional
1)	;More TCO 6.1733 - Bug fixes.
1)	;TCO 6.1689 - Move fork tables to extended sections.  Fix FKPGS reference.
1)	;<TCPIP.5.1.MONITOR>TCPBBN.MAC.21,  5-Jul-83 22:30:57, Edit by PAETZOLD
LINE 21, PAGE 1
2)	;[BBNF]<TAPPAN.MERGE>TCPBBN.MAC.5, 26-Jan-84 12:09:46, Edit by: TAPPAN
2)	; Merge with stanford changes

; TCPBBN.MAC.1 & <BBN-MONITOR>TCPBBN.MAC.1  9-Mar-88 1334	PAGE 2


2)	; UPD ID= 3177, SNARK:<6.MONITOR>TCPBBN.MAC.6,  16-Nov-83 21:34:49 by PAETZOLD
2)	;Make HISTOGRAM symbols conditional
2)	; UPD ID= 2996, SNARK:<6.MONITOR>TCPBBN.MAC.5,   5-Oct-83 14:50:36 by PAETZOLD
2)	;More TCO 6.1733 - Bug fixes.
2)	; UPD ID= 2791, SNARK:<6.MONITOR>TCPBBN.MAC.4,   3-Aug-83 13:23:35 by PAETZOLD
2)	;TCO 6.1689 - Move fork tables to extended sections.  Fix FKPGS reference.
2)	; UPD ID= 2716, SNARK:<6.MONITOR>TCPBBN.MAC.3,  22-Jul-83 14:52:54 by PAETZOLD
2)	;TCO 6.1733 - Merge TCP/IP changes in release 6 again
2)	;<TCPIP.5.1.MONITOR>TCPBBN.MAC.21,  5-Jul-83 22:30:57, Edit by PAETZOLD


LINE 3, PAGE 2
1)	;THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY  BE  USED
1)	;OR COPIED ONLY IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
1)	;
1)	;COPYRIGHT  (C)  DIGITAL  EQUIPMENT  CORPORATION  1976, 1985.
1)	;ALL RIGHTS RESERVED.
1)	
1)	
1)		SEARCH	ANAUNV,PROLOG
1)		TTITLE	(TCPBBN,TCPBBN,< - BBN TCP JSYS Interface Routines>)
1)		IFNDEF REL6,<REL6==1>
1)	
LINE 3, PAGE 2
2)	;THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY ONLY BE USED
2)	;  OR COPIED IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
2)	;
2)	;COPYRIGHT (C) 1982,1983,1984,
2)	;BY DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
2)	
2)		SEARCH	ANAUNV,PROLOG
2)		TTITLE	(TCPBBN,TCPBBN,< - BBN TCP JSYS Interface Routines>)
2)		IFNDEF REL6,<REL6==0>
2)	
2)	FX==Q3					; Must agree with PROLOG, PAGEM
2)	


LINE 24, PAGE 2
1)	IFE REL6,<SWAPCD>
1)	IFN REL6,<XSWAPCD>
1)	
1)	STSFLG==TCP%IX!TCP%NI!TCP%NT!TCP%SD!TCP%ST!TCP%SY!TCP%TV ; Frequent constant
1)	
1)	^L	SUBTTL Send JSYS - Send a Buffer
1)	
1)	;T1/	Flags,,JCN (or Pointer to Connection Descriptor)
1)	;T2/	Pointer to buffer header
1)	;T3/	Timeout (in seconds) (0 is infinite)
1)	;T4/	RX parameters
1)	;	SEND%

; TCPBBN.MAC.1 & <BBN-MONITOR>TCPBBN.MAC.1  9-Mar-88 1334	PAGE 3


1)	;Ret+1:	 Error, Code in T1
1)	;Ret+2:	Success
1)	
1)	IFE REL6,<.SEND::>
1)	IFN REL6,<XNENT .SEND,G>
1)		MCENT			; Enter monitor context
1)		TXNE T1,<STSFLG!TCP%FS!TCP%PS!TCP%VT>&^-<TCP%JS!TCP%WT!TCP%HP>
1)	         JRST TCPILP		; Illegal control bit
1)		XMOVEI T1,SEND1		; Routine to call via CHKARG
1)		CALL CHKARG		; Check arguments, set TCB, call SEND1
1)		JUMPL T1,TCPERR		; Error.
1)		UMOVE T1,T1		; Get the Flags
1)		TLNN T1,(TCP%WT)	; Supposed to wait?
1)	         JRST SKMRTN		; No.  Give immediate skip return
1)	SENDW:	LOAD T1,BIDX,(BFR)	; Buffer Done Flag Index
1)		LOAD T2,TERRF,(TCB)	; Error Flag index
1)		ROT T2,-<WID(TERRF)>	; Put in high bits of T2
1)		LSHC T1,^D18+<WID(TERRF)> ; Build bfr,err,,INTOOT
1)		HRRI T1,INTOOT		; Select SEND Done Test routine
1)		MDISMS			; Wait for either to come on
1)		XMOVEI T1,SENDP2	; Code to do Send checking w/ tcb locked
1)		CALL CHKARG		; Do tcb lookup in case it's gone
1)		JUMPL T1,TCPERR		; Jump if error
1)		JUMPE T1,SKMRTN		; Skip return if conn open
1)		HRLS T1			; Conn closing, move wait bits to lh
1)		HRRI T1,INTZOT		; Select close done test
1)		MDISMS			;
1)		XMOVEI T1,TCJFRE	; Code to do cleanup w/ tcb locked
1)		CALL CHKARG		; Do tcb lookup in case it's gone
1)		JUMPL T1,TCPERR		; Jump if error
1)		SMRETN			; All done, skip return
1)	
1)	SENDP2:	LOAD T1,TERR,(TCB)	; Get possible error
1)		JUMPN T1,[HRROS T1	; If error,
1)			RET ]		; ... return -1,,error in 1.
1)		JE TSUOP,(TCB),SENDP3	; Jump if conn closing already
1)		CALL FREBFR		; Conn open, release buffer resources
1)		SETZ T1,		; Return 0 in t1.
1)		RET
1)	
1)	SENDP3:				; Get wait bits for close wait test
1)		LOAD T1,TOPNF,(TCB)	; Get ID of Open Flag for this TCB
1)		LOAD T2,TERRF,(TCB)	; Error Flag index
1)		ROT T2,-<WID(TERRF)>	; Put in high bits of T2
1)		LSHC T1,<WID(TERRF)>	; Put opn,err in rh of T1.
1)		RET			; Ret index bits to wait on
1)	
1)	TCJFRE:	CALL FREBFR		; Release resources
1)		LOAD T1,TERR,(TCB)	; Get possible error
1)		JUMPE T1,R		; Return 0 in T1 if no error
1)		HRROS T1		;

; TCPBBN.MAC.1 & <BBN-MONITOR>TCPBBN.MAC.1  9-Mar-88 1334	PAGE 4


1)		RET			; Ret with -1,,error in T1.
1)	
1)	TCPERR:	ANDI T1,-1		; Save just the error code
1)	TCPERO:	UMOVEM T1,T1		; Pass to user
1)		JRST EMRET1		; Give no-skip return.  Do not update LSTERR
1)	
1)	TCPILP:	HRROI T1,ELP+^D1	; Illegal parameter (control bit)
1)		JRST TCPERR
1)	
1)	^L	SUBTTL Send JSYS - Send a Buffer - Second Phase
1)	
1)	;T1/	JCN specified by caller
1)	;TCB/	(Extended) Pointer to locked connection block
1)	;   	NOINT
1)	;	CALL SEND1
1)	;Ret+1:	Always, T1 has 0 and BFR has the buffer, or T1 has -1,,error
1)	
1)	SEND1:	JN TTVT,(TCB),SEND8	; Not allowed for TVTs
1)		LOAD T3,TSSYN,(TCB)
1)		CAIE T3,NOTSYN
1)		CAIN T3,FINSNT		; Closed or closing?
1)	         JRST SEND6		; Give error
1)		SETZ T2,		; Not allow options from CDB here
1)		CALL ACTTCB		; Try to activate the TCB (JCN in T1)
1)		JUMPL T1,SEND6		; Can't
1)		XCTU [HRRZ T2,2]	; Get user buffer header address
1)		SETZ T1,
1)		JE TNUFM,(TCB),SEND3	; Skip if old format
1)		UMOVE T1,.TCPBI(T2)	; Get IP info
1)		UMOVE T2,.TCPBO(T2)	; Get user option addresses word
1)		TRNE T1,777		; Specified?
1)	         STOR T1,TTOS,(TCB)	; Yes, Save type of service
1)		HLRS T1
1)		TRNE T1,.RTJST(-1,PITTL) ; User specify non-zero time?
1)	         STOR T1,TTTL,(TCB)	; Yes, Save Time to live
1)		LSH T1,^D<-18+2>	; Top two bits
1)		TRNE T1,3
1)	         STOR T1,TIFDF,(TCB)	; Don't fragment
1)		MOVE T1,T2		; Option addresses
1)	SEND3:
1)	
1)	; Should options be synchronous or asynchronous??
1)	
1)		SKIPE T1		; Have options?
1)		 CALL TCPUOP		; Yes
1)		  JUMPL T1,SENDX	; Error in options
1)		CALL MAKBFR		; Make a buffer descriptor
1)		SKIPGE BFR,T1		; Error?
1)	         EXIT SENDX		; Yes.  Code in T1.
1)		UMOVE T3,T3		; Get the Send Timeout from user
1)		JUMPE T3,SEND4		; He says infinite.  Don't set it.

; TCPBBN.MAC.1 & <BBN-MONITOR>TCPBBN.MAC.1  9-Mar-88 1334	PAGE 5


1)		CAMLE T3,TCPPTM		; Be sure it is reasonable for add to TODCLK
1)	         MOVE T3,TCPPTM
1)		IMULI T3,^D1000		; Convert to milliseconds
1)		STOR T3,TSTO,(TCB)	; Set new value in TCB
1)	SEND4:
1)	^L
1)		UMOVE T1,T4		; Get Retrans. parameter word
1)		CALL RXPARS		; Change them in TCB
1)		MOVE T1,BFR		; What to Enqueue
1)		XMOVEI T2,TCBSBQ(TCB)	; Queue head for send buffers
1)		CALL NQ			; Enqueue it for Packetizer.
1)		LOAD T1,BICNT,(BFR)	; Initial count
1)		LOAD T2,TSBYT,(TCB)	; Currently queued for PZ
1)		ADD T2,T1
1)		STOR T2,TSBYT,(TCB)	; More...
1)		MOVE T1,BFRFLG(BFR)	; Get the buffer flags
1)		TXNN T1,TCP%UR		; URGENT send?
1)		  JRST SEND43		; No.
1)		CALL SETURP		; Yes.  Set the send urgent pointer
1)	SEND43:
1)		LOAD T1,TSLFT,(TCB)	; Current Send Left
1)		LOAD T2,TSSEQ,(TCB)	; Current Send Sequence
1)		LOAD T3,TSWND,(TCB)	; Current Send Window
1)		ADD T3,T1		; Current Right
1)		MODSEQ T3
1)		CALL CHKWND		; See if there is space in the window
1)		JUMPE T1,SEND5		; Jump if not.  Recv'd ACK will restart.
1)		$SIGNL(PZ,0)		; Make Packetizer run now
1)	SEND5:
1)		TDZA T1,T1		; Say OK to caller
1)	SEND6:	  HRROI T1,ELP+^D12	; "Connection Closing"
1)	SENDX:	RET
1)	SEND8:	HRROI T1,ELP+^D30	; Only internet fork can run TVTs
1)		RET
1)	
LINE 25, PAGE 2
2)		SWAPCD
2)	
2)	; Frequent constants
2)	STSFLG==TCP%IX!TCP%NI!TCP%NT!TCP%SD!TCP%ST!TCP%SY!TCP%SL!TCP%TV
2)	OPNFLG==TCP%FS!TCP%PS!TCP%VT!TCP%IC!TCP%RX!TCP%FR  ;OPEN% only flags
2)	
2)	; Resource deallocation routines
2)	
2)	TCPKJB==:R		; No specific TCP routine when a job is killed
2)	
2)	^L	SUBTTL SEND% JSYS - Send a Buffer
2)	
2)	;T1/	Flags,,JCN
2)	;T2/	Pointer to buffer header
2)	;T3/	User Timeout (in seconds) (0 is infinite, max is TCPPTM)

; TCPBBN.MAC.1 & <BBN-MONITOR>TCPBBN.MAC.1  9-Mar-88 1334	PAGE 6


2)	;T4/	RX parameters
2)	;	SEND%
2)	;Ret+1:	 Error, Code in T1
2)	;CHKARG	ELP+^D01 ; JCN out of range/no TCB, Illegal connection/control bit
2)	;TCPUOP	ELP+^D02 ; Error in option length
2)	;CHKARG	ELT+^D04 ; No free JCN/TCB space/free WAIT bit/free TVTs
2)	;	ELP+^D12 ; Attempt to SEND% after CLOSE%
2)	;CHKARG	ELP+^D13 ; Invalid local address/port(LP=0)
2)	;MAKBFR	ELP+^D15 ; Bad buffer arg(s) (Count<0, Adr last word>=1,,0)
2)	;MAKBFR	ELT+^D16 ; No free WAIT bit(s)/space for buffer header
2)	;	ELP+^D30 ; Must be internet fork to use TCP%VT
2)	;CHKARG	ELT+^D31 ; TCP not yet initialized
2)	; Net related errors if TCP%WT
2)	;CHKADD	-1,,ELP+^D05 ; Packet with wild FH/FP
2)	;CHKADD	-1,,EFP+^D07 ; No such TCB
2)	;Ret+2:	Success
2)	
2)	.SEND::	MCENT			; Enter monitor context
2)		SETZ FR,		; No flags
2)		TXNE T1,TCP%JS		; JCN must be supplied
2)		 TXNE T1,<STSFLG!OPNFLG>&^-<TCP%JS!TCP%WT!TCP%HP>
2)	          JRST TCPILP		; Illegal control bit
2)	
2)	MNTM5	AOS CELL(TCJSN,0,,TCJ)	; Count SEND%s
2)	
2)		MOVE T2,T1		; User's AC 1
2)		XMOVEI T1,SEND1		; Routine to call via CHKARG
2)		TXO T1,<001B8>		; Send/phase 1
2)		CALL CHKARG		; Check arguments, set TCB, call SEND1
2)		JUMPL T1,TCPERR		; Error.
2)					; T1/ 0,,BIDX,TERRF
2)	MNTM5	AOS CELL(TCJSN,1,,TCJ)	; Count SEND1 successes
2)	
2)		UMOVE T2,1		; Get User's Flags
2)		SKIPE T1		; Cannot wait if do not have wait indicies
2)		 TXNN T2,TCP%WT		; Supposed to wait?
2)	          SMRETN		; No.  Give immediate skip return
2)	
2)	MNTM5	AOS CELL(TCJSN,2,,TCJ)	; Count SEND% waits
2)	
2)		HRLS T1			; BIDX,TERF,,...
2)		HRRI T1,INTOOT		; Select SEND% Done Test routine
2)		MDISMS			; Wait for buffer-done or error
2)	^L
2)		XMOVEI T1,SENDP2	; Code to do Send checking w/ tcb locked
2)		TXO T1,<002B8>		; SEND%/phase 2
2)		UMOVE T2,1		; User's AC 1
2)		CALL CHKARG		; Do tcb lookup in case it's gone
2)		JUMPL T1,TCPERR		; Jump if error during SEND% wait
2)					; CELL( TCJSN,2 - TCJSN,3 errors in SEND1
2)	MNTM5	AOS CELL(TCJSN,3,,TCJ)	; SEND% wait completed w/o error & still open

; TCPBBN.MAC.1 & <BBN-MONITOR>TCPBBN.MAC.1  9-Mar-88 1334	PAGE 7


2)		JUMPE T1,SKMRTN		; Ok return - SEND% wait complete w/o error
2)	
2)	MNTM5	AOS CELL(TCJSN,4,,TCJ)	; Connection closing during SEND% wait
2)		HRLS T1			; Conn closing, TOPNF,TERRF,,0
2)		HRRI T1,INTZOT		; Select close done test
2)		MDISMS			; Wait for closed or error
2)	
2)		XMOVEI T1,TCJFRE	; Code to do cleanup w/ tcb locked
2)		TXO T1,<003B8>		; SEND%/phase 3
2)		UMOVE T2,1		; User's AC 1
2)		CALL CHKARG		; Do tcb lookup in case it's gone
2)		JUMPL T1,TCPERR		; Jump if error
2)					; CELL( TCJSN,4 - TCJSN,5 SEND% close error
2)	MNTM5	AOS CELL(TCJSN,5,,TCJ)	; Close w/o error within SEND%
2)		SMRETN			; All done, skip return
2)	
2)	
2)		SUBTTL SEND% JSYS - Send a Buffer - Phase 1
2)	
2)	;T1/	JCN specified by caller
2)	;TCB/	Extended Pointer to locked connection block
2)	;   	NOINT
2)	;	CALL SEND1
2)	;Ret+1:	Always, T1 has 0,,BIDX,TERF and BFR has the buffer, or T1 has -1,,error
2)	;TCPUOP	-1,,ELP+^D02 ; Error in option length
2)	;	-1,,ELP+^D12 ; Attempted SEND% after connection was CLOSE%ed
2)	;MAKBFR	-1,,ELP+^D15 ; Bad buffer arg(s) (Count lt 0, Adr last word ge 1,,0)
2)	;MAKBFR	-1,,ELT+^D16 ; No free WAIT bit(s)/space for buffer header
2)	;	-1,,ELP+^D30 ; Must be internet fork to use TCP%VT
2)	
2)	SEND1:	INCRNO TCSND,(TCB)	; Count user sends
2)		LOAD FR,TERRT,(TCB)	; Want error trace?
2)		SKIPE FR		; No
2)		  MOVX FR,1B0		; Yes
2)	
2)		IFQN. TTVT,(TCB)	; If TVT
2)		  HRROI T1,ELP+^D30	; Only internet fork can run TVTs
2)		  RET
2)		ENDIF.
2)	
2)		IFQE. TSUOP,(TCB)	; Closing - PZ may not have sent the FIN yet
2)		  HRROI T1,ELP+^D12	; "Connection Closing"
2)		  RET
2)		ENDIF.
2)	^L
2)		XMOVEI T3,TCBSBQ(TCB)	; Queue head for send buffers
2)		LOAD T3,QCNT,(T3)	; Get current size
2)		LOAD T4,TPSMH		; Get maximum we are willing to hold
2)		CAMGE T3,T4		; Are we at or beyond the maximum?
2)		IFSKP.
2)		  HRROI T1,ELT+^D04	; Yes, Return Temp Resource Shortage

; TCPBBN.MAC.1 & <BBN-MONITOR>TCPBBN.MAC.1  9-Mar-88 1334	PAGE 8


2)		  RET			;  Error
2)		ENDIF.
2)	
2)	MNTM5	AOS CELL(TCJSN,10,,TCJ)	; Count permissible SEND%s
2)	
2)		SETZ BFR,		; Assume no buffer here
2)	
2)		UMOVE T1,4		; Get Retrans. parameter word
2)		CALL RXPARS		; Change them in TCB
2)	
2)		UMOVE T3,3		; Get the User Timeout from user
2)		IFN. T3			; Finite time specified
2)		  CAMLE T3,TCPPTM	; Be sure it is reasonable for add to TODCLK
2)	           MOVE T3,TCPPTM
2)		  CAIGE T3,0		; Must be positive
2)		    SETZ T3,
2)		  IMULI T3,^D1000	; Convert to milliseconds
2)		  STOR T3,TSTO,(TCB)	; Set new value in TCB
2)		ENDIF.
2)	
2)		XCTU [HRRZ T2,2]	; Get user buffer header address
2)		JUMPE T2,R		; No user specified a data buffer, done
2)	
2)	;Process user's data buffer
2)	
2)		IFQN. TNUFM,(TCB)	; New format buffer
2)	MNTM5	  AOS CELL(TCJSN,11,,TCJ) ; Count new format SEND%s
2)		  XCTU [HRRZ T2,2]	; Get user buffer header address
2)		  UMOVE T1,.TCPBI(T2)	; Get IP info
2)		  TRNN T1,777		; Specified? NB: 400 means zero
2)		  IFSKP.
2)		    STOR T1,TTOS,(TCB)	; Yes, Save type of service
2)		    SETONE TTOSU,(TCB)	; Remember user set it
2)		  ENDIF.
2)		  HLRS T1
2)		  TRNE T1,.RTJST(-1,PITTL) ; User specify non-zero time?
2)		    STOR T1,TTTL,(TCB)	; Yes, Save Time to live
2)		  LSH T1,^D<-18+2>	; Top two bits
2)		  TRNE T1,3		; NB: 2 means zero
2)		    STOR T1,TIFDF,(TCB)	; Don't fragment
2)	^L
2)	; Should options be synchronous or asynchronous??
2)	
2)		  UMOVE T1,.TCPBO(T2)	; Get user option addresses word
2)		  IFN. T1		; Have options
2)		    CALL TCPUOP		; Yes
2)		    JUMPL T1,R		; Error in options, T1/ error code
2)		    MOVX T1,PT%TOO	; Send options processed
2)		    TXNN FR,1B0		; TCB trace or
2)		     TDNE T1,MNTRAC	; Want trace?
2)		      CALL PRNPKT	; Yes

; TCPBBN.MAC.1 & <BBN-MONITOR>TCPBBN.MAC.1  9-Mar-88 1334	PAGE 9


2)		  ENDIF.		; Have options
2)		ENDIF.			; End of new format
2)	
2)	;All error checking done, actually build the Buffer
2)	
2)		MOVX T1,<0>;"PTRD"	; How check read access?
2)		CALL MAKBFR		; Make a buffer descriptor
2)		SKIPGE BFR,T1		; Error?
2)		  RET			; Yes.  Code in T1.
2)	
2)		XMOVEI T1,BFRQ(BFR)	; What to Enqueue
2)		XMOVEI T2,TCBSBQ(TCB)	; Queue head for send buffers
2)		CALL NQ			; Enqueue it for Packetizer.
2)	
2)		LOAD T2,BICNT,(BFR)	; Initial count
2)		LOAD T1,TSBYT,(TCB)	; Currently queued for PZ
2)		ADD T1,T2		; Additional data in this buffer
2)		STOR T1,TSBYT,(TCB)
2)	
2)		MOVE T2,BFRFLG(BFR)	; Get the buffer flags
2)		IFXN. T2,BPSH		; User specify PUSH?
2)		  INCRNO TSBFP,(TCB)	; Increment count of buffers with PUSH
2)		ENDIF.
2)	
2)		IFXN. T2,BURG		; URGENT send?
2)		  CALL SETURP	;(T1)	; Yes.  Set the send urgent pointer
2)		  INCRNO TCSUR,(TCB)	; Count urgent sends
2)		ENDIF.
2)	
2)		MOVX T1,PT%TSD		; Send buffer
2)		TXNN FR,1B0		; TCB trace or
2)		 TDNE T1,MNTRAC		; Want trace?
2)		  CALL PRNPKT		; Yes
2)	
2)		LOAD T1,TSLFT,(TCB)	; Current Send Left
2)		LOAD T2,TSSEQ,(TCB)	; Current Send Sequence
2)		LOAD T3,TSWND,(TCB)	; Current Send Window
2)		IFQN. TDBGQ,(TCB)	; Faking zero?
2)		  SETZ T3,		; Yes
2)		ENDIF.
2)		ADD T3,T1		; Current Right
2)		MODSEQ T3
2)		CALL CHKWND		; See if there is space in the window
2)		IFN. T1			; Yes
2)	MNTM5	  AOS CELL(TCJSN,12,,TCJ) ; Count signals to PZ
2)		  $SIGNL(PZ,0)		; Make Packetizer run now
2)		ENDIF.
2)	^L
2)		LOAD T1,BIDX,(BFR)	; Buffer Done Flag Index
2)		LOAD T2,TERRF,(TCB)	; Error Flag index
2)		ROT T2,-<WID(TERRF)>	; Put in high bits of T2

; TCPBBN.MAC.1 & <BBN-MONITOR>TCPBBN.MAC.1  9-Mar-88 1334	PAGE 10


2)		LSHC T1,<WID(TERRF)>	; Build 0,,bfr,err
2)		RET			; Say OK to caller
2)	
2)		SUBTTL SEND% JSYS - Send a Buffer - Phase 2,  JSYS Error Exits
2)	
2)	;SEND%/Phase 2 -- wait for buffer-done or error completed
2)	
2)	SENDP2:	LOAD T1,TERR,(TCB)	; Get possible error
2)		JUMPN T1,TCJFRF		; If error, return -1,,error in 1.
2)	
2)		IFQE. TSUOP,(TCB)	; Connection has been CLOSEd
2)	
2)	;Connection has been CLOSE%ed, now wait for it to close or get an error
2)	
2)					; Get wait bits for close wait test
2)	MNTM5	  AOS CELL(TCJSN,7,,TCJ) ; Connection closing during SEND% wait
2)		  LOAD T1,TOPNF,(TCB)	; Get ID of Open Flag for this TCB
2)		  LOAD T2,TERRF,(TCB)	; Error Flag index
2)		  ROT T2,-<WID(TERRF)>	; Put in high bits of T2
2)		  LSHC T1,<WID(TERRF)>	; Put opn,err in rh of T1.
2)		  RET			; Return index bits for wait
2)		ENDIF.
2)	
2)	MNTM5	AOS CELL(TCJSN,6,,TCJ) ; Count SEND% wait completed ok, still UOPen
2)	
2)	
2)	;Release buffer resources
2)	
2)	TCJFRE:	CALL FREBFR		; Release resources
2)		LOAD T1,TERR,(TCB)	; Get possible error
2)		SKIPE T1		; Return 0 in T1 if no error
2)	TCJFRF:	  HRROS T1		; Make sure lh has -1 when error found
2)		RET			; Ret with -1,,error in T1.
2)	
2)	
2)	;General JSYS error exit routines
2)	
2)	TCPILP:	HRROI T1,ELP+^D01	; Illegal parameter (control bit)
2)	TCPERR:	ANDI T1,-1		; Save just the error code
2)	TCPERO:	UMOVEM T1,1		; Return error code
2)		MOVE T2,T1		; Error code for trace
2)		MOVE T3,TCB
2)	
2)		MOVE T4,T1		; BBN error code
2)		ANDI T4,37
2)		CAILE T4,ERTMAX 	; Error code we know about?
2)		 SETZ T4,		; No so fix it up
2)		MOVE T4,ERTAB(T4)	; Get the TOPS20 error code
2)		MOVEM T4,LSTERR		; For all to see
2)	
2)		MOVX T1,PT%TER		; TCP error

; TCPBBN.MAC.1 & <BBN-MONITOR>TCPBBN.MAC.1  9-Mar-88 1334	PAGE 11


2)		TXNN FR,1B0		; TCB trace or
2)		 TDNE T1,MNTRAC		; Want trace?
2)		  CALL PRNPKT		; Yes
2)		JRST EMRET1		; Give no-skip return.  Do not update LSTERR
2)	
2)	ERTAB:	EXP TCPX25,TCPX25,TCPX25,TCPX30,TCPX20,TCPXX3,TCPX19,TCPX31
2)		EXP TCPX25,TCPX32,TCPX25,TCPX25,TCPX33,TCPXX8,TCPX25,TCPX25
2)		EXP TCPXX1,TCPX34,TCPX25,TCPX25,TCPX34,TCPX34,TCPX34,TCPX25
2)		EXP TCPX25,TCPX25,TCPX25,TCPX25,TCPX25,TCPX34,TCPX25,TCPX16
2)		ERTMAX=.-ERTAB-1
2)	


LINE 9, PAGE 6
1)	;     	NOINT
LINE 9, PAGE 8
2)	;T1/	Total un-packetized byte count
2)	;     	NOINT


LINE 13, PAGE 6
1)	SETURP:	PUSH P,BFR		; Need this global for scanning buffers
1)		TEMP <CNT,NXT>		; Give names to T1, T2
1)		MOVEI CNT,0		; Assume no partial buffer
1)		LOAD BFR,TSCB,(TCB)	; Get partial buffer if any
1)		JUMPE BFR,SETUR1	; Jump if none
1)		SETSEC BFR,INTSEC	; Make extended address
1)		LOAD CNT,BCNT,(BFR)	; Get number of unsent bytes from bfr
1)	SETUR1:
1)		MOVEI NXT,TCBSBQ(BFR)	; Pointer to send buffer queue head
1)	SETUR2:	MOVE BFR,NXT		; Point bfr to what we will process
1)		CAIN BFR,TCBSBQ(BFR)	; Back to the queue head
1)		  JRST SETUR3		; Means done.  Go finish up.
1)		SETSEC BFR,INTSEC	; Make extended address
1)		LOAD NXT,QNEXT,+TCBSBQ(TCB) ; Get pointer to next item for next time
1)		LOAD T3,BCNT,(BFR)	; Get count from this buffer
1)		ADD CNT,T3		; Add into total
1)		JRST SETUR2		; Loop over entire queue, incl. bfr being sent
1)	SETUR3:
1)		LOAD T3,TSSEQ,(TCB)	; Next send seq. num. to be used
1)		ADD T1,T3		; Compute 1st non-urgent seq. num.
1)		MODSEQ T1		; Keep within the right number of bits
1)		STOR CNT,TSURP,(TCB)	; Set the urgent pointer into the TCB
1)		SETONE TSURG,(TCB)	; Say we are in send urgent mode
1)		POP P,BFR
1)		RESTORE
1)		RET
1)	
1)	^L	SUBTTL RECV JSYS - Receive a Buffer
1)	
LINE 14, PAGE 8

; TCPBBN.MAC.1 & <BBN-MONITOR>TCPBBN.MAC.1  9-Mar-88 1334	PAGE 12


2)	SETURP::
2)		JUMPLE T1,R		; Ignore zero or negative counts
2)	
2)	MNTM5	AOS CELL(TCJAA,1,,TCJ)	; Count SETURP calls
2)	
2)		LOAD T3,TSSEQ,(TCB)	; Next send seq. num. to be used
2)		IFQN. TTVT,(TCB)	; If a TVT,
2)		  LOAD T2,TSCPK,(TCB)	; Look for a packet being filled
2)		  SKIPE T2
2)		    LOAD T3,PESEQ,(T2)	; If one exists, base count on it's end
2)		ENDIF.
2)		ADDI T3,-1(T1)		; Compute last urgent seq. num.
2)		MODSEQ T3		; Keep within the right number of bits
2)		STOR T3,TSURP,(TCB)	; Set the urgent pointer into the TCB
2)		SETONE TSURG,(TCB)	; Say we are in send urgent mode
2)		RET
2)	
2)	^L	SUBTTL RECV% JSYS - Receive a Buffer
2)	


LINE 7, PAGE 7
1)	;Ret+2:	Success
1)	
1)	IFE REL6,<.RECV::>
1)	IFN REL6,<XNENT .RECV,G>
1)		MCENT			; Enter monitor context
1)		TXNE T1,<STSFLG!TCP%FS!TCP%PS!TCP%VT!TCP%HP!TCP%SC>&^-<TCP%JS!TCP%WT>
1)	         JRST TCPILP		; Illegal control bit
1)		XMOVEI T1,RECV1		; Routine to call via CHKARG
1)		CALL CHKARG		; Check arguments, set TCB, call RECV1
1)		JUMPL T1,TCPERR		; Error.
1)		UMOVE T1,T1		; Get flags
1)		TLNN T1,(TCP%WT)	; Supposed to wait?
1)	         SMRETN			; No.  Give immediate skip return
1)	RECVW:	LOAD T1,BIDX,(BFR)
1)		LOAD T2,TERRF,(TCB)	; Error Flag index
1)		ROT T2,-<WID(TERRF)>	; Put in high bits of T2
1)		LSHC T1,^D18+<WID(TERRF)>	; Put indexes in LH
1)		HRRI T1,INTOOT		; Select RECV done test routine
1)		MDISMS
1)		XMOVEI T1,TCJFRE	; Code to cleanup w/ tcb locked
1)		CALL CHKARG		; Do tcb lookup in case it's gone
1)		JUMPL T1,TCPERR		; Jump if error
1)		SMRETN			; Return skip to user
1)	
1)	^L	SUBTTL RECV JSYS - Receive a Buffer - Second Phase
1)	
1)	;T1/	JCN specified by caller
1)	;TCB/	(Extended) Locked connection block
1)	;     	NOINT

; TCPBBN.MAC.1 & <BBN-MONITOR>TCPBBN.MAC.1  9-Mar-88 1334	PAGE 13


1)	;	CALL RECV1
1)	;Ret+1:	Always.  T1 has 0 and BFR has the buffer, or T1 has-1,,error
1)	
1)	RECV1:	JN TTVT,(TCB),RECV8	; Not allow for TVTs
1)		LOAD T3,TRSYN,(TCB)	; Get receive state
1)		CAIE T3,NOTSYN		; Not synchronized
1)		 CAIN T3,FINRCV		; or FIN received?
1)		  JRST RECV9		; Yes.  Fail. (error code into buffer?)
1)		SETZ T2,		; Not allow options from CDB here
1)		CALL ACTTCB		; Try to activate the TCB (JCN in T1)
1)		JUMPL T1,RECV9		; Could not.
1)		CALL MAKBFR		; Make a buffer descriptor
1)		SKIPGE BFR,T1		; Check for error
1)	         EXIT RECVX		; There was one.
1)		LOAD T1,TRBS,(TCB)	; Current amount of receive buffer space
LINE 7, PAGE 9
2)	;CHKARG	ELP+^D01 ; JCN out of range/no TCB, Illegal connection/control bit
2)	;CHKARG	ELT+^D04 ; No free JCN/TCB space/free WAIT bit/free TVTs
2)	;	EFP+^D12 ; Connection CLOSING (received a FIN)
2)	;CHKARG	ELP+^D13 ; Invalid local address/port(LP=0)
2)	;MAKBFR	ELP+^D15 ; Bad buffer arg(s) (Count<0, Adr last word>=1,,0)
2)	;MAKBFR	ELT+^D16 ; No free WAIT bit(s)/space for buffer header
2)	;	ELP+^D30 ; Must be internet fork to use TCP%VT
2)	;CHKARG	ELT+^D31 ; TCP not yet initialized
2)	; Net related errors if TCP%WT
2)	;CHKADD	-1,,ELP+^D05 ; Packet with wild FH/FP
2)	;CHKADD	-1,,EFP+^D07 ; No such TCB
2)	;Ret+2:	Success
2)	
2)	.RECV::	MCENT			; Enter monitor context
2)		SETZ FR,		; No flags
2)	MNTM5	AOS CELL(TCJRV,0,,TCJ)	; Count RECV%s
2)		TXNE T1,TCP%JS		; JCN must be supplied
2)		 TXNE T1,<STSFLG!TCP%HP!TCP%SC!OPNFLG>&^-<TCP%JS!TCP%WT>
2)	          JRST TCPILP		; Illegal control bit
2)	
2)		HRROI T1,ELP+^D15	; Make sure have buffer
2)		JUMPE T2,TCPERR		; No buffer, error
2)	
2)		XMOVEI T1,RECV1		; Routine to call via CHKARG
2)		TXO T1,<011B8>		; RECV%/phase 1
2)		UMOVE T2,1		; User's AC 1
2)		CALL CHKARG		; Check arguments, set TCB, call RECV1
2)		JUMPL T1,TCPERR		; Error.
2)					; T1/ 0,,BIDX,TERF
2)	MNTM5	AOS CELL(TCJRV,1,,TCJ)	; Successful RECV1
2)		UMOVE T2,1		; Get flags
2)		TXNN T2,TCP%WT		; Supposed to wait?
2)	         SMRETN			; No.  Give immediate skip return
2)	
2)	MNTM5	AOS CELL(TCJRV,2,,TCJ)	; RECV% waits

; TCPBBN.MAC.1 & <BBN-MONITOR>TCPBBN.MAC.1  9-Mar-88 1334	PAGE 14


2)		HRLS T1			; BIDX,TERF,,...
2)		HRRI T1,INTOOT		; Select RECV% done test routine
2)		MDISMS
2)	
2)		XMOVEI T1,TCJFRE	; Code to cleanup w/ tcb locked
2)		TXO T1,<013B8>		; RECV%/phase 2
2)		UMOVE T2,1		; User's AC 1
2)		CALL CHKARG		; Do tcb lookup in case it's gone
2)		JUMPL T1,TCPERR		; Jump if error
2)	MNTM5	AOS CELL(TCJRV,3,,TCJ)	; RECV% wait completed ok
2)		SMRETN			; Return skip to user
2)	
2)	^L	SUBTTL RECV% JSYS - Receive a Buffer - Phase 1
2)	
2)	;T1/	JCN specified by caller
2)	;TCB/	Extended Locked connection block
2)	;     	NOINT
2)	;	CALL RECV1
2)	;Ret+1:	Always.  T1 has 0,,BIDX,TERF and BFR has the buffer, or T1 has-1,,error
2)	;	-1,,EFP+^D12 ; Connection CLOSING (received a FIN)
2)	;MAKBFR	-1,,ELP+^D15 ; Bad buffer arg(s) (Count < 0, Adr last word >= 1,,0)
2)	;MAKBFR	-1,,ELT+^D16 ; No free WAIT bit(s)/space for buffer header
2)	;	-1,,ELP+^D30 ; Must be internet fork to use TCP%VT
2)	
2)	RECV1:	INCRNO TCRCV,(TCB)	; Count user RECV%s
2)		LOAD FR,TERRT,(TCB)	; Want error trace?
2)		SKIPE FR		; No
2)		  MOVX FR,1B0		; Yes
2)	
2)		IFQN. TTVT,(TCB)	; Not allow for TVTs
2)		  HRROI T1,ELP+^D30	; Only internet fork can run TVTs
2)		  RET
2)		ENDIF.
2)	
2)		LOAD T3,TRSYN,(TCB)	; Get receive state
2)		CAIE T3,TIMWAT		; TIME-WAIT or
2)		 CAIN T3,FINRCV		; FIN received?
2)		IFSKP.			; No.
2)		  CAIN T3,NOTSYN	; Not synchronized?
2)		  ANSKP.		; No
2)					; Do nothing
2)		ELSE.			; Yes.  Fail.
2)		  HRROI T1,EFP+^D12	; "Connection Closing"
2)		  RET
2)		ENDIF.
2)	
2)		XMOVEI T3,TCBRBQ(TCB)	; Queue head for receive buffers
2)		LOAD T3,QCNT,(T3)	; Get current size
2)		LOAD T4,TPRMH		; Get maximum we are willing to hold
2)		CAMGE T3,T4		; Are we at or beyond the maximum?
2)		IFSKP.

; TCPBBN.MAC.1 & <BBN-MONITOR>TCPBBN.MAC.1  9-Mar-88 1334	PAGE 15


2)		  HRROI T1,ELT+^D04	; Yes, Return Temp Resource Shortage
2)		  RET			;  Error
2)		ENDIF.
2)	
2)	MNTM5	AOS CELL(TCJRV,4,,TCJ)	; RECV1 connection state ok
2)	
2)		MOVX T1,<PTWR>		; Writeable
2)		CALL MAKBFR		; Make a buffer descriptor
2)		SKIPGE BFR,T1		; Check for error
2)		  RET			; There was one.
2)	^L
2)	MNTM5	AOS CELL(TCJRV,5,,TCJ)	; RECV1 MAKBFR ok
2)	
2)		LOAD T1,TRBS,(TCB)	; Current amount of receive buffer space


LINE 24, PAGE 8
1)		MOVE T1,BFR		; Item to enqueue
1)		XMOVEI T2,TCBRBQ(TCB)	; Receive buffer queue head
1)		CALL NQ			; Enqueue this buffer there
1)		CALL NUWNDO		; Setup the new window, maybe ENCPKT
1)		JN TRPP,(TCB),RECV5	; Jump if partially process pkt waiting
1)		LOAD T1,QNEXT,<+TCBRPQ(TCB)>	; Ptr to 1st thing on RA queue
1)		CAIN T1,TCBRPQ(TCB)	; Empty queue?
1)	         JRST RECV6		; Yes.  No use running RA
1)	RECV5:
1)		JN TRCB,(TCB),RECV6	; No signal if RA already has a BFR
1)		LOAD T3,QNEXT,<+TCBRBQ(TCB)> ; Get next buffer on the queue
1)		SETSEC T3,INTSEC	; Make extended address
1)		CAME T3,BFR		; Will this new buffer restart RA?
1)	         JRST RECV6		; No.  No need to run RA
1)		$SIGNL(RA,0)		; Make Reassembler run now
1)	RECV6:
1)		TDZA T1,T1		; Say OK to caller
1)	RECV9:	 HRROI T1,ELP+^D12	; "Connection Closing"
1)	RECVX:	RET
1)	RECV8:	HRROI T1,ELP+^D30	; Only internet fork can run TVTs
1)		RET
1)	
1)	^L	SUBTTL OPEN JSYS - Open a Connection
1)	
1)	;T1/	Flags,,Pointer to Connection Descriptor Block (CDB)
1)	;T2/	Persistence, seconds (max is TCPPTM)
1)	;T3/	RX parameters
1)	;	OPEN%
1)	;Ret+1:	 Error.  T1 has <JCN,,code>.	ELP+^D1 - bad bit (TCP%JS)
1)	;Ret+2:	Success.
1)	
1)	IFE REL6,<.OPEN::>
1)	IFN REL6,<XNENT .OPEN,G>
1)		MCENT			; Enter the monitor context

; TCPBBN.MAC.1 & <BBN-MONITOR>TCPBBN.MAC.1  9-Mar-88 1334	PAGE 16


1)		CALL BBNCKK
1)		 RETERR	(TCPX28)	; not legal
1)	
1)	;Unprivileged  users  must  not be allowed to do a listening OPEN% on a
1)	;small port number, e.g. [0.xxx]. This avoids a user from grabbing some
1)	;server port, e.g. [0.23] (the TELNET port) and putting a trojan  horse
1)	;on  it  that gobbles down the user's password. It is really not enough
1)	;to ask the ACJ just based upon it being some TCP open. For example,  a
1)	;site  with  on  ARPANET and some local network may want to allow local
1)	;net access but not ARPA access. Another example are resources such  as
1)	;printing servers which may be accessed only by certain individuals.
1)	
1)	HOCTET==377B27			; high order octet in a port number
1)	
1)		UMOVE T1,1		; get users AC1
1)		TXNE T1,<STSFLG!TCP%JS>&^-<TCP%WT> ; JCN supplied is an error
1)	         JRST TCPILP		; Illegal control bit
1)		MOVE T3,FORKX		; get our fork number
1)		CAMN T3,INTFRK		; bypass check if we're the Internet fork
1)		IFSKP.
1)		  XCTU [HRRZ T3,T1]	; must check, get connection block pointer
1)		  IFXE. T1,TCP%FS	; active connection may have any port #
1)		    UMOVE T1,.TCPLP(T3)	; get requested local port
1)		  ANDXE. T1,HOCTET	; not active, if high octet zero need privs
1)		    JE <SC%WHL,SC%OPR,SC%NAS,SC%NWZ>,CAPENB,[RETERR (NTWZX1)]
1)		  ENDIF.
1)		  UMOVE T1,.TCPFH(T3)	; get foreign host number
1)		  UMOVE T2,.TCPFP(T3)	; get foreign port number
1)		  IFN REL6,<S1XCT <GTOKM (.GOANA,<T1,T2>,[RETERR ()])>> ; ask ACJ for its blessing
1)		  IFE REL6,<GTOKM (.GOANA,<T1,T2>,[RETERR ()])> ; ask ACJ for its blessing
1)		ENDIF.
1)		XMOVEI T1,OPEN1		; Routine to call via CHKARG
1)		CALL CHKARG		; Check arguments, set TCB, call OPEN1
1)		JUMPL T1,OPENE		; Jump if there was an error ?? JCN/TCB
1)		UMOVE T2,T1		; Get flags
1)		TLNE T2,(TCP%WT)	; Supposed to wait?
1)	         JRST OPENW		; Yes.
1)	OPENOK:	TLO T1,(TCP%JS)		; Turn on JCN Supplied bit for him
1)		UMOVEM T1,T1		; Give JCN to user
1)		SMRETN
1)	
1)	OPENW:	PUSH P,T1		; Save the JCN
1)		LOAD T1,TOPNF,(TCB)	; Get ID of Open Flag for this TCB
1)		LOAD T2,TERRF,(TCB)	; Error Flag index
1)		ROT T2,-<WID(TERRF)>	; Put in high bits of T2
1)		LSHC T1,^D18+<WID(TERRF)> ; Put indexes in LH
1)		HRRI T1,INTOOT		; Select OPEN Done Test
1)		MDISMS
1)		POP P,T1
1)		LOAD T2,TERR,(TCB)	; Get error code
1)		JUMPE T2,OPENOK		; Jump if no error

; TCPBBN.MAC.1 & <BBN-MONITOR>TCPBBN.MAC.1  9-Mar-88 1334	PAGE 17


1)		HRLZS T1		; JCN left half
1)		HRR T1,T2		; Put error code in right half
1)		SKIPA
1)	OPENE:	 TLZ T1,400000		; TURN OFF THE ERROR BIT
1)		JRST TCPERO
1)	
1)	^L	SUBTTL OPEN JSYS - Open a Connection - Second Phase
1)	
1)	;T1/	JCN resulting from CDB specified by caller
1)	;T2/	Option addresses word, or 0 if none specified
1)	;TCB/	(Extended) Locked connection block
1)	;    	NOINT
1)	;	CALL OPEN1
1)	;Ret+1:	Always.  T1 has -1,,error or the JCN
1)	;		-1,,ELP+^D6	Already open
1)	;		-1,,ELP+^D12	Closing (one side or other NOTSYN)
1)	;		-1,,ELP+^D30	TCP%VT not allowed by user jobs
1)	
1)	OPEN1::	LOCAL <USRAC1,JCN,UOPTS>
1)		MOVEM T1,JCN
1)		MOVEM T2,UOPTS
1)	        UMOVE USRAC1,T1		; get the flags
1)		TLNN USRAC1,(TCP%VT)	; Virtual terminal?
1)	         JRST OPEN1A		; Not a virtual terminal
1)		HRROI T1,ELP+^D30	; "Only Internet fork can run TVTs"
1)		MOVE T2,FORKX		; Which fork this is
1)		CAME T2,INTFRK		; The Internet fork?
1)	         JRST OPENX		; No.  Give error return
1)	OPEN1A:
1)		JN TSUOP,(TCB),OPEN6	; Jump if already open
1)		JN TLH,(TCB),OPEN1D	; If caller specified a local address use it
1)		LOAD T1,TFH,(TCB)	; Get foreign host
1)		JUMPE T1,OPEN1D
1)		PUSH P,P1		; Save AC
1)		CALL FNDNCT		; Get the NCT for that net
1)		 JRST [ POP P,P1	; Restore AC
1)			MOVE T1,DEFADR	; Use default address
1)			JRST OPEN1B]	; Join below
1)		MOVE T1,NTLADR(P1)	; get our address on that network
1)		POP P,P1		; Restore AC
1)	OPEN1B:
1)		STOR T1,TLH,(TCB)	; And stick it in the TCB
1)	OPEN1D:
1)		MOVE T1,JCN
1)		MOVE T2,UOPTS
1)		CALL ACTTCB		; Try to activate the TCB
1)		JUMPL T1,OPENX2		; Cannot
1)		SETONE TSUOP,(TCB)	; Mark the TCB as open
1)	^L
1)		JE TNUFM,(TCB),OPEN5	; Skip following if old format
1)		HRRZ T1,USRAC1		; Connection block address

; TCPBBN.MAC.1 & <BBN-MONITOR>TCPBBN.MAC.1  9-Mar-88 1334	PAGE 18


1)		UMOVE T1,.TCPIP(T1)	; Get IP parameter word
1)		STOR T1,TTOS,(TCB)	; Save type of service
1)		HLRS T1
1)		TRNE T1,.RTJST(-1,PITTL) ; User specify non-zero time?
1)	         STOR T1,TTTL,(TCB)	; Yes, Save Time to live
1)		LSH T1,^D<-18+2>	; Top two bits
1)		STOR T1,TIFDF,(TCB)	; Don't fragment
1)	OPEN5:
1)	        UMOVE T2,T2		; no get the send timeout from user
1)		JUMPE T2,OPEN4		; Don't change if no specification
1)		CAMLE T2,TCPPTM		; Be sure it is reasonable for add to TODCLK
1)	         MOVE T2,TCPPTM
1)		IMULI T2,^D1000		; Make into milliseconds
1)		STOR T2,TSTO,(TCB)	; Set the new value into the TCB
1)	OPEN4:
1)	        UMOVE T1,T3		; get retrans. parameter word
1)		CALL RXPARS		; Change them in TCB
1)		TLNN USRAC1,(TCP%VT)	; Openning as a virtual terminal?
1)		  JRST OPEN3		; No
1)		SETONE TTVT,(TCB)	; Yes.  Mark TCB as such
1)	OPEN3:
1)		TMNN TCDFS,(TCB)	; JFN interface want active?
1)		TLNE USRAC1,(TCP%FS)	; Supposed to force synchronization?
1)		  CALL FRCPKT		; Yes.  Packetizer will do that.
1)					; Should TSPRS be on allready?
1)		TLNN USRAC1,(TCP%PS)	; Supposed to be persistent?
1)		  JRST OPEN2		; No.
1)		SETONE TSPRS,(TCB)	; Yes, mark the TCB as such.
1)	OPEN2:
1)		MOVE T1,JCN		; Value to return
1)		EXIT OPENX
1)	
1)	;Returning an error is bad since connection is open & cannot return
1)	;both error and JCN,  either abort & return error or skip & return JCN
1)	
1)	OPEN6:	HRROI T1,ELP+^D6	; "Connection already open"
1)	OPENX2:				; Probably bad options
1)	OPENX:
1)		JUMPGE T1,OPENX3	; JUMP IF NO ERROR
1)		HRLI T1,(JCN)		; GET THE JCN FOR USER ABORT
1)		TLO T1,400000		; TURN ON THE ERROR BIT
1)	OPENX3:				; HERE WHEN NO ERROR
1)		RESTORE
1)		RET
1)	
1)	^L	SUBTTL CLOSE JSYS - Close a Connection
1)	
LINE 8, PAGE 11
2)	
2)		XMOVEI T1,BFRQ(BFR)	; Item to enqueue
2)		XMOVEI T2,TCBRBQ(TCB)	; Receive buffer queue head

; TCPBBN.MAC.1 & <BBN-MONITOR>TCPBBN.MAC.1  9-Mar-88 1334	PAGE 19


2)		CALL NQ			; Enqueue this buffer there
2)	
2)		MOVX T1,PT%TRD		; Receive buffer
2)		TXNN FR,1B0		; TCB trace or
2)		 TDNE T1,MNTRAC		; Want trace?
2)		  CALL PRNPKT		; Yes
2)	
2)		CALL NUWNDO		; Setup the new window, maybe ENCPKT
2)	
2)		IFQE. TRCB,(TCB)	; No signal if RA already had a BFR
2)		  IFQE. TRPP,(TCB)	; If no partially processed packet waiting
2)		    XMOVEI CX,TCBRPQ(TCB) ; Look for unprocessed packet
2)		    LOAD T1,QNEXT,(CX)	; Ptr to 1st packet on RA queue
2)		    CAME T1,CX		; Empty queue and
2)	            ANSKP.		; No unprocessed packets queued?
2)					; Yes, do nothing
2)		  ELSE.			; Have a partial or unprocessed packet
2)		    LOAD T3,QCNT,<+TCBRBQ(TCB)> ; How many buffers in the queue?
2)		    CAIE T3,1		; If more than one, nothing to do
2)	            IFSKP.		; Only buffer is one just added, so
2)		      $SIGNL(RA,0)	; Make Reassembler run now
2)	MNTM5	      AOS CELL(TCJRV,6,,TCJ) ; RECV1 signals to RA
2)		    ENDIF.
2)		  ENDIF.
2)		ENDIF.
2)	
2)		LOAD T1,BIDX,(BFR)
2)		LOAD T2,TERRF,(TCB)	; Error Flag index
2)		ROT T2,-<WID(TERRF)>	; Put in high bits of T2
2)		LSHC T1,<WID(TERRF)>	; Build 0,,bfr,err
2)		RET			; Say OK to caller
2)	
2)	^L	SUBTTL OPEN% JSYS - Open a TCP Connection
2)	
2)	;T1/	Flags,,Pointer to Connection Descriptor Block (CDB)
2)	;T2/	User Timeout, seconds (0 is no change, lt 0 is infinite, max is TCPPTM)
2)	;T3/	RX parameters
2)	;	OPEN%
2)	;Ret+1:	 Error.  T1 has <JCN,,code>.
2)	;CHKARG	ELP+^D01 ; JCN out of range/no TCB, Illegal connection/control bit
2)	;TCPUOP	ELP+^D02 ; Error in option length
2)	;CHKARG	ELT+^D04 ; No free JCN/TCB space/free WAIT bit/free TVTs
2)	;OPEN2	ELP+^D06 ; Connection already exists/open
2)	;	ELP+^D12 ; Connection CLOSING (one side or other NOTSYN)
2)	;CHKARG	ELP+^D13 ; Invalid local address/port(LP=0)
2)	;	ELP+^D30 ; Must be internet fork to use TCP%VT
2)	;CHKARG	ELT+^D31 ; TCP not yet initialized
2)	; Net related errors if TCP%WT
2)	;CHKADD	-1,,ELP+^D05 ; Packet with wild FH/FP
2)	;CHKADD	-1,,EFP+^D07 ; No such TCB
2)	;	    ELP+^D09 ; Transmission timeout (TCP%FS was set)

; TCPBBN.MAC.1 & <BBN-MONITOR>TCPBBN.MAC.1  9-Mar-88 1334	PAGE 20


2)	;Ret+2:	Success, T1 has TCP%JS+JCN.
2)	
2)	.OPEN::	MCENT			; Enter the monitor context
2)		SETZ FR,		; No flags
2)		CALL BBNCKK
2)		  RETERR (TCPX28)	; Not allowed
2)	
2)		HRROI T1,ELT+^D31	; "TCP Not initialized yet"
2)		SKIPL TCPON		; TCP ON?
2)		  JRST TCPERR		; No, do not allow an OPEN
2)	
2)	MNTM5  	AOS CELL(TCJOP,0,,TCJ)	; OPEN%s when TCPON
2)	
2)		UMOVE T2,1		; Get user flags
2)		TXNE T2,<STSFLG!TCP%JS>&^-<TCP%WT!OPNFLG>
2)		  JRST TCPILP		; Illegal control bit
2)	
2)		MOVE T1,FORKX		; Which fork this is
2)		CAMN T1,INTFRK		; The Internet fork?
2)		IFSKP.			; No, check further
2)		  HRROI T1,ELP+^D30	; "Only Internet fork can run TVTs"
2)		  TXNE T2,TCP%VT	; Virtual terminal open?
2)		    JRST TCPERR		; Yes, not allowed
2)	^L
2)	;Require privledges to listen on a "Well Known" port (.lt. 256).
2)	
2)	HOCTET==377B27			; High order octet in a port number
2)		  HRRZ T4,T2		; Get CDB pointer
2)		  UMOVE T3,.TCPLP(T4)	; Get Local port number
2)	IFDEF  CMU,<
2)		  IFXE. T2,TCP%FS	;CS62 Active connection may have any port #
2)		    ANDXE. T3,HOCTET	; Not active, if high octet zero need privs
2)	              JE <SC%WHL,SC%OPR,SC%NAS,SC%NWZ>,CAPENB,[RETERR (NTWZX1)] ;CS62
2)		  ENDIF.		; Everything is OK.
2)	>; End of IFDEF CMU
2)		  SKIPN ACJFN		; If have ACJ fork, check OPEN request to
2)		  IFSKP.		; permit sites selective network access.
2)	            HLL T3,T2		; Open flags for ACJ with local port number
2)		    UMOVE T1,.TCPFH(T4)	; Get foreign host number
2)		    UMOVE T2,.TCPFP(T4)	; Get foreign port number
2)		    UMOVE T4,.TCPLH(T4)	; Get Local host number
2)		    GTOKM (.GOANA,<T1,T2,T3,T4>,TCPILP) ; Ask ACJ for its blessing
2)		  ELSE.			; No, ACJ not present, do our own check
2)		    ANDXE. T2,TCP%FS	; Active connection may have any port #
2)		     ANDXE. T3,HOCTET	; Not active, if high octet zero need privs
2)		      JE <SC%WHL,SC%OPR,SC%NAS,SC%NWZ>,CAPENB,TCPILP ; Ret. BBN error
2)		  ENDIF.		; Everything is OK.
2)		ENDIF.
2)	
2)		XMOVEI T1,OPEN2		; Routine to call via CHKARG
2)		TXO T1,<021B8>		; Open/phase 1

; TCPBBN.MAC.1 & <BBN-MONITOR>TCPBBN.MAC.1  9-Mar-88 1334	PAGE 21


2)		UMOVE T2,1		; User's AC 1
2)		CALL CHKARG		; Check arguments, set TCB, call OPEN2
2)		JUMPL T1,OPENE		; Jump on error (400000+JCN,,error)
2)	
2)		UMOVE T3,1		; Get user flags
2)		TXO T1,TCP%JS		; Turn on JCN Supplied bit
2)		UMOVEM T1,1		; JCN to user (so CHKARG can use it if wait)
2)		TXNN T3,TCP%WT		; Supposed to wait?
2)		  SMRETN		; No, return ok
2)					; Yes
2)	
2)	MNTM5	AOS CELL(TCJOP,6,,TCJ)	; OPEN% waits
2)	
2)		PUSH P,T1		; Save the JCN
2)		HRL T1,BFR		; TOPNF,TERRF,,0
2)		HRRI T1,INTOOT		; Select OPEN% Done Test
2)		MDISMS
2)	
2)		XMOVEI T1,GETERR	; Routine to call
2)		TXO T1,<022B8>		; OPEN%/phase 2
2)		UMOVE T2,1		; User's AC 1
2)		CALL CHKARG		; Get error code
2)		POP P,T2		; JCN
2)		EXCH T1,T2		; Assume no error
2)		JUMPE T2,SKMRTN		; Jump if no error
2)	
2)	MNTM5	AOS CELL(TCJOP,7,,TCJ)	; Count OPEN% wait errors
2)	
2)		HRLZS T1		; JCN left half
2)		HRR T1,T2		; Put error code in right half
2)	OPENE:	TLZ T1,400000		; Remove error flag, leaving JCN,,Code
2)		JRST TCPERO		; Return T1 and no skip
2)	
2)	^L	SUBTTL OPEN% JSYS - Open a TCP Connection - Phase 1, 2
2)	
2)	;T1/	JCN resulting from CDB specified by caller
2)	;T2/	Option addresses word, or 0 if none specified
2)	;TCB/	Extended Locked connection block
2)	;    	NOINT
2)	;	CALL OPEN2
2)	;Ret+1:	Always.  T1 has (400000+JCN,,error), or the JCN & BFR has wait indicies
2)	;TCPUOP	-1,,ELP+^D02 ; Error in option length
2)	;OPEN2	-1,,ELP+^D06 ; Connection already exists/open
2)	;	-1,,ELP+^D12 ; Connection closing (one side isn't closed-TIMWAT/NOTSYN)
2)	
2)	OPEN2:	ACVAR <USRAC1,JCN,UOPTS>
2)		MOVEM T1,JCN
2)		MOVEM T2,UOPTS
2)	        UMOVE USRAC1,1		; Get user flags
2)		LOAD CX,MNPTJ		; Get TCB Trace Job Number
2)		SKIPE CX		; 0? (0 means don't match any job)

; TCPBBN.MAC.1 & <BBN-MONITOR>TCPBBN.MAC.1  9-Mar-88 1334	PAGE 22


2)		 CAME CX,JOBNO		; Non-0, Want trace for this job?
2)		  TXNE USRAC1,TCP%PT	; No, Does caller want trace?
2)		IFNSK.			; Yes, somebody out there wants a TCB trace
2)		  SETONE TERRT,(TCB)	; Set flag
2)		ENDIF.
2)	
2)		LOAD FR,TERRT,(TCB)	; Want error trace?
2)		SKIPE FR		; No
2)		  MOVX FR,1B0		; Yes
2)	
2)		TXNN USRAC1,TCP%ET	; Want messages?
2)		IFSKP.			; Yes
2)					; Would be nice to have a file...
2)		  MOVX T1,<.SCRET,,.FHSLF> ; Process's controlling terminal
2)		  SCTTY%
2)		  ERJMP OPENET		; There ought to be a macro  "ANNJE."
2)		  CAIE T2,.CTTRM	; Any set?
2)		  IFSKP.		; No
2)		    GJINF%		; Get job controlling TTY
2)		    ERJMP OPENET
2)		    CAMN T4,[-1]	; Detached?
2)		     TDZA T2,T2		; Yes, forget it
2)		      MOVEI T2,.TTDES(T4) ; No, tty number to tty descriptor
2)		  ENDIF.
2)		  ANDN. T2
2)		    STOR T2,TERJN,(TCB)	; Set tty descriptor
2)	OPENET:	ENDIF.
2)	
2)		IFQN. TSUOP,(TCB)	; If already open
2)		  HRROI T1,ELP+^D06	; "Connection already open"
2)		  JRST OPENX
2)		ENDIF.
2)	^L
2)	;ACTTCB tries to move a connection from the completely unsynchronized
2)	;(closed  or  brand  new)  state  into the SYNABLE state, where it is
2)	;able to send and/or respond to SYNs.  Activating a connection is the
2)	;operation performed by user calls to OPEN%, and makes the connection
2)	;be "alive". If the connection is already active, this results  in  a
2)	;true value.  False is return if the connection is partially closed -
2)	;- one side or the other is NOTSYN state.
2)	
2)	ACTTCB:
2)	MNTM5	AOS CELL(TCJOP,1,,TCJ)	; Reached ACTTCB
2)		LOAD T4,TSSYN,(TCB)	; Get send state
2)		LOAD T3,TRSYN,(TCB)	; Get recv state
2)		CAIE T4,NOTSYN		; Unsynchronized?
2)		  JRST ACTTC7		; No.
2)		CAIE T3,NOTSYN
2)		 CAIN T3,TIMWAT
2)		  TRNA			; TIMWAT or NOTSYN
2)		   JRST ACTTC8		; Return FALSE

; TCPBBN.MAC.1 & <BBN-MONITOR>TCPBBN.MAC.1  9-Mar-88 1334	PAGE 23


2)	
2)	; TIMWAT/NOTSYN.NOTSYN
2)	
2)	MNTM5	AOS CELL(TCJOP,2,,TCJ)	; State ok TIMWAT/NOTSYN.NOTSYN
2)		STOR JCN,TJCN,(TCB)	; Indicate this TCB is owned
2)		STOR TCB,JCNTC,(JCN)	; Save TCB address and
2)		MOVE T3,FORKX		; Owning fork
2)		STOR T3,JCNFX,(JCN)	
2)	
2)		SETZRO <TIPOR,TIPOU,TIOPF>,(TCB)
2)		MOVX T1,<<<MINIHS+3>/4>>
2)		STOR T1,TIPDO,(TCB)
2)		XMOVEI T1,TCBIO(TCB)	; Clear IP option blocks
2)		CALL CLROP
2)		XMOVEI T1,TCBIR(TCB)
2)		CALL CLROP
2)		XMOVEI T1,TCBIU(TCB)
2)		CALL CLROP
2)	
2)		SETZRO <TTPOR,TTPOU,TTOPF>,(TCB)
2)		MOVX T1,<<<MINTHS+3>/4>>
2)		STOR T1,TTPDO,(TCB)
2)		XMOVEI T1,TCBTO(TCB)	; Clear TCP option blocks
2)		CALL CLROP
2)		XMOVEI T1,TCBTR(TCB)
2)		CALL CLROP
2)		XMOVEI T1,TCBTU(TCB)
2)		CALL CLROP
2)	
2)		SKIPE T1,UOPTS		; Option address word
2)		 CALL TCPUOP		; Get options from user
2)		  JUMPL T1,ACTTCX	; Return error code ** RETJCN too
2)	^L
2)		MOVE T2,JOBNO		; Our job number
2)		STOR T2,TOWNR,(TCB)	; Store this as TCB Owner
2)		MOVX T1,SYNABL		; SYN Ok state
2)		STOR T1,TSSYN,(TCB)	; Set send side
2)		STOR T1,TRSYN,(TCB)	; and recv side
2)	
2)		SETONE TRIS,(TCB)	; Receive sequence number not valid
2)	
2)	; Clear persistent SYN flag, Clear OPEN% has been done flag
2)	; Clear "said it's open" bit, Clear ABORT% requested flag
2)	; Clear TVT flag, Clear "Don't Abort on RTX Timeout" Flag
2)	; Clear "Flush RECV data after Close" Flag
2)	; Clear "We did Flush RECV data after Close" Flag
2)	
2)		SETZRO <TSPRS,TSUOP,TSOPN,TSABT,TTVT,TSRX,TSFR,TWFR>,(TCB)
2)		SETZRO TVTL,(TCB)	; Clear TVT line number
2)		SETZRO TSCPK,(TCB)	; No partially filled packet
2)	

; TCPBBN.MAC.1 & <BBN-MONITOR>TCPBBN.MAC.1  9-Mar-88 1334	PAGE 24


2)		MOVE T1,INXPB		; Maximum data size for a packet
2)		SUBI T1,MINIHS+MINTHS	; Assuming no options & largest net
2)		STOR T1,TRWND,(TCB)	; is the default initial receive window.
2)		LOAD T1,TPRMW		; Get shut window level
2)		STOR T1,TCRMW,(TCB)	; Initial value for TCB
2)		LOAD T1,TPRMQ		; Get send source quench level
2)		STOR T1,TCRMQ,(TCB)	; Initial value for TCB
2)		SETZRO TRBS,(TCB)	; No RECV buffer space yet
2)		HRRZ T1,FORKN		; Our Job fork number
2)		STOR T1,TOFRK,(TCB)	; Say who owns the TCB
2)		SETO T1,
2)		STOR T1,TPSIC,(TCB)	; No PSI Channels named yet
2)		STOR T1,TPIFU,(TCB)	; No INTRP fork
2)		STOR T1,TPIFR,(TCB)	; No RECV% DONE fork
2)		STOR T1,TPIFS,(TCB)	; No SEND% DONE fork
2)		STOR T1,TPIFE,(TCB)	; No ERROR fork
2)		STOR T1,TPIFX,(TCB)	; No STATE CHANGE fork
2)		STOR T1,TPIFA,(TCB)	; No PUSH ACK fork
2)		STOR T1,TRLWN,(TCB)	; No last window seq #
2)	
2)		; Allow specifying initial interrupt channels
2)		TXNN USRAC1,TCP%IC	; User specified initial channels?
2)		IFSKP.			; Yes, set them up
2)		  HRRZ T1,USRAC1	; Get CDB address
2)		  UMOVE T1,.TCPIC(T1)	; Get the initial channel word
2)		  CALL OPNCHN ;(T1,TCB:T1) ; Set up the OPEN initial channels
2)		  JUMPL T1,OPENX	; Error, get out
2)		ENDIF.
2)	
2)		MOVE T1,TPRX0		; Good starting point for retrans
2)		STOR T1,TMNRT,(TCB)	; Minimum round trip time
2)		STOR T1,TMXRT,(TCB)	; Maximum round trip time
2)		STOR T1,TRXI,(TCB)	; Current RX interval
2)		STOR T1,TSMRT,(TCB)	; Dynamic starting point, smoothed TSMRT
2)		SETZRO TUNRT,(TCB)	; Assume dynamic initially reliable
2)		SETZRO <TRXPN,TRXPD,TRXPI>,(TCB) ; Clear RX parameters (dynamic)
2)	^L
2)		MOVX T1,^D1000000	; Optimistic
2)		STOR T1,TSMXB,(TCB)	; Maximum baud rate
2)		MOVX T1,OK		; General success code
2)		STOR T1,TERR,(TCB)	; Indicate no error on this connection
2)		MOVX T1,MNTX00
2)		STOR T1,TCERR,(TCB)
2)		LOAD T1,TERRF,(TCB)	; Index of the error event flag
2)		CALL CLRWTB		; Clear it
2)		MOVX T1,<OK>		; Return OK
2)		IFSKP.			; Error exits
2)	ACTTC7:	  CAIN T3,NOTSYN	; Check receive state (S.ne.NOTSYN)
2)	ACTTC8:	    HRROI T1,ELP+^D12	; "Connection closing" error
2)					; (R.ne.TIMWAT/NOTSYN ior S.ne.NOTSYN)
2)					; (S.noweq.SYNABL & R.noweq.SYNABL)

; TCPBBN.MAC.1 & <BBN-MONITOR>TCPBBN.MAC.1  9-Mar-88 1334	PAGE 25


2)	ACTTCX:				; Return with TCPUOP's error code
2)		ENDIF.		;cwl update FR here ***
2)		JUMPL T1,OPENX		; Err xit (maybe bad options), T1/ code
2)	MNTM5	AOS CELL(TCJOP,3,,TCJ)	; Count successful OPEN% activations
2)		SETONE TSUOP,(TCB)	; Mark the TCB as open
2)		IFQN. TNUFM,(TCB)	; Skip following if old format
2)	MNTM5	  AOS CELL(TCJOP,4,,TCJ) ; Count new format OPEN%s
2)		  HRRZ T1,USRAC1	; Connection block address
2)		  UMOVE T1,.TCPIP(T1)	; Get IP parameter word
2)		  TRNN T1,777
2)		  IFSKP.
2)		    STOR T1,TTOS,(TCB)	; Save type of service
2)		    SETONE TTOSU,(TCB)	; Remember user set it
2)		  ENDIF.
2)		  HLRS T1
2)		  TRNE T1,.RTJST(-1,PITTL) ; User specify non-zero TTL?
2)	            STOR T1,TTTL,(TCB)	; Yes, Save Time to live
2)		  LSH T1,^D<-18+2>	; Top two bits
2)		  STOR T1,TIFDF,(TCB)	; Don't fragment
2)		ENDIF.
2)	        UMOVE T2,2		; Get the User Timeout from user
2)		IFG. T2			; Only set timeout if specified
2)		  CAMLE T2,TCPPTM	; Check if reasonable for add to TODCLK
2)		    MOVE T2,TCPPTM
2)		  IMULI T2,^D1000	; Make into milliseconds
2)		  STOR T2,TSTO,(TCB)	; Set the new value into the TCB
2)		ENDIF.
2)	        UMOVE T1,3		; Get retransmission parameter word
2)		CALL RXPARS		; Change them in TCB
2)		MOVX T1,1		; To set flags ...
2)		TXNE USRAC1,TCP%VT	; Openning as a virtual terminal?
2)		  STOR T1,TTVT,(TCB)	; Yes.  Mark TCB as such
2)		TXNE USRAC1,TCP%PS	; Supposed to be persistent?
2)		  STOR T1,TSPRS,(TCB)	; Yes, mark the TCB as such.
2)		TXNE USRAC1,TCP%RX	; If "Don't Abort on RTX Timeout" flag
2)		  STOR T1,TSRX,(TCB)	; Set it in the TCB
2)		TXNE USRAC1,TCP%FR	; If "Flush RECV data after close" flag
2)		  STOR T1,TSFR,(TCB)	; Set it in the TCB
2)	^L
2)		LOAD T2,TTVT,(TCB)	; TVT?
2)		LOAD T1,TPSMO		; Max outstanding packets
2)		LSH T1,(T2)		; Twice as many if TVT
2)		STOR T1,TCSMO,(TCB)	; Maximum outstanding packets
2)	
2)		MOVX T1,PT%TOJ		; Open
2)		TXNN FR,1B0		; TCB trace or
2)		 TDNE T1,MNTRAC		; Want trace?
2)		  CALL PRNPKT		; Yes
2)	
2)		TMNN TCDFS,(TCB)	; JFN interface want active, or
2)		 TXNE USRAC1,TCP%FS	; Supposed to force synchronization?

; TCPBBN.MAC.1 & <BBN-MONITOR>TCPBBN.MAC.1  9-Mar-88 1334	PAGE 26


2)		IFNSK.			; Yes
2)		  IFQE. TLH,(TCB)	; If caller specified local address, use it
2)		    LOAD T1,TFH,(TCB)	; Otherwise, Get foreign host
2)		    IFE. T1		; Better have foreign address to send a packet
2)		      HRROI T1,ELP+^D12	; Ought to have a better code
2)		      JRST OPENX
2)		    ENDIF.
2)		    SETZ T2,
2)		    CALL BSTADR		; Find best local address for foreign
2)		      NOP		; Shouldn't occur
2)	;cwl add t1 error code if down
2)		    STOR T2,TLH,(TCB)	; And stick it in the TCB
2)		  ENDIF.
2)	
2)	MNTM5	  AOS CELL(TCJOP,5,,TCJ) ; Count active OPEN%s
2)		  CALL FRCPKT		; Yes.  Packetizer will do that.
2)		ENDIF.
2)	
2)		MOVE T1,JCN		; JCN to return
2)		LOAD T2,TOPNF,(TCB)	; Get ID of Open Flag for this TCB
2)		LOAD T3,TERRF,(TCB)	; Error Flag index
2)		ROT T3,-<WID(TERRF)>	; Put in high bits of T3
2)		LSHC T2,<WID(TERRF)>	; Build 0,,TOPNF,TERRF
2)		MOVE BFR,T2		; BFR will be preserved over return
2)	
2)	OPENX:	SKIPGE T1		; If have an error
2)		  HRLI T1,400000(JCN)	; Return JCN in LH for user to ABORT%
2)		RET
2)	
2)		ENDAV.
2)	
2)	
2)	;CLROP	Routine to clear specified option block.
2)	
2)	;T1/	Extended Option block address
2)	;	CALL CLROP
2)	;Ret+1:	Always, T2 preserved
2)	
2)	..XI==<MAXIOS+3>/4
2)	..XT==<MAXTOS+3>/4
2)	IFN ..XI-..XT,<PRINTX ? Need two versions of CLROP>
2)	
2)	CLROP:	MOVX T3,<-..XT>	; # words to clear
2)		SETZM (T1)	;**
2)		ADDI T1,1	;**
2)		AOBJN T3,.-2	;**
2)		RET
2)	
2)	
2)	; Second phase of OPEN% and CLOSE% - get the error code
2)	

; TCPBBN.MAC.1 & <BBN-MONITOR>TCPBBN.MAC.1  9-Mar-88 1334	PAGE 27


2)	GETERR:	LOAD T1,TERR,(TCB)	; Get error code
2)		RET
2)	
2)	^L
2)	;OPNCHN	Routine to set up the initial interrupt channels specified by the
2)	;user with the OPEN% JSYS.  This routine assumes that the interrupt
2)	;words in the TCB have all been initialized to -1.
2)	;
2)	;Call:
2)	;T1/	User specified channel word (.TCPIC)
2)	;TCB/	TCB address
2)	;	CALL OPNCHN
2)	;Returns: +1 always:
2)	;	Error:	  T1/	-1,,ELP+^D17 
2)	;	Success:  T1/   0
2)	
2)	OPNCHN:	; N.B. Maximum of 6 ACVARs so that TCB does not get trashed
2)		ACVAR <CNT,FORKID,INICHS,INIPTR,OLDPTR,FRKPTR>
2)		MOVE INICHS,T1		; Save the initial channel word
2)	
2)		MOVE FORKID,FORKX	; Fork that gets interrupted
2)		MOVX INIPTR,<POINT 6,INICHS>  ;Scan initial channels
2)		MOVX OLDPTR,<POINT 6,TCPIC(TCB)>  ;Scan current channels
2)		MOVX FRKPTR,<POINT 18,TCPIF(TCB)>  ;Scan forks
2)		MOVX CNT,6		; Number to scan
2)		DO.
2)		  ILDB T1,INIPTR	; Get Initial setting
2)		  TRC T1,76		; No change or Delete wanted?
2)		  TRCN T1,76
2)		  IFSKP.		; No, a change is wanted
2)		    CAIG T1,5		; Less than or equal to 5?
2)		    IFSKP. 		; No...
2)		      CAIL T1,^D24	; Between 24 and 35?
2)			CAILE T1,^D35
2)		      ANNSK.		; No, bogus number
2)			HRROI T1,ELP+^D17	; Return error
2)			RET
2)		    ENDIF.
2)		    IDPB T1,OLDPTR	; Set the channel in the TCB
2)		    IDPB FORKID,FRKPTR	; And the fork ID 
2)		  ELSE.			; No change wanted...
2)		    IBP OLDPTR		; Skip to the next
2)		    IBP FRKPTR
2)		  ENDIF.
2)		  SOJG CNT,TOP.		; Loop
2)		ENDDO.
2)		SETZ T1,		; Here on success
2)		RET
2)		ENDAV.
2)	
2)	^L	SUBTTL CLOSE% JSYS - Close a TCP Connection

; TCPBBN.MAC.1 & <BBN-MONITOR>TCPBBN.MAC.1  9-Mar-88 1334	PAGE 28


2)	


LINE 6, PAGE 12
1)	;		ELP+^D1   Bad JCN, No TCB, CDB not allowed
1)	;		ELP+^D3   Was never open
1)	;Ret+2:	Success
1)	
1)	IFE REL6,<.CLOSE::>
1)	IFN REL6,<XNENT .CLOSE,G>
1)		MCENT			; Enter the monitor context
1)		TXNE T1,TCP%JS		; JCN must be supplied
1)		 TXNE T1,<STSFLG!TCP%FS!TCP%PS!TCP%VT!TCP%HP!TCP%SC>&^-<TCP%JS!TCP%WT>
1)	          JRST TCPILP		; Illegal control bit
1)		HRRZS T1		; Save just the JCN part
1)		XMOVEI T2,CLOSE1	; Select CLOSE1 routine
1)		CALL CHKJCN		; Check access, set TCB, call CLOSE1
1)		JUMPL T1,TCPERR		; Jump if error.
1)		UMOVE T1,T1		; Get flags
1)		TLNN T1,(TCP%WT)	; Supposed to wait?
1)	         JRST CLOSEX		; No.  User will do ABORT to release JCN
1)		LOAD T1,TOPNF,(TCB)	; Get ID of Open Flag for this TCB
1)		LOAD T2,TERRF,(TCB)	; Error Flag index
1)		ROT T2,-<WID(TERRF)>	; Put in high bits of T2
1)		LSHC T1,^D18+<WID(TERRF)> ; Put indexes in LH
1)		HRRI T1,INTZOT		; Select Close Done Test
1)		MDISMS
1)		LOAD T1,TERR,(TCB)	; Get the error code
1)		JUMPN T1,TCPERR		; Jump if error code non-null
1)		LOAD T1,TJCN,(TCB)	; Get the JCN for this connection
1)		CALL RETJCN		; Release it
1)	CLOSEX:	SMRETN
1)	
1)	CLOSE1::JE TSOPN,(TCB),CLOSE3	; Was it ever open?
1)		JE TSUOP,(TCB),CLOSE3	; Still Open?
1)		SETZRO TSUOP,(TCB)	; No longer
1)		CALL FRCPKT		; Get a FIN sent by Packetizer
1)		TDZA T1,T1		; Tell caller OK
1)	CLOSE3:	  HRROI T1,ELP+^D3	; "Connection not open"
1)		RET
1)	
1)	^L	SUBTTL ABORT JSYS - Abandon this end of a connection
1)	
1)	;T1/	Flags,,JCN
1)	;	ABORT
1)	;Ret+1:	Error.  T1 has code.	ELP+^D1 - CDB supplied
1)	;Ret+2:	Success.  Nothing more will be heard about this connection.
1)	
1)	IFE REL6,<.ABORT::>
1)	IFN REL6,<XNENT .ABORT,G>
1)		MCENT			; Enter monitor context

; TCPBBN.MAC.1 & <BBN-MONITOR>TCPBBN.MAC.1  9-Mar-88 1334	PAGE 29


1)		TXNE T1,TCP%JS		; JCN must be supplied
1)		 TXNE T1,<STSFLG!TCP%FS!TCP%PS!TCP%VT!TCP%HP!TCP%SC>&^-<TCP%JS!TCP%WT>
1)		  JRST TCPILP		; Illegal control bit
1)		HRRZS T1		; Save just the JCN
1)		XMOVEI T2,ABORT1	; Select the routine to run
1)		CALL CHKJCN		; Check arguement, set TCB, run ABORT1
1)		JUMPL T1,TCPERR		; Jump if some sort of error
1)		MOVEI T1,TCPABT		; Select wait routine
1)		HRL T1,FORKX		; For this fork
1)		MDISMS
1)		SMRETN
1)	
1)	;ABORT1(TCB)
1)	;Second phase of ABORT JSYS
1)	
1)	;T1/	JCN specified by caller (ignored here)
1)	;TCB/	(Extended) Locked Connection Block
1)	;      	NOINT
1)	;	CALL ABORT1
1)	;Ret+1:	Always.  T1 has 0 for passing to caller.
1)	
1)	ABORT1:
1)		CALL ABTTCB		; Abort the connection and increment
1)					; # being aborted by this forkx
1)		LOAD T1,TJCN,(TCB)	; Get user's handle
1)		CALL RETJCN		; Release that.
1)		MOVX T1,OK		; Say OK to caller
1)		RET
1)	
1)	^L	SUBTTL ABTJCS - Abort JCNs for Forks
1)	
1)	;T1/	Job fork number of fork being considered
1)	;	CALL ABTJCS
1)	;Ret+1:	Always.
1)	
1)	IFE REL6,<ABTJCS::>
1)	IFN REL6,<XNENT ABTJCS,G>
1)		SKIPE TCPON		; TCP enabled?
1)		 SKIPL TCPIFG		; TCP Initialized yet (JOB-0 startup)
1)		  RET			; No.
1)		SAVET			; CLZFF code requires this
1)		MOVE T3,T1		; Put in place for call via LCKCAL
1)		XMOVEI T1,TCBHLK	; Stabilize JCNTCB table in JSB
1)		XMOVEI T2,ABTJC1	; and call function to abort JCNs
1)		NOINT			; Retain control during this
1)		CALL LCKCAL
1)		MOVEI T1,TCPABT		; Wait for all to be aborted
1)		HRL T1,FORKX		; The ones by this fork, that is.
1)		MDISMS
1)		OKINT			; State is clean again
1)		RET

; TCPBBN.MAC.1 & <BBN-MONITOR>TCPBBN.MAC.1  9-Mar-88 1334	PAGE 30


1)	
1)	;T1/	Job fork number of fork being considered
1)	;ABTJC1
1)	;Same as above, but called with TCBH Lock set, NOINT
1)	;TCBHLK locked, NOINT
1)	
1)	ABTJC1:	LOCAL <JCN,JOBFRK>
1)		PUSH P,TCB
1)		MOVEM T1,JOBFRK
1)		MOVSI JCN,-MAXJCN	; Set to scan table
1)	ABTJC2:	HRRZ TCB,JCNTCB(JCN)	; Get pointer to TCB
1)		JUMPE TCB,ABTJC3	; Avoid non-pointers
1)		SETSEC TCB,INTSEC	; Make extended address
1)		XMOVEI T1,TCBLCK(TCB)	; Pointer to lock on that TCB
1)		XMOVEI T2,ABTJCN	; Function to abort a JCN
1)		MOVE T3,JOBFRK		; Argument for ABTJCN
1)		CALL LCKCAL		; Lock the TCB and Abort the JCN
1)	ABTJC3:	AOBJN JCN,ABTJC2	; Loop over all
1)		POP P,TCB
1)		RESTORE
1)		RET
1)	
1)	^L	SUBTTL ABTBUF - Abort Buffers Associated with Forks
1)	
1)	;	CALL ABTBUF
1)	;Ret+1:	Always.
1)	
1)	IFE REL6,<ABTBUF::>
1)	IFN REL6,<XNENT ABTBUF,G>
1)		SAVET			; KSELF code requires this
1)		SKIPE TCPON		; TCP enabled?
1)		 SKIPL TCPIFG		; TCP Initialized yet (JOB-0 startup)
1)		  RET			; No.
1)		XMOVEI T1,TCBHLK	; Stabilize JCNTCB table in JSB
1)		XMOVEI T2,ABTBF1	; and call function to abort JCNs
1)		CALL LCKCAL		; lock the lock and scan the TCBs
1)		RET
1)	
1)	;ABTBF1	worker for above, but called with TCBH Lock set
1)	
1)	ABTBF1:	LOCAL <JCN>
1)		PUSH P,TCB
1)		MOVSI JCN,-MAXJCN	; Set to scan table
1)	ABTBF2:	HRRZ TCB,JCNTCB(JCN)	; Get pointer to TCB
1)		JUMPE TCB,ABTBF3	; Avoid non-pointers
1)		SETSEC TCB,INTSEC	; Make extended address
1)		PUSH P,JCN
1)		XMOVEI T1,TCBLCK(TCB)	; Lock the TCB
1)		XMOVEI T2,ABTBF4	; Go to worker routine for the TCB
1)		CALL LCKCAL		; Lock the lock and call the routine
1)		POP P,JCN

; TCPBBN.MAC.1 & <BBN-MONITOR>TCPBBN.MAC.1  9-Mar-88 1334	PAGE 31


1)	ABTBF3:	AOBJN JCN,ABTBF2	; Loop over all the JCNs
1)		POP P,TCB		; Restore an AC
1)		RESTORE
1)		RET
1)	
1)	ABTBF4:				; worker routine called with TCB locked
1)		CALL FLSRBX		; flush any receive buffers
1)		CALL FLSSBX		; flush any send buffers
1)		RET			; return to caller
1)	
1)	^L	SUBTTL ABTJCN - Abort a JCN
1)	
1)	;T1/	Job fork number being considered
1)	;TCB/	(Extended) Locked connection block
1)	;TCBH/	Locked TCB Hash table
LINE 6, PAGE 20
2)	;CHKJCN	ELP+^D01 ; JCN out of range/no TCB, Illegal connection/control bit
2)	;CLOSE1	ELP+^D03 ; Connection not open/was never open
2)	; Net related errors if TCP%WT
2)	;CHKADD	-1,,ELP+^D05 ; Packet with wild FH/FP
2)	;CHKADD	-1,,EFP+^D07 ; No such TCB
2)	;Ret+2:	Success
2)	
2)	.CLOSE::
2)		MCENT			; Enter the monitor context
2)		SETZ FR,		; No flags
2)	MNTM5	AOS CELL(TCJCL,0,,TCJ)	; Count CLOSE%s
2)		TXNE T1,TCP%JS		; JCN must be supplied
2)		 TXNE T1,<STSFLG!TCP%HP!TCP%SC!OPNFLG>&^-<TCP%JS!TCP%WT!TCP%FR>
2)	          JRST TCPILP		; Illegal control bit
2)		TXZ T1,<<777777000000-TCP%FR>> ; Save just the JCN part & TCP%FR
2)		XMOVEI T2,CLOSE1	; Select CLOSE1 routine
2)		TXO T2,<031B8>		; CLOSE%/phase 1
2)		CALL CHKJCN		; Check access, set TCB, call CLOSE1
2)		JUMPL T1,TCPERR		; Jump if error.
2)	MNTM5	AOS CELL(TCJCL,1,,TCJ)	; Count successful CLOSE1s
2)		UMOVE T1,1		; Get user flags
2)		TXNN T1,TCP%WT		; Supposed to wait?
2)		  SMRETN		; No.  User will do ABORT to release JCN
2)		IFL. BFR		; Not yet established?
2)	MNTM5	  AOS CELL(TCJCL,2,,TCJ) ; Count CLOSE% waits (still opening)
2)		  HRL T1,BFR		; TOPNF,TERRF,,x
2)		  HRRI T1,INTOOT	; Select CLOSE% Done Test (opening)
2)		  MDISMS
2)		  XMOVEI T1,GETERR	; Get error code
2)		  TXO T1,<032B8>	; CLOSE%/phase 2
2)		  UMOVE T2,1		; User's AC 1
2)		  CALL CHKARG
2)		  JUMPN T1,TCPERR	; Jump if error code non-null
2)		ENDIF.
2)	MNTM5	AOS CELL(TCJCL,2,,TCJ)	; Count CLOSE% waits

; TCPBBN.MAC.1 & <BBN-MONITOR>TCPBBN.MAC.1  9-Mar-88 1334	PAGE 32


2)		HRL T1,BFR		; TOPNF,TERRF,,x
2)		HRRI T1,INTZOT		; Select CLOSE% Done Test (closed)
2)		MDISMS
2)	
2)		XMOVEI T1,GETERR	; Get error code
2)		TXO T1,<033B8>		; CLOSE%/phase 3
2)		UMOVE T2,1		; User's AC 1
2)		CALL CHKARG
2)		JUMPN T1,TCPERR		; Jump if error code non-null
2)	MNTM5	AOS CELL(TCJCL,3,,TCJ)	; Successful CLOSE% wait & RETJCN
2)		LOAD T1,TJCN,(TCB)	; Get the JCN for this connection
2)		CALL RETJCN		; Release it
2)		SMRETN
2)	
2)	^L	SUBTTL CLOSE% JSYS - Close a TCP Connection - Phase 1 (also TVTDET)
2)	
2)	;T1/	JCN Specified by caller (ignored here), possibly with TCP%FR bit
2)	;TCB/	Extended Locked Connection Block
2)	;	NOINT
2)	;	CALL CLOSE1
2)	;Ret+1:	Always. T1 has 0 for OK, or -1,,error
2)	;		BFR has (open) 0,,TOPNF,TERRF  or (opening) 1B0,,TOPNF,TERRF
2)	;CLOSE1	-1,,ELP+^D03 ; Connection not open/was never open
2)	
2)	CLOSE1::
2)		LOAD FR,TERRT,(TCB)	; Want error trace?
2)		SKIPE FR		; No
2)		  MOVX FR,1B0		; Yes
2)	
2)		TXZN T1,TCP%FR		; If "Flush RECV data after close" flag
2)		IFSKP.
2)		  SETONE TSFR,(TCB)	; Set it in the TCB
2)		ENDIF.
2)	
2)		LOAD T2,TOPNF,(TCB)	; Get ID of Open Flag for this TCB
2)		LOAD T3,TERRF,(TCB)	; Error Flag index
2)		ROT T3,-<WID(TERRF)>	; Put in high bits of T2
2)		LSHC T2,<WID(TERRF)>	; 0,,TOPNF,TERRF
2)		MOVE BFR,T2		; Wait indicies of interest
2)					; BFR will be preserved over (FRCPKT &) return
2)		IFQN. TSUOP,(TCB)	; OPENed by user but not yet CLOSEd?
2)		  SETZRO TSUOP,(TCB)	; User CLOSEing it now
2)		  IFQN. TSOPN,(TCB)	; Was it ever open?
2)	MNTM5	    AOS CELL(TCJCL,4,,TCJ) ; FRCPKTs for FIN by CLOSE1
2)		    CALL FRCPKT		; Get Packetizer to try and send the FIN
2)		    MOVX T2,OK		; Tell caller OK
2)		  ELSE.			; Never been opened (But may STILL BE opening)
2)		    TXO BFR,1B0		; Flag that have to wait for open first
2)		    LOAD T2,TERR,(TCB)	; Had any errors?
2)		    SKIPE T2		; Zero is OK
2)		      HRROS T2		; Yes, return error now

; TCPBBN.MAC.1 & <BBN-MONITOR>TCPBBN.MAC.1  9-Mar-88 1334	PAGE 33


2)		  ENDIF.		; T2 has error code
2)		ELSE.			; Either never OPENed or already CLOSEd
2)		  HRROI T2,ELP+^D03	; "Connection not open"
2)		ENDIF.
2)	
2)		MOVX T1,PT%TCJ		; CLOSE% JSYS
2)		TXNN FR,1B0		; TCB trace or
2)		 TDNE T1,MNTRAC		; Want trace
2)		  CALL PRNPKT		; Yes
2)	
2)		MOVE T1,T2		; Error code to be returned
2)		RET
2)	
2)	^L	SUBTTL	Connection Cleanup
2)	
2)	;Kill job:	Nothing to do, TCPKJB is R
2)	;Kill FORKN:	TCPKFK flushes all receive and send Buffers for the FORKN
2)	;Close fork-relative files:
2)	;					      TTYDAS <- LDTACH -- DTACH%
2)	;					   +- FLOGO <-- LDTACH -- JOBCOF
2)	;					   +- LGOUT%
2)	;					   +- CLOSF%(-1)
2)	;TCPCZF <-- INTCZF <-- MNTCZF <-- CLZFF% <-+- RESET%
2)	;  V (TCBHLK)
2)	;TCBSCN -(all jcn)-------(TCBLCK)--> ABTJCN ---(FORKN)--+
2)	;							+-> ABTTCB[RETJCN]
2)	;User ABORT%: -> ABORT1 -(TCBLCK)-----------------------+   (sets TSABT)
2)	
2)	
2)	
2)	
2)	;TCPKFK
2)	;Abort Buffers associated with FORKX.
2)	;Called from [FORK]KSELF via MNTKFK via INTKFK, all registers have been saved.
2)	
2)	
2)	TCPKFK::
2)		SKIPLE TCPON		; TCP enabled?
2)		  RET			; No.
2)	;	SAVEAC <FR,TCB>
2)	;	SAVET			; KSELF code requires this
2)		SETZ FR,		; No flags
2)	MNTM5	AOS CELL(TCJBF,0,,TCJ)	; TCPKFK calls
2)		XMOVEI T1,TCBHLK	; Stabilize JCNTCB table in JSB and
2)		XMOVEI T2,TCBSCN	; Routine to scan JCNTCB table
2)		TXO T2,<076B8>		; TCPKFK/ TCBH
2)		XMOVEI T3,ABTBF6	; Routine to be applied to each TCB found
2)		TXO T3,<077B8>		; TCPKFK/ TCB
2)		SETZ T4,		; No argument (implicit FORKX)
2)		CALL LCKCAL		; Lock the lock and scan the TCBs
2)		RET

; TCPBBN.MAC.1 & <BBN-MONITOR>TCPBBN.MAC.1  9-Mar-88 1334	PAGE 34


2)	
2)	ABTBF6:				; Worker routine called with TCB locked
2)		LOAD FR,TERRT,(TCB)	; Want error trace?
2)		SKIPE FR		; No
2)		  MOVX FR,1B0		; Yes
2)		CALL FLSRBX		; Flush any receive buffers
2)		CALL FLSSBX		; Flush any send buffers
2)		CALL FLSPSI		; Flush the PSI channels for this fork
2)		RET			; Return to caller
2)	^L
2)	;FLSPSI	Flush the PSI assignments for the current FORKX.
2)	
2)	;TCB/	Extended TCB address
2)	;FORKX/	Fork to flush PSI's for
2)	;	CALL FLSPSI
2)	;Return: +1 always
2)	;Clobbers no ACs
2)	
2)	FLSPSI:	ACVAR <CNT,CHNPTR,FRKPTR,MINUS1,FORKID>
2)		SETO MINUS1,		; Get -1
2)		MOVX CHNPTR,<POINT 6,TCPIC(TCB)>  ;Scan current channels
2)		MOVX FRKPTR,<POINT 18,TCPIF(TCB)>  ;Scan forks
2)		MOVX CNT,6		; Number to scan
2)		DO.
2)		  ILDB FORKID,FRKPTR	; Get fork assignment
2)		  IBP CHNPTR		; Point to the corresponding channel
2)		  CAME FORKID,FORKX	; This fork?
2)		  IFSKP.		; Yes, flush the channel
2)		    DPB MINUS1,FRKPTR	; Set fork to -1
2)		    DPB MINUS1,CHNPTR	; Set channel to -1
2)		  ENDIF.
2)		  SOJG CNT,TOP.		; Loop
2)		ENDDO.
2)		RET
2)	
2)		ENDAV.
2)	^L
2)	;TCPCZF	Called from [JSYSF]CLZFF1 via MNTCZF via INTCZF, all registers saved.
2)	
2)	;T1/	Job fork number of fork being considered (FORKN)
2)	;	Critical section, FKLOCK locked
2)	
2)	TCPCZF::
2)		SKIPLE TCPON		; TCP enabled?
2)		  RET			; No.
2)	;	SAVEAC <FR,TCB>
2)	;	SAVET			; CLZFF code requires this
2)		SETZ FR,		; No flags
2)	MNTM5	AOS CELL(TCJAJ,0,,TCJ)	; TCPCZF calls
2)		MOVE T4,T1		; Put FORKN in place for lower level routine
2)		XMOVEI T1,TCBHLK	; Stabilize JCNTCB table in JSB and

; TCPBBN.MAC.1 & <BBN-MONITOR>TCPBBN.MAC.1  9-Mar-88 1334	PAGE 35


2)		XMOVEI T2,TCBSCN	; Routine to scan JCNTCB table
2)		TXO T2,<074B8>		; TCPCZF/ TCBH
2)		XMOVEI T3,ABTJCN	; Abort a TCBs owned by argument FORKN.
2)		TXO T3,<075B8>		; TCPCZF/ TCB
2)					; T4 set above
2)		NOINT			; Retain control during this
2)		CALL LCKCAL
2)		OKINT			; State is clean again
2)		RET
2)	
2)	^L
2)	;ABTJCN	Abort a TCBs owned by argument FORKN.
2)	
2)	;T1/	Job fork number being considered (FORKN)
2)	;TCB/	Extended Locked connection block
2)	;TCBH/	Locked TCB Hash table


LINE 10, PAGE 16
1)	ABTJCN:	LOAD T2,TOWNR,(TCB)	; Get job number of owner
1)	IFE STANSW,<
1)		CAME T2,JOBNO		; Better be ours
1)	>;IFE STANSW
1)	IFN STANSW,<
1)		CAME T2,GBLJNO		; Better be ours
1)	>;IFN STANSW
1)		BUG.(CHK,TCPJS4,TCPTCP,SOFT,<ABTJCN: TCP Conn not owned by aborting job>,,<
1)	
1)	Cause:	ABTJCN was called for a connection not owned by the calling job.
1)	
1)	>)
1)		LOAD T2,TOFRK,(TCB)	; Get job fork handle of owning fork
1)		UMOVE T3,T1		; Get CLZFF flags from caller
1)		CAME T1,T2		; Was JCN created by the object fork?
1)		  JRST ABTJC4		; No.
1)		TXNN T3,CZ%NSF		; Yes. Are we supposed to abort there?
1)		  JRST ABTJC5		; Yes.  Go do it
1)		EXIT ABTJCX
1)	
1)	ABTJC4:	EXCH T1,T2		; Get to right places for SKIIFA
1)		TXNN T3,CZ%NIF		; Abort inferiors' connections?
1)		 IFE REL6,<CALL SKIIFA>	; Check owner inferior to object fork
1)		 IFN REL6,<CALLX (MSEC1,ABTJC6)> ; Check owner inferior to object fork
1)		  EXIT ABTJCX		; Should not kill it
1)	ABTJC5:				; ??Why not CALL ABORT1 for these?
1)		CALL ABTTCB		; Get the TCP fork to do the work
1)		LOAD T1,TJCN,(TCB)	; Get the JCN
1)		CALL RETJCN		; Release that
1)	ABTJCX:	RET
1)	
1)	IFN REL6,<			; this is in section one.  if you want to know

; TCPBBN.MAC.1 & <BBN-MONITOR>TCPBBN.MAC.1  9-Mar-88 1334	PAGE 36


1)		SWAPCD 		   	; why look at SKIIFA
1)	ABTJC6:				; jacket routine for SKIIFA
1)		CALL SKIIFA		; Check owner inferior to object fork
1)		 RET			; non skip return
1)		RETSKP			; skip return
1)		XSWAPCD>		; end of IFN REL6
1)	
1)	^L	SUBTTL ABTTCB - Abort a TCB
1)	
1)	;TCB/	Locked Connection Block
1)	;     	NOINT
1)	;	CALL ABTTCB
LINE 11, PAGE 25
2)	ABTJCN:
2)	MNTM5	AOS CELL(TCJAN,0,,TCJ)	; ABTJCN calls
2)		LOAD FR,TERRT,(TCB)	; Want error trace?
2)		SKIPE FR		; No
2)		  MOVX FR,1B0		; Yes
2)		LOAD T2,TOWNR,(TCB)	; Get job number of owner
2)		CAME T2,JOBNO		; Better be ours
2)		IFSKP.
2)		  LOAD T2,TOFRK,(TCB)	; Get job fork handle (FORKN) of owner
2)		  UMOVE T3,1		; Get CLZFF flags from caller
2)		  CAME T1,T2		; Was JCN created by the object fork?
2)		    JRST ABTJC7		; No.
2)		  TXNN T3,CZ%NSF	; Yes. Are we supposed to abort there?
2)		    JRST ABTJC8		; Yes.  Go do it
2)		  RET			; No.
2)	
2)	ABTJC7:	  EXCH T1,T2		; Get to right places for SKIIFA
2)		  TXNN T3,CZ%NIF	; Abort inferiors' connections?
2)		   CALL SKIIFA		; Check owner inferior to object fork
2)		    RET			; Should not kill it
2)					; Self or inferior
2)	ABTJC8:
2)		  MOVX T1,PT%TAB	; Non-user abort
2)		  TXNN FR,1B0		; TCB trace or
2)		   TDNE T1,MNTRAC	; Want trace?
2)		    CALL PRNPKT		; Yes
2)		  MOVEI T1,ELP+^D14	; Connection reset
2)		  CALLRET ABTTCB	; Abort the TCB and release the JCN
2)		ENDIF.
2)	
2)	MNTM5	AOS CELL(TCJAN,1,,TCJ)	; Count cross job close
2)		BUG.(CHK,TCPJS4,TCPBBN,SOFT,
2)	
2)	<ABTJCN: TCP Conn not owned by aborting job: abjob,onjob,tcb>,
2)	
2)	<<T2,D>,<JOBNO,D>,<TCB,D>>,<
2)	
2)	Cause:	A Job which does not own a TCP connection is trying to abort it.

; TCPBBN.MAC.1 & <BBN-MONITOR>TCPBBN.MAC.1  9-Mar-88 1334	PAGE 37


2)	
2)	Action:
2)	
2)	Data:	TCB owner's job number, Aborter's job number, TCB address
2)	
2)	>)
2)		RET			; Don't kill someone else's connection
2)	^L
2)	;TCBSCN	Routine to scan JCNTCB for vaild TCBs, and apply argument function
2)	;to each.  Called with TCBH Lock set, NOINT
2)	
2)	;T1/	Next function to be called, with Id code
2)	;T2/	Argument for that function
2)	
2)	TCBSCN:	ACVAR <JCN,FCTN,JOBFRK>
2)		MOVEM T1,FCTN
2)		MOVEM T2,JOBFRK
2)	
2)		MOVSI JCN,-MAXJCN	; Set to scan JSB table
2)		DO.
2)		  LOAD TCB,JCNTC,(JCN)	; Get pointer to TCB
2)		  IFN. TCB		; Have entry?
2)					; Validate TCB by looking it up in TCBH
2)		    LOAD T1,TLP,(TCB)	; If TCB is valid, can get LP
2)		    CALL TCBHSH		; Hash LP into a TCBH index
2)		    MOVE T1,T2		; Get working pointer, save queue head
2)		    DO.
2)	  	      LOAD T1,QNEXT,(T1) ; Get next entry in chain
2)	IFN TCBQ,<    XMOVEI T3,-TCBQ(T1) ; Locate top of structure
2)		      CAMN T3,TCB>	; Desired TCB?
2)	IFE TCBQ,<    CAMN T1,TCB>	; Desired TCB?
2)		      IFSKP.
2)		        CAME T1,T2	; Back to head?
2)		          JRST TOP.	; No, go check this one
2)	MNTM5	        AOS CELL(TCJAJ,1,,TCJ) ; TCBSCN cannot find TCB
2)		        SETZB TCB,JCNTCB(JCN) ; TCB has vanished!
2)		      ENDIF.
2)		    ENDDO.
2)		    IFN. TCB		; If valid
2)		      XMOVEI T1,TCBLCK(TCB); Pointer to lock on that TCB
2)		      MOVE T2,FCTN	; Function to be applied to TCB, with id code
2)		      MOVE T3,JOBFRK	; Argument for function
2)		      CALL LCKCAL	; Lock the TCB and Abort the JCN
2)		    ENDIF.
2)		  ENDIF.
2)		  AOBJN JCN,TOP.	; Loop over all
2)		ENDDO.
2)		RET
2)	
2)		ENDAV.
2)	

; TCPBBN.MAC.1 & <BBN-MONITOR>TCPBBN.MAC.1  9-Mar-88 1334	PAGE 38


2)	^L
2)	;ABORT% JSYS	Flush a connection (if necessary), and release JCN.
2)	
2)	;T1/	Flags,,JCN
2)	;	ABORT%
2)	;Ret+1:	Error.  T1 has code.
2)	;CHKJCN	ELP+^D01 ; JCN out of range/no TCB, Illegal connection/control bit
2)	;		   CDB supplied
2)	;Ret+2:	Success.  Nothing more will be heard about this connection.
2)	
2)	.ABORT::
2)		MCENT			; Enter monitor context
2)		SETZ FR,		; No flags
2)	MNTM5	AOS CELL(TCJAB,0,,TCJ)	; Count ABORT%s
2)		TXNE T1,TCP%JS		; JCN must be supplied
2)		 TXNE T1,<STSFLG!TCP%HP!TCP%SC!OPNFLG>&^-<TCP%JS!TCP%WT>
2)		  JRST TCPILP		; Illegal control bit
2)		HRRZS T1		; Save just the JCN
2)		XMOVEI T2,ABORT1	; Select the routine to run
2)		TXO T2,<071B8>		; ABORT%/phase 1
2)		CALL CHKJCN		; Check arguement, set TCB, run ABORT1
2)		JUMPL T1,TCPERR		; Jump if some sort of error
2)	MNTM5	AOS CELL(TCJAB,1,,TCJ)	; Successful ABORT1
2)		SMRETN
2)	
2)	
2)	;ABORT1(TCB)	ABORT% JSYS, phase 1
2)	
2)	;T1/	JCN specified by caller (ignored here)
2)	;TCB/	Extended Locked Connection Block
2)	;      	NOINT
2)	;	CALL ABORT1
2)	;Ret+1:	Always.  T1 has 0 for passing to caller.
2)	
2)	ABORT1:	LOAD FR,TERRT,(TCB)	; Want error trace?
2)		SKIPE FR		; No
2)		  MOVX FR,1B0		; Yes
2)		MOVX T1,PT%TAJ		; ABORT% JSYS
2)		TXNN FR,1B0		; TCB trace or
2)		 TDNE T1,MNTRAC		; Want trace?
2)		  CALL PRNPKT		; Yes
2)	
2)		MOVEI T1,ELP+^D14	; Connection reset
2)		CALL ABTTCB		; Abort the connection and release the JCN
2)	
2)		MOVX T1,OK		; Say OK to caller
2)		RET
2)	
2)	^L
2)	;ABTTCB	Abort a TCB.  Called from ABORT1 (ABORT%) and ABTJCN (ABTJC1,TCPCZF).
2)	;Executing in job which owns the connection (User except for no-TVT error).

; TCPBBN.MAC.1 & <BBN-MONITOR>TCPBBN.MAC.1  9-Mar-88 1334	PAGE 39


2)	
2)	;TCB/	Locked Connection Block
2)	;	NOINT, maybe NOSKED
2)	;T1/	Abort code
2)	;	ELP+^D04 No TVTs available
2)	;	ELP+^D14 Connection reset
2)	;	CALL ABTTCB


LINE 9, PAGE 17
1)		JN TSABT,(TCB),R	; Already being aborted?
1)		SETONE TSABT,(TCB)	; No.  Make it so.
1)		SETZRO TSUOP,(TCB)	; Fake a CLOSE
1)		MOVEI T1,ELP+^D14	; Connection reset
1)		CALL ABTCON		; Clean up the database for this connection
1)		MOVE T1,FORKX		; Our fork number
1)		STOR T1,TABTFX,(TCB)	; Indicate which is killing the TCB
1)		NOSKED			; Make sure we get the system
1)		ADJBP T1,FKABCP		; Pointer to base of counters
1)		LDB T2,T1
1)		CAIGE T2,<1_ABTCBS>-1	; Do not allow count to wrap around
1)	         ADDI T2,1		; Bump the number killed by this fork
1)		DPB T2,T1
1)		OKSKED			; Only be NOSKED for the ABORT part
1)		$SIGNL(PZ,0)		; Run packetizer
1)		RET
1)	^L
1)		RESCD
1)	
1)	;TCPABT(FORKX)
1)	;Scheduler test for ABORT(s) done
1)	
1)	;T1/	a FORKX
1)	;T4/	Return address
1)	;	JSP T4,TCPABT
1)	;Ret+1:	 One or more connections still being aborted
1)	;Ret+2:	All ABORTs completed
1)	
1)	TCPABT::
1)		ADJBP T1,FKABCP
1)		LDB T2,T1
1)		JUMPE T2,1(T4)
1)		JRST 0(T4)
1)	
1)	IFE REL6,<SWAPCD>
1)	IFN REL6,<XSWAPCD>
1)	
1)	^L	SUBTTL STAT JSYS - Get status of a connection or a TCB
1)	
LINE 14, PAGE 28
2)		MOVE T4,T1		; Save abort code

; TCPBBN.MAC.1 & <BBN-MONITOR>TCPBBN.MAC.1  9-Mar-88 1334	PAGE 40


2)	MNTM5	AOS CELL(TCJAT,0,,TCJ)	; ABTTCB calls
2)		JN TSABT,(TCB),ABTTCX	; Already being aborted?
2)	
2)		SETONE TSABT,(TCB)	; No.  Make it so.
2)		SETZRO <TSUOP,TSFP,TSEP>,(TCB) ; Fake user CLOSE%, Clear Force Packet
2)	
2)		MOVE T1,FORKX		; Indicate which fork is killing the TCB
2)		STOR T1,TABTFX,(TCB)
2)	
2)	;If a foreign address is known and we aren't TIMWAT/NOTSYN.NOTSYN a RESET
2)	;is sent to the foreign end to indicate that this end is being flushed.
2)	
2)		MOVE T1,T4		; Abort code (ELP+^D14, connection reset)
2)		CALL ABTCON		; Clean up the database for this connection
2)					; T1 has "release" (0) or "abort" (nz) flag
2)		IFQN. TSSV,(TCB)	; If able to send something, and
2)		ANDN. T1		; Connection is being "abort"ed,
2)		  CALL ABTREP		; Send a RESET reply to other end
2)		ENDIF.
2)	
2)	ABTTCX:
2)		LOAD T1,TJCN,(TCB)	; Get user's handle (JCN)
2)		CALLRET RETJCN		; Release that.
2)	
2)	^L	SUBTTL STAT% JSYS - Get status of a connection or a TCB
2)	


LINE 6, PAGE 19
1)	;	STAT%
1)	;Ret+1:	 Error.  Code in T1
1)	;			ELP+^D20
1)	;			ELP+^D21
1)	;		from CHKARG
1)	;Ret+2:	Success
1)	
1)	IFE REL6,<.STAT::>
1)	IFN REL6,<XNENT .STAT,G>
1)		MCENT			; Enter monitor context
1)		TXNE T1,<TCP%FS!TCP%PS!TCP%VT!TCP%HP!TCP%SC>&^-<TCP%JS!TCP%WT!STSFLG>
1)	         JRST TCPILP		; Illegal control bit
1)		TXNE T1,TCP%ST		; Asking for TCP statistics?
1)	         JRST STATS		; Yes
1)		TXNE T1,TCP%NT		; AOBJN pointer for TVTs wanted?
1)	         JRST STATNT		; Yes
1)		TXNE T1,TCP%NI		; AOBJN pointer for connections wanted?
1)	         JRST STATNI		; Yes
1)		XMOVEI T1,STAT1		; Select routine to call
1)		CALL CHKARG		; Check arguments, set TCB, call STAT1
1)		JUMPL T1,TCPERR		; There was something wrong.
1)		SMRETN

; TCPBBN.MAC.1 & <BBN-MONITOR>TCPBBN.MAC.1  9-Mar-88 1334	PAGE 41


1)	
1)	; Return in 2/ -#TVTs,,first TVT
1)	
1)	STATNT:	MOVE T2,TVTPTR		; Get AOBJN pointer
1)		UMOVEM T2,2		; to user
1)		SMRETN			; All ok
1)	
1)	; Return in 2/ -# connections,,1
1)	
LINE 6, PAGE 29
2)	;T4/	    Address	If TCP%SL set, location in user space for lengths
2)	;	STAT%
2)	;Ret+1:	 Error.  Code in T1
2)	;CHKARG	ELP+^D01 ; JCN out of range/no TCB, Illegal connection/control bit
2)	;CHKARG	ELT+^D04 ; No free JCN/TCB space/free WAIT bit/free TVTs
2)	;CHKARG	ELP+^D13 ; Invalid local address/port(LP=0)
2)	;STATx	ELP+^D20 ; Funny pointer to STAT% (offset)
2)	;STATx	ELP+^D21 ; Bad pointers/transfer size to STAT%
2)	;STATx	ELP+^D22 ; Invalid name
2)	;CHKARG	ELT+^D31 ; TCP not yet initialized
2)	;Ret+2:	Success
2)	
2)	.STAT::	MCENT			; Enter monitor context
2)		SETZ FR,		; No flags
2)	MNTM5	AOS CELL(TCJSU,0,,TCJ)	; Count STAT%s
2)	
2)		MOVX T1,PT%TST		; STAT% JSYS
2)		TXNN FR,1B0		; TCB trace or
2)		 TDNE T1,MNTRAC		; Want trace?
2)		  CALL PRNPKT		; Yes
2)	
2)		UMOVE T1,1		; Get arg back
2)		TXNE T1,<TCP%HP!TCP%SC!OPNFLG>&^-<TCP%JS!TCP%WT!STSFLG>
2)		  JRST TCPILP		; Illegal control bit
2)	 	CALL STATSB		; Decode function bits, call function
2)		JUMPL T1,TCPERR		; There was something wrong.
2)	MNTM5	AOS CELL(TCJSU,1,,TCJ)	; Successful STAT%s
2)		SMRETN
2)	
2)	STATSB:	TXNE T1,TCP%NT		; AOBJN pointer for TVTs wanted?
2)		  CALLRET STATNT	; Yes
2)		TXNE T1,TCP%NI		; AOBJN pointer for connections wanted?
2)		  CALLRET STATNI	; Yes
2)		TXNN T1,TCP%SD		; If just want definitions, don't validate JCN
2)		 TXNE T1,TCP%ST		; Asking for statistics?
2)		  CALLRET STATS		; Yes
2)		MOVE T2,T1		; Flags!connection info for CHKARG
2)		XMOVEI T1,STAT1		; Select routine to call
2)		TXO T1,<051B8>		; STAT%/ TCB
2)		CALLRET CHKARG		; Validate JCN, set TCB, call STAT1
2)	

; TCPBBN.MAC.1 & <BBN-MONITOR>TCPBBN.MAC.1  9-Mar-88 1334	PAGE 42


2)	^L
2)	;Return in 2/ -#TVTs,,first TVT
2)	
2)	STATNT:	MOVE T2,TVTPTR		; Get AOBJN pointer
2)	MNTM5	AOS CELL(TCJSU,2,,TCJ)	; STAT% TVT AOBJN counters
2)		JRST STATO2
2)	
2)	;Return in 2/ -# connections,,1
2)	


LINE 40, PAGE 19
1)		UMOVEM T2,2		; to user
1)		SMRETN			; All ok
1)	^L
1)	; Just copy the statistics area to user space
1)	
1)	STATS:	SETZ TCB,		; Be safe
1)		TXNE T1,TCP%SY		; Giving symbolic names?
1)	         JRST STATS9		; Yes
1)		HLRE T1,T2		; Get count
1)		MOVNS T1		; As a positive number
1)		HLRE T4,T3		; Get size of user's area
1)		MOVNS T4		; As a positive number
1)		CAMLE T1,T4		; Take min as size of transfer
1)	         MOVE T1,T4
1)		MOVEI T4,0(T2)		; Start point
1)		ADD T4,T1		; End + 1
1)		CAILE T4,STATZZ-STAT0	; Compare with size of statistics area
1)	         JRST STATS8		; Tell him it is bad.
1)		PUSH P,T1		; Save for awhile
1)		MOVEI T2,STAT0(T2)	; Start address within statistics area
1)		HRRZS T3		; Assume user section 0
1)		CALL BLTMU		; Transfer from monitor to user
1)		POP P,T4		; Recover size
1)		HRLS T4			; Make N,,N
1)		XCTU [ADDM T4,T2]	; Update user's pointers
1)		XCTU [ADDM T4,T3]
1)		SMRETN
1)	
1)	STATS8:	HRROI T1,ELP+^D21	; Bad arg to STAT
1)		JRST TCPERR
1)	
1)	STATS9:	CALL STATNM		; Do work
1)		JUMPL T1,TCPERR		; Error exit
1)		SMRETN
1)	
1)	^L	SUBTTL STAT JSYS - Get status of a connection - Second Phase
1)	
1)	;T1/	JCN specified by caller (ignored here)
1)	;TCB/	(Extended) Locked connection block

; TCPBBN.MAC.1 & <BBN-MONITOR>TCPBBN.MAC.1  9-Mar-88 1334	PAGE 43


1)	;     	NOINT
1)	;	CALL STAT1
1)	;Ret+1:	Always.  T1 has 0 for OK, or -1,,error
1)	;			-1,,ELP+^D20
1)	;			-1,,ELP+^D21
1)	
1)	STAT1:	LOCAL <XFRCNT>
1)		UMOVE T1,T1		; Get flags
1)		UMOVE T2,T2		; Get pointer
1)		UMOVE T3,T3		; Get pointer to user space
1)		TXNE T1,TCP%SY		; Giving symbolic names?
1)	         JRST STAT6		; Yes
1)		JUMPGE T2,STAT9		; Strange pointer
1)		JUMPGE T3,STAT9		; Strange pointer
1)		HLRE T1,T2		; Get count
1)		MOVNS T1		; As a postive number
1)		HLRE XFRCNT,T3		; Get size of user's area
1)		MOVNS XFRCNT		; As a postive number
1)		CAMLE XFRCNT,T1		; Take min as size of transfer
1)	         MOVE XFRCNT,T1
1)		HRRZ T4,T2		; Start offset
1)		CAIL T4,TCBSIZ		; Must be within TCB
1)	         JRST STAT8		; Tell him "bad arg"
1)		ADD T4,XFRCNT		; Compute end+1
1)		CAILE T4,TCBSIZ		; Trying to read too much?
1)	         JRST STAT8		; Tell him arg is bad.
1)		HRRZS T2		; Flush the count
1)		ADD T2,TCB		; Start address within TCB
1)		HRRZS T3		; Flush the count (assume user sec 0)
1)		MOVE T1,XFRCNT		; Set up count
1)		CALL BLTMU		; Transfer from monitor to user
1)		HRLS XFRCNT
1)		XCTU [ADDM XFRCNT,T2]	; Update user's pointers
1)		XCTU [ADDM XFRCNT,T3]
1)		MOVX T1,OK		; Tell caller all is well
1)		EXIT STATX
1)	
1)	STAT6:	CALL STATNM		; Do the work
1)		JRST STATX
1)	
1)	STAT8:	SKIPA T1,[-1,,ELP+^D20]	; "Funny pointer to STAT"
1)	STAT9:	  HRROI T1,ELP+^D21	; "Bad transfer size to STAT"
1)	STATX:	RESTORE
1)		RET
1)	
1)	^L	SUBTTL STATNM - Symbolic Routines
1)	
1)	; T1/	User flags
1)	; T2/	Input count/pointer
1)	; T3/	Output count/pointer
1)	;	CALL STATNM

; TCPBBN.MAC.1 & <BBN-MONITOR>TCPBBN.MAC.1  9-Mar-88 1334	PAGE 44


1)	;Ret+1:	Always  T1 has error code or 0
1)	
1)	STATNM:	LOCAL <UFL,INP,OUP>
1)		PUSH P,TCB-1		; Used for STAT0
1)		XMOVEI TCB-1,STAT0	; References
1)		JUMPGE T2,STATNV	; IN pointer error
1)		JUMPGE T3,STATNV	; OUT pointer error
1)		MOVEM T1,UFL		; Save flags (TCP%SD)
1)		MOVEM T2,INP		; Save pointers
1)		MOVEM T3,OUP
1)	
1)	; Know have valid input ptr & at least 1 output slot
1)	
1)	STATN3:	UMOVE T4,(INP)		; Get name
1)		CALL SRCH		; Lookup name
1)		JUMPE T2,STATNW		; Lose
1)		TXNE UFL,TCP%SD		; Want pointer or value?
1)		  MOVEI T2,1		; Pointer has only one value
1)		TXNE UFL,TCP%SD		; Want pointer or value?
1)		 SKIPA T1,T3		; Get pointer
1)		  LDB T1,T3		; Get value
1)	
1)	STATN7:	UMOVEM T1,(OUP)		; For user
1)		SOS T2			; One less to go
1)		AOBJP OUP,STATNU	; Leave if output full
1)		JUMPLE T2,STATN8	; End Multiple
1)		ILDB T1,T3		; Get value
1)		JRST STATN7
1)	
1)	STATN8:	AOBJN INP,STATN3	; More input?
1)		SETZ T1,		; No, All done w/o error
1)		JRST STATNX
1)	
1)	STATNU:	SKIPN T1,T2		; Error if more to output
1)	         AOBJP INP,STATNX	; Or more input
1)	STATNV:	SKIPA T1,[-1,,ELP+^D21]	; Bad pointers
1)	STATNW:	 HRROI T1,ELP+^D22	; Invalid name
1)	
1)	STATNX:	UMOVEM INP,2		; Return updated input
1)		UMOVEM OUP,3		; And output pointers
1)		POP P,TCB-1		; Restore register
1)		RESTORE
1)		RET			; Return
1)	
1)	^L	SUBTTL SRCH - Exact Match Binary Search Routine
1)	
1)	; T4/	Symbol
1)	;	CALL SRCH
1)	; T3/	Pointer
1)	; T2/	Count
1)	

; TCPBBN.MAC.1 & <BBN-MONITOR>TCPBBN.MAC.1  9-Mar-88 1334	PAGE 45


1)	SRCH:	TEMP <PRB,XXX,OFS,KEY>
1)		SETZB PRB,T2		; Offset into table & Assume missing
1)		MOVX OFS,1_<^D<36-^L<STABLN>>> ; Get Initial offset (next 2**N)
1)	SRCHF:	ADD PRB,OFS		; Move forward (double)
1)	SRCHR:	LSH OFS,-1		; Next time
1)	         SUB PRB,OFS		; Move reverse
1)		JUMPLE OFS,SRCHX	; Stop if no move
1)		CAIG PRB,STABLN		; Point too far? or
1)		 CAMGE KEY,STSTAB(PRB)	; Value too big?
1)		  JRST SRCHR		; Yes, move back
1)		CAML KEY,STSTAB+1(PRB)	; As far as next?
1)	         JRST SRCHF		; Yes, move forward
1)	SRCHX:	CAME KEY,STSTAB(PRB)	; Exact match?
1)	         RET			; No, error (T2 is 0)
1)		MOVE T3,STATPT(PRB)	; Value
1)		MOVE T2,STATCT(PRB)	; Count
1)		RESTORE
1)		RET
1)	
1)	^L	SUBTTL Symbolic STAT Tables
1)	
1)	DEFINE DEFSTS <
1)		IFN IPPDSW,<XX (M,ACDLAY,HISTSZ)>
1)		XX (M,BGRNCT)
1)		XX (M,BGUSE)
1)		XX (M,BYTRCT)
1)		XX (M,BYTSCT)
1)		XX (M,DGRNCT)
1)		XX (M,DGUSE)
1)		XX (M,DUPKCT)
1)		XX (M,FINRCT)
1)		XX (M,FINSCT)
1)		XX (M,INTBYP)
1)		IFN IPPDSW,<XX (M,IPDLAY,HISTSZ)>
1)		XX (M,IPPKCT)
1)		XX (M,IPRNCT)
1)		XX (M,IPUSE)
1)		XX (M,OHUSE)
1)		IFN IPPDSW,<XX (M,OPDLAY,HISTSZ)>
1)		XX (M,OPPKCT)
1)		XX (M,OPRNCT)
1)		XX (M,OPUSE)
1)		IFN IPPDSW,<XX (M,PZDLAY,HISTSZ)>
1)		XX (M,PZPKCT)
1)		XX (M,PZRNCT)
1)		XX (M,PZUSE)
1)		IFN IPPDSW,<XX (M,RADLAY,HISTSZ)>
1)		XX (M,RAPKCT)
1)		XX (M,RARNCT)
1)		XX (M,RAUSE)
1)		XX (M,RSTRCT)

; TCPBBN.MAC.1 & <BBN-MONITOR>TCPBBN.MAC.1  9-Mar-88 1334	PAGE 46


1)		XX (M,RSTSCT)
1)		IFN IPPDSW,<XX (M,RXDLAY,HISTSZ)>
1)		XX (M,RXPKCT)
1)		XX (M,RXRNCT)
1)		XX (M,RXUSE)
1)		XX (M,SYNRCT)
1)		XX (M,SYNSCT)
1)		XX (T,TABTFX)
1)		XX (M,TASKCT)
1)		XX (T,TCBIO,<1_<WID(PIDO)>-1-<MINIHS+3>/4>)
1)		XX (T,TCBIR,<1_<WID(PIDO)>-1-<MINIHS+3>/4>)
1)		XX (T,TCBIU,<1_<WID(PIDO)>-1-<MINIHS+3>/4>)
1)		XX (T,TCBTO,<1_<WID(PTDO)>-1-<MINTHS+3>/4>)
1)		XX (T,TCBTR,<1_<WID(PTDO)>-1-<MINTHS+3>/4>)
1)		XX (T,TCBTU,<1_<WID(PTDO)>-1-<MINTHS+3>/4>)
1)		XX (T,TCTBS)
1)		XX (T,TCTSQ)
1)		XX (T,TERBF)
1)		XX (T,TERJN)
1)		XX (T,TERR)
1)		XX (T,TERRF)
1)		XX (T,TERRT)
1)		XX (T,TFH)
1)		XX (T,TFP)
1)		XX (T,TIFDF)
1)		XX (T,TIPDO)
1)		XX (T,TIPOR)
1)		XX (T,TIPOU)
1)		XX (T,TJCN)
1)		XX (T,TLH)
1)		XX (T,TLP)
1)		XX (T,TMNRT)
1)		XX (T,TMXRT)
1)		XX (T,TOFRK)
1)		XX (T,TOPFH)
1)		XX (T,TOPFP)
1)		XX (T,TOPLH)
1)		XX (T,TOPNF)
1)		XX (T,TOWNR)
1)		XX (T,TPICA)
1)		XX (T,TPICE)
1)		XX (T,TPICR)
1)		XX (T,TPICS)
1)		XX (T,TPICU)
1)		XX (T,TPICX)
1)		XX (T,TPIFA)
1)		XX (T,TPIFE)
1)		XX (T,TPIFR)
1)		XX (T,TPIFS)
1)		XX (T,TPIFU)
1)		XX (T,TPIFX)

; TCPBBN.MAC.1 & <BBN-MONITOR>TCPBBN.MAC.1  9-Mar-88 1334	PAGE 47


1)		XX (T,TRBS)
1)		XX (T,TRCBY)
1)		XX (T,TRIS)
1)		XX (T,TRLAK)
1)		XX (T,TRLFT)
1)		XX (T,TRLWN)
1)		XX (T,TRPP)
1)		XX (T,TRSYN)
1)		XX (T,TRURG)
1)		XX (T,TRURP)
1)		XX (T,TRWND)
1)		XX (T,TRXI)
1)		XX (T,TRXPD)
1)		XX (T,TRXPI)
1)		XX (T,TRXPN)
1)		XX (T,TSABT)
1)		XX (T,TSBYT)
1)		XX (T,TSCB)
1)		XX (T,TSCR)
1)		XX (T,TSEP)
1)		XX (T,TSFP)
1)		XX (T,TSLFT)
1)		XX (T,TSLVC)
1)		XX (T,TSLVN)
1)		XX (T,TSMRT)
1)		XX (T,TSMXB)
1)		XX (T,TSMXP)
1)		XX (T,TSOPN)
1)		XX (T,TSPRS)
1)		XX (T,TSSEQ)
1)		XX (T,TSSV)
1)		XX (T,TSSYN)
1)		XX (T,TSTO)
1)		XX (T,TSUOP)
1)		XX (T,TSURG)
1)		XX (T,TSURP)
1)		XX (T,TSWND)
1)		XX (T,TTOS)
1)		XX (T,TTPDO)
1)		XX (T,TTPOR)
1)		XX (T,TTPOU)
1)		XX (T,TTTL)
1)		XX (T,TTVT)
1)		XX (T,TVTL)
1)		XX (T,TWLDN)
1)		XX (T,TWLDP)
1)		XX (T,TWLDT)
1)	> ; End of DEFINE DEFSTS
1)	
1)	; Construct the ASCII Name Table
1)	

; TCPBBN.MAC.1 & <BBN-MONITOR>TCPBBN.MAC.1  9-Mar-88 1334	PAGE 48


1)	DEFINE XX (TYP,NAM,LEN)<
1)	IFLE <ASCII /NAM/>-..XL,<PRINTX ? DEFSTS NAM is truncated or out of order>
1)		..XL=ASCII /NAM/
1)		EXP ..XL
1)	> ; End of DEFINE XX
1)	
1)		..XL=400000000000
1)	STSTAB:	400000000000		; Minimum
1)		XLIST
1)		DEFSTS			; Status names
1)		LIST
1)		377777777777		; Maximum
1)	STABLN=.-STSTAB-2
1)	
1)	; Construct the Count Table
1)	
1)	DEFINE XX (TYP,NAM,LEN)<
1)		IFB  <LEN>,<1>
1)		IFNB <LEN>,<LEN>
1)	> ; End of DEFINE XX
1)	
1)	STATCT:	0			; Minimum
1)		XLIST
1)		DEFSTS			; Status counts
1)		LIST
1)		0			; Maximum
1)	
1)	; Construct the LDB Pointer Table
1)	
1)	DEFINE XLDB  (L,O,M)<	<^D<35-POS(M)>>B5+<WID(M)>B11+<TCB>B17+O >
1)	
1)	DEFINE XX (TYP,NAM,LEN)<
1)		..XL=-1
1)	  IFIDN <TYP><M>,<			POINT 36,NAM-STAT0(TCB-1),35
1)			..XL=..XL+1> ; End IFIDN M
1)	  IFIDN <TYP><T>,<	IFNDEF %'NAM,<	POINT 36,NAM(TCB),35>
1)				IFDEF  %'NAM,<	%'NAM (XLDB,,,NAM)>
1)			..XL=..XL+1> ; End IFIDN T
1)	  IFN ..XL,<PRINTX ? Type code for NAM must be M or T>
1)	> ; End of DEFINE XX
1)	
1)	STATPT:	0
1)		XLIST
1)		DEFSTS			; Status pointers
1)		LIST
1)		0
1)	
1)		PURGE ..XL
1)	
1)	^L	SUBTTL CHANL - Set TCP Event Interrupt Channels
1)	

; TCPBBN.MAC.1 & <BBN-MONITOR>TCPBBN.MAC.1  9-Mar-88 1334	PAGE 49


LINE 13, PAGE 30
2)	MNTM5	AOS CELL(TCJSU,3,,TCJ)	; STAT% connection AOBJN counters
2)	STATO2:	UMOVEM T2,2		; Result to user
2)	STATOK:	MOVX T1,OK		; Tell caller all is well
2)		RET			; All ok
2)	
2)	;Function with offsets/names may return OK, or
2)	;STATx	-1,,ELP+^D20 ; Funny pointer to STAT (offset)
2)	;STATx	-1,,ELP+^D21 ; Bad pointers/transfer size to STAT
2)	;STATx	-1,,ELP+^D22 ; Invalid name
2)	
2)	;Copy the statistics area to user space, T1/ flags
2)	
2)	STATS:	SETZ TCB,		; Be safe
2)		TXNE T1,TCP%SY		; Giving symbolic names?
2)		IFSKP.			; No
2)	MNTM5	  AOS CELL(TCJSU,4,,TCJ) ; STAT% statistics requests w/offsets
2)		  XMOVEI Q1,STAT0	; Base for offsets
2)		  MOVX Q2,STATZZ-STAT0	; Invalid offset
2)		  CALLRET STATSO	; Perform function, TCB zero
2)		ENDIF.
2)	MNTM5	AOS CELL(TCJSU,5,,TCJ)	; STAT% statistics requests w/symbols
2)		CALLRET STATSS		; Perform function, TCB zero
2)	
2)	;STAT% JSYS - Get status of a connection - Phase 1
2)	
2)	;TCB/	Extended Locked connection block
2)	;	CALL STAT1     	NOINT
2)	;Ret+1:	Always.  T1 has 0 for OK, or -1,,error
2)	
2)	STAT1:	LOAD FR,TERRT,(TCB)	; Want error trace?
2)		SKIPE FR		; No
2)		  MOVX FR,1B0		; Yes
2)		UMOVE T1,1		; Caller's flags
2)		TXNE T1,TCP%SY		; Giving symbolic names?
2)		IFSKP.			; No
2)	MNTM5	  AOS CELL(TCJSU,6,,TCJ) ; STAT% for connection w/offsets
2)		  MOVE Q1,TCB		; Base for offsets
2)		  MOVX Q2,TCBSIZ	; Invalid offset
2)		  CALLRET STATSO	; Perform function, TCB valid
2)		ENDIF.
2)	MNTM5	AOS CELL(TCJSU,7,,TCJ)	; STAT% for connection w/symbols
2)		CALLRET STATSS		; Perform function, TCB valid
2)	^L
2)	;Given offsets ...
2)	
2)	STATSO:	XCTU [DMOVE T1,1]	; Set up ACs
2)		XCTU [DMOVE T3,3]
2)		IFL. T2			; Non-zero input count and
2)		ANDL. T3		; Non-zero output count
2)	

; TCPBBN.MAC.1 & <BBN-MONITOR>TCPBBN.MAC.1  9-Mar-88 1334	PAGE 50


2)		  HLRE T1,T2		; Get user's input count
2)		  MOVNS T1		; As a postive number
2)		  HLRE T4,T3		; Get size of user's output area
2)		  MOVNS T4		; As a postive number
2)		  CAMLE T1,T4		; Take min as size of transfer
2)		    MOVE T1,T4
2)	
2)		  HRRES T2		; Start offset
2)		  IFGE. T2
2)		    SUB Q2,T1		; Valid words beyond start
2)		    CAMLE T2,Q2		; Trying to read too much?
2)		    ANSKP.		; No
2)		      MOVE T4,T1	; Transfer count in RH
2)		      HRLS T4		; Transfer count in both halves
2)		      XCTU [ADDM T4,2]	; Update user's pointers
2)		      XCTU [ADDM T4,3]
2)	
2)		      ADD T2,Q1		; Start address within data area
2)		      HRRZS T3		; Flush the count (assume user sec 0)
2)		      CALL BLTMU	; Transfer from monitor to user
2)		      JRST STATOK
2)		  ENDIF.
2)	
2)		  HRROI T1,ELP+^D20	; "Funny pointer to STAT"
2)		ELSE.
2)		  HRROI T1,ELP+^D21	; "Bad transfer size to STAT"
2)		ENDIF.
2)		RET
2)	
2)	
2)	
2)	;Given symbols ...	TCB zero or valid
2)	
2)	STATSS:	SAVEAC <Q1,Q2,Q3,P1,<TCB-1>> ; Shouldn't be required, but do it anyway
2)	
2)		XCTU [DMOVE Q1,1]	; Set up ACs
2)		XCTU [DMOVE Q3,3]
2)		CALL STATNM		; Do work, return error code
2)	
2)		XCTU [DMOVEM Q2,2]	; Return results, STAT% format
2)		TXNE Q1,TCP%SL		; Want lengths?
2)		  UMOVEM P1,4		; Yes, return updated pointer
2)		RET
2)	
2)	^L	SUBTTL	TCSTAT - Invoked by IPOPR% or TCOPR%
2)	
2)	;T1/	-1, invoked by IPOPR%
2)	;	otherwise, is TCB corresponding to TCOP% JFN
2)	;	CALL TCSTAT
2)	;Ret+1:	Always, T1 has TOPS-20 error code
2)	

; TCPBBN.MAC.1 & <BBN-MONITOR>TCPBBN.MAC.1  9-Mar-88 1334	PAGE 51


2)	TCSTAT::			
2)	IFN <TCB-1-PKT>,<SAVEAC <PKT>>
2)		SAVEAC <<TCB-1>,TCB>
2)		CAMN T1,[-1]		; Who called
2)		  JRST TCSTAI		; IPOPR%
2)	
2)					; TCOPR%,  T1 has alleged TCB address
2)		MOVE PKT,T1		; Validate TCB for JFN by looking it up in TCBH
2)	
2)		MOVX T1,TCPX34		; Assume bad argument
2)		UMOVE T3,3		; Argument block address
2)		UMOVE T2,.TCFLG(T3)	; Flags from argument block
2)		TXNN T2,<TCP%NT!TCP%TV!TCP%NI!TCP%IX!TCP%ST!TCP%JS> ; Only SY [+SD+SL]
2)		 TXNE T2,<TCP%HP!TCP%SC!OPNFLG>&^-<TCP%JS!TCP%WT!STSFLG>
2)		  RET			; Bad argument
2)	
2)		CALL INTBCK	;(PKT)	; TCB in correct region of memory?
2)		IFSKP.			; Yes
2)		  MOVE TCB,PKT		; In correct memory region, not really a PKT
2)		  LOAD T1,TLP,(TCB)	; If TCB is valid, can get LP
2)		  CALL TCBHSH		; Hash LP into a TCBH index
2)		  MOVE T1,T2		; Get working pointer, save queue head
2)		  DO.
2)	  	    LOAD T1,QNEXT,(T1)	; Get next entry in chain
2)	IFN TCBQ,<  XMOVEI T3,-TCBQ(T1) ; Locate top of structure
2)		    CAMN T3,TCB>	; Desired TCB?
2)	IFE TCBQ,<  CAMN T1,TCB>	; Desired TCB?
2)		    IFSKP.
2)		      CAME T1,T2	; Back to head?
2)		        LOOP.		; No, go check this one
2)		      SETZ TCB,		; TCB has vanished! (or unOPENF%ed DEC TCB)
2)		    ENDIF.
2)		  ENDDO.
2)		  IFN. TCB		; If valid
2)		    XMOVEI T1,TCBLCK(TCB) ; Pointer to lock on that TCB
2)		    XMOVEI T2,TCSTAU	; Function to be applied to TCB, with id code
2)		    TXO T2,<056B8>	; TCOPR% id
2)		    CALL LCKCAL		; Lock the TCB and Abort the JCN
2)		  ELSE.
2)		    MOVX T1,TCPX34	; Bad TCB or arguments
2)		  ENDIF.
2)		ENDIF.
2)	
2)		RET
2)	^L
2)	;TCSTAU	TCOPR% access to connection data. Args in User block pointer to by 3.
2)	
2)	;TCB/	Extended locked TCB pointer
2)	;	CALL TCSTAU
2)	;Ret+1:	Always, T1/ TOPS-20 error code
2)	

; TCPBBN.MAC.1 & <BBN-MONITOR>TCPBBN.MAC.1  9-Mar-88 1334	PAGE 52


2)	TCSTAU:	SAVEAC <Q1,Q2,Q3,P1,<TCB-1>>
2)		XCTU [MOVE T3,3]		; Address of argument block
2)		XCTU [DMOVE Q1,.TCFLG(T3)]	; Get args
2)		XCTU [DMOVE Q3,.TCDTP(T3)]
2)		CALL STATNM			; Return requested information
2)		XCTU [MOVE T3,3]		; Address of argument block
2)		XCTU [DMOVEM Q2,.TCNMP(T3)]	; Update arguments
2)		TXNE Q1,TCP%SL			; Want lengths?
2)		  XCTU [MOVEM P1,.TCLNP(T3)]	; Yes, return updated pointer
2)	TCSTAX:	IFE. T1
2)	TCSTOK:	  MOVX T1,MNTX00		; OK return
2)		ELSE.
2)		  CAIG T1,600000		; TCP error code?
2)		    MOVX T1,TCPX34		; Bad argument
2)		ENDIF.
2)		RET
2)	^L
2)	;TCSTAI	IPOPR% access to statistics and connections.  Args in User block 2.
2)	
2)	TCSTAI:				; IPOPR%
2)		XCTU [MOVE T3,2]		; Get address of argument block
2)		XCTU [MOVE T2,.TCFLG(T3)]	; Get function flags
2)		MOVX T1,TCPX34			; TCOPR argument error
2)		TXNE T2,<TCP%HP!TCP%SC!OPNFLG>&^-<TCP%JS!TCP%WT!STSFLG>
2)		  RET				; Bad argument
2)	
2)		TXZE T2,TCP%NT			; AOBJN pointer for TVTs wanted?
2)		 TLNE T2,-1			; Just TCP%NT bit?
2)		IFSKP.				; Yes
2)		  MOVE T3,TVTPTR		; Get AOBJN pointer
2)	MNTM5	  AOS CELL(TCJSU,2,,TCJ)	; STAT% TVT AOBJN counters
2)		  JRST TCSTA3			; Return -#TVTs,,first TVT
2)		ENDIF.
2)	
2)		TXZE T2,TCP%NI			; AOBJN pointer for connections wanted?
2)		 TLNE T2,-1			; Just TCP%NI bit?
2)		IFSKP.				; Yes
2)		  MOVN T3,TCBCNT		; # connections
2)		  HRLS T3			; in LH
2)		  HRRI T3,1			; First conn. #, 3/ -# conn,,1
2)	MNTM5	  AOS CELL(TCJSU,3,,TCJ)	; STAT% connection AOBJN counters
2)	TCSTA3:	  XCTU [MOVE T2,2]		; Address of argument block
2)		  XCTU [MOVEM T3,.TCNMP(T2)]	; Return 3
2)		  JRST TCSTOK
2)		ENDIF.
2)	
2)		TXNN T2,TCP%SY			; Only names supported
2)		  RET				; Bad argument, T1/ TCPX34
2)	
2)		SETZ TCB,			; Assume not need TCB
2)		TXNN T2,TCP%JS+TCP%TV+TCP%IX	; Have connection info and

; TCPBBN.MAC.1 & <BBN-MONITOR>TCPBBN.MAC.1  9-Mar-88 1334	PAGE 53


2)		 TXNN T2,TCP%ST+TCP%SD		; Need it?
2)		IFSKP.				; No, connectionless
2)	TCSTAJ:	  SAVEAC <Q1,Q2,Q3,P1,<TCB-1>>	; TCB/ Extended Locked connection block
2)		  XCTU [MOVE T3,2]		; Address of argument block
2)		  XCTU [DMOVE Q1,.TCFLG(T3)]	; Get args
2)		  XCTU [DMOVE Q3,.TCDTP(T3)]
2)		  CALL STATNM			; Return requested information
2)		  XCTU [MOVE T3,2]		; Address of argument block
2)		  XCTU [DMOVEM Q2,.TCNMP(T3)]	; Update pointers
2)		  TXNE Q1,TCP%SL		; Want lengths?
2)		    XCTU [MOVEM P1,.TCLNP(T3)]	; Yes, return updated pointer
2)		ELSE.				; Validate connection info, set TCB
2)		  XMOVEI T1,TCSTAJ		; Select routine to call
2)		  TXO T1,<054B8>		; IPOPR% ID
2)						; T2/ flags!connection info
2)		  CALL CHKARG			; Check arguments, set TCB, call TCSTAJ
2)		ENDIF.
2)		JRST TCSTAX			; Translate error code & return
2)	
2)	^L	SUBTTL STATNM - Symbolic Routines
2)	
2)	UFL==Q1	; User's AC1, flags and connection info (TCP%WT implies TCB valid)
2)	INP==Q2	; User's AC2, Input count and address
2)	OUP==Q3	; User's AC3, Output count and address
2)	OUC==P1	; User's AC4, Lengths address, if TCP%SL
2)	;TCB/	Zero or valid TCB address
2)	;	CALL STATNM	TCB-1 saved
2)	;Ret+1:	Always.  T1/ Error code, or 0; Q2-P1 undated.
2)	;STATx	-1,,ELP+^D01 ; Invalid parameter (need connection info)
2)	;STATx	-1,,ELP+^D21 ; Bad pointers/transfer size to STAT
2)	;STATx	-1,,ELP+^D22 ; Invalid name
2)	
2)	..STBT==4	; Bit in TCB but not in TCB-1
2)	IFE <TCB&..STBT>,<PRINTX % Fix ..STBT in STATNM>
2)	IFN <<TCB-1>&..STBT>,<PRINTX % Fix ..STBT in STATNM>
2)	
2)	STATNM:	XMOVEI TCB-1,STAT0	; For references in statistics area
2)		JUMPGE INP,STATNV	; IN count error
2)		JUMPGE OUP,STATNV	; OUT count error
2)		TLZ OUC,-1		; Only address here
2)					; Input ptr valid & at least 1 output slot
2)		DO.
2)		  UMOVE T4,(INP)	; Get name
2)		  CALL SRCH		; Lookup name in T4 to T2/ Len, T3/ Ptr
2)		  JUMPE T2,STATNW	; Error, name not in table
2)	
2)		  TXNN UFL,TCP%SL	; Want legnths?
2)		  IFSKP.
2)		    UMOVEM T2,(OUC)	; Yes, give length to user
2)		    AOS OUC		; Bump pointer, too
2)		  ENDIF.

; TCPBBN.MAC.1 & <BBN-MONITOR>TCPBBN.MAC.1  9-Mar-88 1334	PAGE 54


2)	
2)		  TXNN UFL,TCP%SD	; Want pointer or value?
2)		  IFSKP.
2)		    MOVX T2,1		; Pointer has length 1
2)		    MOVE T1,T3		; Get pointer
2)		  ELSE.
2)		    IFE. TCB		; No valid TCB
2)		      TXNE T3,<<..STBT>B17> ; Pointer use TCB?
2)		        JRST STATNX	; Yes, but don't have it
2)		    ENDIF.	    
2)		    LDB T1,T3		; Get (first) value
2)		  ENDIF.
2)	^L
2)		  DO.			; Return all data bytes for name to user
2)		    UMOVEM T1,(OUP)	; Datum to user
2)		    SOS T2		; One less to go
2)		    AOBJP OUP,STATNU	; Leave if output full
2)		    JUMPLE T2,ENDLP.	; End multiple word "value"
2)		    ILDB T1,T3		; Get value
2)		    LOOP.		; Back for rest
2)		  ENDDO.
2)		  AOBJN INP,TOP.	; Loop if have another name
2)		ENDDO.
2)	
2)		MOVX T1,<OK>		; All done w/o error
2)		RET
2)	
2)	
2)	STATNU:	SKIPN T1,T2		; Error if more to output
2)		  AOBJP INP,R		; Or more input (NB T1 is 0 = OK)
2)	STATNV:	HRROI T1,ELP+^D21	; Bad pointers
2)		RET
2)	
2)	STATNW:	HRROI T1,ELP+^D22	; Invalid name
2)		RET
2)	
2)	STATNX:	HRROI T1,ELP+^D01	; Invalid parameter, need a connection
2)		TXNN UFL,TCP%SL		; Returning legnths?
2)		  SOS OUC		; Yes, undo so returned info is consistent
2)		RET
2)	
2)		PURGE	UFL,INP,OUP,OUC
2)	
2)	^L	SUBTTL SRCH - Exact Match Binary Search Routine
2)	
2)	;T4/	Symbol
2)	;	CALL SRCH
2)	;Ret+1:	  Not found
2)	;Ret+2:	Found and T3/ Pointer, T2/ Count
2)	
2)	PRB==T1

; TCPBBN.MAC.1 & <BBN-MONITOR>TCPBBN.MAC.1  9-Mar-88 1334	PAGE 55


2)	XXX==T2
2)	OFS==T3
2)	KEY==T4
2)	
2)	SRCH:	HRRZ OFS,STSTAB-2	; Next 2**N larger than STABLN
2)		SETZB PRB,T2		; Offset into table & assume missing
2)		DO.
2)		  ADD PRB,OFS		; Move forward (double)
2)		  DO.
2)		    LSH OFS,-1		; Offset for next time
2)		    SUB PRB,OFS		; Move reverse or forward (single)
2)		    JUMPLE OFS,SRCHK	; Stop if no move
2)		    CAMG PRB,STSTAB-1	; Point too far? or
2)		     CAMGE KEY,STSTAB(PRB) ; Value too big?
2)		      LOOP.		; Yes, move reverse
2)		  ENDDO.
2)		  CAML KEY,STSTAB+1(PRB) ; As far as next?
2)		    LOOP.		; Yes, move forward
2)		ENDDO.
2)	SRCHK:	CAME KEY,STSTAB(PRB)	; Exact match?
2)		  RET			; No, error (T2 is 0)
2)					; Yes
2)		HRRE T3,STATPT(PRB)	; Offset (sign extended)
2)		LSH T3,-4		; Restore bits crunched for net
2)		HLL T3,STATPT(PRB)	; Pointer
2)		HLRZ T2,STATCT(PRB)	; Count
2)		RET
2)	
2)		PURGE PRB,XXX,OFS,KEY
2)	
2)	^L	SUBTTL CHANL% - Set TCP Event Interrupt Channels
2)	


LINE 6, PAGE 25
1)	;	CHANL
1)	;Ret+1:	 Error, Code in T1.
1)	;		from CHKARG
1)	;			ELP+^D17 Bad arg to CHANL
1)	;Ret+2:	Success
1)	
1)	IFE REL6,<.CHANL::>
1)	IFN REL6,<XNENT .CHANL,G>
1)		MCENT			; Enter monitor context
1)		TXNE T1,<STSFLG!TCP%FS!TCP%PS!TCP%VT!TCP%HP!TCP%SC>&^-<TCP%JS!TCP%WT>
1)		  JRST TCPILP		; Illegal control bit
1)		XMOVEI T1,CHANL1	; Select routine to call via CHKARG
1)		CALL CHKARG		; Check arguments, set TCB, call CHANL1
1)		JUMPL T1,TCPERR		; Jump if something is wrong.
1)		SMRETN
1)	

; TCPBBN.MAC.1 & <BBN-MONITOR>TCPBBN.MAC.1  9-Mar-88 1334	PAGE 56


1)	;CHANL1(TCB)
1)	;Second phase of CHANL JSYS
1)	
1)	;T1/	JCN specified by caller (ignored here)
1)	;TCB/	(Extended) Locked Connection Block
1)	;      	NOINT
1)	;	CALL CHANL1
1)	;Ret+1:	Always.  T1 has 0 if OK, or -1,,error
1)	;			-1,,ELP+^D17 Bad arg to CHANL
1)	
1)	CHANL1:	TEMP <NEW,OLD,CNT,FORKID>
1)		LOCAL <NEWCHS,NEWPTR,OLDPTR,FRKPTR>
1)		UMOVE NEWCHS,T2		; Get channel word from user
1)		MOVE NEWPTR,[POINT 6,NEWCHS]	; Set to scan them
1)		MOVE OLDPTR,[POINT 6,TCBPIC(TCB)]; Set to scan current ones
1)		MOVE FRKPTR,[POINT 18,TCBPIF(TCB)]; Set to scan forks
1)		MOVEI CNT,6		; How many to scan
LINE 6, PAGE 38
2)	;	CHANL%
2)	;Ret+1:	 Error, Code in T1.
2)	;CHKARG	ELP+^D01 ; JCN out of range/no TCB, Illegal connection/control bit
2)	;CHKARG	ELT+^D04 ; No free JCN/TCB space/free WAIT bit/free TVTs
2)	;CHKARG	ELP+^D13 ; Invalid local address/port(LP=0)
2)	;CHANL1	ELP+^D17 ; Bad arg to CHANL% (not 0-5, 23-35)
2)	;CHKARG	ELT+^D31 ; TCP not yet initialized
2)	;Ret+2:	Success
2)	
2)	.CHANL::
2)		MCENT			; Enter monitor context
2)		TXNE T1,TCP%JS		; JCN must be supplied
2)		 TXNE T1,<STSFLG!TCP%HP!TCP%SC!OPNFLG>&^-<TCP%JS!TCP%WT>
2)		  JRST TCPILP		; Illegal control bit
2)		SETZ FR,		; No flags
2)	MNTM5	AOS CELL(TCJCN,0,,TCJ)	; Count CHANL%s
2)		MOVE T2,T1		; User's AC 1
2)		XMOVEI T1,CHANL1	; Select routine to call via CHKARG
2)		TXO T1,<061B8>		; CHANL%/ TCB
2)		CALL CHKARG		; Check arguments, set TCB, call CHANL1
2)		JUMPL T1,TCPERR		; Jump if something is wrong.
2)	MNTM5	AOS CELL(TCJCN,1,,TCJ)	; Successful CHANL%s
2)		SMRETN
2)	
2)	^L	SUBTTL CHANL% - Set TCP Event Interrupt Channels, Phase 1
2)	
2)	;T1/	JCN specified by caller (ignored here)
2)	;TCB/	Extended Locked Connection Block
2)	;      	NOINT
2)	;	CALL CHANL1
2)	;Ret+1:	Always.  T1 has 0 if OK, or -1,,error
2)	;CHANL1	-1,,ELP+^D17 ; Bad arg to CHANL (not 0-5, 23-35)
2)	

; TCPBBN.MAC.1 & <BBN-MONITOR>TCPBBN.MAC.1  9-Mar-88 1334	PAGE 57


2)	NEW==T1
2)	OLD==T2
2)	CNT==T3
2)	FORKID==T4
2)	
2)	CHANL1:	ACVAR <NEWCHS,NEWPTR,OLDPTR,FRKPTR>
2)		LOAD FR,TERRT,(TCB)	; Want error trace?
2)		SKIPE FR		; No
2)		  MOVX FR,1B0		; Yes
2)		UMOVE NEWCHS,2		; Get channel word from user
2)	
2)		MOVE T2,NEWCHS
2)		MOVX T1,PT%TIS		; CHANL% JSYS
2)		TXNN FR,1B0		; TCB trace or
2)		 TDNE T1,MNTRAC		; Want trace?
2)		  CALL PRNPKT		; Yes
2)	
2)		MOVE NEWPTR,[POINT 6,NEWCHS]	; Set to scan them
2)		MOVE OLDPTR,[POINT 6,TCPIC(TCB)]; Set to scan current ones
2)		MOVE FRKPTR,[POINT 18,TCPIF(TCB)]; Set to scan forks
2)		MOVEI CNT,6		; How many to scan


LINE 43, PAGE 25
1)		 CAIG NEW,5		; OK number for the channel?
1)		  JRST CHANL3		; Take the good number
1)		CAIL NEW,^D24		; These are also OK
LINE 35, PAGE 39
2)		 CAIN NEW,76		; Or delete mark?
2)		  TRNA			; Yes, take the number
2)		   CAIG NEW,5		; OK number for the channel?
2)		    JRST CHANL3		; Take the good number
2)		CAIL NEW,^D24		; These are also OK


LINE 49, PAGE 25
1)		CAIE NEW,77		; No change?
1)		  MOVE OLD,NEW		; No.  New will replace old
1)		DPB OLD,NEWPTR		; Construct the replacement set
LINE 43, PAGE 39
2)		CAIN NEW,76		; Deletion?
2)		 TROA OLD,77		; Deletion.  77 will replace old
2)		  CAIN NEW,77		; No change?
2)		   TRNA
2)		    MOVE OLD,NEW	; Change.  New will replace old
2)		DPB OLD,NEWPTR		; Construct the replacement set


; TCPBBN.MAC.1 & <BBN-MONITOR>TCPBBN.MAC.1  9-Mar-88 1334	PAGE 58



LINE 55, PAGE 25
1)		SOJG CNT,CHANL2		; Loop over all six bytes
1)		MOVEM NEWCHS,TCBPIC(TCB); Stash into TCB
1)		TDZA T1,T1		; Tell caller all is well
1)	CHANL9:	  HRROI T1,ELP+^D17	; "Bad arg to CHANL"
1)		RESTORE
1)		RET
1)	
1)	^L	SUBTTL SCSLV JSYS - Set Connection Security Level
1)	
1)	;T1/	Flags,,JCN or pointer to CDB
1)	;T2/	Security Level
1)	;	SCSLV
1)	;Ret+1:	 Error.  Code in T1
1)	;		from CHKARG
1)	;			ELP+^D29 Security already set
1)	;Ret+2:	Success.
1)	
1)	IFE REL6,<.SCSLV::>
1)	IFN REL6,<XNENT .SCSLV,G>
1)		MCENT
1)		TXNE T1,<STSFLG!TCP%FS!TCP%PS!TCP%VT!TCP%HP!TCP%SC>&^-<TCP%JS!TCP%WT>
1)		  JRST TCPILP		; Illegal control bit
1)		XMOVEI T1,SCSLV1	; Select routine to call via CHKARG
1)		CALL CHKARG		; Check args, set TCB, call SCSLV1
1)		JUMPL T1,TCPERR		; Give error return if appropriate
1)		SMRETN			; Otherwise, it was good.
1)	
1)	;SCSLV1(TCB)
1)	;Second Phase of SCSLV JSYS
1)	
LINE 52, PAGE 39
2)		SETO CX,		; Get -1
2)		CAIN NEW,76		; Deleting?
2)		  DPB CX,FRKPTR
2)		SOJG CNT,CHANL2		; Loop over all six bytes
2)		MOVEM NEWCHS,TCPIC(TCB); Stash into TCB
2)		TDZA T1,T1		; Tell caller all is well
2)	CHANL9:	  HRROI T1,ELP+^D17	; "Bad arg to CHANL"
2)		RET
2)	
2)		ENDAV.
2)		PURGE NEW,OLD,CNT,FORKID
2)	
2)	^L	SUBTTL SCSLV% JSYS - Set Connection Security Level
2)	
2)	;T1/	Flags,,JCN or pointer to CDB
2)	;T2/	Security Level
2)	;	SCSLV%

; TCPBBN.MAC.1 & <BBN-MONITOR>TCPBBN.MAC.1  9-Mar-88 1334	PAGE 59


2)	;Ret+1:	 Error.  Code in T1
2)	;CHKARG	ELP+^D01 ; JCN out of range/no TCB, Illegal connection/control bit
2)	;CHKARG	ELT+^D04 ; No free JCN/TCB space/free WAIT bit/free TVTs
2)	;CHKARG	ELP+^D13 ; Invalid local address/port(LP=0)
2)	;SCSLV1	ELP+^D29 ; Can't change security levels
2)	;CHKARG	ELT+^D31 ; TCP not yet initialized
2)	;Ret+2:	Success.
2)	
2)	.SCSLV::
2)		MCENT
2)		TXNE T1,TCP%JS		; JCN must be supplied
2)		 TXNE T1,<STSFLG!TCP%HP!TCP%SC!OPNFLG>&^-<TCP%JS!TCP%WT>
2)		  JRST TCPILP		; Illegal control bit
2)		SETZ FR,		; No flags
2)	MNTM5	AOS CELL(TCJSC,0,,TCJ)	; Count SCSLV%s
2)		MOVE T2,T1		; User's AC 1
2)		XMOVEI T1,SCSLV1	; Select routine to call via CHKARG
2)		TXO T1,<041B8>		; SCSLV%/ TCB
2)		CALL CHKARG		; Check args, set TCB, call SCSLV1
2)		JUMPL T1,TCPERR		; Give error return if appropriate
2)	MNTM5	AOS CELL(TCJSC,1,,TCJ)	; Successful SCSLV%s
2)		SMRETN			; Otherwise, it was good.
2)	
2)	;SCSLV1	SCSLV% JSYS, Phase 1
2)	


LINE 29, PAGE 26
1)	;			-1,,ELP+^D29 Security already set
1)	
1)	SCSLV1:	UMOVE T2,T2		; Get arg from caller
1)		JN TSLVN,(TCB),SCSLVE	; Bad.  No changes allowed.
1)		STOR T2,TSLVN,(TCB)	; Set the new value
1)		TDZA T1,T1		; Get a 0 to indicate OK
1)	SCSLVE:	  HRROI T1,ELP+^D29	; "Can't change security levels"
1)		RET
1)	
1)	^L	SUBTTL TCP Portion of ATNVT JSYS
1)	
1)	;TATNVT
1)	;Part of ATNVT JSYS for TVTs, Returns to USER w/ w/o skip
1)	;TATNVT
1)	;Attach a TVT to a User TCB; Called in non-Job-0 context
LINE 36, PAGE 40
2)	;SCSLV1	-1,,ELP+^D29 ; Can't change security levels
2)	
2)	SCSLV1:	LOAD FR,TERRT,(TCB)	; Want error trace?
2)		SKIPE FR		; No
2)		  MOVX FR,1B0		; Yes
2)		IFQE. TSLVN,(TCB)	; Better be zero
2)		  UMOVE T2,2		; Get arg from caller

; TCPBBN.MAC.1 & <BBN-MONITOR>TCPBBN.MAC.1  9-Mar-88 1334	PAGE 60


2)		  STOR T2,TSLVN,(TCB)	; Set the new value
2)		  MOVX T1,PT%TSL	; SCSLV JSYS
2)		  TXNN FR,1B0		; TCB trace or
2)		   TDNE T1,MNTRAC	; Want trace?
2)		    CALL PRNPKT		; Yes
2)		  MOVX T1,OK
2)		ELSE.
2)		  HRROI T1,ELP+^D29	; "Can't change security levels"
2)		ENDIF.
2)		RET
2)	
2)	^L	SUBTTL TCP Portion of ATNVT% JSYS
2)	
2)	;TATNVT	Part of ATNVT% JSYS for TVTs, Returns to USER w/ w/o skip.
2)	;Attach a TVT to a User TCB; Called in non-Job-0 context


LINE 11, PAGE 27
1)	;	ATNX1	-1,,ELP+^D1	Invalid JCN
1)	;	ATNX2			Receive side not SYNCED
1)	;	ATNX3			User CLOSEd/ABORTed connection
1)	;	ATNX5			Recieve side has been used (RECVs)
1)	;	ATNX6			Connection has been closed, or has errors
1)	;	ATNX8			Send side not SYNCED
1)	;	ATNX11			Send side has been used (SENDs)
1)	;	ATNX13	-1,,ELT+^D4	No TVTs or
1)	;		-1,,ELT+^D31	TCP not Initialized
LINE 9, PAGE 41
2)	;	ATNX1	-1,,ELP+^D01	JCN out of range/no TCB, Illegal connection
2)	;	ATNX2			Receive side not SYNCED
2)	;	ATNX3			User CLOSE%ed/ABORT%ed connection
2)	;	ATNX5			Recieve side has been used (RECV%s)
2)	;	ATNX6			Connection has been closed, or has errors
2)	;	ATNX8			Send side not SYNCED
2)	;	ATNX11			Send side has been used (SEND%s)
2)	;	ATNX13	-1,,ELT+^D04	No TVTs or
2)	;		-1,,ELT+^D31	TCP not Initialized


LINE 23, PAGE 27
1)	TATNVT::XCTU [HRRZ T1,1]	; Get JCN w/o flags
1)		CALL TATTVT		; Call worker routine
1)		 JRST TCPERR		; Return error
1)		SMRETN			; OK (skip) return
LINE 21, PAGE 41
2)	TATNVT::
2)		XCTU [HRRZ T1,1]	; Get JCN w/o flags
2)	MNTM5	AOS CELL(TCJTV,0,,TCJ)	; TATNVT calls
2)		CALL TATTVT		; Call worker routine
2)		  JRST TCPERR		; Return error
2)	MNTM5	AOS CELL(TCJTV,1,,TCJ)	; Successful TATNV1s

; TCPBBN.MAC.1 & <BBN-MONITOR>TCPBBN.MAC.1  9-Mar-88 1334	PAGE 61


2)		SMRETN			; OK (skip) return


LINE 33, PAGE 27
1)	TATTVT::TXO T1,TCP%JS		; Set JCN Supplied
1)		UMOVEM T1,1		; Put it back for CHKARG
1)		XMOVEI T1,TATNV1	; Routine to call
LINE 34, PAGE 41
2)	TATTVT::
2)		SAVEAC <FR>
2)		SETZ FR,		; No flags
2)		MOVE T2,T1		; User's AC 1
2)		TXO T2,TCP%JS		; Set JCN Supplied
2)		XMOVEI T1,TATNV1	; Routine to call


LINE 39, PAGE 27
1)		  CAIN T1,<ELP+^D1>	; Translate TCP error code into TOPS20
1)		   MOVX T1,ATNX1
1)		  CAIE T1,<ELT+^D4>
1)		   CAIN T1,<ELT+^D31>
LINE 43, PAGE 41
2)		  CAIN T1,<ELP+^D01>	; Translate TCP error code into TOPS20
2)		   MOVX T1,ATNX1
2)		  CAIE T1,<ELT+^D04>
2)		   CAIN T1,<ELT+^D31>


LINE 46, PAGE 27
1)		LOAD T1,TVTL,(TCB)	; Make TTY descriptor
LINE 50, PAGE 41
2)	MNTM5	AOS CELL(TCJTV,1,,TCJ)	; Successful TATNV1s
2)		LOAD T1,TVTL,(TCB)	; Make TTY descriptor


LINE 50, PAGE 27
1)	
1)	^L
1)	
1)	;TATNV1(TCB,JCN)
1)	;Second phase of TATNVT
1)	
LINE 1, PAGE 42
2)	^L	SUBTTL TCP Portion of ATNVT% JSYS, Phase 1
2)	


; TCPBBN.MAC.1 & <BBN-MONITOR>TCPBBN.MAC.1  9-Mar-88 1334	PAGE 62



LINE 11, PAGE 28
1)	
1)	TATNV1:	LOCAL <JCN>
1)		MOVEM T1,JCN
1)		MOVX T1,<-1,,ATNX2>
LINE 8, PAGE 43
2)	;	ATNX2			Receive side not SYNCED
2)	;	ATNX3			User CLOSE%ed/ABORT%ed connection
2)	;	ATNX5			Recieve side has been used (RECV%s)
2)	;	ATNX6			Connection has been closed, or has errors
2)	;	ATNX8			Send side not SYNCED
2)	;	ATNX11			Send side has been used (SEND%s)
2)	;	ATNX13	-1,,ELT+^D04 ; No free TVTs
2)	
2)	TATNV1:	ACVAR <JCN>
2)		MOVEM T1,JCN
2)		LOAD FR,TERRT,(TCB)	; Want error trace?
2)		SKIPE FR		; No
2)		  MOVX FR,1B0		; Yes
2)		MOVX T1,<-1,,ATNX2>


LINE 23, PAGE 28
1)		LOAD BFR,QNEXT,<+TCBRBQ(TCB)>
1)		CAIE BFR,TCBRBQ(TCB)	; Without receive buffers
1)	         JRST TATNV9		; Has buffer, error
1)		MOVX T1,<-1,,ATNX11>
1)		LOAD BFR,QNEXT,<+TCBSBQ(TCB)>
1)		CAIE BFR,TCBSBQ(TCB)	; Without send buffers
1)	         JRST TATNV9		; Has buffer, error
1)		MOVX T1,<-1,,ATNX3>
1)		JE TSUOP,(TCB),TATNV9	; Not OPENed by user error
1)		MOVX T1,<-1,,ATNX6>
1)		JE TSOPN,(TCB),TATNV9	; Not still OPEN error
1)		JN TERR,(TCB),TATNV9	; Had some error error
1)		HRRZ T1,TCB		; ASNTVT wants TCB &
1)		TXO T1,AN%NTP		; Say it will speak new Telnet
1)		IFE REL6,<CALL ASNTVT>	; Assign a virtual terminal
1)		IFN REL6,<CALLX (MSEC1,ASNTVT)> ; Assign a virtual terminal
1)	         JRST TATNV8		; Failed (no TVT available, etc)
1)		STOR T1,TVTL,(TCB)	; Save TTY # connection block
1)	^L
1)	; Forget everything about Job which opened connection & give to Job0
1)	
LINE 30, PAGE 43
2)		XMOVEI CX,TCBRBQ(TCB)
2)		LOAD BFR,QNEXT,(CX)
2)		CAME BFR,CX		; Without receive buffers
2)	         JRST TATNV9		; Has buffer, error

; TCPBBN.MAC.1 & <BBN-MONITOR>TCPBBN.MAC.1  9-Mar-88 1334	PAGE 63


2)		MOVX T1,<-1,,ATNX11>
2)	
2)		XMOVEI CX,TCBSBQ(TCB)
2)		LOAD BFR,QNEXT,(CX)
2)		CAME BFR,CX		; Without send buffers
2)	         JRST TATNV9		; Has buffer, error
2)	
2)		MOVX T1,<-1,,ATNX3>
2)		JE TSUOP,(TCB),TATNV9	; Not OPEN%ed by user error
2)		MOVX T1,<-1,,ATNX6>
2)		JE TSOPN,(TCB),TATNV9	; Not still OPEN% error
2)		JN TERR,(TCB),TATNV9	; Had some error error
2)		MOVE T1,TCB		; ASNTVT wants 23-bit TCB &
2)		TXO T1,AN%NTP		; Say it will speak new Telnet
2)		CALL ASNTVT		; Assign a virtual terminal
2)	         JRST TATNV8		; Failed (no TVT available, etc)
2)		STOR T1,TVTL,(TCB)	; Save TTY # connection block
2)	
2)		MOVE T3,T1		; Line number for trace
2)		MOVX T1,PT%TVT		; ATNVT% JSYS
2)		TXNN FR,1B0		; TCB trace or
2)		 TDNE T1,MNTRAC		; Want trace?
2)		  CALL PRNPKT		; Yes
2)	^L
2)	; Forget everything about Job which opened connection & give to Job0
2)	; Preserve T2
2)	


LINE 15, PAGE 29
1)	TATNV9:	RESTORE
1)		RET
1)	
1)	^L	SUBTTL ACTTCB - Activate a Connection
1)	
1)	;ACTTCB tries to move a connection from the completely unsynchronized
1)	;(closed  or  brand  new)  state  into the SYNABLE state, where it is
1)	;able to send and/or repond to SYNs. Activating a connection  is  the
1)	;operation performed by user calls like OPEN, SEND and RECV, and make
1)	;the connection be "alive". If the connection is already active, this
1)	;results  in  a  true  value.  False  is  return if the connection is
1)	;partially closed -- one side or the other is NOTSYN state.
1)	
1)	;T1/	JCN
1)	;T2/	Option addresses word from OPEN, or 0 if otherwise
1)	;TCB/	(Extended) Locked connection block
1)	;      	NOINT
1)	;	CALL ACTTCB
1)	;Ret+1:	Always.  T1 has 0 if successfully activated, error code otherwise
1)	
1)	; **** Preserve T2 until TCPUOP

; TCPBBN.MAC.1 & <BBN-MONITOR>TCPBBN.MAC.1  9-Mar-88 1334	PAGE 64


1)	
1)	ACTTCB:	LOAD T4,TSSYN,(TCB)	; Get send state
1)		LOAD T3,TRSYN,(TCB)	; Get recv state
1)		CAIE T4,NOTSYN		; Unsynchronized?
1)		  JRST ACTTC7		; No.
1)		CAIE T3,NOTSYN
1)		  JRST ACTTC8		; Return FALSE
1)					; NOTSYN-NOTSYN
1)		STOR T1,TJCN,(TCB)	; Indicate this TCB is owned
1)		MOVE T3,TCB
1)		HRL T3,FORKX		; Form system fork,,TCB
1)		MOVEM T3,JCNTCB(T1)	; Store in job private table
1)					; **** T2 Preserved
1)		SKIPE T1,T2		; Option address word
1)		 CALL TCPUOP		; Get options from user
1)		  JUMPL T1,ACTTCX	; Return error code ** RETJCN too
1)	IFE STANSW,<
1)		MOVE T2,JOBNO		; Our job number
1)	>;IFE STANSW,<
1)	IFN STANSW,<
1)		MOVE T2,GBLJNO		; Our global job number
1)	>;IFN STANSW
1)		STOR T2,TOWNR,(TCB)	; Store this as TCB Owner
1)		MOVX T1,SYNABL		; SYN Ok state
1)		STOR T1,TSSYN,(TCB)	; Set send side
1)		STOR T1,TRSYN,(TCB)	; and recv side
1)	
1)	; Clear persistent SYN flag, Clear OPEN has been done flag
1)	; Clear "said it's open" bit, Clear ABORT requested flag
1)	; Clear TVT flag
1)	
1)		SETZRO <TSPRS,TSUOP,TSOPN,TSABT,TTVT>,(TCB)
1)		SETZRO TVTL,(TCB)	; Clear TVT line number
1)		SETZRO TSCPK,(TCB)	; No partially filled packet
1)	^L
1)		MOVE T1,INTXPB		; Maximum data size for a packet
1)		SUBI T1,MINIHS+MINTHS	; Assuming no options & largest net
1)		STOR T1,TRWND,(TCB)	; is the default initial receive window.
1)		SETZRO TRBS,(TCB)	; No RECV buffer space yet
1)		HRRZ T1,FORKN		; Our Job fork number
1)		STOR T1,TOFRK,(TCB)	; Say who owns the TCB
1)		SETO T1,
1)		STOR T1,TPSIC,(TCB)	; No PSI Channels named yet
1)		STOR T1,TPIFU,(TCB)	; No INTRP fork
1)		STOR T1,TPIFR,(TCB)	; No RECV DONE fork
1)		STOR T1,TPIFS,(TCB)	; No SEND DONE fork
1)		STOR T1,TPIFE,(TCB)	; No ERROR fork
1)		STOR T1,TPIFX,(TCB)	; No STATE CHANGE fork
1)		STOR T1,TPIFA,(TCB)	; No EOL ACK fork
1)		STOR T1,TRLWN,(TCB)	; No last window seq #
1)	IFE STANSW,<

; TCPBBN.MAC.1 & <BBN-MONITOR>TCPBBN.MAC.1  9-Mar-88 1334	PAGE 65


1)		MOVE T1,TCPRX0		; Good starting point for retrans
1)		STOR T1,TMNRT,(TCB)	; Minimum round trip time
1)		STOR T1,TMXRT,(TCB)	; Maximum round trip time
1)		STOR T1,TRXI,(TCB)	; Current RX interval
1)	>;IFE STANSW
1)	IFN STANSW,<
1)		MOVE T1,TCPRX0		; Good starting point for retrans
1)		STOR T1,TMNRT,(TCB)	; Minimum round trip time
1)		STOR T1,TMXRT,(TCB)	; Maximum round trip time
1)		STOR T1,TRXI,(TCB)	; Current RX interval
1)		STOR T1,TSMRT,(TCB)	; initial smoothed RTT
1)	>;IFN STANSW
1)		SETZRO <TRXPN,TRXPD,TRXPI>,(TCB) ; Clear RX parameters
1)		MOVX T1,OK		; General success code
1)		STOR T1,TERR,(TCB)	; Indicate no error on this connection
1)		LOAD T1,TERRF,(TCB)	; Index of the error event flag
1)		CALL CLRWTB		; Clear it
1)		JRST ACTTC9		; Return true to say it is now active
1)	ACTTC7:	CAIN T3,NOTSYN		; Check receive side state
1)	ACTTC8:	 HRROI T1,ELP+^D12	; "Connection closing" error
1)					; (S=NOTSYN, R.ne.NOTSYN or
1)					;  S.ne.NOTSYN, R=NOTSYN)
1)	ACTTC9:	  SETZ T1,		; Return OK (S.ne.NOTSYN & R.ne.NOTSYN)
1)	ACTTCX:	RET			; Return with TCPUOP's error code
1)	
1)	^L	SUBTTL CHKARG - Check BBN TCP JSYS Arguments
1)	
1)	; call FN(JCN,user option word or 0)
1)	;T1/	(Extended) Function address
1)	;T2/	ARG2 for FUNC	(***** obsolete *****)
1)	;	CALL CHKARG
1)	;Ret+1:	Always.  T1 has value of FUNC(JCN,ARG).  TCB has been setup.
1)	;		Note:  TCB is locked & NOINT during call to FUNC
1)	;	CHKJCN	-1,,ELP+^D1	JCN out of range, or no TCB for JCN
1)	;	GETJCN	-1,,ELT+^D4	No free JCN, no space for TCB
1)	;		-1,,ELT+^D31	TCP not initialized
1)	;	CHKADD	...
1)	;	function ...
1)	
1)	CHKARG:	STACKL <<ARGBLK,CHKADW>>
1)		CHKADL (USR)		; LOCAL
1)		XMOVEI PARAMS,ARGBLK	; Set the pointer
1)		MOVEM T1,FN		; Save function address
1)		SETZM ARG1
1)		NOINT
1)		SKIPE TCPON		; TCP turned on?
1)		 SKIPN TCPIFG		; TCP Initialized yet?
1)		  JRST CHKARI		; No.
1)		UMOVE T1,T1		; Get user's AC1 flags
1)		TXNE T1,TCP%IX		; Connection # specified?
1)	         JRST CHKAR3		; Yes

; TCPBBN.MAC.1 & <BBN-MONITOR>TCPBBN.MAC.1  9-Mar-88 1334	PAGE 66


1)		TXNN T1,TCP%JS		; JCN Supplied in right half?
1)	         JRST CHKAR1		; No.  Go translate into one
1)	
1)	; Given JCN
1)	
1)		HRRZS T1		; Save JCN part
1)		MOVE T2,FN		; Function to call if JCN ok
1)		MOVE T3,ARG1		; Argument to FN
1)		CALL CHKJCN		; Set TCB, Lock it & call FN
1)		EXIT CHKARX		; Return whatever result
1)	^L
1)	; Given Connection block or TVT number
1)	
1)	CHKAR1:	TXNE T1,TCP%TV		; TVT number specified?
1)	         JRST CHKAR2		; Yes
1)	
1)	; Given Connection block
1)	
1)		CALL GETJCN		; Reserve a JCN
1)		JUMPL T1,CHKARX		; Couldn't.  Tell caller
1)		MOVEM T1,JCN		; Save the JCN
1)		XCTU [HRRZ USR,T1]	; Get ptr to Connection Descriptor Blk
1)		UMOVE T1,.TCPLH(USR)
LINE 16, PAGE 44
2)	TATNV9:	RET
2)	
2)		ENDAV.
2)	
2)	^L	SUBTTL CHKARG - Check BBN TCP JSYS Arguments
2)	
2)	;Call FN(JCN,user option word or 0)
2)	;T1/	Extended Function address
2)	;T2/	Info for function to be called (Caller's T1/ Flags!connection)
2)	;	CALL CHKARG
2)	;Ret+1:	Always.  T1 has value of FUNC(JCN,ARG).  TCB has been setup.
2)	;		Note:  TCB is locked & NOINT during call to FUNC
2)	;	-1,,ELT+^D31 ; TCP not yet initialized
2)	; JCN
2)	;CHKJCN	-1,,ELP+^D01 ; JCN out of range/no TCB
2)	; CDB
2)	;GETJCN	-1,,ELT+^D04 ; No free JCN
2)	;CHKADD	-1,,ELT+^D04 ; No TCB space/free WAIT bit/too many connections(TCBMAX)
2)	;CHKADD	-1,,ELP+^D13 ; Invalid port(LP=0)
2)	; TVT
2)	;CHKTVT	-1,,ELP+^D01 ; Invalid TVT terminal line number/No TCB for line
2)	; System Connection Index
2)	;	-1,,ELP+^D01 ; Index out of range 1 to TCBCNT
2)	; Net
2)	;CHKADD	-1,,ELP+^D05 ; Packet with wild FH/FP
2)	;CHKADD	-1,,EFP+^D07 ; No such TCB
2)	; or code from function ...

; TCPBBN.MAC.1 & <BBN-MONITOR>TCPBBN.MAC.1  9-Mar-88 1334	PAGE 67


2)	
2)	
2)	CHKARG:	TRVAR <<ARGBLK,CHKADW>>	; Setup argument block for CHKADD
2)		CHKADL (USR)		; Local PARAMS also defined
2)		XMOVEI PARAMS,ARGBLK	; Point to argument block
2)	MNTM5	AOS CELL(TCJCK,0,,TCJ)	; CHKARG calls
2)		MOVEM T1,FN		; Save function address, w/ID
2)		MOVEM T2,ARG1
2)		NOINT
2)		SKIPLE TCPON		; TCP turned on?
2)		  JRST CHKARI		; No.
2)		MOVE T1,T2		; Get user flags
2)	^L
2)	;Given JCN
2)	
2)		TXNN T1,TCP%JS		; JCN Supplied in right half?
2)		IFSKP.			; Yes, validate it
2)	CHKAR1:
2)	MNTM5	  AOS CELL(TCJCK,1,,TCJ) ; CHKARG w/ JCNs
2)		  HRRZS T1		; Save JCN part
2)		  MOVE T2,FN		; Function to call, w/ID, if JCN ok
2)		  MOVE T3,ARG1		; Argument to FN
2)		  CALL CHKJCN		; Set TCB, Lock it & call FN
2)		  JRST CHKARX		; Return whatever result
2)		ENDIF.
2)	
2)	;Given TVT #
2)	
2)		TXNN T1,TCP%TV		; TVT number specified?
2)		IFSKP.			; Yes
2)	CHKAR2:
2)	MNTM5 	  AOS CELL(TCJCK,4,,TCJ) ; CHKARG w/ TVTs
2)		  MOVEI T2,(T1)		; TVT line # into 2
2)		  CALL CHKTVT		; Check if valid TVT
2)		    JRST CHKART		; Lose
2)		  CALL TVTCHK		; Get (locked) data base
2)		    JRST CHKARU		; Not fully active
2)		  LOAD TCB,PTVT,(T2)	; Get TCB address
2)		  CALL ULKTTY		; Unlock TTY data base
2)		  JUMPE TCB,CHKART	; Illegal connection
2)		  MOVX T3,0 ;T1		; Unused Arg for FN is line type??
2)		  XMOVEI T1,TCBLCK(TCB)	; Lock to lock
2)		  MOVE T4,ARG1		; Second arg for FN
2)		  MOVE T2,FN		; Function to call, w/ID
2)		  CALL LCKCAL
2)		  JRST CHKARX		; Leave
2)		ENDIF.
2)	
2)	^L
2)	;Find the nth system connection specified by T1
2)	

; TCPBBN.MAC.1 & <BBN-MONITOR>TCPBBN.MAC.1  9-Mar-88 1334	PAGE 68


2)		TXNN T1,TCP%IX		; Connection # specified?
2)		IFSKP.			; Yes, scan for it
2)	CHKAR3:
2)	MNTM5 	  AOS CELL(TCJCK,5,,TCJ) ; CHKARG w/ connection index
2)		  HRRZS T1		; Just the number
2)		  CAILE T1,0		; Must be greater than 0 and
2)		   CAMLE T1,TCBCNT	; Less than current number
2)		    JRST CHKART		; Lose, invalid index
2)		  PUSH P,TCB		; Save TCB
2)		  PUSH P,T1		; Save index
2)		  XMOVEI T1,TCBHLK	; Lock for TCB hash table
2)		  CALL SETLCK		; Lock it
2)		  MOVSI T2,-TCBHSZ	; Size of hash table
2)		  POP P,T1		; Get index
2)	
2)		  DO.			; Scan TCBH table
2)		    HRRZ TCB,T2		; Current TCBH slot
2)		    ADD TCB,TCBH	; Add base of table (including section)
2)		    MOVE T3,TCB		; Save head of list
2)		    DO.			; Scan entry in TCBH table
2)		      LOAD TCB,QNEXT,(TCB) ; Get next on list
2)		      CAME TCB,T3	; Back to head?
2)		        SOJG T1,TOP.	; No, decrement index, loop if count not zero
2)		    ENDDO.
2)		    ADDI T2,QSZ-1
2)		    SKIPE T1		; Stop, found TCB
2)		      AOBJN T2,TOP.	; Jump back if another slot
2)		  ENDDO.
2)		  SKIPL T2		; Find one?
2)		    SETZ TCB,		; No more, TCB not found
2)	
2)	;TCB points to TCB or is 0
2)	
2)		  AOS TCBHUC		; Bump hash table use count
2)		  XMOVEI T1,TCBHLK	; TCBH lock
2)		  CALL UNLCK		; Unlock it with non-zero count means reading
2)		  HRROI T1,<ELP+^D01>	; Assume error
2)		  SKIPN TCB		; Find a TCB?
2)		  IFSKP.
2)	IFN TCBQ,<  XMOVEI TCB,-TCBQ(TCB)> ; Yes, locate top of structure
2)		    XMOVEI T1,TCBLCK(TCB) ; TCB to lock
2)		    MOVE T2,FN		; Function to call, w/ID
2)		    MOVX T3,0 ;JCN	; Restore args (JCN=0 here)
2)		    MOVE T4,ARG1
2)		    CALL LCKCAL		; Call function
2)		  ENDIF.
2)		  SOS TCBHUC		; Done reading TCB
2)		  POP P,TCB		; Restore register
2)		  JRST CHKARX		; Leave, error code in T1
2)		ENDIF.
2)	^L

; TCPBBN.MAC.1 & <BBN-MONITOR>TCPBBN.MAC.1  9-Mar-88 1334	PAGE 69


2)	;Given Connection block (only allowed by OPEN%)
2)	
2)	CHKAR4:
2)	MNTM5	AOS CELL(TCJCK,2,,TCJ)	; CHKARGs w/ CDBs
2)		CALL GETJCN		; Reserve a JCN
2)		JUMPL T1,CHKARX		; Couldn't.  Tell caller
2)		MOVEM T1,JCN		; Save the JCN
2)		MOVEM T1,ARG2		; Also for error exit check
2)	
2)		XCTU [HRRZ USR,1]	; Get ptr to Connection Descriptor Block
2)		UMOVE T1,.TCPLH(USR)


LINE 19, PAGE 33
1)	; ****	Beginning of Compatability Kludge
1)	
1)		PUSH P,BHC+1		; Assume new format
1)		JUMPE T1,KLUDG0		; If first word 0, must be new (LP=0 illegal)
1)		TLNE T1,-1		; If first word is LP, then only rh 16 bits used
1)	         JRST KLUDG0		; New format
1)		MOVE T4,T3		; Map old format into new
1)		MOVE T3,T2
1)		MOVE T2,T1
1)		SETZB T1,USR		; New info zero if old format
1)		SETZM (P)		; Use old format
1)	KLUDG0:
1)	
1)	; ****	End of Compatability Kludge
1)	
1)		ANDX T1,.RTJST(-1,PISH)
1)		ANDX T2,.RTJST(-1,PSP)
LINE 18, PAGE 48
2)					; ****	Beginning of Compatability Kludge
2)		PUSH P,BHC+1		; Assume new format
2)		IFN. T1			; If first word isn't 0, may be old (LP=0 bad)
2)		  TLNE T1,-1		; If first is old LP, then only RH 16-bits used
2)		  ANSKP.		; Looks like old format
2)	MNTM5	    AOS CELL(TCJCK,3,,TCJ) ; Old format CDBs
2)		    MOVE T4,T3		; Map old format into new
2)		    MOVE T3,T2
2)		    MOVE T2,T1
2)		    SETZB T1,USR	; New info zero if old format
2)		    SETZM (P)		; Use old format
2)		ENDIF.			; ****	End of Compatability Kludge
2)	
2)		ANDX T1,.RTJST(-1,PISH)	;cwl address space codes here
2)		ANDX T2,.RTJST(-1,PSP)


; TCPBBN.MAC.1 & <BBN-MONITOR>TCPBBN.MAC.1  9-Mar-88 1334	PAGE 70



LINE 42, PAGE 33
1)		MOVEM USR,ARG1		; Option addresses is second arg for FN
1)		SETZM WILDOK		; Not OK to find listening connections
1)		MOVE T1,PARAMS		; Pointer to parameter block for CHKADD
1)		CALL CHKADD		; Find TCB, Lock it, Call FN
1)	
1)	; ****	Beginning of Compatability Kludge
1)	
1)		POP P,T2		; Old (0)/New (1) flag
1)		JUMPL T1,CHKA19		; Jump if all went well
1)		STOR T2,TNUFM,(TCB)	; Save format flag
1)		JRST CHKARX
1)	
1)	; ****	End of Compatability Kludge
1)	
1)	CHKA19:	PUSH P,T1		; Save error result
1)		MOVE T1,JCN		; Get back the JCN
1)		CALL RETJCN		; To return & disown TCB ("DEAD")
1)		POP P,T1		; Restore error code
1)		EXIT CHKARX
1)	^L
1)	; Given TVT #
1)	
1)	CHKAR2:	MOVEI T2,(T1)		; TVT line # into 2
1)		IFE REL6,<CALL CHKTVT> 	; Check if valid TVT
1)		IFN REL6,<CALLX (MSEC1,CHKTVT)>	; Check if valid TVT
1)		  JRST CHKART		; Lose
1)		IFE REL6,<CALL TVTCHK> 	; Get (locked) data base
1)		IFN REL6,<CALLX (MSEC1,TVTCHK)> ; Get (locked) data base
1)		  JRST CHKARU		; Not fully active
1)		LOAD TCB,PTVT,(T2)	; Get TCB address
1)		CALL ULKTTY		; Unlock TTY data base
1)		JUMPE TCB,CHKART	; Illegal connection
1)		SETSEC TCB,INTSEC	; TCBs in this section
1)		MOVX T3,0 ;T1		; Unused Arg for FN is line type??
1)		XMOVEI T1,TCBLCK(TCB)	; Lock to lock
1)		MOVE T4,ARG1		; Second arg for FN
1)		MOVE T2,FN		; Function to call
1)		CALL LCKCAL
1)		JRST CHKARX		; Leave
1)	^L
1)	; Find the nth connection specified by T1
1)	
1)	CHKAR3:	HRRZS T1		; Just the number
1)		CAILE T1,0		; Must be greater than 0 and
1)		 CAMLE T1,TCBCNT	; Less than current number
1)		  JRST CHKART		; Lose, invalid index
1)		MOVEM T1,JCN		; Save index
1)		XMOVEI T1,TCBHLK	; Lock for TCB hash table

; TCPBBN.MAC.1 & <BBN-MONITOR>TCPBBN.MAC.1  9-Mar-88 1334	PAGE 71


1)		CALL SETLCK		; Lock it
1)		PUSH P,TCB		; Save TCB
1)		MOVSI T2,-TCBHSZ	; Size of hash table
1)	CHKA30:	HRRZ TCB,T2		; Current TCBH slot
1)		ADD TCB,TCBH		; Add base of table (including section)
1)		HRRZ T3,TCB		; Save head of list
1)	CHKA31:	LOAD TCB,QNEXT,(TCB)	; Get next on list
1)		CAMN TCB,T3		; Back to head?
1)		  JRST [AOBJN T2,CHKA30	; Yes, jump back if another slot
1)			SETZ TCB,	; No more, TCB not found
1)			JRST CHKA32]	; Quit
1)		SETSEC TCB,INTSEC	; TCBs in this section
1)		SOSE JCN		; Count down index
1)		  JRST CHKA31		; Loop if not want this one
1)	
1)	; TCB points to TCB or is 0
1)	
1)	CHKA32:	AOS TCBHUC		; Bump hash table use count
1)		XMOVEI T1,TCBHLK	; TCBH lock
1)		CALL UNLCK		; Unlock it with non-zero count means reading
1)		HRROI T1,<ELP+^D1>	; Assume error
1)		SKIPN TCB		; Find a TCB?
1)	         JRST CHKA33		; No
1)		XMOVEI T1,TCBLCK(TCB)	; TCB to lock
1)		MOVE T2,FN		; Function to call
1)		MOVX T3,0 ;JCN		; Restore args (JCN=0 here)
1)		MOVE T4,ARG1
1)		CALL LCKCAL		; Call function
1)	CHKA33:	SOS TCBHUC		; Done reading TCB
1)		POP P,TCB		; Restore register
1)		JRST CHKARX		; Leave, error code in T1
1)	
1)	CHKARU:	CALL ULKTTY		; Maybe a non-standard block
1)	CHKART:	HRROI T1,ELP+^D1	; Illegal connection
1)		JRST CHKARX
1)	
1)	CHKARI:	HRROI T1,ELT+^D31	; "TCP Not initialized yet"
1)	
1)	CHKARX:	OKINT
1)		CHKADR
1)		RET
1)	
1)	^L	SUBTTL CHKJCN - See if caller has access to JCN
1)	
1)	;T1/	JCN in question
1)	;T2/	(Extended) Function to call if OK
1)	;T3/	Argument for function
LINE 39, PAGE 48
2)		MOVEM USR,ARG1		; Option addresses are second arg for FN
2)	
2)		IFN. T1			; Is local address wild?

; TCPBBN.MAC.1 & <BBN-MONITOR>TCPBBN.MAC.1  9-Mar-88 1334	PAGE 72


2)		  CALL LCLHST		; No, is it one of our addresses?
2)		    JRST CHKA18		; No, invalid address specified
2)		ENDIF.
2)	^L
2)		SETZM WILDOK		; Not OK to find listening connections
2)		MOVE T1,PARAMS		; Pointer to parameter block for CHKADD
2)		CALL CHKADD		; Find TCB, Lock it, Call FN, w/ID
2)	
2)					; ****	Beginning of Compatability Kludge
2)		POP P,T2		; Old (0)/New (1) flag
2)		JUMPL T1,CHKA19		; Jump if error
2)		STOR T2,TNUFM,(TCB)	; Save format flag
2)		JRST CHKARX
2)					; ****	End of Compatability Kludge
2)		JRST CHKA19
2)	
2)	
2)	CHKA18:	POP P,(P)		; Drop Old (0)/New (1) flag
2)		HRROI T1,ELP+^D13	; "Invalid local address"
2)	CHKA19:	PUSH P,T1		; Save error result
2)		MOVE T1,JCN		; Get back the "current" JCN
2)		LOAD T2,JCNTC,(T1)	; To see if reserved or in use
2)		SKIPE T2		; If just reserved, or
2)		 CAMN T1,ARG2		; If "current" is the "reserved" JCN
2)		  CALL RETJCN		; Return & disown TCB ("DEAD")
2)		POP P,T1		; Restore error code
2)		JRST CHKARX
2)	
2)	
2)	
2)	
2)	
2)	CHKARU:	CALL ULKTTY		; Maybe a non-standard block
2)	CHKART:	HRROI T1,ELP+^D01	; Illegal connection
2)		JRST CHKARX
2)	
2)	CHKARI:	HRROI T1,ELT+^D31	; "TCP Not initialized yet"
2)	CHKARX:	OKINT
2)	MNTM5	SKIPGE T1		; Error?
2)	MNTM5	  AOS CELL(TCJCK,6,,TCJ); CHKARG errors
2)		CHKADR
2)		RET
2)	
2)		ENDTV.
2)	^L	SUBTTL CHKJCN - See if caller has access to JCN
2)	
2)	;T1/	JCN in question
2)	;T2/	Extended Function to call, w/ID, if OK
2)	;T3/	Argument for function


; TCPBBN.MAC.1 & <BBN-MONITOR>TCPBBN.MAC.1  9-Mar-88 1334	PAGE 73



LINE 9, PAGE 36
1)	;			-1,,ELP+^D1  Invalid JCN, No TCB
1)	
1)	CHKJCN:	PUSH P,T1		; Save the JCN
1)		CAIL T1,1		; Reasonable number?
1)		 CAIL T1,MAXJCN
1)		  JRST CHKJC9		; No.  Tell Caller
1)		HRRZ TCB,JCNTCB(T1)	; Get the TCB
1)		JUMPE TCB,CHKJC9	; Non-JCN, give error
1)		SETSEC TCB,INTSEC
1)		CALL BBNCHK		; is this call legal for other reasons
1)		 JRST CHKJC9		; no
1)		LOAD T1,TOWNR,(TCB)	; check the owning job number
1)	IFE STANSW,<
1)		CAME T1,JOBNO		; is it the same as our job
1)	>;IFE STANSW
1)	IFN STANSW,<
1)		CAME T1,GBLJNO
1)	>;IFN STANSW
1)		BUG.(CHK,TCPJS3,TCPTCP,SOFT,<CHKJCN: TCB ownership confused>,,<
1)	
1)	Cause:	CHKJCN was called for a connection not owned by the calling job.
1)	
1)	>)
1)		XMOVEI T1,TCBLCK(TCB)	; Pointer to the connection lock
LINE 9, PAGE 50
2)	;	ELP+^D01 ; JCN out of range/no TCB
2)	
2)	CHKJCN:
2)	MNTM5	AOS CELL(TCJCJ,0,,TCJ)	; CHKJCN calls
2)		PUSH P,T1		; Save the JCN and flags
2)		HRRZS T1		; Just JCN
2)		CAIL T1,1		; Reasonable number?
2)		 CAIL T1,MAXJCN
2)		  JRST CHKJC8		; No.  Tell Caller
2)		LOAD TCB,JCNTC,(T1)	; Get the TCB
2)		JUMPE TCB,CHKJC8	; Non-JCN, give error
2)		CALL BBNCHK		; Is this call legal for other reasons
2)		  JRST CHKJC9		; No
2)		LOAD T1,TOWNR,(TCB)	; Check the owning job number
2)	         CAME T1,JOBNO		; Is it the same as our job
2)		  JRST CHKJC7
2)		XMOVEI T1,TCBLCK(TCB)	; Pointer to the connection lock


; TCPBBN.MAC.1 & <BBN-MONITOR>TCPBBN.MAC.1  9-Mar-88 1334	PAGE 74



LINE 36, PAGE 36
1)		CAIA			; Use whatever value is returned
1)	CHKJC9:	  HRROI T1,ELP+^D1	; "Illegal Connection"
1)		ADJSP P,-1		; CLEAR STACK
1)		RET
LINE 29, PAGE 50
2)		JRST CHKJC9		; Use whatever value is returned
2)	
2)	CHKJC7:	BUG.(CHK,TCPJS3,TCPBBN,SOFT,
2)	
2)	<CHKJCN: TCB ownership screwed up - own/job/jcn>,<<T1,D>,<JOBNO,D>,<(P),D>>,<
2)	
2)	Cause:	A TCB is being accessed by a job which does not own it.
2)	
2)	Action:	Try to determine how the situation occurred.
2)	
2)	Data:	Owning job number, Accessing job number, Job connection number.
2)	
2)	>)
2)	
2)	CHKJC8:	HRROI T1,ELP+^D01	; "Illegal Connection"
2)	CHKJC9:	ADJSP P,-1		; Clear stack
2)	MNTM5	SKIPGE T1
2)	MNTM5	  AOS CELL(TCJCJ,1,,TCJ); CHKJCN errors
2)		RET


LINE 5, PAGE 37
1)	;Ret+1:	Always.  T1 has the JCN (.GT.0) or -1,,ELT+^D4
1)	
1)	GETJCN::NOSKED			; Prevent others from interfering
1)		MOVSI T2,-MAXJCN+1	; Max number of JCNs per job (ignore 0)
1)		SKIPE JCNTCB+1(T2)	; Empty slot?
1)		  AOBJN T2,.-1		; No.  Check next
1)		HRROI T1,ELT+^D4	; "No space for another connection"
1)		JUMPGE T2,GETJCX	; Return that if no empty slot found
1)		MOVE T3,FORKX		; Our identity.
1)		HRLZM T3,JCNTCB+1(T2)	; Reserve the slot for later use
1)		MOVEI T1,1(T2)		; The JCN as a result.
1)	GETJCX:	OKSKED
1)		RET
LINE 5, PAGE 51
2)	;Ret+1:	Always.  T1 has the JCN (.GT.0) or
2)	;	-1,,ELT+^D04 ; No free JCN/TCB space/free WAIT bit/free TVTs
2)	
2)	GETJCN:
2)	MNTM5	AOS CELL(TCJGJ,0,,TCJ)	; GETJCN calls
2)		NOSKED			; Prevent others from interfering
2)		MOVSI T2,-MAXJCN+1	; Max number of JCNs per job (ignore 0)

; TCPBBN.MAC.1 & <BBN-MONITOR>TCPBBN.MAC.1  9-Mar-88 1334	PAGE 75


2)		SKIPE JCNTCB+1(T2)	; Empty slot?
2)		  AOBJN T2,.-1		; No.  Check next
2)		HRROI T1,ELT+^D04	; "No space for another connection"
2)		JUMPGE T2,GETJCX	; Return that if no empty slot found
2)		MOVE T3,FORKX		; Our identity.
2)		STOR T3,JCNFX,+1(T2)	; Reserve the slot for later use
2)		MOVEI T1,1(T2)		; The JCN as a result.
2)	GETJCX:	OKSKED
2)	MNTM5	SKIPGE T1
2)	MNTM5	  AOS CELL(TCJGJ,1,,TCJ); GETJCN errors
2)		RET


LINE 7, PAGE 38
1)	
1)	RETJCN::SAVEAC <T1,TCB>
1)		NOSKED
LINE 7, PAGE 52
2)	;Preserves T2,T4
2)	
2)	RETJCN::
2)		SAVEAC <T1,TCB>
2)	MNTM5	AOS CELL(TCJAA,2,,TCJ)	; RETJCN calls
2)		NOSKED


LINE 14, PAGE 38
1)		  CAIA
1)		   JRST RETJC1
1)		BUG.(INF,TCPJS1,TCPTCP,SOFT,<RETJCN: JCN out of range>,,<
1)	
1)	Cause:	RETJCN was called for a JCN that is out of range.
1)	
LINE 17, PAGE 52
2)		  SKIPA CX,FORKX	; Bug info
2)		   JRST RETJC1
2)		BUG.(INF,TCPJS1,TCPBBN,SOFT,
2)	
2)	<RETJCN: JCN out of range - job/fx/jcn/pc>,
2)	
2)	<<JOBNO,JOB>,<CX,FX>,<T1,JCN>,<-3(P),PC>>,<
2)	
2)	Cause:	A TCP job connection number (JCN) is being released, but the JCN
2)		given is not valid.
2)	
2)	Action:	Notify software support of the problem, giving the additional
2)		information displayed.  The bad call has been ignored.
2)	
2)	Data:	Job number, ForkX, Invalid JCN, Address of RETJCN's caller.
2)	


; TCPBBN.MAC.1 & <BBN-MONITOR>TCPBBN.MAC.1  9-Mar-88 1334	PAGE 76



LINE 25, PAGE 38
1)		TRNN TCB,-1		; Just a reserved slot?
1)	         JRST RETJCX		; Yes.  Get out.
1)		SETSEC TCB,INTSEC	; Make extended address
1)		MOVNI T3,1
LINE 38, PAGE 52
2)		AND TCB,[JCNTC]		; Just keep 23-bit TCB address
2)		TDNN TCB,[JCNTC]	; Just a reserved slot?
2)	         JRST RETJCX		; Yes.  Get out.
2)		MOVNI T3,1


LINE 38, PAGE 38
1)		MOVE T1,TCB		; in case we call TCPBFD
LINE 51, PAGE 52
2)	
2)		MOVE T1,TCB		; in case we call TCPBFD


LINE 3, PAGE 39
1)	;Buffer  descriptors  ("Buffers")  are the items which get queued for
1)	;the Packetizer and Reassembler. There is one for each SEND  or  RECV
1)	;executed  by  the user. Amoung other things, a buffer block contains
1)	;an "index" which associates that buffer with a particular  DONE  bit
1)	;which  is stored in resident core; it is this bit that the scheduler
1)	;tests to reactivate a process which is waiting for  that  particular
1)	;buffer.
1)	
1)	;TCB/	(ext) pointer to locked connection block
1)	;	CALL MAKBFR
1)	;Ret+1:	Always.  T1 has the buffer address (.GT.0) or -1,,error
1)	;		-1,,ELP+^D15  Count < 0, Adr last word >= 1,,0
1)	;		-1,,ELT+^D16  No WAIT bits, No memory for BFR HDR
1)	
1)	MAKBFR:	STACKL <DATADR>
1)		LOCAL <HDRADR,FLAGS,COUNT,JCNFLG>
1)		PUSH P,BFR
1)		UMOVE JCNFLG,T1		; Get JCN control flags from user
1)		UMOVE HDRADR,T2		; Get address of header from user
1)		SUBI HDRADR,BFRSUI	; Make it into standard header ptr.
1)		MOVSI FLAGS,(TCP%DN!TCP%ER)	; Done and Error bits
1)		XCTU [ANDCAB FLAGS,BFRFLG(HDRADR)] ; Clear in user space, get others
1)		TXNE FLAGS,TCP%UR	; Urgent (send) bit on?
1)	         TXO FLAGS,TCP%PU	; Yes.  That implies a PUSH.
1)		UMOVE T3,BFRDAD(HDRADR); Address of data area
1)		MOVEM T3,DATADR
1)		UMOVE COUNT,BFRCNT(HDRADR); Number of words/bytes in buffer
1)		JUMPL COUNT,MAKBF9	; Illegal
1)		MOVE T1,DATADR

; TCPBBN.MAC.1 & <BBN-MONITOR>TCPBBN.MAC.1  9-Mar-88 1334	PAGE 77


1)		LSH T1,-PGSFT		; First page of buffer
1)		MOVE T2,DATADR
1)		MOVE T3,COUNT
1)		TLNE JCNFLG,(TCP%WM)	; Count is words?
1)	         JRST MAKBF1		; Yes.
1)		ADDI T3,3		; Round up to word boundary
1)		ASH T3,-2		; Number of words in the buffer
1)	MAKBF1:
1)		ADD T2,T3
1)		SUBI T2,1		; Last word in buffer
1)		LSH T2,-PGSFT		; Last page in buffer
1)		CAIL T2,1000		; Better fit in memory
1)	         JRST MAKBF9		; Give error
1)	^L
1)		TLNN JCNFLG,(TCP%WT)	; Will this fork wait for this buffer?
1)		 TDZA T1,T1		; No.  No wait bit index assigned
1)		  CALL ASNWTB		; Assign an index
1)		JUMPL T1,MAKBFX		; None available right now ??? error code?
1)		PUSH P,T1		; Save for a while
1)		SKIPE T1		; No bit to clear
1)	         CALL CLRWTB		; Clr it to make us hang at SENDW (e.g.)
1)		MOVEI T1,BFRSIZ		; Size of a buffer descriptor
1)	 	CALL GETBLK		; Get a block of free storage
1)		SKIPG BFR,T1		; Got it? ??? error code?
1)	         JRST MAKBF8		; No.  Release index and return ELT+^D16
1)		JN TDEC,(TCB),MAKBF6	; do not do this for a DEC TCB
1)		NOSKED			; Make sure we are the only one
1)		MOVE T1,FORKX		; get my fork index
1)	IFN REL6,<LOAD T1,FKUP%,(T1)>	; get UPT SPT slot
1)	IFE REL6,<HLRZ T1,FKPGS(T1)>	; get UPT SPT slot
1)		LOAD T2,SPTSHC,(T1)	; get the share count on the spt slot
1)		CAIL T2,MAXSHC-10	; is it close to overflow?
1)		 JRST MAKBF7		; yes so we can not continue
1)		CALL UPSHR		; Increment the share count
1)		OKSKED			; give back the system
1)	MAKBF6:
1)		SETZM BFRQ(BFR)		; Indicate buffer is not on a queue
1)		POP P,T1		; Get back the index
1)		STOR T1,BIDX,(BFR)	; Put in wait bit index
1)		STOR TCB,BTCB,(BFR)	; Remember which TCB owns the buffer
1)		MOVEM FLAGS,BFRFLG(BFR)	; Store in monitor copy
1)		SETZRO BPTR,(BFR)	; Clear Index and Indirect fields
1)		MOVX T1,^D8		; Assume byte-send
1)		TLNE FLAGS,(TCP%WM)	; Word mode?
1)	         MOVX T1,^D36		; Yes.  Byte size is 36
1)		STOR T1,BPTRS,(BFR)	; Set into size field of byte pointer
1)		MOVE T1,TODCLK		; Now in milliseconds
1)		STOR T1,BTS,(BFR)	; Set into buffer timestamp
1)		STOR COUNT,BICNT,(BFR)	; Remember the initial count
1)		STOR HDRADR,BHADR,(BFR)	; and header address in user space
1)		MOVE T3,DATADR		; Get the user's data address

; TCPBBN.MAC.1 & <BBN-MONITOR>TCPBBN.MAC.1  9-Mar-88 1334	PAGE 78


1)		STOR T3,BDADR,(BFR)	; Remember it
1)		UMOVE T1,BFROPT(HDRADR)	; Get option addresses word
1)	       				; Beginning of Compatability Kludge
1)		OPSTR SKIPN,TNUFM,(TCB)	; Using new formats?
1)		  SETZ T1,		; No, garbage
1)					; End of Compatability Kludge
1)		MOVEM T1,BFROPT(BFR)	; Save them
1)		MOVX T1,-1		; "Not mapped" indication
1)		STOR T1,BMPAG,(BFR)	; In the monitor window page number
1)		CALL RSTBFR		; Reset the buffer state
1)		MOVE T1,FORKX		; Our own System Fork Number
1)		STOR T1,BFRKX,(BFR)	; Remember for mapping user space
1)		MOVE T1,BFR		; This is the value
1)		JRST MAKBFX
1)	^L
1)	
1)	MAKBF7:				; here when UPT Share count will overflow
1)		OKSKED			; give back the machine
1)		MOVE T1,BFR		; get the free space address
1)		CALL RETBLK		; return the block and fall through
1)					; here when no free space for buffer
1)	MAKBF8:	POP P,T1		; Get back index
1)		TLNE JCNFLG,(TCP%WT)	; Did we assign one?
1)	         CALL RELWTB		; Release it
1)		SKIPA T1,[-1,,ELT+^D16]	; "No space right now"
1)	MAKBF9:	 HRROI T1,ELP+^D15	; "Bad buffer arg(s)"
1)	MAKBFX:	POP P,BFR
1)		RESTORE
1)		RET
1)	
1)	^L	SUBTTL FREBFR - Release Resources Used By a Buffer
1)	
1)	;Called  by  a process doing a SEND, RECV which waits for completion.
1)	;In this case USRBFE (or USRBFF) places the complete  buffer  on  the
1)	;TCPBDQ so it may be release by this routine in the above JSYSs or by
1)	;ABORT.
1)	
1)	;BFR/	(Extended) Buffer
1)	;	CALL FREBFR
1)	;Ret+1:	Always
1)	
1)	FREBFR:	NOSKED
1)		LOAD T1,BIDX,(BFR)	; Get the wait bit index
1)		SETZRO BIDX,(BFR)	; Indicate it has been released
1)		SKIPE T1		; Have a bit to release?
1)	         CALL RELWTB		; Actually release it
1)		MOVE T1,BFR		; Item to dequeue
1)		SKIPE (T1)		; If not queued, skip it
1)	         CALL DQ		; Remove it from the done queue
1)		OKSKED
1)		CALL RETBLK		; Release the storage

; TCPBBN.MAC.1 & <BBN-MONITOR>TCPBBN.MAC.1  9-Mar-88 1334	PAGE 79


1)		RET
1)	
1)	^L
1)	;BBNCHK
1)	;Check  to  see  if  a  BBN  TCP  JSYS is legal. Always legal for the
1)	;monitor. If from user mode not legal for a DEC TCB. If BBNOK is  off
1)	;then never legal from user mode. Skip return if legal.
LINE 3, PAGE 53
2)	;Buffer descriptors ("Buffers") are the items which get queued for
2)	;the Packetizer and Reassembler.  There is one for each SEND% or RECV%
2)	;executed by the user.  Amoung other things, a buffer block contains
2)	;an "index" which associates that buffer with a particular DONE bit
2)	;which is stored in resident core;  it is this bit that the scheduler
2)	;tests to reactivate a process which is waiting for that particular
2)	;buffer.
2)	
2)	;User 1/JCN and flags
2)	;User 2/Address of buffer header
2)	;T1/	Access flags (PTWR form)
2)	;TCB/	Extended pointer to locked connection block
2)	;	CALL MAKBFR
2)	;Ret+1:	Always.  T1 has the buffer address (.GT.0) or -1,,error
2)	;MAKBFR	-1,,ELP+^D15 ; Bad buffer arg(s) (Count lt 0, Adr last word ge 1,,0)
2)	;MAKBFR	-1,,ELT+^D16 ; No free WAIT bit(s)/space for buffer header
2)	
2)	MAKBFR:	ACVAR <HDRADR,JCNFLG,DATADR,ACCESS>
2)	MNTM5	AOS CELL(TCJMB,0,,TCJ)	; MAKBFR calls
2)		PUSH P,BFR		; Save register
2)		MOVEM T1,ACCESS
2)	
2)		MOVEI T1,BFRSIZ		; Size of a buffer descriptor
2)	 	CALL GETBLK		; Get a block of free storage
2)		SKIPLE BFR,T1		; Got it?
2)		IFSKP.			; No
2)		  HRROI T1,ELT+^D16	; "No space right now"
2)		  JRST MAKBFX
2)		ENDIF.
2)		MOVEI T2,BFRSIZ		; Size of a buffer descriptor
2)		CALL CLRBLK		; Clear the block
2)	
2)		STOR TCB,BTCB,(BFR)	; Remember which TCB owns the buffer
2)		MOVE T1,TODCLK		; Now in milliseconds
2)		STOR T1,BTS,(BFR)	; Set into buffer timestamp
2)	
2)		UMOVE JCNFLG,1		; Get JCN control flags from user
2)		TXNN JCNFLG,TCP%WT	; Will this fork wait for this buffer?
2)		IFSKP.			; Yes
2)		  CALL ASNWTB		; Assign an index
2)		  IFL. T1
2)		    MOVX T1,ELT+^D16	; None available (TCP error code)
2)		    JRST MAKBF9		; Go release buffer & return error

; TCPBBN.MAC.1 & <BBN-MONITOR>TCPBBN.MAC.1  9-Mar-88 1334	PAGE 80


2)		  ENDIF.
2)		  STOR T1,BIDX,(BFR)	; Put in wait bit index
2)		  CALL CLRWTB		; Clear it
2)		ENDIF.
2)	^L
2)		UMOVE HDRADR,2		; Get address of header from user
2)		SUBI HDRADR,BFRSUI	; Make it into standard header ptr.
2)		STOR HDRADR,BHADR,(BFR)	; Save header address in user space
2)	
2)		MOVX T1,<TCP%DN!TCP%ER> ; Done and Error bits
2)		XCTU [ANDCAB T1,BFRFLG(HDRADR)] ; Clear in user space, get others
2)		TXNE T1,TCP%UR		; Urgent (send) bit on?
2)		  TXO T1,TCP%PU		; Yes.  That implies a PUSH.
2)		MOVEM T1,BFRFLG(BFR)	; Store in monitor copy
2)	
2)		IFQN. TNUFM,(TCB)	; Using new formats?
2)		  UMOVE T1,BFROPT(HDRADR) ; Get option addresses word
2)		  MOVEM T1,BFROPT(BFR)	; Save them
2)		ENDIF.
2)	
2)		UMOVE T4,BFRCNT(HDRADR) ; Number of words/bytes in buffer
2)		JUMPL T4,MAKBF8		; Illegal
2)		STOR T4,BICNT,(BFR)	; Remember the initial data count
2)	
2)		UMOVE T3,BFRDAD(HDRADR)	; Address of data area possibly
2)					; contains byte pointer and section
2)		TXNE T3,BDAPO!BDASZ	; Size and Position fields 0?
2)		IFSKP.			; Yes, default P and S in the pointer
2)		  TXNE JCNFLG,TCP%WM	; In word mode?
2)		   TXOA T3,<POINT 36,0>	; Yes, use 36 bit bytes
2)		    TXO T3,<POINT 8,0>	; No, use 8 bit bytes
2)		ELSE.			; Non-0 P and S, is S 8 or 36?
2)		  LOAD T2,BDASZ,-BFRDAD+T3  ; Get the Size
2)		  TXNN JCNFLG,TCP%WM	; In word mode?
2)		  IFSKP.		; Yes
2)		    CAIE T2,^D36	; 36 bit bytes?
2)		     JRST MAKBF8	; No, illegal
2)		  ELSE.			; Not in word mode
2)		    CAIE T2,^D8		; 8 bit bytes?
2)		     JRST MAKBF8	; No, illegal
2)		  ENDIF.
2)		ENDIF.
2)		STOR T3,BDADR,(BFR)	; Remember it
2)	
2)		AND T3,[XWD 37,777777]	; 23-bit address
2)		MOVE T1,T3		; Save begin address for MAP
2)	
2)		TXNE JCNFLG,TCP%WM	; Is data count in words?
2)		IFSKP.			; No, octets
2)		  ADDI T4,3		; Round up to word boundary
2)		  ASH T4,-2		; Number of words in the buffer

; TCPBBN.MAC.1 & <BBN-MONITOR>TCPBBN.MAC.1  9-Mar-88 1334	PAGE 81


2)		ENDIF.
2)		ADD T3,T4		; Beyond buffer
2)		SUBI T3,1		; Last word in buffer
2)		MOVE T2,T3		; Save it
2)		LSH T3,-PGSFT		; Last page in buffer
2)		CAIL T3,1000		; Better not cross section boundary
2)		  JRST MAKBF8		; Give error if it does
2)	^L
2)	; Verify access
2)	
2)		TXNN ACCESS,PTWR	; Want to write?
2)		IFSKP.			; Yes
2)		  DO.
2)		    XCTU [MAP T3,(T1)]	; Page access
2)		    TXNE T3,20B5	; Check for hard failure
2)		      JRST MAKBF8	; Found one, let someone else complain
2)		    TXNN T3,17B5	; Skip if page exits
2)	;cwl might it be possible for the system to not have touched the end?
2)		     TXNN T3,1B0	; Not exist and user address is ok
2)		      TXNE T3,PTWR	; Exists or NEX-monitr  and  writeable?
2)		       TRNA		; NEX & User, or EX & writeable
2)		        JRST MAKBF8	; No, fail
2)		    ADDI T1,1000	; Next page
2)		    CAMG T1,T2		; Need to check it?
2)		      JRST TOP.		; Yes
2)		  ENDDO.
2)		ELSE.			; Read access
2)	jfcl;cwl how to check for no read access?
2)		ENDIF.
2)	
2)		MOVE T1,FORKX		; User's system fork number
2)		STOR T1,BFRKX,(BFR)	; Remember for mapping user space
2)	^L
2)		NOSKED			; No, Make sure we are the only one
2)	
2)		LOAD T4,BDASE,(BFR)	; Get section number of data
2)		XSFM T1			; Get previous context flags
2)		TXNN T1,PCU		; Previous Context User on?
2)		IFSKP.			; Yes
2)		  SETZ T2,		; Previous was user, Set monitor flag=0
2)		  LOAD T1,SPTX,+USECTB(T4) ; SPT index of data's section map
2)		ELSE.			; No
2)		  SETO T2,		; Previous monitor, Set monitor flag=1
2)		  LOAD T1,SPTX,+MSECTB(T4) ; SPT index of data's section map
2)		ENDIF.
2)		JUMPE T1,MAKBF7		; Error if no section map
2)		STOR T1,BDSPT,(BFR)	; Save SPT index of data's section map
2)		STOR T2,BFRMN,(BFR)	; Set Buffer from Monitor flag
2)	
2)	IFN REL6,<PRINTX ? Does MAKBFR have to be changed for REL6>
2)	

; TCPBBN.MAC.1 & <BBN-MONITOR>TCPBBN.MAC.1  9-Mar-88 1334	PAGE 82


2)		LOAD T2,BFRMN,(BFR)	; User/Monitor flag
2)		LOAD T4,BHDSE,(BFR)	; Section containing buffer header
2)		IFE. T2			; User
2)		  LOAD T3,SPTX,+USECTB(T4) ; SPT index of user section map
2)		ELSE.
2)		  LOAD T3,SPTX,+MSECTB(T4) ; SPT index of monitor section map
2)		ENDIF.
2)		STOR T3,BHSPT,(BFR)	; SPT index of header's section map
2)	
2)		IFQE. BFRMN,(BFR)	; Is buffer in monitor space, or
2)	;cwl TDEC should imply BFRMN since SEND%/RECV% for DEC was from monitor
2)		ANDQE. TDEC,(TCB)	; Is this a DEC TCB?
2)		  LOAD T2,SPTSHC,(T1)	; Get the share count on the spt slot
2)		  CAIL T2,MAXSHC-10	; Is it close to overflow?
2)		    JRST MAKBF6		; Yes, so we can not continue
2)		  PUSH P,Q1		; Protect critical AC
2)		  CALL UPSHR;(T1)	; Inc. data section's share count
2)		  LOAD T1,BHSPT,(BFR)	; Header section's SPT index
2)		  CALL UPSHR		; Inc. header section's share count
2)		  POP P,Q1
2)		  SETONE BFSRC,(BFR)	; Remember resource
2)		ENDIF.
2)	
2)		OKSKED			; Give back the system
2)	
2)		CALL RSTBFR		; Reset the buffer state
2)		MOVE T1,BFR		; This is the value
2)	MNTM5	AOS CELL(TCJMB,1,,TCJ)	; Successful MAKBFRs
2)		JRST MAKBFX
2)	^L
2)	
2)	MAKBF6:				; Here when UPT Share count will overflow
2)	;	SETZRO BFSRC,(BFR)	; Did not increment share count
2)		OKSKED			; Give back the machine
2)		HRROI T1,ELT+^D16	; No "space" available right now
2)		JRST MAKBF9
2)	
2)	MAKBF7:	OKSKED			; Give back the machine
2)	MAKBF8:	HRROI T1,ELP+^D15	; "Bad buffer arg(s)"
2)	MAKBF9:	PUSH P,T1		; Save error code
2)		LOAD T1,BIDX,(BFR)
2)		SKIPE T1		; Was wait bit assigned?
2)		  CALL RELWTB		; Yes, Release it
2)		MOVE T1,BFR		; Get the free space address
2)		CALL RETBLK		; Return the block and fall through
2)		POP P,T1		; Error code
2)	MAKBFX:	POP P,BFR
2)		RET
2)	
2)		ENDAV.
2)		ENDTV.

; TCPBBN.MAC.1 & <BBN-MONITOR>TCPBBN.MAC.1  9-Mar-88 1334	PAGE 83


2)	
2)	^L	SUBTTL FREBFR - Release Resources Used By a Buffer
2)	
2)	;Called by a process doing a SEND%, RECV% which waits for completion.
2)	;In this case USRBFE (or USRBFF) places the completed buffer on the
2)	;TCPBDQ so it may be released by this routine in the above JSYSs or
2)	;by ABORT.  Note that all mapping functions have already been completed.
2)	
2)	;BFR/	Extended Buffer
2)	;	CALL FREBFR
2)	;Ret+1:	Always
2)	
2)	FREBFR:
2)	MNTM5	AOS CELL(TCJAA,3,,TCJ)	; FREBFR calls
2)		NOSKED
2)	
2)		MOVX T1,PT%TKB		; Kill buffer
2)		TXNN FR,1B0		; TCB trace or
2)		 TDNE T1,MNTRAC		; Want trace?
2)		  CALL PRNPKT		; Yes
2)	
2)		LOAD T1,BIDX,(BFR)	; Get the wait bit index
2)		SETZRO BIDX,(BFR)	; Indicate it has been released
2)		SKIPE T1		; Have a bit to release?
2)		  CALL RELWTB		; Actually release it
2)	
2)		XMOVEI T1,BFRQ(BFR)	; Item to dequeue
2)		SKIPE (T1)		; If not queued, skip it
2)		  CALL DQ		; Remove it from the done queue
2)		OKSKED
2)	
2)	IFN BFRQ,<XMOVEI T1,-BFRQ(T1)>	; Point to top of structure
2)		CALLRET RETBLK		; Release the storage
2)	
2)	^L
2)	;BBNCHK	Check to see if a BBN TCP JSYS is legal.  Always legal for the
2)	;monitor. If from user mode not legal for a DEC TCB.  If BBNOK is off
2)	;then never legal from user mode. Skip return if legal.


LINE 10, PAGE 43
1)		 RETSKP			; No, call is always legal for the monitor
1)		TMNN TDEC,(TCB)		; is this a DEC TCB?
1)	         SKIPN BBNOK		; not DEC TCB.  Are BBN Calls OK?
1)	          RET			; not OK aor this is a DEC TCB
1)		RETSKP			; skip return
1)	
1)	BBNCKK:				; Same as above but does not check the TCB
1)		XSFM T1			; Get PC Flags
1)		SKIPN BBNOK		; BBN Calls OK?
1)	         TXNN T1,PCU		; No. Previous Context User on?

; TCPBBN.MAC.1 & <BBN-MONITOR>TCPBBN.MAC.1  9-Mar-88 1334	PAGE 84


1)	          RETSKP		; PCU off or BBNOK on.
1)		RET			; PCU on and BBNOK off.
LINE 9, PAGE 59
2)		  RETSKP		; No, call is always legal for the monitor
2)		MOVE T1,TCPSW		; Get TCP switches
2)		TMNN TDEC,(TCB)		; Is this a DEC TCB?
2)		 TXNN T1,BBNOK		; Not DEC TCB.  Are BBN Calls OK?
2)		  TRNA
2)		   RETSKP		; Skip return
2)		MOVX T1,TCPX28		; Invalid BBN JSYS call
2)		RET			; Not OK or this is a DEC TCB
2)	
2)	
2)	BBNCKK:				; Same as above but does not check the TCB
2)		XSFM T1			; Get PC Flags
2)		MOVE CX,TCPSW		; Get TCP switches
2)		TXNN CX,BBNOK		; BBN Calls OK?
2)	         TXNN T1,PCU		; No. Previous Context User on?
2)	          RETSKP		; PCU off or BBNOK on.
2)		MOVX T1,TCPX28		; Invalid BBN JSYS call
2)		RET			; PCU on and BBNOK off.
