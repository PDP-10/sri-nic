;[SRI-NIC]XS:<NEWMON>MEXEC.MAC.2,  5-Dec-86 15:27:41, Edit by MKL
; add CRLF after system restarting message
;[SRI-NIC]XS:<SU-61SU>MEXEC.MAC.2,  5-Dec-86 15:21:29, Edit by MKL
;;[SRI-NIC]SS:<6-1-MONITOR>MEXEC.MAC.5,  4-Nov-85 20:12:18, Edit by MKL
;; change IPALOD.EXE to 6-1-IPALOD.EXE
;;SS:<6-1-MONITOR>MEXEC.MAC.4, 29-Oct-85 11:31:48, Edit by KNIGHT
;; Flush turd in a SUMXSW conditional.
;;SS:<6-1-MONITOR>MEXEC.MAC.3, 28-Oct-85 16:55:11, Edit by KNIGHT
;; At NIC, we don't use ARP and PKOPR%.

;SIERRA::SRC:<6.1.MONITOR.STANFORD>MEXEC.MAC.10, 23-Oct-86 13:41:12, Edit by GROSSMAN
; Add Paul Hegarty's non-PS login stuff
; *** Edit 7316 to MEXEC.MAC by RASPUZZI on 11-Jun-86, for SPR #20381
; Change MEXEC to start SETSPD at entry vector plus 1 when setting terminal
; lines, etc for system startup. 
; *** Edit 7279 to MEXEC.MAC by MRASPUZZI on 31-Mar-86, for SPR #20779
; Make MEXEC setup a PRARG block when CJ%FIL is set for an EXEC besides the
; system EXEC
; *** Edit 7259 to MEXEC.MAC by WONG on 14-Mar-86, for SPR #18580
; Add batch info to Usage Session Record.
; *** Edit 7247 to MEXEC.MAC by LOMARTIRE on 19-Feb-86
; Implement OFN caching 
;Edit 7247 - Add CHKOFN for OFN caching cleanup
; *** Edit 7211 to MEXEC.MAC by GRANT on 18-Dec-85
; Add CI counters for WATCH 
;------------------------- Autopatch Tape # 12 -------------------------
; Edit 7173 to MEXEC.MAC by PALMIERI on 23-Oct-85 (TCO 6.1.1542)
; Move modules NIUSR and LLMOP to an extended section. This required the
; changing of some global routine names in LLMOP; Therefor the changes to
; MEXEC, JSYSA, and FORK. 
; Edit 7160 to MEXEC.MAC by WAGNER on 16-Oct-85
; Modify JOBCOF code to respect ACJs wishes regarding logout of jobs even if
; detached job timeout has expired. 
;Edit 7160 Fix Logout of detached jobs to obey ACJ even if it denies
; request to logout. If ACJ denies, wait COFTIM and ask again.
;[SU-SIERRA.ARPA]FS1:<DEC.6.1.MERGE>MEXEC.MAC.8, 24-Jun-86 18:09:28, Edit by GROSSMAN
; Move call to SETPOF to HSYS9 as it was smashing 5 which resulted in a
; premature 'Shutdown complete' message.
;SP:<6-1-MONITOR>MEXEC.MAC.7,  8-Apr-86 23:02:43, Edit by A.JIML
; Display Monitor Build Date correctly at Boot Time
;SP:<SOURCES.6-1-MONITOR>MEXEC.MAC.6,  7-Mar-86 23:01:18, Edit by A.JIML
; Added code to indicate when this Monitor was built
;<6-1-MONITOR>MEXEC.MAC.5,  4-Feb-86 14:20:01, Edit by LOUGHEED
; Remove GTWAA% support (no longer used at LOTS)
;<6-1-MONITOR>MEXEC.MAC.4, 30-Oct-85 22:52:18, Edit by WHP4
; MRC's fix had UMOVE, should have been XCTU.   Fix that.
;<6-1-MONITOR>MEXEC.MAC.3, 30-Oct-85 22:39:11, Edit by WHP4
; Support extended-section entry vector CRJOB's
;<6-1-MONITOR.FT6>MEXEC.MAC.2, 12-Aug-85 17:58:00, Edit by WHP4
;Stanford changes:
; No CHKDMS or DDMP swap space low messages if system is remedial or
;  standalone.  Cuts down on CTY chatter when repairing system structure.
; Make IDLE% work correctly for line 0.
; Patch to CHKR to prevent CFSKPD bughlts
; Make sure LDTALN set up before used in LDTACH
; Timestamped console messages
; Run TIME program to set system clock.
; Start networks at RUNDD3 instead of at RUNDD7 so TIME program works
; Start Address Resolution Protocol (ARP) background process
; Initialize PKOPR% database at system startup
; If system brought up standalone, set Why Reload reason to "SA" automatically
; Support for MRC's HSYS% queuing scheme
; Put our Internet host name in "going down" msg
; Have 5-minute warning about systemwide expunge
; CHKAC% treats domestic structures as an extension of the public structure
; LOTS accounting system changes (UPDWA stuff)
; Fix bug in LGOGOK.  Can't trust user's T1 being anything reasonable
; Output Welcome to ... message on logout and detach
; Less ugly logout message
; Make JOBDIR a GETAB% table  
; HANDS% JSYS for fast lookup of GETAB% tables
; IDLE% JSYS to get a job's "idle" time
; ISI ATACH% fix to eliminate carrier-off PSI race for network TTY's
;SUMEX changes:
; Setup LOGDES from LOGLNO in RUNDD
; Remove login/logout/acct change/attach/detach msgs from LOGDES
;Pup changes:
; Create pup background fork at system startup
; Pup GETAB% tables
; No carrier-off PSI (autologout) if user detaches self from PUP NVT
; Kill Pup connection if attaching a job away from a PNV
; Call SETPOF at system shutdown
;<6-1-MONITOR>MEXEC.MAC.272, 28-Apr-85 15:06:39, Edit by LOUGHEED
; UPD ID= 2290, SNARK:<6.1.MONITOR>MEXEC.MAC.284,  29-Jun-85 22:38:22 by GRANT
;TCO 6.1.1477 - IPALOD has new entry point for monitor
; UPD ID= 2238, SNARK:<6.1.MONITOR>MEXEC.MAC.283,  19-Jun-85 10:57:37 by GROSSMAN
;TCO 6.1.1461 - Add call to LLMJB0 to CHKR.
; UPD ID= 2220, SNARK:<6.1.MONITOR>MEXEC.MAC.282,  12-Jun-85 17:45:43 by GRANT
;Change IPAFOO back to IPALOD
; UPD ID= 2120, SNARK:<6.1.MONITOR>MEXEC.MAC.281,   5-Jun-85 09:55:21 by MCCOLLUM
;TCO 6.1.1406  - Update copyright notice.
; UPD ID= 2026, SNARK:<6.1.MONITOR>MEXEC.MAC.280,  28-May-85 16:34:16 by MCCOLLUM
;Add ERJMPs
; UPD ID= 1965, SNARK:<6.1.MONITOR>MEXEC.MAC.279,  13-May-85 10:11:15 by GRANT
;TCO 6.1.1377 - Load CI ucode into resident memory during system startup. CIFORK
;no longer does loading of CI ucode.
; UPD ID= 1890, SNARK:<6.1.MONITOR>MEXEC.MAC.278,   4-May-85 15:14:42 by MCCOLLUM
;TCO 6.1.1238 - Fix more BUG. documentation
; UPD ID= 1862, SNARK:<6.1.MONITOR>MEXEC.MAC.277,   2-May-85 15:02:58 by GROSSMAN
;TCO 6.1.1354 - Fix CRJOB hangs when created job gets logged out too soon.
; UPD ID= 1858, SNARK:<6.1.MONITOR>MEXEC.MAC.276,  30-Apr-85 15:58:06 by LOMARTIRE
;TCO 6.1.1350 - Set local time from cluster first, then local system
; UPD ID= 1838, SNARK:<6.1.MONITOR>MEXEC.MAC.275,  26-Apr-85 15:09:38 by MCCOLLUM
;TCO 6.1.1238 - Fix more BUG. documentation
; UPD ID= 1837, SNARK:<6.1.MONITOR>MEXEC.MAC.274,  26-Apr-85 15:06:45 by MCCOLLUM
;TCO 6.1.1238 - Fix more BUG. documentation
; UPD ID= 1768, SNARK:<6.1.MONITOR>MEXEC.MAC.273,  22-Apr-85 09:02:38 by GRANT
;More 6.1.1284 - CALL CFSKPR should have been removed
; UPD ID= 1711, SNARK:<6.1.MONITOR>MEXEC.MAC.272,   5-Apr-85 13:47:27 by MCCOLLUM
;TCO 6.1.1238 - Fix BUG. documentation
; UPD ID= 1672, SNARK:<6.1.MONITOR>MEXEC.MAC.271,  25-Mar-85 08:20:11 by GRANT
;TCO 6.1.1284 - Change TEFORK to CIFORK and keep it around to do CI stuff
; UPD ID= 1643, SNARK:<6.1.MONITOR>MEXEC.MAC.270,  18-Mar-85 08:10:03 by GRANT
;More TCO 6.1.1245 - Minor enhancement
; UPD ID= 1624, SNARK:<6.1.MONITOR>MEXEC.MAC.269,  12-Mar-85 15:57:06 by LOMARTIRE
;TCO 6.1.1247 - Remove the extra wait after call to CFSJYN
; UPD ID= 1613, SNARK:<6.1.MONITOR>MEXEC.MAC.268,  11-Mar-85 09:54:05 by GRANT
;TCO 6.1.1245 - Broadcast cease, shutdown canceled, and timesharing is over.
;Add a check for cluster ceases in CHKR.
; UPD ID= 1581, SNARK:<6.1.MONITOR>MEXEC.MAC.267,   4-Mar-85 08:00:58 by LOMARTIRE
;TCO 6.1.1227 - Move the starting of TEFORK earlier to help insure CFS joining
; UPD ID= 1283, SNARK:<6.1.MONITOR>MEXEC.MAC.266,   7-Jan-85 11:03:26 by HAUDEL
;TCO 6.1.1115 - Add ERJMPs after a few JSYSes in logout,attach,and detach code
; Fix typo in UPD ID=1249.
; UPD ID= 1270, SNARK:<6.1.MONITOR>MEXEC.MAC.264,   4-Jan-85 15:01:26 by MCCOLLUM
;TCO 6.1.1111 - Get JFN's for job 0 forks with GJ%ACC on
; UPD ID= 1249, SNARK:<6.1.MONITOR>MEXEC.MAC.263,  31-Dec-84 13:12:53 by MCCOLLUM
;TCO 6.1.1112 - In GETAB%, translate local job number to global for DEVUNT table.
; UPD ID= 1230, SNARK:<6.1.MONITOR>MEXEC.MAC.262,  19-Dec-84 18:35:28 by GRANT
;Move SAVTRE to STG.MAC
; UPD ID= 1218, SNARK:<6.1.MONITOR>MEXEC.MAC.261,  18-Dec-84 12:48:47 by TBOYLE
;TCO 6.1.1092 - Fix jobs hung in LOGOUT - Put CFOBF at LOG2 after SOBE loop
; UPD ID= 1018, SNARK:<6.1.MONITOR>MEXEC.MAC.260,   9-Nov-84 13:25:40 by GRANT
;TCO 6.2278 - fix BUGxxx output
; UPD ID= 944, SNARK:<6.1.MONITOR>MEXEC.MAC.259,   4-Nov-84 15:25:06 by GLINDELL
;More TCO 6.1.1021 - Change MDDTP to reflect MDDT's new position in XCDSEC
; UPD ID= 5050, SNARK:<6.MONITOR>MEXEC.MAC.258,  31-Oct-84 18:08:38 by MOSER
;TCO 6.2256 - FIX CRJOB IF CJ%WTA SPECIFIED
; UPD ID= 5038, SNARK:<6.MONITOR>MEXEC.MAC.257,  30-Oct-84 13:55:40 by MCLEAN
;FIX LOGOUT
; UPD ID= 5037, SNARK:<6.MONITOR>MEXEC.MAC.256,  30-Oct-84 09:59:56 by PAETZOLD
;TCO 6.2267 - Save CX in JOBCOF.
; UPD ID= 5003, SNARK:<6.MONITOR>MEXEC.MAC.255,  24-Oct-84 20:15:31 by GLINDELL
;Put in a call to DCNJB0 in CHKR
; UPD ID= 4974, SNARK:<6.MONITOR>MEXEC.MAC.254,  22-Oct-84 16:31:20 by GRANT
;Remove references to FTCI
; UPD ID= 4965, SNARK:<6.MONITOR>MEXEC.MAC.253,  19-Oct-84 14:46:22 by GLINDELL
;More TCO 6.1.1021 - clear T3 before SOUT in LOGBUG
; UPD ID= 4964, SNARK:<6.MONITOR>MEXEC.MAC.252,  19-Oct-84 13:42:26 by GLINDELL
;More TCO 6.1.1021 - get only section-relative address of BUG. for compare
; UPD ID= 4948, SNARK:<6.MONITOR>MEXEC.MAC.251,  17-Oct-84 15:17:44 by HAUDEL
;TCO 6.2250 - Add an ERJMP after an ODTIM% in LOGJ2 code.
; UPD ID= 4947, SNARK:<6.MONITOR>MEXEC.MAC.250,  17-Oct-84 13:58:59 by HAUDEL
;TCO 6.2249 - Add some ERJMPs after a few JSYSes.
; UPD ID= 4945, SNARK:<6.MONITOR>MEXEC.MAC.249,  17-Oct-84 11:57:16 by TGRADY
; TCO 6.2247 (QAR 706189) Print proper job number in ATTACH JSYS.
; TCO 6.2214 (QAR 706279) Fix up STCRJB and ELOGO to understand that JOBONT
; contains GLOBAL job numbers, not local.  Oversight in edit 4785.
; UPD ID= 4944, SNARK:<6.MONITOR>MEXEC.MAC.248,  17-Oct-84 10:55:47 by HAUDEL
;TCO 6.2246 - Add ERJMP .+1 after BOUTs in LOGTIM: code.
; UPD ID= 4935, SNARK:<6.MONITOR>MEXEC.MAC.247,  15-Oct-84 13:06:30 by GRANT
;The assembly switch CFSCOD has been eliminated
; UPD ID= 4915, SNARK:<6.MONITOR>MEXEC.MAC.246,  10-Oct-84 17:13:06 by GLINDELL
;TCO 6.1.1021 - 6.1 address space
;	BGPTR entries are now two words long (full 30-bit addresses)
; UPD ID= 4884, SNARK:<6.MONITOR>MEXEC.MAC.245,  26-Sep-84 16:40:18 by GRANT
;In CHKR, CALL KLPRCT
; UPD ID= 4882, SNARK:<6.MONITOR>MEXEC.MAC.244,  26-Sep-84 15:59:55 by GRANT
;TCO 6.2225 - Add "save a tree" option to LOGBUG
; UPD ID= 4863, SNARK:<6.MONITOR>MEXEC.MAC.243,  23-Sep-84 15:24:41 by TBOYLE
;Clear output buffer during LOGOUT after STPAR in LOG1
; UPD ID= 4813, SNARK:<6.MONITOR>MEXEC.MAC.242,  17-Sep-84 10:13:22 by PURRETTA
;Update copyright notice
; UPD ID= 4785, SNARK:<6.MONITOR>MEXEC.MAC.241,  31-Aug-84 14:29:47 by TGRADY
;TCO 6.2214 (QAR 706071) Fix up use of CRJONJ and JOBONT for CRJOB'ed jobs.
; UPD ID= 4777, SNARK:<6.MONITOR>MEXEC.MAC.240,  30-Aug-84 10:48:24 by PAETZOLD
;TCO 6.2211 - Carrier off needs to preserve KIMUFL and KIMUPC.
; UPD ID= 4771, SNARK:<6.MONITOR>MEXEC.MAC.239,  29-Aug-84 13:57:18 by TGRADY
;TCO 6.2201 (QAR 706198) - Remove edit 4444 (TCO 6.2121) and fix the
;general problem of needing a local job index in the USAGE record.
; UPD ID= 4743, SNARK:<6.MONITOR>MEXEC.MAC.238,  24-Aug-84 09:43:58 by PAETZOLD
;TCO 6.2191 - Change unsafe SETJSB calls to MAPJSB.
; UPD ID= 4702, SNARK:<6.MONITOR>MEXEC.MAC.237,  16-Aug-84 13:28:15 by GROSSMAN
;More TCO 6.2176 - Reverse order of IPALOD and KNIJB0.
; UPD ID= 4698, SNARK:<6.MONITOR>MEXEC.MAC.236,  15-Aug-84 18:51:40 by GROSSMAN
;TCO 6.2176 - Add call to KNIJB0 in CHKR.
; UPD ID= 4677, SNARK:<6.MONITOR>MEXEC.MAC.235,  13-Aug-84 10:26:47 by GLINDELL
;Type out the full 30-bit address on entry to the MX
; UPD ID= 4676, SNARK:<6.MONITOR>MEXEC.MAC.234,  11-Aug-84 00:54:45 by TBOYLE
;TCO 6.2171 Save all registers at JOBCOF.
; UPD ID= 4620, SNARK:<6.MONITOR>MEXEC.MAC.233,  28-Jul-84 15:58:40 by MOSER
;TCO 6.2083 - ENHANCE MONBK - ADD MONBKX
; UPD ID= 4610, SNARK:<6.MONITOR>MEXEC.MAC.232,  27-Jul-84 14:51:19 by TBOYLE
;New SYSERR - At LOGBF6-1 use XMOVEI.
; UPD ID= 4507, SNARK:<6.MONITOR>MEXEC.MAC.231,  12-Jul-84 21:55:51 by TGRADY
;TCO 6.2126 Use Global job number as argument to GTOKM .GOATJ function
; UPD ID= 4455, SNARK:<6.MONITOR>MEXEC.MAC.230,  12-Jul-84 10:43:05 by CDUNN
;More TCO 6.1127 Add call to SCSLGO at FLOGO to delete SCS% data on top 
;fork kill
; UPD ID= 4444, SNARK:<6.MONITOR>MEXEC.MAC.229,   6-Jul-84 16:54:45 by TBOYLE
;TCO 6.2121 - Make UCKSET convert jobno to local before mapping checkpoint pg.
; UPD ID= 4418, SNARK:<6.MONITOR>MEXEC.MAC.228,   2-Jul-84 13:46:13 by TGRADY
;TCO 6.2114 - Fix typo in TTY2GL to return waiting fork number...
; UPD ID= 4364, SNARK:<6.MONITOR>MEXEC.MAC.227,  20-Jun-84 15:59:58 by TBOYLE
;TCO 6.2104 - Fix session start and end times at USGSEN.
; UPD ID= 4363, SNARK:<6.MONITOR>MEXEC.MAC.226,  20-Jun-84 15:10:36 by TGRADY
;TCO 6.2103 (QAR 706052) - Fix ATACH% to prevent 'Wheel or Opr required' error
; UPD ID= 4358, SNARK:<6.MONITOR>MEXEC.MAC.225,  18-Jun-84 15:48:47 by TGRADY
;TCO 6.2077 (QAR 706022) Make GETAB% return a -1 for non-existant jobs.
; UPD ID= 4356, SNARK:<6.MONITOR>MEXEC.MAC.224,  18-Jun-84 14:13:38 by GRANT
;TCO 6.2102 (QAR 706050) - During system shutdown disallow incoming nvt
;(ARPANET and DECnet) logins.
; UPD ID= 4300, SNARK:<6.MONITOR>MEXEC.MAC.223,   4-Jun-84 23:01:34 by MOSER
;TCO 6.2059 - ALLOW EXEC XCT ONLY - FIX CRJOB - CHANGES FOR NON WHEEL STARTUP
; UPD ID= 4219, SNARK:<6.MONITOR>MEXEC.MAC.222,  14-May-84 18:55:34 by WEISBACH
;~6.0 - Add call to LAT host initialization (LATINI)
; UPD ID= 4211, SNARK:<6.MONITOR>MEXEC.MAC.221,  11-May-84 12:15:11 by GRANT
;In RUNDD2, add call to SRVCFS (moved here from CFSJYN in CFSSRV)
; UPD ID= 4207, SNARK:<6.MONITOR>MEXEC.MAC.220,  11-May-84 08:18:39 by GRANT
;In EGET, ERJMP after the GET%
; UPD ID= 4128, SNARK:<6.MONITOR>MEXEC.MAC.219,  25-Apr-84 11:07:42 by LOMARTIRE
;TCO 6.2046 - Record fork number for various job 0 forks created in RUNDD
; UPD ID= 4115, SNARK:<6.MONITOR>MEXEC.MAC.218,  24-Apr-84 12:59:05 by TGRADY
;TCO 6.2042 - Fix CFSILJ BUGCHK's from GETJI% called with .TTDES+n
; UPD ID= 4069, SNARK:<6.MONITOR>MEXEC.MAC.217,  11-Apr-84 19:12:50 by MOSER
;TCO 6.2023 - REMOVE ALL ERCAL INSTRUCTIONS
; UPD ID= 4062, SNARK:<6.MONITOR>MEXEC.MAC.215,  11-Apr-84 14:47:35 by GRANT
;In IPACHK, more graceful handling of no IPALOD or IPADMP
; UPD ID= 4012, SNARK:<6.MONITOR>MEXEC.MAC.214,  31-Mar-84 08:10:17 by GRANT
;Remove SEARCH of SCAPAR
; UPD ID= 4001, SNARK:<6.MONITOR>MEXEC.MAC.213,  28-Mar-84 20:46:37 by GRANT
;In IPACHK, look on PS:<SYSTEM> instead of SYSTEM:
; UPD ID= 3998, SNARK:<6.MONITOR>MEXEC.MAC.212,  28-Mar-84 17:22:15 by GUNN
;Revoke UPD ID 3741 - Put under FTNSPSRV conditional.
; UPD ID= 3946, SNARK:<6.MONITOR>MEXEC.MAC.211,  19-Mar-84 16:57:31 by MOSER
;TCO 6.2003 - ADD .JILJI FUNCTION OF GETJI
; UPD ID= 3924, SNARK:<6.MONITOR>MEXEC.MAC.210,  14-Mar-84 10:51:46 by TGRADY
;TCO 6.1998 - Fix ELOGO to compare user-specified job number to GBLJNO,
;   not JOBNO
;
; UPD ID= 3869, SNARK:<6.MONITOR>MEXEC.MAC.209,   7-Mar-84 11:30:21 by LEACHE
;More TCO 6.1969 - move init of SWPMWF from MEXEC to PAGUTL
; UPD ID= 3850, SNARK:<6.MONITOR>MEXEC.MAC.207,   5-Mar-84 12:12:38 by GRANT
;In IPACHK, do dumping as well as loading.
; UPD ID= 3816, SNARK:<6.MONITOR>MEXEC.MAC.206,  29-Feb-84 17:04:39 by LEACHE
;TCO 6.1969 Change swappable monitor load to reflect single-pass load
; UPD ID= 3802, SNARK:<6.MONITOR>MEXEC.MAC.205,  29-Feb-84 01:44:07 by TGRADY
; Implement Global Job Numbers
; - In SYSINE, assign a Global Job number from CFS, and save it in GBLJNO
; - In STCRJB, return Global job number to CRJOB creator, put index in JOBONT
; - In RUNDD3, Initialize CFS Global Job Number database...
; - In HSYS41:, convert local job index to global job number for LGOUT Jsys
; - In LOG2, call JBAVAL to release Global job number just before HLTJB call.
; - In LOGJOB, Print Global job number during logout.
; - In ELOGO, translate user-specified global job number into local index
; - In .GJINF, use GBLJNO to return user's own job number, instead of JOBNO
; - In .GETAB, overhaul GTTAB table to use new GTJOB routine to translate
;   user-specified Global Job number into local job index.  Make the tables'
;   'size' be the highest legal Global Job number, MXGLBS, for range checking
;   instead of NJOBS, which is only the highest index value.
;   Also, create jacket routine TTY2GL to convert job index returned by
;   GTBTTF to a global job number
; - In .GETJI, translate user-specified global job number into local index
; - In GETJI4, translate job index into Global job number before returning it.
; - In GETJIT table, return other jobs Global Job number (from JSB)
; - In ATACH1, same as .GETJI
;
; UPD ID= 3741, SNARK:<6.MONITOR>MEXEC.MAC.204,  22-Feb-84 17:27:14 by PAETZOLD
;Revoke previous edit until he gets it right.  
; UPD ID= 3725, SNARK:<6.MONITOR>MEXEC.MAC.203,  22-Feb-84 11:39:52 by GUNN
;~6.0 - Add call to initialize Ethernet LLMOP Protocol Servers
; UPD ID= 3721, SNARK:<6.MONITOR>MEXEC.MAC.202,  22-Feb-84 05:36:57 by GRANT
;Call CFSJ0 from CHKR
; UPD ID= 3698, SNARK:<6.MONITOR>MEXEC.MAC.201,  15-Feb-84 21:28:14 by MURPHY
;Make definition of MDDT include section number so MDDT$G always works.
; UPD ID= 3741, SNARK:<6.MONITOR>MEXEC.MAC.204,  22-Feb-84 17:27:14 by PAETZOLD
;Revoke previous edit until he gets it right.  
; UPD ID= 3725, SNARK:<6.MONITOR>MEXEC.MAC.203,  22-Feb-84 11:39:52 by GUNN
;~6.0 - Add call to initialize Ethernet LLMOP Protocol Servers
; UPD ID= 3721, SNARK:<6.MONITOR>MEXEC.MAC.202,  22-Feb-84 05:36:57 by GRANT
;Call CFSJ0 from CHKR
; UPD ID= 3698, SNARK:<6.MONITOR>MEXEC.MAC.201,  15-Feb-84 21:28:14 by MURPHY
;Make definition of MDDT include section number so MDDT$G always works.
; UPD ID= 3656, SNARK:<6.MONITOR>MEXEC.MAC.200,   4-Feb-84 10:32:35 by MILLER
;Call BRDTIM if CFS stuff is around
; UPD ID= 3648, SNARK:<6.MONITOR>MEXEC.MAC.199,   2-Feb-84 14:35:36 by MURPHY
;Ditto - fix bugs.
; UPD ID= 3640, SNARK:<6.MONITOR>MEXEC.MAC.198,   2-Feb-84 11:53:23 by MURPHY
;Different way of getting to BOOT to load swap mon.
; UPD ID= 3633, SNARK:<6.MONITOR>MEXEC.MAC.197,   1-Feb-84 22:08:42 by MURPHY
;Reference bug strings and pointers in symsec.
; UPD ID= 3565, SNARK:<6.MONITOR>MEXEC.MAC.196,  27-Jan-84 13:34:03 by PAETZOLD
;More TCO 6.1954 - Make CHKPER and DDPPER resident.  Fix DDPWAT bug.
; UPD ID= 3557, SNARK:<6.MONITOR>MEXEC.MAC.195,  26-Jan-84 13:56:47 by PAETZOLD
;More TCO 6.1954 - Make CHKPER and DDPPER global.  Make DDPDUE force DDMP.
; UPD ID= 3539, SNARK:<6.MONITOR>MEXEC.MAC.194,  25-Jan-84 15:14:38 by PAETZOLD
;TCO 6.1954 - Add code for DDPDUE and CHKDUE.
; UPD ID= 3510, SNARK:<6.MONITOR>MEXEC.MAC.193,  23-Jan-84 09:44:12 by PRATT
;TCO 6.1924 - Use "display type" block with "msg" block in WROPER
; UPD ID= 3490, SNARK:<6.MONITOR>MEXEC.MAC.192,  20-Jan-84 11:09:27 by CDUNN
;More TCO 6.1127 - Add new "temp" fork at startup to handle SCA buffer deferal
;requests until after DDMP has mounted PS.
; UPD ID= 3456, SNARK:<6.MONITOR>MEXEC.MAC.191,  13-Jan-84 17:16:14 by TBOYLE
;TCO 6.1933 - (RUNDD4) Do processing if SPRCNT not reset, and start 
;SYSERR queue
; UPD ID= 3449, SNARK:<6.MONITOR>MEXEC.MAC.190,  12-Jan-84 14:22:41 by PAETZOLD
;TCO 6.1929 - Change FKJOBN to FKJBN
; UPD ID= 3420, SNARK:<6.MONITOR>MEXEC.MAC.189,   6-Jan-84 18:13:00 by MILLER
;Add CFSCOD conditional around call to CFTADC
; UPD ID= 3418, SNARK:<6.MONITOR>MEXEC.MAC.188,   6-Jan-84 09:07:27 by PRATT
;TCO 6.1912 - In WROPER, QU%NRS should be set in the arg block, not ac 1 
; UPD ID= 3310, SNARK:<6.MONITOR>MEXEC.MAC.187,  13-Dec-83 18:16:03 by PAETZOLD
;TCO 6.1906 - Add code to update DDPTIM
; UPD ID= 3270, SNARK:<6.MONITOR>MEXEC.MAC.186,   7-Dec-83 09:06:17 by MILLER
;TCO 6.1806. Add calls to DTTIME
; UPD ID= 3192, SNARK:<6.MONITOR>MEXEC.MAC.185,  18-Nov-83 11:01:36 by PAETZOLD
;Do not call CHKIMP
; UPD ID= 3183, SNARK:<6.MONITOR>MEXEC.MAC.184,  17-Nov-83 14:15:55 by PRATT
;TCO 6.1796 - Lots of ERJMPs after TTMSGs in case of refusals
; UPD ID= 3151, SNARK:<6.MONITOR>MEXEC.MAC.183,  15-Nov-83 09:47:34 by PAETZOLD
;TCO 6.1862 - Fix problem with incorrect .XPCN2 word being returned in XPEEK
; UPD ID= 3114, SNARK:<6.MONITOR>MEXEC.MAC.182,   8-Nov-83 09:01:15 by MCINTEE
;~6.0 Remove NSP% jsys
; UPD ID= 3095, SNARK:<6.MONITOR>MEXEC.MAC.181,   3-Nov-83 23:37:50 by GROSSMAN
;TCO 6.1849 - Reset CRJTTY to a value of -1 only during CRJOB startup.
; UPD ID= 3084, SNARK:<6.MONITOR>MEXEC.MAC.180,  28-Oct-83 15:54:56 by HAUDEL
;TCO 6.1840 - Add an ERJMP .+1 after TTMSG 
; UPD ID= 3004, SNARK:<6.MONITOR>MEXEC.MAC.179,   7-Oct-83 17:55:34 by GUNN
;~6.0 Add call to LLMRSJ from FLOGO to clean up LLMOP resources at logout.
; UPD ID= 2993, SNARK:<6.MONITOR>MEXEC.MAC.178,   5-Oct-83 14:49:33 by PAETZOLD
;More TCO 6.1733 - Remove call to IMPBEG.  NCPFRK has gone away.
; UPD ID= 2978, SNARK:<6.MONITOR>MEXEC.MAC.177,   4-Oct-83 08:07:04 by MILLER
;TCO 6.1806 Once again.
; UPD ID= 2944, SNARK:<6.MONITOR>MEXEC.MAC.176,  27-Sep-83 20:35:08 by MILLER
;MORE TCO 6.1806. CHECK ON TAD IN CHKR
; UPD ID= 2930, SNARK:<6.MONITOR>MEXEC.MAC.175,  23-Sep-83 14:00:41 by MILLER
;More TCO 6.1806. Output date and time so operator knows
; UPD ID= 2926, SNARK:<6.MONITOR>MEXEC.MAC.174,  23-Sep-83 10:37:51 by MILLER
;TCO 6.1806. Try to get TAD from CFS
; UPD ID= 2914, SNARK:<6.MONITOR>MEXEC.MAC.173,  20-Sep-83 15:33:39 by LOMARTIRE
;TCO 6.1791 - Do not allow ATACH from batch unless WHEEL or OPR enabled
; UPD ID= 2842, SNARK:<6.MONITOR>MEXEC.MAC.172,  17-Aug-83 21:41:01 by MURPHY
;More 6.1525 - Separate section 0/1 maps.  Remove NRCOD from sec 0 map.
; UPD ID= 2807, SNARK:<6.MONITOR>MEXEC.MAC.171,   9-Aug-83 11:46:15 by MURPHY
;Move MOVCST from here to PAGUTL.
; UPD ID= 2797, SNARK:<6.MONITOR>MEXEC.MAC.170,   4-Aug-83 00:30:32 by LEACHE
;TCO 6.1641  Change swappable freespace initialization
; UPD ID= 2768, SNARK:<6.MONITOR>MEXEC.MAC.169,  25-Jul-83 17:48:48 by MCCOLLUM
;TCO 6.1743 - Add XPEEK% JSYS
; UPD ID= 2749, SNARK:<6.MONITOR>MEXEC.MAC.168,  22-Jul-83 16:38:22 by PAETZOLD
;TCO 6.1733 - Reflect that NCP has gone away.
; UPD ID= 2745, SNARK:<6.MONITOR>MEXEC.MAC.167,  22-Jul-83 16:33:16 by MURPHY
;More 6.1568 - Make COFTIM settable by SMON.
;TCO 6.1719 - Customer-selectable hangup action.
; UPD ID= 2673, SNARK:<6.MONITOR>MEXEC.MAC.166,   5-Jul-83 16:04:54 by MILLER
;Various changes for CFS CI error recovery
; UPD ID= 2669, SNARK:<6.MONITOR>MEXEC.MAC.165,   5-Jul-83 15:48:20 by MOSER
;TCO 6.1568 - USE COFMIN AS VALUE FOR CARRIER OFF WAIT BEFORE LOGOUT
; UPD ID= 2667, SNARK:<6.MONITOR>MEXEC.MAC.164,   5-Jul-83 13:32:48 by MURPHY
;More 6.1525 - Remove hidden symbol table, add symtab in separate section.
; UPD ID= 2602, SNARK:<6.MONITOR>MEXEC.MAC.163,  20-Jun-83 15:40:03 by HALL
;TCO 6.1689 - Move fork tables to extended section
;	Reference FKINT bits via DEFSTR
; UPD ID= 2577, SNARK:<6.MONITOR>MEXEC.MAC.162,  10-Jun-83 17:39:29 by PAETZOLD
;TCO 6.1680 - Turn on QU%NRS in WROPR0
; UPD ID= 2546, SNARK:<6.MONITOR>MEXEC.MAC.161,  31-May-83 16:44:49 by MURPHY
;TCO 6.1525 - Move subsys names tables to ext section.
; UPD ID= 2382, SNARK:<6.MONITOR>MEXEC.MAC.160,  29-Apr-83 15:03:02 by MCINTEE
;TCO 6.1630 - MONBK/PSIMB fix
; UPD ID= 2286, SNARK:<6.MONITOR>MEXEC.MAC.158,  16-Apr-83 19:14:33 by PAETZOLD
;TCO 6.1557 - TCP Merge - Delete old edit history - Update copyright.
; UPD ID= 2245, SNARK:<6.MONITOR>MEXEC.MAC.157,  12-Apr-83 13:15:09 by MCINTEE
;Remove IFNDEF FTNSPSRV
; UPD ID= 2219, SNARK:<6.MONITOR>MEXEC.MAC.156,   8-Apr-83 13:06:09 by MILLER
;TCO 6.1602 again. Fix call to RUNDII in IPACHK
; UPD ID= 2218, SNARK:<6.MONITOR>MEXEC.MAC.155,   8-Apr-83 12:29:03 by MILLER
;Fix IPACHK some
; UPD ID= 2216, SNARK:<6.MONITOR>MEXEC.MAC.154,   8-Apr-83 09:37:05 by MILLER
;Once more. Wait for KLIPA reload at system start-up
; UPD ID= 2215, SNARK:<6.MONITOR>MEXEC.MAC.153,   8-Apr-83 08:36:24 by MILLER
;TCO 6.1602. Load KLIPA microcode when needed
; UPD ID= 2205, SNARK:<6.MONITOR>MEXEC.MAC.152,   8-Apr-83 05:58:57 by WACHS
;TCO 6.1604 - Call KLIPA initialization late
; UPD ID= 2130, SNARK:<6.MONITOR>MEXEC.MAC.151,   2-Apr-83 22:46:44 by LEACHE
;TCO 6.1247 Add centralized penalties for bad passwords
; UPD ID= 2111, SNARK:<6.MONITOR>MEXEC.MAC.149,  28-Mar-83 19:43:31 by MILLER
;TCO 6.1094. Get rid of GETALF
; UPD ID= 2102, SNARK:<6.MONITOR>MEXEC.MAC.148,  28-Mar-83 17:43:19 by MURPHY
;TCO 6.1472 - Minor cleanup re. LSTERR.
; UPD ID= 1995, SNARK:<6.MONITOR>MEXEC.MAC.147,  15-Mar-83 10:58:40 by MILLER
;TCO 6.1544. Call MAPPHQ when mapping BOOT
; UPD ID= 1967, SNARK:<6.MONITOR>MEXEC.MAC.146,  10-Mar-83 17:57:28 by CDUNN
;More TCO 6.1127 - Add lost edit to call SC.RAP to clean up SCA data as
;needed.
; UPD ID= 1929, SNARK:<6.MONITOR>MEXEC.MAC.145,   7-Mar-83 21:02:14 by CDUNN
;Change default to include KLIPA code
; UPD ID= 1913, SNARK:<6.MONITOR>MEXEC.MAC.144,   3-Mar-83 13:05:37 by MCINTEE
;TCO 6.1532 - Remove SE1ENT & SE0ENT in routine STCJB2. Put in a TSTMS0.
; UPD ID= 1908, SNARK:<6.MONITOR>MEXEC.MAC.143,   2-Mar-83 17:30:32 by MILLER
;TCO 6.1094 again. CALL CFSJYN
; UPD ID= 1904, SNARK:<6.MONITOR>MEXEC.MAC.142,   2-Mar-83 15:44:36 by MILLER
;TCO 6.1094 again. Move MNTPS yet again, and call FILRST with it
; UPD ID= 1888, SNARK:<6.MONITOR>MEXEC.MAC.141,   1-Mar-83 10:37:34 by MILLER
;TCO 6.1094. Move call to MNTPS
; UPD ID= 1880, SNARK:<6.MONITOR>MEXEC.MAC.140,  27-Feb-83 22:05:25 by MURPHY
;More TCO 6.1514 and 6.1142 - Use ERJMPS after DIRST in LOGBUG.
;TCO 6.1525 - Get rid of unneeded XJRSTs.
; UPD ID= 1860, SNARK:<6.MONITOR>MEXEC.MAC.139,  22-Feb-83 20:24:48 by MILLER
;TCO 6.1520.  Enable disk preallocation after CHECKD runs
; UPD ID= 1858, SNARK:<6.MONITOR>MEXEC.MAC.138,  22-Feb-83 14:12:36 by MILLER
;TCO 6.1094. Add call to MNTPS during start-up
; UPD ID= 1847, SNARK:<6.MONITOR>MEXEC.MAC.137,  21-Feb-83 16:21:26 by MURPHY
;More 6.1507 - JOBCOF should jump to FLOGO1 not FLOGO after UPDL reset.
; UPD ID= 1842, SNARK:<6.MONITOR>MEXEC.MAC.136,  20-Feb-83 22:17:36 by MURPHY
;TCO 6.1514 - Use ITERX instead of JRST ITRAP.
; and revise the fixup to the fix to the fix to 6.1142 now that DIRST works.
; UPD ID= 1821, SNARK:<6.MONITOR>MEXEC.MAC.135,  18-Feb-83 07:32:51 by MCINTEE
;FIXUP THE FIX TO THE FIX TO 6.1142 - USE A TRVAR, NOT THE STACK
; UPD ID= 1814, SNARK:<6.MONITOR>MEXEC.MAC.134,  16-Feb-83 15:03:35 by MCINTEE
;FIX THE FIX TO 6.1142
; UPD ID= 1810, SNARK:<6.MONITOR>MEXEC.MAC.133,  15-Feb-83 14:22:21 by MILLER
;TCO 6.1094. Improve call to GETALF
; UPD ID= 1809, SNARK:<6.MONITOR>MEXEC.MAC.132,  15-Feb-83 10:16:24 by MURPHY
;TCO 6.1472 - Clean up uses of MCENTR.
;TCO 6.1506 - BUGCHK on unexpected job 0 interrupts.
;TCO 6.1507 - Fix MONPDL in JOBCOF.
;Fix to 6.1142 - Pointer clobbered if DIRST fails in LOGBUG.
; UPD ID= 1773, SNARK:<6.MONITOR>MEXEC.MAC.131,   5-Feb-83 18:55:25 by MILLER
;TCO 6.1094. Use DDMPF to flush pages for CFS
; UPD ID= 1768, SNARK:<6.MONITOR>MEXEC.MAC.130,   4-Feb-83 11:18:53 by MILLER
;TCO 6.1094. Distinguish DDMP for CFS from regular cycle
; UPD ID= 1745, SNARK:<6.MONITOR>MEXEC.MAC.129,   2-Feb-83 18:44:23 by MILLER
;TCO 6.1142. Some code clean ups. More to come...
; UPD ID= 1707, SNARK:<6.MONITOR>MEXEC.MAC.128,  27-Jan-83 20:06:53 by MILLER
;TCO 6.1094.CFS "get directory allocation".
; UPD ID= 1700, SNARK:<6.MONITOR>MEXEC.MAC.127,  26-Jan-83 14:25:30 by WEETON
;TCO 6.1401 - Fix ITRLGO BUGCHKs and WAITNI BUGHLTs
; UPD ID= 1680, SNARK:<6.MONITOR>MEXEC.MAC.126,  19-Jan-83 15:40:31 by MCINTEE
;TCO 6.1471 - MOVE SEBINI FROM EXEC0
; UPD ID= 1661, SNARK:<6.MONITOR>MEXEC.MAC.125,  15-Jan-83 16:45:12 by CHALL
;REMOVE RS(SWPMBP,1), WHICH IS DUPLICATED IN STG
; UPD ID= 1650, SNARK:<6.MONITOR>MEXEC.MAC.124,  13-Jan-83 17:10:37 by CHALL.WIZARD
;Add call to .NSPRS at SJLGO4 (to clean up NSP% DECnet lines for top fork)
; UPD ID= 1630, SNARK:<6.MONITOR>MEXEC.MAC.123,   7-Jan-83 12:39:46 by MCINTEE
;TCO 6.1445 - Monitor version number in SYSJOB.EXE
; UPD ID= 1619, SNARK:<6.MONITOR>MEXEC.MAC.122,   5-Jan-83 10:27:35 by HALL
;TCO 6.1000 and 6.1094
;	Fix code at RUNDE1 to set up context correctly for all processors
;	Clean up the comments a bit. Move JB0INT to be near CHKR
; UPD ID= 1615, SNARK:<6.MONITOR>MEXEC.MAC.121,   4-Jan-83 11:30:55 by MILLER
;TCO 6.1094. Set up MONBK for new CHKR fork
; UPD ID= 1550, SNARK:<6.MONITOR>MEXEC.MAC.120,  21-Dec-82 09:16:12 by MILLER
;TCO 6.1094. Enhance DDMP error code by creating routine DDMPER
; UPD ID= 1539, SNARK:<6.MONITOR>MEXEC.MAC.119,  20-Dec-82 17:27:55 by NICHOLS
;Add FTNSPSRV to distinguish between release 6.0 and 6.1
;Make SYSJOB.EXE into 6-1-SYSJOB.EXE for 6.1 monitors
;Add initialization of CTERM host and other DECnet-36 features
;TCO 6.1030 - DAPLGO added to logout code (McIntee)
; UPD ID= 1511, SNARK:<6.MONITOR>MEXEC.MAC.118,   2-Dec-82 15:17:55 by MOSER
;TCO 6.1110 - CHECK CHKAC ARGUMENT BLOCK LENGTH CORRECTLY
; UPD ID= 1491, SNARK:<6.MONITOR>MEXEC.MAC.117,  30-Nov-82 14:59:23 by MOSER
;TCO 6.1109 - LET CHKAC SUCCEED IF CONNECTED DIRECTORY WRONG BUT ACCESS OK
; UPD ID= 1490, SNARK:<6.MONITOR>MEXEC.MAC.116,  30-Nov-82 12:32:58 by HAUDEL
;More TCO 6.1357
; UPD ID= 1486, SNARK:<6.MONITOR>MEXEC.MAC.115,  29-Nov-82 14:19:55 by GRANT
;TCO 6.1010 - Remove EA.ENT at USGINI, startup runs totally in section 1 now
; UPD ID= 1479, SNARK:<6.MONITOR>MEXEC.MAC.114,  29-Nov-82 09:26:47 by GRANT
;TCO 6.1010 - In EXEC0, add call to MOVCST
; UPD ID= 1466, SNARK:<6.MONITOR>MEXEC.MAC.113,  18-Nov-82 13:59:16 by MOSER
;TCO 6.1380 - PREVENT HUNG JOBS AT LOGOUT
; UPD ID= 1461, SNARK:<6.MONITOR>MEXEC.MAC.112,  18-Nov-82 12:59:42 by MOSER
;TCO 6.1353 - PASS CORRECT ARGS TO ACJ FOR ATACH
; UPD ID= 1454, SNARK:<6.MONITOR>MEXEC.MAC.111,  17-Nov-82 14:15:54 by COBB
;TCO 5.1.1107 - Don't PUSH in STKVAR context at LDTACH+10 or so
; UPD ID= 1452, SNARK:<6.MONITOR>MEXEC.MAC.110,  17-Nov-82 08:23:57 by HAUDEL
;More TCO 6.1357
; UPD ID= 1432, SNARK:<6.MONITOR>MEXEC.MAC.109,  10-Nov-82 10:21:04 by HAUDEL
;TCO 6.1357 - CHANGE SHUTDOWN MESSAGE,ADD CTY MESSAGE
; UPD ID= 1430, SNARK:<6.MONITOR>MEXEC.MAC.108,   9-Nov-82 16:34:53 by WEETON
;Fix TCO 6.1344
; UPD ID= 1426, SNARK:<6.MONITOR>MEXEC.MAC.107,   8-Nov-82 13:52:49 by WEETON
;TCO 6.1344 - Allow enabled WHEEL or OPERATORs to load any program in top fork
; UPD ID= 1405, SNARK:<6.MONITOR>MEXEC.MAC.106,   3-Nov-82 07:00:12 by GRANT
;More TCO 6.1010 - Make RUNDD start in section 1, make USGINI run in section 1.
;Also, print out RUNNING DDMP sooner.
; UPD ID= 1400, SNARK:<6.MONITOR>MEXEC.MAC.105,   2-Nov-82 01:42:01 by CDUNN
;More TCO 6.1127 - Make KACCHG reflect the new keep alive scheme for the
;CI emulator
; UPD ID= 1397, SNARK:<6.MONITOR>MEXEC.MAC.104,   1-Nov-82 14:42:46 by LEACHE
;TCO 6.1342 Add MONVER
; UPD ID= 1386, SNARK:<6.MONITOR>MEXEC.MAC.103,  27-Oct-82 23:07:58 by CDUNN
;More TCO 6.1127 - Add further support for CI emulator keep alive
; UPD ID= 1379, SNARK:<6.MONITOR>MEXEC.MAC.102,  25-Oct-82 14:40:02 by MILLER
;TCO 6.1094. Create CFS section at system start up
; UPD ID= 1366, SNARK:<6.MONITOR>MEXEC.MAC.101,  22-Oct-82 03:52:48 by CDUNN
;More TCO 6.1127, add short routine to job init code to update the CI
;emulation keep alive boundries...
; UPD ID= 1348, SNARK:<6.MONITOR>MEXEC.MAC.99,  18-Oct-82 13:27:46 by COBB
;TCO 6.1315 - Clear CRJTTY after assignment to prevent 2 jobs on 1 tty bug
; UPD ID= 1345, SNARK:<6.MONITOR>MEXEC.MAC.98,  18-Oct-82 11:53:09 by MILLER
;TCO 6.1094. Enhance DDMPA some more
; UPD ID= 1335, SNARK:<6.MONITOR>MEXEC.MAC.97,  13-Oct-82 17:22:13 by MILLER
;Rerun DDMP right away if need be
; UPD ID= 1330, SNARK:<6.MONITOR>MEXEC.MAC.96,  12-Oct-82 17:50:23 by MILLER
;Restart DDMP soon if someone needed it while it was running
; UPD ID= 1301, SNARK:<6.MONITOR>MEXEC.MAC.95,   8-Oct-82 14:35:14 by MILLER
;Put DDMP in its own fork for CFS (TCO 6.1094)
; UPD ID= 1259, SNARK:<6.MONITOR>MEXEC.MAC.94,  29-Sep-82 20:20:00 by MILLER
;Make sure time is not negative
; UPD ID= 1251, SNARK:<6.MONITOR>MEXEC.MAC.93,  27-Sep-82 23:38:29 by MILLER
;Make sure job 0 wakes up in time to run DDMP
; UPD ID= 1247, SNARK:<6.MONITOR>MEXEC.MAC.92,  27-Sep-82 22:24:26 by MILLER
;CFS --  Fix DDMP restart
; UPD ID= 1240, SNARK:<6.MONITOR>MEXEC.MAC.91,  24-Sep-82 14:58:10 by MILLER
;Make DDMP retry wait a bit before trying again
; UPD ID= 1237, SNARK:<6.MONITOR>MEXEC.MAC.90,  24-Sep-82 12:27:19 by LEACHE
;TCO 6.1273 Add MS%ASG
; UPD ID= 1230, SNARK:<6.MONITOR>MEXEC.MAC.89,  24-Sep-82 11:48:26 by MOSER
;TCO 5.1614 MAKE CJ%ETF WORK WITH CJ%FIL.
; UPD ID= 1226, SNARK:<6.MONITOR>MEXEC.MAC.88,  23-Sep-82 23:44:50 by MILLER
;Handle failure from DDMP
; UPD ID= 1178, SNARK:<6.MONITOR>MEXEC.MAC.87,  14-Sep-82 11:07:46 by MOSER
;TCO 6.1264 - CORRECT ARGS TO ACJ AT JOBCF1
; UPD ID= 1159, SNARK:<6.MONITOR>MEXEC.MAC.86,  10-Sep-82 13:30:19 by MILLER
;tco 6.1259. Make JOBCOF go to FLOGO whnever it wants to LOGOUT
; UPD ID= 1151, SNARK:<6.MONITOR>MEXEC.MAC.85,   7-Sep-82 11:10:27 by MILLER
;TCO 6.1255. Suppress start-up dialog if DBUGSW = 3
; UPD ID= 1139, SNARK:<6.MONITOR>MEXEC.MAC.84,   3-Sep-82 15:13:55 by MCINTEE
;More TCO 6.1184 - Eliminate unwanted OKSKED from ATACH code
; UPD ID= 1097, SNARK:<6.MONITOR>MEXEC.MAC.83,  19-Aug-82 13:36:37 by MCINTEE
;TCO 6.1030 - Add call to DAPLGO during logout
; UPD ID= 1075, SNARK:<6.MONITOR>MEXEC.MAC.82,  10-Aug-82 14:19:26 by LEACHE
;TCO 6.1223 - Make "WHY RELOAD" accept a lowercase answer.
; UPD ID= 1009, SNARK:<6.MONITOR>MEXEC.MAC.81,  28-Jul-82 08:21:04 by COBB
;MORE TCO 6.1193 - Fix typo in previous edit...
; UPD ID= 1008, SNARK:<6.MONITOR>MEXEC.MAC.80,  27-Jul-82 15:19:05 by COBB
;TCO 6.1193 - ZERO out count of NOSKED p-faults after startup complete AND...
;TCO 6.1194 - Add call to ENQFKR when killing top fork to release ENQ locks
; UPD ID= 984, SNARK:<6.MONITOR>MEXEC.MAC.79,  12-Jul-82 13:52:05 by CDUNN
;TCO 6.1184 Fix ATACH JSYS to allow attach to terminal assigned by calling job
; UPD ID= 980, SNARK:<6.MONITOR>MEXEC.MAC.78,   7-Jul-82 16:16:30 by COBB
;TCO 6.1183 - Change SYSTEM:EXEC.EXE to DEFAULT-EXEC:
; UPD ID= 859, SNARK:<6.MONITOR>MEXEC.MAC.77,   7-Jun-82 09:39:33 by MURPHY
;TCO 6.1147 - Move bugdefs from BUGS.MAC to here and put them in-line.
; UPD ID= 779, SNARK:<6.MONITOR>MEXEC.MAC.76,  24-May-82 09:12:23 by HALL
;TCO 6.1144 - REMOVE "BLT SWAPPABLE MONITOR"
; UPD ID= 777, SNARK:<6.MONITOR>MEXEC.MAC.75,  21-May-82 11:41:57 by CDUNN
;TCO 6.1127 - Add code to call CISRV for a periodic check from job 0.
; UPD ID= 763, SNARK:<6.MONITOR>MEXEC.MAC.74,  19-May-82 10:09:54 by MILLER
;;TCO 6.1142. Send system messages to ORION
; UPD ID= 719, SNARK:<6.MONITOR>MEXEC.MAC.73,  11-May-82 02:15:55 by CDUNN
;More TCO 6.127 - Add free space assurance for SCA in CHKR routine
; UPD ID= 707, SNARK:<6.MONITOR>MEXEC.MAC.72,   9-May-82 13:02:19 by HALL
;TCO 6.1000- Support the 2080
;	Make flags word for user mode include user AC block (EXEC0, EXECI1,
;		EXBUGH, HSYS4, EXPAL0, JOBCOF
;	At EXECI, preserve full word of flags instead of left half only
;	Make CHKR use XJRST to get to section 1
; UPD ID= 540, SNARK:<6.MONITOR>MEXEC.MAC.71,  20-Mar-82 19:42:50 by PAETZOLD
;TCO 5.1766 - Turn on FH%EPN in PMAP call in SJLGO4.  PM%EPN does not work.
; UPD ID= 471, SNARK:<6.MONITOR>MEXEC.MAC.70,  12-Mar-82 14:41:32 by PAETZOLD
;TCO 5.1753 - Turn on PM%EPN in PMAP call in logout code.  Prevents PAGLCKs
; UPD ID= 433, SNARK:<6.MONITOR>MEXEC.MAC.69,   4-Mar-82 13:59:51 by MURPHY
;TCO 5.1744 - Refers to changes made approx June, 1980.  Make default
;  settings of system messages more like release 4.
; UPD ID= 379, SNARK:<6.MONITOR>MEXEC.MAC.68,   4-Feb-82 09:55:41 by HALL
;TCO 6.1000 - Support the 2080
;	Remove call to KDPINI. Don't need it now that KS isn't supported
; UPD ID= 347, SNARK:<6.MONITOR>MEXEC.MAC.67,  24-Jan-82 23:50:20 by MURPHY
;TCO 5.1697 - XSSEV%, etc.  Move GETPAT and GETDMS to FORK.MAC
; UPD ID= 313, SNARK:<6.MONITOR>MEXEC.MAC.66,  18-Jan-82 10:50:17 by MILLER
; UPD ID= 407, SNARK:<5.MONITOR>MEXEC.MAC.64,  18-Jan-82 10:37:36 by MILLER
;TCO 5.1678 again. Enhance check in ATACH for specific TTY designator
; UPD ID= 305, SNARK:<6.MONITOR>MEXEC.MAC.65,  15-Jan-82 16:27:34 by MILLER
;More TCO 5.1678. Check for same job number
; UPD ID= 302, SNARK:<6.MONITOR>MEXEC.MAC.64,  15-Jan-82 14:04:49 by MILLER
;TCO 5.1678. Make detach of object job in ATACH race-free.
; UPD ID= 386, SNARK:<5.MONITOR>MEXEC.MAC.60,   9-Jan-82 18:30:36 by MILLER
;TCO 5.1661. Unlatch MOS cotrollers after TGHA runs
;MORE OF TCO 6.1054
; UPD ID= 278, SNARK:<6.MONITOR>MEXEC.MAC.61,   6-Jan-82 10:11:09 by MILLER
;TCO 6.1054. ADD GTOKM IN ATTACH.
; UPD ID= 191, SNARK:<6.MONITOR>MEXEC.MAC.60,   6-Nov-81 13:39:04 by MURPHY
;Make monitor forks start in section 1
; UPD ID= 162, SNARK:<6.MONITOR>MEXEC.MAC.59,  23-Oct-81 15:23:34 by COBB
; UPD ID= 247, SNARK:<5.MONITOR>MEXEC.MAC.58,   6-Oct-81 15:21:24 by MOSER
;MORE TCO 5.1512 FIX A BUG.
; UPD ID= 222, SNARK:<5.MONITOR>MEXEC.MAC.57,  28-Sep-81 16:20:34 by PAETZOLD
;TCO 5.1544 - CORRECT CALCULATION FOR UPPER LIMIT OF VBOOT GROUP IN GSMDSK
; UPD ID= 209, SNARK:<5.MONITOR>MEXEC.MAC.56,  23-Sep-81 13:41:05 by MURPHY
;DITTO
; UPD ID= 187, SNARK:<5.MONITOR>MEXEC.MAC.55,  16-Sep-81 17:50:34 by MURPHY
;TCO 5.1514 - Start SYSERR fork earlier in RUNDD so messages from FE don't pile up.
; UPD ID= 184, SNARK:<5.MONITOR>MEXEC.MAC.54,  16-Sep-81 12:09:35 by SCHMITT
;More TCO 4.1051 - Remove definition of USGMUP, it is in STG
; UPD ID= 182, SNARK:<5.MONITOR>MEXEC.MAC.53,  15-Sep-81 16:51:13 by SCHMITT
;TCO 4.1.1051 - Make system restart entry include Monitor uptime
; UPD ID= 179, SNARK:<5.MONITOR>MEXEC.MAC.52,  15-Sep-81 16:26:04 by MOSER
;TCO 5.1512 ADD SE1ENT TO JOBCOF.
; UPD ID= 134, SNARK:<5.MONITOR>MEXEC.MAC.51,   1-Sep-81 16:22:40 by GRANT
;Fix the check for DETACHed before CALL TTHNGU in LOG1 - dataset line was not
;being hung up if user was not logged in
; UPD ID= 57, SNARK:<5.MONITOR>MEXEC.MAC.50,  21-Jul-81 15:22:56 by GRANT
;Change "PS:" to "system structure"
;TCO 5.1375 - Fix bugs in ATACH JSYS
; UPD ID= 19, SNARK:<5.MONITOR>MEXEC.MAC.49,  12-Jul-81 15:44:27 by PAETZOLD
;Replace .FHSLF with .TTDES at DETMS3+3
; UPD ID= 18, SNARK:<5.MONITOR>MEXEC.MAC.48,  11-Jul-81 17:45:10 by PAETZOLD
;TCO 5.1407 - Make sure we dont ask to lock more memory than is on
; replacable queue in GSMD2
; UPD ID= 2289, SNARK:<5.MONITOR>MEXEC.MAC.47,   2-Jul-81 13:36:37 by PAETZOLD
;TCO 5.1393 - Change reference of BUGINT from immediate to full word
; UPD ID= 2265, SNARK:<5.MONITOR>MEXEC.MAC.46,  26-Jun-81 18:07:46 by MURPHY
;TCO 5.1376 - JOBCOF, FLOGO, FRKNOP
; UPD ID= 2125, SNARK:<5.MONITOR>MEXEC.MAC.45,   4-Jun-81 10:11:31 by GRANT
;Make sure all 23 bits of address get returned in GETSEG
; UPD ID= 2069, SNARK:<5.MONITOR>MEXEC.MAC.44,  22-May-81 16:48:23 by ZIMA
;TCO 5.1344 - Correct ATACH and DTACH privilege checking for batch jobs.
; UPD ID= 2056, SNARK:<5.MONITOR>MEXEC.MAC.43,  21-May-81 10:46:10 by SCHMITT
;More of TCO 5.1308
; UPD ID= 1967, SNARK:<5.MONITOR>MEXEC.MAC.42,   8-May-81 14:24:43 by SCHMITT
;More of TCO 5.1308 - Check for system shutdown in CHKR loop
; UPD ID= 1941, SNARK:<5.MONITOR>MEXEC.MAC.41,   5-May-81 17:06:32 by SCHMITT
;TCO 5.1308 - Latch HSYST1 to -1 when system shutdown
; UPD ID= 1921, SNARK:<5.MONITOR>MEXEC.MAC.40,   1-May-81 11:33:52 by PAETZOLD
;TCO 5.1301 add SCOUNT to GETAB tables, also bump SCOUNT in SETSN
; UPD ID= 1910, SNARK:<5.MONITOR>MEXEC.MAC.39,  30-Apr-81 16:29:05 by CHALL
;Inform the victim of a LOGOUT about the killer and his terminal
; UPD ID= 1817, SNARK:<5.MONITOR>MEXEC.MAC.38,  17-Apr-81 09:42:10 by WACHS
;TCO 5.1287 Restrict the possible answers to Why Reload question
; UPD ID= 1778, SNARK:<5.MONITOR>MEXEC.MAC.37,  31-Mar-81 17:43:13 by MURPHY
;Default is shutdown messages at 5 and 1 min
; UPD ID= 1719, SNARK:<5.MONITOR>MEXEC.MAC.36,  16-Mar-81 16:37:05 by MURPHY
;Add "PS:" to system expunge message
; UPD ID= 1569, SNARK:<5.MONITOR>MEXEC.MAC.35,  19-Feb-81 14:07:50 by HALL
;TCO 5.1180 - Move DST to non-zero section
; Fix EXEC0 so that it can run in section 1, because call to SETMPG
;  can get to GDSTX
; BSRAD - Use extra stack location and avoid clobbering PC
; GOTSWM - Change BLT to initialize SYSFK table
; UPD ID= 1496, SNARK:<5.MONITOR>MEXEC.MAC.34,  26-Jan-81 13:25:47 by ENGEL
;GET RID OF THE LCS CALLS. NOT PART OF NEXT RELEASE ANYMORE
; UPD ID= 1485, SNARK:<5.MONITOR>MEXEC.MAC.33,  24-Jan-81 23:20:07 by ZIMA
;TCO 5.1240 - Fix connect time calculation in CPGCON checkpoint routine.
; UPD ID= 1479, SNARK:<5.MONITOR>MEXEC.MAC.32,  22-Jan-81 12:37:41 by ZIMA
;TCO 5.1238 - expunge properly on logout.
; UPD ID= 1292, SNARK:<5.MONITOR>MEXEC.MAC.31,  18-Nov-80 18:11:05 by MURPHY
;FIX BUG IN JOBCOF - MAKE DETACH HAPPEN BEFORE LOGOUT
; UPD ID= 1286, SNARK:<5.MONITOR>MEXEC.MAC.30,  18-Nov-80 14:40:13 by OSMAN
; UPD ID= 1248, SNARK:<5.MONITOR>MEXEC.MAC.29,   7-Nov-80 15:01:32 by SCHMITT
;TCO 5.1194 - Fix code at USGIN7 to not cause CHKPNT errors
; UPD ID= 1221, SNARK:<5.MONITOR>MEXEC.MAC.28,   2-Nov-80 11:48:37 by HALL
;TCO 5.1180 - MOVE THE DST TO NON-ZERO SECTION
;	CHKR - RUN IN SECTION 1
;	GSMDX - RUN IN SECTION 1
;tco 5.1189 - Make entry vector two words
; UPD ID= 1221, SNARK:<5.MONITOR>MEXEC.MAC.28,   2-Nov-80 11:48:37 by HALL
;TCO 5.1180 - MOVE THE DST TO NON-ZERO SECTION
;	CHKR - RUN IN SECTION 1
;	GSMDX - RUN IN SECTION 1
; UPD ID= 1143, SNARK:<5.MONITOR>MEXEC.MAC.27,   8-Oct-80 15:14:08 by MURPHY
;BUG IN JOBCOF
; UPD ID= 1103, SNARK:<5.MONITOR>MEXEC.MAC.26,   2-Oct-80 09:28:08 by MURPHY
;DITTO
; UPD ID= 1081, SNARK:<5.MONITOR>MEXEC.MAC.25,   1-Oct-80 11:53:31 by MURPHY
;FIX ACVAR, ETC.
; UPD ID= 975, SNARK:<5.MONITOR>MEXEC.MAC.24,  29-Aug-80 08:41:47 by ENGEL
;ADD LCS INITIALIZATION CALL
; UPD ID= 972, SNARK:<5.MONITOR>MEXEC.MAC.23,  25-Aug-80 16:53:39 by HALL
;TCO 5.1139 - ADD FAILING PC AND LSTERR TO OUTPUT WHEN FORK 0 CRASHES
; UPD ID= 965, SNARK:<5.MONITOR>MEXEC.MAC.22,  25-Aug-80 16:28:07 by ENGEL
;TCO 5.1136 - ADD DEVLKK
; UPD ID= 932, SNARK:<5.MONITOR>MEXEC.MAC.21,  20-Aug-80 14:59:31 by LYONS
;TCO 5.1062 WRITE VERIFICATION ON WRITE FOR DISKS
; UPD ID= 841, SNARK:<5.MONITOR>MEXEC.MAC.20,   5-Aug-80 16:20:06 by OSMAN
;tco 5.1109 - Add PDV support to SSAVE and GET
; UPD ID= 812, SNARK:<5.MONITOR>MEXEC.MAC.19,  30-Jul-80 11:03:46 by MURPHY
;WEFLAG - DON'T WRITE-PROTECT MONITOR IF NON-0
; UPD ID= 789, SNARK:<5.MONITOR>MEXEC.MAC.18,  23-Jul-80 17:20:10 by R.ACE
;TCO 5.1112 - REMOVE VESTIGIAL "MOVE T1,FORKX" AT JOBCF1+2
; UPD ID= 747, SNARK:<5.MONITOR>MEXEC.MAC.17,   8-Jul-80 17:50:12 by HALL
;FIX LYONS' EDIT TO CHKUM1
; UPD ID= 723, SNARK:<5.MONITOR>MEXEC.MAC.15,   2-Jul-80 11:28:18 by LYONS
;Fix ILMNRF in SAVE% JSYS by maping read only page to non-existant page
; with no access, and fooling SAVEB1 into thinking page is really there
;Fix missing checks for tty detached when we get CTRLTT in LOG1
;Fix time race in CHKUM1 that can cause J0NRUN
;Fix reason why system down as told to IMP
;Fix CTY login after ^ECEASE if it was prohibited before
;ARPAnet can cause UPDL overflows if user in JSYS which locks tty data
;A job with PSI for carrier off does not get it until reattach time.
; UPD ID= 703, SNARK:<5.MONITOR>MEXEC.MAC.14,  26-Jun-80 09:52:06 by LYONS
;Add code to call ACJ on an implicit logout (i.e. thru a hangup of a dataset)
; UPD ID= 700, SNARK:<5.MONITOR>MEXEC.MAC.13,  25-Jun-80 17:26:40 by MURPHY
;FIRST SHUTDOWN MESSAGE CONTROLLED BY SF%MS1
; UPD ID= 698, SNARK:<5.MONITOR>MEXEC.MAC.12,  25-Jun-80 17:05:46 by GRADY
;TCO 5.1079 - FIX RACE AT LDTAC2, BUT UNLOKK DEVLKK AND GO OKINT TOO.
; UPD ID= 666, SNARK:<5.MONITOR>MEXEC.MAC.10,  16-Jun-80 19:06:25 by LYONS
;FIX RACE AT LDTAC2, WHERE CTRLTT MAY NOT BE RIGHT
; UPD ID= 662, SNARK:<5.MONITOR>MEXEC.MAC.9,  16-Jun-80 17:23:27 by KONEN
;TCO 5.1063 - REMOVE PS: AS NAME OF PRIMARY STRUCTURE
; UPD ID= 597, SNARK:<5.MONITOR>MEXEC.MAC.8,   3-Jun-80 17:45:02 by MURPHY
;FACTSW BITS TO CONTROL SYSTEM MESSAGES
; UPD ID= 498, SNARK:<5.MONITOR>MEXEC.MAC.7,  30-Apr-80 15:06:35 by GRANT
;TCO 5.1030 - Add description to ?FULL
; UPD ID= 468, SNARK:<5.MONITOR>MEXEC.MAC.6,  23-Apr-80 15:52:58 by LYONS
;pushed literals as PC dont allow for non zero sections
; UPD ID= 445, SNARK:<5.MONITOR>MEXEC.MAC.5,  15-Apr-80 11:01:18 by HALL
;MOVE LOGDES AND JB0TT INTO RSDAT
; UPD ID= 401, SNARK:<5.MONITOR>MEXEC.MAC.4,   2-Apr-80 15:52:50 by HALL
;FIX LOWER CASE IN PREVIOUS EDIT
; UPD ID= 394, SNARK:<5.MONITOR>MEXEC.MAC.3,   1-Apr-80 15:44:01 by HALL
;MAKE JB0TT AND USGMUP BE PART OF RSVAR PSECT
; UPD ID= 374, SNARK:<5.MONITOR>MEXEC.MAC.2,  26-Mar-80 13:36:09 by ENGEL
;STOP EDDT SYMBOL FROM PRINTING
; UPD ID= 288, SNARK:<4.1.MONITOR>MEXEC.MAC.447,  21-Feb-80 10:58:17 by MURPHY
;NEW FKINT DEFS
; UPD ID= 266, SNARK:<4.1.MONITOR>MEXEC.MAC.446,  15-Feb-80 17:39:58 by MURPHY
;PROPER LENGTH FOR QTIMES TABLE IN GETAB
; UPD ID= 240, SNARK:<4.1.MONITOR>MEXEC.MAC.445,   1-Feb-80 14:40:27 by ENGEL
; UPD ID= 110, SNARK:<4.1.MONITOR>MEXEC.MAC.444,   7-Dec-79 16:30:00 by SCHMITT
;TCO 4.1.1051 - CALC. MONITR UPTIME IN SEC AND GIVE TO USAGE JSYS FOR RESTART
; UPD ID= 106, SNARK:<4.1.MONITOR>MEXEC.MAC.443,   7-Dec-79 09:34:57 by R.ACE
;TCO 4.2591 - SECTION-0 PAGE TABLE SHARE COUNT PROBLEM FROM SSAVE
;ADD ERJMP AFTER SOUT IN LITERAL AFTER SSAVB4
; UPD ID= 91, SNARK:<4.1.MONITOR>MEXEC.MAC.442,   5-Dec-79 09:13:00 by OSMAN
;tco 4.1.1044 - Make EXEC command in mini-exec do implicit RESET
;<4.1.MONITOR>MEXEC.MAC.441, 16-Nov-79 13:47:41, EDIT BY MILLER
;PREVIOUS CHANGES UNDER TCO 4.1.1021
;<4.1.MONITOR>MEXEC.MAC.440, 16-Nov-79 13:00:38, EDIT BY MILLER
;ADD TTFSMS BUGINF
;<4.1.MONITOR>MEXEC.MAC.439, 16-Nov-79 11:46:24, EDIT BY MILLER
;CHANGE ALLMSG TO TIME-OUT TTMSG



;THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY  BE  USED
;OR COPIED ONLY IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
;COPYRIGHT  (C)  DIGITAL  EQUIPMENT  CORPORATION  1976, 1985.
;ALL RIGHTS RESERVED.


	SEARCH MONSYM,PROLOG,SERCOD,ACTSYM
	TTITLE MEXEC

	EXTN <BRDTIM,DDMPF,MOSULE,HNGU0F,HNGU1F,BUGTL>

	IFNDEF FTKLIPA,<FTKLIPA==-1> ;Default is include KLIPA support code
	IFNDEF FTMSCP,<FTMSCP==0>   ;Default is no MSCP

IFN <FTKLIPA!FTMSCP>,<EXTERN SC.RAP,SCSLGO>
;**; [7173] Change 1 line at TTITLE+5	HMP	23-Oct-85
IFE FTNSPSRV,<EXTERN LLMRJB,LLMINI> ;[7173] ~6.0 Defined in LLMOP
	EXTERN FSPINI

;SWAPPABLE MONITOR ROUTINES, JSYS'S, ETC. - D. MURPHY

;AC DEFINITIONS USED HEREIN

DEFAC (FX,Q3)			;FORK INDEX

;NOTE: THE NEXT TWO LOCATIONS MUST BE TOGETHER. GETAB REQUIRES IT

RSI LOGDES,LOGTTY		;DESIGNATOR FOR LOG MSGS - DEF IN PARAMS
RSI JB0TT,0			;DESIG FOR JOB 0 AND ERR MSGS

MICHN==:1B34+1B35		;CHANNELS THAT MONITOR ENABLES
EXWTIM==:^D120			;NUMBER MINUTES BETWEEN AUTO EXPUNGES

	SWAPCD

;LINKAGE TO MDDT

MDDT=:<MSEC1,,LMDDT>		;SO MDDT$G ALWAYS GOES TO KNOWN SECTION
LMDDT::	XJRST MDDTP		;BE SURE TO CHANGE SECTIONS
  IFN FTNSPSRV < ;[6.0]
MDDTP::	SYMSEC,,MDDTX		;IN SYMBOL SECTION
  >
  IFE FTNSPSRV < ;[6.1]
MDDTP:: MDDTX			;MDDTX has section # in 6.1
  >

;REGULAR SUBSYSTEM NAMES FOR INCLUSION IN SNAMES TABLE AT STARTUP

SBSNMS:	SIXBIT /EXEC/
	SIXBIT /(PRIV)/
NSBSNM==.-SBSNMS

;TABLE DEFINES SPECIAL PURPOSE FOR FIRST FEW JOBS

SPECJT:	MSEC1,,RUNDD		;JOB 0 IS ALWAYS DISK CHECKER, ETC.

NSPECJ==.-SPECJT		;NUMBER OF SPECIAL JOBS

	RESCD

;CODE TO INITIALIZE JOB ON FIRST STARTUP.  ALSO INVOKES SYSTEM
;INITIALIZATION IF FIRST JOB AFTER SYSTEM STARTED FROM SCRATCH
;SYSIFG IS 0 WHEN SYSTEM IS JUST STARTING

EXEC0::	MOVX 1,LOGIOB		;SAY JOB CREATION IN PROGRESS
	IORM 1,JOBBIT
	SETZM FPC
	MOVX 1,USRCTX		;SIMULATE CALL FROM USER
	MOVEM 1,FFL
	MCENTR
	SKIPE SYSIFG		;NEW SYSTEM?
	JRST GOTSWM		;NO
	MOVEI T1,MFRKWD		;GET SPECIAL PRIORITY FOR MONITOR FORKS
	MOVEM T1,JOBSKD		;AND SET THIS JOB AS SUCH
	CALL FSIINI		;GO MOUNT THE PUBLIC STRUCTURE
	CALL SWPINI		;SWAPPER CAN NOW BE INITIALIZED
				;IT MUST BE CALLED AFTER NSSUN AND
				;  THE SDB FOR PS ARE SET UP BY FSIINI
	MOVEI T1,PSNUM		;T1/ STRUCTURE NUMBER (PUBLIC STRUCTURE)
	MOVEI T2,HOMPGA		;T2/ ADDRESS OF PAGE TO USE FOR BAT BLOCKS
	MOVX T3,MI%MSG		;T3/ FLAGS TO TELL OPERATOR, FIX INCONSISTENT
	CALL CHKBAT		;AND NOW THE BAT BLOCKS CAN BE CHECKED
				; AND THE OVERFLOW SWAPPING ADDRESSES
				; IN THE BAT BLOCKS PROCESSED

GETSWM::
;   IFN CFSCOD,<
	CALL CFSCSC		 ;First, create CFS data section
;   >
	SETOM SWPMLF		; INIT COUNT OF LOCKERS OF SWP MON
	SKIPN EDDTF		;KEEP EDDT?
	CALL ULKINI		;NO, UNLOCK IT
	SKIPE SMLKF		;KEEP SWPMON LOCKED?
	CALL SWPMLK		;YES, RE-LOCK IT
	CALL MOVNRC		;MAKE SWPMON (NRCOD) BE IN SEC 1 ONLY

	CALL RESLCK		;LOCK DOWN SOME RESIDENT FREE SPACE
	SKIPE VSMFLG		;SWAP MONITOR NEED TO BE FORCED OUT TO DISK?
	JRST [	SETOM SKEDFC	;YES, FORCE IT ALL TO HAPPEN
		MOVEI T1,1000	;1 SECOND OF SLEEP TIME
		DISMS		;SHOULD BE LONG ENOUGH FOR THE SWAPABLE
				;MONITOR TO GET OUT, WITH OUT ANY PROBLEMS.
		SETZM VSMFLG	;STOP FORCING DATA VERIFICATION
		SETZM SKEDFC	;MAKE SURE WE DONT SPEND EXTRA TIME SWAPPING, TOO
		JRST .+1]	;BACK TO THE MAIL LINE CODE

;AT THIS POINT THE SWAPPABLE MONITOR HAS BEEN LOADED.  IF THE MONITOR WAS
;STARTED AT 144, IT HAS ALSO BEEN SWAPPED OUT TO THE DISK.
; IF IT IS DESIRABLE TO PATCH THE SWAPPABLE MONITOR A BREAKPOINT CAN
; BE PUT HERE.  NO PART OF THE SWAPPABLE MONITOR WILL HAVE BEEN EXECUTED YET.

;INITIALIZE THE FORK STRUCTURE FOR THIS JOB. ASSIGN FIRST WORD OF FKPTRS
;AND SYSFK TO THIS FORK. MAKE EACH REMAINING WORD OF FKPTRS POINT TO NEXT
;AVAILABLE SLOT AND FREJFK POINT TO THE FIRST AVAILABLE SLOT
;INITIALIZE REMAINING WORDS OF SYSFK TO -1

GOTSWM:	MOVEI 1,FKPTRS		;1/NAME OF FORK STRUCTURE LIST
	MOVEI 2,NUFKS		;2/NUMBER OF WORDS IN LIST
	CALL ILIST		;INITIALIZE FREE WORDS IN FKPTRS
	MOVE 1,0(1)		;POINT TO SECOND FREE SLOT
	MOVEM 1,FREJFK		;MAKE FREE LIST START WITH SECOND SLOT
	SETZM FKPTRS		;TAKE FIRST SLOT FO THIS FORK
	MOVE 1,FORKX		;GET SYSTEM-WIDE INDEX FOR THIS FORK
	HRRZM 1,SYSFK		;STORE IN JOB STORAGE AREA
				;Note that this clears all the flag bits
				; (defined in FORK) in LH of SYSFK
	MOVEI T1,NUFKS-2	;T1/ NUMBER OF WORDS TO COPY
	MOVEI T2,SYSFK+1	;T2/ STARTING SOURCE WORD
	SETOM (T2)		;INITIALIZE IT TO -1
	MOVEI T3,1(T2)		;T3/ STARTING DESTINATION WORD
	CALL XBLTA		;INITIALIZE BLOCK TO -1 (EXCEPT FIRST WORD)
	MOVE T1,[JTBIFR]	; Initialize JTB free bit table
	MOVEM T1,JTBFRE		;  ..
	SETOM FKLOCK		;INIT FORK LOCK FOR THIS JOB
	SETZM FLKCNT		;CLEAR NEST COUNT
	SETOM FLKOWN		;CLEAR OWNING FORK

;SET UP FOR INTERRUPTS TO BE PROCESSED BY THE MONITOR
;IF AN INTERRUPT OCCURS ON A CHANNEL WHOSE BIT IS SET IN MONCHN,
;THE MONITOR WILL GO TO EXECI
;CHANNELS 34 AND 35 ARE ACTIVATED HERE, AND CTRL/P IS ASSIGNED
;TO THEM IN THE MINI-EXEC

	SETOM TTJTIW
	MOVE 1,[XWD MSEC1,EXECI] ;GO TO EXECI ON INTERRUPT
	CALL MONBKX
	MOVE T1,FORKN		;GET RELATIVE FORK NUMBER
	CALL SETVGN		;AND RESTORE VIRGINITY

	JRST JBI0		;CONTINUE IN SWAPPABLE CODE

;JOB INITIALIZATION...
;SYSIFG IS 0 IF SYSTEM IS BEING STARTED

RSI SPJCAP,<SC%CTC!SC%GTB!SC%LOG!SC%SCT!SC%SUP!SC%WHL!SC%OPR!SC%CNF!SC%MNT!SC%IPC!SC%ENQ!SC%NWZ!SC%NAS!SC%DNA!SC%ANA> ;SPECIAL JOB CAPS

	SWAPCD

JBI0:	CALL JBFINI		;INIT FILE SYS FOR THIS JOB
	SKIPE SYSIFG		;SYSTEM INITIALIZED?
	JRST SYSINE		;YES

;SYSTEM IS BEING STARTED. DO ONCE-ONLY INITIALIZATION

	MOVE T1,SPJCAP		;GET SPECIAL JOB CAPS
	MOVEM T1,CAPENB		;ENABLE ALL CAPABILITIES FOR INITIALIZATION
	MOVEM T1,CAPMSK		;HERE TOO
	
	;*****TEMP*****
	EXTERN SWFREE,SWOPTL,SWFREL
	MOVE T1,[SWFREE,,SWFREE+1]
	SETZM SWFREE		;ZERO THE FREE POOL
	BLT T1,SWFREE+SWFREL-1	;...
	MOVEI T1,SWFREE		;GET ADR OF FREE POOL
	HRLOM T1,SWPFRE		;INITIALIZE POINTER TO FREE BLOCK
	MOVEI T1,SWFREL		;GET LENGTH OF FREE AREA
	HRRZM T1,SWFREE		;MAKE IT ONE LARGE BLOCK
	MOVEM T1,SWPFRE+2	;STORE IN SPACE COUNTER
	SETOM SWPFRE+1		;INITIALIZE LOCK ON FREE STORE
	MOVE T1,[XWD SWFREE+SWFREL,SWFREE]
	MOVEM T1,SWPFRE+4	;SET UP TOP AND BOTTOM POINTERS
	MOVEI T1,SWOPTL		;GET OPTIMUM LENGTH OF MESSAGES
	MOVEM T1,SWPFRE+3	;SAVE IN HEADER BLOCK

	;*****TEMP*****
	CALL FSPINI		;Initialize swappable free space

	SETOM FGLOCK		;INIT FAST GET LOCK
	SETOM SYLNLK		;INIT SYSTEM LOGICAL NAME LOCK
	SETOM CRJLCK		;INIT LOCK OF CRJOB DATA BASE
	CALL FILINI		;INIT FILE SYSTEM
	SETOM GOKLCK		;INIT GETOK LOCK
	SETOM TIMLCK		;INIT LOCK ON TIMER Q'S
	MOVEI T1,0
      DO.
	MOVE T2,SBSNMS(T1)	;MOVE REGULAR SUBSYSTEM NAMES TO TABLE
	MOVEM T2,@[EP. SNAMES(T1)]
	CAIGE T1,NSBSNM-1
	AOJA T1,TOP.
      ENDDO.
	MOVNI 1,NSBSNM		;INIT TABLE POINTER WITH NEG COUNT
	MOVEM 1,SNMPT
	SETOM SNMLCK		;AND INIT LOCK
	MOVE T1,[JOBONT,,JOBONT+1]
	SETOM JOBONT		;NO JOBS ARE YET OWNED BY ANYONE
	BLT T1,JOBONT+NJOBS-1	; ..
	CALL PIDINI		;INITIALIZE THE IPCF DATA BASE AND FORKS
	CALL SLNINI		;INITIALIZE SYSTEM LOGICAL NAMES
	SETOM UTLOCK		;INITIALIZE THE UTEST JSYS DATA BASE
	CALL GETNAM		;INITIALIZE STRING CONTAINING
				; MONITOR VERSION AND NAME
IFN FTNSPSRV,CALL NAMINI        ;INITIALIZE NODE NAME TO "TOPS20", IF DECNET
	MOVEI T1,TMZONE		;INITIALIZE TIMZON
	MOVEM T1,TIMZON
	SETOM ACTLCK		;INITIALIZE LOCK ON ACCT WINDOW PAGES
	SETOM ACTOFN		;NO OFN FOR ACCT VALIDATION DATA FILE YET
	SETOM AVALON		;ALWAYS TURN ON ACCT VALIDATION TILL STATED OTHERWISE
	; ..

;JOB INITIALIZATION...
;THIS CODE IS REACHED FOR ALL JOBS, INCLUDING FIRST ONE AFTER SYSTEM
;STARTUP

SYSINE:	MOVE T1,JOBNO		;GET OUR LOCAL JOB INDEX
	CALL JBGET1		;ASK CFS FOR A GLOBAL JOB NUMBER
	 IFNSK.			;IF NO SKIP, WE HAVE NO MORE JOBS LEFT
	  TMSG <
?No Global Job slots available.
>				;TELL THE USER WHY HE'S GETTING...
	  JRST FLOGO1		; LOGGED OUT.
	 ELSE.			;OTHERWISE
	  MOVEM T1,GBLJNO	;SAVE THE GLOBAL JOB NUMBER HERE (JSB)
	 ENDIF.			;
	MOVE T1,JOBNO		;INITIALIZE THE PID QUOTA
	CALL PIDJBI		;  AND SEND QUOTA
	CALL ENQJBI		;INITIALIZE ENQ/DEQ QUOTA
	MOVE T1,JOBNO		;GET JOB NUMBER
	SETZM CRJFLG		;ASSUME NOT A CREATE-JOB STARTUP
	HLRZ T2,JOBPT(T1)	;CHECK FOR SPECIAL STARTUP FLAG
	CAIE T2,-2		;FROM CRJOB?
	JRST SYSIN1		;NO. NORMAL STARTUP.
	MOVE T2,CRJTTY		;CRJOB. HERE IS THE REQUESTED TTY.
	HRLM T2,JOBPT(T1)	;PUT IT IN JOBPT OF NEW JOB.
	MOVEM T2,CTRLTT		;AND IN THE JSB
	SETOM CRJFLG		;FLAG IN JSB THIS IS A CRJOB STARTUP
SYSIN1:	JUMPL T2,SYSIN2		;JUMP IF JOB IS DETACHED
	CALL TTYASN		;ASSIGN CONTROLLING TTY
	 JRST SYSIN9
	SKIPGE CRJFLG		;CRJOB STARTUP??
	SETOM CRJTTY		; YES, CRJOB TTY IS NO LONGER SPECIAL
	MOVE T2,CTRLTT		;GET TTY NUMBER
	CALL TTCKSP		;GO SEE IF SPEED SETTING NEEDED
SYSIN2:	MOVE T1,TODCLK
	MOVEM T1,CONSTO		;SET CONSOLE TIME ON
	CALL LGTAD
	MOVEM T1,CTIMON		;SET DATE/TIME CONNECT
	SETZM JSSRTM		;Reset session runtime
	SETZM JSSCTM		; and session console time
	MOVE T1,[OURNAM,,LLSR]	;BLT POINTER TO INITIALIZE NODE NAME
	BLT T1,LLSR+WPN-1	;MAKE JOB'S NODE NAME BE OUR LOCAL NAME
	MOVX T1,LOGIOB		;SAY JOB CREATION FINISHED
	ANDCAM T1,JOBBIT


;JOBS 0 THROUGH NSPECJ-1 ARE SPECIAL. SPECJT CONTAINS ADDRESS TO WHICH
;TO TRANSFER. FOR NOW, ONLY JOB 0 IS SPECIAL, AND IT GOES TO RUNDD.
;SEE IF THIS IS A SPECIAL JOB

NOTJB0:	MOVE 1,JOBNO		;FIRST FEW JOBS ARE SPECIAL,
	CAIL 1,NSPECJ		;IS THIS ONE OF THEM?
	IFSKP.
	  MOVEI 2,OPERDN	;YES, GET DIRECTORY NUMBER OF <OPERATOR>
	  HRRM 2,JOBDIR(1) 	;INDICATE LOGGED IN AS <OPERATOR>
	  STOR 2,JSDIR		;SAVE AS CONNECTED DIRECTORY
	  SETZRO JSCDF		;NO STRING IN JSB
	  MOVE 2,STRTAB+PSNUM 	;GET SDB ADDRESS OF PRIMARY STRUCTURE
	  LOAD 2,STRUC,(2) 	;GET ITS UNIQUE STRUCTURE CODE
	  STOR 2,JSUC		;SAVE AS CONNECTED STRUCTURE CODE
	  MOVE 2,[[3
		 ASCIZ "OPERATOR"],,USRNAM]
	  BLT 2,USRNAM+2	;SET UP DEFAULT USER NAME STRING
	  MOVE 2,SPECJT(1)
	  JRST 0(2)		;GO DO THE SPECIAL FUNCTION
	ENDIF.

;NOT A SPECIAL JOB. SET UP TERMINAL INFORMATION

	MOVE A,CTRLTT		; GET CONTROLLING TERMINAL
	JUMPL A,SYSINP		;NO TTY. DON'T INIT TTY PARAMETERS
	CALL CHKPTY		;IS IT A PTY?
	 SKIPA			;NO. INIT TTY PARAMETERS
	JRST SYSINP		;YES. DON'T INIT TTY PARAMETERS
	MOVEI 1,100
	MOVEI 2,3B33		;SET TO HDX HERE, SO SETTING TO FDX
	STPAR			;BELOW WILL FORCE OUT TELNET CONTROL
	MOVE 2,NORMTF		;GET TTY TO STANDARD STATE
	SFMOD
	STPAR			;SET DEVICE PARAMETERS TOO
	MOVE B,CTRLTT		;GET CONTROLLING TERMINAL
	CALL CHKTVT		;SEE IF A TCP VIRTUAL TERMINAL
	 JRST SYSINQ		;NEITHER.  MUST BE NORMAL.
SYSINO:	SKIPA T2,[.TTIDL]	;SOMEKIND OF NET TERMINAL -- IDEAL
SYSINQ:	MOVE 2,NORMTY		;Normal kind of terminal
	MOVEI T1,.PRIOU
	STTYP
	MOVE 2,TTICB1
	MOVE 3,TTICB2
	SFCOC
	HRLOI T1,(TL%CRO+TL%COR+TL%SAB+TL%ABS+TL%STA)
	MOVE T2,CTRLTT		;Get controlling TTY#
	CAMN T2,CTYLNO		;Starting job on CTY?
	TXZ T1,TL%ABS		;Yes - so set refuse links
	MOVEI T2,-1		;ALL REMOTE
	TLINK			;BREAK LINKS, CLEAR ACCEPT
	 JFCL

;GO START THE EXEC. IF SYSTEM IS STAND-ALONE, TELL THE USER

SYSINP:	SKIPE CRJFLG		;IF CREATED JOB, GO SET IT UP.
	JRST STCRJB		; ..
	MOVE B,CTRLTT		;GET CONTROLLING TERMINAL
	CALL CHKTVT		;ARE WE A TVT?
	 SKIPA			;NO
          CALL TVTMSG		;YES SO OUTPUT THE MESSAGE
	MOVE T1,DBUGSW
	CAIGE 1,2		;DEBUG MODE OPERATION?
	JRST STEX		;NO, GO START EXEC
	TMSG <
[Caution--System is stand-alone]
>
	JRST STEX		;WARN USERS FIRST

SYSIN9:	SETOM CTRLTT		;INDICATE DETACHED SO LOGOUT WON'T
	MOVE T2,JOBNO		; TRY TO WRITE ON THIS TERMINAL
	HRROS JOBPT(T2)		;..
	SKIPL CRJFLG		;IS THIS JOB BEING CREATED BY CRJOB JSYS?
	JRST FLOGO1		;NO. GO KILL THE JOB
	SETOM CRJTTY		;YES, CRJOB TTY IS NO LONGER SPECIAL
	CALL SETANS		;SETUP CRJANS AND CRJFLG
	JRST LOGO		;GO KILL THE JOB

;HERE AT STARTUP OF JOB BY CRJOB JSYS.

STCRJB:	MOVE T1,GBLJNO		;GET GLOBAL JOB INDEX FOR CREATOR
	HRLM T1,CRJONJ		;TELL CREATOR, IF WE GET THERE.
	MOVE Q1,JOBNO		;CARRY AROUND MY JOB NUMBER
	MOVE Q2,CRJAC1		;AND CONTROL FLAGS OF CRJOB AC1
	HRRZ T1,CRJONJ		;Get creator's global job number
	CALL GL2LCL		;Convert it into a local job index
	 JRST SCJXX4		;No such job...give up
	HRRM T1,CRJAC1		;Save the local index for later
	HRRZ T1,CRJONJ		;Get the global job number of creator
	HRL T1,GBLJNO		;GET JOB NUMBER FOR JOBONT.
	TXNE Q2,CJ%OWN		;CREATOR WANTS TO OWN ME?
	MOVEM T1,JOBONT(Q1)	;YES. REMEMBER WHO HE IS.
	MOVE T1,CRJSLO		;SIGNAL ON LOGOUT?
	TXNN Q2,CJ%SLO		; ..
	MOVEI T1,0		;NO. CLEAR THE PID
	MOVEM T1,JSLOPD		;SAVE THE PID FOR THE SIGNAL
	JN CJ%LOG,Q2,STCJB1	;JUMP IF WANTS TO LOG IN
	HRRZ T1,CRJAC1		;NO LOGIN, GET CREATOR'S JOB INDEX
	HRRZ T1,JOBDIR(T1)	; TO FETCH CREATOR'S LOGIN DIRECTORY
	STOR T1,JSDIR		;AND MAKE IT OUR CONNECTED DIRECTORY
IFE STANSW,<
	MOVE T1,STRTAB+PSNUM	;POINT TO THE PRIMARY SDB
>;IFE STANSW
IFN STANSW,<
	SKIPGE T1,LOGINS	;GET THE LOGIN STRUCTURE INTO T1
	 MOVEI T1,PSNUM		; FAILS, USE PS INSTEAD
	MOVE T1,STRTAB(T1)	;POINT TO THE SDB
>;IFN STANSW		
	LOAD T1,STRUC,(T1)	; AND FETCH THE PRIMARY STRUCTURE UNIQUE CODE
	STOR T1,JSUC		;SET IN JSB, COMPLETING CONNECT TO PRIMARY STR
	SETZM CAPENB		;MAKE SURE I HAVE NO CAPS ENABLED
	HLLZS CAPMSK		;OR POTENTIAL
	MOVE T1,CRJOJC		;GET OWNING JOB'S CAPS
	AND T1,CRJCAM		;MASKED, IF ASKED
	TXNE Q2,CJ%CAP		;DOES HE WANT TO GIVE ME HIS?
	HRRM T1,CAPMSK		;YES, I'LL TAKE THEM, UNTIL LOGIN JSYS
	JRST STCJ1A		;DONE WITH LOGIN-ISH STUFF

;HERE IF CJ%LOG IS ON IN CALL. I AM TO TRY TO LOG THIS JOB IN.

STCJB1:	HRROI B,CRJUSR		;POINT TO THE USER NAME STRING
	MOVX T1,RC%EMO		;EXACT MATCH ONLY
	RCUSR			; AND CONVERT TO USER NUMBER
	 ERJMP SCJXXX		;PASS FAILURE CODE BACK
	TXNE T1,RC%NOM!RC%AMB	;FILES ONLY, NO MATCH OR
	JRST SCJXX1		; AMBIGUOUS? FAIL. CAN'T LOG IN.
	MOVEM T3,CRJUSR		;STORE THE NUMBER
	HRRZ T3,T3		;CLEAN FOR CAMN LATER
	MOVE T4,CRJOJC		;GET CREATOR'S CAPS
	HRRZ T1,CRJAC1		;AND JOB INDEX
	HRRZ T1,JOBDIR(T1)	;CREATOR'S LOGIN DIRECTORY
	TRNN T4,SC%WHL!SC%OPR	;PRIVILEGED CREATOR?
	CAMN T1,T3		;OR LOGGING IN AS SAME USER?
	JRST STCJ1E		;YES. NO NEED FOR PSWD CHECK.
	TXZE Q2,<CJ%NPW!CJ%NUD>	;NO, SO REQUIRE PASSWORD, AND LOGIN DATE
	JRST [	MOVEI T1,CRJBX1	;ILLEGAL REQUEST
		JRST SCJXXX]
STCJ1E:	LOAD T1,CJ%ACT,Q2	;WHAT KIND OF ACCOUNT DO WE USE?
	CAIE T1,.CJUCA		;USE CURRENT ACCOUNT OF CREATOR
	CAIN T1,.CJUAA		;OR ARG BLOCK ACCOUNT?
	JRST STCJ1C		;YES, IT'S IN THE COMMON STORAGE.
	SETZM CRJACT		;USE DEFAULT
   ;FALL THRU

   ;CAN FALL IN
STCJ1C:	MOVEI T1,0		;BUILD FLAGS FOR LOGIN JSYS
	TXNE Q2,CJ%NPW		;NO PASSWORD NEEDED?
	TRO T1,1		;RIGHT.
	TXNE Q2,CJ%NUD		;NO UPDATE LOGIN DATE?
	TRO T1,2		;RIGHT. TELL LOGIN.
	HRRM T1,CRJFLG		;STORE FOR IT TO SEE
	MOVE T1,CRJUSR		;LET'S DO THE LOGIN NOW.
	HRROI T2,CRJPSW		;PASSWORD, IF ANY.
	MOVE T3,CRJACT		;AND ACCOUNT
	LOGIN			;SEE IF THIS IS ALL VALID.
	 JRST SCJXXX		;APPARENTLY NOT.
	TXNN	Q2,CJ%CAP	;test if CAP flag is on
	JRST	STCJ1A		;no, skip over the rest
	MOVE	T1,CRJOJC	;get caller's caps back
	AND	T1,CAPMSK	;AND them with user's available caps
	HLL	T1,CAPMSK	;copy cap allowed to LH of new jobs caps
	MOVEM	T1,CAPENB	;save caps enabled
STCJ1A:	MOVE T2,CRJCPU		;GET TIME LIMIT FOR THIS JOB
	JUMPE T2,SCJBNL		;JUMP IF NO LIMIT
	MOVE T1,[.FHJOB,,.TIMRT] ;SET TIME LIMIT FOR JOB
	MOVEI T3,.ICMSE		;ON MACHINE-SIZE EXC CHANNEL, SO PANIC
	TIMER			;DO IT
	 JRST SCJXXX		;GIVE BACK FAILURE
SCJBNL:	MOVEI T1,.FHSLF		;SET UP TO DO SPJFN
	MOVE T2,CRJPJF		;FROM THIS ARGUMENT
	TXNE Q2,CJ%FIL		;IS THERE BOTH AN EXEC AND AN INFERIOR?
	TXNN Q2,CJ%ETF		; ..
	SKIPA			;NO. DO THE SPJFN HERE.
	JRST STCJ1D		;YES. ONLY DO THE SPJFN ON THE INFERIOR
	TXNE Q2,CJ%SPJ		;REQUESTED TO DO SPJFN?
	SPJFN			;YES, DO IT.
	 ERJMP SCJXX4		;FAILED. HANDLE IT
STCJ1D:	HLLZS CRJFLG		;NO FLAGS FOR A LATER LOGIN
	TXNN Q2,CJ%FIL		;WANT TO RUN A FILE?
	JRST CJSTEX		;NO. JUST GO GET THE EXEC.
STCJB2:	TXNE Q2,CJ%ETF		;WANT A FILE. AN EXEC TOO?
	JRST STCJB3		;YES.
;**;[7279] Add 2 lines at STCJB2:+2L	MDR	31-MAR-86
	SKIPE CRJEXF		;[7279] Are we passing flags to an EXEC?
	 CALL SCJPRA		;[7279] / Yes, set up a PRARG block
	MOVX T1,GJ%OLD!GJ%SHT	;GET THE REQUESTED FILE IN TOP FORK
	HRROI T2,CRJFIL		;POINT TO THE TEXT
	GTJFN			;GET JFN FOR REQUESTED FILE
	 JRST SCJXXX		;CAN'T
	HRLI T1,.FHSLF		;OK, GET IT INTO THIS FORK.
	GET
	ERJMP SCJXX4		;IF GET FAILS, QUIT.
;NOTE: THIS CODE RUNS IN SECTION 0 FOR SOME UNKNOWN REASON. IN
;ORDER FOR THIS CALL TO BLTMU TO WORK CORRECTLY, THIS CODE TEMPORARILY
;ENTERS SECTION 1. IF STRCJB IS MADE TO RUN ENTIRELY IN SECTION 1, THESE
;MACROS SHOULD BE REMOVED.
	TSTMS0			;We had better be in section 1
	MOVEI T1,20		; Length of AC block
	XMOVEI T2,CRJFAC	; From there
	SETZ T3,
	TXNE Q2,CJ%ACS		;AC SET REQUESTED?
	CALL BLTMU
	MOVEI T1,.FHSLF		;GET THE ENTRY VECTOR
IFE STANSW,<
	GEVEC			;GET THE ENTRY VECTOR
	TLNN T2,777000		;TOPS10 STYLE?
	JRST STCJ2A		;NO. TOPS20 STYLE, IF ANYTHING.
	HRRZ T3,CRJEVO		;OLD STYLE. WHERE DOES START POINT?
	CAILE T3,1		;START OR REENTER, I HOPE.
	JRST SCJXX3		;NO. FAIL.
	UMOVE T2,120		;GET JOBSA
	TRNE T3,-1		;OR IF 1,
	UMOVE T2,124		;GET JOBREN
	SKIPA
STCJ2A:	ADD T2,CRJEVO		;NEW STYLE, ADD OFFSET TO BASE.
	HRRZM T2,-1(P)		;WHERE MRETN WILL GO.
>;IFE STANSW
IFN STANSW,<
	XGVEC%			;GET THE ENTRY VECTOR
	IFXN. T2,777000		;TOPS10 STYLE?
	  HRRZ T3,CRJEVO	;OLD STYLE. WHERE DOES START POINT?
	  CAILE T3,1		;START OR REENTER, I HOPE.
	   JRST SCJXX3		;NO. FAIL.
	  XCTU [HRRZ T2,120]	;GET JOBSA
	  TRNE T3,-1		;OR IF 1,
	   XCTU [HRRZ T2,124]	;GET JOBREN
	ELSE.
	  MOVE T2,CRJEVO	;NEW STYLE, GET OFFSET
	  ADD T2,T3		;AND BASE
	ENDIF.
	MOVEM T2,-1(P)		;WHERE MRETN WILL GO.
>;IFN STANSW
	CALL SUCANS		;SETUP CRJANS WITH SUCCESS
	CALL SCJWTA		;WAIT FOR ATTACH, IF WANTED
	JRST MRETN		;AND GO TO USER MODE.

;Here to setup CRJANS and CRJFLG in an interlocked manner

SUCANS:	SETO T1,		;SAY WE HAVE SUCCEEDED.
SETANS:	NOSKED			;NO INTERRUPTS PLEASE
	SKIPGE CRJFLG		;DO WE HAVE AN ANSWER ALREADY?
	 MOVEM T1,CRJANS	; NO, PUT THE RESPONSE IN CRJANS
	MOVEI T1,1		;INDICATE JOB HAS ALREADY SET CRJANS
	HRLM T1,CRJFLG		; BY MAKING FLAG POSITIVE
	OKSKED			;ENABLE INTERRUPTS
	RET			;ALL DONE!

;HERE IF WANT BOTH A FILE AND AN EXEC.

STCJB3:	MOVX T1,GJ%OLD!GJ%SHT	;GET A JFN FOR THE FILE.
	HRROI T2,CRJFIL		;WITH SUPPLIED NAME
	GTJFN
	 JRST SCJXXX		;CAN'T FIND THE FILE.
	PUSH P,T1		;SAVE JFN A MOMENT
	MOVX T1,CR%CAP		;CREATE THE NEW FORK, MY CAPS.
	TXNE Q2,CJ%ACS		;WANT SOME AC'S LOADED?
	TXO T1,CR%ACS		;YES, HAVE CFORK LOAD THEM.
	MOVEI T2,CRJFAC		;HERE ARE THE AC'S
	CFORK			;MAKE ME A FORK! (YOU'RE A FORK)
	 JRST SCJXX2		;CAN'T DO IT.
	EXCH T1,0(P)		;GET BACK JFN, SAVE FHANDLE
	HRL A,0(P)		;SET UP FOR THE GET
	GET
	ERJMP SCJXX2		;CAN'T GET THE FILE
	MOVE T1,0(P)		;HANDLE OF INFERIOR
	MOVE T2,CRJPJF		;PRIMARY I/O FOR IT
	TXNE Q2,CJ%SPJ		;IF REQUESTED,
	SPJFN			;SET IT.
	POP P,T1		;INFERIOR FORK HANDLE.
	HRLZS T1		;FORK,,0
	HRR T1,CRJEVO		;WHERE TO START IT.
CJSTEX:	CALL SCJPRA		;SET UP PRARG FOR EXEC
	CALL STEX		;GET EXEC 
	CALL SUCANS		;SETUP CRJANS WITH SUCCESS
	CALL SCJWTA		;WAIT FOR ATTACH, IF REQUESTED
	JRST GEX1		;AND START THE EXEC.

;CALL THIS ROUTINE BEFORE GOING TO MRETN FROM CRJOB PATHS. IT WILL
;WAIT FOR JOB TO BECOME ATTACHED, IF THAT'S REQUESTED BY CALLER.

SCJWTA:	TXNN Q2,CJ%WTA		;WANT TO WAIT?
	RET			;NO.
	MOVE T1,JOBNO		;YES. GET MY JOB NUMBER
	MOVEI T1,JOBPT(T1)	;AND JOBPT SLOT FOR THIS JOB
	CALL DISGE		;WAIT FOR LH TO BECOME POSITIVE
	RET			;NOW ATTACHED. RETURN.

SCJXX3:	MOVEI T1,SFRVX1		;BAD ENTRY VECTOR OFFSET
	JRST SCJXXX		;RETURN THAT ERROR

SCJXX2:	POP P,0(P)		;ADJUST STACK POINTER
SCJXX4:	HRRZ T1,LSTERR		;AND RETURN THIS FORK'S LAST ERROR
	JRST SCJXXX		; TO CREATOR

SCJXX1:	MOVEI T1,CRJBX5		;UNKNOWN NAME FOR LOGIN
SCJXXX:	ANDI T1,-1		;REDUCE TO JUST ERROR CODE
	CALL SETANS		;GO SETUP CRJANS
	JRST LOGO		;AND KILL OFF THIS STARTED JOB.

;ROUTINE TO SET UP PRARG FOR EXEC TO READ IN NEW JOB

NCJPRA==3			;NUMBER OF ARGUMENT ITEMS
LCJPRA==6			;LENGTH OF BLOCK TO SET

SCJPRA:	TRVAR <<SCJPRB,10>>	;SPACE TO BUILD PRARG BLOCK
	PUSH P,T1		;PRESERVE FORKX,,SFRKV OFFSET
	MOVEI T1,NCJPRA		;NUMBER OF ARGUMENTS
	MOVEM T1,SCJPRB		;INTO THE BLOCK
	MOVEI T1,SCJPRB		;POINT TO BLOCK WITH PUSH POINTER
	PUSH T1,[1B0+3B6+2B12+CR%PRA]	;I AM A CRJOB PRARG
	PUSH T1,[1B0+4]		;WORD 4 IS ANOTHER DATUM
	PUSH T1,[1B0+5]		;WORD 5 IS ANOTHER DATUM
	MOVE T2,CRJEXF		;FLAGS FOR EXEC IS ONE DATUM
	TXNE Q2,CJ%FIL		;IF THERE IS A PROGRAM
	TXO T2,1B1		;TURN ON "THERE'S A FORK" BIT
	PUSH T1,T2		;FLAGS TO ARG BLOCK
	POP P,T2		;RESTORE FORKX,, ENT-VEC-OFFSET
	TXNE Q2,CJ%FIL		;IF THERE IS A PROGRAM
	PUSH T1,T2		;PUT IT IN BLOCK
	MOVE T1,[.PRAST,,.FHSLF] ; SET MY OWN PRARG BLOCK
	MOVEI T2,SCJPRB		;HERE'S THE BLOCK TO SET
	MOVEI T3,LCJPRA		;HERE'S ITS LENGTH
	PRARG			;SET IT
	ERJMP SCJXX4		;CATCH TRAP IF FAILED
	RET			;SUCCESS.
	SUBTTL Job 0 Initialization (RUNDD)

;SYSTEM INITIALIZATION.  RUN ONCE ONLY BY JOB 0.

	SWAPCD

RUNDD::	MOVE T1,SPJCAP		;GET SPECIAL JOB CAPS
	MOVEM T1,CAPENB		;ENABLE ALL CAPABILITIES FOR INITIALIZATION
	MOVEM T1,CAPMSK		;HERE TOO
	MOVEI T1,RUNDD3		;GO TO RUNDD3 IF AN INTERRUPT OCCURS
	MOVEM T1,JB0XFR		;SAVE THE ADDRESS FOR JB0INT
	MOVE T1,[MSEC1,,JB0INT]	;XFR TO JB0INT ON ERROR
	CALL MONBKX
	MOVX T1,SF%BGS		;Make all messages type on CTY
	IORM T1,FACTSW
	MOVE T1,CTYLNO		;GET CTY LINE NUMBER
	MOVEI T1,.TTDES(T1)	;CONVERT TO 400000+N
	MOVEM T1,JB0TT		;CONTROLLING TERMINAL FOR JOB 0
	HRRM T1,PRIMRY		;AND PRIMARY OUTPUT FOR US
IFN STANSW&SUMXSW,<
	MOVE T1,LOGLNO		;GET LOGTTY LINE NUMBER
	MOVEI T1,.TTDES(T1)	;CONVERT TO TERMINAL DESIGNATOR
	MOVEM T1,LOGDES		;LOGGING TERMINAL
>;IFN STANSW&SUMXSW
	CALL ASCINI		;Initialize accounting shift change stuff
	CALL RESLCK		;BE SURE ADEQUATE RES FREE SPACE
	CALL SERINI		;START SYSERR LOGGING
	SKIPN PROFLG		;WANT PRIMARY PROTOCOL?
	JRST RUNDI7		;NO. SKIP ALL PRIMARY STUFF
	MOVEI A,.PRIOU		;YES. FIRST WAIT FOR CTY TO STOP
	DOBE			;"
	CALL TTSPIN		;INITIALIZE TERMINAL SPEEDS TO NULL
	CALL PROINI		;TURN ON PRIMARY PROTOCOL
	CALL DTRMDS		;TELL -11 NOT TO ANSWER DATA SETS

;TRY TO GET TIME AND DATE FROM THE 11. DTE SERVICE SENDS THE REQUEST TO
;THE 11 AND STORES ITS ANSWER IN TAD11. IF THE 11 DOES NOT KNOW, IT
;RETURNS -1. IN THIS CASE, ASK THE OPERATOR FOR THE TIME. IF THE 11 HAS
;IT, DON'T ASK THE OPERATOR

	SKIPE SMFLAG		;IF SM10 THEN WE ALREADY HAVE TIME AND DATE CORRECT
	JRST RUNDD3
	SETZM TAD11		;ZERO TIME CELL
	CALL RQTAD1		;REQUEST TIME/DATE FROM 11
	 JFCL			;THIS FAILURE CAN'T OCCUR
	SKIPN TAD11		;HAS 11 SENT TIME/DATE YET?
	JRST .-1		;NO. WAIT UNTIL IT DOES
	MOVE B,TAD11		;GET TIME SENT FROM -11
	SETOM TAD11		;YES. RESET TO INDICATE NOT SET BY 11
	CAMN B,[-1]		;DOES THE -11 HAVE IT?
	JRST RUNDI7		;NO
	DMOVE C,TAD11+1		;YES. GET REST OF IDCNV ARGS
	IDCNV			;CONVERT TO INTERNAL
	 JRST RUNDI7		;FAILED. GET FROM OPERATOR THEN
	MOVEM B,CRSTAD		;LET IT FIND IT LATER

	;..
;RUNDD...
;SET SYSTEM TIME AND DATE IF THE 11 PROVIDED IT

	;..
RUNDI7:	MOVEI 1,101
	DOBE
	SKIPE 1,CRSTAD		;DO WE HAVE A SAVED TIME FROM CRASH?
	JRST RUNDD3		;Yes, wait to set time till after cluster join
	MOVX A,SF%MST		;NO. SAY IS A MANUAL START
	IORM A,FACTSW		;""

;Initialize checkpoint interval

RUNDD3:	MOVEI T1,RUNDI4		;GO TO RUNDI4 IF AN INTERRUPT OCCURS
	MOVEM T1,JB0XFR		;SAVE THE ADDRESS FOR JB0INT
	MOVE T1,[^D<10*60000>]	;SET DEFALUT CHECKPOINT INTERVAL
	MOVEM T1,CKPINV		;...
IFN FTKLIPA,<
	CALL PPDINX		;CRANK UP PORT/SCA/SYSAPS
	CALL KLPUCD		;GET PORT UCODE INTO MEMORY
	 IFNSK.
	    CAIE T1,GJFX18	;FAILED, WAS IT NO FILE
	    CAIN T1,KLPX7	; OR NO KLIPA?
	    SKIPA		;YES, THAT'S OK FOR NOW
	    BUG.(CHK,KLIPAF,MEXEC,SOFT,<Failed to read in CI20 microcode>,<<T1,ERRCOD>>,<

Cause:	At system startup we tried to read in the CI20 ucode.  Routine KLPUCD
	in module PHYKLP got a JSYS error while attempting the read.

Data:	ERRCOD - Error code returned
>)
	 ENDIF.
	MOVX T1,1B1		;Make a fork to prevent hanging
	CFORK			;""
	IFSKP.			;If it made it...
	 DO.
	  MOVE T2,[MSEC1,,CIRUN] ;Where it is to run
	  MSFRK			;Do it
	  ERJMP ENDLP.		;If failed, go on
	  MOVEM T1,CIFORK	;Save fork handle for later
	 ENDDO.
	ENDIF.			;Now we can't get hung by SCA buffer deferral
   >	;IFN <FTKLPA>

	CALL IPACHK		;Check on the KLIPA
	IFNSK.			;If +1, we did reload the KLIPA
	 MOVEI T1,^D2000	;Wait here for the driver to see it
	 DISMS			;""
	ENDIF.
;   IFN CFSCOD,<
	AOS CFSSKC		;Check on CI utility now
;   >

;Default the CTY to be an LA120 if we are condensing BUGxxx output

	SKIPN SAVTRE		;SAVING TREES?
	IFSKP.
	   MOVEI T1,.PRIOU	;YES, DEFAULT THE CTY
	   MOVEI T2,.TT120	; TO BE AN LA120
	   STTYP		;SET THE CTY'S TTY TYPE
	    ERJMP .+1
	ENDIF.

IFN STANSW,<
;We start the Multinet background forks (Internet, PUP, ARP) at this point
; instead of at RUNDD7 because we want to invoke the TIME program to set the
; system TAD. By the time SETSPD has run, the various network background forks
; will be set up, ready for TIME to run.  Note that the PUP fork must be
; started first, so as to correctly initialize our subnet routing tables.
IFN PUPSW,<
	CALL PUPBEG		;START THE PUP BACKGROUND FORK FIRST
>;IFN PUPSW
	CALL MNTINI		;INITIALIZE MULTINET TABLES, ETC.
	CALL INTBEG		;START THE INTERNET FORK
IFE NICSW,<
	CALL ARPBEG		;START THE ARP BACKGROUND FORK
	CALL PKOINI		;INIT PKOPR% DATABASE
>;IFE NICSW
>;IFN STANSW	

;RUN SETSPD TO SET LINE SPEEDS, SYSTEM LOGICAL NAMES, OTHER SYSTEM
;PARAMETERS

	MOVX T1,GJ%OLD!GJ%SHT!GJ%PHY ;YES. SET LINE SPEEDS
	HRROI T2,SETSPD		;GET POINTER TO "SYSTEM:X-SETSPD.EXE"
;**[7316] Change 1 line at RUNDD6:-20L	MDR	10-JUN-86
	MOVEI T3,1		;[7316] 3/Offset 1 in entry vector
	SETZM T4		;DO NOT RECORD FORK NUMBER
	CALL RUNDII		;GO RUN IT
	 JRST [	TMSG <
%%No SETSPD.
>
		MOVEI T1,.PRIOU ;WAIT UNTIL THE TERMINAL
		DOBE		; STOPS SO THE NEXT MESSAGE IS OK
		JRST .+1]	;SAY IT FAILED
	CALL GETNAM		;DO AGAIN,SINCE SYSTEM: MAY BE REDEFINED
;   IFN CFSCOD,<		;If CFS...
	CALL FILRST		;reset all file accesses now
	CALL CFSJYN		;Join the network now
	CALL CFGTJB		;Initialize CFS Global Job numbers
	CALL MNTPS		;And mount PS: correctly
;   >	;IFN CFSCOD

;IF DBUGSW IS 0 OR 1, TELL ALL USERS THAT SYSTEM IS RESTARTING

RUNDD6:	MOVE 1,DBUGSW
	SOJG T1,RUNDI4		;If .GE. 2, don't send notification
	SETO 1,
	HRROI 2,[ASCIZ /
System restarting, wait...
/]
	TTMSG
	 ERJMP .+1
	;..
;RUNDD...

;GET DATE AND TIME FROM OPERATOR UNLESS 11 SENT IT EARLIER

	;..
RUNDI4:	MOVEI T1,RUNDI1		;GO TO RUNDI1 IF AN INTERRUPT OCCURS
	MOVEM T1,JB0XFR		;SAVE THE ADDRESS FOR JB0INT

IFN STANSW,<
	TMSG <
Monitor Built: >
	MOVEI 1,.PRIOU
	MOVE 2,SYSTAD
	MOVX 3,OT%DAY!OT%FDY!OT%FMN!OT%4YR!OT%NSC!OT%12H!OT%SCL
	ODTIM			;TYPE IT IN VERBOSE FORMAT
	TMSG <
>
>; IFN STANSW

;   IFN CFSCOD,<			;Only if doing CFS code
	CALL CFTADC		;See if CFS has a better time
	IFNSK.			;CFS does not have the time yet
	  SKIPN T1,CRSTAD	;Did the -11 ever have it?
	  ANSKP.		;Yes, get most recent time from the -11
            SETZM CRSTAD	;Clear unneeded cell
	    SETZM TAD11		;Zero time cell
	    CALL RQTAD1		;Request time/date from 11
	     JFCL		;This failure can't occur
	    SKIPN TAD11		;Has 11 sent time/date yet?
	     JRST .-1		;No. Wait until it does
	    MOVE T2,TAD11	;Get time sent from -11
	    SETOM TAD11		;Reset to indicate not set by 11
	    SETZ T1,		;Assume -11 does not have the time
	    CAMN B,[-1]		;Does the -11 HAVE IT?
	    IFSKP.		;Yes, process it
	      DMOVE T3,TAD11+1	;Get rest of IDCNV args
	      IDCNV		;Convert to internal
	       SETZ T2,		;Failed
	      MOVE T1,T2	;Repositon for check
	    ENDIF.
	ENDIF.
	SKIPN T1		;Did we get the time from anyone?
	IFSKP.			;If so
	 STAD			;Set it
	 ANSKP.			;And if it got set
	 HRROI T1,[ASCIZ /
Date and time is: /]
	 PSOUT			;Tell the operator
	 MOVEI T1,.PRIOU
	 SETOM T2		;Use time we just set
	 MOVX 3,1B1+1B2+1B4+1B5+1B10+1B11+1B17
	 ODTIM			;TYPE IT IN VERBOSE FORMAT
	 HRROI T1,[ASCIZ /
/]
	 PSOUT			;Make it pretty
	 CALL DTTIME		;If a KL, tell the FE
	 JRST RUNDI1		;And go on
	ENDIF.
;   >	;IFN CFSCOD
	CALL LGTAD		;DOES SYSTEM HAVE TIME AND DATE?
	CAME A,[-1]
	JRST RUNDI1		;YES
	MOVE T1,DBUGSW		;Get mode of system
	CAIE T1,3		;Defaulting time/date?
	JRST RUNDI3		;No. Ask then
	MOVE T1,SYSTAD		;Get monitor creation time
	STAD			;Set system time with it
	 NOP
	JRST RUNDI1		;And go on
RUNDI3:
IFN STANSW,<
	MOVX T1,GJ%OLD!GJ%PHY!GJ%SHT	;GTJFN FLAGS
	HRROI T2,[ASCIZ/SYSTEM:TIME.EXE/] ;THE PROGRAM 
	SETZB T3,T4		;START AT MAIN ENTRY POINT, DON'T RECORD FORKX
	CALL RUNDII		;RUN TO COMPLETION, BLOCK UNTIL DONE
	 NOP			;IGNORE AN ERROR
	CALL LGTAD		;GET TIME WORD
	CAME A,[-1]		;DID WE GET THE TIME FROM THE NETWORK?
	JRST RUNDI1		;YES
>;IFN STANSW
	TMSG <
Enter current date and time: >
RUNDI2:	CALL RDDGTD		;GET TAD INTO 2
	PUSH P,2		;SAVE TAD JUST ENTERED
	TMSG <
You have entered >
	MOVEI 1,.PRIOU
	MOVE 2,0(P)
	MOVX 3,1B1+1B2+1B4+1B5+1B10+1B11+1B17
	ODTIM			;TYPE IT IN VERBOSE FORMAT
	MOVE 2,0(P)
	CAMGE 2,SYSTAD		;IS IT GREATER THAN SYSTEM LOAD TAD?
	JRST [	MOVEI 1,.PRIIN	;CLEAR TYPE AHEAD
		CFIBF
		MOVEI 1,.PRIOU
		DOBE		;WAIT FOR TYPE OUT TO STOP
		TMSG <,
that cannot be correct.
Please try again in form MMM-DD-YY HHMM >
		JRST RUNDI2]
	TMSG <,
 is this correct (Y,N) >
	CALL YESNO		;GET VERIFICATION
	JUMPE A,RUNDI3		;IF 'NO', TRY AGAIN
	POP P,1			;CONFIRMED, RECOVER IT
	STAD			;SET IT
	 JFCL
;   IFN CFSCOD,<
	CALL BRDTIM		;If CFS stuff around, reconcile any differences
;   >
	; ..

;RUNDD...

;DECIDE WHETHER TO RUN CHECKD OR NOT. IF CHKBT FOUND ERRORS, FACTSW HAS
;SF%BTE SET; RUN CHECKDTO DO A BIT TABLE CONSISTENCY CHECK. IF BIT
;TABLE FILE DOESN'T EXIST, MS%ASG IS SET IN SDB. DON'T RUN CHECKD.
;(OPERATOR WILL HAVE TO RUN IT WITH THE REBUILD FUNCTION). IF DOING
;RECONSTRUCTION OF ROOT-DIRECTORY OR REBUILD OF BIT TABLE, STARTF HAS
;MI%BTB SET; RUN CHECKD TO DO A REBUILD OF THE BIT TABLE.  IF DOING
;A REFRESH OF THE FILE SYSTEM, DON'T TRY TO RUN CHECKD. IF NONE OF
;THE ABOVE, ASK THE OPERATOR UNLESS AUTO RELOADING. IN ALL CASES,
;ONLY PS IS MOUNTED AT THIS POINT, SO CHECKD IS ONLY RUN ON PS.

	;..
RUNDI1:	MOVEI T1,RUNDD1		;GO TO RUNDD1 IF AN INTERRUPT OCCURS
	MOVEM T1,JB0XFR		;SAVE THE ADDRESS FOR JB0INT
	CALL LOGSST		;LOG RESTART IN SYSERR FILE
	SKIPN AVALON		;RUNNING ACCOUNT VALIDATION?
	JRST RUNDI5		;NO, PROCEED
	CALL ENACT		;INITIALIZE THINGS FOR ACCT VALIDATION
	 JRST [	TMSG <
<SYSTEM>ACCOUNTS-TABLE.BIN not found - Account validation is disabled
>
		SETZM AVALON	;TURN OFF VALIDATION
		JRST .+1]	;AND PROCEED

RUNDI5:	MOVX T4,MI%BTB		;IF REBUILDING THE BIT TABLE (BIT IS
	TDNE T4,STARTF		; SET BY FILINI)
	JRST RUNDC2		;ALWAYS RUN CHECKD IN REBUILD MODE
	MOVE 2,DBUGSW		;IF DEBUGGING,
	CAIL T2,2		;If debugging...
	JRST RUNDD2		;DON'T RUN CHECKD
	MOVX T4,MI%RFS		;IF REFRESHING (BIT IS SET
	TDNE T4,STARTF		; BY FSIINI)
	JRST RUNDD2		;DON'T RUN CHECKD (IT ISN'T THERE)
	MOVE T2,STRTAB+PSNUM	;POINT TO SDB FOR PS
	MOVE T2,SDBSTS(T2)	;GET STATUS BITS FOR PS
	MOVE T1,FACTSW
	TXNE T1,SF%BTE		;BIT TABLE ERRORS?
	TXNE T2,MS%ASG		;YES. ARE DISK ASSIGNMENTS PROHIBITED?
	SKIPA			;YES. DON'T RUN CHECKD
	JRST RUNDC1		;BIT TABLE ERRORS BUT BT FILE EXISTS. RUN CHECKD
	TXNN A,SF%MST		;MANUAL STARTUP?
	JRST RUNDD2		;NO. NO QUESTIONS AND NO CHECKD
	;..

;CHECKD NOT REQUIRED.  SEE IF OPERATOR WANTS IT

	;..
	TMSG <Run CHECKD? >
	CALL YESNO
	JUMPE A,RUNDD2		;JUMP IF NO
RUNDC1:	SKIPA T1,[-1,,[ASCIZ/[Checking file consistency]
/]]
RUNDC2:	HRROI T1,[ASCIZ/[Rebuilding bit table]
/]
	PSOUT
	MOVSI 1,(GJ%OLD!GJ%PHY!GJ%SHT)
	HRROI 2,[ASCIZ /SYSTEM:CHECKD.EXE/]
	MOVX T3,SF%CDR		;SAY CHECKD NOW RUNNING
	IORM T3,FACTSW		;DO IT
	SETZ T3,		;NORMAL ENTRY POINT
	MOVX T4,MI%BTB
	TDNE T4,STARTF		;REBUILDING BIT TABLE?
	MOVEI T3,3		;YES. START AT SPECIAL ENTRY POINT
	SETZM T4		;DO NOT RECORD FORK NUMBER
	CALL RUNDII		;GO START IT
	 JRST [	MOVX T1,SF%CDR	;NOT RUNNING
		ANDCAM T1,FACTSW
		JRST RUNDD1]	;FAILED
	SETZM STARTF		;INDICATE STARTUP IS COMPLETE
IFN SKEDSW,<
	SETZM NNSBE		;RESTART COUNTING NOSKED P-FAULTS
	>			;END IFN SKEDSW
	MOVX T1,SF%CDR		;SAY CHECKD NOT RUNNING ANYMORE
	ANDCAM T1,FACTSW	;""
	JRST RUNDD2		;PROCEED

;FAILED TO FIND CHECKD WHEN RUNNING IT WAS REQUIRED BY THE SYSTEM
;OR REQUESTED BY THE OPERATOR. PRETEND THAT IT RAN AND FOUND
;ERRORS. IF IT IS RUN LATER AND FINDS PS TO BE OK, IT WILL CLEAR
;SF%CDE.
;IT ALSO CAUSES THE 'FILE STRUCTURE NEEDS REPAIR' MESSAGE BELOW
;AND PREVENTS SYSJOB FROM DOING ITS USUAL THING

RUNDD1:	MOVEI T1,RUNDD2		;GO TO RUNDD2 IF AN INTERRUPT OCCURS
	MOVEM T1,JB0XFR		;SAVE THE ADDRESS FOR JB0INT
	TMSG <
No CHECKD
>
	SETZM STARTF		;INDICATE STARTUP COMPLETED
IFN SKEDSW,<
	SETZM NNSBE		;RESTART COUNTING NOSKED P-FAULTS
	>			;END IFN SKEDSW
	MOVX T4,SF%CDE		;PRETEND CHECKD FOUND ERRORS
	IORM T4,FACTSW
	;..
;RUNDD...

;IF DEBUGGING, TELL ALL USERS. IF CHECKD FOUND ERRORS, TELL ALL USERS
;THEN PROCEED AS USUAL

	;..
RUNDD2:	CALL SRVCFS		;NOTIFY MSCP SERVER THAT INIT IS COMPLETE
	SETONE SF%DPR,FACTSW	;Now enable disk preallocation
	MOVEI 1,RUNDD7		;GO TO RUNDD7 IF AN INTERRUPT OCCURS
	MOVEM T1,JB0XFR		;SAVE THE ADDRESS FOR JB0INT
	MOVEI 1,101
	DOBE			;WAIT FOR ANY CHECKD OUTPUT
	MOVE 1,DBUGSW
	CAIL 1,2		;DEBUG MODE OPERATION?
	JRST [	SETO 1,		;YES, DIFFERENT MESSAGE
		HRROI 2,[ASCIZ /
[System is stand-alone]
/]
		TTMSG
		 ERNOP.		;IN CASE OF REFUSALS
		JRST RUNDE1]
	MOVX 1,SF%CDE
	TDNE 1,FACTSW		;DID CHECKD FIND DISK ERRORS?
	JRST [	HRROI 2,[ASCIZ /
[System not in operation - file structure needs repair]
/]
		SETO 1,
		TTMSG
		 ERNOP.		;IN CASE OF REFUSALS
		JRST RUNDE1]

;Create a fork to be the old "job 0" fork -- the one that runs at CHKR.
;Continue the current fork at DDMP.

RUNDE1:	MOVX T1,1B1		;Create a fork
	CFORK			;Do it
RUNDDX: BUG.(HLT,DDXFRK,MEXEC,SOFT,<Cannot create CHKR fork>,<<T1,ERRCOD>>,<

Cause:	CFORK% failed to create the old "Job 0" fork that runs CHKR or the
	fork could not be be started in monitor mode with the MSFRK% JSYS.

Data:	ERRCOD - Error code returned from JSYS

>)
	XMOVEI T2,RUNDEC	;Where to proceed
	MSFRK			;Continue things below
	 ERJMP RUNDDX

;Continue the current fork at DDMP0.

	MOVE T1,[MSEC1,,DDMPER]	;GO TO DDMPER ON ERRORS
	CALL MONBKX
IFE STANSW,<
	TMSG <
Running DDMP

>
>;IFE STANSW
IFN STANSW,<
	CALL TIMSMP
	TMSG < DDMP: Started
>
>;IFN STANSW
	MOVE T1,FORKX		;GET FORK NUMBER
	MOVEM T1,DDMFRK		;RECORD IT
	JRST DDMP0		;DO DDMP HERE

;System initialization fork resumes here

RUNDEC:	MOVX T1,USRCTX		;Start with user context set
	MOVEM T1,FFL
	MCENTR			;Start a new process
	MOVE T1,FORKX		;GET FORK NUMBER
	MOVEM T1,JB0FRK		;RECORD IT
	MOVE T1,[MSEC1,,JB0INT]	;Where to go on error
	CALL MONBKX
	MOVE 1,JB0TT		;JOB 0 TTY
	CAIE 1,377777		;REAL TTY?
	JRST RUNDD4		;YES

;INITIALIZE SYSERR LOGGING

	MOVEI 1,ERRPT		;GET NAME OF SYSTEM ERROR FILE
	CALL PUTNAM		;ADD STRUCTURE NAME
	MOVSI 1,(GJ%FOU!GJ%PHY!GJ%SHT)	;NONE, SO OPEN FILE FOR MESSAGES
	HRROI 2,ERRPT		;GET NAME OF SYSTEM ERROR FILE
	GTJFN
	 BUG.(CHK,NOSERF,MEXEC,HARD,<Cannot GTJFN error report file>,<<T1,ERRCOD>>,<

Cause:	The CHKR fork failed to get a JFN for the ERROR.REPORT file.

Data:	ERRCOD - GTJFN error code

>)
	MOVE 2,[44B5+1B20]
	OPENF
	 BUG.(CHK,SERFOF,MEXEC,HARD,<Cannot OPENF error report file>,<<T1,ERRCOD>>,<

Cause:	The CHKR fork could not open the ERROR.REPORT file.

Data:	ERRCOD - OPENF error code

>)
RUNDD4:	HRRM 1,PRIMRY		;USE IT FOR OUTPUT

;START ACCOUNTING

	CALL USGINI		;START ACCOUNTING
	;..

;RUN SETSPD AGAIN. THIS TIME, START IT AT A SPECIAL PLACE TO MAKE
;IT COPY THE DUMP FILE.

	;..
	MOVX T1,SF%CDE		;DON'T CREATE DUMP.CPY IF THE BIT
	TDNE T1,FACTSW		; TABLE IS BAD
	JRST RUNDD7		;CHECKD FOUND ERRORS IN THE BT
	MOVX T1,GJ%OLD!GJ%PHY!GJ%SHT
	HRROI T2,SETSPD		;GET POINTER TO "SYSTEM:X-SETSPD.EXE"
	MOVEI T3,3		;3/ OFFSET 3 IN ENTRY VECTOR
	SETZM T4		;DO NOT RECORD FORK NUMBER
	CALL RUNDII		;GO RUN IT
	 JFCL			;IGNORE FAILURE
	SKIPL SPRCNT		;IF SPRCNT<0 THEN SETSPD DID NOT RE-INIT IT
	IFSKP.			;SO.. TELL WORLD
	 TMSG <
%SPEAR entry counter was not re-initialized, resynching to 0.
>
	 SETZM SPRCNT		;AND RESET TO 0 TO START LOGGING
	ENDIF.
	AOS SECHKF		;FORCE STUFF GOING ON THE SYSERR QUEUE

;DO NETWORK-RELATED FUNCTIONS

RUNDD7:	MOVEI T1,RUNDD8		;GO TO RUNDD8 IF AN INTERRUPT OCCURS
	MOVEM T1,JB0XFR		;SAVE THE ADDRESS FOR JB0INT
IFE FTNSPSRV,<
	CALL D36INI		;INIT DECNET
	 JFCL			;IGNORE (SPURIOUS) NON-SKIP RETURN
	CALL LLMINI		;INITIALIZE Ethernet LLMOP Protocol Servers
	CALL CTHINI		;INITIALIZE FOR CTERM HOST
	CALL OBJINI		;INITIALIZE OBJECT TYPE TABLE FOR DECNET
>;END IFE NSPSRV
	CALL LATINI		;INITIALIZE LAT HOST
IFE STANSW,<		;WE START THE NETWORKS EARLIER AT STANFORD
	CALL MNTINI		;INITIALIZE MULTINET
	CALL INTBEG		;INITIALIZE THE INTERNET FORK
>;IFE STANSW
IFN FTNSPSRV,<
	CALL ATSINI		;INITIALIZE APPLICATIONS TERMINAL SERVICE
	CALL NSPINI		;INIT DECNET FORK AND DATA BASE
>;END IFE NSPSRV
RUNDD8:	MOVEI T1,RUNDD5		;GO TO RUNDD5 IF AN INTERRUPT OCCURS
	MOVEM T1,JB0XFR		;SAVE THE ADDRESS FOR JB0INT
	AOS SYSIFG		;INDICATE NO LONGER IN STARTUP
				; (NEXT JOB WON'T GO THROUGH RUNDD)
	CALL DONSJ		;START NEXT SPECIAL JOB
	;..

;CREATE FORK UNDER JOB 0 AND RUN SYSJOB IN IT. SYSJOB READS A COMMAND
;FILE, WHOSE NAME IS DETERMINED BY THE SETTING OF DBUGSW. IF CHECKD
;HAS NOT BLESSED THE PRIMARY STRUCTURE (SF%CDE IS SET IN FACTSW), SYSJOB
;DOES NOT READ A COMMAND FILE.  AMONG OTHER THINGS, THIS WILL PREVENT
;LOGINS FROM TERMINALS OTHER THAN THE CTY

	;..
	MOVX T1,<GJ%OLD!GJ%PHY!GJ%SHT>
	HRROI T2,SYSJOB
	SETZM T3		;MAIN ENTRY POINT
	XMOVEI T4,SJBFRK	;LOCATION TO PLACE FORK NUMBER OF SYSJOB
	CALL RUNDIR		;RUN SYSJOB AND RETURN
	 JRST [	 TMSG<
No SYSJOB
>
		JRST .+1]
RUNDD5:	MOVEI 1,1		;KEEP JOB 0 IN QUEUE 1 ALWAYS
	MOVEM 1,JOBBIT		;SET PRIORITY FOR CHKR
	XMOVEI T1,CHKR		;GO TO CHKR IF AN INTERRUPT OCCURS
	MOVEM T1,JB0XFR		;SAVE THE ADDRESS FOR JB0INT
	SETZM EXPFRK		;CLEAR FORK HANDLE
	SKIPN SMFLAG		;IF NOT 2020
	CALL RUNMO1		;RUN MOS MEM DIAG
	SE1ENT			;Make sure we are in section one
	JRST CHKR		;GO DO BACKGROUND

;ROUTINE TO RUN A PROGRAM IN A FORK UNDER JOB 0
; A/ GTJFN T1 ARGS
; B/ GTJFN T2 ARGS
; C/ OFFSET IN ENTRY VECTOR WHERE WE START FORK
; D/ LOCATION IN WHICH TO PLACE FORK NUMBER (0 IF NOT DESIRED)
;	CALL RUNDII
;	  or
;	CALL RUNDIR
;RETURNS +1: FAILED, PROGRAM NOT RUN
;	 +2: RUNDII - PROGRAM RAN TO COMPLETION, FORK KILLED
;	     RUNDIR - PROGRAM STARTED,  A/ FORK HANDLE

RUNDIR:	SAVEAC <Q1>		;SAVE TRASHED AC
	SETZM Q1		;NO WAIT FLAG
	JRST RUNDIC		;CONTINUE

RUNDII::SAVEAC <Q1>		;SAVE TRASHED AC
	SETOM Q1		;WAIT FLAG
RUNDIC:	STKVAR<EVEC,LOCFN,WFLAG,FKHNDL,FILJFN>
	MOVEM C,EVEC		;SAVE OFFSET IN ENTRY VECTOR
	MOVEM D,LOCFN		;SAVE LOCATION TO PUT FORK NUMBER
	MOVEM Q1,WFLAG		;SAVE WAIT FLAG
	GTJFN
	 RET			;FAILED
	MOVEM T1,FILJFN		;SAVE JFN
	MOVX T1,CR%CAP		;XMIT CAPABILITIES
	CFORK			;CREATE A FORK FOR CHECKD
	 JRST [	EXCH T1,FILJFN	;SAVE ERROR CODE. GET JFN
		RLJFN		;RELEASE IT
		 NOP
		MOVE T1,FILJFN	;GET BACK ERROR CODE
		RET]		;AND DONE
	MOVEM T1,FKHNDL		;SAVE FORK HANDLE
	SKIPN T2,LOCFN		;WANT TO SAVE FORK NUMBER?
	IFSKP.			;YES
	  CALL GSWFRK		;(T1/T1) GET SYSTEM WIDE FORK NUMBER
	   JFCL			;IGNORE ERROR
	  MOVEM T1,(T2)		;SAVE FORK NUMBER OR ERROR CODE WHERE SPECIFIED
	ENDIF.
	MOVE T2,JOBBIT		;SET TO SAME AS OURS
	SPRIW			;BY SETTING PRIORITY WORD
	ERJMP .+1		;JUST IN CASE
	HRL T1,FKHNDL		;FORK HANDLE TO LH
	HRR T1,FILJFN		;JFN TO RH
	GET
	 ERJMP [MOVE T1,FKHNDL	;GET FORK HANDLE
		KFORK		;KILL THE FORK
		RET]		;AND DONE
	MOVE T1,FKHNDL		;GET FORK HANDLE
	MOVE 2,EVEC		;2/OFFSET IN ENTRY VECTOR
	SFRKV			;START AT MAIN ENTRY
	 ERJMP [MOVE T1,FKHNDL	;GET HANDLE
		KFORK		;KILL FORK
		RET]
	SKIPN WFLAG		;WANT TO WAIT?
	RETSKP			;NO. RETURN NOW
	WFORK
	KFORK
	RETSKP			;ALL DONE
;ROUTINE TO SETUP A MONITOR FORK TO HANDLE ERRORS
; ACCEPTS: T1/ 30 BIT ADDRESS OF ROUTINE TO TRANSFER TO ON ERROR
;
MONBKX::MOVEM 1,MONBK
	MOVEI 1,.FHSLF		;1/THIS FORK
	MOVEI 2,MICHN		;2/CHANNELS TO ENABLE
	MOVEM 2,MONCHN		;MAKE THE MONITOR TAKE INTERRUPTS ON THEM
	AIC			;ACTIVATE CHANNELS 34 AND 35
	 ERJMPR [BUG.(CHK,MONBKB,MEXEC,SOFT,<Cannot set monitor error interrupt>,<<T1,LSTERR>>,<

Cause:	The monitor was attempting to enable interrupts on the monitor error 
	channels. This BUG. indicates that the AIC failed.

Data:	LSTERR - Last process error

>,R)]
	RET

;ROUTINE TO MAKE RESTART ENTRY IN SYSERR FILE

LOGSST:	TRVAR <<RDDBFR,.RLBSZ>>
	SAVEQ
	JE SF%MST,FACTSW,LOGSS3	;JUMP IF AUTO RESTART
	MOVE T1,DBUGSW		;Get mode of system
IFE STANSW,<
	CAIE T1,3		;Default startup stuff?
>;IFE STANSW
IFN STANSW,<
	CAIGE T1,2		;Default startup or standalone?
>;IFN STANSW
	JRST LOGSS1		;No
	MOVX T1,<ASCIZ /SA/>	;yes. It is Stand-alone then
	MOVEM T1,RDDBFR		;Stash it
	JRST LOGSS3		;And go on
LOGSS1:	TMSG <Why reload? >	;MANUAL RESTART, FIND OUT WHY
	HRROI T1,RDDBFR
	MOVX T2,RD%BRK+RD%BEL+RD%RAI+RD%CRF+20*5
	MOVEI T3,0
	RDTTY			;GET ANSWER
	 JFCL
	SETZ T3,		;FLUSH TERMINATOR (PRESUMABLY NL)
	DPB T3,T1
	MOVE T1,[POINT 7,RDDBFR]
QLP:	ILDB T2,T1		;GET A CHAR
	CAIE T2,40		;SPACE?
	CAIN T2,11		;TAB?
	JRST QLP		;ONE OF THE TWO
	CAIN T2,"?"		;DID HE ASK FOR HELP?
	JRST [HRROI T1,LOGMSG	;GET THE HELP MESSAGE
	      PSOUT		;OUTPUT IT
	      JRST LOGSS1]	;TRY AGAIN
	MOVE T1,[-RLALEN,,RLATAB] ;SET TO VERIFY HIS ANSWER
	CALL MATRLA		;SEE IF ANSWER MATCHES TABLE
	 JRST LOGSS2		;NO, TELL HIM HIS CHOICES
	AOBJP T1,LOGSS3		;YES, SEE IF IT'S UNIQUE
	CALL MATRLA		;ANY OTHER MATCHES?
	 JRST LOGSS3		;NO, THIS IS A WINNER
LOGSS2:	TMSG <  Not a valid response (?=HELP)
>
	JRST LOGSS1		;TRY, TRY AGAIN

LOGSS3:	MOVX T1,RL%LEN
	MOVX T2,RL%SIZ
	CALL ALCSEB		;GET SYSERR STORAGE
	 JRST [BUG.(CHK,SYSERF,MEXEC,HARD,<LOGSST - No SYSERR storage for restart entry>,,<

Cause:	ALCSEB in LOGSST failed to allocate a SYSERR storage block.

Action: As a result, there will be no restart reason entered in ERROR.SYS.

>)
		RET]
	MOVEM T1,Q1
	MOVE T2,[-NWHYIT,,WHYIT]
	CALL SEBCPY		;COPY DATA INTO BLOCK
	 JFCL
	MOVE T2,[-1,,[SEBPTR RL%OPR,SBTSTR,RDDBFR]]
	MOVE T3,FACTSW
	TXNN T3,SF%MST		;USE OPR ANSWER IF MANUAL START
	MOVE T2,[-1,,[SEBPTR RL%HLT,SBTWD,BUGHLT]]
	MOVE T1,Q1		;USE BUGHLT ADDRESS OTHERWISE
	CALL SEBCPY
	 JFCL
	MOVE T1,Q1
	CALL QUESEB		;QUEUE BLOCK FOR SYSERR FILE
	RET
;ROUTINE TO SEE IF RDDBFR MATCHES ENTRY IN TABLE
;CALL T1/AOBJN POINTER TO TABLE
;RETURNS +1 NO MATCH
;RETURNS +2 MATCH
MATRLA:	MOVE T2,[POINT 7,RDDBFR,] ;POINTER TO HIS ANSWER
	MOVE T3,[POINT 7,(T1),]   ;POINTER TO LEGAL ANSWERS
MATRL1:	ILDB T4,T2		;GET NEXT CHAR OF HIS ANSWER
	JUMPE T4,MATRL3		;DONE IF A ZERO CHARACTER
	CAIE T4," "		;END OF FIRST WORD?
	CAIN T4,.CHLFD		;END OF LINE?
	JRST MATRL3		;YES
	ILDB CX,T3		;NO, GET NEXT CHAR OF THIS ANSWER
	CAIN CX,(T4)		;MATCH?
	JRST MATRL2		;YES, KEEP ON GOINT
	AOBJN T1,MATRLA		;NO, TRY NEXT TABLE ENTRY
	RET			;NO MATCH -  NON SKIP RETURN
MATRL2:	TLNN T3,760000		;END OF THIS TABLE ENTRY?
	RETSKP			;YES, SKIP RETURN
	JRST MATRL1		;NO, LOOK AT NEXT CHARACTER HE TYPED
MATRL3:	CAME T2,[POINT 7,RDDBFR,6] ;ANYTHING BEFORE THE END-OF-LINE?
	RETSKP			;YES, TAKE MATCH-RETURN
	RET			;NO, NON-MATCH

RLATAB:	ASCIZ	/OPR/
	ASCIZ	/PARIT/
	ASCIZ	/POWER/
	ASCIZ	/STATI/
	ASCIZ	/HARDW/
	ASCIZ	/HALT/
	ASCIZ	/HUNG/
	ASCIZ	/PM/
	ASCIZ	/CM/
	ASCIZ	/SA/
	ASCIZ	/NEW/
	ASCIZ	/SCHED/
	ASCIZ	/OTHER/
RLALEN==.-RLATAB
LOGMSG:	ASCIZ #
The following is a list of valid responses.  Any comment (up to 72
characters) may be appended to a response.  In case more than one
response is appropriate, choose the earliest one in the list.

Previous system problem:	Different monitor wanted:
	OPR				NEW
	PARITY				SCHED
	POWER
	STATIC			Operator doesn't know or not in list:
	HARDWARE			OTHER
	HALT
	HUNG
	PM
	CM
	SA

#

;POINTER TABLE TO BUILD RELOAD ENTRY

WHYIT:	SEBPTR 0,SBTEVC,SEC%RL	;EVENT CODE (IMMEDIATE)
	SEBPTR RL%SVN,SBTSTR,SVN ;SYSTEM NAME
	SEBPTR RL%STD,SBTWD,SYSTAD ;BUILD TAD
	SEBPTR RL%VER,SBTWD,[EXP SVNM] ;SYSTEM VERSION NUMBER
	SEBPTR RL%SER,SBTWD,APRSER ;APR SERIAL NUMBER
NWHYIT==.-WHYIT

;LOCAL ROUTINE TO READ TAD FROM CTY
;	CALL RDDTAD
; RETURN +1 ALWAYS, 2/ TAD

RDDGTD:	STKVAR <<RDDBFR,20>>
RDDGT1:	HRROI 1,RDDBFR
	MOVE 2,[RD%BRK+RD%BEL+RD%RAI+20*5]
	MOVEI 3,0
	RDTTY			;READ LINE FROM CTY
	 JRST RDDGT2		;FAILED, REPROMPT
	TXNN 2,RD%BTM		;BREAK CHAR TERMINATED INPUT?
	JRST RDDGT2		;NO, GARBAGE INPUT
	HRROI 1,RDDBFR
	MOVEI 2,0
	IDTIM			;CONVERT STRING TO TAD
	 JRST RDDGT2		;INVALID, REPROMPT
	RET			;OK, RETURN IT

RDDGT2:	TMSG <
? Invalid, please try again in form MMM-DD-YY HHMM: >
	JRST RDDGT1		;TRY AGAIN


;EACH SPECIAL JOB CALLS THIS TO DETACH AND START THE NEXT ONE

DONSJ:	CALL LOGONM		;RECORD START OF CURRENT JOB ON LOGGING TERMINAL
	MOVE 4,CTRLTT		;SAVE THIS JOB'S CONTROLLING TERMINAL
	DTACH			;DETACH THE CURRENT JOB
	MOVE 1,JB0TT
	HRRM 1,PRIMRY		;USE JOB 0 TTY FOR ANY OUTPUT
	MOVE 1,JOBNO		;GET CURRENT JOB NUMBER
	CAIL 1,NSPECJ-1		;MORE SPECIAL JOBS TO DO?
	JRST [	MOVX T1,SF%PTY!SF%CTY ;NO. ALLOW CTY AND PTY LOGINS
		IORM T1,FACTSW
		RET]		; AND DON'T CREATE ANOTHER JOB
	MOVE 2,4		;YES. GET LINE NUMBER FOR CALL
	CALLRET SPCSTJ		;START ANOTHER JOB ON SAME TTY

SPCSTJ:	NOSKED
	PUSH P,T2		;SAVE LINE NUMBER
	CALL STADYN		;GET ADDRESS OF DYNAMIC DATA
	 SKIPA			;NOT FULLY ACTIVE
	JRST [	POP P,2
		OKSKED
		RET]
	JUMPG T2,SPCST1		;IF TEMPORARILY ACTIVE, WAIT
	POP P,2			;GET LINE NUMBER BACK
	SETOM TTACTL(T2)	;INDICATE JOB STARTING
	MOVEI 1,JOBSRT		;REQUEST JOB STARTUP FROM SCHED
	HRL 1,2
	CALL SCDRQ7
	OKSKED
	RET

;LINE IS TEMPORARILY IN USE. WAIT UNTIL IT'S AVAILABLE

SPCST1:	POP P,1			;RESTORE LINE NUMBER
	OKSKED
	HRLZS T1		;T1/ (LINE NUMBER,,ROUTINE)
	HRRI T1,TSACT1		;ROUTINE TO WAIT FOR LINE
	PUSH P,T2
	MOVSI T2,FHV1		;LOW BLOCK PRIORITY
	HDISMS
	POP P,T2
	JRST SPCSTJ

	SUBTTL Mini-EXEC

;'MINI-EXEC' - SIMPLE COMMAND INTERPRETER FOR SPECIAL FUNCTIONS

	SWAPCD

EXEC2:	MOVE T1,JOBBIT
	IFXN. T1,LOGIOB		;LOGIN OR OUT?
	  BUG.(CHK,EXILGO,MEXEC,SOFT,<EXECI - Interrupt during login or logout>,,<

Cause: Control has passed to the mini-exec because the top fork hit a
	terminating condition or monitor interrupt.  The top fork EXEC may
	have been wiped out.  In addition, the job was trying to log in or
	out.

Action: The fork is put into an infinite wait state since any other action
	might lead to further itraps, interrupts, looping, etc.
>)
	  WAIT%			;YES, SOME KIND OF DISASTER. GO AWAY QUIETLY.
	ENDIF.
	MOVEI 1,100		;ESTABLISH CORRECT TTY MODES
	MOVE 2,NORMTF
	SFMOD
	MOVE 2,TTICB1
	MOVE 3,TTICB2
	SFCOC
	CALL DTIALL		;DISABLE ALL TERMINAL INTERRUPTS
	MOVE 1,[XWD 20,^D34]	;T1/ CTRL/P ON CHANNEL 34
	ATI			;ASSIGN CONTROL-P FOR INTERRUPTS
	MOVE 1,[MSEC1,,EXECI]	;SETUP TO GET INTERRUPTS IN MON
	CALL MONBKX
	MOVE 2,JOBNO
	HRRZ 1,JOBDIR(2)
	IFE. T1
	  SETZM CAPMSK		;IF NOT LOGGED, FLUSH ALL CAPS
	  SETZM CAPENB
	  MOVE 3,CTRLTT
	  CAME 3,CTYLNO		;ALLOW MINI-EXEC ONLY ON CTY
	ANSKP.
	  MOVE T3,SPJCAP	;CTY, NOT LOGGED IN, GIVE ALL CAPABILITIES
	  MOVEM T3,CAPENB
	  MOVEM T3,CAPMSK
	  MOVEI 3,OPERDN	;YES, GET DIRECTORY NUMBER OF <OPERATOR>
	  MOVEM 3,JOBDIR(2) 	;INDICATE LOGGED IN AS <OPERATOR>
	  STOR 3,JSDIR	;SAVE AS CONNECTED DIRECTORY
	  SETZRO JSCDF	;NO STRING IN JSB
	  MOVE 3,STRTAB+PSNUM ;GET SDB ADDRESS OF STRUCTURE 0 (PUBLIC)
	  LOAD 3,STRUC,(3) ;GET ITS UNIQUE STRUCTURE CODE
	  STOR 3,JSUC	;SAVE AS CONNECTED STRUCTURE CODE
	  MOVE 3,[[3
	  	 ASCIZ "OPERATOR"],,USRNAM]
	  BLT 3,USRNAM+2	;SET DEFAULT USER NAME TO OPERATOR
	ENDIF.
	JN JBMX,,EXECT0		;IF BEEN IN MX BEFORE, DONT CHECK CAPS
	MOVE 1,CAPENB		;LOOK AT CAPS, ALLOW MINI-EXEC
	TRNE 1,SC%WHL		;ONLY IFWHEEL
	IFSKP.
	  SKIPE FORKN		;OTHERWISE,
	  HALTF			;HALTF IF BELOW EXEC
	  SETONE JSFLO		;REMEMBER THE FORCED LOGOUT
	  JRST LOGO		;LOGOUT IF TOP FORK
	ENDIF.
	SETONE JBMX		;REMEMBER THAT JOB WAS IN MINI-EXEC
	; ..

;MINI-EXEC...

EXECT0:	TMSG (MX>)
EXECT1:	PBIN			;GET USER INPUT
	CAIN T1,.CHCRT		;FLUSH CR
	JRST EXECT1
	CAIL 1,"A"+40		;LC CHAR?
	CAILE 1,"Z"+40
	SKIPA			;NO
	SUBI 1,40		;YES, CONVERT
	CAIN T1,.CHLFD		;IGNORE BLANK LINE
	JRST EXECT0
	MOVSI 4,-NXCMD		;SCAN COMMAND TABLE
EXECT2:	HLRZ 2,XCMD(4)		;GET KEY LETTER FOR THIS COMMAND
	CAMN 1,2		;SAME AS JUST TYPED?
	JRST [	HRRZ 2,XCMD(4)	;YES, GET DISPATCH ADDRESS
		JRST 0(2)]	;GO TO IT
	AOBJN 4,EXECT2		;TRY ALL COMMANDS
	JRST EXERR		;NOT FOUND, INDICATE ERROR

;MINI-EXEC COMMANDS

DEFINE CM (NAM,LOC)<
	XWD "NAM",LOC>

XCMD:
   REPEAT 0,<
	CM B,EBLT		;BLT SWP MON
   >
	CM D,EDMP		;DUMP ON FILE
	CM E,GEX		;EXEC
	CM G,EGET		;GET FILE
	CM J,EJMP		;JUMP TO ADDRESS
	CM R,EREST		;RESET
	CM S,EST		;START
	CM <^>,MRETN		;DO MRETN
	CM </>,TODDT		;GO TO MDDT
NXCMD==.-XCMD
;'/' - ENTER MDDT

TODDT:	GTOKM (.GOMDD,)		;ASK FOR PRIVS
	JRST LMDDT		;GO TO DDT


;'BLT SWP MON' - BLT SWAPPABLE CODE TO USER SPACE.  SHOULD DO RESET FIRST,
;THEN DUMP ON DTA--

   REPEAT 0,<
EBLT:	TMSG <LT SWP MON>
	CALL OKGO
	MOVE 2,SWCEND		;LST PAGE
	LSH 2,^D9
	MOVE T1,[NRCOD,,NRCOD]
	XBLTMU [BLT 1,777(2)]
	JRST EXEC2
   >				;END OF REPEAT 0
;'RESET'

EREST:	TMSG <ESET>
	CALL OKGO
	CALL DRESET		;DO THE RESET
	JRST EXEC2

;DRESET IS COMMON ROUTINE USED BY SEVERAL COMMANDS TO DO A RESET

DRESET:	MOVEI 1,-4
	KFORK			;KILL ALL FORKS
	MOVNI 1,1
	MOVSI 2,400000
	MOVE 3,[1B0+1000]	;CLEAR ALL PAGES FROM USER MAP
	PMAP
	MOVNI 1,1		;CLOSE ALL FILES
	CLOSF
	JFCL
	RET

;OKGO - ROUTINE TO LOOK FOR CONFIRMATION AFTER MINI-EXEC HAS
;TYPED THE COMPLETION OF THE COMMAND.

;	CALL OKGO

;RETURNS +1: CONFIRMATION FOUND
;IF NO CONFIRMATION WAS FOUND, GOES TO ERROR ROUTINE

OKGO:	PBIN
	CAIN T1,.CHCRT		;FLUSH CR
	JRST OKGO
	CAIN T1,.CHLFD		;CRLF MEANS GO
	RET
NODD1:	POP P,1			;ANYTHING ELSE MEANS ABORT
	JRST EXERR

;'EXEC'

GEX:	TMSG <XEC>
	CALL OKGO		;CONFIRM
	CALL DRESET		;CLEAR PREVIOUS PROGRAM TO GUARANTEE CINITF IN EXEC IS CLEAR


;HERE TO GET A NEW COPY OF THE EXEC. REACHED FROM MINI-EXEC 'EXEC'
;COMMAND OR WHEN A NEW JOB IS BEING CREATED.  IF FILE EXISTS,
;GOES TO START IT. IF NOT, PRINTS MESSAGE AND GOES TO MINI-EXEC

STEX:	MOVSI 1,(GJ%OLD!GJ%PHY!GJ%SHT)	;OLD FILE+SHORT FORM
	HRROI 2,[ASCIZ /DEFAULT-EXEC:/]
	GTJFN
STEXF:	JRST [	SKIPE CRJFLG	;IS THIS A CRJOB FAILURE?
		JRST CRJMEX	;YES. GO GIVE FAIL CODE
		TMSG <NO EXEC>
		JRST EXCRR]
	HRLI 1,.FHSLF
	GET
	ERJMP STEXF		;CATCH FAILURE OF GET
	SKIPN CRJFLG		;CREATED JOB?
	JRST GEX1
	RET			;RETURN TO FINISH CRJOB STUFF

CRJMEX:	MOVEI T1,CRJBX2		;PREVENT CRJOB GETTING INTO MINIEXEC
	CALL SETANS		;GO SETUP CRJANS
	JRST LOGO		;AND FLUSH OUT THIS JOB.

;'JUMP TO ADDRESS' - JUMP TO USER ADDRESS

EJMP:	TMSG <UMP TO >
	MOVEI 1,100
	MOVEI 3,^D8		;GET OCTAL ADDRESS
	NIN
	 JRST EXERR
	HRRZM 2,-1(P)		;SAVE ADDRESS
	BKJFN			;BACKUP TO READ TERMINATOR
	 JFCL
	CALL OKGO
	JRST MRETN		;RETURN TO USER ADDRESS ON STACK
;'GET FILE'

EGET:	TMSG <ET FILE >
	MOVSI 1,(1B2+1B4+1B16+1B17) ;OLD FILE,CONFIRM,IFOF,SHORT
	MOVE 2,[XWD 100,101]
	GTJFN
	 JRST EXERR
	HRLI 1,400000		;THIS FORK
	GET
	 ERJMP EXERR
	JRST EXEC2

;'START' - STARTS PROGRAM GOTTEN VIA 'GET'

EST:	TMSG <TART>
	CALL OKGO
GEX1:	MOVE 1,EVADDR
	JUMPN 1,.+2
	UMOVE 1,120		;USE JOBSA
	MOVEM 1,-1(P)
	JRST MRETN

;'DUMP ON FILE'

EDMP:	TMSG <UMP ON FILE >
	MOVSI 1,(1B0+1B3+1B4+3B17) ;NEW V,PNT O/N,CONFRM,IFOF,SHRT
	MOVE 2,[XWD 100,101]
	GTJFN
	JRST EXERR
	HRLI 1,400000		;THIS FORK
	MOVE 2,[XWD -1000,520000] ;SAVE ALL ADDRESS SPACE
	SETZ 3,
	SSAVE
	JRST EXEC2

;ERROR CONDITION - PRINT A QUESTION MARK AND GO BACK TO START OF
;MINI-EXEC

EXERR:	TMSG <  ?>
	MOVEI 1,100
	CFIBF			;CLEAR INPUT BUFFER

;PRINT CARRIAGE RETURN/LINE FEED

EXCRR:	SKIPE CRJFLG		;IS THIS A CRJOB?
	JRST CRJMEX		;YES. GET OUT OF MINIEXEC.
	TMSG <
>
	JRST EXEC2

EXCRRW:	TMSG <
>
	JRST EXEC2
	SUBTTL

;PSI TRAPPED TO HERE

EXECI::	XCT FRKNOP		;NOP UNLESS MDDT BPT SET
	EXCH 1,ITFFL		;SAVE 1, GET TRAP FL
	TLNN 1,(UMODF)		;USER?
	JRST EXECI1		;NO
	MOVEM 1,FFL		;SET FLAGS
	MOVE 1,ITFPC		;SET PC
	MOVEM 1,FPC		;YES, ENTER MONITOR AT THAT LOC
	MOVE 1,ITFFL		;RESTORE AC1
EXECI2:	MCENTR
	SETOM PRIMRY
	SKIPE CRJFLG		;IS THIS A CRJOB?
	JRST CRJMEX		;YES. GET OUT OF MINIEXEC.
	MOVEI 1,100
	CFIBF			;CLEAR INPUT BUFFER
	 ERJMP	EXECI4		;error while attempting to LOG IN/OUT
	CALL CLRINT		;CLEAR THE SOFTWARE INTERRUPT SYSTEM
	TRNN 2,2		;CHANNEL 34?
	JRST EXECI3
	MOVEI 1,-4
	FFORK			;FREEZE FORKS
	MOVEI 1,101
	CFOBF			;CLEAR OUTPUT BUFFER
	 ERJMP	EXECI4		;error while attempting to LOG IN/OUT
	TMSG <
ABORT
>
	JRST EXEC2

EXECI1:	MOVE P,UPP		;RESTORE TOP OF PDL
	MOVE 2,1(P)		;GET USER PC
	MOVEM 2,FPC		;STORE PC
	MOVX T1,USRCTX		;SET USER MODE FLAGS WORD
	MOVEM 1,FFL
	JRST EXECI2

EXECI3:	TMSG <
INTERRUPT AT >
	MOVEI 1,101
	HRRZ 2,UPP
	MOVE 2,1(2)		;GET TOP PC
	MOVEI 3,10		;RADIX
	NOUT			;PRINT ADDRESS
	 JFCL
	JRST EXCRRW		;TO MINI-EXEC IF SC%WHL

EXECI4:	MOVE T1,JOBNO		;get current job number
	HLRZ T1,JOBPT(T1)	;get controlling TTY:
	MOVE T2,LSTERR		;get last error this process
	BUG.(INF,LGFAIL,MEXEC,SOFT,<LGOUT or LOGIN JSYS failed>,<<T1,JOBPT>,<T2,LSTERR>>,<

Cause:	An attempt to log in/out a job has failed when it should have succeded.
	The most likely cause of this is terminals that have been TTYSTPed,
	then a LGOUT or LOGIN JSYS was attemped.  An attempt to detach the
	terminal, then logout the job is made.  If either of these fail,
	the job is put in a permanent wait state.

Data:	JOBPT - The terminal number
	LSTERR - The reason of the failure
>)
	DTACH			;attempt to detach myself
	 ERJMP	.+1		;ignore errors
	SETOM	T1		;me
	LGOUT			;logout myself
	 ERJMP	.+1		;ignore errors
	WAIT			;can't log myself out, go to sleep
	 ERJMP	.+1		;ignore errors
	JRST	.-2		;try to sleep again.


;JSYS TO ENTER MDDT

.MDDT::	MCENT
	MOVEI 1,SC%WHL+SC%OPR
	TDNN 1,CAPENB
	JRST WHEELX		;NO PRIVS
	JRST TODDT

	RESCD

;HERE WHEN USER TYPES "EDDT$G" IN MDDT.  DON'T GO TO EDDT UNLESS IT
;IS LOADED AND LOCKED DOWN.  USERS WHO WANT TO ANYWAY CAN TYPE "DDTX$G".

EDDT=:<MSEC1,,.>		;START IN SECTION 1 ON EDDT$G FROM MDDT

	SKIPE DDTPRS		;IS EDDT PRESENT AND LOCKED?
	JRST @[SYMSEC,,DDTX]	;YES, GO TO IT
	TMSG <
? EDDT is not locked down - call LCKINI from MDDT first
>
	JRST LMDDT		;RETURN TO MDDT


;BUGHLT IN JOB CONTEXT TRAPS TO HERE

EXBUGH::SETZM NSKED		;BE OKSKED
	SETZM CRSKED		;BE NOT 'CRITICAL SECTION'
	SETOM TRAPC
	MOVE 1,UPDL		;RESET STACK, ETC.
	MOVEM 1,FPC		;SET PC
	MOVX T1,USRCTX		;SET USER MODE FLAGS WORD
	MOVEM 1,FFL
	MCENTR
	SETZM INTDF
	SKIPN JOBNO		;JOB 0?
	JRST CHKRI		;YES, INTERRUPT
	HRRZ 1,PRIMRY
	HRROI 2,[ASCIZ /
BUGHLT at /]
	SETZ 3,
	SOUT
	HRRZ 2,BUGHLT
	MOVEI 3,^D8
	NOUT
	JFCL
	TMSG <
>
	ITERX			;GENERATE ITRAP

	SWAPCD

;HALT SYSTEM - REQUIRES SC%MNT (OR SC%WHL ETC.) CAPABILITY
;ACCEPTS TIME OF SYSTEM SHUTDOWN AND INITIATES SHUTDOWN PROCESS,
;INCLUDING NOTIFYING USERS, ETC.  ALSO ACCEPTS TIME WHEN SYSTEM
;WILL BE BACK UP WHICH IS AVAILABLE FOR USER INFORMATION ONLY.
; 1/ SHUTDOWN TIME (GTAD FORMAT)
; 2/ EXPECTED UP TIME (GTAD FORMAT)
IFN STANSW,<
; 3/ POINTER TO SHUTDOWN STRING
>;IFN STANSW
;	HSYS
; RETURNS +1: ERROR
; RETURNS +2: SUCCESS

.HSYS::	MCENT
	MOVE 2,CAPENB		;CHECK USER CAPABILITIES
	TXNN 2,SC%WHL+SC%OPR+SC%MNT ;USER ALLOWED TO DO HALT?
	RETERR(CAPX2)		;NO, RETURN BAD
	JUMPG 1,HSYS1		;JUMP UNLESS ABORTING SHUTDOWN
	MOVE T1,HSYST1		;GET OLD TIME
	JUMPE T1,HSYS0		;IF NONE, DONT TYPE MESSAGE
	SETZM HSYST1		;CLEAR OLD TIME
	CALL TADDIF		;GET MILLISECONDS TO SHUTDOWN
	HRROI T2,[ASCIZ/
[Shutdown canceled]
/]
	MOVX T3,SF%MS1
	TDNE T3,FACTSW		;WANT LEVEL 1 MESSAGES?
IFE STANSW,<
	SKIPGE HSYST3		;WAS A MESSAGE EVER PRINTED
>;IFE STANSW
IFN STANSW,<
	CAML T1,[^D<2*60*60*1000>] ;WERE WE LESS THAN 2 HOURS TO GO?
>;IFN STANSW
	SKIPA
	CALL ALLMSG		;YES, INFORM USERS OF CANCELLATION
	CALL MSSSVD		;(/) ANY DISKS SERVED?
	IFSKP.
	   CALL CFCBRD		;(/) TELL OTHER SYSTEMS
	    NOP			;NO ONE ELSE OUT THERE
	ENDIF.
IFN STANSW,<
	GTOKM (.GOHSY,,MRETN)	;CALL ACJ TO UPDATE DOWNTIME QUEUE
>;IFN STANSW
HSYS0:	SMRETN			;SUCCESSFUL RETURN

HSYS1:	PUSH P,1		;HOLD THE DESIRED SHUTDOWN
	CALL TADDIF		;COMPUTE MILLISECONDS TO SHUTDOWN
IFE STANSW,<
	TLNE 1,770000		;OVER A WEEK AHEAD, OR NEGATIVE?
	RETERR(TIMEX2)		;YES, GIVE BAD TIME FAILURE
	POP P,2			;RECOVER SHUTDOWN TIME
	MOVEM 2,HSYST1		;STORE FOR EXEC TO SEE
	SETOM HSYST3		;FLAG FOR FIRST MESSAGE
>;IFE STANSW
IFN STANSW,<
	SKIPGE T1		;NEGATIVE?
	 RETERR(TIMEX2)		;YES, GIVE BAD TIME FAILURE
	POP P,HSYST1		;RECOVER SHUTDOWN TIME FOR EXEC TO SEE
	MOVX T2,^D<2*60*60*1000> ;SET SO FIRST MESSAGE IS 2 HOURS BEFORE
	MOVEM T2,HSYST3		;SHUTDOWN
>;IFN STANSW
	UMOVE 2,2		;GET EXPECTED UP TIME
	CAMG 2,HSYST1		;CHECK RANGE
	SETZ 2,			;JUNK, ASSUME UNKNOWN
	MOVEM 2,HSYST4		;SAVE FOR EXEC TO TELL USERS
IFN STANSW,<
	SETZM HSYST5		;CLEAR REASON STRING
	MOVE T1,[HSYST5,,HSYST5+1]
	BLT T1,HSYST5+<NHSYSR-1>
	XCTU [HRRZ T1,3]	;GET USER'S POINTER
	IFN. T1			;ONLY DO IF REASON STRING GIVEN
	  MOVSI T2,-NHSYSR	;FORM AOBJN POINTER TO TABLE
	  DO.
	    UMOVE T3,(1)	;GET WORD FROM USER'S REASON
	    MOVEM T3,HSYST5(2)	;STORE IT IN REASON STRING
	    ADDI T1,1		;GO TO NEXT WORD OF USER'S STRING
	    TRNE T3,376		;LAST WORD OF STRING?
	     AOBJN T2,TOP.	;NO, LOOP BACK UNTIL OUR STRING FILLED
	  ENDDO.
	  GTOKM (.GOHSY,,MRETN)	;YES, CALL ACCESS CONTROL JOB TO UPDATE QUEUES
	ENDIF.
>;IFN STANSW
	AOS JB0FLG		;POKE JOB 0 TO DO MSG
	SMRETN
;COMPUTE TIME UNTIL SHUTDOWN IN MILLISECONDS
; A/ TAD OF SHUTDOWN
;	CALL TADDIF
; RETURN +1, A/ MILLISECONDS TO SHUTDOWN

TADDIF:	PUSH P,1
	CALL LGTAD		;GET CURRENT TIME AND DATE
	POP P,2
	SUBM 2,1		;GET POSITIVE DIFFERENCE OF TIMES
	CAML T1,[^D8,,0]	;WITHIN 8 DAYS?
	JRST [	MOVSI T1,377777	;NO, RETURN VERY LARGE NUMBER
		RET]
	MUL T1,[^D<24*3600*1000>]	;MILLISECONDS/DAY
	DIV T1,[1B17]		;SHIFT BINARY POINT
	RET

;HSYST1 AND HSYST4 ARE A GETAB TABLE

IFE STANSW,<
NHSYST==2			;NUMBER OF VALUES IN GETAB TABLE
NR HSYST1,1			;SYSTEM SHUTDOWN TIME OR 0
NR HSYST4,1			;EXPECTED UP TIME
>;IFE STANSW
IFN STANSW,<
NHSYSR==20			;NUMBER OF WORDS IN REASON
NHSYST==NHSYSR+2		;NUMBER OF VALUES IN GETAB TABLE
NR HSYST1,1			;SYSTEM SHUTDOWN TIME OR 0
NR HSYST4,1			;EXPECTED UP TIME
NR HSYST5,NHSYSR+1		;ROOM FOR A REASON
>;IFN STANSW

NR HSYST2,1			;INTERVAL (IN MS) TO NEXT MSG TIME
NR HSYST3,1			;TIME OF NXT MSG IN MS BEFORE SHUTDOWN

;POINTS (IN MINUTES BEFORE SHUTDOWN) AT WHICH TO DO NOTIFICATION

CTIMS:	^D<BYTE (9) 60,30,15,10>
	^D<BYTE (9) 5,1,0>

;ROUTINE TO TYPE SYSTEM SHUTDOWN MESSAGE IF NECESSARY.
;CALLED ONLY BY JOB 0 CHKR.

CHKHSY:	SKIPE A,HSYST1		;SHUTDOWN ABORTED?
	CAMN A,[-1]		;OR IS SYSTEM SHUTDOWN?
	RET			;YES
	CALL TADDIF		;COMPUTE TIME UNTIL SHUTDOWN
IFE STANSW,<
	MOVE 3,HSYST3		;DUE TIME FOR MESSAGE
	CAMN 3,[-1]		;FIRST TIME HERE?
	JRST CHKHS3		;YES - GIVE MESSAGE ANYWAY
>;IFE STANSW
	CAMLE 1,HSYST3		;NO - MESSAGE DUE NOW?
	JRST [	SUB 1,HSYST3	;NO, COMPUTE INTERVAL TO NEXT MSG
		MOVEM 1,HSYST2	;LEAVE IT FOR CHKR
		RET]		;RETURN QUIETLY
CHKHS3:	ADDI 1,^D30000		;ROUND TO NEAREST MINUTE
	IDIVI 1,^D60000		;CONVERT TO INTEGER MINUTES
	JUMPLE 1,CHKHS4		;IF NO TIME LEFT, GO KILL SYSTEM
	CALL THSYS		;SEND MSG TO ALL TTYS
	CAILE 1,^D60		;LESS THAN AN HOUR?
	JRST [	MOVEI 2,^D60	;NO - SET NEXT MESSAGE FOR 1 HOUR NOW
		CAILE 1,^D120	;BETWEEN 1 AND 2 HOURS
		MOVEI 2,^D120	;MAKE FIRST NOTICE BE AT 1 HOUR
		JRST CHKHS5]
	MOVE 3,[POINT 9,CTIMS]	;SETUP TO FIND NEXT NOTIFY TIME
	ILDB 2,3		;GET A TIME FROM LIST
	CAMG 1,2		;SHORTER THAN ACTUAL TIME REMAINING?
	JRST .-2		;NO, KEEP LOOKING
CHKHS5:	IMULI 2,^D60000		;CONVERT MINUTES TO MILLISECONDS
	MOVEM 2,HSYST3		;SET AS NEXT MESSAGE TIME
	JRST CHKHSY		;FINAL CHECK AND RETURN

;SHUTDOWN TIME HAS ARRIVED, COMMENCE SHUTDOWN.

CHKHS4:	MOVX T1,SF%RMT!SF%LCL!SF%PTY!SF%MCB!SF%NVT
	ANDCAM T1,FACTSW	;ONLY ALLOW CTY TO LOGIN
	MOVX T1,SF%CTY		;MAKE SURE CTY CAN LOG IN
	IORM T1,FACTSW		;EVEN IF HE COULD NOT DO IT BEFORE
	CALL DWNMSG		;SEND LAST MESSAGE
	SETOM HSYST1		;CLEAR FLAGS IN CASE RESTARTED
	MOVE T1,CTYLNO		;SET UP CTY MESSAGE
	TXO T1,.TTDES
	HRROI T2,[ASCIZ/
	OPERATOR - WAIT FOR THE MESSAGE 'Shutdown complete' BEFORE
	ENTERING COMMANDS TO PARSER
/]
	SETZ T3,		;STOP ON ZERO BYTE
	SOUT			;SEND MESSAGE TO CTY
;...
;...
	CALL MSSSVD		;(/) ANY SERVED DISKS?
	IFSKP.
	   MOVE T1,CTYLNO	;YES, SET UP CTY MESSAGE
	   TXO T1,.TTDES
	   HRROI T2,[ASCIZ/
	ALSO, MAKE SURE OTHER SYSTEMS IN THE CLUSTER HAVE
	COMPLETED ALL NECESSARY STRUCTURE DISMOUNTS BEFORE THIS
	SYSTEM IS SHUTDOWN

/]
	   SETZ T3,
	   SOUT
	   CALL CFCBRD		;(/) TELL OTHER SYSTEMS
	    NOP			;NO ONE ELSE OUT THERE
	ENDIF.
	MOVSI T1,(1B1)		;CREATE FORK WITH SAME CAPS
	CFORK
	 BUG.(HLT,HSYFRK,MEXEC,soft,<HSYS - Job 0 CFORK failed>,,<

Cause:	This will occur if the CFORK JSYS fails to create a fork for
	shutting down the system.

	This failure will occur if the forks are totally used up, or if job
	0 has used the maximum number of forks permitted.  NUFKS contains this
	maximum number.
>)
	MOVE T2,[MSEC1,,HSYS4]	;SET IT TO START NEXT SHUTDOWN PHASE
	MSFRK			;START FORK IN MONITOR MODE
	RET

;FORK STARTED AT SHUTDOWN TIME
;COMMENCE SHUTDOWN. PREVENT NEW JOBS, LOGOUT EXISTING JOBS, HALT.

HSYS4:	MOVX T1,USRCTX		;USER MODE FLAGS WORD
	MOVEM 1,FFL		;ESTABLISH USUAL JSYS CONTEXT
	SETZM FPC		;SET PC
	MCENTR
	MOVX T1,SF%RMT!SF%LCL!SF%PTY!SF%MCB!SF%NVT
	ANDCAM T1,FACTSW	;ONLY ALLOW CTY TO LOGIN
IFN STANSW,<
	MOVX T1,SF%CTY		;MAKE ABOVE REALLY TRUE!
	IORM T1,FACTSW
>;IFN STANSW
	MOVE 6,[XWD -NJOBS+1,1]	;START WITH JOB 1
	SKIPGE JOBRT(6)		;LOOK FOR EXISTING JOB
HSYS41:	AOBJN 6,.-1
	JUMPGE 6,HSYS7		;JUMP IF DONE
	HLRZ 1,JOBPT(6)		;CHECK CTRLTT FOR JOB
	CAMN 1,CTYLNO		;CTY?
	JRST HSYS41		;YES, DON'T FLUSH
	MOVEI 1,0(6)		;GET JOB NUMBER
	CALL LCL2GL		;CONVERT LOCAL JOB INDEX TO GLOBAL JOB #
	 JRST HSYS41		;NOT THERE?
	LGOUT			;LOG IT OUT
	 JFCL
	JRST HSYS41

HSYS7:	MOVEI 5,^D120000	;MAX TIME TO WAIT FOR JOBS TO FINISH
	ADD 5,TODCLK		;LOGGING OUT
HSYS8:	CAMG 5,TODCLK		;WAITED MAX TIME?
	JRST HSYS9		;YES, PROCEED WITH SHUTDOWN
	MOVE T2,HSYST4		;GET TIME BACK UP
	MOVEI T1,^D12		;SHOULD BE CODE FOR REASON FOR HALT
				;BUT FOR NOW, JUST SAY "SCHEDULED DOWN"
	CALL MNTHLT		;TELL THE NETWORK WE ARE GOING AWAY
	MOVE 6,[XWD -NJOBS+1,1]	;START WITH JOB 1
	SKIPGE JOBRT(6)		;SEE IF ANY JOBS STILL EXIST
HSYS81:	AOBJN 6,.-1
	JUMPGE 6,HSYS9		;NONE FOUND, PROCEED
	HLRZ 1,JOBPT(6)		;CHECK FOR CTY JOB
	CAMN 1,CTYLNO
	JRST HSYS81		;YES, IGNORE
	MOVEI 1,^D1000		;NO, WAIT 1 SEC., THEN CHECK AGAIN
	DISMS
	JRST HSYS8

HSYS9:
IFN STANSW&PUPSW,<
	CALL SETPOF		;TURN OFF PUP ETHERNET
>;IFN STANSW&PUPSW
	CALL PHYLOG		;LOG DISK, TAPE STATISTICS
	SETZM DDTIME		;POKE DDMP
	AOS JB0FLG
	MOVEI 5,^D10		;WAIT 10 SEC MAX FOR JOB 0
HSYS91:	MOVEI 1,^D1000		;WAIT 1 SEC
	DISMS
	SKIPN DDTIME		;DDMP FINISHED?
	SOJG 5,HSYS91		;NO, WAIT MORE
	JUMPLE 5,HSYS9		;IF TIMED OUT, TRY AGAIN
	SKIPE IOIP		;WRITES IN PROGRESS?
	JRST .-1		;YES, WAIT FOR COMPLETION
	MOVE T1,CTYLNO
	TXO T1,.TTDES		;MAKE VALID DESIGNATOR
	HRROI T2,[ASCIZ /
Shutdown complete
/]
	TTMSG			;NOTIFY OPERATOR
	 ERJMP .+1		;IN CASE OF REFUSALS
	MOVEI T1,^D15000
	DISMS
	HALTF

;ROUTINE TO SEND GOING DOWN MESSAGE TO ALL LINES

THSYS:	STKVAR <TIM,<MSG,^D25>,CFBRD>
	SETZM CFBRD		;ASSUME NO CLUSTER BROADCAST
	MOVEM T1,TIM		;SAVE NUMBER OF MINUTES
	HRROI T1,MSG		;INIT PTR TO MSG
IFE STANSW,<
	HRROI T2,[ASCIZ /
[System going down/]
>;IFE STANSW
IFN STANSW,<
	HRROI T2,[ASCIZ /
[/]
	SETZ T3,
	SOUT
	MOVE T2,T1		;DESTINATION POINTER
	MOVX T1,.GTHNS		;NUMBER TO NAME CONVERSION
	SETO T3,		;-1 MEANS LOCAL HOST
	GTHST%			;TRY GETTING INTERNET NAME
	IFNJE.
	  MOVE T1,T2		;GET POINTER BACK IN T1
	ELSE.
	  MOVE T1,T2		;GET POINTER BACK IN T1
	  HRROI T2,[ASCIZ/System/] ;DEFAULT NAME
	  SETZ T3,
	  SOUT%
	ENDIF.
	HRROI T2,[ASCIZ/ going down/]
>;IFN STANSW
	SETZ T3,
	SOUT
	MOVE T2,TIM		;GET TIME
	CAILE T2,^D60		;LESS THAN ONE HOUR?
	JRST THSYS1		;NO - SPECIAL MESSAGE
	SETOM CFBRD		;YES, NEED CLUSTER BROADCST
	HRROI T2,[ASCIZ / in /]
	SETZ T3,
	SOUT
	MOVE T2,TIM		;GET TIME
	CAIN T2,1		;THE 'ONE' CASE?
	JRST [	HRROI T2,[ASCIZ /one minute!!]
/]
		JRST HSYS51]	;SPECIAL MESSAGE
	MOVEI T3,^D10
	NOUT
	 JFCL
	HRROI T2,[ASCIZ / minutes/]
	SETZ T3,
	SOUT			;APPEND TO MESSAGE
THSYS1:	HRROI T2,[ASCIZ / at /]
	SETZ T3,0
	SOUT
	MOVE T2,HSYST1		;TELL ACTUAL TIME
	MOVEI T3,0
	ODTIM			;IN MESSAGE
	HRROI T2,[ASCIZ /]
/]
HSYS51:	SETZ T3,
	SOUT
	HRROI T2,MSG		;POINT TO CONSTRUCTED MSG
	MOVE T3,FACTSW
	MOVE T4,TIM
	SKIPL HSYST3		;THE FIRST TIME? OR...
	CAIG T4,5		;5 MIN OR LESS?
	CAIA			;YES, ALWAYS SEND
	TXNE T3,SF%MS1		;WANT LEVEL 1 MESSAGES?
	CALL ALLMSG		;SEND TO ALL LINES
;...
;...
	SKIPN CFBRD		;CLUSTER BROADCAST?
	IFSKP.
	   CALL MSSSVD		;(/) YES, ANY DISKS SERVED?
	   ANSKP.
	      CALL CFCBRD	;(/) TELL OTHER SYSTEMS ABOUT OUR SHUTDOWN
	      ANSKP.
	         HRROI T1,MSG	;INFORM OUR OPERATORS
	         HRROI T2,[ASCIZ/

Check other cluster systems for
structure dismount instructions.

/]
	         SETZ T3,
	         SOUT
	         MOVEI T2,MSG	;RETRIEVE MESSAGE ADDRESS
	         MOVEI T3,.QBSYS ;TYPE IS "SYSTEM MESSAGE"
	         CALL WROPR0	;(T1,T2,T3/) TELL OPERATORS
	ENDIF.
	MOVE T1,TIM		;RESTORE TIME
	RET

	ENDSV.
;ROUTINE TO SEND LAST MESSAGE, INCLUDING EXPECTED UPTIME.

DWNMSG:	STKVAR <<MSG,20>>
	HRROI T1,MSG
	HRROI T2,[ASCIZ /
[Timesharing is over/]
	SETZ T3,
	SOUT
	SKIPN HSYST4		;HAVE AN UPTIME?
	JRST DWNMS1		;NO
	HRROI T2,[ASCIZ /, up again at /]
	SOUT
	MOVE T2,HSYST4		;GET UPTIME
	MOVEI T3,0		;STANDARD FORMAT
	ODTIM			;CONVERT TIME TO TEXT
DWNMS1:	HRROI T2,[ASCIZ /]
/]
	SETZ T3,
	SOUT
	HRROI T2,MSG		;HAVE TEXT, NOW SEND IT TO ALL LINES
	CALL ALLMSG
	RET
	SUBTTL CHKR - Job 0 Periodic Checker

;PERIODIC (10 SEC) CHECK OF THINGS

CHKR::	TSTMS0			;BE SURE NO SECTION 0
	SETZM JB0FLG		;CLEAR REQUEST FLAG
	MOVE 1,TODCLK
	ADD T1,CHKPER		;NOW PLUS MAX CHECK PERIOD
	MOVEM 1,CHKTIM		;LEAVE FOR SCHED TO CHECK
	SETZM CHKDUE		;RESET THE OVERDUE COUNTER
	CALL KNIJB0		;Check on the KLNI's
	MOVE T1,TODCLK		;Get the time of day
	CAMGE T1,LLMACT		;Time to send an ID?
	SKIPE RIQHED		;Any stuff to do for LLMOP?
	 CALL LLMJB0		; Yes, take care of it
;   IFN CFSCOD,<
	CALL CFTADC		;See if a TAD is around
	IFSKP.			;If so
	 STAD			;Set it
	  NOP			;
	CALL DTTIME		;If a KL, tell the FE
	ENDIF.
	CALL CFSJ0		;And see if any background action is needed
;   >	;IFN CFSCOD
	CALL KLPRCT		;DO PERIODIC CI READ-COUNTERS
	CALL RESLCK		;LOCK OR UNLOCK RESIDENT FREE SPACE
	CALL DTEPOL		;GO SEE IF ANY DTE'S NEED ATTENTION
	CALL MNTCHK		;KEEP MULTINET RUNNING
	SKIPL DRMJ0R		;DRUM JOB 0 REQUEST?
	CALL CHKDRM		;YES
	MOVE 1,DSKRCE		;DISK RECOVERABLE ERRORS
	CAME 1,CHKDRE		;DIFFERENT THAN LAST CHECK?
	CALL CHKDE1		;YES, GO PRINT INFO
	MOVE 1,DSKNRE		;DISK NON-REC ERRORS
	CAME 1,CHKDNE		;DIFFERENT?
	CALL CHKDSK		;PRINT INFO
	SKIPE MTAJB0		;MTA ON LINE INTERRUPT?
	CALL MTASSP		;YES REQUEST SETSPD
  IFE FTNSPSRV < ;[6.1]
	CALL DCNJB0		;Do DECnet periodic functions
  >
	SKIPE USGBEG		;CHECK USAGE QUEUE
	CALL USGMES		;HAVE SOMETHING - EMPTY QUEUE
	CALL CHKCKP		;CHECK ON CHECKPOINT
	CALL CHKASC		;Check for accounting shift change
	CALL CHKBGS		;CHECK IF TIME TO STORE ASCII TIME
	SKIPE A,HSYST1		;SHUTDOWN PROCESS ACTIVE?
	CAMN A,[-1]		;OR IS SYSTEM SHUTDOWN
	SKIPA			;SYSTEM SHUTDOWN OR PROCESS NOT ACTIVE
	CALL CHKHSY		;YES, CHECK IT
	SKIPE CCHEAD		;ANY CLUSTER CEASES?
	CALL CHKCLC		;YES, GO OUTPUT THEM
	CALL IMICHK		;MAKE SURE IMP INPUT Q'S EMPTIED
;**;[7247] Add 1 line after CHKUM1:-10			DML	19-Feb-86
	CALL CHKOFN		;[7247] Check OFNS
	MOVE A,TODCLK
	CAMGE A,UMSGTM		;TIME FOR USER MESSAGES?
	JRST CHKUM1		;NO
	CALL CHKDKS		;CHECK DISK SPACE
	CALL CHKDMS		;CHECK DRUM SPACE
	CALL CHKSPT		;CHECK SPT SPACE
	MOVE A,TODCLK		;SET TIME FOR NEXT MSG
	ADD A,[^D<5*60000>]	;IN 5 MINUTES
	MOVEM A,UMSGTM
CHKUM1:
	CALL CHKMOS		;CHECK IF MEMORY DIAG NEEDS TO RUN
	MOVEI A,^D30000		;SETUP TO DISMISS FOR 30 SEC
	SKIPE B,HSYST1		;SHUTDOWN ACTIVE?
	CAMN B,[-1]		;OR SYSTEM SHUTDOWN?
	SKIPA			;NO SHUTDOWN OR ALREADY SHUTDOWN
	SKIPGE B,HSYST2		;YES, REASONABLE TIME TO WAIT?
	JRST CHKUM2		;NOT ACTIVE OR BAD TIME
	CAMLE A,B		;LESS THAN 30 SECONDS AWAY
	MOVE A,B		;YES, DISMISS UNTIL THEN
	;..

	;..
CHKUM2:	MOVE B,DDTIME		;Time for DDMP
	SUB B,TODCLK		;Relative time for DDMP
	IFG. B			;If still in the future
	 CAMLE A,B		;Will we run in time?
	 MOVE A,B		;No. So use this time instead
	ENDIF.
	CALL SETBKT		;SETUP TIME FOR DISMISS TEST
	HRRI A,JB0TST		;OR JB0FLG
	MOVSI B,FHV1		;LOW BLOCK PRIORITY
	HDISMS
	JRST CHKR

;MAXIMUM CHECK PERIOD - USED TO SET SCHEDULER ALARM

	RESCD

CHKPER::^D<1*60000>		;1 MINUTE - CHKR ALARM PERIOD
DDPPER::^D<1*60000>		;1 MINUTE - DDMP ALARM PERIOD

JB0TST:	SKIPE JB0FLG		;EXPLICIT REQUEST?
	JRST 1(4)		;YES, WAKEUP
	JRST BLOCKT		;NO, GO TEST TIME

;Test routine for DDMP

DDPWAT:	MOVE T1,TODCLK		;Get now
	SKIPN DDCFSF		;Force for CFS?
	CAML T1,DDTIME		;Time to do it?
	JRST 1(4)		;yes
	SKIPN DDPDUE		;ddmp force?
	JRST 0(4)		;no
	JRST 1(4)		;yes

;TEST ROUTINE TO CIFORK

CIWAIT:	SKIPE CIFRKF		;ANYTHING TO DO?
	JRST 1(4)		;Yes
	JRST 0(4)		;No
	SWAPCD

NR UMSGTM,1			;TIME OF NEXT USER MESSAGES
NR MTCHNG,1			;FLAG FOR MTA STATUS CHANGE
;JB0INT - HERE WHEN INTERRUPT OCCURS IN FORK 0

;THIS ROUTINE IS POINTED TO BY MONBK. THE SCHEDULER TRANSFERS
;CONTROL TO HERE WHEN AN INTERRUPT OCCURS ON CHANNEL 34 OR 35 IN
;FORK 0. JB0XFR CONTAINS THE ROUTINE TO WHICH THIS CODE TRANSFERS
;AFTER CLEANING THINGS UP

JB0INT:	BUG.(CHK,JB0INX,MEXEC,SOFT,<Unexpected interrupt in job 0 during initialization>,<<ITFPC,PC>,<JB0XFR,NEWPC>,<LSTERR,LSTERR>>,<

Cause:	An unexpected error has occurred in Job 0 which results
	in control being transferred to the default error handler.
	This has happened during job 0 initialization.
	The error handler will attempt to reset the context and
	continue at the specified error address,
	however some system resources may be
	hung as a result of locks not being cleared.  The stack
	can be examined to determine what was in progress when
	the error occurred.

Data:	PPC - PC at which error occurred
	NEWPC - Address to which control will be transferred after cleanup
	LSTERR - Last error code in this fork
>)
	SETZM NSKED		;BE OKSKED
	SETZM CRSKED		;BE NOT 'CRITICAL SECTION'
	MOVX CX,USRCTX
	MOVEM CX,FFL		;RESET CONTEXT
	MCENTR
	MOVE T1,[XWD MSEC1,J0EMER] ;IN CASE OF EMERGENCY
	CALL MONBKX
	CALL CLRINT		;CLEAR THE INTERRUPT SYSTEM
	MOVE T1,FORKX		;T1/ FORK NUMBER
	SETZM T2		;T2/ ALL INTERRUPT LEVELS
	CALL JSBSTF		;CLEAN THE JSB STACK
	MOVE T1,FORKX		;T1/ FORK NUMBER
	SETZM T2		;T2/ ALL LEVELS
	CALL GOKFRE		;CLEAN UP GETOK QUEUES (SHOULDN'T HAVE ANY)
	MOVE T1,[XWD MSEC1,JB0INT] ;BACK TO HERE IF ANOTHER INTERRUPT
	CALL MONBKX
	MOVE T1,JB0XFR		;SEE WHERE WE ARE TO GO NEXT
	JRST 0(T1)		; AND GO THERE

;HERE WHEN AN ERROR OCCURRED WHILE IN JB0INT. GIVE UP.

J0EMER:	BUG.(HLT,STRTER,MEXEC,SOFT,<Fatal error while processing previous startup error>,,<

Cause:	When a software channel 34 or 35 interrupt happens on fork
	0, the monitor transfers control to the routine specified in
	MONBK.  This address will often be the starting address of
	JB0INT.  JB0INT handles errors in fork 0.  While JB0INT is doing its
	error recovery, it sets MONBK to J0EMER, so that this STRTER BUGHLT
	will occur if another error happens during JB0INT execution.
>)

;CLRINT - CLEAR THE INTERRUPT SYSTEM

CLRINT:	MOVEI 1,400000		;DEACTIVATE SOFTWARE INTERRUPT CHANNELS
	SETO 2,			; FOR THIS PROCESS

	DIC
	CALL DTIALL		;IN CASE PROGRAM TURNED ANY ON
	MOVE 2,PSIBW
	CIS			;CLEAR ALL INTERRUPTS IN PROGRESS
	RET

IFE STANSW,<		;NOT USED AT STANFORD SINCE WE TIME STAMP EVERYTHING
;Here to put number in message and provide time stamp.
;	T1/ byte pointer to use

CHKH1:	CALL TTDECP		;OUTPUT DECIMAL
	MOVEI 2," "
	IDPB T2,T1		;PUNCTUATE
	PUSH P,T1		;SAVE POINTER
	CALL LGTAD		;CURRENT TIME AND DATE
	MOVE T2,T1
	POP P,T1
	SETZM T3
	IFG. T2
	 ODTIM			;INCLUDE TAD WITH MESSAGE
	ENDIF.
	HRROI T2,[ASCIZ /
/]
	SOUT			;MAKE IT PRETTY
	RET
>;IFE STANSW
IFN STANSW,<
;TIMSMP - ROUTINE TO OUTPUT A SYSTEM TIMESTAMP FOR CTY LOG MESSAGES
;ENTER AT TIMSFM WITH T1/ DESTINATION

TIMSMP::MOVX T1,.PRIOU		;DEFAULT DESTINATION TO THE CTY
TIMSMF:	PUSH P,T1		;PRESERVE DESTINATION POINTER
	MOVX T1,.PRIOU
	RFPOS%			;SEE WHERE CARRIAGE IS NOW
	POP P,T1		;RESTORE DESTINATION POINTER
	IFXN. T2,.RHALF		;OUTPUT CRLF IF NOT AT LEFT MARGIN
	  FMSG <
>				;SEND A CRLF TO THE BUFFER
	ENDIF.
	SETO T2,		;TIME NOW
	SETZ T3,		;NORMAL FORMATTING OPTIONS
	ODTIM%
	 ERJMP .+1
	RET
>;IFN STANSW
;Routine to see if a KLIPA load/dump is needed.
;Returns:
;	+1 did something
;	+2 didn't

IPACHK:	CALL CHKKLP		;(/T2) Ask the port driver
	 RETSKP			;NOTHING NEEDED
	MOVX T1,GJ%SHT!GJ%OLD	;EXISTING FILE
	MOVEI T3,3		;SPECIAL ENTRY FOR MONITOR STARTUP
	SKIPE T2		;LOADING?
	IFSKP.

;We will try to load the port's u-code

IFN NICSW,<
	  HRROI T2,[ASCIZ /PS:<SYSTEM>6-1-IPALOD.EXE/] ;The file
>;IFN NICSW
IFE NICSW,<
	  HRROI T2,[ASCIZ /PS:<SYSTEM>IPALOD.EXE/] ;The file
>;IFE NICSW
	  XMOVEI T4,CILFRK	;PLACE TO PUT FORK NUMBER OF IPALOD
	  CALL RUNDII		;Do it
	   SKIPA		;Failed
	  RET			;Did it. Say so.
	  BUG.(CHK,NOLODF,MEXEC,SOFT,<Could not find CI-20 microcode load program>,,<

Cause:	The KLIPA (IPA20) RAM needs to be reloaded. The file
	PS:<SYSTEM>IPALOD.EXE is supposed to be run to do this. However,
	the file does not exist. TOPS-20 is ignoring the CI-20.

Action:	If you wish to use the CI, you must create the load file and run it
	from the EXEC.
>)
	  CALL KLPNLF		;DECLARE THE KLIPA DEAD
	  RET
	ENDIF.

;We will try to dump the port's u-code

	HRROI T2,[ASCIZ /PS:<SYSTEM>IPADMP.EXE/] ;The file
	XMOVEI T4,CIDFRK	;PLACE TO PUT FORK NUMBER OF IPADMP
	CALL RUNDII		;Do it
	 SKIPA			;Failed
	RET			;Did it. Say so.
	BUG.(CHK,NODMPF,MEXEC,SOFT,<Could not find CI-20 microcode dump program>,,<

Cause:	The KLIPA (IPA20) RAM needs to be dumped. The file PS:<SYSTEM>IPADMP.EXE
	is supposed to be run to do this. However, the file does not exist.

Action:	Something has happened which warrants dumping the CI-20 microcode in
	order to get information to diagnose a problem.  It is advisable to put
	the dump program on the system.
>)
	CALL KLPNDF		;RELOAD AND START THE PORT
	RET
	SUBTTL DDMP - INITIATE PAGE MOVEMENT TO DISK IF APPROPRIATE

DDMP0:	TSTMS0			;BE SURE NO SECTION 0
	SETZM P1		;Not doing CFS-forced DDMP
DDMP00:	MOVE T1,TODCLK		;GET THE CURRENT TIME
	ADD T1,DDPPER		;CALCULATE NEXT ALARM TIME
	MOVEM T1,DDPTIM		;AND SAVE IT FOR THE SCHED TO CHECK
	SETZM DDPDUE		;RESET THE OVERDUE COUNTER
	MOVE T1,DRMFRE		;DRUM SPACE LOW?
IFE STANSW,<
	CAMGE T1,DRMIN0
	JRST [	TMSG <DDMP: SWAP SPACE LOW ACTION.
>
		JRST DDMPA]
DDMPA:
>;IFE STANSW
IFN STANSW,<
	CAMGE A,DRMIN0		;SWAP SPACE LOW?
	 SKIPE DBUGSW		;YES, NOTE ONLY IF PRODUCTION SYSTEM
	  JRST DDMPAA		;NOT LOW OR WE'RE DEBUGGING
	CALL TIMSMP		;TIMESTAMP OUTPUT
	TMSG < DDMP: Swap space low action
>
DDMPAA:
>;IFN STANSW
	IFE. P1			;Check which flavor we are doing
	 CALL DDMP		;DO THE WORK
	  NOP
	ELSE.
	 CALL DDMPF		;DO force out
	 AOS DDCFSF
	ENDIF.
	IFE. P1			;If this was a regular run
	 MOVX A,^D60000		;SET TIME FOR NEXT CYCLE AS 1 MINUTE
	 ADD A,TODCLK		;When to do it again
	 MOVEM A,DDTIME
	ENDIF.
	SETZM P1
	SKIPE DDCFSF		;Need another force?
	IFNSK.			;If so
	 MOVEI T1,^D50		;Wait a short while
	 DISMS			;""
	ELSE.
	 MOVEI A,DDPWAT		;The test
	 HDISMS			;Wait a bit
	ENDIF.
	EXCH P1,DDCFSF		;Zero the word, get new value for flag
	JRST DDMP00		;And do it again

;Here when DDMP fork gets an error

DDMPER:	BUG.(CHK,DDMINT,MEXEC,SOFT,<Unexpected interrupt in DDMP process>,<<ITFPC,ITFPC>,<LSTERR,LSTERR>>,<

Cause:	An unexpected error has occurred in the process which handles
	migration of pages to disk.  The error handler will attempt
	to reinitialize the context and resume processing.  The
	stack may be examined for an indication of where the error
	occurred.

Data:	ITFPC - PC when error occurred.
	LSTERR - Last error code in fork.
>)
	SETZM NSKED		;BE OKSKED
	SETZM CRSKED		;BE NOT 'CRITICAL SECTION'
	MOVX CX,USRCTX
	MOVEM CX,FFL
	MCENTR			;RESET STACK, REINIT CONTEXT
	MOVE T1,FORKX		;T1/ FORK NUMBER
	SETZM T2		;T2/ ALL INTERRUPT LEVELS
	CALL JSBSTF		;CLEAN THE JSB STACK
	JRST DDMP0		;RESUME

;This is CIFORK.  It is started during system startup, immediately after
;the CI20 is started.  This fork must be started before CHKR becuase it
;performs functions which are needed before CHECKD had completed.

CIRUN:	MOVX T1,USRCTX		;Start with user context set
	MOVEM T1,FFL		;.	.	.
	MCENTR			;Start a new process
CILOOP:	MOVEI T1,CIWAIT		;The wait test
	MDISMS			;Wait up
	TMNE CIBUF		;NEED TO CREATE BUFFERS?
	CALL SC.ALM		;YES, Do buffer checking now
	TMNE CIREP		;NEED TO REAP CONNECT BLOCKS?
	CALL SC.RAP		;YES
	JRST CILOOP		;And do it agaain

; ROUTINE TO REQUEST SETSPD FOR MAGTAPE ON LINE

MTASSP:	SETZM MTAJB0		;CLEAR REQUEST FLAG
	MOVX T1,GJ%OLD!GJ%PHY!GJ%SHT
	HRROI T2,SETSPD		;GET POINTER TO "SYSTEM:X-SETSPD.EXE"
	MOVEI T3,4		;START AT ENTRY VECTOR POSITION 4
	SETZM T4		;DO NOT RECORD FORK NUMBER
	CALL RUNDII		;RUN SETSPD AND WAIT UNTIL IT'S DONE
	 JFCL			;IGNORE FAILURE
	RET

;ROUTINE CALLED BY CHKR TO SEE IF ANY ACTION NEEDED FOR THE
;MOS MEMORY DIAGNOSTIC

CHKMOS:	SKIPN T1,MOSFRK		;NOW RUNNING?
	JRST CHKMO1		;NO. SEE IF WE SHOULD RUN IT
	RFSTS			;YES. SEE WHAT IT IS DOING
	LOAD T1,RF%STS,T1	;GET ITS STATUS
	CAIE T1,.RFHLT		;HALTED?
	CAIN T1,.RFFPT		;OR ERROR?
	SKIPA T1,MOSFRK		;YES.
	RET			;NO. ALL DONE THEN
	KFORK			;KILL THE PROCESS
	SETZM MOSFRK		;NO MORE FORK HERE
	CALL MOSULE		;UNLATCH CONTROLLER NOW

;HERE IF NO FORK NOW RUNNING. SEE IF ONE NEEDED

CHKMO1:	SKIPE ERRTBL		;HAVE SOME ENTRIES TO PROCESS
	CALL RUNMOS		;YES. START THE DIAG
	RET			;DONE

;ROUTINE TO RUN THE MOS MEM DIAGNOSTIC

RUNMOS:	TDZA T3,T3		;MAIN ENTRY POINT
RUNMO1:	MOVEI T3,1		;SYS START UP ENTRY
	MOVX T1,<GJ%OLD!GJ%SHT!GJ%PHY>
	HRROI T2,[ASCIZ /SYSTEM:TGHA.EXE/] ;THE DIAG
	SETZM T4		;DO NOT RECORD FORK NUMBER
	CALL RUNDIR		;RUN TGHA
	 RET			;DIDN'T DO IT.
	MOVEM T1,MOSFRK		;SAVE FORK HANDLE FOR LATER
	RET			;AND DONE
	SUBTTL

;ROUTINE CALLED BY JOB 0 TO FINISH LOADING UP SYSERR BLOCK
;  FOR BUGHLT'S AND BUGCHK'S
;ACCEPTS IN T1/	ADDRESS OF SYSERR BLOCK
;RETURNS +1:	ALWAYS

LOGBUG::SAVEAC <Q1,Q2,P1>
	TRVAR <BUGSP,BUGPNM,BUGTAD,<LOGBUF,^D70>,<QBLK,4>>
	MOVEM T1,Q1		;SAVE POINTER TO SYSERR BLOCK
	HRROI T1,LOGBUF		;POINTER TO BLOCK
	SKIPN SAVTRE		;SAVING TREES?
	IFSKP.
IFE STANSW,<
	   CALL SLOGTM		;YES, OUTPUT THE TIME
	   FMSG < ***BUG>
	   CALL LOGNAM		;OUTPUT THE BUG NAME
	   FMSG <*** >
>;IFE STANSW
IFN STANSW,<
	   CALL TIMSMF		;PRINT TIME STAMP
	   CALL LOGNAM		;PRINT " BUGINF: FOOBAR"
	   FMSG < - >		;PRETTY PRINTING
>;IFN STANSW
	ELSE.
	   FMSG <
********************
*BUG>
	   CALL LOGNAM		;OUTPUT THE BUG NAME
	   CALL RLOGTM		;OUTPUT THE DATE AND TIME
	   FMSG <
*>
	ENDIF.
	SETZB T2,BUGSP		;CLEAR POINTERS
  IFN FTNSPSRV,< ;[6.0]
	MOVE Q2,BUGTP		;ADDRESS OF BUG POINTERS
	MOVE P1,BUGTL		;LENGTH OF TABLE
      DO.
	SOJL P1,[HRROI T2,[ASCIZ/Message not found for this address/]
		JRST ENDLP.]
	MOVE T4,0(Q2)		;SEARCH FOR ADDRESS IN TABLE
	HLRZ T2,T4		;GET ADDRESS
	HRRZ T3,SEBDAT+BG%ADR(Q1) ;Get BUGHLT address
	CAME T2,T3		;Found it?
	AOJA Q2,TOP.		;NO, STEP POINTER AND LOOP
	HRRZ T2,T4		;GET POINTER TO MESSAGE STRING
	HLL T2,Q2		;INCLUDE SECTION NUMBER
	MOVEM T2,BUGSP		;SAVE IT FOR SYSERR BLOCK
  >
  IFE FTNSPSRV,< ;[6.1]
	MOVE Q2,BUGTP		;ADDRESS OF BUG POINTERS
	MOVE P1,BUGTL		;LENGTH OF TABLE
	MOVE T4,SEBDAT+BG%ADR(Q1) ;Get PC of BUG
	TLNN T4,-1		;Skip if not section 0
	HRLI T4,MSEC1		; otherwise load section 1 for compare
      DO.
	SOJL P1,[HRROI T2,[ASCIZ/Message not found for this address/]
		JRST ENDLP.]
	CAMN T4,0(Q2)		;Compare with BUG in BGPTR
	IFSKP.			; -not the one,
	  ADDI Q2,2		;  Move to next entry
	  LOOP.			;   and go back to try next
	ENDIF.
	MOVE T2,1(Q2)		;Get BGSTR pointer
	MOVEM T2,BUGSP		;SAVE IT FOR SYSERR BLOCK
  >
	TXO T2,<.P07>		;MAKE OWGBP
      ENDDO.
	SETZ T3,		;Set up for SOUT
	SOUT			;TYPE OUT STRING
	SETZM BUGPNM		;START WITH A NULL PROGRAM NAME
	SKIPGE SEBDAT+BG%JOB(Q1)	;IS THERE A JOB?
	JRST LOGBF5		;NO, SKIP JOB/USER LINE
	SKIPN SAVTRE		;SAVING TREES?
	IFSKP.
	   FMSG <  Job: >	;YES
	ELSE.
	   FMSG <
*Job:  >
	ENDIF.
	HRRZ T2,SEBDAT+BG%JOB(Q1)	;GET JOB NUMBER
	MOVEI T3,12		;TYPE IT IN DECIMAL
	NOUT
	 ERJMP .+1
	MOVE T2,JOBPNM(T2)	;GET PROGRAM NAME
	MOVEM T2,BUGPNM		;SAVE NAME OF PROGRAM
	FMSG <, User: >
	HRRZ T2,SEBDAT+BG%USR(Q1)	;GET USER LOGGED IN DIR NUMBER
	HRLI T2,USRLH		;TURN IT INTO PROPER FORMAT USER NUMBER
	DIRST			;TYPE OUT USER NAME
	 ERJMPS .+1		;IGNORE ERROR, PRESERVE PTR IN T1
LOGBF5:	SKIPG Q2,SEBDAT+BG%RCT(Q1) ;GET COUNT OF REGISTERS SAVED
	JRST LOGBF7		;NO REGISTERS TO BE TYPED
	SKIPN SAVTRE		;SAVING TREES?
	IFSKP.
IFE STANSW,<
	   FMSG <  Additional Data: >  ;YES
>;IFE STANSW
IFN STANSW,<
	   FMSG <, Data >	;YES
>;IFN STANSW
	ELSE.
	   FMSG <
*Additional data: >
	ENDIF.
	XMOVEI T4,SEBDAT+BG%REG(Q1)	;GET POINTER TO REGISTER AREA
LOGBF6:	MOVE T3,[NO%MAG+10]	;TYPE THEM IN UNSIGNED OCTAL
	MOVE T2,0(T4)		;GET NEXT REG TO TYPE
	NOUT
	 ERJMP .+1
	SOJLE Q2,LOGBF7		;DONE?
	FMSG <, >	;NO
	AOJA T4,LOGBF6		;GO TYPE OUT REST

LOGBF7:	SKIPN SAVTRE		;SAVING TREES?
	IFSKP.
	   FMSG <
>
	ELSE.
	   FMSG <
********************
>
	ENDIF.
	SETZ T2,
	IDPB T2,T1		;TIE IT OFF
	MOVEI T2,LOGBUF
	MOVE T4,SEBDAT+BG%FLG(Q1) ;GET TYPE OF BUG 
	MOVEI T3,.QBCHK		;BUGCHK BY DEFAULT (BUGHLTS DON'T MAKE IT)
	CAIN T4,BG%CHK		;BUGCHK?
	MOVEI T3,.QBCHK		;YES, .QBDTY VALUE FOR BUGCHK
	CAIN T4,BG%INF		;INFORMATIONAL BUG CHECK?
	MOVEI T3,.QBINF		;YES, .QBDTY VALUE FOR BUGINF
	CALL WROPR0		;SEND IT
	MOVE T1,CRSTD1		;GET DATE OF BUGCHK
	CAMN T1,[-1]		;IS THERE ONE SET?
	CALL LGTAD		;NO, SEE IF IT IS SET NOW
	MOVEM T1,BUGTAD		;SAVE DATE AND TIME OF BUGCHK
	MOVE T1,Q1		;GO COPY REST OF DATA TO BLOCK
	MOVE T2,[-NBUGET,,BUGET]
	CALL SEBCPY
	 JFCL
	SOS BUGCNT		;COUNT DOWN THE QUEUED UP BLOCK COUNT
	SETZM BUGCHK		;CLEAR OUT LAST BUGCHK ADR
	RET			;FINISHED

BUGET:	SEBPTR BG%SVN,SBTSTR,SVN ;SYSTEM NAME
	SEBPTR BG%PNM,SBTWD,BUGPNM ;PROGRAM NAME
	SEBPTR BG%DAT,SBTWD,BUGTAD ;TIME AND DATE OF CRASH
	SEBPTR BG%MSG,SBTSTR,@BUGSP ;BUG MESSAGE
NBUGET==.-BUGET

;LOCAL ROUTINE TO OUTPUT THE TIME
;RETURNS:	+1

RLOGTM:	FMSG <" at >
	SKIPA
SLOGTM:	MOVX T3,OT%NDA		;NO DATE, JUST THE TIME
	MOVE T2,SEBDAT+BG%DAT(Q1) ;GET TIME AND DATE OF BUG CHECK
	ODTIM			;TYPE OUT TIME AND DATE
	 ERJMP .+1
	RET

;LOCAL ROUTINE TO OUTPUT THE BUGXXX TYPE AND NAME
;RETURNS:	+1

LOGNAM:	MOVE T4,SEBDAT+BG%FLG(Q1) ;GET TYPE OF BUG CHECK
IFE STANSW,<
	HRROI T2,[ASCIZ/HLT /]
	CAIN T4,BG%CHK		;BUGCHK?
	HRROI T2,[ASCIZ/CHK /]	;YES
	CAIN T4,BG%INF		;INFORMATIONAL BUG CHECK?
	HRROI T2,[ASCIZ/INF /]	;YES
>;IFE STANSW
IFN STANSW,<
	HRROI T2,[ASCIZ/ BUGHLT: /]
	CAIN T4,BG%CHK		;BUGCHK?
	HRROI T2,[ASCIZ/ BUGCHK: /]	;YES
	CAIN T4,BG%INF		;INFORMATIONAL BUG CHECK?
	HRROI T2,[ASCIZ/ BUGINF: /]	;YES
>;IFN STANSW
	SOUT
	 ERJMP .+1
	SKIPE SAVTRE		;SAVING TREES?
	IFSKP.
	   FMSG <">		;NO
	ENDIF.
	MOVE T4,[POINT 6,SEBDAT+BG%NAM(Q1)]
LOGNA1:	ILDB T2,T4		;NOW TYPE OUT 6 CHAR NAME
	JUMPE T2,R		;IF AT END, STOP TYPING
	ADDI T2," "		;TRANSLATE SIXBIT TO ASCII
	IDPB T2,T1		;STORE IT
	TLNE T4,770000		;AT END OF NAME YET?
	JRST LOGNA1		;NO, LOOP BACK FOR REST OF CHARS
	RET

;Routine to write message to operator. Uses ORION if it can
;	T1/ count of words in string
;	T2/ string address
;	T3/ .QBDTY value (.QBCHK,.QBINF,.QBSYS)
;	CALL WROPER

;	or
;	T1/ ending bp
;	T2/ buffer address
;	T3/ .QBDTY value (.QBCHK,.QBINF,.QBSYS)
;	CALL WROPR0

;	Returns +1 always
;Clobbers all temps

;Format of the QBLK STKVAR storage:
;
;  QBLK/  Function and flags      	;.QUFNC
;    +1/  Response block (not used)	;.QURSP
;    +2/  QA%IMM!<Length=1>!.QBDTY	;.QUARG+.QATYP  (DISPLAY TYPE)
;    +3/  .QBCHK,.QBINF,or .QBSYS	;.QUARG+.QADAT
;    +4/  <Length>,,.QBMSG		;.QUARG+.QATYP+2 (MESSAGE BLOCK)
;    +5/  ADDR OF STRING		;.QUARG+.QADAT+2
   QLNG==6

WROPR0::HRRZS T1		;GET ADDRESS
	SUBI T1,-1(T2)		;COMPUTE WORDS
WROPER::STKVAR<<QBLK,QLNG>>
	MOVEI T4,QBLK		;POINT AT OUR BLOCK
	MOVEM T2,.QUARG+.QADAT+2(T4) ;STORE STRING
	MOVEM T3,.QUARG+.QADAT(T4) ;STORE MESSAGE TYPE
	HRLI T1,.QBMSG		;SUBFUNCTION ARG
	MOVSM T1,.QUARG+.QATYP+2(T4) ;STASH SUBFUNC STUFF
	MOVX T3,<QU%NRS!.QUWTO>	;NO RESPONSE FOR WRITE TO OPERATOR
	MOVEM T3,.QUFNC(T4)	;SAVE THE FUNCTION AND FLAGS
	MOVX T3,<QA%IMM!<FLD(1,QA%LEN)>!<FLD(.QBDTY,QA%TYP)>>
	MOVEM T3,.QUARG+.QATYP(T4) ;SAVE THE DISPLAY TYPE, LENGTH, FLAGS
	SETZM .QURSP(T4)	;NO RESPONSE BLOCK
	MOVEI T1,QLNG		;LENGTH OF ARG BLOCK
	MOVEI T2,QBLK		;POINT AT ARG BLOCK
	QUEUE%			;DO IT
	 ERJMP WROPE0		;IF FAILED, PUT ON THE CTY
	JE SF%BGS,FACTSW,R	;CHECK IF WANT BOTH
WROPE0:	HRRO T1,.QUARG+.QADAT+2(T4) ;GET POINTER TO STRING
	PSOUT			;SO DO IT
	RET			;DONE

	ENDSV.

;SEND TEXT TO ALL LINES, WAIT FOR COMPLETION
; 2/ PTR TO ASCIZ MESSAGE
;	CALL ALLMSG
; RETURN +1 ALWAYS, WAIT LONG ENOUGH FOR MESSAGE TO APPEAR ON 110 BAUD
;LINES.

ALLMSG::SETZ 1,			;SAY NO WAIT
   REPEAT 0,<
	HLRZ 3,2		;CHECK LH OF POINTER
	CAIN 3,-1		;DEFAULT?
	HRLI 2,(<POINT 7,0>)	;YES, DO IT
   >
	SETO T3,		;SAY ALL LINE
	TTMSG			;TYPE THE STUFF
	 ERJMP [BUG.(INF,TTFSMS,MEXEC,SOFT,<Failed to send system message>,,<

Cause:	The most likely reason for this failure is that RSX20F cannot
	complete the previous TTMSG request. Typically this is caused by a
	hung DH11 line, but could be a software bug as well.
>)
		JRST .+1]	;CONTINUE
	RET			; AND RETURN

CHKDRM: REPEAT 0,<
	TMSG <
*****DRUM ERR: >
	MOVSI 6,-NDRMEW		;# OF DRUM ERROR WORDS
	HRRI 6,DRMCFE		;FINISH AOBJN PTR
CHKD1:	MOVE B,0(6)		;GET WORD
	CALL TTOCTP		;PRINT IT
	TMSG <
	>
	AOBJN 6,CHKD1
   >	;REPEAT 0
	SETOM DRMJ0R		;RESET REQUEST FLAG
	RET			;RETURN

CHKDMS:	MOVE 1,DRMFRE
	CAMLE 1,DRMIN0		;DRUM SPACE LOW?
	RET			;NO
	STKVAR <<MSGBBF,^D70>>
	HRROI 2,[ASCIZ /
[Caution--Swapping space low]
/]
	MOVX T3,SF%MS0
	TDNE T3,FACTSW		;WANT LEVEL 0 MESSAGES?
	CALL ALLMSG		;YES, DO IT
	HRROI T1,MSGBBF		;WHERE IT'S GOING
IFE STANSW,<
	HRROI T2,[ASCIZ /
*****Swapping space low, /]
	SETZM T3
	SOUT			;COPY IT
	MOVE 2,DRMFRE
	CALL CHKH1		;DO MORE
>;IFE STANSW
IFN STANSW,<
	SKIPE DBUGSW		;IF WE ARE STANDALONE OR DEBUGGING
	 RET			;WE DON'T WANT THIS MESSAGE ON THE CTY
	CALL TIMSMF
	FMSG < CHKDMS: Swapping space low, >
	MOVE T2,DRMFRE
	CALL PRTPGS		;PRINT FREE COUNT
>;IFN STANSW
	MOVEI T2,MSGBBF
	MOVEI T3,.QBSYS		;.QBDTY VALUE FOR SYSTEM MESSAGE
	CALLRET WROPR0		;DO IT
	ENDSV.


;**;[7247]  Add routine CHKOFN				DML	19-Feb-86
;[7247] CHKOFN - Check the number of OFNS in system and release some if needed
;[7247] Note - Performance counters - Charge this time to BKGND/FILW?
;[7247] Tricky because low level routines can cause OKSKED/reschedule 
;[7247] Time is now charged to job 0 so this may be enough...

CHKOFN:	NOSKED			;[7247] Lock up system
	SKIPL OFNTIM		;[7247] Should we release only cached OFNS?
	IFSKP.			;[7247] Yes
	  CALL FREOFC		;[7247] Free all cached OFNS now
	   JFCL			;[7247] Don't care about this return
	  OKSKED		;[7247] 
	  RET			;[7247] 
	ENDIF.			;[7247] 
	MOVE T1,TODCLK		;[7247] Get now
	CAMLE T1,OFNTIM		;[7247] Time to do this?
	CALL FREOFG		;[7247] Yes
	 JFCL			;[7247] Ignore +1 return
	MOVEI T1,NOFN		;[7247] Get number OFNS
	SUB T1,NOF		;[7247] ... left in system
	CAIG T1,^D50		;[7247] Below threshold?
	CALL FREOFG		;[7247] Yes so try again
	 JFCL			;[7247] 
	OKSKED			;[7247] Safe to run again!
	RET			;[7247] 

CHKSPT:	MOVE 1,SPTC
	CAMGE 1,SPC1		;SPT LOW?
	RET			;NO
	STKVAR <<MSGBBF,^D70>>
	HRROI 2,[ASCIZ /
[Caution--SPT space low]
/]
	MOVE T3,FACTSW
	TXNE T3,SF%MS0		;WANT LEVEL 0 MESSAGES?
	CALL ALLMSG		;YES, DO IT
	HRROI T1,MSGBBF
IFE STANSW,<
	HRROI T2,[ASCIZ /
*****SPT space low, /]
	SETZM T3
	SOUT			;COPY STRING
	MOVN 2,[NOFN-SSPT]
	SUB 2,SPTC		;SPACE LEFT
	CALL CHKH1		;DO REST OF MESSAGE
>;IFE STANSW
IFN STANSW,<
	CALL TIMSMF
	FMSG < CHKSPT: SPT space low, >
	MOVN T2,[NOFN-SSPT]
	SUB T2,SPTC		;SPACE LEFT
	CALL PRTPGS
>;IFN STANSW
	MOVEI T2,MSGBBF		;GET START
	MOVEI T3,.QBSYS		;.QBDTY VALUE FOR SYSTEM MESSAGE
	CALLRET WROPR0		;AND WRITE IT
	ENDSV.
;CHECK DSK SPACE

CHKDKS:	SKIPGE T1,EXPFRK	;EXPUNGE FORK RUNNING?
	RET			;YES - EXIT QUIETLY
	JUMPE T1,CKDKS1		;NO - EXISTS?
	SETZM EXPFRK		;YES - KILL IT
	KFORK			;...
CKDKS1:	SETZM T1		;ASSUME PUBLIC STRUCTURE
	CALL GSTRPG		;GET COUNT OF USED AND FREE PAGES ON STRUCTURE
	MOVE T1,T2		;GET FREE COUNT
	SUB 1,SYSSPC		;LESS 'BUFFER'
	CAILE 1,SYWRND		;LOW?
	RET			;NO
	STKVAR <<MSGBBF,^D70>,SAVSIZ>
	MOVEM T2,SAVSIZ
	HRROI 2,[ASCIZ /
[Caution--Disk space low on system structure]
/]
	MOVE T3,FACTSW
	TXNE T3,SF%MS0		;WANT LEVEL 0 MESSAGES?
	CALL ALLMSG		;YES, DO IT
	SKIPN T1,EXPTIM		;ENOUGH TIME SINCE LAST EXPUNGE?
	MOVX T1,<EXWTIM*^D60000> ;DONT DO EXPUNGES IN FIRST n MIN
	CAMG T1,TODCLK
	CALL EXPALL		;YES, DO EXPUNGE *
	HRROI T1,MSGBBF		;ADDRESS OF BUFFER
IFE STANSW,<
	HRROI T2,[ASCIZ /
*****Disk space low on system structure, /]
	SETZM T3
	SOUT
	MOVE T2,SAVSIZ		;RECOVER FREE SPACE
	CALL CHKH1
>;IFE STANSW
IFN STANSW,<
	CALL TIMSMF
	FMSG < CHKDKS: Disk space low on system structure, >
	MOVE T2,SAVSIZ		;RESTORE COUNT OF FREE PAGES
PRTPGS:	CALL TTDECP		;OUTPUT IN DECIMAL
	FMSG < pages remaining
>
>;IFN STANSW
	MOVEI T2,MSGBBF		;START OF MESSAGE
	MOVEI T3,.QBSYS		;.QBDTY VALUE FOR SYSTEM MESSAGE
	CALLRET WROPR0		;DO IT

;ROUTINE TO DO EXPUNGE * WHEN DISK SPACE LOW
;START FORK AND MARK IT RUNNING
;	CALL EXPALL
;RETURNS +1 ALWAYS

NR EXPTIM,1		;TIME OF LAST EXPUNGE PLUS MIN INTERVAL
NR EXPFRK,1		;        0 := NO EXPUNGE FORK
			; -1,,FRKH := FORK RUNNING
			;  0,,FRKH := EXPUNGE DONE

EXPALL:	MOVX T1,CR%CAP		;PASS CAPABILITIES DOWN
	CFORK			;CREATE FORK
	 BUG.(HLT,EXPAFK,MEXEC,SOFT,<EXPALL - Job 0 CFORK failed>,,<

Cause:	This will happen if the CFORK JSYS fails to create a fork
	for doing the system-wide expunge of structure PS:. This could most
	likely happen if all the fork slots are used up.
>)
	HRROM T1,EXPFRK		;MARK FORK RUNNING
	MOVE T2,[MSEC1,,EXPAL0]	;START INFERIOR
	MSFRK			; IN MONITOR MODE
	RET			;RETURN (WAIT TILL DONE)

;EXPUNGE FORK STARTS HERE

EXPAL0:	MOVX T1,USRCTX	;SET FUNNY JSYS CONTEXT
	MOVEM T1,FFL
	SETZM FPC		;SET PC
	MCENTR
	CALL EXPAL1		;AWAY WE GO
	HRRZS EXPFRK		;SAY WE ARE DONE
	HALTF			;AND STOP

EXPAL1:	MOVX T2,SF%CDE!SF%BTE
	TDNE T2,FACTSW		;ANY BIT TABLE ERRORS?
	RET			;YES. DON'T EXPUNGE
IFN STANSW,<
	HRROI T2,[ASCIZ /
[Deleted files will be expunged from system structure in 5 minutes.]
/]
	MOVE T3,FACTSW
	TXNE T3,SF%MS1		;WANT LEVEL 1 MESSAGES?
	 CALL ALLMSG
	MOVE T1,[<5*^D60000>-^D30000]	;5 MIN. LESS 30 SECONDS
	DISMS%			;WAIT FOR SOMETHING TO HAPPEN
	SETZ T1,		;HAVE WE FREED ANY PAGES?
	CALL GSTRPG		;GET SPACE ON PRIMARY STRUCTURE
	SUB T2,SYSSPC		;LESS BUFFER
	CAMG T2,SYSSPC		;LOW STILL?
	IFSKP.
	  HRROI T2,[ASCIZ/
[Systemwide expunge postponed]
/]				;NO, WE NEEDN'T UNDERGO THE ORDEAL!!
	  MOVE T3,FACTSW
	  TXNE T3,SF%MS1	;WANT LEVEL 1 MESSAGES?
	   CALL ALLMSG
	  RET
	ENDIF.
>;IFN STANSW
	HRROI T2,[ASCIZ /
[Deleted files will be expunged from system structure in 30 seconds]
/]
	MOVE T3,FACTSW
	TXNE T3,SF%MS1		;WANT LEVEL 1 MESSAGES?
	CALL ALLMSG
	MOVEI T1,^D30000
	DISMS			;GIVE USERS TIME TO UNDELETE
	MOVX T1,RC%AWL		;ALLOW WILD CARDS
	HRROI T2,[ASCIZ "PS:<*>"]
	RCDIR			;GET FIRST DIRECTORY NUMBER
	 ERJMP [BUG.(CHK,EXPRCD,MEXEC,HARD,<EXPALL - RCDIR failure>,,<

Cause:	RCDIR% failed to translate the first directory of PS:<*> to a
	directory number in routine EXPALL.

Action:	The system-wide expunge of PS: has not been done.

>)
		JRST EXPAL3]	;WE TRIED
EXPAL2:	SETZ T1,		;NOTHING SPECIAL
	MOVE T2,T3		;PUT DIRECTORY NUMBER IN RIGHT PLACE
	DELDF			;EXPUNGE
	 ERJMP .+1		;IGNORE FAILURES
	MOVX T1,RC%STP!RC%AWL	;STEP TO NEXT
	MOVE T3,T2		;WHERE WE LEFT OFF
	HRROI T2,[ASCIZ "PS:<*>"] ;WHERE WE STARTED
	RCDIR			;...
	 ERJMP EXPAL3		;QUIT ON FAILURE
	TXNN T1,RC%NMD		;DONE?
	JRST EXPAL2		;NO - KEEP GOING

EXPAL3:	MOVX T1,<EXWTIM*^D60000>	;DONE, SET NEXT POSSIBLE TIME
	ADD T1,TODCLK
	MOVEM T1,EXPTIM
	HRROI T2,[ASCIZ /
[System structure expunge completed]
/]
	MOVE T3,FACTSW
	TXNE T3,SF%MS1		;WANT LEVEL 1 MESSAGES?
	CALL ALLMSG		;NOTIFY USERS
	RET			;DONE

CHKDSK:	RET			;NOP

CHKDE1:	RET			;NOP

;UTILITY NUMBER PRINTERS
;DECIMAL PRINT FOR LESS THAN 18 BIT NUMBERS
;OCTAL PRINT FOR MORE THAN 18 BIT NUMBERS DOES DDT HALFWORD FORMAT.

;A/ BYTE POINTER, IF TTDECP CALLED
;B/ NUMBER TO PRINT
;	CALL TTXXXP	;XXX=(DEC,OCT)
;NUMBER PRINTED TO PRIMARY OUTPUT

TTDECP:	SKIPA C,[^D10]		;DECIMAL
TTOCTP:	MOVEI C,^D8		;IN OCTAL
	TLNN B,-1		;LH NON-0?
	JRST TTOCT1		;NO, SIMPLE PRINT
	PUSH P,B		;SAVE DATA
	HLRZ B,B		;PRINT LH
	NOUT
	 JFCL
	MOVEI B,","		;PRINT ,,
	IDPB B,A
	IDPB B,A
	POP P,B			;RECOVER DATA
	HRRZ B,B
TTOCT1:	NOUT			;PRINT RH
	 JFCL
	RET

;ANY INTERRUPT WILL EVENTUALLY TRAP TO HERE

CHKRI:	BUG.(CHK,JB0CSH,MEXEC,SOFT,<Job 0 crash>,<<ITFPC,PC>,<LSTERR,LSTERR>>,<

Cause:	An unexpected interrupt has occurred in the job 0 fork which
	checks system status.  The context will be reinitialized, and
	the process restarted.  The stack may be examined to determine
	the situation which caused the error.

Data:	PC - PC at which error occurred.
	LSTERR - Last error code for this fork.
>)
	SETZM NSKED		;BE OKSKED
	SETZM CRSKED		;BE NOT 'CRITICAL SECTION'
	MOVX CX,USRCTX
	MOVEM CX,FFL
	MCENTR			;REINIT CONTEXT
	SETZM PSIBW
	JRST CHKR

NR CHKDRE,1			;COUNT OF REC. ERRORS AT LAST REPORT
NR CHKDNE,1			; "" NON-REC. ""
NR CHKDMC,1

;CHKBGS - CHECK IF TIME TO STORE NEW ASCII TIME AND DATE FOR TYPEOUT
;	  AT BUGHLT TIME
;
;RETURNS:  +1,	ALWAYS

CHKBGS:	MOVE T1,TODCLK		;GET CURRENT DATE AND TIME
	CAML T1,BUGTMS		;TIME TO STORE ASCII STRING?
	SKIPGE TADIDT		;HAS TIME BEEN SET
	RET			;NO, NOT YET
	MOVX T2,<BUGINT>	;GET TIME INTERVAL FOR STORING STRING
	ADD T1,T2		;GET NEXT TIME FOR STORING STRING
	MOVEM T1,BUGTMS		;STORE
	MOVE T1,[POINT 7,BUGTIM] ;GET BYTE POINTER FOR STORING TIME
	MOVNI T2,1		;GET CURRENT TIME AND DATE
	SETZ T3,		; IN DEFAULT FORMAT
	ODTIM
	MOVE T2,"/"		;STORE DELIMITER FOR BUGMSG ROUTINE
	IDPB T2,T1
	RET

;ROUTINE TO FINISH LOGGING OF PARITY ERROR - RUN IN JOB 0 CONTEXT

; T1/ ADDRESS OF SYSERR BLOCK

PFCPJ0::SAVEQ
	HLRZ FX,SEBDAT+PT%JOB(T1) ;GET FORKX AT TRAP
	CAIE FX,-1
	SKIPGE FKPT(FX)
	RET			;IN SCHED OR FORK KILLED, NO DATA
	LOAD T2,FKJBN		;GET JOB NUMBER
	HRRM T2,SEBDAT+PT%JOB(T1) ;REPORT IT
	HRRZ T3,JOBDIR(T2)	;GET LOGGED-IN DIRECTORY
	HRLI T3,USRLH		;MAKE IT A USER NUMBER
	MOVEM T3,SEBDAT+PT%USR(T1) ;REPORT IT
	MOVE T3,JOBPNM(T2)	;GET PROGRAM NAME
	MOVEM T3,SEBDAT+PT%PGM(T1) ;REPORT IT
	RET

;THE CHKAC JSYS - CHECK THE ACCESSABILITY OF A FILE OR DIRECTORY

;ACCEPTS IN 1/	COUNT OF ARGUMENTS
;	    2/	LOCATION OF ARGUMENT BLOCK
;	CHKAC
;RETURNS +1:	ERROR - ERROR CODE IN AC 1
;	 +2:	AC 1 = 0	ACCESS NOT ALLOWED
;		AC 1 = -1	ACCESS IS ALLOWED

;ARGUMENT BLOCK:
;	.CKAAC	DESIRED ACCESS CODE
;	.CKALD	LOGGED IN USER NUMBER OF THE USER DOING THE ACCESSING
;	.CKACD	CONNECTED STRUCTURE,,DIRECTORY OR POINTER TO STRUCTURE/
;		DIRECTORY STRING
;	.CKAEC	ENABLED CAPABILITIES OF THE USER
;	.CKAUD	STRUCTURE,,DIRECTORY OR POINTER TO STRUCTURE/DIRECTORY STRING
;		FOR FILE BEING ACCESSED
;		IF CK%JFN IS SET IN AC1, THIS IS JFN FOR FILE
;	.CKAPR	PROTECTION OF FILE BEING ACCESSED

.CHKAC::MCENT			;ENTER JSYS
	STKVAR <<SVT3T4,2>>
	UMOVE Q1,2		;GET LOCATION OF ARGUMENT BLOCK
	XCTU [HRRZ T1,1]	;GET LENGTH OF ARGUMENT BLOCK
	XCTU [HLL Q1,1]		;GET THE FLAGS
	TXNN Q1,CK%JFN		;SPECIFIING A JFN?
	CAILE T1,.CKAPR		;NO, MUST INCLUDE PROTECTION
	CAIGE T1,.CKAPR		;YES, PROTECTION NOT NEEDED
	RETERR (CKAX1)		;LENGTH IS TOO SHORT
	XCTU [MOVE T1,.CKAEC(Q1)] ;LENGTH IS OK, GET CAPABILITIES
	TRNE T1,SC%WHL!SC%OPR	;IS THIS USER A WHEEL?
	JRST CHKACT		;YES, ACCESS IS LEGAL ALWAYS
	XCTU [HRRZ P1,.CKAAC(Q1)] ;GET ACCESS CODE
	UMOVE T1,.CKAUD(Q1)	;GET THE JFN OR DIRECTORY DESIGNATOR
	TXNE Q1,CK%JFN		;IS USER GIVING A JFN?
	JRST CHKAC2		;YES
	CALL CNVSTD		;CONVERT TO A DIRECTORY NUMBER
	 RETERR ()		;ILLEGAL FORMAT OF STRING
CHKAC2:	MOVE P2,T1		;SAVE JFN OR DIR NUMBER IN P2
	UMOVE T1,.CKALD(Q1)	;GET THE LOGGED IN USER NUMBER
	LOAD T2,NMFLG,T1	;GET BITS 0-2
	CAIN T2,NUMVAL		;IS THIS A NUMBER?
	JRST CHKAC3		;YES, DONT NEED TO CONVERT THE STRING
	CALL CNVSTU		;CONVERT STRING TO USER NUMBER
	 RETERR ()		;FAILED
CHKAC3:	CALL CNVDIR		;CONVERT IT TO A DIR NUMBER
	MOVE P3,T1		;SAVE DIRECTORY # IN P3
	UMOVE T1,.CKACD(Q1)	;GET CONNECTED DIR # INTO P4
	CALL CNVSTD		;GET DIR NUMBER FROM STRING
	 SETZ T1,		;FAILED TO GET A DIRECTORY NUMBER
	MOVE P4,T1		;SAVE DIR NUMBER FOR LATER
	TXNN Q1,CK%JFN		;GIVING A JFN?
	XCTU [HRLZ P5,.CKAPR(Q1)] ;NO, GET PROTECTION
	TXNE Q1,CK%JFN		;USER GIVING A JFN?
	JRST [	HRRZ T1,P2	;YES, GET IT
		CALL GETFPD	;GET PROT AND DIR #
		 RETERR (CKAX4)	;BAD JFN
		MOVE P2,T1	;SAVE DIR #
		HRLZ P5,T2	;SAVE PROTECTION
		JRST .+1]
	MOVE T1,P2		;MAP IN DIRECTORY OF FILE
	CALL SETDIR		;FIRST CHECK LEGALITY OF DIR #
	 RETERR (CKAX2)		;ILLEGAL DIR #
	ULKDIR			;UNLOCK DIR, BUT STAY NOINT
	CAIL P1,.CKADR		;IS THIS A DIRECTORY ACCESS CHECK?
	JRST CHKDIR		;YES, GO SET UP DIR PROTECTION VALUE
	MOVEI T4,<DP%RD>B35	;MUST ALSO CHECK READ ACCESS TO DIR
CHKAC0:	MOVSI Q2,40		;SET UP MASK WORD
	MOVN T1,P1		;GET CODE
	LSH Q2,0(T1)		;FORM THE ACCESS CHECK MASK
	TDNE Q2,P5		;IS THIS MODE ALLOWED FOR WORLD?
	JRST [	MOVE T1,DIRORA	;YES, NOW SEE IF LEGAL TO REF DIR
		LOAD T1,DRPRT,(T1) ;GET DIRECTORY PROTECTION
		TDNE T4,T1	;LEGAL TO REFERENCE IT?
		JRST CHKACT	;YES, THIS IS LEGAL THEN
		JRST .+1]	;NO, GO SEE IF THIS IS OWNER OR GROUP
	HLLZ T1,P5		;MAKE OWNER SUPERSET OF GROUP
	LSH T1,6
	IORM T1,P5		;DONT ALLOW GROUP MORE PRIVS THAN OWNER
	LSH Q2,^D12		;NOW SEE IF LEGAL FOR OWNER
	LSH T4,^D12		;DO SAME FOR DIR PROTECTION MASK
	MOVE T3,DIRORA		;GET BASE ADR OF MAPPED DIR
	LOAD T3,DRPRT,(T3)	;GET DIR PROTECTION
	MOVE T2,T3
	LSH T2,6		;MAKE OWNER SUPERSET OF GROUP
	IORM T2,T3		;T3 = DIR PROTECTION
	TDNE T4,T3		;LEGAL ACCESS FOR OWNER IN DIRECTORY?
	TDNN Q2,P5		;YES, IS FILE ACCESS LEGAL?
	JRST CHKACF		;IF NOT LEGAL FOR OWNER, THEN FALSE
	CAME P3,P2		;IS THIS FILE IN SAME DIR AS USER?
	CAMN P4,P2		;EITHER LOGGED IN OR CONNECTED
	JRST CHKACT		;YES, RETURN TRUE
	DMOVEM T3,SVT3T4	;SAVE T3 AND T4
	SETZ P4,		;FLAG FOR DIFFERENT STRUCTURES
	HLRZ T1,P2		;GET STRUCTURE TO ACCESS
	HLRZ T2,P3		;GET LOGGED IN STRUCTURE UNIQUE CODE
	CAMN T1,T2		;ARE THEY THE SAME?
	JRST CHKAC4		;YES, FORGET DOMESTIC STR TEST
	HLRZ T1,P2		;GET STRUCTURE UNIQUE CODE
	CALL CNVSTR		;GET STRUCTURE NUMBER
	 RETERR ()		;COULDN'T FIND STRUCTURE
	MOVE T2,T1		;SAVE STRUCTURE NUMBER
	CALL ULKSTR		;UNLOCK STRUCTURE FROM CNVSTR
	MOVE T2,STRTAB(T2)	;GET STRUCTURE DATA BLOCK ADDRESS
	MOVE T1,SDBSTS(T1)	;GET STATUS OF STRUCTURE
	TXNN T1,MS%DOM		;IS IT DOMESTIC?
	JRST CHKACF		;NO, RETURN FALSE
	MOVEI T2,MAXLW+1	;GET SOME JSB FREE SPACE
	CALL ASGJFR		; IN WHICH TO STORE USER NAME
	 RETERR (SACTX2)	;INSUFFICIENT RESOURCES
	MOVE P4,T1		;STORE FREE SPACE BLOCK ADDRESS
	AOS T1			;DON'T STEP ON HEADER
	HRLI T1,-1		;MAKE IT A POINTER
	MOVE T2,P3		;GET LOGGED IN DIRECTORY
	HRLI T2,USRLH		;MAKE IT A USER NUMBER
	DIRST			;GET USER NAME
	 JRST [ MOVEI T1,JSBFRE	;RELEASE FREE SPACE
		MOVE T2,P4
		CALL RELFRE
		RETERR ()]
	MOVE T1,P4		;GET ADDRESS OF NAME
	HLRZ T2,P2		;GET STUCTURE UNIQUE CODE
	CALL DIRLKX		;DOES USER HAVE A DIRECTORY ON THIS STR?
IFE STANSW,<
	 JRST [	MOVEI T1,JSBFRE	;NO DIRECTORY ON THAT STRUCTURE
		MOVE T2,P4	;RELEASE FREE SPACE
		CALL RELFRE
		JRST CHKACF]	;RETURN FALSE
>;IFE STANSW
IFN STANSW,<
;APPLY PUBLIC STRUCTURE USER GROUPS TO OTHER DOMESTIC STRUCTURES
	 SETZ T1,		;NO, MEANS ONLY NO OWNER ACCESS
>;IFN STANSW
	MOVE T2,P4		;GET ADDRESS OF JSB SPACE
	MOVE P4,T1		;STORE DIRECTORY NUMBER
	MOVEI T1,JSBFRE
	CALL RELFRE		;RETURN JSB SPACE
	HLL P4,P2		;ADD STR UNIQUE CODE TO DIR NUMBER
	CAMN P2,P4		;TRYING TO ACCESS OUR OWN DIRECTORY?
	JRST CHKACT		;YES, RETURN SUCCESS
IFN STANSW,<
;APPLY PUBLIC STRUCTURE USER GROUPS TO OTHER DOMESTIC STRUCTURES
	SETZ P4,		;PRETEND ACCESS AS IF FOR A P.S. DIRECTORY
>;IFN STANSW
	MOVE T1,P2		;MAP IN DESIRED DIRECTORY AGAIN
	CALL SETDIR
	 RETERR ()
	ULKDIR			;UNLOCK DIRECTORY
CHKAC4:	DMOVE T3,SVT3T4		;RESTORE T3 AND T4
	LSH Q2,-6		;NO, NOW SEE IF THIS IS SAME GROUP
	LSH T4,-6		;SAME FOR GROUP
	TDNE T4,T3		;LEGAL ACCESS TO DIR BY GROUPS?
	TDNN Q2,P5		;YES, LEGAL FOR GROUP?
	JRST CHKACF		;NO, RETURN FALSE
	CALL CPYDGP		;COPY DIR GROUPS INTO JSB
	 JRST CHKACF		;NO GROUPS
	MOVE P6,T1		;SAVE THE JSB POINTER
	SKIPN T1,P4		;TRYING TO ACCESS DIR ON PRIMARY STRUCTURE?
	MOVE T1,P3		;YES, GET LOGGED IN DIRECTORY
	CALL SETDIR		;GET INFO ABOUT THIS USER
	 RETERR (CKAX2)		;ILLEGAL DIRECTORY NUMBER
	ULKDIR			;UNLOCK THE DIRECTORY LOCK FROM GETDDB
	MOVE Q1,P6		;GET AOBJN POINTER TO DIR GROUP LIST
CHKAC1:	HLRZ T1,0(Q1)		;GET FIRST MEMBER OF GROUP
	CALL CHKUGP		;CHECK IT AGAINST USER GROUPS
	 SKIPA			;NO MATCH
	JRST [	MOVE A,P6	;MATCH FOUND
		CALL RELGRP	;RELEASE THE SPACE IN THE JSB
		JRST CHKACT]	;RETURN TRUE
	HRRZ T1,0(Q1)		;GET NEXT MEMBER OF GROUP
	CALL CHKUGP		;CHECK FOR MATCH
	 SKIPA			;NO MATCH
	JRST [	MOVE A,P6	;MATCHED!
		CALL RELGRP	;RELEASE THE JSB SPACE
		JRST CHKACT]	;RETURN TRUE
	AOBJN Q1,CHKAC1		;LOOP UNTIL LIST IS FINISHED
	MOVE A,P6		;RELEASE THE SPACE IN JSB
	CALL RELGRP
CHKACF:	TDZA T1,T1		;RETURN FALSE
CHKACT:	SETO T1,		;TRUE
	UMOVEM T1,1		;STORE ANSWER
	SMRETN			;AND RETURN

CHKDIR:	CAIL P1,.CKADR		;IS THIS A LEGAL FUNCTION CODE
	CAILE P1,.CKACF
	RETERR (CKAX3)		;NO, ILLEGAL ACCESS CODE
	SUBI P1,.CKADR		;SET UP FOR MASK BUILDING
	MOVE T4,DIRORA		;GET BASE OF DIR AREA
	LOAD T4,DRPRT,(T4)	;GET DIR PROTECTION
	HRL P5,T4		;ONLY WANT 18 BITS
	MOVEI T4,77		;DONT CARE ABOUT DIR PROTECTION CHECK
	JRST CHKAC0		;GO FINISH JSYS


;ROUTINE TO COPY A LIST OF GROUPS TO THE JSB
;	CALL CPYDGP	OR	CALL CPYUGP
;RETURNS +1:	NO GROUPS
;	 +2:	AOBJN POINTER TO LIST IN JSB RETURNED IN T1

CPYDGP::EA.ENT			;ENTER SEC 1
	MOVE D,DIRORA		;GET BASE OF DIR AREA
	LOAD D,DRDGP,(D)	;GET DIR GROUP LIST
	JRST CPYUG0		;ENTER COMMON CODE

CPYUGP::EA.ENT			;ENTER SEC 1
	MOVE D,DIRORA		;GET BASE OF DIR AREA
	LOAD D,DRUGP,(D)	;GET USER GROUP LIST
CPYUG0:	JUMPE D,R		;IF 0, NO LIST
	STKVAR <CPYUGA>
	ADD D,DIRORA		;GET ABS ADR OF LIST
	LOAD C,BLKTYP,(D)	;GET TYPE OF THIS BLOCK
	CAIE C,.TYGDB		;MUST BE A DIRECTORY GROUP BLOCK
	RET			;DIR IS SCREWED UP
	LOAD B,BLKLEN,(D)	;GET LENGTH OF BLOCK
	SOS B			;SKIP OVER HEADER
	MOVEM D,CPYUGA		;SAVE ADR OF LIST
	CALL ASGJFR		;GET A BLOCK FROM JSB
	 RET			;NO ROOM
	MOVE D,CPYUGA		;GET BACK ADR OF LIST
	HRRZ B,0(A)		;GET LENGTH OF DIR LIST
	MOVNS B			;SET UP AN AOBJN POINTER TO JSB
	HRL A,B
	MOVE C,A		;LEAVE POINTER IN A
CPYUGL:	MOVE B,1(D)		;GET NEXT ELEMENT IN LIST
	MOVEM B,0(C)		;STORE IN JSB
	AOS D			;STEP TO NEXT ELEMENT IN LIST
	AOBJN C,CPYUGL		;LOOP TIL LIST IS COPIED
	RETSKP			;RETURN SUCCESSFUL WITH POINTER IN A


;ROUTINE TO RELEASE A GROUP LIST FROM JSB
;ACCEPTS IN A/	POINTER TO LIST
;	CALL RELGRP
;RETURNS +1:	ALWAYS

RELGRP::HLRE B,A		;GET LENGTH OF BLOCK
	HRRZS	A		;INSURE IN THIS SECTION
	MOVNM B,(A)		;STORE LENGTH IN BLOCK
	HRRZ B,A		;GET ADR OF BLOCK
	MOVEI A,JSBFRE
	CALLRET RELFRE		;RELEASE THE BLOCK

   REPEAT 0,<			;***** NO LONGER USED ****

;MDDT INTERNAL SUBROUTINE CALL.  THIS SUBROUTINE IS THE INTERFACE
;BETWEEN MDDT AND THE REST OF THE MONITOR.  CALL:
;
;	AC1/	FUNCTION CODE
;	AC2-AC4/ ARGUMENTS
;	CALL .IMOPR
;	  ERROR RETURN
;	SUCCESSFUL RETURN



.IMOPR::JUMPLE T1,R		;FAIL IF NOT POSITIVE
	CAIG T1,IMMAX		;FUNCTION LEGAL?
	SKIPN HSYBLK		;SYMBOLS HIDDEN? (FUNCTIONS SO FAR NEED THIS)
	RET			;NO, GIVE ERROR RETURN
	JRST @IMTAB-1(T1)	;GO TO PROPER ROUTINE



IMTAB:	IFIW	IMALC		;(1) ALLOCATE PAGES FOR USE
	IFIW	IMMAP		;(2) MAP PAGES OF THE SYMBOL SPACE
	IFIW	IMUMAP		;(3) UNMAP PAGES OF SYMBOLS

	IMMAX==.-IMTAB		;HIGHEST FUNCTION




;FUNCTION .IMALC.  ALLOCATES A PAGE FOR USE IN MAPPING SYMBOLS.  PAGE
;IS RELEASED WHEN FORK IS DESTROYED.  MULTIPLE CALLS WILL RETURN THE
;SAME PAGE.  ARGUMENTS:
;
;	T2/	NUMBER OF PAGES DESIRED (ONLY 1 IS LEGAL NOW)
;
;RETURNS PAGE NUMBER OF FIRST PAGE IN T1.


IMALC:	CAIE T2,1		;ASKING FOR ONE PAGE?
	RET			;NO, FAIL
	NOINT			;PREVENT INTERRUPTIONS
	SKIPE T1,SYMPAG		;PREVIOUSLY ALLOCATED A PAGE?
	JRST IMALCH		;YES, RETURN IT
	CALL ASGPAG		;GET A NEW JSB PAGE
	SETZ T1,		;NONE AVAILABLE
	MOVEM T1,SYMPAG		;REMEMBER FOR LATER USE
IMALCH:	OKINT			;INTERRUPTS OK NOW
	LSH T1,-PGSFT		;CONVERT TO PAGE NUMBER
	JUMPN T1,RSKP		;SKIP RETURN IF GOT A PAGE
	RET			;OTHERWISE FAIL

;FUNCTION .IMMAP.  MAP PAGES OF THE SYMBOL SPACE.  USED BY MDDT
;AND SNOOP JSYS.  ARGUMENTS:
;
;	T2/	PAGE IN SYMBOL SPACE TO MAP
;	T3/	PAGE IN MONITOR SPACE TO MAP TO
;	T4/	COUNT OF PAGES TO MAP.  1B0 SET IF WRITE ENABLED


IMMAP:	MOVE T1,T2		;SET UP PAGE NUMBER TO MAP
	HRL T1,SYMBAS		;AND PUT IN SPT INDEX OF SYMBOL MAP
	TDNN T2,[-1,,777000]	;SYMBOL SPACE EXISTS ONLY IN SECTION 0
IMMAP1:	TDNE T3,[-1,,776000]	;SEE IF PAGE IS SECTION 0 OR 1
	RET			;IF NOT, ERROR
	ANDI T3,777		;MAKE SECTION 1 SAME AS SECTION 0
	MOVE T2,T3		;GET PAGE WHERE WE MAP TO
	LSH T2,PGSFT		;TURN INTO ADDRESS
	TXZE T4,1B0		;WANT IT WRITE-ENABLED?
	TXO T2,PTRW		;YES, SET WRITE BIT
	TLNN T4,-1		;CHECK REST OF LEFT HALF
	TRNN T4,-1		;AND MAKE SURE HAVE NONZERO COUNT
	RET			;NO, ERROR
	ADDI T3,-1(T4)		;CALCULATE LAST PAGE TO BE MAPPED
	TRNE T3,777000		;MAKE SURE IT STAYS IN SECTION 0
	RET			;NO, ERROR
	MOVE T3,T4		;PUT COUNT IN RIGHT AC
	CALL MSETMP		;DO THE MAPPING
	RETSKP			;GOOD RETURN



;FUNCTION .IMUMP.  UNMAP SYMBOL PAGES.  ARGUMENTS ARE:
;
;	T2/	PAGE IN NORMAL SPACE WHERE SYMBOLS WERE MAPPED
;	T3/	COUNT OF PAGES TO UNMAP


IMUMAP:	MOVE T4,T3		;MOVE ARGS TO RIGHT ACS
	MOVE T3,T2		;SO CAN JOIN OTHER ROUTINE
	SETZM T1		;ZERO FOR UNMAP
	CALLRET IMMAP1		;GO DO THE WORK

   >				;**** END OF REPEAT 0 AROUND .IMOPR ****

;LOGOUT

.LGOUT::MCENT
	CAME 1,[-1]		;SELF?
	JRST ELOGO		;NO
	MOVSI 1,(SC%LOG)
	TDNN 1,CAPMSK		;LOG PERMITTED?
	RETERR (LOUTX4)		;NO, ERROR RETURN
	SETONE JSELO		;FLAG THAT JOB EXECUTED ITS OWN LGOUT
LOGO:	SE1ENT			;GET TO SECTION 1
	MOVE T1,JOBNO		;GET CORRECT JOB NUMBER
	CALL LGOGOK		;CHECK TO SEE IF LOGO LEGAL
	SKIPN FORKN		;TOP FORK?
	JRST FLOGO1		;YES
	NOINT
	HLRZ 1,FORKN		;NO, GET ITS NUMBER
	HRRZ 2,SYSFK(1)
	NOSKED
	SETONE <FKPS0,FKILO>,(T2) ;REQUEST LOGOUT INTERRUPT
	CALL PSIR4
	OKSKED
	OKINT
	JRST WAIT1		;WAIT FOR TOP FORK TO KILL THE JOB

;ROUTINE CALLED TO LOGOUT ANOTHER JOB.
;ACCEPTS:	A/ JOB NUMBER
;RETURNS:	+1 WITH LOGOUT REQUESTED

	RESCD			;MUST BE RESIDENT AS CALLED BY SCHEDULER

ELOGOO::NOSKD1			; prevent races
	SKIPGE JOBRT(T1)	; job exist?
	JRST [	OKSKD1			; no, fail
		RET]			;  ..
	HRRZ 2,JOBPT(1)		;TOP FORK OF OBJECT JOB
	SETONE <FKPS0,FKILO>,(T2) ;REQUEST LOGOUT INTERRUPT
	CALL PSIR4
	OKSKD1			;ALLOWING SCHEDULING AGAIN
	RET			;AND DONE

;THE FOLLOWING IS RUN IN THE TOP FORK OF A JOB TO RESPOND TO
;A LOGOUT REQUEST FROM ANOTHER JOB.
;HERE FROM PSI SERVICE DEBREAK.  FFL AND FPC SETUP.

	SWAPCD

FLOGO::	MCENTR			;SIMULATE ENTRY FROM USER
	; ..

;THE FOLLOWING CODE DOES THE ACTUAL LOGOUT.  IT RUNS ONLY IN
;THE TOP FORK OF THE JOB BEING LOGGED OUT

	; ..
FLOGO1:	MOVX 1,LOGIOB		;SAY JOB DESTRUCTION IN PROGRESS
	IORM 1,JOBBIT

	MOVE T1,JOBNO		;GET OUR JOB NUMBER
	HLRZ T1,JOBPT(T1)	;GET A POSSIBLE CRJOB INDICATOR
	CAIE T1,-2		;IS THIS THE OBJECT OF A CRJOB?
	SKIPGE CRJFLG		;NO, TRY DIFFERENT TEST
	 SETOM CRJANS		;YES, FORCE EXECUTOR OF CRJOB JSYS TO WAKE UP.

	MOVEI 1,400000
	SETO 2,
	DIC			;DEACTIVATE INTERRUPTS AND KEYS
	CALL DTIALL
	CALL NETLGO		;RELEASE ANY JOB-WIDE NETWORK RESOURCES
	CALL INTLGO		;RELEASE ANY JOB WIDE INTERNET RESOURCES
	CALL DAPLGO		;RELEASE ANY JOB-WIDE DAP% RESOURCES
	MOVE T1,FORKX		;GET FORK NUMBER OF TOP FORK
	CALL SCSLGO		;RELEASE ANY SCS% RESOURCES OWNED BY TOP FORK
	MOVEI T1,-4
	KFORK			;DELETE FORKS
	MOVE T1,JOBNO		;MARK THAT I AM NO LONGER OWNED
	SETOM JOBONT(T1)	; ..
	MOVSI T3,-NJOBS		;LOG OUT ANY JOBS WHICH I OWN
SJLGO1:	HRRZ T2,JOBONT(3)	;DO I OWN THIS ONE?
	CAME T2,GBLJNO		; ..
	 JRST SJLGO2		;NO.
	SETOM JOBONT(T3)	;MAKE IT UNOWNED, SO IT FINISHES
	MOVEI T1,0(T3)		;YES. LOG IT OUT.
	CALL LCL2GL		;Convert his index into a global job number
	 JRST SJLGO2		;and go back to the loop
	LGOUT
	 JFCL			;SHOULD HAVE WORKED.
SJLGO2:	AOBJN T3,SJLGO1		;SEE IF I OWN ANY MORE JOBS
	; ..

	; ..
SJLGO4:	SETO T1,			;CLEAR USER MAP OF TOP FORK
	MOVSI 2,<.FHSLF!FH%EPN>		;THIS FORK
	MOVE 3,[PM%CNT!PM%EPN!<1000>B35] ;REQUEST 1000 PAGES
	PMAP
	 ERJMP .+1
	MOVE FX,FORKX
	RESET			;CLEAN UP JSB STACK
	LOAD 1,FKJSB		;GET JSB
	CALL WTSPT		;WAIT FOR SHR CNT OF 1
	SKIPL CTRLTT
	RESET			;RESET TTY MODES, ETC.
	CALL UNPAGE		;CLEAR PAGE MODE
	MOVE T1,FORKX		;THIS FORK...
	CALL ENQFKR		;RELEASE ANY ENQ LOCKS OWNED BY THIS JOB
	MOVE 1,[CZ%ARJ+CZ%ABT+400000] ;WAIT+FLUSH NONX + THIS FORK
	CLZFF
IFE FTNSPSRV,<
	CALL SCLGOU        	;CLEAN UP DECNET SJB, PORT TABLE, AND SAB
;**; [7173] Change 1 line at SJLGO4:+17	HMP	23-Oct-85
	CALL LLMRJB		;[7173] ~6.0 Release LLMOP Request Blocks for this job
>
	MOVE 1,FORKX		;NOW KILL PIDS OF THIS FORK
	CALL PIDKFK		; INCLUDING JOB WIDE PIDS
	CALL CLKREL		;RELEASE TIMER BLOCKS
	MOVE 4,JOBNO
	HRRZ 1,JOBDIR(4)	;GET LOGIN DIR
	JUMPE 1,LOG1		;DON'T EXPUNGE IF NOT LOGGED IN
	HRLI T1,USRLH		;GET USER NUMBER
	CALL CNVDIR		;CONVERT IT TO A DIRECTORY NUMBER
	MOVE T2,T1		;SET UP FOR DELDF
	MOVX T1,DD%DTF		;DELETE TEMPORARY FILES
	PUSH P,T2		;SAVE DIR NUMBER
	DELDF			;EXPUNGE LOGIN DIR
	 ERJMP .+1		;DONT STOP ON ERRORS
	CALL GTCSCD		;GET CONNECTED STRUCTURE,,DIRECTORY
	POP P,T3		;GET BACK DIR # FROM LAST DELDF
	CAMN T1,T3		;ARE THEY THE SAME?
	JRST LOG0		;YES, DO NO EXPUNGE AGAIN
	MOVE T2,T1		;GET DIR NUMBER INTO 2
	MOVX T1,DD%DTF		;DELETE TEMPORARY FILES
	DELDF			;EXPUNGE CONNECTED DIR
	 ERJMP .+1		;DONT STOP ON ERRORS
LOG0:	CALL LOGSTR		;GO DECREMENT MOUNT COUNT FOR ALL STR'S
				; THIS JOB HAS MOUNTED
	MOVNI 1,1		;NOW RELEASE ALL ASSIGNED DEVICES
	RELD
	 JFCL
	MOVE 1,LOGDES
IFE STANSW&SUMXSW,<
	MOVE 1,LOGDES
	DOBE			;WAIT FOR LOG TTY INACTIVE
>;IFE STANSW&SUMXSW
IFN STANSW&SUMXSW,<
	MOVX T1,.NULIO		;DON'T CLUTTER UP LOGTTY
>;IFN STANSW&SUMXSW
	CALL LOGTOT		;SUMMARY TO LOG TTY
	CALL LOGTUS		;Perform USAGE for logout
LOG1:	HRRE 1,CTRLTT
	JUMPL 1,LOG2		;CONTROL TTY?
	MOVEI 1,400000(1)	;YES, PRINT LOGOUT MESSAGE
	RFMOD			;TURN OFF PAGE MODE
	 ERJMP	.+1		;ignore errors
	TXZ 2,TT%PGM		;TO ALLOW THE MESSAGE TO COME OUT
	STPAR
	 ERJMP	.+1		;ignore errors
	CALL LOGTOT
	HRLOI T1,(TL%CRO+TL%COR+TL%SAB+TL%ABS)
	SKIPGE T2,CTRLTT	;GET TTY
	 JRST LOG2		;IF DETACHED
	CAMN T2,CTYLNO		;Logging off CTY?
	TXZ T1,TL%ABS		;Yes - set refuse links
	MOVEI T2,-1
	TLINK			;BREAK LINKS, SET ACCEPT
	 JFCL
	MOVEI T4,^D15		;WAIT FOR 15 SECONDS MAX
LOG21:	HRRE T1,CTRLTT		;GET TTY #
	JUMPL T1,LOG2		;NONE
	MOVEI T1,400000(1)	;GET DESIGNATOR
	SOBE			;LOGOUT MESSAGE COMPLETE?
	IFNSK.
	  MOVEI T1,^D1000	;NO, WAIT A SECOND
	  DISMS
	  SOJG T4,LOG21		;TRY AGAIN OR GIVE UP
	ENDIF.
	CFOBF			;FLUSH OUTPUT BUFFER FOR GOOD MEASURE
	 ERJMP .+1
      DO.
	SKIPGE T2,CTRLTT	;IF DETACHED, DON'T HANG UP
	EXIT.
	MOVE T1,JOBNO
	HRRZ T1,JOBDIR(1)
	IFE. T1			;LOGGED IN?
	  SKIPN HNGU0F		;NO, HANGUP IN THIS CASE?
	  EXIT.			;NO
	ELSE.
	  SKIPN HNGU1F		;YES, HANGUP IN THIS CASE?
	  EXIT.			;NO
	ENDIF.
	CALL TTHNGU		;HANG UP LINE
      ENDDO.
IFN STANSW,<
	SKIPLE T2,CTRLTT	;GET CONTROLLING TERMINAL
	 CALL BANNER		;PUT A BANNER ON WHAT FEW LOCAL LINES WE HAVE
>;IFN STANSW

;HERE IF NO CTY

LOG2:	MOVEI T1,SPIDTB+.SPQSR	;GET PID ADDRESS
	SKIPE SPIDTB+.SPQSR	;IS QUASAR RUNNING?
	CALL LOGOMS		;YES, SEND IT A MESSAGE
	 JFCL
	MOVEI T1,SPIDTB+.SPOPR	;GET ORION PID ADDRESS
	SKIPE SPIDTB+.SPOPR	;RUNNING?
	CALL LOGOMS		;YES, SEND IT A MESSAGE
	 JFCL
	SKIPE T1,JSLOPD		;IS THERE A PID IN JSB FOR LGOUT MSG?
	CALL LOGOMO		;YES. SEND THE LOGOUT MESSAGE TO CREATOR
	 JFCL
	MOVE T1,GBLJNO		;GET GLOBAL JOB NUMBER
	CALL JBAVAL		;TELL CFS TO RELEASE IT
	JRST HLTJB

LGOGOK:	SAVET
IFN STANSW,<
	STKVAR <LGOJOB>
	MOVEM T1,LGOJOB		;SAVE JOB NUMBER LOGGING OUT
	CAMN T1,JOBNO		;SAME AS MY JOB?
	 SETOM LGOJOB		;YES, SET UP AS PSEUDO SELF LOGOUT
>;IFN STANSW
	HRRZ T1,JOBDIR(T1)	;DIRECTORY
	JUMPE T1,R		;QUIT NOT LOGGED IN
	HRLI T1,USRLH
	CALL CNVDIR		;GET DIRECTORY NUMBER
	GTDAL			;GET ALLOCATION
	ERJMP R			;QUIT SOME ERROR
IFE STANSW,<
	UMOVE T1,T1		;GET ORIG ARGUMENT
>;IFE STANSW
IFN STANSW,<
	MOVE T1,LGOJOB		;GET LGOUT% JSYS FORM OF JOB NUMBER
>;IFN STANSW
	GTOKM (.GOLGO,<T2,T3,T1>,[RETBAD ()])	 ;ASK PERMISSION
	RET			;RETURN TO CALLER

IFN STANSW,<
; Welcome to ... message banner.  Hangs line up if dataset
; T2/	TERMINAL NUMBER TO GIVE BANNER TO
;	CALL BANNER

BANNER:	SAVET			;PROTECT TEMPS
	TRVAR <ADDPAR,BANDES>
	JUMPLE T2,R		;VALIDATE TTY # (CAN'T BE DET OR TTY0)
	CAML T2,CTYLNO		;IS THIS LINE BETWEEN 1 AND <CTY-1>?
	 RET			;NO - CTY, PTY, OR NVT
	SKIPL TTSTAT(T2)	;REMOTE?
	IFSKP.
	  MOVX T1,.CTTRM	;YES, FINISH OUTPUT ON CONTROLLING TERMINAL
	  DOBE%			;BEFORE DATASET HANGUP
	   ERJMP .+1		;PROTECT AGAINST ITRAP
	  CALL GTCJOB		;GET LINE'S CONTROLLING JOB
	   RET			;NOT ACTIVE?
	  CAIN T3,-1		;NO OWNING JOB?
	   SETZ T3,		;YES, SAY NOT LOGGED IN
	  IFE. T3		;LOGGED IN?
	    SKIPN HNGU0F	;NO, HANGUP IN THIS CASE?
	     RET		;NO
	  ELSE.
	    SKIPN HNGU1F	;YES, HANGUP IN THIS CASE?
	     RET		;NO
	  ENDIF.
	  CALLRET TTHNGU	;HANG UP DATASET, RETURN
	ENDIF.
	MOVEI T1,.TTDES(T2)	;GET COPY OF TERMINAL DESIGNATOR
	MOVEM T1,BANDES		;SAVE DESIGNATOR IN BANDES FOR DPYCTL
	SETZM ADDPAR		;ASSUME NO PARITY TO ADD
	GDSTS%			;GET DEVICE BITS
	IFNJE.
	  ANDX T2,GD%PAR	;ISOLATE PARITY ADD BIT
	  MOVEM T2,ADDPAR	;SAVE PARITY BIT
	ENDIF.
	GTTYP%			;GET TERMINAL TYPE
	 ERJMP R
	MOVEI T1,^D2000		;WAIT 2 SECONDS
	DISMS%
	SKIPN T4,TTYPE1(T2)	;GET ADDR OF FUNCTION TABLE
	 RET			;NOT A DISPLAY - NO BANNER THEN

; ON SOME TERMINALS WE ERASE DIFFERENTLY THAN FROM THE TABLES
.STPL==377			;SAME AS .STP IN STG

IFE SUMXSW,<
	CAIE T2,.TT100		;RESET VT100 TO POWER UP CONFIGURATION FIRST
	IFSKP.
	  MOVEI T3,V100RS	;YES, POINT TO TABLE OF RESET CODES.
	  DO.
	    SKIPN T1,(T3)	;GET A POINTER TO RESET STRING.
	    IFSKP.		;LIST IS EXHAUSTED.
	      CALL DPYCTL	;SET THIS RESET STRING TO TERMINAL.
	      MOVEI T1,^D100	;DISMISS TO LET THE VT100 CRUNCH
	      DISMS%
	      AOJA T3,TOP.	;POINT TO NEXT RESET CODE AND GO DO IT
	    ENDIF.
	  ENDDO.
	ENDIF.
	CAIE T2,.TTH19		;RESET HEATH TO POWER UP CONFIGURATION FIRST
	IFSKP.
	  MOVEI T1,[BYTE (8) 033,"z",.STPL]
	  CALL DPYCTL
	  MOVEI T1,^D750	;HEATHS NEED THE DELAY
	  DISMS%
	ENDIF.
>;IFE SUMXSW
	MOVEI T1,[BYTE (8) 032,.STPL] ;ADM3 SPECIAL CLEAR
	CAIN T2,.TTADM		;TREAT ADM3 SPECIALLY
	IFSKP.
	  MOVEI T1,[BYTE (8) 002,036,035,.STPL] ;DM SPECIAL CLEAR
	  CAIN T2,.TTDAM	;DM'S DON'T HAVE CLEOS
	ANSKP.
	  MOVE T1,.CURHM(T4)	;HOME CURSOR
	  CALL DPYCTL
	  MOVE T1,.CURES(T4)	;ERASE TO EOS
	ENDIF.
	CALL DPYCTL
	CALL UNPAGE		;CLEAR PAUSE ON END OF PAGE
	MOVE T1,BANDES
	HRRZ T2,TODCLK		;NOW PRINT SOME LINE FEEDS
	IDIVI T2,^D8
	ADDI T3,2		;RANDOM BETWEEN 2 AND 9
	MOVEI T2,.CHLFD
	DO.
	  BOUT%
	   ERJMP R
	  SOJG T3,TOP.
	ENDDO.

;DISPLAY SYSTEM NAME AND DOWNTIME PREDICTION

	MOVE T4,[POINT 7,SVN]	;DETERMINE LENGTH OF SYSTEM NAME STRING
	DO.
	  ILDB T2,T4
	  SKIPE T2
	   SOJA T3,TOP.		;T3 ACCUMULATES NEGATIVE OF STRING LENGTH
	ENDDO.
	ADDI T3,^D72		;WIDTH OF TERMINAL WE USE FOR MARGINS, ETC.
	IFG. T3			;PARANOIA CHECK IN CASE MOBY STRING
	  LSH T3,-1		;DIVIDE BY TWO TO GET PROPER INDENTATION
	  MOVEI T2," "		;SPACE OVER THAT MANY PLACES
	  DO.
	    BOUT%
	     ERJMP R
	    SOJG T3,TOP.
	  ENDDO.
	ENDIF.
	HRROI T2,SVN		;NAME OF SYSTEM
	SETZ T3,		;JUST IN CASE SYSTEM NAME TOO LARGE
	SOUT%
	 ERJMP R
	SKIPG HSYST1		;ANY DOWNTIME SET?
	IFSKP.
	  HRROI T2,[ASCIZ/

 The system will go down at /]
	  SOUT%
	   ERJMP R
	  MOVE T2,HSYST1
	  MOVX T3,<OT%DAY!OT%NSC!OT%12H>
	  ODTIM%
	   ERJMP R
	  SKIPN HSYST4
	  IFSKP.
	    HRROI T2,[ASCIZ/ until /]
	    SETZ T3,
	    SOUT%
	     ERJMP R
	    MOVE T2,HSYST4
	    MOVX T3,<OT%DAY!OT%NSC!OT%12H>
	    ODTIM%
	     ERJMP R
	  ENDIF.
	  SETZ T3,
	  SKIPN HSYST5		;ANY REASON SET?
	  IFSKP.
	    HRROI T2,[ASCIZ/
 for /]
	    SOUT%
	     ERJMP R
	    HRROI T2,HSYST5	;OUTPUT REASON
	    SOUT%
	     ERJMP R
	  ENDIF.
	ENDIF.

; TERMINATE WITH SOME LINEFEEDS, TO PUSH MESSAGE UP ON DUMB TERMINALS

	MOVE T1,BANDES		;GET LINE DESIGNATOR BACK
	HRROI T2,[ASCIZ/

            Welcome.  To get started, press the RETURN key.

/]
	SETZ T3,		;NULL-TERMINATED MESSAGE
	SOUT%
	 ERJMP R
	HRRZ T2,TODCLK		;PRINT SOME MORE LINE FEEDS
	IDIVI T2,10
	ADDI T3,2		;RANDOM BETWEEN 2 AND 9
	MOVEI T2,.CHLFD
	DO.
	  BOUT%
	   ERJMP R
	  SOJG T3,TOP.
	ENDDO.
	DOBE%
	 ERJMP R
	RET

;LOCAL ROUTINE TO SEND CONTROL SEQUENCES TO TERMINAL, SIMILAR TO COMND'S
;DPCTL.  PUTS TERMINAL IN BINARY MODE WHILE SENDING.
; A/ BYTE (8)C,C,..  OR  Z [BYTE (8)C,C,..]
;	CALL DPYCTL
; RETURN +1 ALWAYS, TERMINAL MODES PRESERVED

DPYCTL:	SAVET			;DON'T CLOBBER TEMPS
	STKVAR <WRD,PWRD,MD,<CCOC,2>>
	MOVEM T1,WRD		;SAVE WORD
	TXNE T1,.LHALF		;HAVE WORD OR POINTER?
	 MOVEI T1,WRD		;WORD, MAKE POINTER TO WORD
	HRLI T1,(<POINT 8,0>)	;CONSTRUCT POINTER TO STRING
	MOVEM T1,PWRD		;SAVE IT
	MOVE T1,BANDES		;GET OUTPUT DESIGNATOR
	RFCOC%			;GET CCOC WORDS
	 ERJMP R
	DMOVEM T2,CCOC		;SAVE FOR LATER REFERENCE
	DMOVE T2,[BYTE (2) 2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2
		  BYTE (2) 2,2,2,2,2,2,2,2,2,2,2,2,2,2]
	SFCOC%			;IMAGE ON ALL CHARACTERS
	 ERJMP R
	RFMOD%			;GET CURRENT TERM MODES
	 ERJMP R
	TXO T2,TT%IGN		;DON'T CHANGE WAKEUP BITS
	MOVEM T2,MD		;SAVE
	TXZ T2,TT%DAM		;SET TO BINARY
	SFMOD%
	 ERJMP R
	DO.
	  ILDB T2,PWRD		;GET BYTE
	  CAIN T2,.STPL		;STOP CODE?
	  IFSKP.
	    SKIPE ADDPAR	;ADDING PARITY TO THIS LINE?
	     CALL TTCMPP	;COMPUTE PARITY FOR THIS CHARACTER
	    BOUT%		;NO, SEND IT
	     ERJMP R
	    LOOP.
	  ENDIF.
	ENDDO.
	MOVE T2,MD		;RESTORE TERM MODES
	SFMOD%
	 ERJMP R
	DMOVE T2,CCOC		;SAVE FOR LATER REFERENCE
	SFCOC%
	 ERJMP R
	RET
>;IFN STANSW

;LOGSTR - ROUTINE TO DECREMENT MOUNT COUNT FOR ALL STRUCTURES THIS
;	  JOB HAS MOUNTED.
;
;CALL:		CALL LOGSTR
;RETURNS: +1 ALWAYS

LOGSTR:	SAVEP
	LOCK JSSTLK		;LOCK THE JSB STRUCTURE INFO DATA
	MOVSI P1,-STRN		;SET UP TO LOOP OVER STR INFO BLOCKS IN JSB
	MOVEI P2,JSSTRT		;GET ADDRESS OF FIRST BLOCK TO LOOK AT

LGST10:	JE <JSMCI,JSXCL>,(P2),LGST20 ;IF THIS JOB DIDN'T MOUNT THIS STR, CHECK NEXT
	LOAD T1,JSSTN,(P2)	;GET UNIQUE CODE FOR THIS STRUCTURE
	CALL CNVSTR		;GET STRUCTURE # AND LOCK THE STRUCTURE
	 JRST LGST20		;FAILED, MUST ALREADY BE DISMOUNTED, GO ON
	MOVEM T1,P3		;SAVE STRUCTURE NUMBER
	JN JSXCL,(P2),[	MOVX T1,D1%INI ;IF MOUNTED EXCLUSIVELY BY THIS JOB,
			ANDCAM T1,DEVCH1+DVXST0(P3) ; MAKE STR GENERALLY AVAILABLE
			JRST .+1]
	JE JSMCI,(P2),LGST15	;IF MOUNT COUNT NOT INCREMENTED, GO UNLOCK STR
	MOVE T1,P3		;GET STRUCTURE NUMBER AGAIN
	MOVE T2,P2		;GET ADDRESS OF STR INFO BLOCK IN JSB
	MOVE T3,JOBNO		;GET JOB NUMBER
	CALL DECMNT		;GO DECREMENT THE MOUNT COUNT FOR THIS STR
	 JFCL			;IGNORE FAILURE, GO ON
LGST15:	MOVE T1,P3		;RESTORE STRUCTURE NUMBER
	CALL ULKSTR		;UNLOCK THE STRUCTURE NOW
LGST20:	ADDI P2,JSSTMX		;GET ADDRESS OF NEXT STR INFO BLOCK IN JSB
	AOBJN P1,LGST10		;GO CHECK NEXT STR INFO BLOCK

	UNLOCK JSSTLK		;DONE, UNLOCK THE JSB STR INFO LOCK
	RET			;RETURN

;THE FOLLOWING IMPLEMENTS LOGOUT OF A JOB OTHER THAN SELF.
;LEGAL IF USER IS SC%WHL OR SC%OPR, OR IF OTHER JOB IS SAME USER

ELOGO:	MOVE T2,GBLJNO		;GIVEN JOB NUMBER TO LOGOUT
	CAIN T2,0(T1)		;SELF?
	RETERR(LOUTX1)		;YES, CAN'T SAY IT THAT WAY
	JUMPE T1,[RETERR (LOUTX5)] ;CANNOT LOGOUT JOB 0
	CALL GL2LCL		;CONVERT GLOBAL JOB NUMBER TO LOCAL INDEX
	 RETERR(LOUTX2)		;ILLEGAL JOB NUMBER
	MOVE P1,T1		; preserve target job index
	CALL LGOGOK		;GETOK CHECK
	NOSKED			; prevent races
	SKIPGE JOBRT(P1)	;EXISTS?
	RETERR(LOUTX2,OKSKED)	; no, fail
	MOVE T1,P1		; target job index
	CALL SETJSB		; map its JSB
	MOVE P2,T1		; preserve JSB address
	HRRZ T3,JOBDIR(P1)	;LOGIN DIRECTORY OF OBJECT JOB
	MOVE T1,JOBNO		; our job number
	XOR T3,JOBDIR(T1)	; our directory number
	TRNN T3,-1		;SAME AS THIS JOB?
	JRST ELOGO1		;YES, THAT'S OK
	HLRE T1,JOBPT(P1)	;GET TTY OF THE JOB BEING LOGGED OUT
	JUMPL T1,ELOGO3		;JUMP IF DETACHED
	CALL PTGETJ		;GET CONTROLLING JOB # IF TTY IS A PTY
	JUMPL T1,ELOGO3		;JUMP IF NOT A PTY JOB
	CAMN T1,JOBNO		;JOB BEING CONTROLLED BY JOB DOING THE LGOUT
	JRST ELOGO1		;YES, SO DO IT
ELOGO3:	HRRZ T3,JOBONT(P1)	;DO I OWN THAT JOB IN CRJOB SENSE?
	CAMN T3,GBLJNO		;JOBONT contains global job numbers
	JRST ELOGO1		;YES. OK TO LOG IT OUT.
	MOVEI T3,SC%WHL+SC%OPR	;OTHERWISE MUST BE SC%WHL
	TDNN T3,CAPENB
	JRST [	CALL CLRJSB		; unmap the JSB
		RETERR(LOUTX3,OKSKED)]	; quit
ELOGO1:	SETOM JOBONT(P1)	;MAKE IT UNOWNED SO IT CAN LOG OUT
	SETONE JSOLO,(P2)	;FLAG IN IT THAT SOMEONE LGOUT'ED IT
	MOVE T1,JOBNO		;AND WHO IT WAS
	MOVEM T1,JSLOJB(P2)	; ..
	CALL CLRJSB		;LET GO OF THE JSB
	MOVE T1,P1		; target job number
	CALL ELOGOO		;LOG OUT THE TARGET JOB
	OKSKED
	SMRETN			;AND DONE

;LOGGING FUNCTIONS

;TYPE LOGOUT MESSAGE, DESTINATION DESIGNATOR IN 1

LOGTOT::SKIPE 2,JSLOJB		;DID SOMEONE ELSE LOG OUT THIS JOB?
	CALL LOGTOK		;YES - INFORM THE VICTIM
	HRROI 2,[ASCIZ /Killed/]
	CALLRET LOGUSD		;Log job and time used info, setup time for USAGE
				; and return from LOGTOT

;SUBROUTINE TO TELL A VICTIM ABOUT WHO LOGGED OUT HIS JOB

LOGTOK:	PUSH	P,T2		;SAVE JOB NUMBER OF MURDERER
	HRROI	T2,[ASCIZ /Killed by /]
	PUSHJ	P,LOGMES
	MOVE	T2,(P)		;GET KILLER BACK
	HRRZ	T2,JOBDIR(T2)
	JUMPE	T2,LOGTK1	;SKIP THIS IF HE'S NOT LOGGED IN
	HRLI	T2,USRLH	;ELSE OUTPUT USER'S NAME
	MOVE	T3,T1		;SAVE OUTPUT DESIGNATOR
	DIRST
	 ERJMP [MOVE T1,T3	;IF ERROR, RESTORE OUTPUT DESIGNATOR
		JRST .+1]
LOGTK1:	POP	P,T2		;GET JOB NUMBER
	HLRZ	T2,JOBPT(T2)	;GET CONTROLLING TERMINAL OF THAT JOB
	JUMPL	T2,LOGTK2	;IF JOB IS DETACHED SKIP THIS
	PUSH	P,T2		;ELSE SAVE TERMINAL NUMBER
	HRROI	T2,[ASCIZ /, TTY /]
	PUSHJ	P,LOGMES
	POP	P,T2		;GET TERMINAL NUMBER AGAIN
	MOVEI	T3,^D8		;PRINT IT IN OCTAL
	PUSHJ	P,LGNOUT
LOGTK2:	CALLRET	LOGCR		;OUTPUT A CRLF AND RETURN

;Perform USAGE for logout

LOGTUS:	MOVEI T1,.USLGO		;LOGOUT FUNCTION
	MOVEI T2,LOGLST
	USAGE			;USAGE JSYS
	 ERJMP XUSAGE		;REPORT FAILURE
	RET			;Return from LOGTUS

;LOGON MESSAGE, CALLED FROM .LOGIN

LOGONM::
IFE STANSW&SUMXSW,<
	SKIPL 1,LOGDES
	DOBE			;WAIT FOR OTHER USE OF TTY TO FINISH
	HRROI 2,[ASCIZ /Login/]
	CALL LOGMES
	MOVE T2,CTRLTT		;T2/ LINE NUMBER
	CALL LOGJOB
	PUSH P,1
>;IFE STANSW&SUMXSW
	MOVEI T1,.USLGI		;LOGIN FUNCTION
	MOVEI T2,LOGLST		;POINT TO PARAMETERS
	USAGE
	 ERJMP [CALL XUSAGE	;REPORT USAGE FAILURE
		JRST .+1]
IFE STANSW&SUMXSW,<
	POP P,1
	CALLRET LOGCR		;AND CRLF
>;IFE STANSW&SUMXSW
IFN STANSW&SUMXSW,<
	MOVE T1,LOGDES		;INCASE ANYBODY EXPECTS IT
	RET
>;IFN STANSW&SUMXSW

XUSAGE:	BUG.(CHK,UXXFAI,MEXEC,HARD,<USAGE JSYS failure>,,<

Cause:	The monitor attempted to perform a USAGE% call to log either a
	login, logout, or session entry and it failed. There is no
	reasonable explanation for the failure of this JSYS call.
>)
	RET			;CONTINUE

;PARAMETER BLOCK FOR LOGIN/LOGOUT/SESSION CHANGE CALLS

LOGLST:	USENT. (.UTSEN,1,1)	;SESSION ENTRY TYPE
	USRTM. (JBRUNT)		;RUN-TIME
	USACT. (<-1,,ACCTSR>)	;ACCOUNT
	USSST. (CTIMON)		;SESSION START DATE/TIME
	USJTY. (-1)		;BATCH T/S FLAG
	USBJN. (JBBNAM)		;BATCH JOB NAME
	USBSN. (JBBSEQ)		;BATCH SEQ NUMBER
	USCOM. (<-1,,JSSRM+1>)	;SESSION REMARK
	USCCT. (CONCON)		;CONSOLE CONNECT TIME
	USPNM. (<SIXBIT "MONITR">,US%IMM)
	USPVR. ([EXP SVNM])	;MONITOR NAME AND VERSION
	USNM2. (<-1,,USRNAM+1>)	;USER NAME
;**;[7259]At LOGLST:+12L add 1 line   JYCW 7-Mar-86
	USBRI. (BATRID)		;[7259]Batch request ID
	0			;END OF LIST

;CHANGED ACCOUNT NUMBER MESSAGE

LOGCJM::
IFE STANSW&SUMXSW,<
	SKIPL 1,LOGDES
	DOBE
>;IFE STANSW&SUMXSW
IFN STANSW&SUMXSW,<
	MOVEI 1,.NULIO		;DON'T CLUTTER UP LOGTTY
>;IFN STANSW&SUMXSW
	HRROI 2,[ASCIZ /Changed/]
	CALL LOGUSD		;Log job and time used, setup for time for USAGE
	MOVE T2,JBRUNT		;Get session runtime
	ADDM T2,JSSRTM		;Update session runtime start for next session
	MOVE T2,CONCON		;Get session connect time
	ADDM T2,JSSCTM		;Update session console time start
	PUSH P,1		;SAVE OUTPUT DESIGNATOR
	MOVEI T1,.USSEN		;SESSION ENTRY CODE
	MOVEI T2,LOGLST		;PARAMS
	USAGE
	 ERJMP [CALL XUSAGE
		JRST .+1]
	POP P,1			;RESTORE
	RET			;Return from LOGCJM

;Print job info, time used, and setup times for USAGE

LOGUSD:	CALL LOGMES		;Print message type
	MOVE T2,CTRLTT		;Get controlling terminal number
	CALL LOGJOB		;Type job and terminal info
IFE STANSW,<
	HRROI T2,[ASCIZ /,  Used /]
>;IFE STANSW
IFN STANSW,<
	HRROI T2,[ASCIZ /
 Used /]
>;IFN STANSW
	CALL LOGMES		; . . .
	MOVE T2,JOBNO		;Get this job's number
	MOVE T2,JOBRT(T2)	;Get runtime of job
	MOVE T3,T2		;Copy it again
	SUB T3,JSSRTM		;Compute session runtime
	MOVEM T3,JBRUNT		;Save for USAGE
	CALL LOGTIM		;Print runtime

	HRROI T2,[ASCIZ / in /]
	CALL LOGMES		; . . .
	MOVE T2,TODCLK		;Get current uptime
	SUB T2,CONSTO		;Compute console time logged in
	MOVE T3,T2		;Copy console time
	SUB T3,JSSCTM		;Compute console time this session

	MOVEM T3,CONCON		;Save console time for USAGE
	CALL LOGTIM		;Print console time

	SKIPN JSSRTM		;Session start
	SKIPE JSSCTM		; at beginning of job?
	 SKIPA			;No-- print time this session
	JRST LOGUS2		;Yes-- don't repeat ourselves

	HRROI T2,[ASCIZ /,
  Used this session /]
	CALL LOGMES		; . . .
	MOVE T2,JBRUNT		;Get session time
	CALL LOGTIM		;Print it
	HRROI T2,[ASCIZ / in /]
	CALL LOGMES		; . . .
	MOVE T2,CONCON		;Get console time this session
	CALL LOGTIM		;Print it
LOGUS2:
	CALLRET LOGCR		;Finish with CRLF

;PRINT TIME FROM 2

LOGTIM:	JUMPL 1,R
	IDIVI 2,^D1000		;MS TO SECS
	IDIVI 2,^D60		;PEEL OFF SECONDS
	PUSH P,3
	IDIVI 2,^D60		;PEEL OFF MINUTES
	PUSH P,3
	CALL LOGNUM		;PRINT HOURS
	MOVEI 2,":"
	BOUT
	 ERJMP .+1		;NOTHING ELSE TO DO
	POP P,2
	CALL LOG2NM		;PRINT MINUTES
	MOVEI 2,":"
	BOUT
	 ERJMP .+1		;NOTHING ELSE TO DO
	POP P,2
	CALL LOG2NM		;PRINT SECONDS
	RET

;ATACH AND DETACH MESSAGES

;DETMSG - RECORD DETACHING OF JOB

;ACCEPTS:
;	T2/ LINE NUMBER

DETMSG:	
IFE STANSW&SUMXSW,<
	STKVAR <DETMLN>
	MOVEM T2,DETMLN		;SAVE LINE NUMBER
	HRROI 2,[ASCIZ /Detached/] ;WORD FOR LOG TTY
	SKIPL 1,LOGDES
	DOBE
	 ERJMP .+1
	CALL LOGMES
	MOVE T2,DETMLN		;T2/ LINE NUMBER
	CALL LOGJOB
				;*** DETACH ***
	CALLRET LOGCR		;CRLF AND RETURN
>;IFE STANSW&SUMXSW

DETMS0:
IFE STANSW&SUMXSW,<
	ASUBR <ATAJN,ATALN>	;JOB # , LINE #
	HRROI 2,[ASCIZ /Detached job /]
	SKIPL 1,LOGDES
	DOBE
	 ERJMP .+1
	CALL LOGMES
	MOVE 2,ATAJN		;GET REMOTE JOB NUMBER
	CALL LOGNUM
	HRROI 2,[ASCIZ / from TTY /]
	JRST ATAMS3
>;IFE STANSW&SUMXSW

ATAMSG:	
IFE STANSW&SUMXSW,<
	ASUBR <ATAJN,ATALN>	;JOB # , LINE #
	SKIPL 1,LOGDES
	DOBE
	 ERJMP .+1
	HRROI 2,[ASCIZ /Attached job /]
	CALL LOGMES
	MOVE T2,ATAJN		;GET JOB NUMBER
	CALL LOGNUM		;PRINT IT
	HRROI 2,[ASCIZ / to TTY /]
ATAMS3:	CALL LOGMES
	MOVE T2,ATALN		;LINE NUMBER
	MOVEI 3,^D8		;PRINT IN OCTAL
	CALL LGNOUT
	CALL LOGJ2		;PRINT AND STORE TOD
				;*** ATTACH ***
	CALLRET LOGCR		; END WITH CRLF
>;IFE STANSW&SUMXSW
IFN STANSW&SUMXSW,<
O	RET			;NO JUNK ON SUMEX'S LOGGING TTY
>;IFN STANSW&SUMXSW

;PRINTS  JOB 1, TTY 40, AT 12:34:56
;  OR    JOB 1, DETACHED, AT 12:34:56

;ACCEPTS:
;	T2/ LINE NUMBER

LOGJOB:	STKVAR <LOGJLN>
	MOVEM T2,LOGJLN		;T2/ LINE NUMBER
	HRROI 2,[ASCIZ / Job /]
	CALL LOGMES
	MOVE T2,GBLJNO		;Print global job number
	CALL LOGNUM
	MOVE 2,JOBNO		;Get Job index
	HRRZ 2,JOBDIR(2)
	JUMPE 2,LOGJ3		;LOGGED IN NOW?
	HRROI 2,[ASCIZ /, User /]
	CALL LOGMES
	MOVE 2,JOBNO
	HRRZ 2,JOBDIR(2)
	HRLI 2,USRLH		;TURN IT INTO A 36 BIT USER NUMBER
	MOVE 3,1		;SAVE OUTPUT DESIGNATOR
	CAIL 1,0
	DIRST			;DIRECTORY NAME
	 ERJMP [MOVE 1,3	;IF ERROR, RESTORE OUTPUT DESIGNATOR
		JRST .+1]	;AND CONTINUE
IFE STANSW,<		;NOT ALL SU SITES USE ACCOUNTING
	HRROI 2,[ASCIZ /, Account /]
	CALL LOGMES
	CALL LOGACC
>;IFE STANSW
LOGJ3:	MOVE 2,LOGJLN
	JUMPL 2,LOGJ1		;IF NO CTRL TTY (DETACHED JOB)
	HRROI 2,[ASCIZ /, TTY /]
	CALL LOGMES
	MOVE 2,LOGJLN
	MOVEI 3,^D8		;PRINT TTY NUMBER IN OCTAL
	CALL LGNOUT
LOGJ2:
IFE STANSW,<
	HRROI 2,[ASCIZ /,
  at /]
>;IFE STANSW
IFN STANSW,<
	HRROI 2,[ASCIZ/, at /]
>;IFN STANSW
	CALL LOGMES
	PUSH P,1		;SAVE DESIGNATOR
	CALL LGTAD		;DO LOCAL GTAD
	MOVE 2,1
	POP P,1			;RESTORE DESTINATION
	JUMPL 1,R
	SETZ 3,			;STANDARD DATE AND TIME
	CAIL 2,0
	ODTIM
	 ERJMP .+1
	RET

LOGJ1:	HRROI 2,[ASCIZ /, Detached/]
	CALL LOGMES
	JRST LOGJ2

LOGACC:	HRROI T2,ACCTSR		;POINT TO STRING
	MOVEI T3,0		;TERMINATE ON NULL
	CAIL T1,0		;VALID PNTR
	SOUT			;YES - OUTPUT STRING
	 ERJMP .+1
	RET			;RETURN

LOGMES:	SETZ 3,
	SOUT
	 ERJMP .+1
	RET

LOG2NM:	SKIPA 3,[EXP NO%LFL!NO%ZRO+^D2B17+^D10] ;Decimal, two digits
LOGNUM:	MOVEI 3,^D10		;DECIMAL FOR TIMES, ETC.
LGNOUT:	NOUT
	 ERJMP .+1
	RET

LOGCR:	HRROI 2,[ASCIZ /
/]
	SETZ 3,
	SOUT
	 ERJMP .+1
	RET

;PRINTS   [JOB N DETACHED BY NAME] TO TTY OF JOB BEING ATTACHED
; OR UNATTACHED.
;ACCEPTS:	1/JOB # OF JOB BEING UNATTACHED
;		2/LINE # OF JOB BEING UNATTACHED
;		3/DIR # OF USER UNATTACHING THE JOB
;		4/TTY # OF USER UNATTACHING THE JOB

DETMS1:	TRVAR <<MSGBUF,25>,JOB,LINE,DIRN,DTTYN,TMPPTR>
	MOVEM 1,JOB		;SAVE INPUTS
	MOVEM 2,LINE
	MOVEM 3,DIRN
	MOVEM 4,DTTYN		;SAVE TTY # OF DETACHER
	HRROI 1,MSGBUF		;START FILLING BUFFER
	CALL LOGCR		;CRLF
	HRROI 2,[ASCIZ/[Job /]
	CALL LOGMES
	HRRZ 2,JOB		;JOB # TO BE PRINTED
	CALL LOGNUM
	HRROI 2,[ASCIZ/ detached by /]
	CALL LOGMES
	MOVE 2,DIRN
	MOVEM 1,TMPPTR		;SAVE PLACE IN BUFFER IN CASE DIRST FAILS
	DIRST			;GET USER WHO'S UNATTACHING THE JOB
	ERJMP DIRFIX
DETMS2:	SKIPGE DTTYN		;IS DETACHER ON A TTY?
	JRST DETMS3		;NO
	HRROI 2,[ASCIZ/ on terminal /]
	CALL LOGMES
	MOVE 2,DTTYN		;Get the TTY number
	MOVEI 3,10		;OCTAL NUMBER
	CALL LGNOUT
DETMS3:	HRROI 2,[ASCIZ/]/]
	CALL LOGMES
	CALL LOGCR		;CLOSE WITH CRLF
	MOVEI 1,.TTDES		;MAKE A TTY DESIGNATOR
	ADD 1,LINE		;TTY LINE NUMBER
	HRROI 2,MSGBUF		;POINT TO NOW-COMPLETED MESSAGE
	TTMSG			;SEND IT OUT
	 ERJMP .+1
	RET

;UNATTACHER NOT LOGGED IN

DIRFIX:	MOVE 1,TMPPTR		;RESTORE BUFFER POINTER
	HRROI 2,[ASCIZ/user/]
	CALL LOGMES		;PLACE PSEUDO-NAME IN BUFFER
	JRST DETMS2		;FINISH ASSEMBLING THE MESSAGE

;INFO JSYS'S

.GJINF::MCENT
	CALL GTCSCD		;GET CONNECTED STRUCTURE CODE,,DIRECTORY
	MOVE T2,T1		;RETURN CONNECTED STR/DIR NUMBER
	MOVE T3,JOBNO
	HRRZ T1,JOBDIR(T3)
	SKIPE T1			;IF NOT LOGGED IN, RETURN 0
	HRLI T1,USRLH		;TURN THIS INTO A 36 BIT USER NUMBER
	MOVE T4,CTRLTT
	MOVE T3,GBLJNO		;RETURN GLOBAL JOB NUMBER FOR OURSELF
MR4:	UMOVEM T4,T4
MR3:	UMOVEM T3,T3
MR2:	UMOVEM T2,T2
MR1:	UMOVEM T1,T1
	JRST MRETN

.TIME::	MCENT
	MOVE 1,TODCLK		;TIME SINCE SYSTEM STARTED
	MOVEI 2,^D1000		;DIVISOR FOR SECONDS
	JRST MR2		;RETURN 2 AC'S

.RUNTM::MCENT
	NOSKED
	CALL UCLOCK		;UPDATE CLOCKS
	OKSKED
	CALL FLOCK		;LOCK THE FORK STRUCTURE
	XCTU [HRRZ 1,1]	;FORK HANDLE
	CAIN 1,-5		;WHOLE JOB?
	JRST RUNTM1		;YES
	CALL SETJFK
	CALL SETLF1
	MOVE 1,FKRT(1)		;FORK RUN TIME FROM PSB
	JRST RUNTM2

RUNTM1:	NOINT
	MOVE 1,JOBNO
	MOVE 1,JOBRT(1)
RUNTM2:	MOVE 3,TODCLK		;CURRENT TIME
	SUB 3,CONSTO		;LESS TIME ON, FOR CONSOLE TIME USED
	MOVEI 2,^D1000		;MILLISECONDS
RETA3:	UMOVEM 1,1		;RETURN VALUES IN 1,2,3
	UMOVEM 2,2
	UMOVEM 3,3
	JRST CLFRET

.GTRPI::MCENT
	CALL FLOCK		;LOCK THE FORK STRUCTURE
	CALL SETLFK
	MOVE 2,USWPCT(1)
	MOVE 3,PTTIM(1)
	IDIVI 3,^D100		;RETURN MILLISEC, NOT HPTIM UNITS
	MOVE 1,UTRPCT(1)
	JRST RETA3

;GET DIRECTORY ALLOCATION
;ACCEPTS IN 1/	DIR # OR -1 FOR CONNECTED DIR
;	GTDAL
;RETURNS +1:	1/	LOGGED IN QUOTA
;		2/	CURRENT ALLOCATION
;		3/	LOGGED OUT QUOTA

.GTDAL::MCENT
	UMOVE T1,1		;GET DIR #
	CAMN T1,[-1]		;-1 MEANS CONNECTED DIRECTORY
	CALL GTCSCD		;GET CONNECTED DIR NUMBER
	CALL IGTDAL		;USE INTERNAL ROUTINE
	 ITERR()		;FAILED
	JRST MR3		;RETURN 1, 2 AND 3

;INTERNAL GTDAL, 1/ DIRECTORY #

IGTDAL::STKVAR <IGTDN>
	MOVEM T1,IGTDN		;SAVE DIR #
	CALL SETDIR		;MAP THE DIRECTORY IN
	 RETBAD ()		;FAILED
	HRRZ T1,IGTDN		;DIRECTORY NUMBER
	LOAD T2,CURSTR		;STRUCTURE NUMBER
	CALL GETCAL
	 JRST [	MOVE T3,DIRORA	;DIR NOT OPENED
		LOAD T1,DRLIQ,(T3) ;LOGGED IN QUOTA
		LOAD T2,DRDCA,(T3) ;CURRENT ALLOCATION
		LOAD T3,DRLOQ,(T3) ;LOGGED OUT QUOTA
		JRST IGTDX]	;EXIT
	MOVE T3,DIRORA		;GET BASE ADR OF MAPPED DIR
	MOVN T2,T1		;NEGATE PAGES LEFT
	LOAD T1,DRLIQ,(T3)	;GET LOGGED IN QUOTA
	ADD T2,T1		;ACTUAL USED
	LOAD T3,DRLOQ,(T3)	;GET LOGGED OUT QUOTA
IGTDX:	CALL USTDIR		;UNLOCK THE DIR
	RETSKP			;GOOD RETURN

;HIGH PRECISION TIME JSYS
;MADE RESIDENT FOR SPEED

	RESCD

.HPTIM::MCENT
	CAIL 1,0		;CHECK RANGE OF ARG
	CAIL 1,NHPTIM
	RETERR(HPTX1)		;UNDEFINED CLOCK
	JRST HPTTAB(1)

HPTTAB:	JRST HPT0		;ELAPSED TIME
	JRST HPT1		;FORK RUNTIME
NHPTIM==.-HPTTAB

HPT0:	NOSKED
	JSP 4,MTIME		;READ TODCLK IN 1E-5 SECOND UNITS
	OKSKED
	UMOVEM 1,1
	SMRETN

HPT1:	NOSKED
	CALL UCLOCK		;UPDATE USER RUNTIMES
	OKSKED
	MOVE 1,FKRT		;GET MILLISECOND PART
	IMULI 1,NTMS		;CONVERT TO HP UNITS
	ADD 1,RUNT2		;INCLUDE FRACTION OF MILLISECOND
	UMOVEM 1,1
	SMRETN

	SWAPCD


;GET NUMBER OF TABLE AND FIRST WORD GIVEN SIXBIT SYMBOL
; 1/ SIXBIT 'TABLENAME'
;	SYSGT
; RETURN +1 ALWAYS,
;  1/ -LENGTH,,TABLENUMBER  OR 0

.SYSGT::MCENT
	MOVSI 4,-GTBSIZ
	CAMN 1,SYMTAB(4)
	JRST SYSGT1
	AOBJN 4,.-2
	XCTU [SETZM 2]		;NOT FOUND RETURN 0
	JRST MRETN

SYSGT1:	HLRZ 2,GTTSZ(4)		;SIZE
	MOVN 2,2		;NEGATE IT
	HRLI 4,0(2)		;COMBINE WITH TABLE NUMBER
	UMOVEM 4,2		;GIVE TO USER
	HRRZ T3,T4		;GET TABLE NUMBER
	SETZ T2,		;GET OFFSET ZERO
	XCT GTGET(T3)		;GO GET THE FIRST ENTRY
	UMOVEM 1,1		;GIVE FIRST WORD TO USER
	JRST MRETN

;GET TABLE ENTRY
; 1/ INDEX,,TABLENUMBER
;	GETAB
; RETURN +1: ERROR
; RETURN +2: 1/ DATA

.GETAB::MCENT
	MOVSI 2,(1B1)
	TDNN 2,CAPMSK		;GETAB CAPABILITY EXISTS?
	RETERR(GTABX3)		;NO
	HLRZ 2,1		;INDEX OR -1
	MOVEI 3,0(1)		;TABLE NUMBER
	CAIL 3,GTBSIZ		;LEGAL NUMBER?
	RETERR(GTABX1)		;NO
	HLRZ 1,GTTSZ(3)		;GET SIZE OF TABLE
	CAIN 2,-1		;INDEX OF -1?
	JRST RETN1		;YES, RETURN NEG OF TABLE SIZE
	CAIL 2,0(1)		;INDEX WITHIN BOUNDS?
	RETERR(GTABX2)
	XCT GTGET(T3)		;GET WORD
	UMOVEM 1,1		;RETURN IT TO USER
	SMRETN

RETN1:	XCTU [MOVNM 1,1]	;RETURN NEG OF LENGTH
	SMRETN

;Tables for GTTAB
;All  tables defined with following macro which takes name of another
;macro to call for each table. Table indices are defined  in  MONSYM,
;order  and  place  must be preserved if tables are added or deleted.
;Place may be held by call with no args.

;The argument to gtabs is a macro to be called for each  table.  five
;arguments  are  given, sixbit table name, location, length, routine,
;symbolic value for table number (from MONSYM).

; Note, job tables are accessed by Job index, which must be translated
; from the user-specified global job number by calling GL2LCL in CFSSRV.
; Therefore, the 'length' or maximum legal value for a user-specified
; global job number is the highest legal global job number, MXGLBS, and
; not the maximum local job index, NJOBS.


DEFINE GTABS (XXX)<
	XXX JOBTTY,JOBPT,MXGLBS,GTJOB
	XXX JOBRT,JOBRT,MXGLBS,GTJOB
	XXX TICKPS,[^D1000],1
IFE STANSW,<
	XXX			;;FORMERLY JOBDIR
>;IFE STANSW
IFN STANSW,<
	XXX JOBDIR,JOBDIR,MXGLBS,GTJOB
>;IFN STANSW
	XXX TTYJOB,0,NLINES,TTY2GL
	XXX NCPGS,TOTRC,1
	XXX DEVNAM,DEVNAM,NDEV
	XXX DEVCHR,DEVCHR,NDEV
	XXX DEVUNT,DEVUNT,NDEV,UNT2GL
	XXX DSKERR,DSKRCE,NDSKEW
	XXX DRMERR,DRMCFE,NDRMEW
	XXX SYSVER,SVN,NSVNT
	XXX SYSTAT,SKDTM0,NSTAT
	XXX QTIMES,QSUM,NQUEUE
	XXX JOBNAM,JOBNAM,MXGLBS,GTJOB
	XXX SNAMES,SNAMES,NNAMES
	XXX STIMES,STIMES,NNAMES
	XXX SPFLTS,SPFLTS,NNAMES
	XXX SSIZE,SSIZE,NNAMES
	XXX SNBLKS,SNBLKS,NNAMES
	XXX DBUGSW,DBUGSW,2
	XXX LOGDES,LOGDES,2
	XXX PTYPAR,0,1,GTBPTY
	XXX SYMTAB,SYMTAB,GTBSIZ
	XXX DWNTIM,HSYST1,NHSYST
	XXX JOBPNM,JOBPNM,MXGLBS,GTJOB
	XXX BLDTD,SYSTAD,1
	XXX				;;FORMERLY LSTDRN
	XXX APRID,APRSER,1
	XXX HQLAV,HQLAV,NRJAVS
	XXX LQLAV,LQLAV,NRJAVS
	XXX NETRDY,0,10,GNTRDY
	XXX 				;;FORMERLY IMPHRT
	XXX 				;;FORMERLY HSTSTS
	XXX 				;;FORMERLY HSTNAM
	XXX 				;;FORMERLY HOSTN
	XXX 				;;FORMERLY NETLSK
	XXX 				;;FORMERLY GNTFSK
	XXX 				;;FORMERLY NETAWD
	XXX 				;;FORMERLY NETBAL
	XXX 				;;FORMERLY NETSTS
	XXX 				;;FORMERLY NETBUF
	XXX 				;;FORMERLY NETBTC
	XXX 				;;FORMERLY IMPLT1
	XXX 				;;FORMERLY IMPLT2
	XXX 				;;FORMERLY IMPLT3
	XXX 				;;FORMERLY IMPLT4
	XXX LHOSTN,NOHOST,2		;;ARPA HOST NUMBER, NVT COUNTER
	XXX JBONT,JOBONT,MXGLBS,GTJOB	;;OWNING JOB
	XXX NSWPGS,NSWPGS,1		;;DEFAULT SWAPPING PAGES
	XXX SCOUNT,SCOUNT,NNAMES	;;COUNT OF SETSN'S S FOR SUBSYSTEM
	XXX MONVER,137,1		;;MONITOR VERSION NUMBER
;**;[7211] Add 1 line at (DEFINE SYMT)-5	CEG 18-Dec-85
	XXX CISTAT,CIPKSN,NCSTAT	;;[7211] CI STATISTICS
IFN STANSW&PUPSW,<
	XXX PUPPAR,PUPPAR,NPUPPR	;PUP PARAMETER TABLE
	XXX PUPROU,PUPROU,NPNETS	;HOST NUMBER AND ROUTING TABLE
	XXX PUPLSK,PUPLSK,NPUPUN	;LOCAL SOCKET NUMBERS,
	XXX PUPLNH,0,NPUPUN,GTBLNH	;LOCAL NET/HOST NUMBERS, BSP LINKAGE
	XXX PUPFPT,0,NPUPUN,GTBFPT	;FOREIGN PORTS
	XXX PUPSTS,PUPSTS,NPUPUN	;PUP STATUS WORD
	XXX PUPBUF,0,PUPBFZ*NPUPUN,GTBBUF	;STORAGE REGION FOR PUP DATA
	XXX PUPSTA,PUPSTA,NPUPST,,.PUTA ;STATISTCS
	XXX NVTPUP,0,NTTPNV,GTBNVT	;PUP NVT INFO (TTYPUP WORD)
	XXX PUPPSI,0,NPUPUN,GTBPSI	;PUP PSI AND PNV/JOB INFORMATION
	XXX PUPON,PUPON,1		;ETHERNET UP/DOWN FLAG
>;IFN STANSW&PUPSW
   >

;ASSEMBLE SYMBOL TABLE

DEFINE SYMT (NAM,LOC,SIZ,ROUT,VALUE)<
   IFB <NAM>,<0>		;;LEAVE 0 IF PLACE RESERVED
   IFNB <NAM>,<
      IFB <VALUE>,<		;;IF VALUE WAS NOT SPECIFIED
	..X==.'NAM		;;GET NAME FROM MONSYM
.'NAM::!SIXBIT /NAM/>		;;CHECK TABLE INDEX, ASSEMBLE SIXBIT
      IFNB <VALUE>,<		;;IF VALUE WAS SPECIFIED
	..X==VALUE		;;GET NAME FROM MONSYM
VALUE::!SIXBIT /NAM/>>>		;;CHECK TABLE INDEX, ASSEMBLE SIXBIT

SYMTAB::!PHASE 0			;;MAKE TAGS BE RELATIVE TO 0
	GTABS SYMT		;;ASSEMBLE SYMTAB, CHECK INDEX MNEMONICS
GTBSIZ::DEPHASE

;ASSEMBLE POINTERS AND SIZES

DEFINE LOCT (NAM,LOC,SIZ,ROUT,VALUE)<
   IFB <NAM>,<0>		;;LEAVE 0 IF PLACE RESERVED
   IFNB <NAM>,<
	EXP LOC>>		;;30-BIT ADDRESS HERE

GTTAB::	GTABS LOCT

DEFINE SIZT (NAM,LOC,SIZ,ROUT,VALUE)<
   IFB <NAM>,<0>		;;LEAVE 0 IF PLACE RESERVED
   IFNB <NAM>,<
	XWD SIZ,0>>

GTTSZ::	GTABS SIZT

;DEFINE PROCESSING ROUTINE

DEFINE ACTR (NAM,LOC,SIZ,ROUT,VALUE)<
   IFB <NAM>, <SETZM T1>	;;NULL TABLE GIVES NULL ANSWER
   IFNB <NAM>,< IFB <ROUT>, <CALL GTGETR> ;;DFAULT PROCESSOR
   IFNB <ROUT>, <CALL ROUT> 	;;DO SPECIFIED PROCESS
        >
   >

GTGET:	GTABS ACTR		;DEFINE PROCESSING TABLES

;GETAB Job table access routine, used to translate user-specified
;Global job number into local job table index before looking up
;requested data in GTGETR below
;	T2/	Global Job number

GTJOB:	MOVE T1,T2		;PUT JOB NUMBER WHERE IT'S EXPECTED
	CALL GL2LCL		;TRANSLATE IT
	IFNSK.			;If no skip, no such job
	 SETO T1,		;So return a -1, as documented
	 RET			;
	ENDIF.			;
	MOVE T2,T1		;PUT JOB INDEX WHERE IT'S EXPECTED
;Fall through...

;GENERAL GETTAB ROUTINE.
;	3/ TABLE NUMBER
;	2/ TABLE OFFSET
;RETURNS: +1 WITH T1/ ANSWER

GTGETR:	ADD T2,GTTAB(T3)	;GET TABLE BASE
	MOVE T1,0(T2)		;FETCH TABLE ENTRY
	RET			;AND DONE

;GET THE GLOBAL JOB NUMBER FOR JOB CONTROLLING TTY NUMBER GIVEN
;	RETURNS +1, ALWAYS, WITH
;	T2/ GLOBAL JOB NUMBER,,WAITING FORK
;		OR
;	T1/ -1		(NO CONTROLLING JOB)
;		OR
;	T1/ -2,,-1	(NOT INITIALIZED YET)
;
TTY2GL:	CALL GTBTTF		;CALL TTYSRV ROUTINE TO GET JOB INDEX
	SKIPGE T1		;NEGATIVE MEANS NOT THERE (YET)
	 RET			;SO JUST SAY SO
	MOVE T2,T1		;SAVE REQUESTED DATA
	HLRZ T1,T1		;GET JOB NUMBER FROM LH
	CALL LCL2GL		;CONVERT JOB INDEX TO GLOBAL JOB NUMBER
	 SETOM T1		;JOB HAS NO GLOBAL JOB NUMBER YET.
	MOVSI T1,(T1)		;PUT GLOBAL JOB # IN LH
	HRR T1,T2		;GET WAITING FORK INDEX BACK.
	RET			;AND THAT'S IT.

;GET THE GLOBAL JOB NUMBER OF THE OWNER OF A DEVICE AND RETURN IT ALONG
;WITH THE DEVICE'S UNIT NUMBER (FROM DEVUNT)
; RETURNS +1 ALWAYS WITH
;	T1/	GLOBAL JOB NUMBER (OR -1 OR -2),,DEVICE UNIT NUMBER
;
UNT2GL:	SKIPG T3,DEVUNT(T2)	;JOB NUMBER IN LH?
	IFSKP.			;IF YES, MUST TRANSLATE
	 HLRZ T1,T3		;GET THE LOCAL INDEX
	 CALL LCL2GL		;GET THE GLOBAL JOB NUMBER
	  SETO T1,		;SHOULDN'T HAPPEN, RETURN -1
	 HRL T3,T1		;CONSTRUCT NEW DEVUNT FOR USER
	ENDIF.
	MOVE T1,T3		;PUT IT WHERE USER EXPECTS IT
	RET			;DONE

IFN STANSW,<
; JSYS FOR EFFICIENT PEEKING AT MONITOR TABLES
; 1/ -TABLE LENGTH,,TABLE
;	HANDS%
; RETURN +1: ALWAYS
;
; TABLE: <GETAB TABLE INDEX>,,<PLACE TO STORE TABLE>
;ALL MONITOR TABLES TRANSFERRED COMPLETELY

.HANDS::MCENT
	SKIPL T4,T1		;CHECK POINTER VALIDITY, AND LEAVE IN T4
	 ITERR(ARGX17)		;NOT AN AOBJN POINTER, BARF
	MOVX T1,SC%GTB
	TDNN T1,CAPMSK		;GETAB CAPABILITY EXISTS?
	 ITERR(GTABX3)		;NO
HANDS1:	XCTU [HLRO T1,(T4)]	;-1,,TABLE NUMBER
	XCTU [HRRZ T2,(T4)]	;PLACE TO PUT IT
	PUSH P,T4		;SAVE AOBJN POINTER
	CALL GTBLT0		;CALL WORK ROUTINE TO TRANSFER WHOLE TABLE
	 ITERR ()		;IF LOST PASS ON ERROR AS TRAP
	POP P,T4
	AOBJN T4,HANDS1		;NEXT TABLE ENTRY
	MRETNG			;SUCCESS RETURN

REPEAT 0,<	;KEEP CODE AROUND IN CASE WE EVER WANT TO INSTALL GTBLT%
;BLT A PORTION OF A TABLE TO USER SPACE
;
;   T1/	START INDEX,,TABLE NUMBER
;   T2/	WORD COUNT,,USER DESTINATION ADDRESS
;	IF LH(T1) = -1 THEN IGNORE LH(T2) AND TRANSFER WHOLE TABLE.
;	GTBLT
; RETURNS:
;   +1:	FAILURE, ERROR CODE IN 1
;	   GTABX1 IF BAD TABLE NUMBER
;	   GTABX2 IF TOO MANY WORDS REQUESTED
;	   GTABX3 IF NOT PROPER CAPABILITY
;   +2:	SUCCESS
;

.GTBLT::MCENT			;SLOW JSYS ENTRY
	MOVX T3,SC%GTB		;DOES USER HAVE GETAB% CAPABILITY?
	TDNN T3,CAPMSK		; ...
	 RETERR(GTABX3)		;IF NOT PROPER CAPABILITY
	CALL GTBLT0		;CALL WORK ROUTINE
	 RETERR()		;FAIL, PASS ON ERROR
	SMRETN			;SUCCESS
>;REPEAT 0

;WORK ROUTINE FOR GTBLT AND HANDS.
;
;ENTER W/ T1 AND T2 SET AS FOR GTBLT, ABOVE
;RETURNS +1 ON FAILURE, +2 ON SUCCESS, AS ABOVE

;Q1 - OFFSET INTO TABLE
;Q2 - TABLE INDEX
;T4 - TABLE LENGTH

GTBLT0:	HLRE Q1,T1		;GET STARTING OFFSET INTO TABLE OR -1
	HRRZ Q2,T1		;GET TABLE NUMBER
	CAIGE Q2,GTBSIZ		;RANGE CHECK IT
	 SKIPN T4,GTTSZ(Q2)	;DOES TABLE EXIST?
 	  RETBAD(GTABX1)	;BOMB IF BAD TABLE NUMBER OR NON-EXISTENT TABLE
	HLRZS T4		;PUT TABLE LENGTH IN RH OF T4
	HRRZ T1,GTGET(Q2)	;GET ADDRESS OF ACCESS ROUTINE
	CAIE T1,GTGETR		;SPECIAL?
	 JRST GTBLT4		;YES, GO HANDLE IT
	JUMPL Q1,GTBLT3		;JUMP IF WHOLE TABLE WANTED
	HLRZ T1,T2		;GET WORD COUNT
	JUMPE T1,RSKP		;IF ZERO WORDS REQUESTED, RETURN NOW
	ADDI T1,(Q1)		;ADD COUNT AND OFFSET
	CAILE T1,(T4)		;RANGE CHECK AGAINST TABLE SIZE
	 RETBAD(GTABX2)		;BOMB IF COUNT + OFFSET .GT. TABLE SIZE
	SUBI T1,(Q1)		;T1/ WANT JUST WORD COUNT
	HRRZ T3,T2		;T3/ DESTINATION IN PREVIOUS SECTION
	MOVE T2,GTTAB(Q2)	;T2/ SOURCE ADDRESS
	HRLI T2,MSEC1		;SET MONITOR SECTION
	ADDI T2,(Q1)		;ADD OFFSET INTO TABLE
	CALL BLTMU1		;MONITOR TO USER, BE SMART ABOUT SECTIONS
	RETSKP			;SUCCESS RETURN

;TRANSFER WHOLE TABLE.

GTBLT3:	HLRZ T1,GTTSZ(Q2)	;T1/ WORD COUNT
	HRRZ T3,T2		;T3/ DESTINATION ADDRESS
	HRRZ T2,GTTAB(Q2)	;T2/ SOURCE ADDRESS
	HRLI T2,MSEC1		;SET MONITOR ADDRESS
	CALL BLTMU1		;MONITOR TO USER, BE SMART ABOUT SECTIONS
	RETSKP			;SUCCESS RETURN

;TRANSFER TABLE WITH A SPECIAL ACCESS ROUTINE.

GTBLT4:	JUMPGE Q1,GTBLT5	;IF NOT WHOLE TABLE...
	HLL T2,GTTSZ(Q2)	;THEN SET WORD COUNT TO TABLE SIZE
	SETZ Q1,		;AND SET TABLE OFFSET TO ZERO
GTBLT5:	HLRZ T1,T2		;GET WORD COUNT
	JUMPE T1,RSKP		;IF ZERO WORDS REQUESTED, RETURN
	ADDI T1,(Q1)		;ADD WORD COUNT AND OFFSET
	CAILE T1,(T4)		;MAKE SURE COUNT + OFFSET .LT. TABLE SIZE
	 RETBAD(GTABX2)		;BOMB
	SUBI T1,(Q1)		;SUBTRACT OFF OFFSET
	MOVNI T4,(T1)		;GET NEGATIVE WORD COUNT
	MOVSI T4,(T4)		;SWAP SIDES TO FORM AN AOBJN POINTER
	HRR T4,Q1		;T4 HAS -COUNT,,OFFSET
	HRRZ Q1,T2		;Q1 HAS USER ADDRESS
	XSFM T2			;GET FLAGS INCLUDING PCS
	ANDI T2,EXPCS		;GET JUST PREVIOUS CONTEXT SECTION
	CAIL Q1,20		;DOES USER ADDRESS START IN THE AC'S?
	HRLI Q1,(T2)		;NO, SET A SECTION NUMBER
GTBLT6:	MOVEI T3,(Q2)		;SET TABLE NUMBER FOR ACCESS ROUTINE
	MOVEI T2,(T4)		;SET OFFSET FOR ACCESS ROUTINE
	PUSH P,T4		;SAVE THIS AC
	XCT GTGET(T3)		;GET TABLE WORD
	UMOVEM T1,(Q1)		;SEND WORD TO USER
	ADDI Q1,1		;ADVANCE USER ADDRESS
	POP P,T4		;RESTORE T4
	AOBJN T4,GTBLT6		;ADVANCE INDEX INTO TABLE
	RETSKP			;SUCCESS RETURN

; JSYS TO DETERMINE IDLE TIME FOR A JOB
; 1/ FLAGS,,JOB NUMBER
;	IDLE%
; NO FLAGS SET:  MS SINCE ANY FORK IN THE JOB LAST RAN (CPU IDLE TIME)
; 1B17 SET:  MS SINCE TYPE IN TO JOB'S TTY LAST OCCURED (TYPEIN IDLE TIME)
;
; RETURN +1: ALWAYS, AC1/ NUMBER OF MS JOB HAS BEEN IDLE

	SEARCH TTYDEF		;GET TTIDLE DEFINITION

.IDLE::	MCENT			;ENTER MONITOR CONTEXT
	HLLZ T2,T1		;COPY FLAGS INTO T2
	HRRZS T1		;ISOLATE JOB NUMBER
	CALL GL2LCL		;TRANSLATE GLOBAL JOB NUMBER TO LOCAL INDEX
	 ITERR()		;BAD JOB NUMBER, OR NOT LOCAL
	SKIPGE JOBRT(T1)	;JOB EXISTS?
	 ITERR(ARGX08)		;NO
	JUMPN T2,IDLTYP		;JUMP IF WANT OTHER THAN CPU IDLE TIME
	MOVSI T2,-NFKS		;POINTER INTO FORK TABLE
	HRLOI T4,377777		;VERY BIG #
IDLE0:  LOAD T3,FKJO%,(T2)	;GET JOB NUMBER FOR THIS FORK
	CAIE T3,(T1)		;BELONG TO SPECIFIED USER?
	IFSKP.
	  MOVE T3,TODCLK	;YES, GET MS CLOCK
	  OPSTR <SUB T3,>,FKTIM,(T2)	;COMPUTE TIME SINCE THIS FORK RAN
	  CAMLE T4,T3		;FIND SMALLEST TIME
	   MOVE T4,T3
	ENDIF.
	AOBJN T2,IDLE0		;LOOP OVER ALL FORKS
	CAMN T4,[377777,,777777] ;DIDN'T FIND A FORK?
	 ITERR(ARGX08)		;YES, SAY DOESN'T EXIST
	UMOVEM T4,1		;RETURN VALUE TO USER
	MRETNG

;HERE TO GET LAST TYPEIN IDLE TIME

IDLTYP:	TXNN T2,ID%TTY		;WANT TTY IDLE?
	 ITERR(ARGX02)		;NO, BAD ARGUMENTS 
	HLRE T2,JOBPT(T1)	;GET JOB'S CONTROLLING TTY
	SKIPL T2		;IF NEGATIVE
	 CALL LCKTTY		;OR IF CAN'T LOCK TTY DYNAMIC DATA BLOCK
	  ITERR(TTYX01)		;THEN THE LINE IS INACTIVE
	MOVE T4,TODCLK		;GET NOW
	SUB T4,TTIDLE(T2)	;SUBTRACT TODCLK OF LAST TYPE IN
	CALL ULKTTY		;UNLOCK TTY
	UMOVEM T4,1		;RETURN TYPEIN IDLE TIME
	MRETNG			;GOOD RETURN TO CALLER
>;IFN STANSW

;SUBSYSTEM STATISTICS LOGIC
; 1/ SIXBIT NAME OF SYSTEM PROGRAM BEING RUN OR (PRIV)
; 2/ SIXBIT NAME OF PROGRAM
;	SETSN
; RETURN +1: ALWAYS, NAME SET IN STATISTICS TABLE

.SETSN::MCENT
	NOINT
	MOVE 3,JOBNO
	MOVEM 2,JOBPNM(3)	;SET JOB PROGRAM NAME
	AOSE SNMLCK		;LOCK TABLE
	CBLK1			;OR WAIT TILL LOCKABLE
	MOVM T3,SNMPT		;COUNT OF ENTRIES NOW
      DO.
	SOJL T3,ENDLP.		;SCAN BACKWARDS, JUMP IF DONE
	CAMN 1,@[EP. SNAMES(3)]	;DESIRED NAME?
	JRST SNM1		;YES
	JRST TOP.
      ENDDO.
	MOVM T3,SNMPT
	CAIL 3,NNAMES-1		;TABLE NOW FULL?
	SKIPA 1,[SIXBIT /.OTHER/] ;YES, USE CATCH-ALL NAME
	JRST [ SETZM @[EP. SCOUNT(3)] ;ZERO THE COUNT
	       SOS SNMPT	;UPDATE POINTER
	       JRST .+1]	;CONTINUE WITH FLOW
	MOVEM 1,@[EP. SNAMES(3)] ;ADD NAME TO TABLE
SNM1:	MOVE 2,JOBNO
	HRRM 3,JOBNAM(2)	;PUT INDEX IN JOB TABLE
	AOS @[EP. SCOUNT(3)]	;BUMP THE SETSN COUNT
	SETOM SNMLCK		;UNLOCK TABLE
	OKINT
	SMRETN

NR SNMPT,1			;NEG COUNT OF ENTRIES IN SNAMES
NR SNMLCK,1			;LOCK FOR SNAMES TABLE

;PROGRAM NAME LOGIC

;SET NAME
; 1/ SIXBIT NAME OF PROGRAM
;	SETNM
; RETURN +1: ALWAYS, NAME SET AS PROGRAM NAME FOR JOB

.SETNM::MCENT
	MOVE 3,JOBNO		;GET THIS JOB NUMBER
	MOVEM 1,JOBPNM(3)	;SET THE NAME
	JRST MRETN

;GET NAME
;	GETNM
; RETURN +1: ALWAYS, 1/ SIXBIT NAME OF PROGRAM

.GETNM::MCENT
	MOVE 1,JOBNO
	MOVE 1,JOBPNM(1)
	JRST MR1		;RETURN 1 AC

;GETNAM -- SUBROUTINE TO CONSTRUCT VERSION AND SYSTEM NAME FROM TEXT
; IN THE FILE SYSTEM:MONNAM.TXT, OR IF THE FILE DOES NOT EXIST,
; TO USE THE DEFAULT TEXT ASSEMBLED INTO THE MONITOR IN THE BLOCK
; LABLED TSVN.  THE FORMAT OF THE RESULTING  TEXT IS:

; V D.DD.DD <TEXT>

; WHERE THE FIRST SEVERAL CHARACTERS IDENTIFY THE MONITOR VERSION AND ALWAYS
; COME FROM THE PREASSEMBLED STRING; AND THE <TEXT> COMES EITHER FROM
; THE FILE OR FROM THE PREASSEMBLED STRING.  THE ENTIRE STRING MAY
; BE UP TO 132(10) CHARACTERS LONG, SO <TEXT> MAY BE 122(10),
; OR 172(8) CHARACTERS LONG.  <TEXT> IN THE FILE SHOULD BE TERMINATED BY
; EOL.


GETNAM:	STKVAR <A1>		;RESERVE SPACE FOR ONE TEMP
	MOVE T1,[POINT 7,SVN]	;BYTE POINTER TO DESTINATION
	MOVEM T1,A1		;SAVE UPDATED PTR. TO DEST. STRING
	MOVX T1,GJ%SHT!GJ%OLD	;FLAG FOR SHORT GTJFN CALL AND OLD FILE ONLY
	HRROI T2,[ASCIZ /SYSTEM:MONNAM.TXT/] ;IMPLICIT STRING PTR TO FILE NAME
	GTJFN			;IS THERE A FILE?
	 JRST GETNA1		;NO FILE - DOESN'T MATTER WHY
	MOVX T2,<OF%RD+FLD(7,OF%BSZ)> ;FILE EXISTS, SET UP OPENF CALL
	OPENF			; ..
	 JRST GETNA1		;UNSUCCESFUL FOR ANY REASON, USE
				; DEFAULT STRING
	MOVEI T3,<NSVNT-VTSVNT>*5-1	;MAX. # OF BYTES WE CAN MOVE
	MOVE T4,A1		;RECALL BYTE PTR TO BUFFER
GETNA2:	BIN			;GET NEXT CHARACTER FROM FILE
	CAIE T2,.CHCRT		;IS IT A CARRIAGE RETURN?
	CAIN T2,.CHLFD		;NO, IS IT A LINE FEED?
	JRST GETNA3		;A CR OR A LF WAS ENCOUNTERED
	JUMPE T2,GETNA3		;JUMP ALSO IF IT'S A NULL
	IDPB T2,T4		;IT'S A GOOD CHARACTER, PUT INTO BUFFER
	SOJG T3,GETNA2		;JUMP IF WE HAVN'T EXHAUSTED ALL BUT
				; ONE BYTE POSITION IN BUFFER.
;MANUAL MERGE OF 1B CHANGES
GETNA3:	CLOSF			;YES, CLOSE FILE, RELEASE JFN
	 JFCL			;IGNORE FAILURE
	MOVE T1,T4		;GET STRING POINTER AGAIN
	HRROI T2,VTSVN		;IMPLICIT STRING POINTER TO VERSION
	SETZ T3,		;STOP ON A NULL
	SOUT			;MOVE PREASSEMBLED VERSION TO BUFFER
	RET			;EXIT

GETNA1:	HRROI T1,SVN		;IMPLICIT BYTE POINTER OF DESTINATION
	HRROI T2,TSVN		;IMPLICIT BYTE POINTER TO PREASSEMBLED
				; MONITOR NAME
GETNA5:	SETZ T3,		;SPECIFY TERMINATION ON A NULL
	SOUT			;MOVE PREASSEMBLED STRING TO BUFFER
				; THE MOVE INCLUDED A TERMINATING NULL
	RET			; SO -- WE'RE DONE


;GET JOB INFORMATION
; 1/ JOB #, OR -1 FOR SELF, OR TTY # + 400000
; 2/ -N,,USER ADR
; 3/ FIRST ENTRY DESIRED
;	GETJI
; RETURN +1: FAILURE
; RETURN +2: SUCCESS, ENTRIES STORED IN USER ARRAY
;REQUIRES GETAB CAPABILITY IF JOB OTHER THAN SELF

.GETJI::MCENT
	UMOVE P2,3		;GET NUMBER OF FIRST ENTRY DESIRED
	HRL P2,P2		;DUPLICATE IN BOTH HAVLES
	JUMPL P2,[RETERR (GTJIX1)] ;INSURE NOT NEGATIVE
	ADD P2,[-NGTJIT,,0]	;SETUP AOBJN PTR TO FIRST ENTRY
	JUMPGE P2,[RETERR (GTJIX1)] ;ALREADY BEYOND END OF TABLE
	UMOVE P3,2		;GET USER 'S ADR POINTER
	CAMN T1,[-1]		;SELF?
	IFNSK.			;IF NO SKIP, -1 WAS SPECIFIED
	 MOVE T1,JOBNO		;SO GET OUR OWN INDEX
	 JRST GETJI5		;AND SKIP CAPABILITY CHECK
	ENDIF.			;
	MOVX T2,SC%GTB
	TDNN T2,CAPMSK		;HAS GETAB CAPABILITY?
	RETERR (GTABX3)		;NO
	TRZE T1,400000		;TTY DESIGNATOR?
	IFNSK.			;IF NO SKIP, TTY WAS SPECIFIED
	 CAIL T1,0		;YES, LEGAL LINE NUMBER	?
	 CAIL T1,NLINES
	  RETERR (GTJIX2)	;NO
	 MOVE T2,T1		;T2/ LINE NUMBER
	 CALL GTCJOB		;GET OWNING JOB NUMBER
  	 JRST GETJI6		;JUMP IF NOT ACTIVE
	 CAIN T3,-1		;IS THERE AN OWNING JOB?
	  JRST GETJI6		;NO.
	 MOVE T2,T3		;YES. PRESERVE JOB NUMBER
	 HLRZ T3,JOBPT(T2) 	;GET CONTROLLING TTY FOR JOB
	 CAME T3,T1		;SAME AS GIVEN TTY?
	  JRST GETJI1		;NO, TTY IS ASSIGNED NOT CONTROLLING
	 MOVE T1,T2		;SETUP JOB INDEX
	ELSE.			;OTHERWISE, USER SPECIFIED A JOB NUMBER
	 CALL GL2LCL		;SO CONVERT IT INTO A JOB INDEX
	  RETERR()		;CFSSRV WILL RETURN THE RIGHT STUFF
	ENDIF.			;FALL THROUGH

;No longer needed.  GL2LCL checks job number...

REPEAT 0,<
	CAIL 1,0		;LEGAL JOB NUMBER?
	CAIL 1,NJOBS
	RETERR (GTJIX3)		;NO
>	;END REPEAT 0

; T1/ Local index of job requested

GETJI5:	NOSKED			;DON'T ALLOW JOB TO LOG OUT
	SKIPGE JOBRT(T1)	;JOB EXISTS?
	RETERR (GTJIX4,<OKSKED>) ;NO. GIVE APPROPRIATE ERROR
	MOVEM 1,P1		;SAVE JOB NUMBER
	CALL SETJSB		;MAP IN JSB OF OBJECT JOB
	OKSKED			;OK TO ALLOW SCHEDULING. JOB CAN'T LOGOUT
				; SINCE ITS JSB IS MAPPED
	MOVEM T1,P4		;SAVE JSB OFFSET
GETJI2:	XCT GETJIT(P2)		;GET ITEM
	 UMOVEM 1,0(P3)		;GIVE IT TO USER (ROUTINES THAT SKIP HAVE ALREADY DONE THIS)
	AOBJP P3,GETJI3		;COUNT USER'S COUNT AND ADR
	AOBJN P2,GETJI2		;COUNT OUR COUNT AND ADR
GETJI3:	CALL CLRJSB		;UNMAP JSB OF OBJECT JOB
GETJIX:	UMOVEM P3,2		;UPDATE USERS PTR
	SMRETN

;GETJI...
;HERE IF TTY GIVEN AND NO CONTROLLING JOB
;GETJI6 - NO JOB OWNS THIS TERMINAL; GETJI1 - A JOB OWNS THIS TERMINAL
;BUT IT IS NOT THE JOB'S CONTROLLING TERMINAL

GETJI6:	SETOM T2		;INDICATE NO OWNING JOB
	SKIPA
GETJI1:	TLO 2,(1B1)		;SAY ASSIGNED
GETJI4:	XCTU [SKIPE 3]		;DOES USER WANT FIRST ENTRY?
	JRST GETJIX		;NO, NOTHING TO DO
	SKIPLE T1,T2		;SKIP IF IT'S NOT A JOB INDEX
	IFNSK.			;NO SKIP MEANS IT'S IS A JOB
	 HRRZ T1,T2		;Get Rh only (local job index)
	 CALL LCL2GL		;CONVERT INDEX TO GLOBAL JOB NUMBER
	  SETOB T1,T2		;NO GLOBAL JOB NUMBER YET
	 HLL T1,T2		;Get back the 'assigned' flag, if any
	ENDIF.			;THAT'S ALL
	UMOVEM T1,0(P3)		;YES, STORE IT
	AOBJN P3,.+1		;UPDATE HIS POINTER
	JRST GETJIX		;RETURN

;TABLE OF GETJI ITEMS - WORD IS EXECUTED TO GET ITEM IN AC1

GETJIT:	MOVE T1,GBLJNO(P4)	;User's Global Job Number
	HLRE 1,JOBPT(P1)	;TTY NUMBER OR -1 IF DETACHED
	CALL GETSN5		;GET LOGIN DIRECTORY NUMBER
	CALL GETSN4		;GET CONNECTED STRUCTURE,,DIRECTORY
	CALL GETSN1		;SUBSYSTEM NAME
	MOVE 1,JOBPNM(P1)	;PROGRAM NAME
	MOVE 1,JOBRT(P1)	;RUN TIME
	CALL GETSN3		;JOB NUMBER OF OWNER OF PTY IF ANY
	CALL GETRTL		;GET RUNTIME LIMIT OF JOB
	CALL GETBB		;GET BATCH BIT
	CALL GETJID		;GET DENSITY
	LOAD T1,JSMTP,(P4)	;GET MAGTAPE PARITY DEFAULT
	CALL GETJIM		;GET MAGTAPE DATA MODE
	CALL GETJRS		;GET MAGTAPE RECORD SIZE
	LOAD T1,JSDFS,(P4)	;GET DEFERRED SPOOLING BIT
	CALL GETSN6		;GET THE LOGGED IN DIRECTORY NUMBER
	CALL GETJSR		;GET SESSION REMARK
	MOVE T1,LSTLGN(P4)	;PICK UP LAST LOGIN D&T
	MOVE T1,JSSRTM(P4)	;(.JISRT) Get session start runtime
	MOVE T1,JSSCTM(P4)	;(.JISCT) Get SESsion start console time
	CALL GETT20		;GET TOPS20 COMMAND LEVEL FLAG
	MOVE T1,SRTTIM(P4)	;GET TIME JOB WAS INITIALIZED
	MOVE T1,BATSTF(P4)	;GET BATCH STREAM AND FLAGS WORD
	CALL GETLL		;GET LOGICAL LOCATION
	MOVE T1,P1		;GET LOCAL JOB INDEX
;**;[7259]At GETJIT:+25L add 3 lines JYCW  7-Mar-86
	MOVE T1,JBBSEQ(P4)	;[7259]Get Batch Sequence number
	MOVE T1,JBBNAM(P4)	;[7259]Get Batch Job name
	MOVE T1,BATRID(P4)	;[7259]Get Batch request ID
NGTJIT==.-GETJIT

;ACTION ROUTINES FOR ITEMS NOT AVAILABLE IN SINGLE MOVE

;GET CONNECTED STRUCTURE,,DIRECTORY

;GET CONNECTED STRUCTURE,,DIRECTORY

GETSN4:	MOVE T1,P4		;T1/OFFSET FOR ADDRESSING JSB
	CALL GTOJCD		;GET CONNECTED STRUCTURE CODE,,DIRECTORY
	RET

;GET LOGGED DIR NUMBER

GETSN5:	HRRZ T1,JOBDIR(P1)	;GET DIR NUMBER
	SKIPE T1		;IF NOT LOGGED IN, RETURN 0
	HRLI T1,USRLH		;MAKE IT BE A 36 BIT USER NUMBER
	RET

;GET -1 OR 0 FOR TOPS20 COMMAND LEVEL OR USER LEVEL

GETT20:	LOAD T1,JBT20,(P4)	;GET TOPS20 BIT
	MOVN T1,T1		;BIT ON => -1 (AT TOPS20 COMMAND LEVEL), BIT OFF => 0 (NOT AT T20)
	RET

;GET THE LOGGED IN DIRECTORY NUMBER

GETSN6:
IFN STANSW,<
	SKIPGE T1,LOGINS	;GET LOGIN STRUCTURE
>;IFN STANSW			; IF IT FAILS, USE PS
	MOVEI T1,PSNUM		;DIR IS ON PUBLIC STR
	CALL STRCNV		;CONVERT IT
	 RETERR (,<CALL CLRJSB>)
	HRLZS T1		;GET UNIQUE CODE IN THE LEFT HALF
	HRR T1,JOBDIR(P1)	;GET THE DIRECTORY NUMBER
	RET			;AND RETURN

;GET SUBSYSTEM NAME

GETSN1:	HRRZ 1,JOBNAM(P1)	;GET STATISTICS INDEX
	MOVE 1,@[EP. SNAMES(1)]	;GET NAME
	RET

;GET JOB NUMBER OF OWNER OF PTY

GETSN3:	HLRE 1,JOBPT(P1)	;GET CONTROLLING TTY
	JUMPL 1,RETO		;RETURN -1 IF DETACHED
	CALL PTYGFK		;GET FORK WHICH OWNS PTY
	 JRST RETO		;NO PTY, RETURN -1
	MOVEM 1,FX
	LOAD 1,FKJBN		;GET JOB NUMBER WHICH OWNS FORK
	CALL LCL2GL		;Convert local Job index into Global Job number
	 RETERR (,<CALL CLRJSB>)	;No such job/invalid job index
	RET


;GET BATCH BIT

GETBB:	HLRE T1,JOBPT(P1)	;GET CONTROLING TTY
	JUMPL T1,RETZ		;IF NONE, JOB NOT CONTROLLED BY BATCH
	CALL PTYGBB		;GET BATCH BIT
	 JRST RETZ		;NOT A PTY
	RET			;ANSWER IS IN T1


;GET MAGTAPE DENSITY

GETJID:	LOAD T1,JSMTD,(P4)	;GET DEFAULT DENSITY
	SKIPN T1		;USING SYSTEM DEFAULT?
	MOVEI T1,MTDFDN		;YES
	RET


;GET MAGTAPE DATA MODE

GETJIM:	LOAD T1,JSMTM,(P4)	;GET DEFAULT DATA MODE
	SKIPN T1		;USING SYSTEM DEFAULT
	MOVEI T1,MTDFDM		;YES
	RET


;GET MAGTAPE RECORD SIZE

GETJRS:	LOAD T1,JSMTR,(P4)	;GET RECORD SIZE
	SKIPN T1		;USING SYSTEM DEFAULT?
	MOVEI T1,MTDFRS		;YES
	RET

;GET RUNTIME LIMIT FOR THIS JOB

GETRTL:	LOAD T1,JOBRTP,(P1)	;GET POINTER TO RUNTIME LIMIT BLK
	JUMPE T1,R		;WAS NONE
	LOAD T1,TIMTIM,(T1)	;GET ACTUAL LIMIT
	RET

;GET SESSION REMARK

GETJSR:	MOVEI T2,JSSRM(P4)	;ADDRESS OF REMARK IN JSB
GU1:	UMOVE T1,0(P3)		;PLACE WHERE USER WANTS REMARK PUT
	HRRZ T3,P3		;GET USER ADDRESS FOR UPDATED POINTER
	CALL CPYTU1		;COPY REMARK TO USER SPACE
	RETSKP			;SKIP SO POINTER DOESN'T GET UPDATED TWICE!

;GET LOGICAL LOCATION

GETLL:	MOVEI B,LLSR-1(P4)	;ADDRESS OF LOCATION STRING (MINUS ONE FOR CPYTU1)
	CALLRET GU1		;USE STANDARD MAGIC FOR FINISHING UP

;CONVERT ASCIZ PTR TO SIXBIT WORD
; 1/ BYTE PTR TO ASCIZ STRING
;	CALL ASZSIX
; RETURN +1: FAILURE, ILLEGAL CHARACTER
; RETURN +2: 1/ WORD OF SIXBIT
;  ASCIZ STRING LONGER THAN 6 CHARACTERS IS TRUNCATED

ASZSIX::STKVAR <WSIX>		;DECLARE LOCAL VAR FOR SIXBIT WORD
	SETZM WSIX		;CLEAR SIXBIT WORD
	MOVE 3,[POINT 6,WSIX]
	MOVEI 4,6		;6 CHARS MAX
SNM3:	XCTBU [ILDB 2,1]	;GET CHAR FROM USER
	JUMPE 2,SNM4		;END OF STRING IF NULL
	CAIL 2,40		;LEGAL CHARACTER?
	CAIL 2,140
	RET			;NO, DO +1 RETURN
	SUBI 2,40		;CONVERT TO SIXBIT
	IDPB 2,3		;BUILD SIXBIT
	SOJG 4,SNM3		;COUNT CHARS
SNM4:	MOVE 1,WSIX		;GET SIXBIT
	RETSKP

;LIGHTS, SWITCHES, AND OTHER MAINTENANCE STUFF

.SWTCH:: MCENT
	MOVE 2,CAPENB
	TXNN 2,SC%WHL+SC%OPR+SC%MNT ;SUFFICIENT CAPABILITIES?
	JRST CAPXR		;NO
	SETZ T1,		;INIT ANSWER
	UMOVEM 1,1
	SMRETN

.LITES::MCENT
	MOVE 2,CAPENB
	TRNN 2,SC%WHL+SC%OPR+SC%MNT ;REQUIRES STATUS
	JRST CAPXR
	SMRETN

.USRIO::MCENT
	MOVEI 1,SC%WHL+SC%OPR+SC%MNT
	TDNN 1,CAPENB		;REQUIRES STATUS
CAPXR:	RETERR(CAPX2)		;RETURN BAD, USER LACKS CAPABILITIES
	MOVSI 1,(1B6)		;USER IO BIT
	IORM 1,0(P)		;PUT IT ON
	SMRETN

;PEEK - AC1:  N,,MONLOC
;       AC2:     USRLOC

.PEEK::	MCENT
	MOVEI 3,SC%WHL+SC%OPR+SC%MNT
	TDNN 3,CAPENB		;HAS NECESSARY CAPS?
	RETERR(CAPX2)		;NO
	MOVSI 5,0(1)		;SETUP BLT ARGS - FROM
	HRRI 5,0(2)		; .. TO
	MOVEI 6,0(2)
	HLRZ 3,1		;COUNT
	HRRZ T4,T1		; FIND MONITOR LIMIT
	ADD T4,T3
	ADDI 6,-1(3)		; .. TO LIMIT

;CHECK ALL PAGES OF SOURCE BLOCK FOR PROPER ACCESS

	MOVEI 1,0(1)		;GET MONITOR ADDRESS
PEEK1:	PUSH P,1
	MRPAC			;GET ACCESS OF MONITOR PAGE
	TLNN T1,-1		;LEGAL RANGE? ** TO BE CHANGED FOR XADR **
	TLNN 2,(PA%RD)		;READABLE?
	RETERR(PEEKX2)		;NO
	POP P,1
	IORI 1,777		;BUMP ADDRESS TO NEXT PAGE
	ADDI 1,1
	CAMGE 1,T4		;CHECKED ALL PAGES?
	JRST PEEK1		;NO, GO CHECK NEXT ONE
	UMOVE T3,T2		;GET TO ADDRESS FROM USER
	UMOVE T2,T1		;GET FROM ADDRESS AGAIN
	HLRZ T1,T2		;FIND SIZE
	HRLI T2,MSEC1		;SECTION 1 IN MONITOR
	CALL BLTMU1		;TRANSFER FROM MONITOR TO USER
	SMRETN

;ERROR - SC%WHL OR SC%OPR REQUIRED BUT NOT ENABLED

WHEELX:	ITERR(WHELX1)

	SUBTTL	XPEEK% JSYS
;
; XPEEK% JSYS
;
;	AC1:	ADDRESS OF ARGUMENT BLOCK
;
.XPEEK::MCENT			;ENTER MONITOR CONTEXT
	UMOVE T2,1		;GET ADDRESS OF ARGUMENT BLOCK FROM USER
	UMOVE T1,.XPFNC(T2)	;GET FUNCTION CODE FROM USER
	CAILE T1,0		;FUNCTION CODE WITHIN
	CAIL T1,XPTLEN		; VALID RANGE ?
	ITERR (ARGX02)		;NO, RETURN "INVALID FUNCTION" ERROR
	MOVE T4,XPKTAB(T1)	;GET ADDRESS OF FUNCTION ROUTINE
	CALL (T4)		;DISPATCH TO ROUTINE
	 ITERR ()		;FAILED. RETURN ERROR CODE
	MRETNG			;SUCCESS. DONE

;
; DISPATCH TABLE FOR XPEEK FUNCTIONS
;
XPKTAB:	0			;NOT USED
	EXP XPPEK		;EXTENDED PEEK FUNCTION

XPTLEN==.-XPKTAB


;
; XPPEEK FUNCTION.
;
; ARGUMENT BLOCK:
;
;	WORD	DESCRIPTION
;
;	 0	LENGTH OF ARGUMENT BLOCK
;	 1	FUNCTION CODE - .XPPEK
;	 2	NUMBER OF WORDS TO TRANSFER
;	 3	NUMBER OF WORDS TRANSFERRED
;	 4	ADDRESS OF FIRST LOCATION IN MONITOR
;	 5	ADDRESS IN USER SPACE TO TRANSFER TO
;
XPPEK:	STKVAR <COUNT,MONLOC>
	MOVE Q1,T2		;SAVE ADDRESS OF USER BLOCK
	MOVEI T4,SC%WHL+SC%OPR+SC%MNT
	TDNN T4,CAPENB		;HAS NECESSARY CAPS?
	ITERR(CAPX2)		;NO
	UMOVE T1,.XPABL(Q1)	;GET LENGTH OF ARGUMENT BLOCK
	CAIGE T1,.XPLEN		;LONG ENOUGH?
	ITERR (ARGX04)		;NO. COMPLAIN
	UMOVE T1,.XPCN1(Q1)	;GET WORD COUNT FROM USER
	HRRZM T1,COUNT
	UMOVE T1,.XPMAD(Q1)	;GET MONITOR ADDRESS FROM USER
	HLRZ T2,T1		;GET MONITOR SECTION
	SKIPN T2		;SECTION GIVEN?
	HRLI T1,MSEC1		;NO. USE SECTION 1 IN MONITOR
	MOVEM T1,MONLOC		;SAVE THE MONITOR LOCATION
	MOVE T4,T1
	ADD T4,COUNT		;FIND MONITOR LIMIT

;CHECK ALL PAGES OF SOURCE BLOCK FOR PROPER ACCESS

XPEEK1:	PUSH P,T1		;SAVE MONITOR ADDRESS
	MRPAC			;GET ACCESS OF MONITOR PAGE
	TLNN T2,(PA%RD)		;READABLE?
	RETERR(PEEKX2)		;NO
	POP P,T1		;RESTORE ADDRESS
	IORI T1,777		;BUMP ADDRESS TO NEXT PAGE
	ADDI T1,1
	CAMGE T1,T4		;CHECKED ALL PAGES?
	JRST XPEEK1		;NO, GO CHECK NEXT ONE
	UMOVE T3,.XPUAD(Q1)	;GET USER ADDRESS FROM USER
	MOVE T2,MONLOC		;GET MONITOR ADDRESS AGAIN
	MOVE T1,COUNT		;GET COUNT FROM USER
	CALL BLTMU1		;TRANSFER FROM MONITOR TO USER
	SUB T2,MONLOC		;GET NUMBER OF WORDS TRANSFERRED
	UMOVEM T2,.XPCN2(Q1)	;RETURN COUNTS
	RETSKP			;DONE. SUCCESS


;DETACH FROM CONTROLLING TTY

.DTACH::MCENT
	SKIPGE T1,CTRLTT	;GET CONTROLLING TERMINAL
	MRETNG			;NONE, ASSUME OK
	CALL PTYGBB		;ARE WE CONTROLLED BY BATCH?
	IFSKP.
	ANDL. T1
	  MOVX T1,SC%WHL!SC%OPR ;IF CONTROLLED BY BATCH,
	  TDNN T1,CAPENB	;MUST HAVE WHEEL OR OPR
	  ITERR (CAPX1)	;NOT ENOUGH PRIVILEGES
	ENDIF.
IFN STANSW,<
	SKIPLE T2,CTRLTT	;GET CONTROLLING TERMINAL
	 CALL BANNER		;WELCOME TO ...
>;IFN STANSW
	MOVX T1,.CTTRM		;FINISH OUTPUT ON CONTROLLING TERMINAL
	DOBE			; BECAUSE TTYDAS WILL RELEASE BUFFERS
	 ERJMP	.+1		;IGNORE ERRORS
	MOVE P1,CTRLTT		;SAVE LINE NUMBER
IFN STANSW&PUPSW,<	
	CALL PNVDET		;IF PUP NVT, FLAG NO CARRIER-OFF PSI WANTED
>;IFN STANSW&PUPSW
	CALL LDTACH		;DO THE WORK
	MOVE T1,JOBNO
	HRRE T1,JOBDIR(T1)
	IFN. T1			;IF LOGGED IN,
	  MOVE T2,P1		;T2/ LINE NUMBER
	  CALL DETMSG		;YES. NOTE EVENT ON LOGGING TERMINAL
	ENDIF.
	MRETNG			;AND ALL DONE

;DTACH CALLED INTERNALLY

LDTACH:	STKVAR <LDTALN,TSTRTN>	;Detach Line Number, Test Routine Address
LDTAC2:	SKIPGE T2,CTRLTT	;DOES JOB HAVE A CONTROLLING TERMINAL?
	RET			;NO. DON'T DO ANYTHING
IFN STANSW,<
	MOVEM T2,LDTALN		;SAVE LINE NUMBER
>;IFN STANSW
	HRLOI T1,(TL%CRO+TL%COR+TL%SAB+TL%ABS)
	CAMN T2,CTYLNO		;Detaching CTY?
	TXZ T1,TL%ABS		;Always leave CTY refusing links
	MOVEI T2,-1
	TLINK			;BREAK LINKS
	 JFCL
	CALL LCKDVL		;LOCK DEVICE LOCK, NO NOINT
	SKIPGE T2,CTRLTT	;GET CONTROLLING TTY
	IFNSK.			;ITS GONE NOW
	 UNLOKK DEVLKK		;NOT THERE, RELEASE DEVLKK
	 MOVEM T1,TSTRTN	;SAVE TEST ROUTINE ADDR
	 MOVE T2,LDTALN		;MIGHT BE DYNAMIC DATA LOCKED BY SOME JSYS
	 MOVEI T3,"C"-100	;SO GIVE JOB A ^C AND HOPE
	 CALL TTPSRQ		;WONT HELP IF TRAPPING ^C
	 MOVE T1,TSTRTN		;PUT ADDRESS BACK
	 OKINT			;GO OKINT AND
	 RET 			;RETURN
	ENDIF.			;HERE WHEN CTRLTT IS STILL THERE
IFE STANSW,<
	MOVEM T2,LDTALN		;SAVE LINE NUMBER
>;IFE STANSW
	CALL STADYN		;POINT TO DYNAMIC DATA
	 JRST LDTAC3		;NOT ACTIVE. SHOULDN'T HAPPEN
	CALL TTFWAK		;WAKE UP PROCESS IN INPUT WAIT ON THIS LINE
	MOVE T2,LDTALN		;T2/ LINE NUMBER
	CALL TTYDAS		;DEASSIGN DYNAMIC DATA
	 JRST [	UNLOKK DEVLKK	;FAILED - UNLOCK DEVICE LOCK
		OKINT		;LCKDVL WENT NOINT
		TXZN T1,1B0	;ERROR OR WAIT?
		RET		;ERROR. CURRENTLY NO WAY TO HANDLE THIS
		HRL T1,LDTALN	;T1/(LINE NUMBER,,ADDRESS OF TEST ROUTINE)
		MDISMS		;WAIT UNTIL DEALLOCATION IS POSSIBLE
		JRST LDTAC2]	;TRY AGAIN
LDTAC3:	SETOM CTRLTT		;INDICATE JOB DOESN'T HAVE CONTROLLING TERMINAL
	MOVE T1,JOBNO
	HRROS JOBPT(T1)
	UNLOKK DEVLKK		;UNLOCK DEVICE LOCK
	OKINT
	RET

;LDET2 - DETACH JOB FROM TERMINAL WITHOUT DEALLOCATING TERMINAL DATA

;RETURNS +1: ALWAYS

;PRESERVES T2

LDET2:	STKVAR<LDETSV>
	HRLOI T1,(TL%CRO+TL%COR+TL%SAB+TL%ABS)
	MOVE T2,CTRLTT		;GET CONTROLLING TERMINAL
	CAMN T2,CTYLNO		;Check for CTY
	TXZ T1,TL%ABS		;CTY should default to refuse links
	MOVEI T2,-1
	TLINK			;BREAK LINKS
	 JFCL
	CALL UNPAGE		;CLEAR PAGING
	MOVE 2,CTRLTT		;T2/ CONTROLLING TERMINAL NUMBER
	MOVEM T2,LDETSV		;SAVE IT
	MOVE 1,JOBNO
	HRRE T1,JOBDIR(T1)	;GET LOGGED IN DIRECTORY
	CAIE T1,0		;LOGGED IN?
	CALL DETMSG		;YES, DO MESSAGE AND EFACT
	SETOM CTRLTT		;INDICATE NO CONTROLLING TERMINAL
	MOVE T1,JOBNO		;GET JOB NUMBER
	HRROS JOBPT(T1)		;INDICATE NO CONTROLLING TERMINAL
	MOVE T2,LDETSV		;T2/ LINE NUMBER
	CALL LCKTTY		;POINT TO DYNAMIC DATA
	 SKIPA			;NOT ACTIVE
	CALL TTFWAK		;WAKE FORK IN INPUT WAIT ON THIS LINE
	CALL ULKTTY		;ALLOW DEALLOCATION
	MOVE T2,LDETSV		;RESTORE LINE NUMBER
	RET

;ROUTINE TO TURN OFF PAGE MODE FOR CONTROLLING TERMINAL.
;CLOBBERS A AND B

UNPAGE:	MOVEI A,.PRIOU		;THE CONTROLLING TERMINAL
	MOVEI B,.MOXOF		;CLEAR PAUSE ON END
	SETZM C
	MTOPR			;DO IT
	 ERJMP	.+1		;ignore errors
	RET			;AND DONE

;PROCEDURE TO HANDLE DATASET CARRIER OFF OR PTY CLOSED.
;DETACH JOB IMMEDIATELY, LOGOUT AFTER 5 MINUTES IF NOT REATTACHED.
;INVOKED ON REQUEST BY PSI SERVICE

JOBCOF::SKIPGE SLOWF		;IN JSYS CONTEXT?
	JRST [	MCENTR		;NO, GET THERE - FFL and FPC setup by PSI
		PUSH P,[IFIW!MRETN]	;SETUP RETURN
		JRST .+1]
	SAVEAC <CX>		;SAVE CX BEFORE ACSAV SMASHES IT
	ACSAV
	STKVAR <CFFFL,CFFPC>
	MOVE T1,FFL		;GET CONTENTS OF FFL
	MOVEM T1,CFFFL		;SAVE IT
	MOVE T1,FPC		;GET CONTENTS OF FPC
	MOVEM T1,CFFPC		;SAVE IT
	MOVE 1,JOBNO
	SKIPGE B,CTRLTT		;HAVE A CONTROLLING TTY?
	JRST JOBCF1		;NO
	CALL GTCJOB		;GET ITS OWNING JOB
	 JRST JOBCF2		;NONE. GO ON
	CAIN C,0(A)		;SAME AS THIS ONE?
	JRST JOBCF1		;YES. GO ON
JOBCF2:	SETOM CTRLTT		;NO. CLEAR THIS ASSIGNMENT
	MOVE T1,JOBNO
	HRROS JOBPT(T1)		;ALSO CLEAR CONTROLLING TTY HERE
JOBCF1:	CALL LDTACH		;DO LOCAL DETACH
	MOVE T1,JOBNO
	HRRZ 1,JOBDIR(1)	;SEE IF NOW LOGGED IN
	IFE. T1
	  MOVX T1,USRCTX	;NO, RESET STACK AND LOGOUT
	  MOVEM T1,FFL
	  SETZM FPC
	  JRST FLOGO
	ENDIF.
	MOVE T1,BITS+.TICRF	;CHECK TO SEE WHAT THE TOP FORK THINKS
	TDNE T1,TTSPSI		; OF TAKING A CARRIER OFF INTERUPT
	 JRST JOBCF3		;IT THINKS SO, SO LET IT TRY
	CALL FFORKI		;INDIRECTLY FREEZE ALL INFERIORS
;**;[7160]ADD LABEL AT JOBCF1:+11.L	DSW	10/16/85
JOBCF0:	MOVE T1,COFTIM		;[7160] SETUP TO WAIT
	CALL SETBKT		;COMPUTE BLOCKT DATA
	HRRI 1,COFTST		;SETUP SPECIAL TEST
	MOVSI T2,FHV1		;LOW BLOCK PRIORITY
	HDISMS
	MOVE 1,JOBNO		;SEE IF NOW ATTACHED
	SKIPL JOBPT(1)
	IFSKP.
;**;[7160] REWRITE CODE IN CONDITIONAL AT JOBCF0:+7.L	DSW	10/16/85
	  MOVE T1,JOBNO		;[7160] NO, CHECK WITH ACJ
	  HRRZ T1,JOBDIR(T1)	;[7160] DIRECTORY
	  JUMPE T1,FLOGO1	;[7160] DON'T CHECK IF NOT LOGGED IN
	  HRLI T1,USRLH		;[7160]
	  CALL CNVDIR		;[7160] GET THE NUMBER OF THAT DIRECTORY
	  GTDAL			;[7160] GET THE ALLOCATION
	   ERJMP FLOGO1		;[7160] DON'T TRY ACJ IF THERE IS AN ERROR
	  SETOM T1		;[7160] FAKE LOGOUT WITH -1 AS ARGUMENT
	  GTOKM (.GOLGO,<T2,T3,T1>,JOBCF0) ;[7160] ASK ACJ, IF NO WAIT AGAIN
	  MOVX T1,USRCTX	;[7160] ACJ SAID YES...
	  MOVEM T1,FFL		;[7160] RESET STACK, INIT JSYS CONTEXT
	  SETZM FPC		;[7160]
	  MCENTR		;[7160]
	  JRST FLOGO1		;[7160] AND LOGOUT THE JOB
	ENDIF.
	NOINT			;KEEP CONTROL
	HLRZ T2,JOBPT(T1)	;GET CONTROLLING TTY
;**;[7160] CHANGE 1 LINE AT JOBCF3:-4.L	DSW	10/16/85
	MOVEI T3,.TICCC		;[7160] FAKE A CONTROL-C
	CALL TTPSRQ		;""
	CALL RFORKI		;RESUME ALL INDIRECTLY FROZEN INFERIORS
	OKINT			;ALLOW INTS AGAIN
JOBCF3:	MOVE T1,CFFFL		;GET OLD FFL
	MOVEM T1,FFL		;RESTORE IT
	MOVE T1,CFFPC		;GET OLD FPC
	MOVEM T1,FPC		;RESTORE IT AS WE MAY HAVE DONE SOME OTHER JSYS
	RET

;SCHEDULER TEST FOR ABOVE. WAITS UNTIL JOB ATTACHED OR SPECIFIED TIME
;ELAPSED

	RESCD

COFTST:	LOAD 2,FKJBN		;GET JOB NUMBER
	SKIPL JOBPT(2)		;NOW ATTACHED?
	JRST 1(4)		;YES, WAKEUP
	JRST BLOCKT		;NO, GO TEST TIME

	SWAPCD

;ATTACH JOB TO TTY

;ACCEPTS:
;	T1/ FLAGS,,JOB NUMBER TO ATTACH TO
;	T2/ USER NUMBER OF JOB IN AC 1
;	T3/ POINTER TO PASSWORD STRING
;	T4/ DESIGNATOR FOR TERMINAL TO BE USED IF AT%TRM FUNCTION OF 1
;	    IS ON.

;	ATACH

;RETURN +1: FAILURE, ERROR CODE IN 1
;RETURN +2: SUCESS.

.ATACH::MCENT
	SAVEAC <Q1,Q2,FX>	;DEFINE ALL Q'S TO USE AS WORK REGS
	STKVAR <ATACJN,ATACDR,ATACLN,ATACUN>
	MOVEM T2,ATACUN		;STASH THE USER NUMBER
	UMOVE Q1,1		;BITS MODIFYING THE ATACH
	TXNE Q1,AT%TRM		;PROXY ATTACH
	JRST ATACH1		;YES.  DO NOT CARE ABOUT USER NUMBER
	HLRZ T3,T2		;GET UNIQUE CODE OF USER NUMBER
	CAIE T3,USRLH		;IS THIS A LEGAL USER NUMBER?
	RETERR (ATACX3)		;NO, GIVE ERROR RETURN
ATACH1:	MOVEI T1,0(T1)		;GET OBJECT JOB NUMBER
	JUMPE T1,[RETERR (ATACX1)] ;CAN'T ATTACH TO JOB 0
	CALL GL2LCL		;TRANSLATE GLOBAL JOB NUMBER TO LOCAL INDEX
	 RETERR()		;LET CFS REPORT THE ERROR
	MOVEM T1,ATACJN		;SAVE JOB NUMBER TO ATTACH TO
;	CAIGE T1,NJOBS		;REASONABLE JOB NUMBER? - GL2LCL CHECKS THIS
	SKIPGE JOBRT(T1)	;AND JOB EXISTS?
ATACH5:	RETERR(ATACX1)		;NO
	TXNN Q1,AT%TRM		;PROXY ATTACH
	IFNSK.			;IF NOT
	 CAMN T1,JOBNO		;TRYING TO DO HIS JOB?
	 RETERR (ATACX2)	;YES. ERROR
	ELSE.
	 UMOVE FX,4		;GET TTY NUMBER TO ATACH THE JOB TO
	 ANDI FX,377777		;JUST LINE NUMBER PART
	 SKIPG FX		;VALID TTY NUMBER?
	 RETERR (ATACX7)	;NO, FAIL
	 CAIL FX,NLINES		;EXISTANT LINE?
	 RETERR (ATACX1)	;NO. FAIL.
	ENDIF.
	HRRZ T3,JOBDIR(T1)	;DIRECTORY OF  OTHER JOB
	MOVEM T3,ATACDR		;SAVE DIRECTORY NO. FOR FACT FILE
	CAIE T3,0(T2)		;SAME AS SPECIFIED?
	RETERR(ATACX3)		;NO
	SKIPL T1,CTRLTT		;GET CONTROLLING TERMINAL
	CALL PTYGBB		;ARE WE CONTROLLED BY BATCH?
	 SKIPA			;NO, CONTINUE
	JUMPL T1,[MOVX T1,SC%WHL!SC%OPR  ;IF CONTROLLED BY BATCH,
		TDNN T1,CAPENB	;MUST HAVE WHEEL OR OPR
		RETERR(CAPX1)	;NOT ENOUGH PRIVILEGES
		JRST .+1]	;OK, CONTINUE
	; ..

	; ..
;SEE IF USER CAN LEGALLY ATTACH OTHER JOB.  ATTACH IS LEGAL IF
;BOTH JOBS ARE SAME USER, IF THIS USER IS SC%WHL, OR IF
;USER GIVES PROPER PASSWORD
;ALSO, ATACH IS LEGAL IF JOB BEING ATTACHED IS OWNED BY THE
;SAME USER AS THE OWNER OF THE PTY CONTROLLING THE JOB DOING THE
;ATACH AND THE JOB DOING THE ATACH IS NOT YET LOGGED IN.
;ALSO, IF OWNER OF PTY IS AN ENABLED WHEEL OR OPR, JOB
;ON PTY MAY ALWAYS DO ATACH.
;ALSO, LEGAL IF OBJECT JOB IS OWNED BY ATACH-ER, DUE TO CRJOB.
;IN ADDITION, ATTACHING TO A JOB CONTROLLED BY BATCH IS ILLEGAL
;WITHOUT BEING LOGGED-IN WITH WHEEL OR OPR PRIVS ENABLED.

	HRRZ T1,Q1		;Get object Global job number
	MOVX T2,<-1,,T4>	;GETJI ARGUMENT POINTER
	MOVX T3,.JIBAT		;SEE IF UNDER CONTROL OF BATCH
	GETJI			;GET THE INFORMATION
	 SETZ T4,		;CONTINUE, CATCH THIS LATER
	JUMPL T4,[MOVE T2,JOBNO	;BATCH JOB.  USER MUST BE LOGGED-IN
		MOVX T1,SC%WHL!SC%OPR ; WITH WHEEL OR OPR ENABLED
		SKIPE JOBDIR(T2) ;TEST LOGIN
		TDNN T1,CAPENB	;IS LOGGED-IN, TEST CAPS
		 RETERR (CAPX1)	;NOT GOOD ENOUGH
		JRST .+1]	;OK, CONTINUE IN-LINE
	TXNE Q1,AT%NAT		;DOING ATACH OR UNATTACH?
	IFSKP.			;IF ATTACH
	 HRRZ T4,CTRLTT		;ASSUME THIS IS THE TTY #
	 TXNE Q1,AT%TRM		;IS IT A PROXY?
	 MOVE T4,FX		;YEP
	 HRRZ T3,Q1		;Get global job number
	 GTOKM (.GOATJ,<T3,T4>,[RETERR()]) ;LET ACJ SNIFF THIS
	ENDIF.
	MOVE T3,ATACDR		;REFETCH OTHER USER NUMBER
	MOVE T2,JOBNO		;GET THIS JOB NUMBER
	HRRZ T2,JOBDIR(T2)	;GET USER NUMBER FOR THIS JOB
	CAMN T2,T3		;SAME AS OTHER JOB?
	JRST ATACH3		;YES, NO FURTHER LEGALITY CHECKS
	JUMPN T2,ATACH6		;PTY OWNER IS IRRELEVANT IF NOT LOGGED IN
	MOVE T1,CTRLTT		;SEE IF I AM ON A PTY
	JUMPL T1,ATACH6		;JUMP IF NO CONTROLLING TTY
	CALL PTGETJ		;GET CONROLLING JOB # OR -1
	JUMPL T1,ATACH6		;NON-PTY DOING THE ATACH IF -1
	HRRZ T4,JOBDIR(T1)	;T4 GETS OWNER OF PTY
	XCTU [HRRZ T3,T2]	;GET OWNER OF JOB BEING ATACHED
	CAMN T3,T4		;THE SAME?
	JRST ATACH3		;YES, SO NO PASSWORD NEEDED
	CALL GJCAPS		;GET CAPABILITIES OF OWNER OF PTY
	TXNE T1,SC%WHL+SC%OPR	;PRIVILEGED?
	JRST ATACH3		;YES, SO NO PASSWORD NEEDED
ATACH6:	MOVE T3,ATACDR		;GET DIR NUMBER
	MOVEI T1,SC%WHL+SC%OPR
	TDNE T1,CAPENB		;THIS USER HAS CAPS?
	JRST ATACH3		;YES, NO FURTHER CHECKS
	MOVE T1,ATACJN		;SEE IF I OWN THE JOB
	HRRZ T1,JOBONT(T1)	;OWNER FIELD
	CAMN T1,GBLJNO		;IS IT ME?
	JRST ATACH3		;YES, THEN IT'S LEGAL.
	UMOVE T1,2		;GET USER NUMBER FOR PASSWORD CHECK
	CALL CNVDIR		;GET USER'S LOGGED-IN DIRECTORY NUMBER
	UMOVE T2,T3		;GET PTR TO PASSWORD STRING
	TRNE T3,-1		;FAIL IF JOB NOT LOGGED IN
	CALL PASSWC		;PROPER PASSWORD?
	 JRST [ SKIPN T1	;NO, NEED TO SLEEP?
		CALL PASPEN	;YES
		RETERR(ATACX4)]	;NOW BOMB OUT

;USER HAS PROVEN RIGHT TO DO THIS. THE FOLLOWING DATA IS AVAILABLE:
;	JOBNO/ JOB NUMBER OF CALLER OF JSYS
;	CTRLTT/ TERMINAL AT WHICH CALLER IS RUNNING
;	ATACJN/ JOB NUMBER TO BE ATTACHED TO THIS TERMINAL

;USER WANTS TO ASSOCIATE THE JOB IN ATACJN WITH THE TERMINAL IN CTRLTT
;IF THE JOB IS CURRENTLY ATTACHED, IT MUST BE DETACHED FIRST

ATACH3:	TXNE Q1,AT%TRM+AT%NAT	;IS MY TTY TO BE USED?
	JRST ATACH9		;NOT BY DEFAULT, ANYWAY.
	SKIPGE FX,CTRLTT	;YES. GET MY TTY
	RETERR ATACX2		;I DON'T HAVE ONE. FAIL.
ATACH9:	TXNN Q1,AT%TRM		;USING A DIFFERENT LINE?
	JRST ATACHB		;NO
	HRRZ T2,FX		;YES, BETTER ASSIGN SOME DYNAMIC DATA
	NOSKED			;PREVENT STATE CHANGES
	CALL GTCJOB		;GET CONTROLLING JOB
	IFSKP.			;IF ACTIVE
	 CAIE T3,777777		;UNASSIGNED?
	 CAMN T3,JOBNO		;THIS JOB?
	 SKIPA			;UNASSIGNED OR ASSIGNED TO THIS JOB
	 RETERR (DEVX2,<OKSKED>)
	ENDIF.
	CALL TTYASC		;ASSIGN AS CONSOLE
	 RETERR(,<OKSKED>)
	OKSKED
ATACHB:	MOVE T1,ATACJN		;GET BACK OBJECT JOB NUMBER
	CALL MAPJSB		;SETUP OTHER JOB'S JSB
	 RETERR(ARGX08)		;NO SUCH JOB
	MOVEI Q2,0(T1)		;SAVE OFFSET FOR OTHER JOB'S JSB
IFN STANSW,<
	SKIPLE T2,CTRLTT(Q2)	;OTHER JOB NOW ATTACHED?
	 CALL BANNER		;YES, BANNER IT
>;IFN STANSW
	SKIPGE T2,CTRLTT(Q2)	;OTHER JOB NOW ATTACHED?
	JRST ATACH2		;NO. DON'T DETACH IT

;OBJECT JOB IS ATTACHED. DETACH IT FROM ITS CURRENT CONTROLLING
;TERMINAL AND DEALLOCATE THAT TERMINAL'S DATA

	MOVEM T2,ATACLN		;SAVE ITS CONTROLLING TERMINAL
	CALL LCKDVL		;LOCK DEVICE LOCK, GO NOINT
	NOSKED			;MUST DETACH IT FIRST
	CALL STADYN		;POINT TO DYNAMIC DATA
	 JRST ATACH7  		;NOT ACTIVE. DON'T DEASSIGN IT
	CALL TTFWAK		;WAKE FORK IN INPUT WAIT ON THIS LINE
IFN STANSW&PUPSW,<
	CALL PNVABT		;BLOW AWAY PUP CONNECTION IF NECESSARY
>;IFN STANSW&PUPSW
	MOVE T2,ATACLN		;T2/ LINE NUMBER
	CALL TTYDAS		;DEASSIGN THE LINE
	 JRST [	PUSH P,T1	;SAVE THE ERROR CODE
		OKSKED
		CALL CLRLFK	;UNMAP THE JSB
		UNLOKK DEVLKK	;UNLOCK DEVICE LOCK
		OKINT		;LCKDVL WENT NOINT
		POP P,T1	;GET THE CODE BACK
		TXZN T1,1B0	;NEED TO WAIT?
		RETERR		;NO. RETURN FAILURE
		HRL T1,ATACLN	;T1/(LINE NUMBER,,ADDRESS OF TEST ROUTINE)
		MDISMS		;WAIT UNTIL DEALLOCATION IS POSSIBLE
		JRST ATACH3]	;TRY AGAIN
ATACH7:	SETOM CTRLTT(Q2)	;INDICATE JOB HAS NO CONTROLLING TERMINAL
	MOVE T1,ATACJN		;GET OBJECT JOB NUMBER
	HRROS JOBPT(T1)		;NO CONTROLLING TERMINAL AGAIN
	OKSKED
	UNLOKK DEVLKK		;UNLOCK DEVICE LOCK
	OKINT			;LCKDVL WENT NOINT
IFN STANSW,<
	MOVEI T1,^D3000		;BLOCK FOR THREE SECONDS
	CALL SETBKT		; SO THAT CARRIER-OFF PSI WILL DETACH
	HRRI T1,BLOCKT		; THE OLD JOB RATHER THAN THE NEW JOB
	MDISMS			; ON NETWORK TERMINALS
	MOVE T1,ATACJN		;GET OBJECT JOB NUMBER
>;IFN STANSW
	MOVE T2,ATACLN		;T2/ LINE NUMBER OF DETACHED JOB
	MOVE T3,JOBNO		;GET THIS JOB NUMBER
	HRRZ T3,JOBDIR(T3)	;GET USER NUMBER FOR THIS JOB
	HRLI T3,USRLH		;MAKE IT BE A USER NUMBER
	MOVE T4,CTRLTT		;AND TTY # OF DETACHER
	HRRZ T1,Q1		;Get the global job number of object
	CALL DETMS1		;TELL JOB IT'S BEING DETACHED
	; ..

;OBJECT JOB HAS BEEN DETACHED. DETACH CALLER FROM CONTROLLING TERMINAL
;AND ATTACH OBJECT JOB TO THAT TERMINAL. DON'T DEALLOCATE THE DYNAMIC
;DATA FOR THE TERMINAL

	;..
ATACH2:	TXNE Q1,AT%NAT		;REQUESTED NO ATTACH?
	JRST ATACH4		;YES
	MOVEM FX,ATACLN		;NO, MAKE SURE LINE RIGHT
	MOVE T2,FX		;prepare for LDET2
	NOINT			; ..
	CAMN FX,CTRLTT		;NEED TO GIVE AWAY MY TERMINAL?
	CALL LDET2		;YES, DETACH THIS JOB BUT KEEP DYNAMIC DATA
	NOSKED

;ASSIGN OBJECT JOB TO CORRECT TERMINAL

	MOVE T4,ATACJN		;GET OBJECT JOB
	MOVEM FX,CTRLTT(Q2)	;SET CTRLTT IN DEST JOB
	HRLM FX,JOBPT(T4)
	MOVEI T1,.TTDES(FX)	;T1/ DEVICE DESIGNATOR FOR TERMINAL
	CALL CHKDES 		;GET INDEX TO DEVICE TABLES
	 BUG.(HLT,TTBAD1,MEXEC,SOFT,<Bad device designator for terminal at ATACH2>,,<

Cause:	The call to CHKDES failed.  This should not happen, since the terminal
	number involved comes from Q3, which is either the number of terminal
	controlling the job, or a user-supplied terminal number from the user's
	AC4.  If a user-supplied number is being used, it was range-checked by
	comparing it to NLINES.  If it is the number of the controlling
	terminal, the job was already verified to be attached somewhere, so
	this BUGHLT should not occur.
>)
	MOVE T1,ATACJN		;GET OTHER JOB NUMBER
	HRLM T1,DEVUNT(T2)	;INDICATE OTHER JOB OWNS THE TERMINAL
	MOVE T2,ATACLN		;T2/ TERMINAL NUMBER
	MOVE T1,TTSPSI(Q2)	;T1/ INTERRUPT WORD FOR OTHER JOB
	MOVE T3,TTSDPS(Q2)	;T3/ DEFERRED INTERRUPT WORD FOR OTHER JOB
	CALL TTSINT		;SET INTERRUPT WORDS FOR THIS TERMINAL
	MOVE T1,ATACJN		;T1/ OTHER JOB
	CALL STCJOB		;SET THIS AS CONTROLLING THE TERMINAL
	OKSKED
	OKINT
	CALL CLRLFK		;CLEAR MAPPING OF JSB
	HRRZ T1,Q1		;Get the global job number of object
	MOVE T2,ATACLN		;SET UP JOB/LINE INFO
	CALL ATAMSG		;DO LOGGING STUFF
	MOVE T1,JOBNO
	HRRE T1,JOBDIR(T1)
	JUMPE T1,LOGO		;VANISH IF NOT LOGGED IN
	SMRETN

;HERE IF CALLER REQUESTED "NO ATTACH", I.E. DETACHING REMOTE JOB

ATACH4:	CALL CLRLFK		;CLEAR MAPPING OF JSB
	HRRZ T1,Q1		;Get the global job number of object
	MOVE T2,ATACLN		; AND LINE #
	CALL DETMS0		;DO LOG MSG AND FACT FILE ENTRY
	SMRETN

	ENDSV.			;END STKVAR

;USAGE UTILITIES FOR JOB 0

;USAGE VARIABLES

NR CKPGID,1			;PAGE IDENT OF CURRENT MAPPED PAGE UN CHECKPOINY FILE

;INIT USAGE DATA BASE

USGINI:	SAVEAC <Q1,Q2,FX>	;PRESERVE ALL TEMP WORK REGS
	STKVAR <CKPNJ,CKIDNT>
	SETOM USGLOK		;CLEAR LOCKS
	SETZM USQCNT		;EMPTY QUEUE
	SETZM USGBEG		;INIT QUEUE
	MOVEI T1,USGBEG-1
	MOVEM T1,USGEND		;TO BE EMPTY
	SETZM USGEOF		;INIT EOF POINTER
	SETZM CKPJFN		;NO JFN'S YET
	SETZM USGJFN		;...
	SETZM CKPGID		;NO PAGE MAPPED
	MOVE T1,TODCLK		;SETUP FIRST CHECKPOINT INTERVAL
	ADD T1,CKPINV
	MOVEM T1,CKPTIM		;TIME FOR FIRST CHECKPOINT
	MOVX T1,SF%CDE		;FILE SYSTEM OK?
	TDNE T1,FACTSW
	JRST [	TMSG <? System accounting will not be done due to file system errors
>
		RET]
USGIN1:	HRROI T2,USGFIL		;FILESPEC FOR USAGE FILE
	CALL USGOPN		;OPEN FILE
	 JRST [	CALL CRUSGF	;NONE - CREATE USAGE FILE
		 BUG.(HLT,UXXCRE,MEXEC,SOFT,<Cannot create usage file>,,<

Cause:	If the GTJFN (GJ%PHY,GJ%OLD) or the OPENF (OF%RD,OF%WR,
	OF%RTD) on the file pointed to by CKPFIL (PS:[ACCOUNTS]
	CHECKPOINT.BIN.1) fails, then another GTJFN (GJ%FOU) and OPENF
	(OF%WR) is attempted in order to create a new checkpoint file.
	If these latter GTJFN and OPENF fail, the UXXCRE BUGHLT occcurs.

Action:	Analyze the error code from the failing JSYS, and fix the
	checkpoint file so that the error does not happen.
>)
		JRST USGIN1]	;TRY AGAIN
	MOVEM T1,USGJFN		;STORE JFN
	TXO T1,CO%NRJ		;RETAIN JFN
	CLOSF			;THIS SHOULD CORRECT PAGE COUNT
	 JFCL			;SHOULDN'T HAPPEN
	MOVX T2,44B5+OF%RD!OF%WR!OF%RTD
	MOVE T1,USGJFN		;FETCH JFN
	OPENF			;OPEN FOR REAL NOW
	 BUG.(HLT,UXXOPN,MEXEC,SOFT,<Unable to open usage file>,,<

Cause:	USGINI invoked OPENF (OF%RD,OF%WR,OF%RTD), which failed to open the
	file pointed to by USGFIL, probably PS:[ACCOUNTS]SYSTEM-DATA.BIN.
>)
	HRRZ T1,T1		;GET RID OF OPEN FLAGS
	FFFFP			;FIND-FIRST-FREE-FILE PAGE
	HRRZ Q1,T1		;SAVE PAGE NUMBER
	MOVE T1,USGJFN		;JFN AGAIN
	MOVE T2,[1,,.FBBYV]	;GET PAGE COUNT
	MOVEI T3,T4		; INTO T4
	GTFDB
	HRRZS T4		;PAGE # ONLY
	CAME Q1,T4		;CORRECT NUMBER
	BUG.(INF,USGHOL,MEXEC,HARD,<Lost page(s) in usage file>,,<

Cause:	This BUGINF indicates that the first free page in the USAGE file as
	reported by FFFFP% is not the last page in the file. This means
	that the file has holes in it, or lost pages.

Action:	The USAGE must be repaired.

>)
	JUMPE Q1,USGIN4		;EMPTY FILE IF 0
USGIN2:	SETZ Q2,		;INIT TO WORD 0
	JUMPL Q1,USGIN3		;MUST BE EMPTY IF NONE LEFT
	SOS T1,Q1		;WANT LAST PAGE
	HRL T1,USGJFN		; FROM USAGE FILE
	MOVX T2,PM%RD		;READ ONLY
	CALL USGMAP		;MAP PAGE
	MOVEI Q2,777		;SCAN BACK FROM END OF PAGE
	SKIPN T1,FPG0A(Q2)	; FOR FIRST NON-ZERO WORD
	SOJGE Q2,.-1		;...
	AOJE Q2,[SOJA Q1,USGIN2] ;PAGE WAS ALL ZEROS
				;ADJUST COUNT TO FIRST AVAIL WORD
	;..
	;..
USGIN3:	IMULI Q1,PGSIZ		;CALC EOF POINTER
	ADD Q1,Q2
USGIN4:	MOVEM Q1,USGEOF		;SETUP LOC

;CHECKPOINT INIT

USGIN5:	HRROI T2,CKPFIL		;FILE NAME FOR CHECKPOINT
	CALL USGOPN		;OPEN IT
	 JRST [	CALL CRCKPT	;NON-EX CREATE NEW ONE
		 BUG.(HLT,UXXCKP,MEXEC,SOFT,<Couldn't create checkpoint file>,,<

Cause:	The file PS:[ACCOUNTS]CHECKPOINT.BIN.1 could not be referenced
	for one reason or another.  The code first attempts a GTJFN (GJ%PHY,
	GJ%OLD) and an OPENF (OF%RD,OF%WR,OF%RTD), one of which must fail
	for UXXCKP to be a possibility.

	After the above GTJFN or OPENF has failed, then a GTJFN (GJ%PHY,GJ%NEW)
	is attempted.  If this succeeds, then UXXCKP will occur if a failure
	happens on one of the following: the subsequent OPENF (OF%WR,OF%RD),
	the call to ASGSWP to allocate CKPSIZ words, or the SOUT writing
	CKPSIZ words to the checkpoint file.

	If the GTJFN (GJ%PHY,GJ%NEW) fails, then another GTJFN (GJ%PHY,GJ%DEL)
	is attempted, and its failure will cause UXXCKP.  If this GTJFN
	succeeds, however, then a CHFDB (turning off FB%DEL to undelete the
	file) is done, and its failure will also cause UXXCKP.

Action:	Use EDDT to patch the system so that you can bring up the system
	without the checkpoint file being referenced.  Then get the checkpoint
	file into a state such that none of the above failures will occur.
>)
		JRST USGIN5]
	MOVEM T1,CKPJFN		;SAVE JFN
	HRLZS T1		;START AT PAGE 0
	MOVEM T1,CKIDNT		;SAVE IDENT
	MOVX T2,PM%RD
	CALL USGMAP		;MAP PAGE
	MOVE Q1,FPG0A+1		;GET # OF JOBS IN FILE
	ERJMP CKPBAD		;IF NON-EX PAGE, FILE IS BAD
	MOVE T1,FPG0A+3		;SIZE OF CHECKPOINT RECORD
	CAIN T1,CKPSIZ		;BETTER BE SAME
	CAIGE Q1,NJOBS		;.GE. MAX JOBS IN MONITOR
CKPBAD:	JRST [	BUG.(INF,UXXFIT,MEXEC,HARD,<Checkpoint file not in correct format for this system, rebuilding...>,,<

Cause:	The PS:<ACCOUNTS>CHECKPOINT.BIN file is not in the correct format
	for this monitor's configuration. This can occur if the value of
	NJOBS has changed from the previous monitor or if the size of the
	checkpoint records has changed. This BUGCHK can be expected if the
	monitor has been upgraded from 5.1 to 6.0 or 6.1.

Action:	TOPS-20 will rebuild the CHECKPOINT file.

>)
		CALL UNMAPC
		MOVE T1,CKPJFN	;CLOSE AND DELETE (EXPUNGE)
		TXO T1,CO%NRJ
		CLOSF
		 JFCL
		MOVE T1,CKPJFN
		TXO T1,DF%EXP
		DELF
		 JFCL
		SETZM CKPJFN
		JRST USGIN5]	;START OVER FOR CHECKPOINT
	MOVEM Q1,CKPNJ		;SAVE NUMBER OF JOBS IN FILE
	MOVE T1,FPG0A+2		;GET DATE/TIME OF LAST CHECKPOINT
	MOVEM T1,CKPDTL		;SAVE
	SKIPN USGEOF		;USAGE FILE EMPTY?
	JRST USGI6B		;YES - SKIP THIS
	HRLZ T1,CKPJFN		;START AT PAGE 0 AGAIN
USGIN6:	MOVEI Q2,PGSIZ/CKPSIZ	;NUMBER OF JOBS/PAGE
	SETZ FX,		;INIT OFFSET
	MOVX T2,PM%RD
	MOVEM T1,CKIDNT		;SAVE IDENT
	CALL USGMAP
	SKIP FPG0A		;TEST PAGE FOR GOODNESS
	ERJMP CKPBAD		;NOT GOOD IF INTERRUPT TAKES
USGI6A:	SKIPLE T4,FPG0A(FX)	; .GT. 0 MEANS WRITE IN PROGRESS
	MOVEM T4,USGEOF		;THIS IS ACTUAL USGEOF
	ADDI FX,CKPSIZ		;STEP TO NEXT ENTYR
	SOJLE Q1,USGI6B		;MORE JOBS TO DO?
	SOJG Q2,USGI6A		;YES - MORE IN THIS PAGE?
	MOVE T1,CKIDNT		;RESTORE LAST PAGE MAPPED
	AOJA T1,USGIN6		;STEP TO NEXT PAGE

USGI6B:	CALL UNMAPC		;UNMAP CHECKPOINT PAGE; THIS IS THE LAST TIME
				; WE WILL BE USING ONLY READ ACCESS
	MOVE T1,USGJFN		;GET USAGE FILE JFN
	MOVE T2,USGEOF		;CURRENT EOF
	SFPTR			;SET TO START WRITTING HERE
	 JFCL			;IGNORE ERRORS
	MOVX T1,SF%USG		;TURN ON USAGE JSYS
	IORM T1,FACTSW		;...
	;..
	;..
	MOVE T1,TODCLK		; GET MONITOR UPTIME IN MSEC
	IDIVI T1,^D1000		; MAKE IT SECONDS
	MOVEM T1,USGMUP		; AND STORE IT WHERE RESTART LIST KNOWS
	MOVE T1,TODCLK		; GET MONITOR UPTIME IN MSEC
	IDIVI T1,^D1000		; MAKE IT SECONDS
	MOVEM T1,USGMUP		; AND STORE IT WHERE RESTART LIST KNOWS
				;WRITE RESTART RECORD NOW
	MOVEI T1,.USENT		;GENERATE ENTRY
	MOVEI T2,RSTLST		;POINT TO RESTART LIST
	USAGE			;THIS WILL MAKE A RECORD ON USQ
	CALL USGMES		;IMMEDIATELY WRITE INTO FILE
	MOVEI Q1,1		;MERGE CHECKPOINT FILE
	SOS CKPNJ		; FOR JOBS 1 THRU NJOBS-1
	CALL LGTAD		;GET DATE/TIME
	MOVE Q2,T1		;SAVE IN Q2
USGIN7:	MOVE T1,Q1		;JOB #
	CALL USGSPG		;SET PAGE FOR THIS JOB
	SKIPGE 0(T4)		;IS ENTRY ACTIVE?
	JRST USGIN8		;NO, GET NEXT ENTRY
	MOVEI T2,.UTCKP		;RECORD TYPE FOR CHECKPOINT MERGE
	HRLM T2,1(T4)		;STORE IN HEADER
	HRRZ T3,1(T4)		;GET RECORD LENGTH
	CAIL T3,CKPSIZ		;IS LENGTH LESS THAN MAX SIZE?
	JRST [	BUG.(CHK,CKPLEN,MEXEC,HARD,<USGINI - Illegal checkpoint entry length>,,<

Cause:	While executing USGINI, an active checkpoint entry was found with
	an illegal length.  This could be caused by a trashed
	CHECKPOINT.BIN file.

Action:	Delete CHECKPOINT.BIN and reload system.

>)
		JRST USGIN8]	;AND IGNORE ENTRY
	ADD T3,T4		;ADD IN BASE
	HRLM T2,0(T3)		;STORE TYPE IN TRAILER ALSO
	MOVEM Q2,2(T4)		;SET ENTRY DATE/TIME TO NOW.
	CALL USGUP0		;UPDATE FOR THIS JOB
USGIN8:	CAMGE Q1,CKPNJ		;DONE?
	AOJA Q1,USGIN7		;NO - INCR AND PROCEDE
	CALL UNMAPC		;UNMAP CHECKPOINT PAGE
	CALLRET NXTASC		;Find next acct shift change time
				; and return from USGINI


;Initialize accounting shift change stuff
;Must be done before SETSPD is run!!!

ASCINI:	SETZM ASCPTR		;Indicate no accounting shift changes yet
	SETZM ASCTIM		; and no time set for next one
	SETOM ASCLOK		;Leave ASCPTR lock unlocked
	RET			;Return from ASCINI

;RESTART ENTRY DATA LIST

RSTLST:	USENT. (.UTRST,1,1)	;RESTART RECORD TYPE
	USSNM. (<-1,,SVN>)	;SYSTEM NAME STRING
	USMVR. ([EXP SVNM])	;SYSTEM VERSION NUMBER
	USPNM. (<SIXBIT "MONITR">,US%IMM)
	USPVR. ([EXP SVNM])	;MONITOR NAME/VERSION FOR USAGE
	USMBD. (SYSTAD)		;MONITOR BUILD DATE/TIME
	USMUP. (USGMUP)		; MONITOR UPTIME SINCE LAST RELOAD
	USLCK. (CKPDTL)		;DATE/TIME OF LAST CHECKPOINT
	USMUP. (USGMUP)		; MONITOR UPTIME SINCE LAST RELOAD
	USCP0. (APRSER)		;APR SERIAL NUMBER
	0			;END OF LIST
;ROUTINE TO OPEN A FILE FOR READ/WRITE

USGOPN:	MOVX T1,GJ%SHT!GJ%PHY!GJ%OLD!GJ%ACC
	GTJFN
	 RET			;NON-EX RETURN
	MOVX T2,44B5+OF%RD!OF%WR!OF%RTD
	OPENF			;OPEN FILE
	 RET			;FAILURE
	RETSKP			;OK - RETURN

;ROUTINE TO CREATE USAGE FILE

CRUSGF:	MOVX T1,GJ%SHT!GJ%PHY!GJ%FOU
	HRROI T2,USGFIL
	GTJFN
	 RET			;ERROR
	MOVX T2,44B5+OF%WR	;WRITE FIRST
	OPENF
	 RET			;FAILURE
	CALL USGNOD		;SET NO-DUMP
	HRLI T1,.FBBYV		;CHANGE THIS WORD
	TXO T1,CF%NUD
	MOVX T2,FB%RET		;RETENTION COUNT
	MOVEI T3,0		; TO BE 0
	CHFDB
	HRRZS T1		;JFN ONLY AGAIN
	CLOSF			;FIX ON DISK
	 JFCL
	RETSKP			;GOOD RETURN
;ROUTINE TO COPY CHECKPOINT ENTRY TO USAGE FILE
; T1/ PAGE IDENT
; T4/ ENTRY ADDRESS

USGUP0:	CALL USGUPS		;Perform file update
	SETOM 0(T4)		;SET ENTRY FREE
	RET			;RETURN FROM USGUP0

; Subroutine to copy current checkpoint entry into USAGE file entry

USGUPS:	SKIPGE 0(T4)		;ENTRY ACTIVE?
	 RET			;NO - NOTHING TO DO
	MOVE T1,USGEOF		;GET CURRENT EOF
	MOVEM T1,0(T4)		;SAVE IN CHECKPOINT
	MOVE T1,USGJFN		;JFN FOR USAGE FILE
	MOVEI T2,1(T4)		;ADDRS OF DATA
	HRLI T2,(POINT 36,,)	;FORM BP
	HRRZ T3,0(T2)		;GET LENGTH OF ITEM
	ADDM T3,USGEOF		;UPDATE USAGE EOF POINTER
	MOVNS T3		;MAKE NEGATIVE
	SOUT			;DUMP INTO FILE
	 ERJMP [CALL USGIOE	;REPORT IO ERROR
		JRST .+1]
	MOVE T1,USGEOF		;CALC PAGE JUST WRITTEN
	LSH T1,-PGSFT
	HRL T1,USGJFN		;FORM IDENT
	MOVEI T2,1		;DO ONE PAGE
	UFPGS			;UPDATE FILE PAGE
	 ERJMP [CALL USGIOE	;REPORT FAILURE
		JRST .+1]
	RET			;Return from USGUPS

;IO ERROR IN USAGE FILE

USGIOE:	MOVE T1,USGEOF		;REPORT BAD PAGE
	LSH T1,-PGSFT
	BUG.(CHK,UXXWER,MEXEC,HARD,<Write error in usage file>,<<T1,PAGE>>,<

Cause:	A SOUT or UFPGS error occurred while trying to write to the USAGE
	file. This indicates that there is a hard error in the file.

Action:	The USAGE file must be repaired.

Data:	PAGE - Page number in USAGE file

>)
	RET			;CONTINUE
;ROUTINE TO CREATE A CHECKPOINT FILE

CRCKPT:	STKVAR <SCKJFN>
	HRROI T2,CKPFIL
	MOVX T1,GJ%SHT!GJ%PHY!GJ%NEW ;NEW ONLY
	GTJFN
	 ERJMP [MOVX T1,GJ%SHT!GJ%PHY!GJ%DEL	;HANDLE CASE OF THE
		HRROI T2,CKPFIL	; DELETED BUT NOT EXPUNGED FILE
		GTJFN		; TO PREVENT UXXCKP BUGHLTS
		 ERJMP R	;NOT THAT CASE
		HRLI T1,.FBCTL	;WORD IN FDB TO CHANGE
		MOVX T2,FB%DEL	;TO UNDELETE FILE
		SETZM T3	;CLEAR DELETED BIT
		CHFDB		;DO IT
		 ERJMP R	;FAILURE
		HRRZS T1	;CLEAR STUFF FROM LEFT HALF
		JRST .+1]	;AND CONTINUE
	MOVEM T1,SCKJFN		;SAVE FOR LATER
	MOVX T2,44B5+OF%WR!OF%RD ;READ/WRITE
	OPENF
	 RET			;FAILURE
	CALL USGNOD		;SET NO-DUMP
	NOINT			;APPEASE FREE SPACE ROUTINES
	MOVEI T1,CKPSIZ		;ALLOCATE BUFFER
	CALL ASGSWP		; FOR CHECKPOINT RECORD
	 RETBAD (,OKINT)	;NONE TO BE HAD
	MOVE Q2,T1		;SAVE BASE ADDRS
	MOVEI Q1,NJOBS		;INIT FOR NUMBER OF JOBS
	SETOM 0(Q2)		;-1 SHOWS FREE ENTRY
	MOVEM Q1,1(Q2)		;STORE # OF JOBS IN JOB 0
	CALL LGTAD
	MOVEM T1,2(Q2)		;DATE/TIME OF LAST CHECKPOINT
	MOVEI T1,CKPSIZ		;SIZE OF CHECKPOINT RECORD
	MOVEM T1,3(Q2)
	MOVE T1,SCKJFN		;GET JFN
	HRLI Q2,(POINT 36,,)	;FORM BP
CRCKP1:	MOVE T2,Q2		;COPY BP
	MOVNI T3,CKPSIZ		;SIZE OF ENTRY
	SOUT			;WRITE IT
	 ERJMP [OKINT		;UNDO NOINT
		RETBAD ()]	;AND GIVE ERROR
	SOJG Q1,CRCKP1		;LOOP OVER ALL JOBS
	CLOSF			;CLOSE FILE
	 JFCL
	HRRZ T1,Q2		;ADDRS OF TEMP BLOCK
	MOVEI T2,CKPSIZ		; ITS SIZE
	CALL RELSWP		;RELEASE STORAGE
	OKINT			;UNDO NOINT
	RETSKP			;GOOD RETURN
;ROUTINE TO UPDATE CHECKPOINT PAGE AND UNMAP IT

UNMAPC:	MOVEI T2,1		;1 PAGES
	SKIPE T1,CKPGID		;PAGE IDENT OF LAST PAGE MAPPED
	UFPGS			;UPDATE ON DISK
	 JFCL			;WE TRIED
	SETZB T1,CKPGID		;UNMAP PAGE, MARK NO PAGE MAPPED
	MOVEI T2,FPG0A
	CALLRET SETMPG		;...


;ROUTINE TO SET (MAP) CHECKPOINT FILE PAGE FOR JOB N
; T1/ JOB #
;RETURNS:	T4/ ENTRY ADDRESS
;		T1/ PAGE IDENT

USGSPG:	IMULI T1,CKPSIZ		;CALC CHECKPOINT LOC
	IDIVI T1,PGSIZ		;T1 := PAGE , T2 := LINE
	PUSH P,T2		;SAVE LINE
	HRL T1,CKPJFN		;FORM JFN,,PN
	MOVX T2,PM%RD!PM%WR	;READ/WRITE
	CALL USGMAP
	POP P,T4		;RESTORE OFFSET
	ADDI T4,FPG0A		;ADD IN BASE
	RET			; AND RETURN

;ROUTINE TO SET FB%NOD (NODUMP) FOR FILE JFN IN T1

USGNOD:	HRLI T1,.FBCTL		;SAY WORD 1
	TXO T1,CF%NUD		;NO UPDATE DIRECTORY
	MOVX T2,FB%NOD		;SET BIT AND MASK
	MOVX T3,FB%NOD
	CHFDB			;WRITE INTO FDB
	HRRZS T1		;RETURN JFN INTACT
	RET

;ROUTINE TO MAP A PAGE OF A FILE INTO FPG0
;CALL: T1/ JFN,,PAGE#
;      T2/ ACCESS BITS

USGMAP:	CAMN A,CKPGID		;IS THIS PAGE ALREADY MAPPED?
	 RET			;YES-- RETURN NOW FROM USGMAP
	PUSH P,T2		;SAVE ACCESS INFO
	PUSH P,T1		;SAVE PAGE ID
	MOVEI T2,1		;ONE PAGE TO UPDATE
	SKIPE T1,CKPGID		;GET CURRENT PAGE THAT'S MAPPED
	UFPGS			;UPDATE IT
	 JFCL			;WE TRIED
	POP P,T1		;RESTORE PAGE IDENT
	MOVEM T1,CKPGID		;REMEMBER NEW PAGE IDENT
	CALL JFNOFN		;CONVERT TO OFN,,PN
	 BUG.(HLT,UXXMAP,MEXEC,SOFT,<USGMAP - Call to JFNOFN failed>,,<

Cause:	USGMAP wants to map a page of a file into FPG0 via SETMPG.
	It calls JFNOFN to convert the JFN.PN atom to OFN.PN, which SETMPG
	wants.  If JFNOFN fails, this BUGHLT occurs.  Some reasons that JFNOFN
	will fail are: JFN is not associated with a disk file; JFN is not open;
	attempt to create a new page table for a file that is not open for
	writing; attempt to create a new page table for a directory file;
	attempt to create a new page table for which there is no room on disk.
>)
	POP P,T2		;RESTORE ACCESS INFO
	HRRI T2,FPG0A		;ADDRS TO MAP PAGE
	CALLRET SETMPG		;MAP THE PAGE
;USAGE QUEUED MESSAGE HANDLER

USGMES:	SAVEAC <Q1,Q2,FX>	;SAVE REGS
USGMS0:	SKIPN Q1,USGBEG		;ANYTHING ON QUEUE?
	RET			;NO - DONE
	LOAD T1,UQFCN,(Q1)	;GET FCN CODE
	CAILE T1,USGLGL		;CHECK VALID
USGBFC:	BUG.(HLT,UXXILL,MEXEC,SOFT,<USGMES - Illegal function code>,,<

Cause:	The USAGE JSYS causes entries in the usage queue.  Each
	entry has a dispatch offset which is used by USGMES as an index into
	a vector for calling the appropriate support routine.

	If the dispatch offset is too large, this BUGHLT occurs.  Since the
	monitor itself is creating the entries in the queue, such a mismatch
	should never occur.
>)
	CALL @USGREQ(T1)	;DISPATCH
	CALL OFFUSQ		;REMOVE FROM QUEUE
	JRST USGMS0		;LOOP TILL DONE

;DISPATCH TABLE

USGREQ:	DTBDSP (USGENT)		;0 - WRITE ENTRY INTO FILE
	DTBDSP (USGCLS)		;1 - CLOSE OUT FILE
	DTBDSP (USGCKU)		;2 - CHECKUOINT
	DTBDSP (USGLGI)		;3 - LOGIN
	DTBDSP (USGLGO)		;4 - LOGOUT
	DTBDSP (USGSEN)		;5 - SESSION ENTRY
	DTBDSP (USGBFC)		;6 - ILLEGAL
	DTBDSP (USGBFC)		;7 - ILLEGAL
	DTBDSP (USGASU)		;10 - Accounting shift change
   USGLGL==.-USGREQ-1

;JOB 0 ROUTINE TO PERFORM CHECKPOINT TIMING

CHKCKP:	MOVE T1,TODCLK		;CURRENT TIME
	CAMGE T1,CKPTIM		;TIME FOR CHECKPOINT?
	RET			;NO - RETURN
	SAVEAC <Q1,Q2,FX>	;SAVE REGS
	MOVE T1,FACTSW		;CHECK IF ACCOUNTING
	TXNE T1,SF%USG		;???
	CALL USGCKP		;YES - CHECKPOINT ALL JOBS
	MOVE T1,TODCLK		;RESET NEXT TIME
	ADD T1,CKPINV		;ADD INTERVAL
	MOVEM T1,CKPTIM		;SAVE NEW TIME
	RET			;RETURN


;Job 0 routine to perform automatic accounting shift change

CHKASC:	SKIPE T1,ASCTIM		;Get next accounting shift change time
	CAMLE T1,TODCLK		;Time for change yet?
	 RET			;Not yet.
	SAVEAC <Q1,Q2,FX>	;Need all the Q's for this...
	MOVE T1,FACTSW		;Get current state bits
	TXNE T1,SF%USG		;Doing accounting today?
	 CALL USGASC		;Yes-- perform accounting shift change
;	CALLRET NXTASC		;Compute next time for change and return from CHKASC
; NXTASC - Compute next accounting shift change time
;
; Register usage in this routine:
; T1/	Current DOW/time table entry
; T2/	Time selected from table (-1 if none found yet)
; T3/	Bit for current DOW (day-of-week) being tested
; T4/	Current pointer to DOW/time table
; Q1/	Bit for DOW of today
; Q2/	Current time in seconds since midnight of the day being tested
;	(will be negative if other than today)

; DOW/time table entry format:
; LH:	Bit n on means that this entry valid on day-of-week (DOW) n
;	(0=Monday)
; RH:	Time-of-day when shift will occur on selected DOWs, in
;	seconds since midnight.

NXTASC::
	SAVEAC <Q1,Q2,FX>	;Need all the Q's
	LOCK ASCLOK		;Lock time table database

	MOVX T2,-1		;Use current date/time
	MOVX T4,0		;No options
	ODCNV			;Get time, day-of-week, etc.
	 ERJMP NXTAS7		;No date/time-- set next time to never
	HRRZ Q2,T4		;Save the seconds since midnight now
	MOVX Q1,1B0		;Get first bit for Monday
	MOVNI T1,(T3)		;Get -ve day of week (0=Monday)
	LSH Q1,(T1)		;Get bit for this day of week in Q1
	MOVE T3,Q1		;Start testing at today's DOW

	MOVX T2,^D<24*60*60>	;Indicate no time found yet

; Loop through table, once for each DOW in the future, until
;  next accounting shift change time is found

NXTAS1:	SKIPN T4,ASCPTR		;Get AOBJN pointer to DOW/time table
	 JRST NXTAS7		;No table-- set next time to infinity

; Loop through table for this DOW to see if any changes this day

NXTAS2:	MOVE T1,(T4)		;Get entry from table
	TDNN T1,T3		;Entry in effect this DOW?
	 JRST NXTAS3		;No-- skip it
	CAIGE Q2,(T1)		;Has the time for this change already past?
	CAIG T2,(T1)		; or have we already found an earlier time?
	 JRST NXTAS3		;Yes to either question-- skip entry
	HRRZ T2,T1		;Found a reasonable time-- remember it

NXTAS3:	AOBJN T4,NXTAS2		;Loop through whole table

	CAIGE T2,^D<24*60*60>	;Find a valid entry?
	 JRST NXTAS8		;Yes-- go compute time from now

; No time found this DOW-- step to next day in future and search table again

	TDNE T3,Q1		;Back to today?
	 JUMPL Q2,NXTAS7	;Yes-- give up if not first time
	SUBI Q2,^D<24*60*60>	;Step current time back another day
	LSH T3,-1		;Shift to next DOW
	TXNE T3,1B7		;Beyond Sunday?
	 MOVX T3,1B0		;Yes-- reset back to Monday
	JRST NXTAS1		;Keep searching table

; No table or no entries with any DOW's-- set next time to infinity

NXTAS7:	SETZ T2,		;Indicate no time set
	JRST NXTAS9		;Store and return

; Found next applicable table entry-- find out when the change should occur

NXTAS8:	SUB T2,Q2		;Compute seconds from now till
				; when entry time will occur
	IMULI T2,^D1000		;Convert to TODCLK units of MS
	ADD T2,TODCLK		;Compute TODCLK time when we will change

NXTAS9:	MOVEM T2,ASCTIM		;Save next change time
	UNLOCK ASCLOK		;Unlock ASCPTR database
	RET			;Return from NXTASC
;WRITE ENTRY INTO FILE FROM QUEUE

USGENT:	MOVE T1,USGJFN		;GET JFN
	MOVEI T2,UQDAT(Q1)	;POINT TO DATA
	HRLI T2,(POINT 36,,)	;FORM BP
	HRRZ T3,UQDAT(Q1)	;GET LENGTH OF ITEM
	ADDM T3,USGEOF		;UPDATE EOF POINTER
	MOVNS T3		;NEGATE
	SOUT			;WRITE IN FILE
	 ERJMP [CALL USGIOE	;REPORT ERROR
		JRST .+1]
	MOVE T1,USGEOF		;CALC PAGE JUST WRITTEN
	LSH T1,-PGSFT
	HRL T1,USGJFN		;FORM IDENT
	MOVEI T2,1		;DO ONE PAGE
	UFPGS			;UPDATE FILE PAGE
	 ERJMP USGIOE		;OH WELL...
	RET			;DONE

;CLOSE OUT CURRENT FILE AND START A NEW ONE

USGCLS:	STKVAR <NJFN>
	CALL CRUSGF		;CREATE A NEW FILE
	 JRST [	BUG.(CHK,UXXCL1,MEXEC,HARD,<Unable to create new usage file>,<<T1,ERRCOD>>,<

Cause:	The USAGE file could not be created. This error will occur if a JFN
	cannot be obtained on the file or if it cannot be opened.

Data:	ERRCOD - JSYS error code

>)
		RET]		;JUST EXIT - NOTHING DONE
	HRROI T2,USGFIL		;NOW OPEN IT
	CALL USGOPN
	 JRST [	BUG.(CHK,UXXCL2,MEXEC,HARD,<Unable to open new usage file>,<<T1,ERRCOD>>,<

Cause:	This bug indicates that the USAGE file could not be opened. This
	will occur if a JFN cannot be obtained on the file or if the file
	cannot be opened.

Data:	ERRCOD - JSYS error code

>)
		RET]		;TOUGH AGAIN
	MOVEM T1,NJFN		;SAVE NEW JFN
	MOVE T1,USGJFN		;GET CURRENT JFN
	HRLI T1,.FBCTL		;THIS WORD
	TXO T1,CF%NUD		;DONT UPDATE DIR
	MOVX T2,FB%NOD		;SET TO CLEAR THIS BIT
	SETZ T3,		; TO ALLOW FILE TO DUMP
	CHFDB
	 ERJMP .+1		;WE TRIED
	HRRZS T1		;RESTORE JFN
	CLOSF			;CLOSE OUT FILE
	 BUG.(CHK,UXXCL3,MEXEC,HARD,<Unable to close usage file>,,<

Cause:	This bug indicates that TOPS-20 could not CLOSF the USAGE file.
	This bug is highly unlikely unless the JFN has been lost.

Data:	ERRCOD - JSYS error code

>)
	SETZM USGEOF		;SETUP FOR NEW FILE
	MOVE T1,NJFN
	MOVEM T1,USGJFN		;NOW HAVE NEW FILE TO USE
	UNLOCK (USGLOK)		;UNLOCK WAITER
	RET			;RETURN
;ROUTINE TO SET CHECKPOINT FROM QUEUE
;RETURNS: Q2/ PAGE IDENT

UCKSET:	LOAD T1,UQLJI,(Q1)	;Get Local job index from USAGE header
	CALL USGSPG		;SET CHECKPOINT PAGE
	MOVE Q2,T1		;SAVE IDENT
	MOVEI T1,2(T4)		;SET FROM,,TO FOR CLEAR
	HRLI T1,1(T4)		;...
	SETZM 1(T4)		;ZERO FIRST WORD
	BLT T1,CKPSIZ-1(T4)	;CLEAR
	MOVEI T1,1(T4)		;POINT TO DESTINATION
	HRLI T1,UQDAT(Q1)	; LHS := DATA
	HRRZ T2,UQDAT(Q1)	;GET LENGTH
	ADD T2,T4		;LAST WORD OF XFER
	BLT T1,0(T2)		;MOVE DATA
	SETZM 0(T4)		;MARK ITEM INUSE
	RET			;RETURN DONE

;HANDLE USAGE LOGIN

USGLGI:	CALL UCKSET		;COPY DATA TO CHECKPOINT
	CALLRET UNMAPC		;EXIT AND UNMAP PAGE

;HANDLE USAGE LOGOUT

USGLGO:	CALL UCKSET		;COPY DATA TO CHECKPOINT
	MOVE T1,Q2		;SETUP IDENT
	CALL USGUP0		;UPDATE USAGE FILE (CLEAR CKPT)
	CALLRET UNMAPC		;EXIT AND UNMAP PAGE

;HANDLE SESSION END

USGSEN:	LOAD T1,UQLJI,(Q1)	;Get local job index
	CALL USGSPG		;MAP CHECKPOINT ENTRY
	MOVE T2,UQDAT+1(Q1)	;GET UHTAD (SESSION END)
	MOVEM T2,2(T4)		;UPDATE CHECKPOINT RECORD FOR SESSION END
	PUSH P,T4		;SAVE ADDRS
	HRRZ T3,1(T4)		;CALC POINTER TO CHECKPOINT DATA
	ADDI T3,CKOFF(T4)
	HRRZ T2,UQDAT(Q1)	;CALC POINTER INTO QUEUE ENTRY
	ADDI T2,CKOFF+1(Q1)	; FOR CKPT DATA
	MOVE T4,0(T2)		;UPDATE CHECKPOINT RECORD
	MOVEM T4,0(T3)		; STASH SESSION START TIME
	MOVE T4,1(T2)		;GET CONNECT TIME
	MOVEM T4,1(T3)		; STASH IT
	MOVE T4,2(T2)		;GET RUNTIME
	MOVEM T4,2(T3)		; STASH IT
	POP P,T4		;RESTORE ADDRS
	CALL USGUP0		;MERGE INTO USAGE FILE(T1 AND T4 SETUP)
	CALL UCKSET		;COPY NEW CHECKPOINT INFO
	HRRZ T1,1(T4)		;NOW SETUP TO CLEAR CHECKPOINT
	ADDI T1,CKOFF(T4)
	SETZM 1(T1)		;DATA FOR RUTIME AND CONNECT
	SETZM 2(T1)		;...
	MOVE T2,UQDAT+1(Q1)	;GET TIME OF SESSION CHANGE (END TIME)
	MOVEM T2,0(T1)		; STASH AS NEW SESSION START TIME
	CALLRET UNMAPC		;UNMAP CHECKPOINT PAGE
;ROUTINE TO UPDATE CHECKPOINT ENTRY FOR A SINGLE JOB
; T1/ JOB NUMBER

CPOINT:	SETZM ASCFLG		;Don't perform accounting shift change
CPONT0:	SAVEAC <Q1,Q2,FX>	;SAVE REGS
	STKVAR <PGID,CPAD,CPIP>	;Page ident, chekpoint address,
				; checkpoint item AOBJN pointer
	MOVE Q1,T1		;SAVE JOB # IN Q1
	CALL USGSPG		;SET CHECKPOINT PAGE
	MOVEM T1,PGID		;Save checkpoint page address in PGID
	MOVEM T4,CPAD		;Save address within page in CPAD
	HRRZ FX,1(T4)		;GET LENGTH OF ENTRY
	ADDI FX,CKOFF(T4)	;POINT TO CHECKPOINT DATA
	HRLI FX,-CKITMS		;FORM AOBJN PNTR
	MOVEM FX,CPIP		;Save checkpoint item pointer
	CALL LGTAD		;GET CURRENT DATE/TIME
	MOVEM T1,2(T4)		; INTO CHECKPOINT RECORD
	MOVE T1,Q1		;JOB #
	NOSKED			;DO THIS NOSKED
	SKIPN JOBDIR(T1)	;JOB LOGGED IN?
	JRST [	OKSKED		;NO - JUST RETURN
		JRST CPNT3]
	CALL SETJSB		;MAP JSB FOR JOB
	OKSKED			;JOB IS NOW FIXED IN MY MAP
	MOVE T3,T1		;SAVE PNTR IN T3
	MOVEI Q2,0		;INIT INDEX TO 0

; *** NOTE *** WITH FIXES TO SESSION START TIME, IT MAY NOT BE NECESSARY
; TO RESET THE SESSION START TIME ALL THE TIME. IF YOU CAN PROVE IT ...

CPNT1:	XCT CPTBL(Q2)		;FETCH WORD
	MOVEM T1,0(FX)		;STORE
	AOS Q2			;STEP TO NEXT TABLE ENTRY
	AOBJN FX,CPNT1

	SKIPN ASCFLG		;This accounting shift change also?
	 JRST CPNT2		;No-- go on

; Accounting shift change-- update USAGE file

	MOVE T1,PGID		;Get page ident
	MOVE T4,CPAD		;Address within page
	PUSH P,T3		;Save JSB pointer
	CALL USGUPS		;Make new USAGE entry
	SETZM 0(T4)		;Indicate checkpoint entry still in use
	POP P,T3		;Restore JSB pointer

; Reset job statistics and set new checkpoint entry

	MOVE FX,CPIP		;Get checkpoint item pointer
	MOVEI Q2,0		;INIT INDEX TO 0
CPNT11:	MOVE T1,0(FX)		;Get old value
	XCT SETBL(Q2)		;Reset current value of data item
	XCT CPTBL(Q2)		;Get new value of data item
	MOVEM T1,0(FX)		;STORE
	AOS Q2			;STEP TO NEXT TABLE ENTRY
	AOBJN FX,CPNT11

CPNT2:	CALL CLRJSB		;UNMAP JSB
CPNT3:	RET			;RETURN FROM CPOINT

;CHECKPOINT DATA TABLE

CPTBL:	MOVE T1,CTIMON(T3)	;(0) SESSION START TIME
	CALL CPGCON		;(1) GET CONNECT TIME
	CALL CPGRTM		;(2) JOB RUN TIME

;Checkpoint data routines

CPGCON:	MOVE T1,TODCLK		;CURRENT DATE/TIME
	SUB T1,CONSTO(T3)	; LESS START TIME
	SUB T1,JSSCTM(T3)	; from start of session
	RET			;GIVES CONNECT TIME

CPGRTM:	MOVE T1,JOBRT(Q1)	;Get job runtime
	SUB T1,JSSRTM(T3)	; from start of session
	RET			;Return from CPGRTM

;Session End data table

SETBL:	CALL SESCTI		;(0) Date/time of session start
	ADDM T1,JSSCTM(T3)	;(1) Console time start of session
	ADDM T1,JSSRTM(T3)	;(2) Runtime start of session

;Session End data routines

SESCTI:	CALL LGTAD		;Get current date/time
	MOVEM T1,CTIMON(T3)	;Set start of new session
	RET			;Return from SESCTI


;PERFORM CHECKPOINT OVER ALL JOBS

USGCKU:	CALL USGCKP		;DO WORK
	JRST USGULR		;Unlock waiter and return

;Perform accounting shift change

USGASU:	CALL USGASC		;Do work
USGULR:	UNLOCK (USGLOK)		;UNLOCK WAITER
	RET			;RETURN

;Internal routine to perform checkpoint of all jobs
; or accounting shift change

USGCKP:	SETZM ASCFLG		;Note not accounting shift change
	JRST USGC00		;Continue

USGASC:	SETOM ASCFLG		;Note accounting shift change
USGC00:	MOVEI Q1,NJOBS-1	;MAX JOBS TO DO

; Loop over all active jobs

USGCK0:	SKIPN JOBDIR(Q1)	;JOB EXIST AND IS LOGGED IN?
	JRST USGCK1		;NO - STEP TO NEXT
	MOVE T1,Q1		;COPY JOB #
	CALL CPONT0		;CHECKPOINT ONE JOB
USGCK1:	SOJG Q1,USGCK0		;LOOP OVER ALL
	MOVEI T1,0		;MAP JOB 0 ENTRY
	CALL USGSPG		;...
	MOVE Q1,T4		;POINTER TO ENTRY
	MOVE Q2,T1		;PAGE IDENT
	CALL LGTAD		;GET CURRENT DATE/TIME
	MOVEM T1,2(Q1)		;UPDATE DATE/TIME OF CKPOINT
	MOVE T1,Q2		;UNMAP PAGE
	CALLRET UNMAPC		; AND EXIT

	RESCD

	TNXEND
	END
