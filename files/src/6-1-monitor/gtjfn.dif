

; GTJFN.MAC.3 & GTJFN.GXJFN.1 19-Apr-88 0111	PAGE 1



LINE 1, PAGE 1
1)	;[SRI-NIC]SRC:<6-1-MONITOR>GTJFN.MAC.2, 15-Mar-87 02:17:48, Edit by MKL
1)	; add kludge to stop RELRNG until bug is found (just before RELJF1)
1)	;[SRI-NIC]XS:<SU-61SU>GTJFN.MAC.2,  5-Dec-86 14:07:40, Edit by MKL
1)	;;SS:<6-1-MONITOR>GTJFN.MAC.3, 28-Oct-85 16:46:01, Edit by KNIGHT
1)	;; Up MAXINP to 10000.
1)	
1)	; *** Edit 7300 to GTJFN.MAC by RASPUZZI on 23-May-86, for SPR #21241
1)	; Stop MONNEJ BUGCHKs by putting in missing ERJMPs 
1)	; *** Edit 7298 to GTJFN.MAC by RASPUZZI on 22-May-86
1)	; Add code to make the .GJNOD function work when an extended block is passed 
1)	
1)	;------------------------- Autopatch Tape # 13 -------------------------
1)	; *** Edit 7206 to GTJFN.MAC by WAGNER on 4-Dec-85, for SPR #20941
1)	; Fix RELRNG bughlts caused by trying to release non-existant temp storage.
1)	; There is no temp storage when a JFN is transitional. 
1)	;------------------------- Autopatch Tape # 12 -------------------------
1)	; *** Edit 7194 to GTJFN.MAC by LOMARTIRE on 15-Nov-85 (TCO none)
1)	; Remove edit 7135 because of bad side effects 
1)	; Edit 7135 to GTJFN.MAC by LOMARTIRE on 15-Aug-85, for SPR #15670 (TCO 6-1-1520)
1)	; Allow JFNS% to return connected directory on parse-only JFNs 
1)	;<6-1-MONITOR.FT6>GTJFN.MAC.2, 11-Aug-85 19:34:51, Edit by WHP4
1)	;Stanford changes:
1)	; Add ? handling (see lines marked with SMXGTJ)
1)	; Partial recognition for filenames
1)	; Changes for CWR's attribute lookup code
1)	; Fix random punctuation
1)	;
1)	; UPD ID= 2263, SNARK:<6.1.MONITOR>GTJFN.MAC.59,  21-Jun-85 12:20:23 by LOMARTIRE
1)	;More TCO 6.1.1292 - Remove code added at GNJFN1 until better solution found
1)	; UPD ID= 2235, SNARK:<6.1.MONITOR>GTJFN.MAC.58,  18-Jun-85 16:35:03 by MOSER
1)	;TCO 6.1.1459 - RETURN CORRECT ERRORS - LOGICAL NAME LOOP ETC FROM SETDEV
1)	; UPD ID= 2214, SNARK:<6.1.MONITOR>GTJFN.MAC.57,  11-Jun-85 15:31:44 by MCCOLLUM
1)	;TCO 6.1.1442 - Only save FILOPT in STRDVD if we came in through STRDEV
1)	; UPD ID= 2207, SNARK:<6.1.MONITOR>GTJFN.MAC.56,   7-Jun-85 08:47:37 by LOMARTIRE
1)	;TCO 6.1.1394 - Make extension recognition work again as in 5.1
1)	; UPD ID= 2204, SNARK:<6.1.MONITOR>GTJFN.MAC.55,   5-Jun-85 21:07:23 by PALMIERI
1)	;TCO 6.1.1433  Allow wildcards in filespec when doing parse only network JFNs
1)	; UPD ID= 2081, SNARK:<6.1.MONITOR>GTJFN.MAC.54,   3-Jun-85 14:40:45 by MCCOLLUM
1)	;TCO 6.1.1406  - Update copyright notice.
1)	; UPD ID= 1881, SNARK:<6.1.MONITOR>GTJFN.MAC.53,   4-May-85 12:55:45 by MCCOLLUM
1)	;TCO 6.1.1238 - Fix more BUG. documentation
1)	; UPD ID= 1784, SNARK:<6.1.MONITOR>APRSRV.MAC.196,  23-Apr-85 12:40:03 by MCCOLLUM
1)	; UPD ID= 1699, SNARK:<6.1.MONITOR>GTJFN.MAC.52,  29-Mar-85 15:28:28 by MCCOLLUM
1)	;TCO 6.1.1296 - Save FILOPT in RECNA0 before calling DEFDEV
1)	; UPD ID= 1694, SNARK:<6.1.MONITOR>GTJFN.MAC.51,  28-Mar-85 12:42:30 by LOMARTIRE
1)	;TCO 6.1.1292 - Make GNJFN handle deleted files better
1)	; UPD ID= 1659, SNARK:<6.1.MONITOR>GTJFN.MAC.50,  20-Mar-85 14:52:12 by LOMARTIRE
1)	;TCO 6.1.1279 - Prevent ILLUUO from bad byte pointer passed in to GTJFN

; GTJFN.MAC.3 & GTJFN.GXJFN.1 19-Apr-88 0111	PAGE 2


1)	; UPD ID= 1654, SNARK:<6.1.MONITOR>GTJFN.MAC.49,  18-Mar-85 16:59:05 by PALMIERI
1)	;TCO 6.1.1276  Allow wildcard for nodename for parse only JFN's
1)	; UPD ID= 1622, SNARK:<6.1.MONITOR>GTJFN.MAC.48,  12-Mar-85 15:54:36 by LOMARTIRE
1)	;More TCO 6.1.1222 - Make sure length of string is always counted correctly
1)	; UPD ID= 1580, SNARK:<6.1.MONITOR>GTJFN.MAC.47,   4-Mar-85 07:42:40 by LOMARTIRE
1)	;TCO 6.1.1222 - Make G1%NLN work correctly when recognition used
1)	; UPD ID= 1431, SNARK:<6.1.MONITOR>GTJFN.MAC.46,  31-Jan-85 10:56:25 by LOMARTIRE
1)	;TCO 6.1.1143 - Make system wide logicals search job then system wide tables
1)	; UPD ID= 1402, SNARK:<6.1.MONITOR>GTJFN.MAC.45,  24-Jan-85 16:45:04 by LOMARTIRE
1)	;TCO 6.1.1121 - Prevent ILMNRF in RECDIR with parse-only JFN no-match
1)	;UPD ID= 1257, SNARK:<6.1.MONITOR>GTJFN.MAC.44,   2-Jan-85 11:09:20 by PAETZOLD
1)	;More TCO 6.1.1101 - Change the way the FILOPT calculation is done.
1)	; UPD ID= 1255, SNARK:<6.1.MONITOR>GTJFN.MAC.43,   1-Jan-85 18:39:43 by PAETZOLD
1)	;More TCO 6.1.1101 - Put back GNJFN3 call in STRDEV.
1)	; UPD ID= 1252, SNARK:<6.1.MONITOR>GTJFN.MAC.42,   1-Jan-85 15:24:29 by PAETZOLD
1)	;TCO 6.1.1101 - Make STRDEV prevent device name block overtrimming.
1)	; UPD ID= 5019, SNARK:<6.MONITOR>GTJFN.MAC.41,  26-Oct-84 13:51:40 by LOMARTIRE
1)	;TCO 6.2261 - Return GJFX24 not STRX09 when device expansion fails for log name
1)	; UPD ID= 4809, SNARK:<6.MONITOR>GTJFN.MAC.40,  17-Sep-84 10:01:12 by PURRETTA
1)	;Update copyright notice
1)	; UPD ID= 4801, SNARK:<6.MONITOR>GTJFN.MAC.39,  13-Sep-84 12:01:04 by PAETZOLD
1)	;More TCO 6.2190 - Make DSK*: when it is the default device.
1)	; UPD ID= 4737, SNARK:<6.MONITOR>GTJFN.MAC.38,  24-Aug-84 09:39:46 by PAETZOLD
1)	;TCO 6.2190 - Fix DSK*: to work when PS is not named PS:.
1)	; UPD ID= 4142, SNARK:<6.MONITOR>GTJFN.MAC.36,  25-Apr-84 16:06:34 by CJOHNSON
1)	; Temporarily remove edit for TCO 6.1976 - it was crashing
1)	; UPD ID= 3799, SNARK:<6.MONITOR>GTJFN.MAC.34,  29-Feb-84 01:42:58 by TGRADY
1)	; Implement Global Job numbers
1)	; - In DEFVER, user Global job number in GBLJNO to create Temp file version #
1)	;
1)	; UPD ID= 3784, SNARK:<6.MONITOR>GTJFN.MAC.33,  28-Feb-84 13:31:36 by CJOHNSON
1)	;TCO 6.1976 - Make STRDEV determine the name of the p.s., rather than assume PS
1)	; UPD ID= 3485, SNARK:<6.MONITOR>GTJFN.MAC.32,  20-Jan-84 07:44:26 by MCINTEE
1)	;Still more TCO 6.1030 - allow node names for parse-only filespecs
1)	; UPD ID= 3258, SNARK:<6.MONITOR>GTJFN.MAC.31,   6-Dec-83 09:51:58 by MOSER
1)	;TCO 6.1833 - PREVENT CRASH WHEN PARSE ONLY AND ATTRIBUTES
1)	; UPD ID= 2989, SNARK:<6.MONITOR>GTJFN.MAC.30,   5-Oct-83 14:48:23 by PAETZOLD
1)	;TCO 6.1817 - Reset FILST1 as well as FILSTS in ASGJFN
1)	; UPD ID= 2957, SNARK:<6.MONITOR>GTJFN.MAC.29,  28-Sep-83 16:51:43 by MOSER
1)	;TCO 6.1810 - DON'T EXPAND DSK: IF G1%SLN SET
1)	; UPD ID= 2888, SNARK:<6.MONITOR>GTJFN.MAC.26,  12-Sep-83 12:37:09 by PRATT
1)	;TCO 6.1795 - Fix problem with GJ%MSG which causes user confusion @ENDAL2-2
1)	; UPD ID= 2881, SNARK:<6.MONITOR>GTJFN.MAC.25,   8-Sep-83 09:59:47 by TBOYLE
1)	;More TCO 6.1743 - fix typo, change .ENDIF to ENDIF.
1)	; UPD ID= 2880, SNARK:<6.MONITOR>GTJFN.MAC.24,   7-Sep-83 12:59:32 by TBOYLE
1)	;TCO 6.1743 - Make DEFEXT: return GJFX23 if it occurs.
1)	; UPD ID= 2866, SNARK:<6.MONITOR>GTJFN.MAC.23,  24-Aug-83 08:17:22 by MCINTEE
1)	;More TCO 6.1226 - In ASGJFN, clear the word FILST1
1)	; UPD ID= 2772, SNARK:<6.MONITOR>GTJFN.MAC.22,  27-Jul-83 13:30:54 by MCINTEE
1)	;More TCO 6.1030 - Better error message for node names in file specs
1)	; UPD ID= 2295, SNARK:<6.MONITOR>GTJFN.MAC.21,  16-Apr-83 19:17:23 by PAETZOLD

; GTJFN.MAC.3 & GTJFN.GXJFN.1 19-Apr-88 0111	PAGE 3


1)	;TCO 6.1557 - TCP Merge - Delete old edit history - Update copyright.
1)	; UPD ID= 2146, SNARK:<6.MONITOR>GTJFN.MAC.20,   4-Apr-83 13:23:27 by MCINTEE
1)	;More TCO 6.1030 - Node names in file spec not in 6.0
1)	; UPD ID= 2106, SNARK:<6.MONITOR>GTJFN.MAC.19,  28-Mar-83 17:48:44 by MURPHY
1)	;Minor cleanup - use ERJMPR instead of explicit load from LSTERR.
1)	; UPD ID= 1596, SNARK:<6.MONITOR>GTJFN.MAC.16,  29-Dec-82 10:41:01 by DONAHUE
1)	;TCO 6.1159 - Don't allocate CTRL/R buffer if string is from memory
1)	; UPD ID= 1272, SNARK:<6.MONITOR>GTJFN.MAC.15,   4-Oct-82 12:42:21 by MCINTEE
1)	;TCO 6.1030 - Add call to DIMLNK near end of .GTJFN
1)	; UPD ID= 1125, SNARK:<6.MONITOR>GTJFN.MAC.14,  31-Aug-82 12:43:00 by MCINTEE
1)	;TCO 6.1243 - Change all occurrences of ENDSTR to ENDSTX
1)	; UPD ID= 1090, SNARK:<6.MONITOR>GTJFN.MAC.13,  18-Aug-82 08:10:38 by PAETZOLD
1)	;More TCO 6.1219 - Use FILDEV from the JFN as COMND does not have DEV set up
1)	; UPD ID= 1080, SNARK:<6.MONITOR>GTJFN.MAC.12,  11-Aug-82 15:59:45 by PAETZOLD
1)	;One more time TCO 6.1219 - Do not use P3 as it is DEFAC'ed out
1)	; UPD ID= 1079, SNARK:<6.MONITOR>GTJFN.MAC.11,  11-Aug-82 13:29:59 by PAETZOLD
1)	;More TCO 6.1219 - Use P3 instead of DEV in RELJFN as DEV might have unit
1)	;                  numbers in the left half
1)	; UPD ID= 1078, SNARK:<6.MONITOR>GTJFN.MAC.10,  11-Aug-82 10:33:15 by PAETZOLD
1)	;More TCO 6.1219 - Handle case where DEV not set in RLJFD call in RELJFN
1)	; UPD ID= 1065, SNARK:<6.MONITOR>GTJFN.MAC.9,   9-Aug-82 16:19:49 by PAETZOLD
1)	;TCO 6.1219 - Make RELJFN dispatch to RLJFD
1)	; UPD ID= 979, SNARK:<6.MONITOR>GTJFN.MAC.8,   7-Jul-82 16:11:28 by MCINTEE
1)	;More TCO 6.1143 - NFT: strikes again
1)	; UPD ID= 963, SNARK:<6.MONITOR>GTJFN.MAC.7,  28-Jun-82 14:53:52 by MCINTEE
1)	;More TCO 6.1030 - initialize FLLNK in JFN block
1)	; UPD ID= 893, SNARK:<6.MONITOR>GTJFN.MAC.6,   9-Jun-82 22:56:45 by MURPHY
1)	;TCO 6.1147 - Move bugdefs from BUGS.MAC to here and put them in-line.
1)	; UPD ID= 882, SNARK:<6.MONITOR>GTJFN.MAC.5,   9-Jun-82 15:53:31 by MCINTEE
1)	;TCO 6.1030 - change some MDDOKs to DSKOK.
1)	; UPD ID= 855, SNARK:<6.MONITOR>GTJFN.MAC.4,   7-Jun-82 08:17:22 by MCINTEE
1)	;TCO 6.1030 : node name parsing - recognition fix
1)	; UPD ID= 780, SNARK:<6.MONITOR>GTJFN.MAC.3,  24-May-82 11:32:33 by MCINTEE
1)	;more TCO 6.1143 & fix up disallowing of NFT: in file specs
1)	; UPD ID= 773, SNARK:<6.MONITOR>GTJFN.MAC.2,  20-May-82 10:09:52 by MCINTEE
1)	;TCO 6.1143 - Add in "local files specs only" to long form GTJFN - G1%LOC
1)	; UPD ID= 300, SNARK:<6.MONITOR>GTJFN.MAC.13,  14-Jan-82 09:00:34 by MCINTEE
1)	;TCO 6.1055 - GJ%NOD flag returned if node name in file spec
1)	; UPD ID= 290, SNARK:<6.MONITOR>GTJFN.MAC.12,  10-Jan-82 15:36:07 by GROUT
1)	;TCO 5.1656: If G1%SLN set, don't expand DSK:
1)	; UPD ID= 284, SNARK:<6.MONITOR>GTJFN.MAC.11,   8-Jan-82 14:50:05 by MURPHY
1)	;Restore COC words correctly (bug from code reorg)
1)	; UPD ID= 268, SNARK:<6.MONITOR>GTJFN.MAC.10,  23-Dec-81 15:46:00 by MCINTEE
1)	;Node name parsing : -1	in LH of FILDEV (No units on this "device")
1)	; UPD ID= 262, SNARK:<6.MONITOR>GTJFN.MAC.9,  16-Dec-81 16:23:14 by MCINTEE
1)	;Node name parsing - disallow wildcards & recognition and fix bugs
1)	;Disallow use of NFT: in file spec
1)	; UPD ID= 202, SNARK:<6.MONITOR>GTJFN.MAC.8,  10-Nov-81 12:20:27 by MURPHY
1)	;TAKE OUT TCO 5.1415
1)	; UPD ID= 181, SNARK:<6.MONITOR>GTJFN.MAC.7,   3-Nov-81 13:20:47 by MCINTEE
1)	;Node name parsing - Call SETTMP after parsing the node part

; GTJFN.MAC.3 & GTJFN.GXJFN.1 19-Apr-88 0111	PAGE 4


1)	; UPD ID= 140, SNARK:<6.MONITOR>GTJFN.MAC.6,  19-Oct-81 16:00:22 by COBB
1)	;TCO 6.1029 - CHANGE SE1CAL TO EA.ENT
1)	; UPD ID= 124, SNARK:<6.MONITOR>GTJFN.MAC.5,  19-Oct-81 09:51:37 by MCINTEE
1)	;Fix error returns for node name parsing
1)	; UPD ID= 107, SNARK:<6.MONITOR>GTJFN.MAC.4,  14-Oct-81 23:45:30 by MURPHY
1)	;Fix bugs from node parsing
1)	; UPD ID= 100, SNARK:<6.MONITOR>GTJFN.MAC.2,  12-Oct-81 11:58:31 by COBB
1)	;tco 5.1562 - Insert default fields when called parse-only (GJ%OFG)
1)	;NODE NAME PARSING
1)	;PUT SOURCE INTO M60:
1)	; UPD ID= 88, SNARK:<5.MONITOR>GTJFN.MAC.14,   4-Aug-81 09:33:39 by SCHMITT
LINE 1, PAGE 1
2)	;<MONITOR.CMU.MERGE>GTJFN.MAC.4, 21-Apr-87 15:48:25, Edit by VAF
2)	;[BBN] TCP: ;FLAGS attribute
2)	;<MONITOR.CMU>GTJFN.MAC.3, 31-Oct-86 13:11:10, Edit by VAF
2)	;CS161 Make this be CS-only
2)	;<MONITOR.CMU>GTJFN.MAC.2, 24-Sep-86 15:36:06, Edit by VAF
2)	;CS161 Change to RELJFN for Stanford pipes.
2)	;<MONITOR.CMU>GTJFN.MAC.1, 15-Jan-85 21:59:52, Edit by VAF
2)	;Remerge CC/CS change in 5.1 tape #8/5.4 IP/TCP
2)	;CS82T-TL11 GXJFN%: Support for fast cumulative-incremental dumps and
2)	;	disk scans.
2)	;CS82	[SMXGTJ] Add ? handling.
2)	;CS82A	More [SMXGTJ] for partial recognition handling.
2)	;CS82B	Improvements to CS82: comma-separate & "lineify" file name output.
2)	;	Give message, not beep for no matching files.
2)	;CM366	;A* hack for seeing files protected against user.
2)	;CMB111	At REDFL1 - load T2 with XCTV and change XCT - prevent ILLUUO
2)	;-------
2)	;GIDNEY::<TCPIP.5.3.MONITOR>GTJFN.MAC.3, 19-Mar-84 10:34:57, Edit by PAETZOLD
2)	;Zero FILST1 in ASGJFN
2)	;<TCPIP.5.3.MONITOR>GTJFN.MAC.2,  6-Dec-83 23:49:37, Edit by PAETZOLD
2)	;<TCPIP.5.1.MONITOR>GTJFN.MAC.7,  5-Jul-83 08:24:33, Edit by PAETZOLD
2)	;TCP Changes for 5.1 merge
2)	;Edit 3103 to GTJFN.MAC by CJOHNSON on Wed 25-Apr-84, for SPR #19927
2)	;		Remove faulty edit 3077
2)	;Edit 3077 to GTJFN.MAC by CJOHNSON on Fri 24-Feb-84, for SPR #19927
2)	;		Make STRDEV determine name of public structure (fix DSK*:)
2)	;Edit 3050 to GTJFN.MAC by MOSER on Tue 6-Dec-83 - PREVENT ILMNRF
2)	;EDIT 3050 - PREVENT ILMNRF WHEN PARSE ONLY HAS ATRIBUTES.
2)	; NOTE: EDIT 3050 WAS IN 4.1 AND SIRUS AS EDIT 1980 BY PED
2)	;Edit 3013 to GTJFN.MAC by PRATT on Mon 12-Sep-83, for SPR #17124
2)	;		Fix GJ%MSG problem which causes user confusion.
2)	;Edit 3011 to GTJFN.MAC by TBOYLE on Wed 7-Sep-83, for SPR #17233
2)	;		Make DEFEXT: return GJFX23 error if it occurs.
2)	;Edit 2945 by LOMARTIRE on Wed 6-Apr-83, for SPR #18751
2)	;		Do not output SYS: when escape first character hit.
2)	; UPD ID= 58, FARK:<5-WORKING-SOURCES.MONITOR>GTJFN.MAC.2,   9-Jun-82 13:01:28 by DONAHUE
2)	;Edit 2625 - Don't allocate CTRL/R buffer if string is from memory
2)	; UPD ID= 478, SNARK:<5.MONITOR>GTJFN.MAC.18,  16-Feb-82 16:39:59 by GROUT
2)	;Revision of TCO 5.1656 - fix typographical error

; GTJFN.MAC.3 & GTJFN.GXJFN.1 19-Apr-88 0111	PAGE 5


2)	; UPD ID= 442, SNARK:<5.MONITOR>GTJFN.MAC.17,  26-Jan-82 10:02:43 by GROUT
2)	;TCO 5.1656 - Don't expand existing DSK: if G1%SLN set
2)	; UPD ID= 300, SNARK:<5.MONITOR>GTJFN.MAC.16,  28-Oct-81 11:33:19 by MURPHY
2)	;Take out TCO 5.1415 because it affects external behaviour of GTJFN.
2)	; UPD ID= 254, SNARK:<5.MONITOR>GTJFN.MAC.15,  12-Oct-81 11:41:35 by COBB
2)	;TCO 5.1562 - Insert default fields when GJ%OFG (parse-only)
2)	; UPD ID= 88, SNARK:<5.MONITOR>GTJFN.MAC.14,   4-Aug-81 09:33:39 by SCHMITT


LINE 169, PAGE 1
1)	;CLEAN UP CODE, SOME STEPS TOWARD PARSING NODE NAMES AS NODE::
1)	; UPD ID= 1489, SNARK:<5.MONITOR>GTJFN.MAC.9,  25-Jan-81 20:33:21 by ZIMA
LINE 54, PAGE 1
2)	; UPD ID= 1489, SNARK:<5.MONITOR>GTJFN.MAC.9,  25-Jan-81 20:33:21 by ZIMA


LINE 186, PAGE 1
1)	
1)	^L
1)	
1)	;THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY  BE  USED
1)	;OR COPIED ONLY IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
1)	;
1)	;COPYRIGHT  (C)  DIGITAL  EQUIPMENT  CORPORATION  1976, 1985.
1)	;ALL RIGHTS RESERVED.
1)	
1)	
LINE 70, PAGE 1
2)	;<4.MONITOR>GTJFN.MAC.35, 15-Oct-79 16:19:01, Edit by SCHMITT
2)	;TCO 4.2252 - HAVE GNJFN CLR IGDLF ONLY IF WANT LOWEST NON-DELETED VERSION
2)	;<OSMAN.MON>GTJFN.MAC.1, 10-Sep-79 15:32:38, EDIT BY OSMAN
2)	;TCO 4.2412 - Move definition of BUGHLTs, BUGCHKs, and BUGINFs to BUGS.MAC
2)	;<4.MONITOR>GTJFN.MAC.33,  3-Aug-79 11:48:18, EDIT BY DBELL
2)	;MOVE CHECKING FOR G1%SLN TO A BETTER PLACE
2)	;<4.MONITOR>GTJFN.MAC.32, 26-Jun-79 11:24:37, EDIT BY DBELL
2)	;TCO 4.2311 - IMPLEMENT G1%SLN TO PREVENT EXPANSION OF LOGICAL NAMES
2)	;<4.MONITOR>GTJFN.MAC.31, 12-Jun-79 08:30:50, EDIT BY MILLER
2)	;DON'T CALL DEVAV IN SETDEV IF PARSE-ONLY
2)	;<4.MONITOR>GTJFN.MAC.30,  6-Jun-79 19:05:17, EDIT BY DBELL
2)	;REMOVE TCO 4.2252, IT CAUSED OTHER BUGS.
2)	;<4.MONITOR>GTJFN.MAC.29, 30-May-79 11:49:34, EDIT BY DBELL
2)	;TCO 4.2262 - SET GNJFF TO INDICATE A GNJFN IS BEING DONE
2)	;<4.MONITOR>GTJFN.MAC.28, 29-May-79 16:09:19, EDIT BY KIRSCHEN
2)	;REMOVE SPOOLED FILE FORMS ATTRIBUTE FROM ATTRIBUTE LIST
2)	;<4.MONITOR>GTJFN.MAC.27, 18-May-79 11:26:26, EDIT BY DBELL
2)	;TCO 4.2252 - HAVE GNJFN ONLY SET IGDLF IF WE WANT DELETED FILES.
2)	;<4.MONITOR>GTJFN.MAC.26, 17-May-79 08:44:12, EDIT BY BLOUNT
2)	;TAKE OFF-LINE OUT OF PRFXTB
2)	;MERGE ARNIE'S CHANGES INTO SOURCES:
2)	;<4.MONITOR>GTJFN.MAC.26, 19-Apr-79 14:33:41, EDIT BY MILLER
2)	;<4.MONITOR>GTJFN.MAC.25, 19-Apr-79 14:26:24, EDIT BY MILLER

; GTJFN.MAC.3 & GTJFN.GXJFN.1 19-Apr-88 0111	PAGE 6


2)	;FIX CODE AT DEFDI1 TO CHECK FOR ASTF
2)	;<4.MONITOR>GTJFN.MAC.24, 12-Apr-79 17:20:38, EDIT BY MILLER
2)	;MAKE PARSE ONLY WORK ON DEVICE NAMES
2)	;<4.MONITOR>GTJFN.MAC.23, 21-Mar-79 12:43:16, EDIT BY BOSACK
2)	;ADD MONUMENTS TO NOINTNESS IN CHKDSK AND CNVSIX HEADINGS
2)	;<4.MONITOR>GTJFN.MAC.22, 15-Mar-79 14:25:30, EDIT BY KIRSCHEN
2)	;FIX OKINT FREE SPACE ASSIGN AT STODN1
2)	;<4.MONITOR>GTJFN.MAC.21, 15-Mar-79 13:31:37, EDIT BY DBELL
2)	;TCO 4.2215 - CLEAR THE RIGHT FLAG WHEN DEFAULTING DSK*: AT DEFSDV
2)	;<4.MONITOR>GTJFN.MAC.20,  6-Mar-79 10:13:40, EDIT BY MILLER
2)	;<4.MONITOR>GTJFN.MAC.19,  5-Mar-79 13:15:55, EDIT BY MILLER
2)	;CALL RELMT FROM RELJFN IF JFN IS ON AN MT
2)	;<4.MONITOR>GTJFN.MAC.18,  4-Mar-79 17:24:47, EDIT BY KONEN
2)	;UPDATE COPYRIGHT FOR RELEASE 4
2)	;<4.MONITOR>GTJFN.MAC.17, 19-Feb-79 13:47:28, EDIT BY DBELL
2)	;TCO 4.2193 - MAKE RECOGNITION OF DSK*: WORK PROPERLY AT DFDVTY
2)	;<4.MONITOR>GTJFN.MAC.16, 11-Jan-79 10:30:01, EDIT BY MILLER
2)	;<4.MONITOR>GTJFN.MAC.15, 10-Jan-79 10:36:16, EDIT BY MILLER
2)	;BE SURE TO CLEAR NREC IN ENDEXT
2)	;<4.MONITOR>GTJFN.MAC.14, 19-Dec-78 12:26:36, EDIT BY MILLER
2)	;DON'T ALLOW GTJFN ON MTX: IF DEVICE ASSIGNED TO ANOTHER JOB
2)	;<4.MONITOR>GTJFN.MAC.13, 15-Dec-78 12:51:43, EDIT BY MILLER
2)	;<4.MONITOR>GTJFN.MAC.12, 15-Dec-78 12:50:00, EDIT BY MILLER
2)	;MAKE SURE GNJFN ALWAYS UNLOCKS JFN AND GOES OKINT
2)	;<4.MONITOR>GTJFN.MAC.11,  4-Dec-78 14:46:44, EDIT BY MILLER
2)	;ZERO FILOFN IN ASGJFN
2)	;<4.MONITOR>GTJFN.MAC.10, 23-Nov-78 21:58:14, EDIT BY ZIMA
2)	;TCO 4.2097 - CHECK FOR DISK FILE JFN BEFORE GOING OKINT IN GNJFN
2)	;<4.MONITOR>GTJFN.MAC.9, 16-NOV-78 14:11:46, Edit by KONEN
2)	;ALLOW A PARSE-ONLY JFN FOR A FILE ON AN UNMOUNTED STR
2)	;<KONEN>GTJFN.MAC.3, 31-Jul-78 11:19:46, Edit by KONEN
2)	;DO NOT ALLOW A JFN FOR A FILE ON AN UNMOUNTED STRUCTURE
2)	;INSTALLED ARCHIVE SYSTEM MODIFICATIONS, OFFLINE ATTRIBUTE
2)	;<4.MONITOR>GTJFN.MAC.6, 17-Oct-78 10:00:40, EDIT BY MILLER
2)	;CHANGE ACCESS TO TAPE-ACCESS
2)	;<4.MONITOR>GTJFN.MAC.5, 16-Oct-78 17:40:57, EDIT BY DBELL
2)	;TCO 4.2045 - ACCEPT COMMA AS CONFIRMATION CHAR AFTER RECOGNITION IS DONE
2)	;<4.MONITOR>GTJFN.MAC.4, 13-Oct-78 11:01:56, EDIT BY MILLER
2)	;ADD ACCESS ATTRIBUTE
2)	;<4.MONITOR>GTJFN.MAC.3, 16-Aug-78 16:38:18, EDIT BY ENGEL
2)	;FIX AT ENDAL2 FOR GJ%IFG AND GJ%OFG CASE
2)	;<4.MONITOR>GTJFN.MAC.2,  7-Jul-78 15:14:26, Edit by HEMPHILL
2)	;IF DIRECTORY LOOKUP FAILS IN DEFDI0, STEP STRUCTURE IF ALLOWED
2)	;<4.MONITOR>GTJFN.MAC.1,  7-Jul-78 14;IF DIRECTORY LOOKUP FAILS IN ENDDI0, STEP STRUCTURE IF ALLOWED
2)	


; GTJFN.MAC.3 & GTJFN.GXJFN.1 19-Apr-88 0111	PAGE 7



LINE 13, PAGE 2
1)	
1)	PNCATT==:";"			;PUNCTUATION FOR ATTRIBUTES
LINE 141, PAGE 1
2)	PNCATT==:";"			;PUNCTUATION FOR ATTRIBUTES


LINE 18, PAGE 2
1)	PNCNOD==:":"			;PUNCTUATION FOR NODE (DIGRAPH)
1)	
1)	;GENERAL DEFINITIONS FOR RDTXT PROCESSING
1)	
1)	;OFFSETS IN BLOCK FOR RDTXT
1)	
1)	STRPNT==0			;MAIN STRING POINTER
1)	STRCNT==1			;MAX CHARACTER COUNT
1)	LDPNT==2			;BYTE POINTER FOR ILDB'S
1)	LDCNT==3			;COUNT OF BYTES IN LDPNT STRING
1)	ARGCNT==4			;ARG COUNT FOR TEXT CALL
LINE 145, PAGE 1
2)	
2)	
2)	;THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY ONLY BE USED
2)	;  OR COPIED IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
2)	;
2)	;COPYRIGHT (C) 1976,1977,1978,1979,1980,1981,1982,1983,
2)	;BY DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
2)	
2)	;GENERAL DEFINITIONS FOR RDTXT PROCESSING
2)	
2)	VARC==17			;WORDS OF STACK NEEDED FOR RDTXT STUFF
2)	STRPNT==0			;OFFSET ON STACK FOR MAIN STRING POINTER
2)	STRCNT==1			;OFFSET FOR MAX CHARACTER COUNT
2)	LDPNT==2			;OFFSET FOR BYTE POINTER FOR ILDB'S
2)	LDCNT==3			;OFFSET FOR COUNT OF BYTES IN LDPNT STRING
2)	ARGCNT==4			;ARG COUNT FOR TEXT CALL


LINE 41, PAGE 2
1)	 VARC==17			;WORDS NEEDED FOR RDTXT STUFF
1)	
LINE 173, PAGE 1
2)	


; GTJFN.MAC.3 & GTJFN.GXJFN.1 19-Apr-88 0111	PAGE 8



LINE 47, PAGE 2
1)	IFE NICSW,<
1)	MAXINP==<^D120-VARC>*5		;MAX WORDS TO GET FOR TEXTI
1)	>;IFE NICSW
1)	IFN NICSW,<
1)	MAXINP==:^D10000		;Maximum chars to get for TEXTI%
1)	>;IFN NICSW
1)	DEFINP==MAXINP			;DEFAULT SIZE OF RDTXT BUFFER
1)	LNHDRL==2			;LENGTH OF LOGICAL NAME CHAIN BLOCK HDR
1)	^L
1)	;SPECIAL AC DEFINITIONS USED HEREIN
1)	
1)	DEFAC (TMP,Q1)			;Temporary AC
1)	DEFAC (TXT,Q2)			;POINTER FOR RDTXT
1)	DEFAC (E,Q3)			;POINTER TO USER PARAMETER BLOCK
LINE 178, PAGE 1
2)	MAXINP==<^D120-VARC>*5		;MAX WORDS TO GET FOR TEXTI
2)	DEFINP==MAXINP			;DEFAULT SIZE OF RDTXT BUFFER
2)	LNHDRL==2			;LENGTH OF LOGICAL NAME CHAIN BLOCK HDR
2)	
2)	;SPECIAL AC DEFINITIONS USED HEREIN
2)	
2)	DEFAC (TXT,P6)			;POINTER FOR RDTXT
2)	DEFAC (E,Q3)			;POINTER TO USER PARAMETER BLOCK


LINE 12, PAGE 3
1)	
1)	DEFINE TMSG(M)<
LINE 1, PAGE 2
2)	^L
2)	DEFINE TMSG(M)<


LINE 28, PAGE 3
1)	PBYTSZ::POINT 6,FILBYT(JFN),11	; Points to "s" of file byte pointer
1)	PFLMOD::POINT 4,FILSTS(JFN),35	; MODE OF OPEN
1)	
LINE 17, PAGE 3
2)	PFLMOD::POINT 4,FILSTS(JFN),35	; MODE OF OPEN
2)	PBYTPO::POINT 6,FILBYT(JFN),5	; Points to "p" of file byte pointer
2)	PBYTSZ::POINT 6,FILBYT(JFN),11	; Points to "s" of file byte pointer
2)	
2)	


; GTJFN.MAC.3 & GTJFN.GXJFN.1 19-Apr-88 0111	PAGE 9



LINE 34, PAGE 3
1)	
1)	MSKSTR WLDF,FLAGS(TXT),1B0		; STRING IS A WILD MASK
1)	MSKSTR DWLDF,FLAGS(TXT),1B1		; DEFAULT STRING IS WILD
1)	MSKSTR VERFF,FLAGS(TXT),1B2		;COLLECTING A VERSION
1)	MSKSTR SAWALT,FLAGS(TXT),1B3		;SAW AN ALTMODE WHILE SCANNING
1)	MSKSTR SWBRKT,FLAGS(TXT),1B4		;SAW A SQUARE BRACKET FOR DIRECTORY
1)	MSKSTR SAWCR,FLAGS(TXT),1B5		;SAW A CR
1)	MSKSTR SAWSLN,FLAGS(TXT),1B6		;SAW A SYSTEM LOGICAL NAME
1)	MSKSTR TMPFL,FLAGS(TXT),1B7		;LAST ATTRIBUTE WAS ;T
1)	MSKSTR PREFXF,FLAGS(TXT),1B8		;GATHERING A PREFIX OF AN ATTRIBUTE
1)	MSKSTR ARBATF,FLAGS(TXT),1B9		;GATHERING THE DATA PART OF AN ATTRIBUTE
1)	MSKSTR ATRF,FLAGS(TXT),1B10		;HAVE SEEN AN ATTRIBUTE
1)	MSKSTR RIEFLG,FLAGS(TXT),1B11		;RETURN ON EMPTY FLAG
1)	MSKSTR SAWF,FLAGS(TXT),1B12		;SAW A CONTROL-F
1)	MSKSTR NOLOGF,FLAGS(TXT),1B13		;DON'T USE LOGICAL NAMES
1)	MSKSTR COLNF,FLAGS(TXT),1B14		;LAST CHAR WAS A COLON
1)	MSKSTR CNTVF,FLAGS(TXT),1B15		;CONTROL-V TYPED
1)	^L
LINE 1, PAGE 4
2)	^L


LINE 15, PAGE 4
1)	; .GJGEN	LH(E)	; Flags
1)	;		RH(E)	; Default version
1)	; .GJSRC	LH(E+1)	; Input jfn (377777 means none)
1)	;		RH(E+1)	; Output jfn (377777 means none)
1)	; .GJDEV	E+2	; Default string pointer device
1)	; .GJDIR	E+3	; Default string pointer directory
1)	; .GJNAM	E+4	; Default string pointer name
1)	; .GJEXT	E+5	; Default string pointer extension
1)	; .GJPRO	E+6	; Default string pointer protection
1)	; .GJACT	E+7	; Default string pointer account
1)	; .GJJFN	E+10	; Desired jfn if jfnf=1 (optional)
1)	; .GJF2 	E+11	;ALTERNATE FLAGS,,COUNT (CONTROLLED BY JFNRD)
1)	; .GJCPP	E+12	;RETURN BUFFER ADDRESS
1)	; .GJCPC	E+13	;RETURN BUFFER ADDRESS SIZE IN WORDS
1)	; .GJRTY	E+14	; ^R BUFFER(CONTROLLED BY G1%RBF)
1)	; .GJBFP	E+15	; POINTER TO DESTINATION BUFFER
1)	; .GJATR	E+16	;POINTER TO ARBITRARY ATTRIBUTES BLOCK
1)	; .GJNOD	E+17	; Default string pointer node name
1)	; If a default string pointer is 0, then it is assumed unspecified
LINE 15, PAGE 5
2)	;	LH(E)	; Flags
2)	;	RH(E)	; Default version
2)	;	LH(E+1)	; Input jfn (377777 means none)
2)	;	RH(E+1)	; Output jfn (377777 means none)
2)	;	E+2	; Default string pointer device

; GTJFN.MAC.3 & GTJFN.GXJFN.1 19-Apr-88 0111	PAGE 10


2)	;	E+3	; Default string pointer directory
2)	;	E+4	; Default string pointer name
2)	;	E+5	; Default string pointer extension
2)	;	E+6	; Default string pointer protection
2)	;	E+7	; Default string pointer account
2)	;	E+10	; Desired jfn if jfnf=1 (optional)
2)	;	E+11	;ALTERNATE FLAGS,,COUNT (CONTROLLED BY JFNRD)
2)	;	E+12	;RETURN BUFFER ADDRESS
2)	;	E+13	;RETURN BUFFER ADDRESS SIZE IN WORDS
2)	;	E+14	; ^R BUFFER(CONTROLLED BY G1%RBF)
2)	;	E+15	; POINTER TO DESTINATION BUFFER
2)	;	E+16	;POINTER TO ARBITRARY ATTRIBUTES BLOCK
2)	; If a default string pointer is 0, then it is assumed unspecified


LINE 2, PAGE 6
1)	CCTAB:	CC1(ILLCHR)		; Null
1)		CC1(ILLCHR)		; Control-a
1)		CCN ILLCHR,4		; Control-b to e
1)		CC1(CONTF)		; Control-f
1)		CCN ILLCHR,2		; Control-g & h
1)		CC1(SPACE)		; TAB
1)		CC1(TERMS)		; LF
1)		CC1(ILLCHR)		; Control-k
1)		CC1(TERMS)		;CONTROL-L (FF)
1)		CC1(CARRET)		;CONTROL-M (CR)
1)		CCN ILLCHR,4		; Control-n - q
1)		CC1(CONTR)		; Control-r
1)		CCN ILLCHR,2		; Control-s, t
1)		CC1 (CONTU)		;CONT-U
1)		CC1($QUOT)		; Control-v
1)		CC1(CONTU)		; Control-w
1)		CC1(ILLCHR)		; Control-x
1)		CC1(ILLCHR)		; CONTROL-Y
1)		CC1(TERMS)		;CONTROL-Z
1)		CC1(ALTMOD)		; Alt-mode
1)		CCN ILLCHR,3		; 34-36
1)		CC1(TERMS)		; Eol
1)		CC1(SPACE)		; Space
1)		CCN TERMS,3		; ! " #
1)		CC1(UPPER)		; $
1)		CC1(WILDC)		; %
1)		CC1 (ILLCHR)		; &
1)		CCN TERMS,3		;' ( )
1)		CC1($STAR)		; Asterisk
1)		CC1(TERMS)		; +
1)		CC1(COMMA)		; Comma
1)		CC1(MINUSC)		; -
1)		CC1($DOT)		; Dot
1)		CC1(TERMS)		; Slash
1)		CCN DIGITC,12		; Digits

; GTJFN.MAC.3 & GTJFN.GXJFN.1 19-Apr-88 0111	PAGE 11


1)		CC1($COLON)		; Colon
1)		CC1($SEMIC)		; Semi-colon
1)		CC1($LANG)		; <
1)		CC1(TERMS)		; =
1)		CC1($RANG)		; >
1)		CC1(QBRK)		; ?
1)		CC1(TERMS)		; @
1)		CC1(UPPERA)		; A
1)		CCN UPPER,16		; B - o
1)		CC1(UPPERP)		; P
1)		CCN UPPER,3		; Q - s
1)		CC1(UPPERT)		; T
1)		CCN UPPER,6		; U - z
1)		CC1 ($LANG)		; [
1)		CC1 (ILLCHR)		;\
1)		CC1 ($RANG)		; ]
1)		CC1 (ILLCHR)		; ^
1)		CC1(UPPER)		; _
1)		CC1(ILLCHR)		; Acute accent
1)		CC1(LOWERA)		; Lower case a
1)		CCN LOWER,16		; Lower case b - o
1)		CC1(LOWERP)		; Lower case p
1)		CCN LOWER,3		; Lower case q - s
1)		CC1(LOWERT)		; Lower case t
1)		CCN LOWER,6		; Lower case u - z
1)		CCN ILLCHR,4		; Curly brackets vert bar complement
1)		CC1(CONTU)		; Rubout
1)	
1)		QW
1)	^L
1)	; Character dispatch table
1)	
1)	CHDTB:
1)		PHASE 0			; MAKE OFFSETS RELATIVE TO 0
1)	UPPER::!CALL UCCH		; (0) upper case letter
1)	LOWER::!CALL LCCH		; (1) lower case letter
1)	EDTCHR::!			; EDITING CHARACTERS
1)	CONTU::!ERRLJF GJFX4,<MOVEM A,ERRSAV> ;(2) FOR CONT-U
1)	CONTR::!ERRLJF GJFX4,<MOVEM A,ERRSAV> ;(3) FOR CONT-R
1)	COMMA::!JRST ENDCNF		;(4) COMMA
1)	SPACE::!JRST ENDALL		;(5) SPACE
1)	CONTF::!CALL RECFLF		;(6) CONT-F
1)	TERMS::!JRST ENDCNF		; (7) cr, lf, ff, tab, eol
1)	ALTMOD::!JRST RECALL		; (10) alt-mode
1)	$COLON::!CALL ENDDEV		; (11) colon
1)	$LANG::!CALL BEGDIR		; (12) <
1)	$RANG::!CALL ENDDIR		; (13) >
1)	$DOT::!	CALL ENDNAM		; (14) .
1)	$SEMIC::!CALL ENDEXT		; (15) ;
1)	$QUOT::!CALL QUOTCH		; (16) control-v
1)	ILLCHR::!ERRLJF GJFX4,<MOVEM A,ERRSAV> ; (17) illegal character

; GTJFN.MAC.3 & GTJFN.GXJFN.1 19-Apr-88 0111	PAGE 12


1)	$STAR::!CALL STAR		; (20) asterisk
1)	DIGITC::!CALL DIGIT		; (21) digits
1)	UPPERT::!CALL TCH		; (22) t
1)	UPPERP::!CALL PCH		; (23) p
1)	UPPERA::!CALL ACH		; (24) a
1)	LOWERT::!CALL LCTCH		; (25) lower case t
1)	LOWERP::!CALL LCPCH		; (26) lower case p
1)	LOWERA::!CALL LCACH		; (27) lower case a
1)	MINUSC::!CALL MINUS		; (30) minus sign
1)	$CTRLX::!ERRLJF GJFX4,<MOVEM A,ERRSAV> ; (31) ^X IS AN illegal character
1)	IFE STANSW,<			; [SMXGTJ]
1)	QBRK:!	ERRLJF (GJFX34)		; (32) ?
1)	WILDC:!	CALL QUEST		;(33) WILD CARD CHARACTER
1)	>;IFE STANSW			; [SMXGTJ]
1)	IFN STANSW,<			; [SMXGTJ]
1)	QBRK:!	CALL QUEST		; (32) ?
1)	WILDC:!	CALL PCENT		;(33) WILD CARD CHARACTER
1)	>;IFN STANSW			; [SMXGTJ]
1)	CARRET::!CALL DOCR		; (34) CARRIAGE RETURN
1)	$NODEP::!CALL ENDNOD		; (35) NODE PUNCTUATION
1)		DEPHASE			; END OF ADDRESS RELOCATION
1)	ECHDTB:
1)	^L
1)	;THE JSYS
1)	
1)	;START WITH A LOT OF INITIALIZATION
1)	
1)	.GTJFN::MCENT			; Enter slow code
1)		TRVAR <INFMOD,<INFCOC,2>,BKGCH>
1)			;INFMOD - SAVED RFMOD OF INPUT FILE IF ANY
1)			;INFCOC - SAVED RFCOC OF INPUT FILE IF ANY
1)			;BKGCH - BACKED UP CHARACTER FROM GCH
1)		SETZB TXT,BKGCH		; MARK THAT TXT IS NOT SET UP YET
1)		MOVE E,A		; Set pointer to parameter block
LINE 2, PAGE 7
2)	CCTAB:	CC1(17)			; Null
2)		CC1(17)			; Control-a
2)		CCN 17,4		; Control-b to e
2)		CC1(6)			; Control-f
2)		CCN 17,2		; Control-g & h
2)		CC1(5)			; TAB
2)		CC1(7)			; LF
2)		CC1(17)			; Control-k
2)		CC1(7)			;CONTROL-L (FF)
2)		CC1(34)			;CONTROL-M (CR)
2)		CCN 17,4		; Control-n - q
2)		CC1(3)			; Control-r
2)		CCN 17,2		; Control-s, t
2)		CC1 (2)			;CONT-U
2)		CC1(16)			; Control-v
2)		CC1(2)			; Control-w

; GTJFN.MAC.3 & GTJFN.GXJFN.1 19-Apr-88 0111	PAGE 13


2)		CC1(17)			; Control-x
2)		CC1(17)			; CONTROL-Y
2)		CC1(7)			;CONTROL-Z
2)		CC1(10)			; Alt-mode
2)		CCN 17,3		; 34-36
2)		CC1(7)			; Eol
2)		CC1(5)			; Space
2)		CCN 7,3			; ! " #
2)		CC1(0)			; $
2)		CC1(33)			; %
2)		CC1 (17)		; &
2)		CCN 7,3			;' ( )
2)		CC1(20)			; Asterisk
2)		CC1(7)			; +
2)		CC1(4)			; Comma
2)		CC1(30)			; -
2)		CC1(14)			; Dot
2)		CC1(7)			; Slash
2)		CCN 21,12		; Digits
2)		CC1(11)			; Colon
2)		CC1(15)			; Semi-colon
2)		CC1(12)			; <
2)		CC1(7)			; =
2)		CC1(13)			; >
2)		CC1(32)			; ?
2)		CC1(7)			; @
2)	^L
2)		CC1(24)			; A
2)		CCN 0,16		; B - o
2)		CC1(23)			; P
2)		CCN 0,3			; Q - s
2)		CC1(22)			; T
2)		CCN 0,6			; U - z
2)		CC1 (12)		; [
2)		CC1 (17)		;\
2)		CC1 (13)		; ]
2)		CC1 (17)		; ^
2)		CC1(0)			; _
2)		CC1(17)			; Acute accent
2)		CC1(27)			; Lower case a
2)		CCN 1,16		; Lower case b - o
2)		CC1(26)			; Lower case p
2)		CCN 1,3			; Lower case q - s
2)		CC1(25)			; Lower case t
2)		CCN 1,6			; Lower case u - z
2)		CCN 17,4		; Curly brackets vert bar complement
2)		CC1(2)			; Rubout
2)	
2)		QW
2)	
2)	^L

; GTJFN.MAC.3 & GTJFN.GXJFN.1 19-Apr-88 0111	PAGE 14


2)	.GTJFN::MCENT			; Enter slow code
2)		SETZ TXT,		; MARK THAT TXT IS NOT SET UP YET
2)		MOVE E,A		; Set pointer to parameter block


LINE 16, PAGE 8
1)		XCTU [HLLZ F,.GJGEN(F1)] ; Get flags from user
1)		CAIN F1,1		; Short form? (or doesn't matter case)
LINE 8, PAGE 9
2)		XCTU [HLLZ F,0(F1)]	; Get flags from user
2)		CAIN F1,1		; Short form? (or doesn't matter case)


LINE 22, PAGE 8
1)		TXNE E,GJ%FNS		; Is 2 a pointer
1)		JRST GTJFZ		; No, skip the following
LINE 14, PAGE 9
2)		;TQNE <OSTRF>		;TCO 5.1415 -  IS THIS A PARSE ONLY JFN
2)		;TQO <ASTF>		; YES, SAY SO
2)		TLNE E,2		; Is 2 a pointer
2)		JRST GTJFZ		; No, skip the following


LINE 33, PAGE 8
1)		CALL SETINF		;SETUP FILES IF NECESSARY
1)		TLNN E,777777		; Can't specify jfn if short form
1)		TQNN <JFNF>		; Is user trying to specify jfn?
1)		IFSKP.
1)		  CALL USRJFN		;YES, SET IT UP
1)		ELSE.
1)		  CALL ASGJFN		;GET A FREE JFN
1)		   ERRLJF(GJFX3)	; Jfn not available
1)		ENDIF.
1)		CALL SETSTR		;SET STAR BITS IN STS CORRECTLY
1)		TQNN <JFNRD>		;EXTENDED BLOCK GIVEN?
LINE 27, PAGE 9
2)		CALL INFTST
2)		JRST GTJFZ1
2)		RFCOC
2)		PUSH P,B
2)		PUSH P,C
2)		RFMOD			;GET MODE BITS TOO
2)		TXZ B,TT%OSP		;FORGET OUTPUT SUPPRESS
2)		PUSH P,B		;SAVE THEM
2)		TRZ B,3B29		;CLEAR DATA MODE FIELD
2)		TRO B,17B23+1B29	;SET BREAK ON EVERYTHING
2)		SFMOD			;AND PUT IT IN EFFECT
2)		CALL SFCC0
2)	GTJFZ1:	CALL OTFTST		;CS82B Have output file JFN?
2)		IFSKP.			;CS82B Yes
2)		  RFMOD			;CS82B Get its mode

; GTJFN.MAC.3 & GTJFN.GXJFN.1 19-Apr-88 0111	PAGE 15


2)		  LDB B,[POINTR B,TT%WID] ;CS82B Get terminal width
2)		  SUBI B,1		;CS82B One less, to prevent line wrapping...
2)		  MOVEM B,DRTWD		;CS82B Save it for use in ? typeout
2)		ENDIF.			;CS82B
2)		TLNN E,777777		; Can't specify jfn if short form
2)		TQNN <JFNF>		; Is user trying to specify jfn?
2)		JRST GTJF1		; No.
2)		HRRZ JFN,E
2)		XCTU [SKIPL JFN,10(JFN)]	; Yes, get his version of jfn
2)		CAIL JFN,MJFN
2)		ERRLJF GJFX1,<MOVEM JFN,ERRSAV>
2)		CAIE JFN,.PRIIN		;PRIMARY INPUT?
2)		CAIN JFN,.PRIOU		;NO. PRIMARY OUTPUT?
2)		ERRLJF GJFX1,<MOVEM JFN,ERRSAV> ;YES. CANT SPECIFY THAT JFN
2)	^L
2)	GTJFZ2:	NOINT
2)		LOCK JFNLCK
2)	GTJFZ3:	CAML JFN,MAXJFN		; Above currently available jfn's?
2)		 JRST [	PUSH P,JFN	; Yes, sve this
2)			MOVE JFN,MAXJFN
2)			AOS MAXJFN
2)			IMULI JFN,MLJFN
2)			CALL RELJF2
2)			POP P,JFN
2)			JRST GTJFZ3]
2)		IMULI JFN,MLJFN		;MAKE IT A USEABLE JFN
2)		SKIPN FILSTS(JFN)	; Is this jfn free?
2)		JRST [	JUMPE JFN,.+1	;AND NOT 0?
2)			CALL ASGJF1	; Yes, assign it
2)			JRST GTJF01]
2)		UNLOCK JFNLCK
2)		OKINT
2)		TQNN <JFNAF>
2)		ERRLJF GJFX2,<MOVEM JFN,ERRSAV>
2)	GTJF1:	CALL ASGJFN
2)		ERRLJF(GJFX3)		; Jfn not available
2)	GTJF01:	CALL SETSTR		;SET STAR BITS IN STS CORRECTLY
2)		TQNN <JFNRD>		;EXTENDED BLOCK GIVEN?


LINE 47, PAGE 8
1)		XCTU [TDNE A,.GJF2(D)]	; Want to find invisible files?
1)		 TQO <IGIVF>		; Yes, flag that fact
1)		XCTU [HRRZ A,.GJF2(D)]	;YES. GET SIZE OF EXTENDED BLOCK
1)		CAIGE A,.GJCPC-.GJF2	;IS THERE A COUNT GIVEN?
1)		JRST USDFLT		;NO. GO AROUND THE REST
1)		XCTU [SKIPG B,.GJCPC(D)] ;YES. IS IT NON-ZERO?
1)		MOVEI B,DEFINP		;NO. USE THE DEFAULT
1)		CAIGE A,.GJRTY-.GJF2	;HAVE A ^R BUFFER?
1)		JRST USDFL1		;NO. GO ON THEN
1)		XCTU [SKIPN .GJRTY(D)]	;IS THERE A ^R BUFFER?

; GTJFN.MAC.3 & GTJFN.GXJFN.1 19-Apr-88 0111	PAGE 16


1)		JRST USDFL1		;NO. USE VALUE WE NOW HAVE
LINE 28, PAGE 10
2)		XCTU [TDNE A,11(D)]	; Want to find invisible files?
2)		 TQO <IGIVF>		; Yes, flag that fact
2)		XCTU [HRRZ A,11(D)]	;YES. GET SIZE OF EXTENDED BLOCK
2)		CAIGE A,2		;IS THERE A COUNT GIVEN?
2)		JRST USDFLT		;NO. GO AROUND THE REST
2)		XCTU [SKIPG B,13(D)]	;YES. IS IT NON-ZERO?
2)		MOVEI B,DEFINP		;NO. USE THE DEFAULT
2)		CAIGE A,3		;HAVE A ^R BUFFER?
2)		JRST USDFL1		;NO. GO ON THEN
2)		XCTU [SKIPN 14(D)]	;IS THERE A ^R BUFFER?
2)		JRST USDFL1		;NO. USE VALUE WE NOW HAVE


LINE 62, PAGE 8
1)	
1)	;INITIALIZATION CONTINUES...SETUP BLOCK TO BE USED BY RDTXT FOR INPUT
1)	;EDITING OF TEXT BEFORE WE PARSE IT.  SETUP ^R BUFFERS, ETC.
1)	
1)		CALL SRDTXT		;SETUP RDTXT BLOCK
1)		MOVEM B,STRCNT(TXT)	;SAVE IT
LINE 43, PAGE 10
2)	USDFL2:	PUSH P,B		;SAVE COUNT
2)		IDIVI B,5		;GET NUMBER OF WORDS
2)		SKIPE C			;INTEGRAL NUMBER?
2)		AOS B			;NO. GET ONE MORE WORD FOR THE SLOP
2)		ADDI B,VARC+1		;GET ADDITIONAL WORDS NEEDED
2)		NOINT			;PRESERVE THE SANCTITY OF THE JSB
2)		CALL ASGJFR		;GET SOME SPACE
2)		 JRST [	OKINT		;NOT THERE APPARENTLY
2)			POP P,0(P)	;CLEAN UP THE STACK
2)			ERRLJF (GJFX22)] ;GO COMPLAIN TO THE CALLER
2)		; ..
2)	^L
2)	;GTJFN...
2)	
2)		MOVEI TXT,1(A)		;ESTABLISH ARG REGION
2)		HRLI A,(<POINT 7,0,35>)	;MAKE IT A STRING POINTER
2)		HRLM A,FILLNM(JFN)	;SAVE THE BLOCK ADDRESS FOR RELJFN
2)		OKINT			;GOT IT. ALLOW INTERRUPTS
2)		ADDI A,VARC		;TO BEGINNING OF STRING SPACE
2)		HRRZ B,A
2)		SETZM 1(B)		;INITIALIZE FIRST WORD OF STRING TO NULL
2)		SETZM STRPNT(TXT)	;CLEAR RDTXT INPUT
2)		SETZM FLAGS(TXT)	;CLEAR FLAGS
2)		SETZM STPCNT(TXT)	;CLEAR LOGICAL NAME STEP COUNT
2)		POP P,B			;RESTORE ORIGINAL BYTE COUNT
2)		MOVEM B,STRCNT(TXT)	;SAVE IT


; GTJFN.MAC.3 & GTJFN.GXJFN.1 19-Apr-88 0111	PAGE 17



LINE 72, PAGE 8
1)		UMOVE C,.GJF2(D)	;GET FLAG WORD
1)		MOVX B,NOLOGF		;GET SUPPRESSION OF LOGICAL NAMES BIT
LINE 20, PAGE 11
2)		UMOVE C,11(D)		;GET FLAG WORD
2)		MOVX B,NOLOGF		;GET SUPPRESSION OF LOGICAL NAMES BIT


LINE 77, PAGE 8
1)		CAIL B,.GJRTY-.GJF2	;INCLUDE A ^R BUFFER?
1)		XCTU [SKIPN B,.GJRTY(D)] ;IS IT NON-ZERO?
1)		IFSKP. <
1)		  CALL RTYSET>		;YES, SET IT UP
1)	GJF00:	MOVEM A,STRPNT(TXT)	;SAVE POINTER IN RDTXT AREA
LINE 25, PAGE 11
2)		CAIGE B,3		;INCLUDE A ^R BUFFER?
2)		JRST GJF00		;;NO.
2)		XCTU [SKIPN B,14(D)]	;IS IT NON-ZERO?
2)		JRST GJF00		;NO. GO ON
2)		PUSH P,[0]		;A TEST WORD ON THE STACK
2)		PUSH P,[0]		;AND ANOTHER FOR THE MAIN STRING
2)		MOVX A,RIEFLG		;SEE IF THIS IS A RETURN ON EMPTY CALL
2)		TXNE C,G1%RIE		;...
2)		IORM A,FLAGS(TXT)	;YES, REMEMBER THIS FOR LATER
2)		TXNN C,G1%RBF		;IS ^R BUFFER CONTIGUOUS?
2)		XCTU [SKIPN A,12(D)]	;IS THERE A BUFFER?
2)		JRST GJF01		;NO. GO ON
2)		TLC A,-1		;YES. MAKE IT A GOOD POINTER
2)		TLCN A,-1
2)		HRLI A,(<POINT 7,0>)
2)		IBP A			;AND INCREMENT IT
2)		CALL DBP		;DECREMENT
2)		MOVEM A,0(P)		;SAVE FINAL POINTER
2)	GJF01:	TQNE <STRF>		;HAVE A STRING POINTER?
2)		JRST [	UMOVE A,2	;YES. GET IT
2)			IBP A		;INCREMENT IT
2)			CALL DBP	;AND DECREMENT IT
2)			MOVEM A,-1(P)	;SAVE IT FOR TESTING
2)			JRST .+1]	;AND GO INLINE
2)		HRRZ A,E
2)		UMOVE A,14(A)		;AND GET ^R POINTER
2)		TLC A,-1		;MAKE ^R POINTER VALID
2)		TLCN A,-1
2)		HRLI A,(<POINT 7,0>)
2)		IBP A			;INCREMENT IT
2)		CALL DBP		;AND DECREMENT IT
2)		MOVE B,A		;AND PUT IT IN B
2)		MOVE D,STRCNT(TXT)	;MAX BYTE COUNT
2)		MOVE A,ARGCR(TXT)	;GET BACK MAIN POINTER

; GTJFN.MAC.3 & GTJFN.GXJFN.1 19-Apr-88 0111	PAGE 18


2)	;**;[2625] Add 2 lines at GTJTP:-1L	PED	9-JUN-82
2)		TQNE <STRF>		;[2625] FROM A STRING IN MEMORY?
2)		JRST GTJ02		;[2625] YES - NO CTRL/R BUFFER
2)	GTJTP:	CAME B,-1(P)		;SAME AS MAIN POINTER?
2)		CAMN B,0(P)		;AT THE END
2)		JRST GTJ02		;YES
2)		XCTBU [ILDB C,B]	;GET A BYTE
2)		JUMPE C,GTJ02		;NULL ENDS BUFFER
2)		SOSGE D			;MAKE SURE THIS ONE FITS
2)		ERRLJF (GJFX51)		;IT DOESN'T
2)		IDPB C,A		;COPY INTO MONITOR BUFFER
2)		JRST GTJTP		;GO DO MORE
2)	GTJ02:	HRRZM D,STRCNT(TXT)	;BYTE SIZE
2)		SUB P,BHC+2		;CLEAN UP THE STACK
2)	GJF00:	MOVEM A,STRPNT(TXT)	;SAVE POINTER IN RDTXT AREA


LINE 86, PAGE 8
1)		XCTU [HRRZ C,.GJF2(D)]	;GET COUNT
1)		CAIGE C,.GJRTY-.GJF2	;HAVE A ^R POINTER?
1)		JRST GTJF12		;NO. GO ON THEN
1)		XCTU [SKIPE .GJRTY(D)]	;IS ^R BUFFER NON-ZERO?
1)		XCTU [SKIPN C,.GJCPC(D)] ;YES. IS COUNT NON-ZERO?
1)		JRST GTJF12		;NO. NO TRIMMING THEN
LINE 78, PAGE 11
2)		XCTU [HRRZ C,11(D)]	;GET COUNT
2)		CAIGE C,3		;HAVE A ^R POINTER?
2)		JRST GTJF12		;NO. GO ON THEN
2)		XCTU [SKIPE 14(D)]	;IS ^R BUFFER NON-ZERO?
2)		XCTU [SKIPN C,13(D)]	;YES. IS COUNT NON-ZERO?
2)		JRST GTJF12		;NO. NO TRIMMING THEN


LINE 109, PAGE 8
1)		; ..
1)	
1)	; ****
1)	;END OF SETUP OF RDTXT STUFF
1)	; ****
1)	^L
1)	;DO SOME REAL GTJFN WORK - I.E., GET AND PARSE CHARACTERS
1)	
1)	GTJF0:	CALL SETTMP		; Set up temporary string block
LINE 101, PAGE 11
2)	GTJF0:	CALL SETTMP		; Set up temporary string block


; GTJFN.MAC.3 & GTJFN.GXJFN.1 19-Apr-88 0111	PAGE 19



LINE 8, PAGE 9
1)	GTJF22:	MOVE B,STRPNT(TXT)	;THE START OF IT ALL
LINE 105, PAGE 11
2)	;..
2)	^L
2)	GTJF22:	MOVE B,STRPNT(TXT)	;THE START OF IT ALL


LINE 25, PAGE 9
1)		 ERJMPR ERRDO		;ERR CODE TO A AND ERROR
1)		HRRZ C,ARGDC(TXT)
1)		HLL C,ARGFLG(TXT)	;GET THE FLAGS
1)		TXNE C,RD%BTM		;FOUND A REAL BREAK CHARACTER?
1)		IFSKP.
1)		  TRNN C,-1		;NO, COUNT EXHAUSTED?
1)		  ERRLJF GJFX51		;YES. BOMB HIM OUT
1)		  HLRZ A,ARGJFN(TXT)
1)		  GTSTS			; SEE IF IT WAS AN EOF
1)		  TXNE B,GS%EOF		; IS IT?
1)		  ERRLJF (IOX4)		;YES. GO TELL HIM
1)		  TQNE <JFNRD>		;NO. ALTERNATE FLAG WORD?
1)		  CALL [HRRZ D,E
1)			UMOVE D,.GJF2(D) ;YES. GET IT
1)			TXNE D,G1%RND	;DOES HE WANT CONTROL BACK?
1)			ERRLJF(GJFX37)	;YES. HE WANT IT BACK
1)			RET]		;GO BACK
1)		  BKJFN
1)		   JFCL			;TO GET THE BREAK
1)		  BIN			;GET IT
1)		  CAIN B,"R"-100	;^R?
1)		  JRST [CALL RETYPE 	;YES. DO IT
1)			JRST GTJF22] 	;AND DONE
1)		  CALL DING		;NO. DING AT HIM
1)		  JRST GTJF22		;AND DONE
1)		ENDIF.
1)		LDB B,ARGDST(TXT)	;LOOK AT THE TERMINATOR
LINE 19, PAGE 12
2)		 ERJMP [MOVE T1,LSTERR	;TRAP ERRORS (ERRLJF NOT GOOD ENOUGH)
2)			JRST ERRDO]	; AND EXIT WITH ERROR, RELEASING JFN
2)		HRRZ C,ARGDC(TXT)
2)		HLL C,ARGFLG(TXT)	;GET THE FLAGS
2)		TXNN C,RD%BTM	;FOUND A REAL BREAK CHARACTER?
2)		JRST [	TRNN C,-1	;COUNT EXHAUSTED?
2)			ERRLJF GJFX51	;YES. BOMB HIM OUT
2)			HLRZ A,ARGJFN(TXT)
2)			GTSTS		; SEE IF IT WAS AN EOF
2)			TXNE B,GS%EOF	; IS IT?
2)			ERRLJF (IOX4)	;YES. GO TELL HIM
2)			TQNE <JFNRD>	;NO. ALTERNATE FLAG WORD?

; GTJFN.MAC.3 & GTJFN.GXJFN.1 19-Apr-88 0111	PAGE 20


2)			CALL [	HRRZ D,E
2)				UMOVE D,11(D) ;YES. GET IT
2)				TXNE D,G1%RND ;DOES HE WANT CONTROL BACK?
2)				ERRLJF(GJFX37) ;YES. HE WANT IT BACK
2)				RET]		;GO BACK
2)			BKJFN
2)			 JFCL		;TO GET THE BREAK
2)			BIN		;GET IT
2)			CAIN B,"R"-100	;^R?
2)			JRST [	CALL RETYPE ;YES. DO IT
2)				JRST GTJF22] ;AND DONE
2)			CALL DING	;NO. DING AT HIM
2)			JRST GTJF22]	;AND DONE
2)		LDB B,ARGDST(TXT)	;LOOK AT THE TERMINATOR


LINE 10, PAGE 10
1)	GTJF2:	SKIPE A,BKGCH		;BACKED UP CHAR?
1)		IFSKP.
1)		  CALL GCH		; NO, Get next character
1)		   JRST GTJF23		;NO MORE
1)		ELSE.
1)		  SETZM BKGCH		;CLEAR LOCAL CHAR BFR
1)		ENDIF.
1)		TMNE <CNTVF>		; Control-v pending?
1)		JRST [	SETZRO CNTVF
1)			CALL UCCH	; Yes, ignore any special meanings
1)			 JRST ERRDO	;ERROR DURING HANDLING OF THIS CHAR
1)			JRST GTJF2]
1)		MOVX B,SAWCR		;SEE IF JUST SAW A CR
1)		TDNN B,FLAGS(TXT)	;DID WE?
1)		IFSKP.
1)		  ANDCAM B,FLAGS(TXT) 	;YES. TURN OFF BIT
1)		  CAIE A,.CHLFD		;IS THIS A LINE FEED?
1)		  ERRLJF(GJFX4)		;NO. ILLEGAL CHARACTER THEN
1)		ENDIF.
1)		IFQN. COLNF		;PREV CHAR WAS COLON?
1)		  SETZRO COLNF		;YES, NOW HAVE
1)		  CAIE A,PNCNOD		; NODE PUNCTUATION?
1)		  IFSKP.
1)		    TQNN <ASTF>		;YES. PARSE ONLY ?
1)	            ERRLJF(GJFX55)	;NO. ILLEGAL.
1)		    MOVEI B,$NODEP	;YES, FAKE USUAL DISPATCH
1)		  ELSE.
1)		    MOVEM A,BKGCH	;NO, SAVE THIS CHAR
1)		    MOVEI B,$COLON	;HANDLE SINGLE COLON
1)		  ENDIF.
1)		ELSE.
1)		  CAIE A,PNCNOD		;POSSIBLE NODE DIGRAPH?
1)		  IFSKP.
1)		    SETONE COLNF	;YES, MUST SEE WHAT FOLLOWS

; GTJFN.MAC.3 & GTJFN.GXJFN.1 19-Apr-88 0111	PAGE 21


1)		    JRST GTJF2
1)		  ENDIF.
1)		  MOVE B,A
1)		  IDIVI B,^D36/CCSIZE	;Prepare to get character class
1)		  LDB B,CPTAB(C)	;Get character class
1)		  CAIL B,ECHDTB-CHDTB
1)		  ERRLJF GJFX4,<MOVEM A,ERRSAV>
1)		ENDIF.
1)	GTJF21:	XCT CHDTB(B)		; Execute the dispatch table
1)		 SKIPN A		; IF NON-ZERO, THEN ERROR
LINE 10, PAGE 13
2)	GTJF2:	CALL GCH		; Get next character
2)	GTJF23:	 JRST [	JUMPN A,ERRDO	; IF A NON-ZERO, ERROR
2)			MOVE A,FLAGS(TXT)
2)			TXNE A,RIEFLG	;RETURN ON EMPTY?
2)			ERRLJF GJFX48	;YES, DO NOT GO READ FROM JFNS
2)			CALL INFTST	; SEE IF MORE TO COME FROM TTY
2)			 JRST  ENDALL	;NO. GO END THE INPUT SEQUENCE
2)			CALL CLRJFN	;CLEAR THE JFN BLOCK AND THE FLAGS
2)			CALL SETTMP	;GET ANOTHER WORK AREA
2)			 JRST ERRDO	;ERROR IN SETTMP
2)			JRST MRTEXT]	;GO CONTINUE COLLECTING TTY INPUT
2)		TQZE <CNTVF>		; Control-v pending?
2)		JRST [	CALL UCCH	; Yes, ignore any special meanings
2)			 JRST ERRDO	;ERROR DURING HANDLING OF THIS CHAR
2)			JRST GTJF2]
2)		MOVX B,SAWCR		;SEE IF JUST SAW A CR
2)		TDNE B,FLAGS(TXT)	;DID WE?
2)		JRST [	ANDCAM B,FLAGS(TXT) ;YES. TURN OFF BIT
2)			CAIE A,.CHLFD	;IS THIS A LINE FEED?
2)			ERRLJF(GJFX4)	;NO. ILLEGAL CHARACTER THEN
2)			JRST .+1]	;YES. GO USE IT
2)		MOVE B,A
2)		IDIVI B,^D36/CCSIZE	; Prepare to get character class
2)		LDB B,CPTAB(C)		; Get character class
2)		CAIL B,ECHDTB-CHDTB
2)		ERRLJF GJFX4,<MOVEM A,ERRSAV>
2)		XCT CHDTB(B)		; Execute the dispatch table
2)		 SKIPN A		; IF NON-ZERO, THEN ERROR


LINE 59, PAGE 10
1)	
1)	;MAIN STRING EXHAUSTED
1)	
1)	GTJF23:	JUMPN A,ERRDO		; IF A NON-ZERO, ERROR
1)		IFQN. COLNF		;COLON LAST SEEN?
1)		  SETZRO COLNF		;YES, CLEAR IT
1)		  MOVEI B,$COLON
1)		  JRST GTJF21		;HANDLE IT
1)		ENDIF.

; GTJFN.MAC.3 & GTJFN.GXJFN.1 19-Apr-88 0111	PAGE 22


1)		MOVE A,FLAGS(TXT)
1)		TXNE A,RIEFLG		;RETURN ON EMPTY?
1)		ERRLJF GJFX48		;YES, DO NOT GO READ FROM JFNS
1)		CALL INFTST		; SEE IF MORE TO COME FROM TTY
1)		 JRST ENDALL		;NO. GO END THE INPUT SEQUENCE
1)		CALL CLRJFN		;CLEAR THE JFN BLOCK AND THE FLAGS
1)		CALL SETTMP		;GET ANOTHER WORK AREA
1)		 JRST ERRDO		;ERROR IN SETTMP
1)		JRST MRTEXT		;GO CONTINUE COLLECTING TTY INPUT
1)	^L
1)	;QUOTE CHARACTER
1)	
1)	QUOTCH:	SETONE CNTVF		;SET FLAG FOR NEXT CHAR
1)		RETSKP
1)	
LINE 1, PAGE 14
2)	^L
2)	; Character dispatch table
2)	
2)	CHDTB:
2)		PHASE 0			; MAKE OFFSETS RELATIVE TO 0
2)	UPPER:!	CALL UCCH		; (0) upper case letter
2)	LOWER:!	CALL LCCH		; (1) lower case letter
2)	EDTCHR:!			; EDITING CHARACTERS
2)	CONTU:!	ERRLJF GJFX4,<MOVEM A,ERRSAV> ;(2) FOR CONT-U
2)	CONTR:!	ERRLJF GJFX4,<MOVEM A,ERRSAV> ;(3) FOR CONT-R
2)	COMMA:!	JRST ENDCNF		;(4) COMMA
2)	SPACE:!	JRST ENDALL		;(5) SPACE
2)	CONTF:!	CALL RECFLF		;(6) CONT-F
2)	TERMS:!	JRST ENDCNF		; (7) cr, lf, ff, tab, eol
2)	ALTMOD:!JRST RECALL		; (10) alt-mode
2)		CALL ENDDEV		; (11) colon
2)		CALL BEGDIR		; (12) <
2)		CALL ENDDIR		; (13) >
2)		CALL ENDNAM		; (14) .
2)		CALL ENDEXT		; (15) ;
2)		TQOA <CNTVF>		; (16) control-v
2)	ILLCHR:!ERRLJF GJFX4,<MOVEM A,ERRSAV> ; (17) illegal character
2)		CALL STAR		; (20) asterisk
2)	DIGITC:!CALL DIGIT		; (21) digits
2)	UPPERT:!CALL TCH		; (22) t
2)	UPPERP:!CALL PCH		; (23) p
2)	UPPERA:!CALL ACH		; (24) a
2)	LOWERT:!CALL LCTCH		; (25) lower case t
2)	LOWERP:!CALL LCPCH		; (26) lower case p
2)	LOWERA:!CALL LCACH		; (27) lower case a
2)	MINUSC:!CALL MINUS		; (30) minus sign
2)		ERRLJF GJFX4,<MOVEM A,ERRSAV> ; (31) ^X IS AN illegal character
2)	QBRK:!	CALL QUEST		;CS82 [SMXGTJ] (32) ?
2)	WILDC:!	CALL PCENT		;CS82 [SMXGTJ] (33) WILD CARD CHARACTER
2)	CARRET:!CALL DOCR		; (34) CARRIAGE RETURN

; GTJFN.MAC.3 & GTJFN.GXJFN.1 19-Apr-88 0111	PAGE 23


2)		DEPHASE			; END OF ADDRESS RELOCATION
2)	ECHDTB:
2)	^L
2)	; Continuation of gtjfn code
2)	


LINE 44, PAGE 11
1)	LTR:	TQNN <STARF>		;SAW STAR?
1)		IFSKP.
1)		  MOVX B,WLDF		;YES, SET WILD BIT IN FLAGS
1)		  IORM B,FLAGS(TXT)
1)		ENDIF.
1)		MOVX B,PREFXF		;SEE IF THIS IS THE FIRST CHAR OF
LINE 41, PAGE 16
2)	LTR:	TQNE <STARF>
2)		JRST [	MOVX B,WLDF	;SET WILD BIT IN FLAGS
2)			IORM B,FLAGS(TXT)
2)			JRST .+1]	; AND GO INLINE
2)		MOVX B,PREFXF		;SEE IF THIS IS THE FIRST CHAR OF


LINE 1, PAGE 12
1)	^L
1)	LTR1:	TQZE <KEYFF>		; A PREFIX OF AN ATTRIBUTE
LINE 51, PAGE 16
2)	LTR1:	TQZE <KEYFF>		; A PREFIX OF AN ATTRIBUTE


LINE 30, PAGE 14
1)	
1)	; Minus sign
LINE 1, PAGE 18
2)	^L
2)	; Minus sign


LINE 2, PAGE 15
1)	;NODE NAME TERMINATOR (::)
1)	
1)	ENDNOD:	TQNN DIRFF
1)		TQNE <DEVF,DIRF,NAMF,EXTF> ;MUST BE THE FIRST FIELD
1)		RETBAD GJFX54
1)		CALL ENDSTX		;TERMINATE STRING
1)		CALL ENDTMP		;SAVE THE STRING
1)		STOR A,FLNOD,(JFN)
1)		CALL ENDNDX		;LOOK UP NODE NAME & SETUP JFN BLOCK
1)		 RETBAD()		;ERROR, RETURN
1)		CALLRET SETTMP		;RESET TEMP BLOCK & RETURN
1)	
1)	;DEFAULT THE NODE NAME IF GIVEN

; GTJFN.MAC.3 & GTJFN.GXJFN.1 19-Apr-88 0111	PAGE 24


1)	
1)	DEFNOD:	CALL GLNNOD		;SEE IF DEFAULT FROM LOGICAL NAME
1)		IFNSK.
1)		  JUMPN A,R		;NO, QUIT IF HARD ERROR
1)	;**;[7298] Change 1 line at DEFNOD:+3	MDR	22-MAY-86
1)		  TXNN E,-1B17		;[7298] Have JFN block?
1)		  TQNN JFNRD		;EXTENDED JFN BLOCK?
1)		  RETSKP		;NO, DEFAULT NODE NOT PROVIDED
1)	;**;[7298] Add 3 lines at DEFNOD:+6	MDR	22-MAY-86
1)		  XCTU [HRRZ A,.GJF2(E)];[7298] Get count in extended GTJFN block
1)		  CAIE A,.GJNOD-.GJF2	;[7298] Is there a word there for .GJNOD?
1)		  RETSKP		;[7298] No, so let's return quietly
1)		  HRRZ D,E
1)		  XCTU [SKIPN A,.GJNOD(D)] ;SEE IF STRING HERE
1)	 	  RETSKP		;NO
1)		  CALL REDFLT		;YES, COPY IT
1)		   RETBAD
1)		ENDIF.
1)		NOINT
1)		LOAD A,FLTSD,(JFN)	;GET TEMP STRING
1)		SETZRO FLTSD,(JFN)
1)		STOR A,FLNOD,(JFN)	;SAVE IT AS NODE
1)	ENDNDX:	TQNN <JFNRD>		;Long form GTJFN ?
1)		IFSKP.
1)		  BLOCK.		;yes. this block exits +1 on error, +2 on
1)					; success
1)		    SAVEAC <A,B>	;grab ACs
1)		    MOVX A,G1%LOC	;is local
1)		    HRRZ B,E		; files only
1)		    XCTU [TDNE A,.GJF2(B)] ;  flag set ?
1)		    RET			;yes. exit block with error
1)		    RETSKP		;no. exit block success
1)		  ENDBK.
1)		  RETBAD (GJFX6)	;return the error that we used to.
1)		ENDIF.
1)		CALL NODLUK		;SEE IF A VALID NODE NAME
1)		 RETBAD ()    		;NOT VALID, PASS ALONG ERROR MESSAGE
1)		OKINT			;MATCH ENDTMP
1)		SETONE NODEF		;HAVE A NODE NOW
1)		MOVEI B,NFTIDX		;IMPLIES DEVICE NFT
1)		STOR B,FLDVX,(JFN)	;SAVE DEVICE INDEX
1)		HRRZ DEV,DEVDSP(B)	;SET UP FILDEV - RH IS DEVICE DISPATCH
1)		HRLI DEV,-1		; LH IS -1, MEANS DEVICE HAS NO UNITS
1)		MOVEM DEV,FILDEV(JFN)
1)		SETONE FLLNK,(JFN)	;initialize link index
1)		RETSKP
1)	^L
1)	; Device name terminator (:)
LINE 2, PAGE 20
2)	; Device name terminator (:)


; GTJFN.MAC.3 & GTJFN.GXJFN.1 19-Apr-88 0111	PAGE 25



LINE 26, PAGE 16
1)	ENDDV2:	TQNE <DIRFF>		;DIRECTORY ALREADY SPECIFIED?
1)		RETBAD(GJFX6)		;YES, LOSE
1)		TQOE <DEVF>
1)		RETBAD (GJFX6)		; Device already specified (syntax)
1)		TQNE NODEF		;HAVE SEEN NODE?
1)		IFSKP.
1)		  CALL DEFNOD		;NO, TRY FOR DEFAULT
1)		   RET			;SOME KIND OF HARD FAILURE
1)		ENDIF.
1)		CALL ENDSTX		; Terminate string, get lookup pointer
1)		MOVEM T1,ENDDVS		;SAVE STRING POINTER
1)		TQZE <STARF>		; WAS A STAR OF SOME SORT TYPED?
1)		JRST ENDSDV		; YES
1)		TQNE NODEF		;HAVE NODE NOW?
1)		JRST ENDDV0		;YES
1)		CALL CHKLNM		; GO SEE IF THIS IS A LOGICAL NAME
1)		 JRST ENDDV3		;NO, GO LOOK UP DEVICE
1)		TQZ <DEVF>		; TURN OFF DEVICE FLAG SET FROM ABOVE
LINE 26, PAGE 20
2)	ENDDV2:	TQNE <DIRFF>
2)		RETBAD(GJFX6)
2)		TQOE <DEVF>
2)		RETBAD (GJFX6)		; Device already specified (syntax)
2)		CALL ENDSTR		; Terminate string, get lookup pointer
2)		MOVEM A,ENDDVS		; SAVE STRING POINTER FOR LATER
2)		TQZE <STARF>		; WAS A STAR OF SOME SORT TYPED?
2)		JRST ENDSDV		; YES
2)		CALL CHKLNM		; GO SEE IF THIS IS A LOGICAL NAME
2)		 JRST [	MOVE A,ENDDVS	;IF NO LOG NAME, GO LOOK UP DEVICE
2)			JRST ENDDV0]
2)		TQZ <DEVF>		; TURN OFF DEVICE FLAG SET FROM ABOVE


LINE 49, PAGE 16
1)		CALL LNKLGJ		;ADD THIS LOGICAL NAME TO CHAIN
1)		 JRST [	OKINT
LINE 43, PAGE 20
2)		CALL LNKLNM		;ADD THIS LOGICAL NAME TO CHAIN
2)		 JRST [	OKINT


; GTJFN.MAC.3 & GTJFN.GXJFN.1 19-Apr-88 0111	PAGE 26



LINE 1, PAGE 17
1)	^L
1)	ENDDV3:	MOVE T1,ENDDVS		;RESTORE STRING POINTER
1)	ENDDV0:	CALL SETDEV		; SET UP DEVICE INFORMATION
LINE 48, PAGE 20
2)	
2)	ENDDV0:	CALL SETDEV		; SET UP DEVICE INFORMATION


LINE 13, PAGE 18
1)	ENDSDV:
1)	IFN STANSW,<			; [SMXGTJ]
1)		TQNN <ASTAF,OSTRF>	; STARS ALLOWED?
1)		 RETBAD (GJFX31)	; NO. GIVE BAD RETURN
1)	>;IFN STANSW			; [SMXGTJ]
1)		CALL STRDEV		; SET UP FIRST STR IN LIST
1)		 RETBAD ()		; ILLEGAL USE OF STAR
1)		MOVEM T1,ENDDVS		; SAVE POSSIBLY ALTERED BLOCK POINTER
1)		JRST ENDDV0		; GO SET UP THIS STR
LINE 59, PAGE 20
2)	
2)	ENDSDV:	TQNN <ASTAF,OSTRF>	;CS82 [SMXGTJ] Stars allowed?
2)		 RETBAD (GJFX31)	;CS82 [SMXGTJ] No. Give bad return
2)		CALL STRDEV		; SET UP FIRST STR IN LIST
2)		 RETBAD ()		; ILLEGAL USE OF STAR
2)		JRST ENDDV0		; GO SET UP THIS STR


LINE 26, PAGE 18
1)	
1)	;ROUTINE TO CHECK THE SYNTAX OF STARED DEVICE FIELD
LINE 1, PAGE 21
2)	^L
2)	;ROUTINE TO CHECK THE SYNTAX OF STARED DEVICE FIELD


LINE 33, PAGE 18
1)	STRDVD:	TRVAR <DEFFLG>
1)		SETOM DEFFLG		;FLAG THAT WE'RE DEFAULTING
1)		MOVE B,[DWLDF]		;GET ONE TYPE OF WILD FLAG
1)		JRST STRDE1		;JOIN COMMON CODE
1)	STRDEV:	TRVAR <DEFFLG>
1)		SETZM DEFFLG		;NOT DEFAULTING
1)		MOVX B,WLDF		;OR ANOTHER TYPE
1)	STRDE1:	STKVAR <LPTR,DPTR>	;TEMPS FOR DSK*
1)		ANDCAM B,FLAGS(TXT)	;CLEAR IT
LINE 8, PAGE 22
2)	STRDVD:	SKIPA B,[DWLDF]		;GET ONE TYPE OF WILD FLAG
2)	STRDEV:	MOVX B,WLDF		;OR ANOTHER TYPE

; GTJFN.MAC.3 & GTJFN.GXJFN.1 19-Apr-88 0111	PAGE 27


2)		ANDCAM B,FLAGS(TXT)	;CLEAR IT


LINE 45, PAGE 18
1)		NOINT			;MAKE SURE ASGFRE DOES NOT GET UPSET
1)		CALL GNJFN3		;MAKE SURE WE HAVE AN UNTRIMMED BLOCK
1)		 RETBAD (,<OKINT>)     	;FROM THE JSB,  PASS DOWN FREE SPACE ERROR 
1)		OKINT
1)		MOVX T2,<POINT 7,>	;GET BYTE POINTER LEFT HALF
1)		HRRI T2,1(T1)		;GET THE ADDRESS OF THE BLOCK
1)		MOVEM T2,DPTR		;SAVE THE TARGET POINTER
1)		MOVX T2,<POINT 6,>	;GET SIXBIT BYTE POINTER
1)		HRR T2,STRTAB+PSNUM	;GET ADR OF SDB FOR PS
1)		MOVEM T2,LPTR		;SAVE THE SOURCE POINTER
1)		MOVEI T3,6		;SIX CHARACTERS
1)	STRDE9:				;SIXBIT TO ASCII LOOP
1)		ILDB T2,LPTR		;GET A BYTE
1)		SKIPN T2		;NULL?
1)		 JRST STRD10		;YES
1)		ADDI T2,40		;CONVERT TO ASCII
1)		IDPB T2,DPTR		;STORE THE ASCII
1)		SOJG T3,STRDE9		;LOOP FOR ALL SIX CHARS OR UNTIL NULL
1)	STRD10:				;HERE WHEN ALL CHARS CONVERTED
1)		SETZ T2,		;GET A NULL BYTE
1)		IDPB T2,DPTR		;SAVE THE NULL BYTE
1)		MOVEI T2,2(T1)		;DETERMINE A REASONABLE END OF THE BLOCK
1)		SKIPN DEFFLG		;SET FILOPT IF NOT DEFAULTING
1)		 HRRM T2,FILOPT(JFN)	;MAKE SURE THIS BLOCK DOES NOT GET OVERTRIMMED
1)		TQO <STRSF,STEPF>	;REMEMBER THAT THE DEVICE FIELD IS *
LINE 14, PAGE 22
2)		MOVE B,[ASCIZ/PS/]	;START AT STRUCTURE 0
2)		MOVEM B,1(A)		;STORE NEW STRING OVER OLD ONE
2)		TQO <STRSF,STEPF>	;REMEMBER THAT THE DEVICE FIELD IS *


LINE 1, PAGE 20
1)	^L
1)	; Directory terminator (>)
LINE 21, PAGE 23
2)	
2)	; Directory terminator (>)


; GTJFN.MAC.3 & GTJFN.GXJFN.1 19-Apr-88 0111	PAGE 28



LINE 17, PAGE 21
1)		CALL ENDSTX		; Terminate string, get lookup pointer
1)		BLCAL. MDDOK,<<FILDEV(JFN)>> ;A MULTIPLE DIR DEVICE?
1)		IFSKP.
1)		  TQNE <ASTF>		;YES, DOING PARSE ONLY?
1)		ANSKP.
1)		  LOAD B,FLUC,(JFN)	;GET STRUCTURE CODE
1)		  CALL DIRLKX		;NO, Lookup directory (no recognition)
1)		   JRST ENDDI1		; Failed
1)		  STOR A,FLDNO,(JFN)	; Save directory number
1)		ELSE.
1)		  SETZRO FLDNO,(JFN)	; NO DIRECTORY NUMBER
1)		ENDIF.
1)		CALL ENDTMP		; TIE OFF THE DIRECTORY NAME STRING
1)		STOR A,FLDIR,(JFN)	; SAVE IT IN THE JFN BLOCK
1)		OKINT			; UNLOCK SINCE ENDTMP LEFT THINGS LOCKED
LINE 37, PAGE 23
2)		CALL ENDSTR		; Terminate string, get lookup pointer
2)		HRRZ B,FILDEV(JFN)	;SEE IF THIS IS A DISK
2)		CAIN B,DSKDTB		;IF NOT, DONT CALL DIRLKX
2)		TQNE <ASTF>		;DOING PARSE ONLY?
2)		JRST ENDDI2		;YES. DO IT THEN
2)		LOAD B,FILUC,(JFN)	; GET STRUCTURE NUMBER
2)		CALL DIRLKX		; Lookup directory (no recognition)
2)		 JRST ENDDI1		; Failed
2)		HRRM A,FILDDN(JFN)	; Save directory number
2)		CALL ENDTMP		; TIE OFF THE DIRECTORY NAME STRING
2)		STOR A,FILDIR,(JFN)	; SAVE IT IN THE JFN BLOCK
2)		OKINT			; UNLOCK SINCE ENDTMP LEFT THINGS LOCKED


LINE 37, PAGE 21
1)	STRDIR:
1)	IFN STANSW,<			; [SMXGTJ]
1)		TQNN <ASTAF,OSTRF>	; STARS ALLOWED?
1)		 RETBAD (GJFX31)	; NO. GIVE BAD RETURN
1)	>;IFN STANSW			; [SMXGTJ]
1)		MOVE A,FLAGS(TXT)	; SEE IF A WILD MASK
LINE 54, PAGE 23
2)	STRDIR:	TQNN <ASTAF,OSTRF>	;CS82 [SMXGTJ] Stars allowed?
2)		 RETBAD (GJFX31)	;CS82 [SMXGTJ] No. Give bad return
2)		MOVE A,FLAGS(TXT)	; SEE IF A WILD MASK


; GTJFN.MAC.3 & GTJFN.GXJFN.1 19-Apr-88 0111	PAGE 29



LINE 50, PAGE 21
1)		STOR A,FLDMS,(JFN)	; STORE MASK
1)		OKINT			; ALLOW INTS AGAIN
LINE 64, PAGE 23
2)		STOR A,FILDMS,(JFN)	; STORE MASK
2)		OKINT			; ALLOW INTS AGAIN


LINE 55, PAGE 21
1)		 RETBAD GJFX17		;NO SUCH DIRECTORY
1)		TQO <DIRTF>		;REMEMBER SEEN A DIRECTORY
LINE 69, PAGE 23
2)		 MOVEI A,GJFX17		;NO SUCH DIRECTORY
2)		 RETBAD()		;GIVE IT UP
2)		TQO <DIRTF>		;REMEMBER SEEN A DIRECTORY


LINE 1, PAGE 22
1)	^L
1)	;HERE IF DIRECTORY LOOKUP FAILED
LINE 75, PAGE 23
2)	
2)	;HERE IF DIRECTORY LOOKUP FAILED


LINE 10, PAGE 23
1)		STOR A,FLDIR,(JFN)	; Store the pointer
1)		OKINT			; Allow ints which were disallowed in ENDTMP
LINE 84, PAGE 23
2)		STOR A,FILDIR,(JFN)	; Store the pointer
2)		OKINT			; Allow ints which were disallowed in ENDTMP


LINE 1, PAGE 24
1)	^L
LINE 89, PAGE 23
2)	
2)	;HERE IF NON-DIRECTORY DEVICE OR SCAN ONLY
2)	
2)	ENDDI2:	CALL ENDTMP		; FINISH OFF THE STRING
2)		HLLZS FILDDN(JFN)	; NO DIRECTORY NUMBER
2)		STOR A,FILDIR,(JFN)	; STORE THE POINTER TO DIRECTORY STRING
2)		OKINT			; ALLOW INTS
2)		JRST ENDDI3		; AND GO FINISH UP
2)	^L


; GTJFN.MAC.3 & GTJFN.GXJFN.1 19-Apr-88 0111	PAGE 30



LINE 19, PAGE 25
1)	
1)	;ENTER HERE FROM RECALL
1)	
1)	ENDNA3:	TQO <NAMF>		; NO WE HAVE A NAME
1)		TQNE <DIRF>		; Do we have a directory yet?
1)		IFSKP.
1)		CALL DEFDIR		; No. default it
1)		 JUMPN A,R		; RETURN IF FATAL ERROR
1)		ENDIF.
1)		TQZE <STARF>
1)		JRST STARNM
1)		CALL ENDSTX		; Terminate string, get lookup pointer
1)		CALL NAMLKX		; Look up name without recognition
1)		 JRST STEPLN		; NO SUCH NAME, GO STEP LOGICAL NAME
1)		MOVEM A,FILFDB(JFN)	; REMEMBER THE FDB ADDRESS
LINE 19, PAGE 24
2)	ENDNA3:	TQO <NAMF>		; NO WE HAVE A NAME
2)		TQNE <DIRF>		; Do we have a directory yet?
2)		JRST ENDNA0		; YES, GO USE ITK
2)		CALL DEFDIR		; No. default it
2)		 JUMPN A,R		; RETURN IF FATAL ERROR
2)	ENDNA0:	TQZE <STARF>
2)		JRST STARNM
2)		CALL ENDSTR		; Terminate string, get lookup pointer
2)		CALL NAMLKX		; Look up name without recognition
2)		 JRST STEPLN		; NO SUCH NAME, GO STEP LOGICAL NAME
2)		 RETBAD 		; AMBIGUOUS NAME
2)		MOVEM A,FILFDB(JFN)	; REMEMBER THE FDB ADDRESS


LINE 1, PAGE 26
1)	^L
1)	STARNM:	
1)	IFN STANSW,<			; [SMXGTJ]
1)		TQNN <ASTAF,OSTRF>	; STARS ALLOWED?
1)		 RETBAD (GJFX31)	; NO. GIVE BAD RETURN
1)	>;IFN STANSW			; [SMXGTJ]
1)		MOVE A,FLAGS(TXT)	; SEE IF A WILD MASK
LINE 36, PAGE 24
2)	
2)	STARNM:	TQNN <ASTAF,OSTRF>	;CS82 [SMXGTJ] Stars allowed?
2)		 RETBAD (GJFX31)	;CS82 [SMXGTJ] No. Give bad return
2)		MOVE A,FLAGS(TXT)	; SEE IF A WILD MASK


; GTJFN.MAC.3 & GTJFN.GXJFN.1 19-Apr-88 0111	PAGE 31



LINE 15, PAGE 27
1)		STOR A,FLNMS,(JFN)	; PUT IN MASK POINTER
1)		OKINT			; ALLOW INTS AGAIN
LINE 47, PAGE 24
2)		STOR A,FILNMS,(JFN)	; PUT IN MASK POINTER
2)		OKINT			; ALLOW INTS AGAIN


LINE 25, PAGE 27
1)		MOVEM A,FILFDB(JFN)	; REMEMBER THE FDB ADDRESS
LINE 57, PAGE 24
2)		 RETBAD			;AMBIGUOUS NAME
2)		MOVEM A,FILFDB(JFN)	; REMEMBER THE FDB ADDRESS


LINE 16, PAGE 28
1)	
1)	;ENTER HERE FROM RECALL
1)	
1)	ENDEX8:	TQO <KEYFF>		; NEXT SCAN WILL LOOK FOR KEY LETTERS
LINE 16, PAGE 25
2)	ENDEX8:	TQO <KEYFF>		; NEXT SCAN WILL LOOK FOR KEY LETTERS


LINE 30, PAGE 28
1)	
1)	ENDEX7:	TQOE <EXTF>		; Do we have an extension yet?
LINE 27, PAGE 25
2)	ENDEX7:	TQOE <EXTF>		; Do we have an extension yet?


LINE 38, PAGE 28
1)		CALL ENDSTX		; No, terminate, get lookup pointer
1)		CALL EXTLKX		; Lookup extension without recognition
1)		 JRST STEPLN		; NO SUCH EXT, GO STEP LOGICAL NAME
1)		MOVEM A,FILFDB(JFN)	; REMEMBER THE FDB ADDRESS
LINE 34, PAGE 25
2)		CALL ENDSTR		; No, terminate, get lookup pointer
2)		CALL EXTLKX		; Lookup extension without recognition
2)		 JRST STEPLN		; NO SUCH EXT, GO STEP LOGICAL NAME
2)		 RETBAD			; AMBIGUOUS EXT
2)		MOVEM A,FILFDB(JFN)	; REMEMBER THE FDB ADDRESS


; GTJFN.MAC.3 & GTJFN.GXJFN.1 19-Apr-88 0111	PAGE 32



LINE 61, PAGE 28
1)	STREXT:
1)	IFN STANSW,<			; [SMXGTJ]
1)		TQNN <ASTAF,OSTRF>	; STARS ALLOWED?
1)		 RETBAD (GJFX31)	; NO. GIVE BAD RETURN
1)	>;IFN STANSW			; [SMXGTJ]
1)		MOVE A,FLAGS(TXT)	; SEE IF A WILD MASK
LINE 58, PAGE 25
2)	STREXT:	TQNN <ASTAF,OSTRF>	;CS82 [SMXGTJ] Stars allowed?
2)		 RETBAD (GJFX31)	;CS82 [SMXGTJ] No. Give bad return
2)		MOVE A,FLAGS(TXT)	; SEE IF A WILD MASK


LINE 74, PAGE 28
1)		STOR A,FLEMS,(JFN)	; STORE MASK STRING
1)		OKINT			; ALLOW INTS AGAIN
LINE 68, PAGE 25
2)		STOR A,FILEMS,(JFN)	; STORE MASK STRING
2)		OKINT			; ALLOW INTS AGAIN


LINE 84, PAGE 28
1)		MOVEM A,FILFDB(JFN)	; REMEMBER THE FDB ADDRESS
LINE 78, PAGE 25
2)		 RETBAD			; AMBIGUOUS
2)		MOVEM A,FILFDB(JFN)	; REMEMBER THE FDB ADDRESS


LINE 91, PAGE 28
1)	
1)	ENDEX2:	TQZN <ACTFF>		; Were we collecting an account
1)		JRST ENDEX5		; No
1)	ENDEXA:	CALL ENDSTX		; Account is a string
1)		CALL ENDTMP
1)		MOVEM A,FILACT(JFN)	; Save positive account block pointer
1)		OKINT
1)		TQNE <VERF>		; HAVE A VERSION YET?
1)		IFSKP.
1)		  CALL DEFVER		; NO, GO GET ONE
1)		   RETBAD ()	; FAILED
1)		ENDIF.
1)		CALL CHKACT		; SEE IF THE ACCOUNT STRING MATCHES
LINE 1, PAGE 26
2)	^L
2)	ENDEX2:	TQZN <ACTFF>		; Were we collecting an account
2)		JRST ENDEX5		; No
2)	ENDEXA:	CALL ENDSTR		; Account is a string
2)		CALL ENDTMP
2)		MOVEM A,FILACT(JFN)	; Save positive account block pointer

; GTJFN.MAC.3 & GTJFN.GXJFN.1 19-Apr-88 0111	PAGE 33


2)		OKINT
2)		TQNN <VERF>		; HAVE A VERSION YET?
2)		JRST [	CALL DEFVER	; NO, GO GET ONE
2)			 RETBAD ()	; FAILED
2)			JRST .+1]	; HAVE A VERSION, CAN NOW CHECK ACCOUNT
2)		CALL CHKACT		; SEE IF THE ACCOUNT STRING MATCHES


LINE 118, PAGE 28
1)		IFNSK.
1)		  ANDCAM B,FLAGS(TXT) 	;CLEAR ;T FLAG
1)		  MOVE A,CNTWRD(TXT)
1)		  SUB A,FILCNT(JFN)
1)		  JUMPE A,[CALLRET SETTMP] ;IF NULL FIELD, THEN OK
1)		  CAIE A,1		;EXACTLY ONE CHAR ("T")?
1)		  RETBAD (GJFX40)	;NO. SYNTAX ERROR THEN
1)		  TQO <TMPFF>		;MARK THAT A TEMP FILE IS BEING MADE
1)		  CALLRET SETTMP	;SET UP FOR NEXT ATTRIBUTE
1)		ENDIF.
1)		TQNN <NUMFF>		; Was a number input?
LINE 27, PAGE 27
2)		JRST [	ANDCAM B,FLAGS(TXT) ;CLEAR ;T FLAG
2)			MOVE A,CNTWRD(TXT)
2)			SUB A,FILCNT(JFN)
2)			JUMPE A,[CALLRET SETTMP] ;IF NULL FIELD, THEN OK
2)			CAIE A,1	;EXACTLY ONE CHAR ("T")?
2)			RETBAD (GJFX40)	;NO. SYNTAX ERROR THEN
2)			TQO <TMPFF>	;MARK THAT A TEMP FILE IS BEING MADE
2)			CALLRET SETTMP]	;SET UP FOR NEXT ATTRIBUTE
2)		TQNN <NUMFF>		; Was a number input?


LINE 138, PAGE 28
1)		IFSKP. <		;IS OKAY
1)		  RETBAD (GJFX20)>		;VERSION # IS TOO BIG
1)		CAMN A,[-1]
LINE 45, PAGE 27
2)		SKIPA			;IS OKAY
2)		RETBAD (GJFX20)		;VERSION # IS TOO BIG
2)		CAMN A,[-1]


LINE 146, PAGE 28
1)	IFE STANSW,<
1)	STRVR1:	CALL VERLUK		; Lookup this version
1)		 JRST STEPLN		; GO TRY TO STEP LOGICAL NAME
1)		HRRM A,FILVER(JFN)
1)		MOVEM B,FILFDB(JFN)	; REMEMBER THE FDB ADDRESS
1)		TQO <VERTF>		; Remember that version was input
1)	>;IFE STANSW
1)	IFN STANSW,<			; [SMXGTJ]

; GTJFN.MAC.3 & GTJFN.GXJFN.1 19-Apr-88 0111	PAGE 34


1)	STRVR1:	CALL GTVER		; LOOKUP THIS VERSION (AND CHECK ACCESS)
1)		 JRST STEPLN		; GO TRY TO STEP LOGICAL NAME
1)	>;IFN STANSW			; [SMXGTJ]
1)	IFN STANSW,<			;[CWR] THIS SHOULD PROBABLY BE A BUG FIX, 
1)		MOVX B,VERFF		;[CWR]   AS WE'RE NO LONGER LOOKING FOR A VERSION
1)		ANDCAM B,FLAGS(TXT)	;[CWR]   AFTER WE'VE SAID WE'VE GOTTEN ONE
1)	>;IFN STANSW
1)		JRST ENDEX0
1)	
1)	STRVER:
1)	IFN STANSW,<			; [SMXGTJ]
1)		TQNN <ASTAF,OSTRF>	; STARS ALLOWED?
1)		 RETBAD (GJFX31)	; NO. GIVE BAD RETURN
1)	>;IFN STANSW			; [SMXGTJ]
1)		TQO <VERSF,STEPF>
LINE 53, PAGE 27
2)	STRVR1:	CALL GTVER		;CS82 [SMXGTJ] Lookup this version (and check access)
2)		 JRST STEPLN		; GO TRY TO STEP LOGICAL NAME
2)	;	HRRM A,FILVER(JFN)	;CS82 [SMXGTJ] Bookkeeping done by GTVER
2)	;	MOVEM B,FILFDB(JFN)	;CS82 [SMXGTJ] REMEMBER THE FDB ADDRESS
2)	;	TQO <VERTF>		;CS82 [SMXGTJ] Remember that version was input
2)		JRST ENDEX0
2)	^L
2)	STRVER:	TQNN <ASTAF,OSTRF>	;CS82 [SMXGTJ] Stars allowed?
2)		 RETBAD (GJFX31)	;CS82 [SMXGTJ] No. Give bad return
2)		TQO <VERSF,STEPF>


LINE 1, PAGE 29
1)	^L
1)	;END OF A PREFIX
LINE 9, PAGE 28
2)	
2)	;END OF A PREFIX


LINE 17, PAGE 30
1)		CALL ENDSTX		;TIE OFF THE STRING
1)		HRRZS A			;GET THE ADR OF THE STRING BLOCK
1)		LOAD B,PFXVAL		;GET THE PREFIX VALUE
1)		HRRZ C,DEV		;GET DISPATCH ADDRESS ONLY
1)		SKIPN C			;IS THERE A DEVICE?
1)		RETBAD (GJFX40)		;NO. INVALID ATTRIBUTES
1)		CALL @ATRD(C)		;CHECK ITS LEGALITY
LINE 25, PAGE 28
2)		CALL ENDSTR		;TIE OFF THE STRING
2)		HRRZS A			;GET THE ADR OF THE STRING BLOCK
2)		LOAD B,PFXVAL		;GET THE PREFIX VALUE
2)		HRRZ C,DEV		;GET DISPATCH ADDRESS ONLY
2)	;**;[3050] Add 2 lines at ENDARB:+14L	TAM	6-DEC-83
2)		SKIPN C			;[3050] IS THERE ONE?

; GTJFN.MAC.3 & GTJFN.GXJFN.1 19-Apr-88 0111	PAGE 35


2)		RETBAD (GJFX40)		;[3050] NO - ERROR
2)		CALL @ATRD(C)		;CHECK ITS LEGALITY


LINE 6, PAGE 31
1)		CALL ENDSTX		;TIE OFF THE STRING
1)		HRLI A,(POINT 7,0,35)	;GET POINTER TO THE PREFIX
LINE 6, PAGE 29
2)		CALL ENDSTR		;TIE OFF THE STRING
2)		HRLI A,(POINT 7,0,35)	;GET POINTER TO THE PREFIX


LINE 11, PAGE 31
1)		 ERJMPR [RETBAD ()]	;ERROR CODE TO T1 AND RETURN FAIL
1)		TXNN B,TL%ABR!TL%EXM	;FOUND A MATCH?
LINE 11, PAGE 29
2)		 ERJMP [MOVE A,LSTERR	;FAILED, GET THE ERROR CODE
2)			RETBAD ()]	;AND GIVE THE FAILURE RETURN
2)		TXNN B,TL%ABR!TL%EXM	;FOUND A MATCH?


LINE 34, PAGE 31
1)	IFN STANSW,<
1)		[ASCIZ/DUMP-PENDING/],,.PFPND	;[CWR] DUMP-PENDING FDB
1)	>;IFN STANSW
1)		[ASCIZ/EXPIRATION-DATE/],,.PFEXP ;MAGTAPE EXPRIATION DATE
1)		[ASCIZ/FOREIGN-HOST/],,.PFTFH ;TCP FOREIGN HOST
LINE 35, PAGE 29
2)		[ASCIZ/EXPIRATION-DATE/],,.PFEXP ;MAGTAPE EXPRIATION DATE
2)		[ASCIZ/FLAGS/],,.PFFLG	;[BBN] Flags (e.g., TCP)
2)		[ASCIZ/FOREIGN-HOST/],,.PFTFH ;TCP FOREIGN HOST


LINE 42, PAGE 31
1)	IFN STANSW,<
1)		[ASCIZ/INCREMENTAL/],,.PFINC	;[CWR]
1)	>;IFN STANSW
1)		[ASCIZ/LOCAL-HOST/],,.PFTLH ;TCP LOCAL HOST NUMBER
LINE 41, PAGE 29
2)		[ASCIZ/LOCAL-HOST/],,.PFTLH ;TCP LOCAL HOST NUMBER


LINE 53, PAGE 31
1)	IFN STANSW,<
1)		[ASCIZ/SINCE/],,.PFSNC		;[CWR]
1)		[ASCIZ/SUMMARY/],,.PFSUM	;[CWR]
1)	>;IFN STANSW
1)		[ASCIZ /TAPE-ACCESS/],,.PFACC ;ACCESS CODE ON MT DEVICE
LINE 49, PAGE 29
2)		[ASCIZ /TAPE-ACCESS/],,.PFACC ;ACCESS CODE ON MT DEVICE


; GTJFN.MAC.3 & GTJFN.GXJFN.1 19-Apr-88 0111	PAGE 36



LINE 12, PAGE 32
1)		TQNE NODEF		;HAVE NODE?
1)		IFSKP.
1)		  CALL DEFNOD		;NO, TRY FOR DEFAULT
1)		   RET			;HARD ERROR
1)		ENDIF.
1)		CALL GLNDEV		; GET LOGICAL NAME DEFAULT
1)		IFSKP. <
1)		  JRST DEFDV0>		; GO USE THIS ONE
1)		JUMPN A,R		; IF ERROR, RETURN IMMEDIATELY
LINE 12, PAGE 30
2)		CALL GLNDEV		; GET LOGICAL NAME DEFAULT
2)		 SKIPA			; NONE EXISTS
2)		JRST DEFDV0		; GO USE THIS ONE
2)		JUMPN A,R		; IF ERROR, RETURN IMMEDIATELY


LINE 28, PAGE 32
1)		XCTU [SKIPN A,.GJDEV(D)] ; Get user's default pointer
1)		JRST DEFDV1		; None specified, use dsk
LINE 23, PAGE 30
2)		XCTU [SKIPN A,2(D)]	; Get user's default pointer
2)		JRST DEFDV1		; None specified, use dsk


LINE 35, PAGE 32
1)		STOR A,FLTSD,(JFN)	;IN CASE STRDVD CHANGED IT
1)		TQNE NODEF		;HAVE NODE NOW?
1)		IFSKP.
1)		  CALL CHKLNM		;NO, SEE IF THIS DEFAULT IS A LOGICAL NAME
1)		   SKIPA A,DEFDVS	;NO, GET BACK STRING POINTER
1)		  JRST DFDVL0		; YES, LOOP BACK AND TRY FOR A DEVICE
1)		ENDIF.
1)		CALL SETDEV		; SET UP DEVICE INFORMATION
1)		IFNSK.			;No such device
1)		  CAIN A,STRX09		;STRUCTURE MOUNT ERROR?
1)		  MOVEI A,GJFX24	;YES, RETURN MORE CORRECT ERROR CODE
1)		  JRST STEPLN		;Step logical name
1)		ENDIF.			
1)		NOINT
1)		LOAD A,FLTSD,(JFN)
1)		SETZRO FLTSD,(JFN)
1)		CALL CHKDSK		; SEE IF THIS IS "DSK:"
LINE 30, PAGE 30
2)		CALL CHKLNM		; SEE IF THIS DEFAULT IS A LOGICAL NAME
2)		 SKIPA A,DEFDVS		;NO, GET BACK STRING POINTER
2)		JRST DFDVL0		; YES, LOOP BACK AND TRY FOR A DEVICE
2)		CALL SETDEV		; SET UP DEVICE INFORMATION
2)		 JRST STEPLN		; NO SUCH DEVICE

; GTJFN.MAC.3 & GTJFN.GXJFN.1 19-Apr-88 0111	PAGE 37


2)		NOINT
2)		HLRZ A,FILTMP(JFN)
2)		HRRZS FILTMP(JFN)
2)		CALL CHKDSK		; SEE IF THIS IS "DSK:"


LINE 56, PAGE 32
1)		CALLRET DFDVTY		;IF DOING RECOGNITION, TYPE OUT DEV NAM
LINE 43, PAGE 30
2)		HRRZ B,FILLNM(JFN)	;SEE IF THERE IS A LOGICAL NAME
2)		JUMPN B,RFALSE		;IF YES, DONT TYPE ANYTHING OUT
2)		CALLRET DFDVTY		;IF DOING RECOGNITION, TYPE OUT DEV NAM


LINE 27, PAGE 33
1)		LOAD A,FLTSD,(JFN)	;GET POINTER TO DEFAULT STRING
1)		SETZRO FLTSD,(JFN)	;CLEAR POINTER TO LN STRING IN FILTMP
1)		JRST DFDVL2		;GO STORE LOGICAL NAME
LINE 27, PAGE 31
2)		HLRZ A,FILTMP(JFN)	;GET POINTER TO DEFAULT STRING
2)		HRRZS FILTMP(JFN)	;CLEAR POINTER TO LN STRING IN FILTMP
2)		JRST DFDVL2		;GO STORE LOGICAL NAME


LINE 36, PAGE 33
1)	  REPEAT 0,<			;NEVER WANT TO TYPE DEFAULTED DEVICE FIELD
1)		MOVE B,1(A)		;GET FIRST WORD OF STRING
1)		TRZ B,677		;CLEAR OUT POSSIBLE GARBAGE BITS
1)		CAME B,[ASCIZ/DSK/]	;IS THE NAME "DSK"?
1)		 CALL DFDVTY		;NO, THEN GO TYPE IT MAYBE
1)		JFCL			;DFDVTY SKIPS SOMETIMES
1)		MOVE A,DEFDVS		;GET BACK POINTER TO STRING
1)		MOVE B,DEFDVI		;GET BACK INDEX
1)	  >				;END REPEAT 0
1)		MOVEI C,FILLNM(JFN)	;GET ADDRESS OF CHAIN HEADER WORD
1)		MOVE D,STPCNT(TXT)	;GET CURRENT STEP COUNTER
1)		CALL LNKLGJ		;ADD THIS LOGICAL NAME TO CHAIN
1)		 JRST [	OKINT
LINE 36, PAGE 31
2)	;**;[2945]  Delete 7 lines at DFDVL2:+2		DML	6-APR-83
2)	;[2945]	MOVE B,1(A)		;GET FIRST WORD OF STRING
2)	;[2945]	TRZ B,677		;CLEAR OUT POSSIBLE GARBAGE BITS
2)	;[2945]	CAME B,[ASCIZ/DSK/]	;IS THE NAME "DSK"?
2)	;[2945]	 CALL DFDVTY		;NO, THEN GO TYPE IT MAYBE
2)	;[2945]	JFCL			;DFDVTY SKIPS SOMETIMES
2)	;[2945]	MOVE A,DEFDVS		;GET BACK POINTER TO STRING
2)	;[2945]	MOVE B,DEFDVI		;GET BACK INDEX
2)		MOVEI C,FILLNM(JFN)	;GET ADDRESS OF CHAIN HEADER WORD
2)		MOVE D,STPCNT(TXT)	;GET CURRENT STEP COUNTER
2)		CALL LNKLNM		;ADD THIS LOGICAL NAME TO CHAIN
2)		 JRST [	OKINT

; GTJFN.MAC.3 & GTJFN.GXJFN.1 19-Apr-88 0111	PAGE 38




LINE 52, PAGE 33
1)		IFSKP. <
1)		  JRST DEFDV0>		;GO CHECK THIS ONE OUT
1)		JUMPN A,R		; IF ERROR, RETURN IMMEDIATELY
LINE 51, PAGE 31
2)		 SKIPA			;THERE WASNT ONE
2)		JRST DEFDV0		;GO CHECK THIS ONE OUT
2)		JUMPN A,R		; IF ERROR, RETURN IMMEDIATELY


LINE 9, PAGE 35
1)		TQNE NODEF		; HAVE SEEN NODE?
1)		RETSKP			; YES, DEVICE FIELD NOT CHECKED
1)		MOVEM A,SETDVT		; SAVE POINTER TO STRING
LINE 9, PAGE 33
2)		MOVEM A,SETDVT		; SAVE POINTER TO STRING


LINE 17, PAGE 35
1)		IFSKP.
1)		  MOVEI A,GJFX38	; CANNOT GET OLD FILE ON OUTPUT ONLY DEV
1)		  JRST STEPLN		; GO SEE IF LOGICAL NAME CAN BE STEPPED
1)		ENDIF.
1)		HRRM B,FILIDX(JFN)	; STORE INDEX INTO DEVICE TABLES
LINE 15, PAGE 33
2)		SKIPA			; YES, ALL IS OK
2)		JRST [	MOVEI A,GJFX38	; CANNOT GET OLD FILE ON OUTPUT ONLY DEV
2)			JRST STEPLN]	; GO SEE IF LOGICAL NAME CAN BE STEPPED
2)		HRRM B,FILIDX(JFN)	; STORE INDEX INTO DEVICE TABLES


LINE 26, PAGE 35
1)		IFSKP.
1)		  CALL DEVAV		;YES. CHECK IF AVAILABLE
1)		   RETBAD (OPNX7)	;NOT. GIVE ERROR THEN
1)		ENDIF.
1)		BLCAL. DSKOK,<DEV>	;SEE IF DISK
1)		 RETSKP			;ISN'T
1)		HLRZ B,DEV		;GET UNIT # (MAY BE STR #)
1)		CAIN B,-1		;YES - SPECIFIC STRUCTURE?
1)		RETSKP			;NO, ALL DONE
1)		STOR C,FLUC,(JFN)	;STORE UNIQUE CODE IN JFN BLOCK
1)		SETZ B,			;THIS JSB IS MAPPED
LINE 23, PAGE 33
2)		SKIPA			;DON'T DO DEVAV
2)		JRST [	CALL DEVAV	;YES. CHECK IF AVAILABLE
2)			 RETBAD (OPNX7)	;NOT. GIVE ERROR THEN
2)			JRST .+1]	;IT IS. PROCEED
2)		HLRZ B,DEV		;GET UNIT # (MAY BE STR #)

; GTJFN.MAC.3 & GTJFN.GXJFN.1 19-Apr-88 0111	PAGE 39


2)		CAIN D,DSKDTB		;IS THIS A DISK DEVICE?
2)		CAIN B,-1		;YES - SPECIFIC STRUCTURE?
2)		RETSKP			;NO, ALL DONE
2)		STOR C,FILUC,(JFN)	;STORE UNIQUE CODE IN JFN BLOCK
2)		SETZ B,			;THIS JSB IS MAPPED


LINE 48, PAGE 35
1)			STOR C,FLUC,(JFN) ;CLEAR UNIQUE CODE
1)			MOVEM C,FILDEV(JFN) ;CLEAR DEVICE
LINE 44, PAGE 33
2)			STOR C,FILUC,(JFN) ;CLEAR UNIQUE CODE
2)			MOVEM C,FILDEV(JFN) ;CLEAR DEVICE


LINE 55, PAGE 35
1)	;NO SUCH DEVICE
1)	
1)	SETDV1:	TQNE <ASTF>		; PARSE ONLY?
LINE 51, PAGE 33
2)	SETDV1:	TQNE <ASTF>		; PARSE ONLY?


LINE 11, PAGE 36
1)	CHKDSK:	TLC DEV,-1		;LH IS -1?
1)		TLCE DEV,-1
1)		RETSKP			;NO, ALREADY HAVE SPECIFIC STR
1)		STKVAR <CHKDSN>		;SAVE NAME POINTER
1)		MOVEM A,CHKDSN
1)		BLCAL. DSKOK,<DEV>	;SEE IF REAL DISK
1)		 RETSKP			;ISN'T
1)		MOVE B,FLAGS(TXT)	;GET FLAGS INTO B
1)		TXNE B,NOLOGF		;ARE WE EXPANDING LOGICAL NAMES?
1)	;	CALL CHKLN1		;TCO 6.1810;IF NOT, IS DSK: DEFINED?
1)		SKIPA			;TCO 6.1810 NEVER EXPAND IF NOLOGF
1)		JRST CHKDS1		;NOLOGF CLEAR OR DSK: NOT DEFINED, TRANSLATE
LINE 11, PAGE 34
2)	CHKDSK:	CAME DEV,[-1,,DSKDTB]	;IS THIS "DSK"?
2)		RETSKP			;NO, NO CHANGE NEEDED
2)		STKVAR <CHKDSN>		;SAVE NAME POINTER
2)		MOVEM A,CHKDSN
2)		MOVE B,FLAGS(TXT)	;GET FLAGS INTO B
2)		TXNE B,NOLOGF		;ARE WE EXPANDING LOGICAL NAMES?
2)		CALL CHKLN1		;IF NOT, IS DSK: DEFINED?
2)		JRST CHKDS1		;NOLOGF CLEAR OR DSK: NOT DEFINED, TRANSLATE


; GTJFN.MAC.3 & GTJFN.GXJFN.1 19-Apr-88 0111	PAGE 40



LINE 26, PAGE 36
1)		STOR A,FLUC,(JFN)	;PUT THIS IN THE JFN BLOCK
1)		CALL CNVSTR		;CONVERT
LINE 22, PAGE 34
2)		STOR A,FILUC,(JFN)	;PUT THIS IN THE JFN BLOCK
2)		CALL CNVSTR		;CONVERT


LINE 1, PAGE 37
1)	^L
1)	;ROUTINE TO CHANGE THE DEVICE NAME TO THE CORRECT NAME FROM DEVTAB
LINE 30, PAGE 34
2)	
2)	;ROUTINE TO CHANGE THE DEVICE NAME TO THE CORRECT NAME FROM DEVTAB


LINE 10, PAGE 38
1)		CAIL B,3		;LARGE ENOUGH FOR STRUCTURE NAME?
1)		IFSKP.
1)		  HRRZ B,A		;NO, RETURN THIS STRING
1)		  MOVEI A,JSBFRE
1)		  CALL RELFRE
1)		  MOVEI B,3		;NOW GET A NEW STRING
1)		  CALL ASGJFR		;TO HOLD STR NAME
1)		   RETBAD (GJFX32)
1)		ENDIF.
1)		HLRZ C,FILDEV(JFN)	;GET STRUCTURE UNIT NUMBER
LINE 39, PAGE 34
2)		CAIGE B,3		;LARGE ENOUGH FOR STRUCTURE NAME?
2)		JRST [	HRRZ B,A	;NO, RETURN THIS STRING
2)			MOVEI A,JSBFRE
2)			CALL RELFRE
2)			MOVEI B,3	;NOW GET A NEW STRING
2)			CALL ASGJFR	;TO HOLD STR NAME
2)			 RETBAD (GJFX32)
2)			JRST .+1]
2)		HLRZ C,FILDEV(JFN)	;GET STRUCTURE UNIT NUMBER


LINE 25, PAGE 39
1)	CHKLN2:	TQNE <PHYOF>		;Is this physical only?
1)		JRST CHKLN3		;YES, ONLY LOOK A SYSTEM LOGICAL NAMES
LINE 25, PAGE 35
2)	CHKLN2:	MOVX A,SAWSLN		;HAVE WE SEEN A SYSTEM LOGICAL NAME YET?
2)		TDNN A,FLAGS(TXT)	;...
2)		TQNE <PHYOF>		;OR IS THIS PHYSICAL ONLY?
2)		JRST CHKLN3		;YES, ONLY LOOK A SYSTEM LOGICAL NAMES


; GTJFN.MAC.3 & GTJFN.GXJFN.1 19-Apr-88 0111	PAGE 41



LINE 11, PAGE 41
1)	;LNKLGJ - LOCAL VARIENT FOR GTJFN, SETS FLAGS
1)	
1)	LNKLGJ:	IFG. B			;SYSTEM LN?
1)		  SETONE SAWSLN		;YES, NOTE HAVE SEEN IT
1)		ENDIF.
1)		;..			;FALL INTO COMMON ROUTINE
1)	
1)	LNKLNM::STKVAR <LNKLNP,LNKLNI,LNKLNC,LNKLNS>
1)		HRRZM C,LNKLNC		;SAVE ADDRESS OF CHAIN HEADER
1)		JUMPL B,LNKLN1		;IF B = -1, DONT ADD THIS TO CHAIN
LINE 11, PAGE 37
2)	LNKLNM::STKVAR <LNKLNP,LNKLNI,LNKLNC,LNKLNS>
2)		HRRZM C,LNKLNC		;SAVE ADDRESS OF CHAIN HEADER
2)		MOVX C,SAWSLN		;SET UP TO MARK SAWSLN
2)		SKIPLE B		;IS THIS A SYSTEM LN?
2)		IORM C,FLAGS(TXT)	;YES, REMEMBER WE HAVE SEEN IT
2)		JUMPL B,LNKLN1		;IF B = -1, DONT ADD THIS TO CHAIN


LINE 16, PAGE 42
1)		IFSKP. <
1)		  JRST DEFDI0>		; YES, USE IT
1)		JUMPN A,R		; IF ERROR, RETURN IMMEDIATELY
1)		HRRZ A,E
1)		TLNN E,777777		; No default if short form
1)		XCTU [SKIPN A,.GJDIR(A)] ; Get default pointer
1)		JRST DEFDI1		; None specified
LINE 16, PAGE 38
2)		 SKIPA			; NO
2)		JRST DEFDI0		; YES, USE IT
2)		JUMPN A,R		; IF ERROR, RETURN IMMEDIATELY
2)		HRRZ A,E
2)		TLNN E,777777		; No default if short form
2)		XCTU [SKIPN A,3(A)]	; Get default pointer
2)		JRST DEFDI1		; None specified


LINE 27, PAGE 42
1)		BLCAL. MDDOK,<<FILDEV(JFN)>> ;A MULTIPLE DIR DEVICE?
1)		 JRST DEFDI3		;NO
1)		LOAD B,FLUC,(JFN)	;GET STRUCTURE NUMBER
1)		CALL DIRLKX		; Look it up
LINE 27, PAGE 38
2)		HRRZ B,FILDEV(JFN)	;SEE IF THIS IS A DISK
2)		CAIE B,DSKDTB		;IF NOT, DONT CALL DIRLKX
2)		JRST DEFDI3		;NOT A DISK
2)		LOAD B,FILUC,(JFN)	;GET STRUCTURE NUMBER
2)		CALL DIRLKX		; Look it up

; GTJFN.MAC.3 & GTJFN.GXJFN.1 19-Apr-88 0111	PAGE 42




LINE 34, PAGE 42
1)		LOAD B,FLUC,(JFN)	;GET THE UNIQUE CODE OF THIS STR
1)		HRLZS B			;BUILD A STR/DIR NUMBER
1)		HRR B,FILDDN(JFN)	;GET DEFAULT AGAIN
1)		CAMN A,B		;IS THIS THE SAME AS THE DEFAULT?
1)		IFSKP.
1)		  CALL DEFDIT		;NO, THEN TYPE OUT DIR NAME IF DOING RECOGNITION
1)		  IFSKP. <AOS 0(P)>	;DO SKIP RETURN
1)		ENDIF.
1)	DEFDI3:	NOINT
1)		LOAD B,FLTSD,(JFN)
1)		STOR B,FLDIR,(JFN)	; SAVE THE NAME IN THE JFN BLOCK
1)		SETZRO FLTSD,(JFN)
1)		OKINT
LINE 35, PAGE 38
2)		LOAD B,FILUC,(JFN)	;GET THE UNIQUE CODE OF THIS STR
2)		HRLZS B			;BUILD A STR/DIR NUMBER
2)		HRR B,FILDDN(JFN)	;GET DEFAULT AGAIN
2)		CAME A,B		;IS THIS THE SAME AS THE DEFAULT?
2)		 CALL DEFDIT		;NO, THEN TYPE OUT DIR NAME IF DOING RECOGNITION
2)		SKIPA			; NOTHING HAS BEEN OUTPUT TO USER YET
2)		 AOS 0(P)		;SET UP FOR SKIP RETURN
2)	DEFDI3:	NOINT
2)		HLRZ B,FILTMP(JFN)
2)		STOR B,FILDIR,(JFN)	; SAVE THE NAME IN THE JFN BLOCK
2)		HRRZS FILTMP(JFN)
2)		OKINT


LINE 50, PAGE 42
1)	DEFDI1:	BLCAL. DSKOK,<<FILDEV(JFN)>> ;REAL DISK?
1)		 SKIPA			;NO
1)		TQNE <ASTF>		;IS IT REAL JFN?
1)		JRST DEFDI4		;NO, DONT SET DIRECTORY NUMBER AND STRING
1)		LOAD A,JSCDS		;GET POINTER TO NAME STRING IN JSB
1)		JN JSCDF,,DEFDI5	;IF VAILD, GO COPY IT TO FLDIR
1)		CALL GTCSCD		;GET CONNECTED STRUCTURE CODE,,DIRECTORY
LINE 50, PAGE 38
2)	DEFDI1:	HRRZ A,FILDEV(JFN)	;GET DISPATCH ADDRESS
2)		TQNN <ASTF>		;IS IT REAL JFN?
2)		CAIE A,DSKDTB		;IS THIS THE DISK?
2)		JRST DEFDI4		;NO, DONT SET DIRECTORY NUMBER AND STRING
2)		LOAD A,JSCDS		;GET POINTER TO NAME STRING IN JSB
2)		JN JSCDF,,DEFDI5	;IF VAILD, GO COPY IT TO FILDIR
2)		CALL GTCSCD		;GET CONNECTED STRUCTURE CODE,,DIRECTORY


; GTJFN.MAC.3 & GTJFN.GXJFN.1 19-Apr-88 0111	PAGE 43



LINE 61, PAGE 42
1)		LOAD A,FLUC,(JFN)	;GET UNIQUE CODE OF THIS STR
1)		LOAD B,CURUC		;GET CURRENT MAPPED DIR
LINE 61, PAGE 38
2)		LOAD A,FILUC,(JFN)	;GET UNIQUE CODE OF THIS STR
2)		LOAD B,CURUC		;GET CURRENT MAPPED DIR


LINE 77, PAGE 42
1)		LOAD A,FLUC,(JFN)	;GET UNIQUE CODE OF STRUCTURE
1)		LOAD B,JSUC		;GET CONNECTED STR #
LINE 77, PAGE 38
2)		LOAD A,FILUC,(JFN)	;GET UNIQUE CODE OF STRUCTURE
2)		LOAD B,JSUC		;GET CONNECTED STR #


LINE 95, PAGE 42
1)		LOAD B,FLTSD,(JFN)
1)		STOR B,FLDIR,(JFN)	; SAVE THE NAME IN THE JFN BLOCK
1)		SETZRO FLTSD,(JFN)
1)		OKINT
LINE 95, PAGE 38
2)		HLRZ B,FILTMP(JFN)
2)		STOR B,FILDIR,(JFN)	; SAVE THE NAME IN THE JFN BLOCK
2)		HRRZS FILTMP(JFN)
2)		OKINT


LINE 102, PAGE 42
1)		LOAD B,FLUC,(JFN)	;GET THE UNIQUE CODE OF THIS STR
1)		HRLZS B			;BUILD A STR/DIR NUMBER
LINE 102, PAGE 38
2)		LOAD B,FILUC,(JFN)	;GET THE UNIQUE CODE OF THIS STR
2)		HRLZS B			;BUILD A STR/DIR NUMBER


LINE 6, PAGE 43
1)	;	 +2:	OK, STRING POINTER PUT IN FLDIR(JFN)
1)	
1)	STORDN::STKVAR <STODNA,STODNL>
1)		EA.ENT
1)		MOVEM A,STODNA		;SAVE THE POINTER
LINE 6, PAGE 39
2)	;	 +2:	OK, STRING POINTER PUT IN FILDIR(JFN)
2)	
2)	STORDN::STKVAR <STODNA,STODNL>
2)		SE1CAL
2)		MOVEM A,STODNA		;SAVE THE POINTER


; GTJFN.MAC.3 & GTJFN.GXJFN.1 19-Apr-88 0111	PAGE 44



LINE 18, PAGE 43
1)		LOAD C,FLDIR,(JFN)	;GET POINTER TO EXISTING NAME STRING
1)		JUMPE C,STODN1		;IF ANY
LINE 18, PAGE 39
2)		LOAD C,FILDIR,(JFN)	;GET POINTER TO EXISTING NAME STRING
2)		JUMPE C,STODN1		;IF ANY


LINE 30, PAGE 43
1)		STOR A,FLDIR,(JFN)	;REMEMBER THIS STRING IN THE JFN BLOCK
1)		OKINT			;PERMIT INTERRUPTS AGAIN
1)	STODN2:	MOVE D,STODNA		;GET BACK POINTER TO NAME STRING
1)		MOVE B,[POINT 7,0(D),34]	;GET A BYTE POINTER TO NAME STRING
1)		LOAD A,FLDIR,(JFN)	;SET UP BYTE POINTER TO STRING IN JSB
1)		HRLI A,(POINT 7,0,34)
LINE 30, PAGE 39
2)		STOR A,FILDIR,(JFN)	;REMEMBER THIS STRING IN THE JFN BLOCK
2)		OKINT			;PERMIT INTERRUPTS AGAIN
2)	STODN2:	MOVE D,STODNA		;GET BACK POINTER TO NAME STRING
2)		MOVE B,[POINT 7,0(D),34]	;GET A BYTE POINTER TO NAME STRING
2)		LOAD A,FILDIR,(JFN)	;SET UP BYTE POINTER TO STRING IN JSB
2)		HRLI A,(POINT 7,0,34)


LINE 44, PAGE 43
1)	SDIRN::	BLCAL. MDDOK,<<FILDEV(JFN)>> ;A MULTIPLE DIR DEVICE?
1)		 RETSKP			;NO, THEN RETURN OK
1)		SAVEP
1)		LOAD A,FLDIR,(JFN)	;GET POINTER TO THE DIRECTORY NAME
1)		HRRZ B,0(A)		;GET LENGTH OF THE STRING
1)		MOVNI B,-2(B)		;GET NUMBER OF FULL WORDS
1)		HRL A,B			;SET UP LOOKUP POINTER
1)		LOAD B,FLUC,(JFN)	;GET THE UNIQUE CODE OF STR
1)		CALL DIRLKX		;GET THE DIRECTORY NUMBER
LINE 44, PAGE 39
2)	SDIRN::	SAVEP
2)		HRRZ A,FILDEV(JFN)	;IS THIS THE DISK?
2)		CAIE A,DSKDTB		;...
2)		RETSKP			;NO, THEN RETURN OK
2)		LOAD A,FILDIR,(JFN)	;GET POINTER TO THE DIRECTORY NAME
2)		HRRZ B,0(A)		;GET LENGTH OF THE STRING
2)		MOVNI B,-2(B)		;GET NUMBER OF FULL WORDS
2)		HRL A,B			;SET UP LOOKUP POINTER
2)		LOAD B,FILUC,(JFN)	;GET THE UNIQUE CODE OF STR
2)		CALL DIRLKX		;GET THE DIRECTORY NUMBER


; GTJFN.MAC.3 & GTJFN.GXJFN.1 19-Apr-88 0111	PAGE 45



LINE 10, PAGE 44
1)		LOAD A,FLTSD,(JFN)	; GET TEMP STRING
1)		STOR A,FLDMS,(JFN)	; TO MASK FIELD
1)		SETZRO FLTSD,(JFN)
1)		OKINT			; ALLOW INTS
LINE 10, PAGE 40
2)		HLRZ A,FILTMP(JFN)	; GET TEMP STRING
2)		STOR A,FILDMS,(JFN)	; TO MASK FIELD
2)		HRRZS FILTMP(JFN)
2)		OKINT			; ALLOW INTS


LINE 26, PAGE 44
1)		LOAD B,FLDMS,(JFN)	; GET DIRECTORY MASK
1)		CALL TYSTR1		; GO DO THIS OR A STAR
LINE 26, PAGE 40
2)		LOAD B,FILDMS,(JFN)	; GET DIRECTORY MASK
2)		CALL TYSTR1		; GO DO THIS OR A STAR


LINE 41, PAGE 44
1)	DEFDT1:	LOAD B,FLTSD,(JFN)	;GET STRING WITH DIR NAME IN IT
1)		CALL TSTRB		;TYPE OUT DIR NAME
LINE 41, PAGE 40
2)	DEFDT1:	HLRZ B,FILTMP(JFN)	;GET STRING WITH DIR NAME IN IT
2)		CALL TSTRB		;TYPE OUT DIR NAME


LINE 15, PAGE 45
1)		IFSKP. <
1)		  JRST DEFNM1>		; FOUND ONE, GO USE IT
1)		JUMPN A,R		; IF ERROR, RETURN IMMEDIATELY
1)		HRRZ A,E
1)		TLNN E,777777		; No default for short form
1)		XCTU [SKIPN A,.GJNAM(A)] ; Get user's default pointer
1)		JRST RFALSE		; None specified
LINE 15, PAGE 41
2)		 SKIPA			; THERE WAS NONE
2)		JRST DEFNM1		; FOUND ONE, GO USE IT
2)		JUMPN A,R		; IF ERROR, RETURN IMMEDIATELY
2)		HRRZ A,E
2)		TLNN E,777777		; No default for short form
2)		XCTU [SKIPN A,4(A)]	; Get user's default pointer
2)		JRST RFALSE		; None specified


; GTJFN.MAC.3 & GTJFN.GXJFN.1 19-Apr-88 0111	PAGE 46



LINE 30, PAGE 45
1)		MOVEM A,FILFDB(JFN)	; REMEMBER THE FDB ADDRESS
1)		NOINT
1)		LOAD B,FLTSD,(JFN)
1)		SETZRO FLTSD,(JFN)
1)		HRLM B,FILNEN(JFN)
1)		OKINT
1)		TQO <NAMF,NAMTF>
1)		TQNN <NREC>
1)		HRLI B,(<POINT 7,0,34>)	; SET UP BYTE POINTER
1)		CALL TSTRQC		;(B) Output the default name
1)		 RETBAD()		;Error - invalid field length
1)		AOS (P)			;Adjust for skip return
1)		JRST RFALSE		;Return with A set to zero
1)	
LINE 30, PAGE 41
2)		 RETBAD ()		; AMBIGUOUS NAME
2)		MOVEM A,FILFDB(JFN)	; REMEMBER THE FDB ADDRESS
2)		NOINT
2)		HLRZ B,FILTMP(JFN)
2)		HRRZS FILTMP(JFN)
2)		HRLM B,FILNEN(JFN)
2)		OKINT
2)		TQO <NAMF,NAMTF>
2)		AOS (P)
2)		TQNN <NREC>
2)		HRLI B,(<POINT 7,0,34>)	; SET UP BYTE POINTER
2)		CALL TSTRQ		; Output the default name
2)		JRST RFALSE
2)	


LINE 49, PAGE 45
1)		LOAD A,FLTSD,(JFN)	; GET DEFAULT POINTER
1)		STOR A,FLNMS,(JFN)	; TO MASK
1)		SETZRO FLTSD,(JFN)
1)		OKINT
LINE 49, PAGE 41
2)		HLRZ A,FILTMP(JFN)	; GET DEFAULT POINTER
2)		STOR A,FILNMS,(JFN)	; TO MASK
2)		HRRZS FILTMP(JFN)
2)		OKINT


; GTJFN.MAC.3 & GTJFN.GXJFN.1 19-Apr-88 0111	PAGE 47



LINE 59, PAGE 45
1)		MOVEM A,FILFDB(JFN)	;REMEMBER THE FDB ADDRESS
LINE 59, PAGE 41
2)		 RETBAD ()		;AMBIGUOUS
2)		MOVEM A,FILFDB(JFN)	;REMEMBER THE FDB ADDRESS


LINE 64, PAGE 45
1)		LOAD B,FLNMS,(JFN)	; NAME MASK
1)		TQNN <NREC>
LINE 65, PAGE 41
2)		LOAD B,FILNMS,(JFN)	; NAME MASK
2)		TQNN <NREC>


LINE 15, PAGE 46
1)		IFNSK.
1)		  CAIE 1,GJFX23		; DIRECTORY FULL?
1)		  JRST RFALSE		; NO, THEN SAY NO MATCH
1)		  RETBAD		; YES, THEN TELL CALLER THE REAL ERROR
1)		ENDIF.
1)		MOVEM A,FILFDB(JFN)	; REMEMBER THE FDB ADDRESS
1)		NOINT
1)		LOAD B,FLTSD,(JFN)
1)		SETZRO FLTSD,(JFN)
1)		HRRM B,FILNEN(JFN)
LINE 15, PAGE 42
2)	;**;[3011] REPLACE ONE LINE AT DEFEXT: + 5L WITH 3.	TAB	7-SEP-83
2)	;[3011]	 JRST RFALSE
2)		 JRST [	CAIE 1,GJFX23	;[3011] SKIP IF DIRECTORY FULL
2)			JRST RFALSE	;[3011] ELSE SAY NO MATCH.
2)			RETBAD]		;[3011] RETURN AS ERROR
2)		 JRST RFALSE		; None such
2)		MOVEM A,FILFDB(JFN)	; REMEMBER THE FDB ADDRESS
2)		NOINT
2)		HLRZ B,FILTMP(JFN)
2)		HRRZS FILTMP(JFN)
2)		HRRM B,FILNEN(JFN)


LINE 37, PAGE 46
1)		SOS (P)			;Do not assume success return yet
1)		CALL TSTRQC		;(B) Output the default extension
1)		 RETBAD()		;Error - invalid field length
1)		AOS (P)			;Success so readjust for skip return
1)		TQNE <NVERF>
LINE 38, PAGE 42
2)		CALL TSTRQ		; Output the default extension
2)		TQNE <NVERF>

; GTJFN.MAC.3 & GTJFN.GXJFN.1 19-Apr-88 0111	PAGE 48




LINE 13, PAGE 47
1)		LOAD A,FLTSD,(JFN)	; GET DEFAULT POINTER
1)		STOR A,FLEMS,(JFN)	; TO MASK FIELD
1)		SETZRO FLTSD,(JFN)	; CLEAR OUT DEFAULT POINTER
1)		OKINT
LINE 13, PAGE 43
2)		HLRZ A,FILTMP(JFN)	; GET DEFAULT POINTER
2)		STOR A,FILEMS,(JFN)	; TO MASK FIELD
2)		HRRZS FILTMP(JFN)	; CLEAR OUT DEFAULT POINTER
2)		OKINT


LINE 20, PAGE 47
1)		LOAD B,FLEMS,(JFN)	;EXTENSION MASK
1)		TQNN <NREC>
LINE 20, PAGE 43
2)		LOAD B,FILEMS,(JFN)	;EXTENSION MASK
2)		TQNN <NREC>


LINE 37, PAGE 47
1)		IFSKP. <
1)		  RETSKP>		; GOT ONE
1)		JUMPN A,R		; IF ERROR, RETURN IMMEDIATELY
1)		HRRZ A,E
1)		TLNN E,777777		; No default if short form
1)		XCTU [SKIPN A,.GJEXT(A)] ; Get user's default pointer
1)		JRST RFALSE		; NONE THERE
LINE 37, PAGE 43
2)		 SKIPA			; NONE FOUND
2)		RETSKP			; GOT ONE
2)		JUMPN A,R		; IF ERROR, RETURN IMMEDIATELY
2)		HRRZ A,E
2)		TLNN E,777777		; No default if short form
2)		XCTU [SKIPN A,5(A)]	; Get user's default pointer
2)		JRST RFALSE		; NONE THERE


LINE 15, PAGE 48
1)		IFNSK.
1)		  HRRZ A,E
1)		  XCTU [HRRE A,.GJGEN(A)]	;NONE, Get USER DEFINED default version
1)		ENDIF.
1)		TQNE <TMPFF>
1)		SKIPE A			;TEMPORARY AND WANT "DEFAULT"?
1)		JRST DEFVR1
1)		MOVE A,GBLJNO		; Default becomes global job number for temp
1)		ADDI A,^D100000
LINE 15, PAGE 44

; GTJFN.MAC.3 & GTJFN.GXJFN.1 19-Apr-88 0111	PAGE 49


2)		JRST [	HRRZ A,E
2)			XCTU [HRRE A,0(A)]	;NONE, Get USER DEFINED default version
2)			JRST .+1]
2)		TQNE <TMPFF>
2)		SKIPE A			;TEMPORARY AND WANT "DEFAULT"?
2)		JRST DEFVR1
2)		MOVE A,JOBNO		; Default becomes job number for temp
2)		ADDI A,^D100000


LINE 27, PAGE 48
1)		IFSKP. <
1)		  SOS A>		; 0 default becomes -1 for output
1)		CAMN A,[-3]		;-3 MEANS *
1)	IFE STANSW,<			; [SMXGTX]
1)		JRST [	TQNN <ASTAF>	;STARS ALLOWED?
1)	>;IFE STANSW
1)	IFN STANSW,<			; [SMXGTX]
1)		JRST [	TQNN <ASTAF,OSTRF> ;STARS ALLOWED?
1)	>;IFN STANSW
1)			TQNE <ASTF>	;* ALREADY SEEN?
LINE 26, PAGE 44
2)		JRST .+2
2)		SOS A			; 0 default becomes -1 for output
2)		CAMN A,[-3]		;-3 MEANS *
2)		JRST [	TQNN <ASTAF,OSTRF> ;CS82 [SMXGTJ] STARS ALLOWED?
2)			TQNE <ASTF>	;* ALREADY SEEN?


LINE 46, PAGE 48
1)	IFE STANSW,<			; [SMXGTJ]
1)	DEFVR2:	CALL VERLUK		; Extant?
1)		 JRST STEPLN		; NO, STEP THE LOGICAL NAME
1)		HRRM A,FILVER(JFN)
1)		MOVEM B,FILFDB(JFN)	; REMEMBER THE FDB ADDRESS
1)	>;IFE STANSW			; [SMXGTJ]
1)	IFN STANSW,<			; [SMXGTJ]
1)	DEFVR2:	CALL GTVER		; EXTANT? (AND CHECK ACESS)
1)		 JRST STEPLN		; NO, STEP THE LOGICAL NAME
1)	>;IFN STANSW			; [SMXGTJ]
1)		MOVE B,A
LINE 40, PAGE 44
2)	DEFVR2:	CALL GTVER		;CS82 [SMXGTJ] Extant? (and check acess)
2)		 JRST STEPLN		; NO, STEP THE LOGICAL NAME
2)	;	HRRM A,FILVER(JFN)	;CS82 [SMXGTJ] Bookkeeping done by GTVER
2)	;	MOVEM B,FILFDB(JFN)	;CS82 [SMXGTJ] REMEMBER THE FDB ADDRESS
2)		MOVE B,A


; GTJFN.MAC.3 & GTJFN.GXJFN.1 19-Apr-88 0111	PAGE 50



LINE 71, PAGE 48
1)		IFSKP. <
1)		  MOVEI B,0>		;YES, TYPE OUT .0 FOR VERSION #
1)		CALL DNOUT
LINE 59, PAGE 44
2)		SKIPA			;NO
2)		MOVEI B,0		;YES, TYPE OUT .0 FOR VERSION #
2)		CALL DNOUT


LINE 45, PAGE 49
1)		IFE. B			;ENDED WITH A NUL?
1)		  SETO B,		;YES, BACK UP THE BYTE POINTER ONCE
1)		  ADJBP B,A		;SO THE DATA FIELD APPEARS TO BE NULL
1)		  MOVE A,B
1)		ENDIF.
1)		CALL REDFLT		;NOW GO READ IN THE DATA PORTION
LINE 45, PAGE 45
2)		SKIPN B			;ENDED WITH A NUL?
2)		JRST [	SETO B,		;YES, BACK UP THE BYTE POINTER ONCE
2)			ADJBP B,A	;SO THE DATA FIELD APPEARS TO BE NULL
2)			MOVE A,B
2)			JRST .+1]
2)		CALL REDFLT		;NOW GO READ IN THE DATA PORTION


LINE 65, PAGE 49
1)	CHKATR:	LOAD B,FLATL,(JFN)	;GET START OF CHAIN
1)	CHKAT1:	JUMPE B,RSKP		;IF AT END OF CHAIN, RETURN OK
LINE 65, PAGE 45
2)	CHKATR:	LOAD B,FILATL,(JFN)	;GET START OF CHAIN
2)	CHKAT1:	JUMPE B,RSKP		;IF AT END OF CHAIN, RETURN OK


LINE 80, PAGE 49
1)	ADDATR:	LOAD A,FLTSD,(JFN)	;FIRST CHECK LEGALITY OF ATTRIBUTE
1)		LOAD B,PFXVAL		;GET THE PREFIX VALUE
1)		HRRZ C,DEV		;GET DISPATCH ADDRESS ONLY
1)		SKIPN C			;IS THERE A DEVICE?
1)		RETBAD (GJFX40)		;NO. INVALID ATTRIBUTES
1)		CALL @ATRD(C)		;CALL DEVICE DEPENDENT MODULE FOR OK
1)		 RETBAD ()		;ILLEGAL ATTRIBUTE FOR THIS DEVICE
1)		NOINT			;DISALLOW INTERRUPTS
1)		LOAD A,FLTSD,(JFN)	;PICK UP THE DATA STRING
1)		SETZRO FLTSD,(JFN)	;CLEAR POINTER TO TEMP STRING
1)		CALL LNKATR		;LINK THIS ATTRIBUTE ONTO CHAIN
LINE 80, PAGE 45
2)	ADDATR:	HLRZ A,FILTMP(JFN)	;FIRST CHECK LEGALITY OF ATTRIBUTE
2)		LOAD B,PFXVAL		;GET THE PREFIX VALUE

; GTJFN.MAC.3 & GTJFN.GXJFN.1 19-Apr-88 0111	PAGE 51


2)		HRRZ C,DEV		;GET DISPATCH ADDRESS ONLY
2)	;**;[3050] ADD 2 LINES AT ADDATR:+3L	TAM	6-DEC-83
2)		SKIPN C			;[3050] IS THERE ONE?
2)		RETBAD (GJFX40)		;[3050] NO - ERROR
2)		CALL @ATRD(C)		;CALL DEVICE DEPENDENT MODULE FOR OK
2)		 RETBAD ()		;ILLEGAL ATTRIBUTE FOR THIS DEVICE
2)		NOINT			;DISALLOW INTERRUPTS
2)		HLRZ A,FILTMP(JFN)	;PICK UP THE DATA STRING
2)		HRRZS FILTMP(JFN)	;CLEAR POINTER TO TEMP STRING
2)		CALL LNKATR		;LINK THIS ATTRIBUTE ONTO CHAIN


LINE 100, PAGE 49
1)	LNKATR:	LOAD B,FLATL,(JFN)	;GET POINTER TO FIRST ITEM ON LIST
1)		STOR B,PRFXL,(A)	;MAKE NEW ITEM POINT DOWN THE CHAIN
1)		MOVE B,PREFIX(TXT)	;GET PREFIX VALUE
1)		STOR B,PRFXV,(A)	;PUT THIS VALUE IN HEADER
1)		STOR A,FLATL,(JFN)	;PUT NEW ITEM ON CHAIN
1)		MOVX C,ATRF		;MARK THAT AN ATTRIBUTE WAS SEEN
LINE 101, PAGE 45
2)	LNKATR:	LOAD B,FILATL,(JFN)	;GET POINTER TO FIRST ITEM ON LIST
2)		STOR B,PRFXL,(A)	;MAKE NEW ITEM POINT DOWN THE CHAIN
2)		MOVE B,PREFIX(TXT)	;GET PREFIX VALUE
2)		STOR B,PRFXV,(A)	;PUT THIS VALUE IN HEADER
2)		STOR A,FILATL,(JFN)	;PUT NEW ITEM ON CHAIN
2)		MOVX C,ATRF		;MARK THAT AN ATTRIBUTE WAS SEEN


LINE 128, PAGE 49
1)		IFSKP. <
1)		  SUBI A,40>		;YES, CONVERT IT TO UPPERCASE
1)		IDPB A,C		;STORE THIS CHARACTER IN STRING
LINE 129, PAGE 45
2)		SKIPA
2)		SUBI A,40		;YES, CONVERT IT TO UPPERCASE
2)		IDPB A,C		;STORE THIS CHARACTER IN STRING


LINE 138, PAGE 49
1)		 ERJMPR [RETBAD ()]	;ERR CODE TO T1 AND RETURN FAIL
1)		TXNN B,TL%ABR!TL%EXM	;FOUND ONE?
LINE 139, PAGE 45
2)		 ERJMP [MOVE A,LSTERR	;GET THE ERROR CODE
2)			RETBAD ()]	;AND RETURN
2)		TXNN B,TL%ABR!TL%EXM	;FOUND ONE?


; GTJFN.MAC.3 & GTJFN.GXJFN.1 19-Apr-88 0111	PAGE 52



LINE 20, PAGE 50
1)		XCTU [SKIPN A,.GJACT(A)] ; Get default account
1)		RETSKP			; NonE specified
LINE 20, PAGE 46
2)		XCTU [SKIPN A,7(A)]	; Get default account
2)		RETSKP			; NonE specified


LINE 39, PAGE 50
1)		LOAD A,FLTSD,(JFN)	;GET START OF STRING
1)		CALL TRMBLK		;TRIM IT
LINE 39, PAGE 46
2)		HLRZ A,FILTMP(JFN)	;GET START OF STRING
2)		CALL TRMBLK		;TRIM IT


LINE 46, PAGE 50
1)		LOAD A,FLTSD,(JFN)	; THE STRING POINTER
1)		SETZRO FLTSD,(JFN)
1)		MOVEM A,FILACT(JFN)
LINE 46, PAGE 46
2)		HLRZ A,FILTMP(JFN)	; THE STRING POINTER
2)		HRRZS FILTMP(JFN)
2)		MOVEM A,FILACT(JFN)


LINE 14, PAGE 51
1)		IFSKP. <
1)		  JRST DEFPR1>		; USE THIS VALUE
1)		JUMPN A,R		; IF ERROR, RETURN IMMEDIATELY
1)		HRRZ A,E
1)		TLNN E,777777		; No default if short form
1)		XCTU [SKIPN A,.GJPRO(A)] ; Get the default protection from user
1)		RETSKP
1)	DEFPR1:	CAMG A,[6B2-1]		; Must be numeric
1)		CAMGE A,[5B2]
1)		IFSKP.
1)		  MOVEM A,FILPRT(JFN)	;NOT A STRING, SAVE IT AS IS
1)		ELSE.
1)		  TLC A,-1
1)		  TLCE A,-1		;LH =-1?
1)		  TLNN A,-1		;OR LH=0
1)		  HRLI A,(POINT 7,) 	;YES. USE DEFAULT
1)		  CALL REDFLT		; GET STRING
1)		   RETBAD		; ERROR
1)		  LOAD A,FLTSD,(JFN) 	;GET STRING ADDRESS
1)		  TQO <OCTF>		; SAY LOOKING FOR OCTAL
1)		  CALL GETNUM		; TRY TO CONVERT TO NUMBER
1)		   RETBAD (GJFX14)	; ILLEGAL

; GTJFN.MAC.3 & GTJFN.GXJFN.1 19-Apr-88 0111	PAGE 53


1)		  MOVEM A,FILPRT(JFN) 	;STASH IT AWAY
1)		  NOINT
1)		  LOAD B,FLTSD,(JFN) 	;THE JSB SPACE
1)		  SETZRO FLTSD,(JFN)
1)		  MOVEI A,JSBFRE
1)		  CALL RELFRE		;FREE THE BLOCK
1)		  OKINT
1)		ENDIF.
1)		TQO <PRTF>
1)		RETSKP
1)	^L
1)	;ROUTINE TO COLLECT A NUMBER FOR DEFACT AND DEFPRT
LINE 14, PAGE 47
2)		 SKIPA			; NONE
2)		JRST DEFPR1		; USE THIS VALUE
2)		JUMPN A,R		; IF ERROR, RETURN IMMEDIATELY
2)		HRRZ A,E
2)		TLNN E,777777		; No default if short form
2)		XCTU [SKIPN A,6(A)]	; Get the default protection from user
2)		RETSKP
2)	DEFPR1:	CAMG A,[6B2-1]		; Must be numeric
2)		CAMGE A,[5B2]
2)		JRST [	TLC A,-1
2)			TLCE A,-1	;LH =-1?
2)			TLNN A,-1	;OR LH=0
2)			HRLI A,(POINT 7,) ;YES. USE DEFAULT
2)			CALL REDFLT	; GET STRING
2)			 RETBAD		; ERROR
2)			HLRZ A,FILTMP(JFN) ;GET STRING ADDRESS
2)			TQO <OCTF>	; SAY LOOKING FOR OCTAL
2)			CALL GETNUM	; TRY TO CONVERT TO NUMBER
2)			 RETBAD (GJFX14)	; ILLEGAL
2)			MOVEM A,FILPRT(JFN) ;STASH IT AWAY
2)			NOINT
2)			HLRZ B,FILTMP(JFN) ;THE JSB SPACE
2)			HRRZS FILTMP(JFN)
2)			MOVEI A,JSBFRE
2)			CALL RELFRE	;FREE THE BLOCK
2)			OKINT
2)			JRST DEFPR2]	;GO MARK IT
2)		MOVEM A,FILPRT(JFN)
2)	DEFPR2:	TQO <PRTF>
2)		RETSKP
2)	
2)	;ROUTINE TO COLLECT A NUMBER FOR DEFACT AND DEFPRT


; GTJFN.MAC.3 & GTJFN.GXJFN.1 19-Apr-88 0111	PAGE 54



LINE 8, PAGE 53
1)	; Copies the default string into a block addressed by FLTSD (lh(filtmp(jfn)))
1)	; Clobbers a,b,c,d
LINE 8, PAGE 48
2)	; Copies the default string into a block addressed by lh(filtmp(jfn))
2)	; Clobbers a,b,c,d


LINE 22, PAGE 53
1)	REDFL0:	SAVEAC <TMP>		;Save the temporary AC
1)		STKVAR <BYTSAV,STTSAV>
1)		MOVEM B,TMP 		;Save instruction to get bytes
1)	REDFL1:	XCT TMP 		;Get a byte
1)		MOVEM B,BYTSAV		;SAVE THE BYTE
LINE 22, PAGE 48
2)	REDFL0:	STKVAR <XCTV,BYTSAV,STTSAV>
2)		MOVEM B,XCTV		;SAVE INSTRUCTION TO GET BYTES
2)	REDFL1:	MOVE T2,XCTV		;CMB111 Get instruction in a reg. for KIMXCR
2)		XCT T2			;CMB111 GET A BYTE
2)		MOVEM B,BYTSAV		;SAVE THE BYTE


LINE 34, PAGE 53
1)		CAIN C,$QUOT		; Character quote?
1)		 JRST REDFL3
1)		CAIN C,$STAR		;STAR?
1)		JRST REDFST
1)		CAIL C,DIGITC
1)		CAILE C,LOWERA
1)		CAIN C,MINUSC		;LOWER CASE LETTER OR MINUS?
1)		JRST REDFL4		;YES
1)		CAIN C,$DOT		; DOT?
1)		JRST REDFL4		; YES, DOT IS LEGAL IN DIR NAMES AND ACCOUNTS
1)		CAILE C,LOWER		; A NON-ALPHA?
1)		JRST [	 SETZ B,	;YES, END OF STRING
LINE 34, PAGE 48
2)		CAIN C,16		; Character quote?
2)		 JRST REDFL3
2)		CAIN C,20
2)		JRST REDFST
2)		CAIL C,21
2)		CAILE C,27
2)		CAIN C,30
2)		JRST REDFL4
2)		CAIN C,14		; DOT?
2)		JRST REDFL4		; YES, DOT IS LEGAL IN DIR NAMES AND ACCOUNTS
2)		CAILE C,1		; A NON-ALPHA?
2)		JRST [	 SETZ B,	;YES, END OF STRING


; GTJFN.MAC.3 & GTJFN.GXJFN.1 19-Apr-88 0111	PAGE 55



LINE 56, PAGE 53
1)		IFSKP. <
1)		  TRZ B,40>		;YES. RAISE IT
1)	REDFL2:	SOSGE D			;ROOM FOR THIS ONE IN THE BUFFER?
LINE 56, PAGE 48
2)		SKIPA			;NO. DONT RAISE IT
2)		TRZ B,40		;YES. RAISE IT
2)	^L
2)	REDFL2:	SOSGE D			;ROOM FOR THIS ONE IN THE BUFFER?


LINE 62, PAGE 53
1)	REDFLE:	LOAD A,FLTSD,(JFN)
1)		MOVE B,C
1)		CALL TRMBLK		; Trim the block and return excess
1)		LOAD A,FLTSD,(JFN)
1)		MOVN B,(A)		;GET NEG LENGTH OF BLOCK, I.E. -(NWDS+1)
LINE 6, PAGE 49
2)	REDFLE:	HLRZ A,FILTMP(JFN)
2)		MOVE B,C
2)		CALL TRMBLK		; Trim the block and return excess
2)		HLRZ A,FILTMP(JFN)
2)		MOVN B,(A)		;GET NEG LENGTH OF BLOCK, I.E. -(NWDS+1)


LINE 71, PAGE 53
1)		XCT TMP 		;Get next byte
1)		JRST REDFL2
LINE 15, PAGE 49
2)		XCT XCTV		;GET NEXT BYTE
2)		JRST REDFL2


LINE 79, PAGE 53
1)		IFSKP. <
1)		  RETBAD (GJFX31)>	; NO. GIVE APPROPRIATE ERROR
1)		TQNE <OSTRF>		; OUTPUT STARS ?
LINE 23, PAGE 49
2)		SKIPA			;ALLOW IT
2)		RETBAD (GJFX31)		; NO. GIVE APPROPRIATE ERROR
2)		TQNE <OSTRF>		; OUTPUT STARS ?


; GTJFN.MAC.3 & GTJFN.GXJFN.1 19-Apr-88 0111	PAGE 56



LINE 92, PAGE 53
1)		LOAD A,FLTSD,(JFN)
1)		IFN. A
1)		  HRRZ B,0(A)		;HAVE A STRING. SEE IF CORRECT LENGTH
1)		  CAIN B,MAXLW+1	;HAS IT BEEN TRIMMED?
1)		  JRST GDFTM1		;NO. USE IT THEN
1)		  MOVE B,A		;YES. MUST RELEASE IT
1)		  MOVEI A,JSBFRE	; BACK TO THE POOL
1)		  NOINT
1)		  SETZRO FLTSD,(JFN)	; NO STRING NOW
1)		  CALL RELFRE		;FREE IT UP
1)		  OKINT			;ALLOW INTS AGAIN
1)		ENDIF.
1)		MOVEI B,MAXLW+1
LINE 36, PAGE 49
2)		HLRZ A,FILTMP(JFN)
2)		JUMPN A,[HRRZ B,0(A)	;HAVE A STRING. SEE IF CORRECT LENGTH
2)			CAIN B,MAXLW+1	;HAS IT BEEN TRIMMED?
2)			JRST GDFTM1	;NO. USE IT THEN
2)			MOVE B,A	;YES. MUST RELEASE IT
2)			MOVEI A,JSBFRE	; BACK TO THE POOL
2)			NOINT
2)			HRRZS FILTMP(JFN); NO STRING NOW
2)			CALL RELFRE	;FREE IT UP
2)			OKINT		;ALLOW INTS AGAIN
2)			JRST .+1]	;AND GO GET A NEW BLOCK
2)		MOVEI B,MAXLW+1


LINE 108, PAGE 53
1)		STOR A,FLTSD,(JFN)
1)		OKINT
LINE 51, PAGE 49
2)		HRLM A,FILTMP(JFN)
2)		OKINT


LINE 10, PAGE 55
1)		BLCAL. DSKOK,<<FILDEV(JFN)>> ;DISK?
1)		 RETSKP			;NOT A DISK, ALWAYS PROCEED
1)		CALL GETFDB		;MAP IN THE FILE
LINE 10, PAGE 51
2)		HRRZ A,FILDEV(JFN)	;SEE IF THIS IS THE DISK
2)		CAIE A,DSKDTB		;...
2)		RETSKP			;NOT A DISK, ALWAYS PROCEED
2)		CALL GETFDB		;MAP IN THE FILE


; GTJFN.MAC.3 & GTJFN.GXJFN.1 19-Apr-88 0111	PAGE 57



LINE 49, PAGE 55
1)		 RETBAD (GJFX44)	;NO, FAIL
1)		SKIPN D			;END OF STRING?
LINE 50, PAGE 51
2)		IFNSK.			;CM366 Match any account?
2)		 ILDB D,COMACP		;CM366 That is the last char isn't it?
2)		 SKIPN D		;CM366
2)		 CAIE C,"*"		;CM366
2)		 RETBAD (GJFX44)	;NO, FAIL
2)		 RETSKP			;CM366 It was just a *, match then
2)		 ENDIF.			;CM366
2)		SKIPN D			;END OF STRING?


LINE 16, PAGE 57
1)	RECDI1:	CALL ENDSTX		; Terminate string, get lookup pointer
1)		PUSH P,FILOPT(JFN)	; Save filopt(jfn) for typing out tail
1)		BLCAL. MDDOK,<<FILDEV(JFN)>> ;A MULTIPLE DIR DEVICE?
1)		 JRST RECDI3		; No.  Do not update FILOPT for JFN
1)		LOAD B,FLUC,(JFN)	; GET STRUCTURE NUMBER
1)		MOVE C,FILOPT(JFN)	; COPY POINTER TO TAIL
LINE 16, PAGE 53
2)	RECDI1:	CALL ENDSTR		; Terminate string, get lookup pointer
2)		PUSH P,FILOPT(JFN)	; Save filopt(jfn) for typing out tail
2)		HRRZ B,FILDEV(JFN)	;SEE IF THIS IS A DISK
2)		CAIE B,DSKDTB		;IF NOT, DONT CALL DIRLKX
2)		JRST RECDI2		; NOT A DISK
2)		LOAD B,FILUC,(JFN)	; GET STRUCTURE NUMBER
2)		MOVE C,FILOPT(JFN)	; COPY POINTER TO TAIL


LINE 25, PAGE 57
1)			JRST RECDI3	; Yes. Do not update FILOPT for JFN
1)			POP P,FILOPT(JFN)
LINE 26, PAGE 53
2)			JRST RECDI2	; YES. TREAT AS IF AMBIGUOUS THEN
2)			POP P,FILOPT(JFN)


LINE 32, PAGE 57
1)		STOR A,FLDIR,(JFN)	;STORE IT IN THE JFN BLOCK
1)		OKINT			;UNLOCK FROM ENDTMP
1)		POP P,B
1)		TQNE <NREC>		;WANT RECOGNITION?
1)		IFSKP.
1)		  CALL TSTRQ		;YES. TYPE OUT REST OF NAME
1)		  CALL BRKOUT		;OUTPUT THE PUNCTUAUTION
1)		ENDIF.
1)		TQO <DIRF,DIRTF>

; GTJFN.MAC.3 & GTJFN.GXJFN.1 19-Apr-88 0111	PAGE 58


1)		TQZ <DIRFF>
1)		CALLRET SETTMP		; Reset temp block and return
1)	^L
1)	; HERE ON AMBIGUOUS RETURN FROM DIRLUK
1)	
1)	RECDI2:	MOVEM B,FILOPT(JFN)	;STORE UPDATED POINTER
1)	RECDI3:	POP P,B			;Get back pointer to untyped text
1)		TQNE <NREC>		;DOING RECOGNITION?
LINE 33, PAGE 53
2)		STOR A,FILDIR,(JFN)	;STORE IT IN THE JFN BLOCK
2)		OKINT			;UNLOCK FROM ENDTMP
2)		POP P,B
2)		TQNN <NREC>		;WANT RECOGNITION?
2)		JRST [	CALL TSTRQ	;YES. TYPE OUT REST OF NAME
2)			CALL BRKOUT	;OUTPUT THE PUNCTUAUTION
2)			JRST .+1]	;AND GO FINISH UP
2)		TQO <DIRF,DIRTF>
2)		TQZ <DIRFF>
2)		CALLRET SETTMP		; Reset temp block and return
2)	
2)	; HERE ON AMBIGUOUS RETURN FROM DIRLUK
2)	
2)	RECDI2:	MOVEM B,FILOPT(JFN)	;STORE UPDATED POINTER
2)		POP P,B			;GET BACK POINTER TO UNTYPED TEXT
2)		TQNE <NREC>		;DOING RECOGNITION?


LINE 6, PAGE 59
1)		 JRST [	JN AMBGF,,DING	;IF AMBIGUOUS...
1)			JUMPN A,R	;IF ERROR, RETURN NOW
1)			MOVEI A,GJFX19	;IF NO ERROR, STEP LOGICAL NAME
1)			JRST STEPLN]
1)		RETSKP
1)	
1)	RECEXX:	CALL ENDSTX		; Terminate string, get lookup pointer
1)		PUSH P,FILOPT(JFN)	; Save filopt(jfn) for typing out tail
1)		CALL EXTLUK		; Lookup extension
1)		 JRST [	POP P,FILOPT(JFN)
1)	IFE STANSW,<
1)			JN AMBGF,,R	;IF AMBIGUOUS...
1)	>;IFE STANSW
1)	IFN STANSW,<			; Partial recognition
1)			IFQN. AMBGF
1)			  MOVE B,FILOPT(JFN)
1)			  CALL TSTRQ	; Recognize what we can
1)			  RET
1)			ENDIF.
1)	> ;IFN STANSW			; Partial recognition
1)			TQNE <OLDNF>	;IF OLD FILE DESIRED,
1)			JRST RFALSE	;GO STEP LOGICAL NAME
1)			RET]

; GTJFN.MAC.3 & GTJFN.GXJFN.1 19-Apr-88 0111	PAGE 59


1)		MOVEM A,FILFDB(JFN)	; REMEMBER THE FDB ADDRESS
LINE 6, PAGE 54
2)		 JRST [	JUMPN A,R	;IF ERROR, RETURN NOW
2)			MOVEI A,GJFX19	;IF NO ERROR, STEP LOGICAL NAME
2)			JRST STEPLN]
2)		 CALLRET DING
2)		RETSKP
2)	
2)	RECEXX:	CALL ENDSTR		; Terminate string, get lookup pointer
2)		PUSH P,FILOPT(JFN)	; Save filopt(jfn) for typing out tail
2)		CALL EXTLUK		; Lookup extension
2)		 JRST [	POP P,FILOPT(JFN)
2)			TQNE <OLDNF>	;IF OLD FILE DESIRED,
2)			JRST RFALSE	;GO STEP LOGICAL NAME
2)			TQNE <NREC>	;DOING RECOGNITION?
2)			RETBAD		;NO, GO RETURN THE ERROR
2)			RETSKP]		; RETURN AMBIG
2)		 JRST [	POP P,FILOPT(JFN)
2)			MOVE B,FILOPT(JFN) ;CS82A [SMXGTJ]
2)			CALL TSTRQ	;CS82A [SMXGTJ] Recognize what we can
2)			RETSKP]		; Ambiguous
2)		MOVEM A,FILFDB(JFN)	; REMEMBER THE FDB ADDRESS


LINE 39, PAGE 59
1)		CALL TSTRQC		;(B) Yes, output tail
1)		 RETBAD()		;Error - invalid field length
1)		TQNE <NVERF>
LINE 35, PAGE 54
2)		CALL TSTRQ		; Yes, output tail
2)		TQNE <NVERF>


LINE 51, PAGE 59
1)		RETSKP
LINE 46, PAGE 54
2)		AOS 0(P)		;GIVE DOUBLE SKIP RETURN
2)		RETSKP


LINE 6, PAGE 60
1)		IFSKP. <
1)		  RETSKP>
1)		JUMPN A,R		;IF ERRORS, RETURN
LINE 6, PAGE 55
2)		 SKIPA
2)		RETSKP
2)		JUMPN A,R		;IF ERRORS, RETURN


; GTJFN.MAC.3 & GTJFN.GXJFN.1 19-Apr-88 0111	PAGE 60



LINE 20, PAGE 60
1)		 JRST [	JN AMBGF,,DING	;IF AMBIGUOUS
1)			JUMPN A,R	;IF ERROR, RETURN NOW
1)			MOVEI A,GJFX19	;EXTENSION NOT FOUND
1)			RET]
1)		RETSKP
1)	^L
1)	; Recognize name
1)	; This routine operates in the same way as recdir and recext above
1)	
1)	RECNA0:	TQNE <DEVF>		;SEEN A DEVICE YET?
1)		IFSKP.
1)		  CALL DEFDEV		;NO, GO GET DEFAULTED DEVICE
1)		  IFSKP. <
1)		    RETSKP>		;DEVICE NAME WAS RECOGNIZED, STOP HERE
1)		  JUMPN A,[RETBAD ()]	;IF ERROR, EXIT
1)		ENDIF.
1)		TQNE <DIRF>		;SEEN A DIRECTORY YET?
1)		IFSKP.
1)		  CALL DEFDIR		;NO, GO DEFAULT ONE
1)		  IFSKP. <
1)		    RETSKP>		;DIR WAS RECOGNIZED, STOP HERE
1)		  JUMPN A,[RETBAD ()]	;OTHERWISE EXIT
1)		ENDIF.
1)		SETZ A,			;NO ERROR CONDITION
LINE 20, PAGE 55
2)		 JRST [	JUMPN A,R	;IF ERROR, RETURN NOW
2)			MOVEI A,GJFX19	;EXTENSION NOT FOUND
2)			RET]
2)		 JRST DING
2)		RETSKP
2)	
2)	
2)	; Recognize name
2)	; This routine operates in the same way as recdir and recext above
2)	
2)	RECNA0:	TQNN <DEVF>		;SEEN A DEVICE YET?
2)		JRST [	CALL DEFDEV	;NO, GO GET DEFAULTED DEVICE
2)			 SKIPA
2)			RETSKP		;DEVICE NAME WAS RECOGNIZED, STOP HERE
2)			JUMPE A,.+1	;IF NO ERRORS, GO DEFAULT IN NAME
2)			RETBAD ()]	;OTHERWISE, EXIT
2)		TQNN <DIRF>		;SEEN A DIRECTORY YET?
2)		JRST [	CALL DEFDIR	;NO, GO DEFAULT ONE
2)			 SKIPA
2)			RETSKP		;DIR WAS RECOGNIZED, STOP HERE
2)			JUMPE A,.+1	;IF NO ERRORS CONTINUE ON
2)			RETBAD ()]	;OTHERWISE EXIT
2)		SETZ A,			;NO ERROR CONDITION

; GTJFN.MAC.3 & GTJFN.GXJFN.1 19-Apr-88 0111	PAGE 61




LINE 24, PAGE 61
1)		IFNSK.
1)		  JUMPN A,R		;IF ERROR EXIT
1)		  MOVE C,FILCNT(JFN)
1)		  CAMN C,CNTWRD(TXT)
1)		  CALL DEFNAM
1)		  IFNSK.
1)		    JUMPE A,DING	;IF NO ERRORS, RING THE BELL
1)		    RETBAD ()
1)		  ENDIF.
1)		ENDIF.
1)		TQNN <NREC>		;DOING RECOGNITION?
LINE 47, PAGE 55
2)		 JRST [	JUMPN A,R	;IF ERROR EXIT
2)			MOVE C,FILCNT(JFN)
2)			CAMN C,CNTWRD(TXT)
2)			CALL DEFNAM
2)			 SKIPA
2)			JRST .+1
2)			JUMPE A,DING	;IF NO ERRORS, RING THE BELL
2)			RETBAD ()]
2)		TQNN <NREC>		;DOING RECOGNITION?


LINE 3, PAGE 62
1)		IFSKP. <
1)		  RETSKP>
1)		JUMPE A,DING		;GO RING BELL IF NO ERROR
LINE 3, PAGE 56
2)		 SKIPA
2)		RETSKP
2)		JUMPE A,DING		;GO RING BELL IF NO ERROR


LINE 12, PAGE 62
1)	RECNA2:	CALL ENDSTX		; Terminate string, get lookup pointer
1)		PUSH P,FILOPT(JFN)	; Save filopt(jfn) for typing tail
1)		CALL NAMLUK		; Lookup name in directory
1)		 JRST [	POP P,FILOPT(JFN)
1)	IFE STANSW,<
1)			JN AMBGF,,RFALSE ;IF AMBIGUOUS
1)	>;IFE STANSW
1)	IFN STANSW,<			; Partial recognition
1)			IFQN. AMBGF
1)			  MOVE B,FILOPT(JFN)
1)			  CALL TSTRQ	; Recognize what we can
1)			  JRST RFALSE
1)			ENDIF.
1)	> ;IFN STANSW			; Partial recognition	

; GTJFN.MAC.3 & GTJFN.GXJFN.1 19-Apr-88 0111	PAGE 62


1)			TQNN <OLDNF>	;NEW FILES ALLOWED?
LINE 12, PAGE 56
2)	RECNA2:	CALL ENDSTR		; Terminate string, get lookup pointer
2)		PUSH P,FILOPT(JFN)	; Save filopt(jfn) for typing tail
2)		CALL NAMLUK		; Lookup name in directory
2)		 JRST [	POP P,FILOPT(JFN)
2)			TQNN <OLDNF>	;NEW FILES ALLOWED?


LINE 30, PAGE 62
1)		MOVEM A,FILFDB(JFN)	; REMEMBER THE FDB ADDRESS
LINE 20, PAGE 56
2)		 JRST [	POP P,FILOPT(JFN)
2)			MOVE B,FILOPT(JFN) ;CS82A [SMXGTJ]
2)			CALL TSTRQ	;CS82A [SMXGTJ] Recognize what we can
2)			JRST RFALSE]	; Ambiguous
2)		MOVEM A,FILFDB(JFN)	; REMEMBER THE FDB ADDRESS


LINE 38, PAGE 62
1)		IFSKP.
1)		  CALL TSTRQC		;(B) Type remainder
1)		   RETBAD() 		;Error - invalid field length
1)		ENDIF.
1)		CALLRET SETTMP
LINE 32, PAGE 56
2)		SKIPA			; Setup new temp, and return
2)		CALL TSTRQ		; Type remainder
2)		CALLRET SETTMP


LINE 27, PAGE 63
1)	RECPR0:	CALL ENDSTX		;TIE OFF THE PREFIX STRING
1)		HRLI A,(POINT 7,0,35)	;GET POINTER TO THE FIRST CHAR
LINE 27, PAGE 57
2)	RECPR0:	CALL ENDSTR		;TIE OFF THE PREFIX STRING
2)		HRLI A,(POINT 7,0,35)	;GET POINTER TO THE FIRST CHAR


LINE 32, PAGE 63
1)		 ERJMPR [RETBAD ()]	;ERR CODE TO A AND RETURN FAIL
1)		TXNN B,TL%ABR!TL%EXM	;FOUND A PREFIX?
LINE 32, PAGE 57
2)		 ERJMP [MOVE A,LSTERR	;GET THE ERROR CODE
2)			RETBAD ()]
2)		TXNN B,TL%ABR!TL%EXM	;FOUND A PREFIX?


; GTJFN.MAC.3 & GTJFN.GXJFN.1 19-Apr-88 0111	PAGE 63



LINE 2, PAGE 64
1)	RETYPE:	TMSG </
LINE 2, PAGE 58
2)	   REPEAT 0,<			; Repeat zero historical code
2)	DELALL:	TMSG </___
2)	/>
2)		NOINT
2)		CALL RELJFX		; Release jfn (to clear free storage)
2)		CALL ASGJFN		; And reassign
2)		RETBAD (GJFX3,<OKINT>)	; Should not happen, but in case
2)		OKINT
2)		HRRZ F1,E
2)		XCTU [HLLZ F,0(F1)]
2)		MOVEI F1,0
2)		CALLRET SETTMP		; And start over
2)	   >				; End of REPEAT ZERO historical code
2)	
2)	
2)	RETYPE:	TMSG </


LINE 14, PAGE 65
1)	ENDALZ:	HRRZ A,FILDEV(JFN)	;Disallow use of device NFT: -
1)		CAIN A,NFTDTB		; using device NFT AND
1)		TQNE NODEF		;  no node in file spec ?
1)		IFSKP.
1)		  TQNE <ASTF>		;yes. parse only ?
1)		  IFSKP.
1)		    MOVEI T1,GJFX16 	;no. force failure. (NO SUCH DEVICE)
1)		    JRST ERRDO
1)		  ENDIF.
1)		  SETZM FILDEV(JFN)	;yes. clear device field in JFN block
1)		ENDIF.
1)		TQNN <STARF>
1)		IFSKP.
1)		CALL [	TQNE <DIRFF> ;COLLECTING DIRECTORY?
1)			IFSKP.
1)			  TQNN <NAMF>
1)			  CALLRET ENDNA3
1)			  CALLRET ENDEX8
1)			ELSE.
1)			  CALL ENDDIR 	;YES. GO FINISH IT UP
1)			   RET	 	;FAILED
1)			  TQNN <NREC> 	;DOING RECOGNITION?
1)			  CALL BRKOUT 	;YES. OUTPUT TERMINATOR
1)			  RETSKP	;DONE
1)			ENDIF.]
1)		 JRST [	JUMPL A,GTJFST	; IF <0, LN WAS STEPPED
1)			JRST ERRDO]	; ELSE, NO STEP

; GTJFN.MAC.3 & GTJFN.GXJFN.1 19-Apr-88 0111	PAGE 64


1)		ENDIF.
1)		MOVE C,FILCNT(JFN)
1)		TQNN <DIRFF>		;COLLECTING A DIRECTORY?
1)		CAME C,CNTWRD(TXT)	; Is input string NON-null?
1)		IFNSK.
1)		  TQNN <NREC>		;YES. DOING RECOGNITION?
1)		  TXNN F1,STRSF!DIRSF!NAMSF!EXTSF!VERSF ;YES. SEEN A STAR?
1)		  IFSKP.
1)		    TQNE <EXTF> 	;YES, GOT EXTENTION FIELD YET?
1)		    IFSKP.
1)		      CALL DING 	;NO, RETURN AMBIGUOUS
1)		      MOVEI A,0
1)		      JRST GTJF2
1)		    ENDIF.
1)		  ENDIF.
1)		  CALL RECFL0
1)		  IFNSK.
1)		    JUMPE A,GTJF2	; AMBIGUOUS
1)		    JUMPG A,ERRDO	; ERROR
1)		    TQNE <ASTF>		; PARSE ONLY?
1)		    JRST ENDAL4		; YES, CONTINUE
1)		    JRST GTJFST		; RETRY - LOGICAL NAME WAS STEPPED
1)		  ENDIF.
1)		ENDIF.
1)		MOVE C,FLAGS(TXT)	;SEE IF GETTING AN ATTRIBUTE
1)		TXNN C,ARBATF		;...
1)		IFSKP.
1)		  MOVEI A,GJFX46	;YES
1)		  TQNE <NREC>		;RECOGNIZING?
1)		  JRST ERRDO		;NO, THEN GIVE AN ERROR RETURN
1)		  CALL DING		;YES, RING THE BELL
1)		  JRST GTJF2		;AND GO BACK FOR THE ATTRIBUTE VALUE
1)		ENDIF.
1)		TQNE <NAMF,NNAMF>	; Do we have a name?
1)	      IFSKP.
1)		CALL DEFNAM		; No, try the default name
1)		IFNSK.
1)		  JUMPL A,GTJFST	; LN WAS STEPPED, GO RETRY
1)		  JUMPG A,ERRDO		; ERROR OCCURED
1)		  CALL RECNAM		; NO DEFAULT, SEE IF A NO-NAME DEVICE
1)		  IFNSK.
1)		    JUMPE A,GTJF2	; GO GET MORE FROM USER
1)		    JUMPG A,ERRDO	; ERROR
1)		    TQNE <ASTF>		; PARSE ONLY?
1)		    JRST ENDAL4		; YES - DON'T RETRY STEPPED LOGICAL NAME
1)		    JRST GTJFST		; RETRY - LOGICAL NAME WAS STEPPED
1)		  ENDIF.
1)		ENDIF.
1)	      ENDIF.
1)		TQNE <EXTF,NNAMF>	; After all that, do we have ext?
1)		JRST ENDAL4		; Yes

; GTJFN.MAC.3 & GTJFN.GXJFN.1 19-Apr-88 0111	PAGE 65


LINE 14, PAGE 59
2)	ENDALZ:	TQNN <STARF>
2)		JRST ENDLZ1
2)		CALL [	TQNE <DIRFF> ;COLLECTING DIRECTORY?
2)			JRST [	CALL ENDDIR ;YES. GO FINISH IT UP
2)				 RET	 	;FAILED
2)				TQNN <NREC> ;DOING RECOGNITION?
2)				CALL BRKOUT ;YES. OUTPUT TERMINATOR
2)				RETSKP]	  ;DONE
2)			TQNN <NAMF>
2)			CALLRET ENDNA3
2)			CALLRET ENDEX8]
2)		 JRST [	JUMPL A,GTJFST	; IF <0, LN WAS STEPPED
2)			JRST ERRDO]	; ELSE, NO STEP
2)	ENDLZ1:	MOVE C,FILCNT(JFN)
2)		TQNN <DIRFF>		;COLLECTING A DIRECTORY?
2)		CAME C,CNTWRD(TXT)	; Is input string NON-null?
2)		JRST [	TQNN <NREC>	;YES. DOING RECOGNITION?
2)			TXNN F1,STRSF!DIRSF!NAMSF!EXTSF!VERSF ;YES. SEEN A STAR?
2)			SKIPA		;NO. GO DO LOOKUP
2)			CALL [	TQNE <EXTF> ;GOT EXTENTION FIELD YET?
2)				RET	;YES, RECOGNITION AFTER EXT IS OK
2)				CALL DING ;NO, RETURN AMBIGUOUS
2)				MOVEI A,0
2)				RETSKP]
2)			CALL RECFL0
2)			 SKIPA
2)			JRST .+1	; FOUND ONE
2)			JUMPE A,GTJF2	; AMBIGUOUS
2)			JUMPG A,ERRDO	; ERROR
2)			TQNE <ASTF>	; PARSE ONLY?
2)			JRST ENDAL4	; YES, CONTINUE
2)			JRST GTJFST]	; RETRY - LOGICAL NAME WAS STEPPED
2)		MOVE C,FLAGS(TXT)	;SEE IF GETTING AN ATTRIBUTE
2)		TXNE C,ARBATF		;...
2)		JRST [	MOVEI A,GJFX46	;YES
2)			TQNE <NREC>	;RECOGNIZING?
2)			JRST ERRDO	;NO, THEN GIVE AN ERROR RETURN
2)			CALL DING	;YES, RING THE BELL
2)			JRST GTJF2]	;AND GO BACK FOR THE ATTRIBUTE VALUE
2)		TQNE <NAMF,NNAMF>	; Do we have a name?
2)		JRST ENDAL0		; Yes.
2)		CALL DEFNAM		; No, try the default name
2)		 JRST [	JUMPL A,GTJFST	; LN WAS STEPPED, GO RETRY
2)			JUMPG A,ERRDO	; ERROR OCCURED
2)			CALL RECNAM	; NO DEFAULT, SEE IF A NO-NAME DEVICE
2)			 SKIPA
2)			JRST ENDAL0	; YES, THEN THROUGH WITH GTJFN JSYS
2)			JUMPE A,GTJF2	; GO GET MORE FROM USER
2)			JUMPG A,ERRDO	; ERROR
2)			TQNE <ASTF>	; PARSE ONLY?

; GTJFN.MAC.3 & GTJFN.GXJFN.1 19-Apr-88 0111	PAGE 66


2)			JRST ENDAL4	; YES - DON'T RETRY STEPPED LOGICAL NAME
2)			JRST GTJFST]	; RETRY - LOGICAL NAME WAS STEPPED
2)	ENDAL0:	TQNE <EXTF,NNAMF>	; After all that, do we have ext?
2)		JRST ENDAL4		; Yes


LINE 100, PAGE 65
1)	ENDAL4:	TQNE <NNAMF>		; NO NAME DEVICE?
1)		JRST ENDAL7		; YES
1)		TQNE <VERF>		; Do we have a version?
1)		IFSKP.
1)		  CALL DEFVER		; No, default it
1)		  IFNSK.
1)		    JUMPGE A,ERRDO	;ERROR
1)		    CALL STOALT		;LN WAS STEPPED, PUT ALTMODE BACK IF NEEDED
1)		     JRST ERRDO		;ERROR ENCOUNTERED
1)		    JRST GTJFST		;GO REPROCESS THE COMMAND
1)		  ENDIF.
1)		ENDIF.
1)		TQNE <NEWF,NEWVF>
1)		IFSKP.
1)		  TQNN <ASTF>		; Parse-only?
1)		  JRST ENDAL7		; No, continue
1)		ENDIF.
1)		TQNE <PRTF>		; Do we have protection?
1)		IFSKP.
1)		  CALL DEFPRT		; No, default it
1)		   JRST ERRDO
1)		ENDIF.
1)		TQNE <ACTF>		; Do we have an account?
1)		IFSKP.
1)		  CALL DEFACT		; No, default it
1)		   JRST ERRDO
1)		ENDIF.
1)	ENDAL7:	CALL DEFATR		;GET SET UP ANY DESIRED ATTRIBUTES
1)		 JRST ERRDO		;FAILED
1)	ENDL77:	TQNN <TCONF>		;ALREADY CONFIRMED?
LINE 76, PAGE 59
2)		;..
2)	^L
2)		;..
2)	ENDAL4:	TQNE <NNAMF>		; NO NAME DEVICE?
2)		JRST ENDAL7		; YES
2)		TQNN <VERF>		; Do we have a version?
2)		JRST [	CALL DEFVER	; No, default it
2)			 SKIPA		; ERROR
2)			JRST .+1	;FOUND A VERSION NUMBER
2)			JUMPGE A,ERRDO	;ERROR
2)			CALL STOALT	;LN WAS STEPPED, PUT ALTMODE BACK IF NEEDED
2)			 JRST ERRDO	;ERROR ENCOUNTERED
2)			JRST GTJFST]	;GO REPROCESS THE COMMAND

; GTJFN.MAC.3 & GTJFN.GXJFN.1 19-Apr-88 0111	PAGE 67


2)		TQNN <NEWF,NEWVF>
2)		JRST [	TQNN <ASTF>	; Parse only?
2)			JRST ENDAL7	; No, Continue...
2)			JRST .+1]	; Yes, check fields to insert
2)		TQNN <PRTF>		; Do we have protection?
2)		JRST [	CALL DEFPRT	; No, default it
2)			 JRST ERRDO
2)			JRST .+1]
2)		TQNN <ACTF>		; Do we have an account?
2)		JRST [	CALL DEFACT	; No, default it
2)			 JRST ERRDO
2)			JRST .+1]
2)	ENDAL7:	CALL DEFATR		;GET SET UP ANY DESIRED ATTRIBUTES
2)		 JRST ERRDO		;FAILED
2)	REPEAT 0,<	TQNE <RTYPF>	; User request retyping name?
2)		JRST [	TMSG1 </
2)	/>
2)			SETZ C,		; USE DEFAULT FLAGS
2)			HRRZ A,E
2)			XCTU [HRRZ A,1(A)] ;OUTPUT JFN
2)			TLNE E,777777
2)			TLNE E,2
2)			CAIN A,377777	;NULL?
2)			JRST .+1	;MUST BE A NOOP
2)			CALL JFNSM	;PRINT THE FILE NAME
2)			 JFCL
2)			JRST .+1]>	;ALL DONE
2)	ENDL77:	TQNN <TCONF>		;ALREADY CONFIRMED?


LINE 147, PAGE 65
1)	ENDAL9:	TXNN F1,DIRSF!NAMSF!EXTSF!VERSF
LINE 58, PAGE 60
2)		;..
2)	^L
2)		;..
2)	ENDAL9:	TXNN F1,DIRSF!NAMSF!EXTSF!VERSF


LINE 178, PAGE 65
1)		IFSKP. <
1)		  ERRLJF GJFX15>	; Improper confirmation
1)		BKJFN			;  BACK UP THE INPUT
1)		 JFCL
1)		CALL CLRJFN		;CLEAR OUT THE INPUT
1)		CALL SETTMP		;GET SOME WORK SPACE
1)		 JRST ERRDO
1)		TXNN F1,DIRSF!NAMSF!EXTSF!VERSF
1)		TQNN <PONFF>		;PRINT REQUESTED?
1)		JRST MRTEXT		;NO. GO ON
1)		CALL RETYPE		;RETYPE EDITED FILESPEC

; GTJFN.MAC.3 & GTJFN.GXJFN.1 19-Apr-88 0111	PAGE 68


1)		JRST MRTEXT		;AND GO GET SOME MORE INPUT
1)	^L
LINE 34, PAGE 61
2)		JRST [	BKJFN		;  BACK UP THE INPUT
2)			 JFCL		;
2)			CALL CLRJFN	;CLEAR OUT THE INPUT
2)			CALL SETTMP	;GET SOME WORK SPACE
2)			 JRST ERRDO
2)			TXNN F1,DIRSF!NAMSF!EXTSF!VERSF
2)			TQNN <PONFF>	;PRINT REQUESTED?
2)			JRST MRTEXT	;NO. GO ON
2)	;**;[3013] Replace 2 lines with 1 line @ENDAL-2/<tab>+10  JMP Sep 12,83
2)			CALL RETYPE	;[3013] RE-TYPE THE EDITED LINE
2)			JRST MRTEXT]	;AND GO GET SOME MORE INPUT
2)		ERRLJF GJFX15		; Improper confirmation
2)	^L


LINE 9, PAGE 66
1)		TQNE <ACTF>		; Do we have an account string?
1)		IFSKP.
1)		  NOINT			;AVOID INTERRUPTS WHILE FILACT IS FUDGED
1)	IFE STANSW,<
1)		  MOVEI B,ACCTSR-1 	;POINT TO ACCOUNT STRING
1)		  MOVN A,ACCTSL
1)	>;IFE STANSW
1)	IFN STANSW,<		;;FOR SOME REASON, ALTHOUGH IN GLOBS, THIS SYMBOL IS
1)				;; UNDEFINED.  MACRO BUG?  -KSL 27-APR-85 
1)		  MOVEI B,ACCTSR##-1 	;POINT TO ACCOUNT STRING
1)		  MOVN A,ACCTSL##
1)	>;IFN STANSW
1)		  HRLI B,2(A)		;LOOKUP POINTER TO ACCOUNT
1)		  CALL @ALUKD(E)
1)		   JRST [POP P,E	;ERROR
1)			JRST ERRDO]
1)		  SETZM FILACT(JFN)
1)		  OKINT
1)		  JRST ENDALT
1)		ENDIF.
1)		MOVE B,FILACT(JFN)
LINE 9, PAGE 62
2)		TQNN <ACTF>		; Do we have an account string?
2)		JRST [	NOINT		;AVOID INTERRUPTS WHILE FILACT IS FUDGED
2)			MOVEI B,ACCTSR-1 ;POINT TO ACCOUNT STRING
2)			MOVN A,ACCTSL
2)			HRLI B,2(A)	;LOOKUP POINTER TO ACCOUNT
2)			CALL @ALUKD(E)
2)			 JRST [	POP P,E	;ERROR
2)				JRST ERRDO]
2)			SETZM FILACT(JFN)
2)			OKINT

; GTJFN.MAC.3 & GTJFN.GXJFN.1 19-Apr-88 0111	PAGE 69


2)			JRST ENDALT]
2)		MOVE B,FILACT(JFN)


LINE 40, PAGE 66
1)		HRRZ A,E		;SEE IF REAL DISK
1)		POP P,E			;RESTORE E
1)		BLCAL. DSKOK,<A>	;REAL DISK?
1)		IFSKP. <
1)		  CALL FDBINU>		;YES - INIT NAME STRINGS IN FDB
1)	ENDALS:	CALL STRUSR		;RETURN FILE NAME TO THE USER
LINE 31, PAGE 62
2)		HRRZ A,NLUKD(E)		;SEE IF REAL DISK FILE
2)		POP P,E			;RESTORE E
2)		CAIN A,MDDNAM		;...
2)		CALL FDBINU		;YES - INIT NAME STRINGS IN FDB
2)	ENDALS:	CALL STRUSR		;RETURN FILE NAME TO THE USER


LINE 51, PAGE 66
1)		JRST ENDLS1		; YES. DON'T RELEASE ACCOUNT AND PROT STRINGS
1)		SKIPLE B,FILPRT(JFN)
LINE 41, PAGE 62
2)		JRST ENDLS1		; YES. DON'T RELEASE ACCOUNT AND PROT
2)					;  STRINGS
2)		SKIPLE B,FILPRT(JFN)


LINE 58, PAGE 66
1)		LOAD B,FLTSD,(JFN)
1)		SKIPE B
LINE 49, PAGE 62
2)		HLRZ B,FILTMP(JFN)
2)		SKIPE B


LINE 75, PAGE 66
1)		OKINT
1)		CALL ENDINF		;RESTORE INPUT FILES
1)		MOVE A,JFN		; GET JFN
1)		IDIVI A,MLJFN		; CONVERT BACK TO USER INDEX
LINE 1, PAGE 63
2)	^L
2)		OKINT
2)		CALL INFTST
2)		 JRST ENDL55		;NO INPUT FILE
2)		POP P,B			;GET ORIGINAL JFN MODE WORD
2)		SFMOD			;SET IT BACK
2)		POP P,C
2)		POP P,B
2)		SFCOC

; GTJFN.MAC.3 & GTJFN.GXJFN.1 19-Apr-88 0111	PAGE 70


2)	ENDL55:	MOVE A,JFN		; GET JFN
2)		IDIVI A,MLJFN		; CONVERT BACK TO USER INDEX


LINE 91, PAGE 66
1)		 TXO JFN,GJ%GND		; Not seeing deleted files
1)		TQNN <IGIVF>
1)		 TXO JFN,GJ%GIV		; Not seeing invisible files
1)		TQNE NODEF
1)		 TXO JFN,GJ%NOD		; Saw a node name in file spec
1)	ENDA51: TQNN <OSTRF>		;Real file
1)		TQNN <NODEF>		; AND saw node name ?
1)		IFSKP.
1)		  CALL DIMLNK		;yes. establish link to remote FAL
1)		   JRST ERRDO		;failure.
1)		ENDIF.
1)		UMOVEM JFN,1		; Return jfn to user
1)		TQNN <ASTF>		; REAL JFN?
LINE 24, PAGE 64
2)		 TXO JFN,GJ%GND
2)		TQNN <IGIVF>
2)		 TXO JFN,GJ%GIV		; Not seeing invisible files
2)	ENDA51:	UMOVEM JFN,1		; Return jfn to user
2)		TQNN <ASTF>		; REAL JFN?


LINE 111, PAGE 66
1)		BLCAL. DSKOK,<NUM>	;SEE IF REAL FDB PRESENT, i.e. real disk
1)		 JRST ENDL58		;ISN'T
1)		CALL GETFDB		; FIND FDB FOR THE FILE
LINE 36, PAGE 64
2)		HRRZ A,NLUKD(NUM)	;MAKE SURE THIS FILE HAS A REAL FDB
2)		CAIE A,MDDNAM		;DOES IT?
2)		JRST ENDL58		;NO. RETURN NOW
2)		CALL GETFDB		; FIND FDB FOR THE FILE


LINE 117, PAGE 66
1)		CALL ACCCHK		; DO IT
1)		 JRST ENDL57		; NOT ACCESSIBLE. GO STEP IT
1)		MOVE A,0(P)		; GET BACK THE FDB ADDRESS
1)	IFN STANSW,<
1)		CALL MDDAMC		;[CWR] VERIFY ATTRIBUTE MASK
1)		 JRST ENDL57		;[CWR] FAILED, GO STEP.
1)	
1)	; The above is technically erroneous, as it should be determined
1)	; much earlier if the initial FDB is wrong or not.  The reason for
1)	; this is that a non-wild specification which desires the attribute
1)	; match will succeed where it should not.  C'est la vie.
1)	
1)	>;IFN STANSW

; GTJFN.MAC.3 & GTJFN.GXJFN.1 19-Apr-88 0111	PAGE 71


1)		CALL COMACT		; COMPARE THE ACCOUNT STRING
LINE 43, PAGE 64
2)	;CM366	CALL ACCCHK		; DO IT
2)		CALL ACCOVR		;CM366 If ;A* given, try to override FC%DIR
2)		 JRST ENDL57		; NOT ACCESSIBLE. GO STEP IT
2)		MOVE A,0(P)		; GET BACK THE FDB ADDRESS
2)		CALL COMACT		; COMPARE THE ACCOUNT STRING


LINE 6, PAGE 67
1)		IFSKP. <
1)		  JRST ENDL6A>		; YES. LET HIM GET NULL EXTENSION THEN
1)		MOVEI B,"."
LINE 6, PAGE 65
2)		SKIPA			; NO
2)		JRST ENDL6A		; YES. LET HIM GET NULL EXTENSION THEN
2)		MOVEI B,"."


LINE 15, PAGE 67
1)		IFSKP. <
1)		  JRST ENDAL4>		;YES. USE IT
1)		JUMPN A,ERRDO		;IF BAD NEWS, BOMB OUT
LINE 15, PAGE 65
2)		 SKIPA			;NO
2)		JRST ENDAL4		;YES. USE IT
2)		JUMPN A,ERRDO		;IF BAD NEWS, BOMB OUT


LINE 28, PAGE 67
1)		IFSKP. <
1)		  JRST ENDAL4>
1)		IFQN. AMBGF		;NO, FAILURE OR AMBIGUOUS
1)		  CALL DING		;AMBIGUOUS, DING AND TRY FOR MORE
1)		  JRST GTJF2
1)		ENDIF.
1)		JUMPL A,GTJFST		;LOGICAL NAME WAS STEPPED
1)		JUMPG A,ERRDO		;AN ERROR WAS ENCOUNTERED
1)		MOVEI A,GJFX19		;SET UP ERROR CODE
1)		CALL STEPLN		;STEP THE LOGICAL NAME IF ANY
1)		JUMPL A,GTJFST		;LOGICAL NAME WAS STEPPED
1)		JRST ERRDO		;LOGICAL NAME NOT STEPPED, BOMB OUT
1)	
LINE 28, PAGE 65
2)		 JRST [	JUMPL A,GTJFST	;LOGICAL NAME WAS STEPPED
2)			JUMPG A,ERRDO	;AN ERROR WAS ENCOUNTERED
2)			MOVEI A,GJFX19	;SET UP ERROR CODE
2)			CALL STEPLN	;STEP THE LOGICAL NAME IF ANY
2)			JUMPL A,GTJFST	;LOGICAL NAME WAS STEPPED
2)			JRST ERRDO]	;LOGICAL NAME NOT STEPPED, BOMB OUT
2)		 JRST [	CALL DING

; GTJFN.MAC.3 & GTJFN.GXJFN.1 19-Apr-88 0111	PAGE 72


2)			JRST GTJF2]
2)		JRST ENDAL4
2)	


LINE 6, PAGE 68
1)	IFE STANSW,<			; [SMXGTJ]
1)		TQNN <ASTF>		;* ALREADY SEEN?
1)		TQNE <ASTAF>
1)		SKIPA A,FILCNT(JFN)	;ALLOW IT
1)		RETBAD (GJFX31)		; Illegal *
1)	>;IFE STANSW			; [SMXGTJ]
1)	IFN STANSW,<			; [SMXGTJ]
1)		MOVE A,FILCNT(JFN)	; ALLOW STARS SO *? CAN GIVE DIRECTORY LISTING
1)	>;IFN STANSW			; [SMXGTJ]
1)		MOVE B,CNTWRD(TXT)	;GET MAX VALUE
1)		CAIN A,-1(B)		; HAVE SOMETHING ALREADY?
1)		TQNE <STARF>		; ALREADY SEENA STAR?
1)		IFNSK.
1)		  MOVX A,WLDF		; YES. IT IS WILD THEN
1)		  IORM A,FLAGS(TXT) 	;REMEMBER THIS
1)		  TQNE <NUMFF>		;COLLECTING A NUMBER?
1)		  RETBAD (GJFX4)	;YES. GIVE AN ERROR THEN
1)		ENDIF.
1)	STAR2:	TQNE <OSTRF>
LINE 6, PAGE 66
2)	;	TQNN <ASTF>		;CS82 [SMXGTJ] * ALREADY SEEN?
2)	;	TQNE <ASTAF>		;CS82 [SMXGTJ]
2)	;	SKIPA A,FILCNT(JFN)	;CS82 [SMXGTJ] ALLOW IT
2)	;	RETBAD (GJFX31)		;CS82 [SMXGTJ] Illegal *
2)	;CS82 [SMXGTJ] Allow stars so *? can give directory listing
2)		MOVE A,FILCNT(JFN)	;CS82 [SMXGTJ]
2)		MOVE B,CNTWRD(TXT)	;GET MAX VALUE
2)		CAIN A,-1(B)		; HAVE SOMETHING ALREADY?
2)		TQNE <STARF>		; ALREADY SEENA STAR?
2)		JRST [	MOVX A,WLDF	; YES. IT IS WILD THEN
2)			IORM A,FLAGS(TXT) ;REMEMBER THIS
2)			TQNE <NUMFF>	;COLLECTING A NUMBER?
2)			RETBAD (GJFX4)	;YES. GIVE AN ERROR THEN
2)			JRST .+1]	;PROCEED
2)	STAR2:	TQNE <OSTRF>


; GTJFN.MAC.3 & GTJFN.GXJFN.1 19-Apr-88 0111	PAGE 73



LINE 29, PAGE 68
1)	IFE STANSW,<			; [SMXGTJ]
1)	QUEST:
1)	>;IFE STANSW			; [SMXGTJ]
1)	IFN STANSW,<			; [SMXGTJ]
1)	PCENT:				; MAKE ROUTINE NAME MEANINGFUL
1)	>;IFN STANSW			; [SMXGTJ]
1)		TQNE <NUMFF>		; FOR WILD CHARS. ON A NUMBER?
1)		RETBAD (GJFX4)		; YES. ILLEGAL CHARACTER THEN
1)		CALL DPST		; SAVE BYTE
1)		 RETBAD()		; NO ROOM
1)	IFE STANSW,<			; [SMXGTJ] ALLOW STARS SO *? GIVES DIR LISTING
1)		TQNN <ASTF>		;* ALREADY SEEN?
1)		TQNE <ASTAF>		; STARS ALLOWED?
1)		IFSKP. <
1)		  RETBAD (GJFX31)>	; NO. GIVE BAD RETURN
1)	>;IFE STANSW			; [SMXGTJ]
1)		MOVX A,WLDF		; FOR FLAGS
1)		IORM A,FLAGS(TXT)	;REMEMBER WILD CHAR SEEN
1)		CALLRET STAR2		; GO DO THE * STUFF
1)	^L
1)	IFN STANSW,<			; [SMXGTJ]
1)	; Routines to handle user question mark input.  Entered from input char
LINE 25, PAGE 66
2)	;CS82 [SMXGTJ] Make routine name meaningful
2)	
2)	PCENT:	TQNE <NUMFF>		;CS82 [SMXGTJ] FOR WILD CHARS. ON A NUMBER?
2)		RETBAD (GJFX4)		; YES. ILLEGAL CHARACTER THEN
2)		CALL DPST		; SAVE BYTE
2)		 RETBAD()		; NO ROOM
2)	
2)	;CS82 [SMXGTJ] Allow stars so *? can give directory listing 
2)	;	TQNN <ASTF>		;CS82 [SMXGTJ] * ALREADY SEEN?
2)	;	TQNE <ASTAF>		;CS82 [SMXGTJ] STARS ALLOWED?
2)	;	SKIPA			;CS82 [SMXGTJ] ALLOW IT
2)	;	RETBAD (GJFX31)		;CS82 [SMXGTJ] NO. GIVE BAD RETURN
2)	
2)		MOVX A,WLDF		; FOR FLAGS
2)		IORM A,FLAGS(TXT)	;REMEMBER WILD CHAR SEEN
2)		CALLRET STAR2		; GO DO THE * STUFF
2)	
2)	^L
2)	;CS82 *** Begin ***
2)	; [SMXGTJ] This is the beginning of the code for interactive ? handling
2)	
2)	; Routines to handle user question mark input.  Entered from input char


; GTJFN.MAC.3 & GTJFN.GXJFN.1 19-Apr-88 0111	PAGE 74



LINE 14, PAGE 69
1)		TQNE <OSTRF>		; GJ%OFG, parse only?
LINE 16, PAGE 67
2)	
2)		TQNE <OSTRF>		; GJ%OFG, parse only?


LINE 18, PAGE 69
1)		CALL INFTST		; Test for no input JFN
1)		 ERRLJF GJFX34		; None, so break out now
1)		SETZ A,			; Erase the ?
1)		DPB A,CURPNT(TXT)
1)		PUSH P,LDPNT(TXT)	; Save TEXTI context
LINE 21, PAGE 67
2)	
2)		CALL INFTST		; Test for no input JFN
2)		 ERRLJF GJFX34		; None, so break out now
2)	
2)		SETZ A,			; Erase the ?
2)		DPB A,CURPNT(TXT)
2)	
2)		PUSH P,LDPNT(TXT)	; Save TEXTI context


LINE 26, PAGE 69
1)		TQNN <DEVF>		; Device specified?
1)		 CALL DEFDEV		; No, get a default (and set up FILDEV)
1)		HRRZ B,FILDEV(JFN)	; Has to be some flavor of DSK:
1)		CAIE B,DSKDTB
1)		 JRST QUEST2		; Oops, ding him and restart
1)		TQO <NREC>		; Turn off recognition
1)		TQNE <EXTFF>		; Extension being specified?
LINE 32, PAGE 67
2)	
2)		TQNN <DEVF>		; Device specified?
2)		 PUSHJ P,DEFDEV		; No, get a default (and set up FILDEV)
2)	
2)		HRRZ B,FILDEV(JFN)	; Has to be some flavor of DSK:
2)		CAIE B,DSKDTB
2)		 JRST QUEST2		; Oops, ding him and restart
2)	
2)		TQO <NREC>		; Turn off recognition
2)	
2)		TQNE <EXTFF>		; Extension being specified?


; GTJFN.MAC.3 & GTJFN.GXJFN.1 19-Apr-88 0111	PAGE 75



LINE 1, PAGE 70
1)	^L
1)	QUEST0:	CALL GSIBE		; Anything typed?
1)		 SKIPA			; Yes, eat it
LINE 1, PAGE 68
2)	^LQUEST0:	PUSHJ P,GSIBE		; Anything typed?
2)		 SKIPA			; Yes, eat it


LINE 8, PAGE 71
1)		CFOBF%			; Clear output buffer
1)		XCTU [HLRZ A,1(D)]	; Something was typed to stop output
1)		BIN%			; Get the input and throw it away
1)	
1)	QUEST2:	CALL DING		; Can't help in any later fields
1)	
LINE 7, PAGE 69
2)		CFOBF			; Clear output buffer
2)		XCTU [HLRZ A,1(D)]	; Something was typed to stop output
2)		BIN			; Get the input and throw it away
2)	
2)	QUEST2:	PUSHJ P,DING		; Can't help in any later fields
2)	


LINE 27, PAGE 71
1)		CALL RETYPE		; Retype the input text
1)		CALL BACKIT		; Backup over the null that was the ?
LINE 26, PAGE 69
2)	
2)		PUSHJ P,RETYPE		; Retype the input text
2)	
2)		CALL BACKIT		; Backup over the null that was the ?


LINE 37, PAGE 71
1)		CALL RELJFN		; Go clean up
1)		CALL ASGJFN		; Go get another
1)		IFNSK.
LINE 38, PAGE 69
2)		PUSHJ P,RELJFN		; Go clean up
2)		PUSHJ P,ASGJFN		; Go get another
2)		IFNSK.


; GTJFN.MAC.3 & GTJFN.GXJFN.1 19-Apr-88 0111	PAGE 76



LINE 43, PAGE 71
1)		   CALL RELFRE
1)		  ERRLJF GJFX3		; And bomb out
LINE 44, PAGE 69
2)		   PUSHJ P,RELFRE
2)		  ERRLJF GJFX3		; And bomb out


LINE 49, PAGE 71
1)		XCTU [HLLZ F,0(E)]	; Fetch his flags again
1)		MOVEI F1,0		; And clear others
1)		MOVE A,STRPNT(TXT)	; Reinit pointer to input string
1)		MOVEM A,LDPNT(TXT)
1)		SETZM LDCNT(TXT)	; Zap the input count
1)		CALL SETTMP		; Get another temp block and continue
LINE 50, PAGE 69
2)	
2)		XCTU [HLLZ F,0(E)]	; Fetch his flags again
2)		MOVEI F1,0		; And clear others
2)	
2)		MOVE A,STRPNT(TXT)	; Reinit pointer to input string
2)		MOVEM A,LDPNT(TXT)
2)		SETZM LDCNT(TXT)	;ZAP THE INPUT COUNT
2)	
2)		CALL SETTMP		; Get another temp block and continue


LINE 3, PAGE 72
1)	QNAM:	TQNN <DIRSF>		; Any directory stars?
1)		CALL QSNAM		; No, append star and find first file
1)		 JRST QUEST2		; Directory stars or no match
1)		DO.
1)		HLRZ A,FILNEN(JFN)	; Print this name
1)		CALL QNXTL
1)		CALL QVNAM0		; Now look for the next name
1)		 JRST QUEST0		; None left, beep and retype
1)		CALL GSIBE		; Anything input?
1)		 JRST QUEST1		; Yes, quit
1)		LOOP.			; go print it
1)		ENDDO.
1)	
1)	; Here we had a ? while entering an extension
1)	
1)	QEXT:	TQNN <DIRSF,NAMSF>	; Any directory or name stars?
1)		CALL QSEXT		; No, append star and find first file
1)		 JRST QUEST2		; Stars or no match
1)		DO.
LINE 3, PAGE 70
2)	QNAM:	TQNE <DIRSF>		;CS82B Any directory stars?

; GTJFN.MAC.3 & GTJFN.GXJFN.1 19-Apr-88 0111	PAGE 77


2)		 JRST QUEST2		;CS82B Yup - ding him
2)		TMSG </ file name/>	;CS82B Start message
2)		PUSHJ P,QSNAM		; No, append star and find first file
2)		 JRST QNAMNM		;CS82B No match
2)		TMSG </, one of the following: 
2)	/>
2)		SETZM DRTLN		;CS82B Line length is 0
2)		DO.
2)		HLRZ A,FILNEN(JFN)	; Print this name
2)		PUSHJ P,QNXTL
2)		PUSHJ P,QVNAM0		; Now look for the next name
2)		 JRST QUEST0		; None left, beep and retype
2)		PUSHJ P,GSIBE		; Anything input?
2)		 JRST QUEST1		; Yes, quit
2)		TMSG </,/>		;CS82B ...
2)		LOOP.			; go print it
2)		ENDDO.
2)	
2)	QNAMNM:	TMSG </ (no matches found)
2)	/>				;CS82B
2)		JRST QUEST3		;CS82B
2)	
2)	; Here we had a ? while entering an extension
2)	
2)	QEXT:	TQNE <DIRSF,NAMSF>	;CS82B Any directory or name stars?
2)		 JRST QUEST2		;CS82B Ding
2)		TMSG </ file extension/> ;CS82B
2)		PUSHJ P,QSEXT		; No, append star and find first file
2)		 JRST QNAMNM		;CS82B No match
2)		TMSG </, one of the following:
2)	/>				;CS82B
2)		SETZM DRTLN		;CS82B Line length is 0
2)		DO.


LINE 29, PAGE 72
1)		CALL QNXTL
1)		CALL QVEXT0		; Now look for the next extension
1)		 JRST QUEST0		; None left, beep and retype
1)		CALL GSIBE		; Anything input?
1)		 JRST QUEST1		; Yes, quit
1)		LOOP.			; go print it
LINE 44, PAGE 70
2)		PUSHJ P,QNXTL
2)		PUSHJ P,QVEXT0		; Now look for the next extension
2)		 JRST QUEST0		; None left, beep and retype
2)		PUSHJ P,GSIBE		; Anything input?
2)		 JRST QUEST1		; Yes, quit
2)		TMSG </,/>		;CS82B
2)		LOOP.			; go print it


; GTJFN.MAC.3 & GTJFN.GXJFN.1 19-Apr-88 0111	PAGE 78



LINE 39, PAGE 72
1)	QVER:	TQNN <DIRSF,NAMSF,EXTSF>  ; Any dir, name, or ext stars?
1)		CALL QSVER		; No, make it a star and find first file
1)		 JRST QUEST2		; Stars or no match
1)		DO.
1)		TMSG </
1)	  />				; No, print this number
1)		HRRZ B,FILVER(JFN)
1)		CALL DNOUT
1)		CALL QVVER0		; Now look for the next version
1)		 JRST QUEST0		; None left, beep and retype
1)		CALL GSIBE		; Anything input?
1)		 JRST QUEST1		; Yes, quit
1)		LOOP.			; go print it
1)		ENDDO.
1)	^L
1)	; Following are routines for stepping the Name, Ext, and Version
1)	; fields and assuring that at least one file is accessible with the
LINE 55, PAGE 70
2)	QVER:	TQNE <DIRSF,NAMSF,EXTSF> ;CS82B Any dir, name, or ext stars?
2)		 JRST QUEST2		;CS82B Ding
2)		TMSG </ file version/>	;CS82B
2)		PUSHJ P,QSVER		; No, make it a star and find first file
2)		 JRST QNAMNM		;CS82B No match
2)		TMSG </, one of the following:
2)	/>				;CS82B
2)		DO.
2)		TMSG </ />		;CS82B
2)		HRRZ B,FILVER(JFN)
2)		PUSHJ P,DNOUT
2)		PUSHJ P,QVVER0		; Now look for the next version
2)		 JRST QUEST0		; None left, beep and retype
2)		PUSHJ P,GSIBE		; Anything input?
2)		 JRST QUEST1		; Yes, quit
2)		TMSG </,/>		;CS82B
2)		LOOP.			; go print it
2)		ENDDO.
2)	^L; Following are routines for stepping the Name, Ext, and Version
2)	; fields and assuring that at least one file is accessible with the


; GTJFN.MAC.3 & GTJFN.GXJFN.1 19-Apr-88 0111	PAGE 79



LINE 13, PAGE 73
1)		CALL LKPTR		; Need a lookup ptr
1)	QVNAM1:	TQO <NAMSF,STEPF>
1)		CALL NAMLKX		; Find the next one
1)		 RET			; Match is impossible
1)		NOINT			; Match
LINE 12, PAGE 71
2)		PUSHJ P,LKPTR		; Need a lookup ptr
2)	QVNAM1:	TQO <NAMSF,STEPF>
2)		PUSHJ P,NAMLKX		; Find the next one
2)		 RET			; Match is impossible
2)		 RET			; Ambiguous
2)		NOINT			; Match


LINE 23, PAGE 73
1)		CALL SETTMP		; And reinit FILTMP ptr
1)		 RETBAD
1)		CALL QVEXT		; Now look for acceptable ext and ver
1)		 JRST QVNAM0		; None for this name, step it
LINE 23, PAGE 71
2)		PUSHJ P,SETTMP		; And reinit FILTMP ptr
2)		 RETBAD
2)		PUSHJ P,QVEXT		; Now look for acceptable ext and ver
2)		 JRST QVNAM0		; None for this name, step it


LINE 34, PAGE 73
1)		CALL LKPTR		; Need a lookup ptr
1)	QVEXT1:	TQO <EXTSF,STEPF>
1)		CALL EXTLKX		; Find the next one
1)		 RET			; No more, return +1
LINE 34, PAGE 71
2)		PUSHJ P,LKPTR		; Need a lookup ptr
2)	QVEXT1:	TQO <EXTSF,STEPF>
2)		PUSHJ P,EXTLKX		; Find the next one
2)		 RET
2)		 RET			; No more, return +1


LINE 44, PAGE 73
1)		CALL SETTMP		; And reinit FILTMP ptr
1)		 RETBAD
1)		CALL QVVER		; Now look for acceptable ver
1)		 JRST QVEXT0		; None for this ext, step it
LINE 45, PAGE 71
2)		PUSHJ P,SETTMP		; And reinit FILTMP ptr
2)		 RETBAD
2)		PUSHJ P,QVVER		; Now look for acceptable ver

; GTJFN.MAC.3 & GTJFN.GXJFN.1 19-Apr-88 0111	PAGE 80


2)		 JRST QVEXT0		; None for this ext, step it


LINE 57, PAGE 73
1)		CALL GTVER		; Go find next one and check access
1)		 RET			; None, return +1
1)		RETSKP			; Finally we have an acceptable one
1)					; Return +2
1)	^L
1)	; Routine to locate a file version with acceptable access privileges
1)	; Entry:   A = desired version number
LINE 58, PAGE 71
2)		PUSHJ P,GTVER		; Go find next one and check access
2)		 RET			; None, return +1
2)		RETSKP			; Finally we have an acceptable one
2)					; Return +2
2)	^L; Routine to locate a file version with acceptable access privileges
2)	; Entry:   A = desired version number


LINE 12, PAGE 74
1)		CALL VERLUK		; No, don't bother leaving it locked
1)		 RET			; Couldn't find it - return +1
LINE 11, PAGE 72
2)		PUSHJ P,VERLUK		; No, don't bother leaving it locked
2)		 RET			; Couldn't find it - return +1


LINE 18, PAGE 74
1)	GTVER1:	CALL VERLKX		; Lookup requested version - return FDB
1)		 RET			; Couldn't get one - return +1
LINE 17, PAGE 72
2)	GTVER1:	PUSHJ P,VERLKX		; Lookup requested version - return FDB
2)		 RET			; Couldn't get one - return +1


LINE 29, PAGE 74
1)		CALL ACCCHK
1)		 JRST GTVER3		; Bad news, see if we can try another
LINE 28, PAGE 72
2)		PUSHJ P,ACCCHK
2)		 JRST GTVER3		; Bad news, see if we can try another


; GTJFN.MAC.3 & GTJFN.GXJFN.1 19-Apr-88 0111	PAGE 81



LINE 36, PAGE 74
1)		CALL USTDIR		; OK, release the directory
1)		RETSKP			; And return +2
1)	
1)	GTVER3:	CALL USTDIR		; Invalid access, release directory
1)		POP P,A			; recover this version number
LINE 35, PAGE 72
2)		PUSHJ P,USTDIR		; OK, release the directory
2)		RETSKP			; And return +2
2)	
2)	GTVER3:	PUSHJ P,USTDIR		; Invalid access, release directory
2)		POP P,A			; recover this version number


LINE 1, PAGE 75
1)	^L
1)	; Routine to skip if input buffer is empty.
1)	; Entry:   From ? routines
1)	; Call:	   CALL GSIBE
1)	; Return:  +1, input not empty or non TTY
LINE 1, PAGE 73
2)	^L; Routine to skip if input buffer is empty.
2)	; Entry:   From ? routines
2)	; Call:	   PUSHJ P,GSIBE
2)	; Return:  +1, input not empty or non TTY


LINE 9, PAGE 76
1)	GSIBE:	CALL INFTST		; Check input JFN
1)		 RET			; Nope, return +1
LINE 8, PAGE 74
2)	GSIBE:	PUSHJ P,INFTST		; Check input JFN
2)		 RET			; Nope, return +1


LINE 18, PAGE 76
1)	; Call:	   CALL QSNAM  name being entered
1)	;          CALL QSEXT  extension being entered
1)	;          CALL QSVER  version being entered
1)	; Return:  +1 always, fake input fields set up
1)	
1)	QSNAM:	CALL QSTAR		; Add a star
1)		CALL ENDNAM		; And find a name
1)		 RET
1)	QSEXT:	CALL QSTAR		; Add a star
1)		CALL ENDEX7		; And find an extension
1)		 RET
1)	QSVER:	CALL QSTAR		; Make a star version
1)		CALL ENDEX7		; And find a version

; GTJFN.MAC.3 & GTJFN.GXJFN.1 19-Apr-88 0111	PAGE 82


1)		 RET
LINE 17, PAGE 74
2)	; Call:	   PUSHJ P,QSNAM  name being entered
2)	;          PUSHJ P,QSEXT  extension being entered
2)	;          PUSHJ P,QSVER  version being entered
2)	; Return:  +1 always, fake input fields set up
2)	
2)	QSNAM:	PUSHJ P,QSTAR		; Add a star
2)		PUSHJ P,ENDNAM		; And find a name
2)		 RET
2)	QSEXT:	PUSHJ P,QSTAR		; Add a star
2)		PUSHJ P,ENDEX7		; And find an extension
2)		 RET
2)	QSVER:	PUSHJ P,QSTAR		; Make a star version
2)		PUSHJ P,ENDEX7		; And find a version
2)		 RET


LINE 37, PAGE 76
1)	; Call:    CALL QSTAR
1)	; Return:  +1 always, * added to input buffers and old file flag set
LINE 36, PAGE 74
2)	; Call:    PUSHJ P,QSTAR
2)	; Return:  +1 always, * added to input buffers and old file flag set


LINE 42, PAGE 76
1)		CALL LTR		; Put it in FILTMP, and set WLDF
1)		 RETBAD()		; Can't
LINE 41, PAGE 74
2)		PUSHJ P,LTR		; Put it in FILTMP, and set WLDF
2)		 RETBAD()		; Can't


LINE 3, PAGE 77
1)	; Call:	   CALL QNXTL
1)	; Return:  +1 always
1)	; Clobbers A,B,C
1)	
1)	QNXTL:	PUSH P,A		; Save block adr for now
1)		TMSG </
1)	  />
1)		POP P,B
LINE 3, PAGE 75
2)	; Call:	   PUSHJ P,QNXTL
2)	; Return:  +1 always
2)	; Clobbers A,B,C
2)	
2)	QNXTL:
2)		PUSH P,A		; Save block adr for now
2)		MOVEI A,1(A)		;CS82B Point past header

; GTJFN.MAC.3 & GTJFN.GXJFN.1 19-Apr-88 0111	PAGE 83


2)		HRLI A,(POINT 7,)	;CS82B Make a byte ptr
2)		MOVEI C,2		;CS82B Count up space separator & comma
2)		DO.			;CS82B
2)		  ILDB B,A		;CS82B Get char
2)		  JUMPE B,ENDLP.	;CS82B Done
2)		  AOJA C,TOP.		;CS82B Inc count, go do next
2)		ENDDO.			;CS82B
2)		MOVE B,C		;CS82B Copy the count
2)		ADDB C,DRTLN		;CS82B Make new line length
2)		CAMG C,DRTWD		;CS82B Is this greater than terminal width?
2)		IFSKP.			;CS82B Yes
2)		  MOVEM B,DRTLN		;CS82B Make new line length
2)		  TMSG </
2)	/>				;CS82B Make a new line
2)		ENDIF.			;CS82B
2)		TMSG </ />		;CS82B Separator
2)		POP P,B


LINE 17, PAGE 77
1)	; Call:	   CALL LKPTR
1)	; Return:  +1, A = lookup pointer:  -# words,,first word - 1
LINE 33, PAGE 75
2)	; Call:	   PUSHJ P,LKPTR
2)	; Return:  +1, A = lookup pointer:  -# words,,first word - 1


LINE 30, PAGE 77
1)	>;IFN STANSW			; [SMXGTJ]
1)	^L
1)	; Set up temp string block for this jfn
LINE 46, PAGE 75
2)	; [SMXGTJ] This is the end of the code for interactive ? handling
2)	
2)	;CS82 *** End ***
2)	
2)	; Set up temp string block for this jfn


LINE 21, PAGE 78
1)		IFNSK.			;IF NOT,
1)		  MOVEI A,MAXSHT	;GET MAX SIZE FOR A NAME THEN
1)		  TQNE <EXTFF>		;ABOUT TO COLLECT AN EXTENSION?
1)		  MOVEI A,MAXEXT	;YES. USE MAX SIZE OF AN EXTENSION THEN
1)		ENDIF.
1)		MOVEM A,FILCNT(JFN)
1)		MOVEM A,CNTWRD(TXT)	;REMEMBER THIS
LINE 69, PAGE 75
2)		 SKIPA			;NO
2)		JRST SETTM2		;YES
2)		MOVEI A,MAXSHT		;GET MAX SIZE FOR A NAME THEN

; GTJFN.MAC.3 & GTJFN.GXJFN.1 19-Apr-88 0111	PAGE 84


2)		TQNE <EXTFF>		;ABOUT TO COLLECT AN EXTENSION?
2)		MOVEI A,MAXEXT		;YES. USE MAX SIZE OF AN EXTENSION THEN
2)	SETTM2:	MOVEM A,FILCNT(JFN)
2)		MOVEM A,CNTWRD(TXT)	;REMEMBER THIS


LINE 22, PAGE 79
1)	
1)	GCH2:	TQZ <STRF>		; No more string input
LINE 22, PAGE 76
2)	GCH2:	TQZ <STRF>		; No more string input


LINE 2, PAGE 80
1)	;SETUP RDTXT BLOCK
1)	
1)	SRDTXT:	PUSH P,B		;SAVE COUNT
1)		IDIVI B,5		;GET NUMBER OF WORDS
1)		SKIPE C			;INTEGRAL NUMBER?
1)		AOS B			;NO. GET ONE MORE WORD FOR THE SLOP
1)		ADDI B,VARC+1		;GET ADDITIONAL WORDS NEEDED
1)		NOINT			;PRESERVE THE SANCTITY OF THE JSB
1)		CALL ASGJFR		;GET SOME SPACE
1)		 JRST [	OKINT		;NOT THERE APPARENTLY
1)			POP P,0(P)	;CLEAN UP THE STACK
1)			ERRLJF (GJFX22)] ;GO COMPLAIN TO THE CALLER
1)		MOVEI TXT,1(A)		;ESTABLISH ARG REGION
1)		HRLI A,(<POINT 7,0,35>)	;MAKE IT A STRING POINTER
1)		HRLM A,FILLNM(JFN)	;SAVE THE BLOCK ADDRESS FOR RELJFN
1)		OKINT			;GOT IT. ALLOW INTERRUPTS
1)		ADDI A,VARC		;TO BEGINNING OF STRING SPACE
1)		HRRZ B,A
1)		SETZM 1(B)		;INITIALIZE FIRST WORD OF STRING TO NULL
1)		SETZM STRPNT(TXT)	;CLEAR RDTXT INPUT
1)		SETZM FLAGS(TXT)	;CLEAR FLAGS
1)		SETZM STPCNT(TXT)	;CLEAR LOGICAL NAME STEP COUNT
1)		POP P,B			;RESTORE ORIGINAL BYTE COUNT
1)		RET
1)	^L
1)	;SETUP INTERNAL ^R BUFFER
1)	
1)	RTYSET:	STKVAR <RTY0P,RTY1P>
1)		MOVX A,RIEFLG		;SEE IF THIS IS A RETURN ON EMPTY CALL
1)		TXNE C,G1%RIE		;...
1)		IORM A,FLAGS(TXT)	;YES, REMEMBER THIS FOR LATER
1)		TXNN C,G1%RBF		;IS ^R BUFFER CONTIGUOUS?
1)		XCTU [SKIPN A,.GJCPP(D)] ;IS THERE A BUFFER?
1)		JRST GJF01		;NO. GO ON
1)		TLC A,-1		;YES. MAKE IT A GOOD POINTER
1)		TLCN A,-1
1)		HRLI A,(<POINT 7,0>)

; GTJFN.MAC.3 & GTJFN.GXJFN.1 19-Apr-88 0111	PAGE 85


1)		IBP A			;AND INCREMENT IT
1)		CALL DBP		;DECREMENT
1)		MOVEM A,RTY0P		;SAVE FINAL POINTER
1)	GJF01:	TQNN <STRF>		;HAVE A STRING POINTER?
1)		IFSKP.
1)		  UMOVE A,2		;YES. GET IT
1)		  IBP A			;INCREMENT IT
1)		  CALL DBP		;AND DECREMENT IT
1)		  MOVEM A,RTY1P		;SAVE IT FOR TESTING
1)		ENDIF.
1)		HRRZ A,E
1)		UMOVE A,.GJRTY(A)	;AND GET ^R POINTER
1)		TLC A,-1		;MAKE ^R POINTER VALID
1)		TLCN A,-1
1)		HRLI A,(<POINT 7,0>)
1)		IBP A			;INCREMENT IT
1)		CALL DBP		;AND DECREMENT IT
1)		MOVE B,A		;AND PUT IT IN B
1)		MOVE D,STRCNT(TXT)	;MAX BYTE COUNT
1)		MOVE A,ARGCR(TXT)	;GET BACK MAIN POINTER
1)		TQNE <STRF>		;FROM A STRING IN MEMORY
1)		JRST GTJ02		;YES - NO CTRL/R BUFFER
1)	GTJTP:	CAME B,RTY1P		;SAME AS MAIN POINTER?
1)		CAMN B,RTY0P		;AT THE END
1)		JRST GTJ02		;YES
1)		XCTBU [ILDB C,B]	;GET A BYTE
1)		JUMPE C,GTJ02		;NULL ENDS BUFFER
1)		SOSGE D			;MAKE SURE THIS ONE FITS
1)		ERRLJF (GJFX51)		;IT DOESN'T
1)		IDPB C,A		;COPY INTO MONITOR BUFFER
1)		JRST GTJTP		;GO DO MORE
1)	
1)	GTJ02:	HRRZM D,STRCNT(TXT)	;BYTE SIZE
1)		RET
1)	^L
1)	;SETUP USER-PROVIDED JFN
1)	
1)	USRJFN:	HRRZ JFN,E
1)		XCTU [SKIPL JFN,10(JFN)]	; Yes, get his version of jfn
1)		CAIL JFN,MJFN
1)		ERRLJF GJFX1,<MOVEM JFN,ERRSAV>
1)		CAIE JFN,.PRIIN		;PRIMARY INPUT?
1)		CAIN JFN,.PRIOU		;NO. PRIMARY OUTPUT?
1)		ERRLJF GJFX1,<MOVEM JFN,ERRSAV> ;YES. CANT SPECIFY THAT JFN
1)	GTJFZ2:	NOINT
1)		LOCK JFNLCK
1)	GTJFZ3:	CAMGE JFN,MAXJFN	; Above currently available jfn's?
1)		IFSKP.
1)		  PUSH P,JFN		; Yes, sve this
1)		  MOVE JFN,MAXJFN
1)		  AOS MAXJFN

; GTJFN.MAC.3 & GTJFN.GXJFN.1 19-Apr-88 0111	PAGE 86


1)		  IMULI JFN,MLJFN
1)		  CALL RELJF2
1)		  POP P,JFN
1)		  JRST GTJFZ3
1)		ENDIF.
1)		IMULI JFN,MLJFN		;MAKE IT A USEABLE JFN
1)		SKIPN FILSTS(JFN)	; Is this jfn free?
1)		CAIN JFN,0		;AND NOT 0?
1)		IFSKP.
1)		  CALL ASGJF1		; Yes, assign it
1)		ELSE.
1)		  UNLOCK JFNLCK
1)		  OKINT
1)		  TQNN <JFNAF>
1)		  ERRLJF GJFX2,<MOVEM JFN,ERRSAV>
1)		ENDIF.
1)		RET
1)	^L
1)	; Assign a jfn
LINE 2, PAGE 77
2)	; Assign a jfn


LINE 33, PAGE 83
1)		SETZM FILST1(JFN)	;RESET FLAGS IN FILST1
1)		HRRZ A,FORKN		; Get fork number
1)		HRLZM A,FILVER(JFN)
1)		SETZM FILTMP(JFN)
LINE 33, PAGE 77
2)		HRRZ A,FORKN		; Get fork number
2)		HRLZM A,FILVER(JFN)
2)		SETZM FILST1(JFN)
2)		SETZM FILTMP(JFN)


LINE 40, PAGE 83
1)		SETZM FILNND(JFN)
1)		SETZM FILST1(JFN)
1)		HLLZS FILIDX(JFN)
LINE 40, PAGE 77
2)		HLLZS FILIDX(JFN)


; GTJFN.MAC.3 & GTJFN.GXJFN.1 19-Apr-88 0111	PAGE 87



LINE 48, PAGE 83
1)		SETZRO FLDIR,(JFN)	; ZERO POINTER TO DIR STRING
1)		SETZRO FLATL,(JFN)
1)		SETOM FILLCK(JFN)
LINE 46, PAGE 77
2)		SETZRO FILDIR,(JFN)	; ZERO POINTER TO DIR STRING
2)		SETZRO FILATL,(JFN)
2)		SETOM FILLCK(JFN)


LINE 7, PAGE 84
1)	RELJFN::
1)	RELJFX:
1)		NOINT
1)		LOCK JFNLCK
1)		SKIPN A,FILSTS(JFN)	;ALLREADY RELEASED?
1)		JRST RELJF4		;yes Already released
1)		HRRZ A,FILDEV(JFN)	;GET THE DISPATCH ADDRESS FROM THE JFN
1)		SKIPE A			;DEVICE DISPATCH SET?
1)		CALL @RLJFD(A)		;YES...RELEASE ANY DEVICE SPECIFIC STORAGE
1)	         NOP			;IGNORE NON-SKIP RETURN
1)		MOVE A,FILSTS(JFN)	;GET THE STATUS AGAIN
1)		TXNE A,ASGF		;WAS THIS JFN BEING ASSIGNED?
LINE 7, PAGE 78
2)	RELJFN::CALL RELMT		;SEE IF NEED TO CLEAN UP MT DATA BASE
2)	RELJFX:				;CS161
2)	CS,<	CAIE NUM,PIPDTB>	;CS161 PIPE DEVICES ARE ALSO FUNNY
2)		CAIN NUM,TCPDTB		;CS161 IS THIS TCP?
2)		 CALL @RELJD(DEV)	;YES SO TELL TCP TO DO ITS THING
2)		NOP			;SKIP RETURNS ARE OK
2)		NOINT
2)		LOCK JFNLCK
2)		SKIPN A,FILSTS(JFN)
2)		JRST RELJF4		; Already released
2)		TXNE A,ASGF		;WAS THIS JFN BEING ASSIGNED?


LINE 26, PAGE 84
1)		BLCAL. DSKOK,<<FILDEV(JFN)>> ;REAL DISK?
1)		 SKIPA			;NO
1)		TLNE C,(DV%IN)		;IF AN INPUT DEVICE, DONT SEND MESSAGE
1)		JRST RELJF0		;NOT OPENED, DONT SEND MESSAGE
1)		CALL GETFDB		;GET THE FDB MAPPED
1)		 JRST RELJF0		;FOULED UP, DONT SEND MESSAGE
1)		EA.ENT
1)		MOVE T2,.FBBYV(T1)	;SET UP FOR MESSAGE
LINE 25, PAGE 78
2)		HRRZ B,FILDEV(JFN)	;SEE IF THIS FILE WAS ACTUALLY OPENED
2)		TLNN C,(DV%IN)		;IF AN INPUT DEVICE, DONT SEND MESSAGE

; GTJFN.MAC.3 & GTJFN.GXJFN.1 19-Apr-88 0111	PAGE 88


2)		CAIE B,DSKDTB		;IF IT IS DSK, IT WAS OPENED
2)		JRST RELJF0		;NOT OPENED, DONT SEND MESSAGE
2)		CALL GETFDB		;GET THE FDB MAPPED
2)		 JRST RELJF0		;FOULED UP, DONT SEND MESSAGE
2)		SE1CAL
2)		MOVE T2,.FBBYV(T1)	;SET UP FOR MESSAGE


LINE 38, PAGE 84
1)		 BUG.(CHK,NOSPLM,GTJFN,SOFT,<RELJFN - Could not send spool message to QUASAR>,,<
1)	
1)	Cause:	Could not tell QUASAR of spooled file for output.
1)	
1)	>)
1)	RELJF0:	CALL RELJF3		;RELEASE COMMON STUFF
LINE 37, PAGE 78
2)		 BUG(NOSPLM)
2)	RELJF0:	CALL RELJF3		;RELEASE COMMON STUFF


LINE 9, PAGE 85
1)		LOAD B,FLNOD,(JFN)	;RELEASE NODE IF ANY
1)		SKIPE B
1)		CALL RELFRE
1)		HLRZ B,FILDDN(JFN)
1)		SKIPE B
1)		CALL RELFRE		; Release device string block
1)		LOAD B,FLDIR,(JFN)	;SEE IF THERE IS A DIR NAME STRING
1)		SKIPE B
LINE 9, PAGE 79
2)		HLRZ B,FILDDN(JFN)
2)		SKIPE B
2)		CALL RELFRE		; Release device string block
2)		LOAD B,FILDIR,(JFN)	;SEE IF THERE IS A DIR NAME STRING
2)		SKIPE B


LINE 24, PAGE 85
1)		LOAD B,FLDMS,(JFN)	; GET DIR WILD MASK
1)		SKIPE B			; HAVE ONE?
1)		CALL RELFRE		; YES. RELEASE IT
1)		LOAD B,FLNMS,(JFN)	; NAME WILD MASK
1)		SKIPE B			; HAVE ONE?
1)		CALL RELFRE		; YES. RELEASE IT
1)		LOAD B,FLEMS,(JFN)	; EXTENSION WILD MASK
1)		SKIPE B			; HAVE ONE?
LINE 21, PAGE 79
2)		LOAD B,FILDMS,(JFN)	; GET DIR WILD MASK
2)		SKIPE B			; HAVE ONE?
2)		CALL RELFRE		; YES. RELEASE IT
2)		LOAD B,FILNMS,(JFN)	; NAME WILD MASK

; GTJFN.MAC.3 & GTJFN.GXJFN.1 19-Apr-88 0111	PAGE 89


2)		SKIPE B			; HAVE ONE?
2)		CALL RELFRE		; YES. RELEASE IT
2)		LOAD B,FILEMS,(JFN)	; EXTENSION WILD MASK
2)		SKIPE B			; HAVE ONE?


LINE 36, PAGE 85
1)		STOR B,FLDMS,(JFN)	; CLEAR DIR WILD MASK
1)		STOR B,FLNMS,(JFN)	; CLEAR NAME WILD MASK
1)		STOR B,FLEMS,(JFN)	; CLEAR EXTENSION WILD MASK
1)		CALL RELATR		; GO RELEASE ATTRIBUTE LIST
LINE 33, PAGE 79
2)		STOR B,FILDMS,(JFN)	; CLEAR DIR WILD MASK
2)		STOR B,FILNMS,(JFN)	; CLEAR NAME WILD MASK
2)		STOR B,FILEMS,(JFN)	; CLEAR EXTENSION WILD MASK
2)		CALL RELATR		; GO RELEASE ATTRIBUTE LIST


LINE 47, PAGE 85
1)	;**;[7206] INSERT 2 LINES AT RELJF1:-7.L	DSW	12/04/85
1)		TXNE B,TRNSF		;[7206] WAS THIS JFN TRANSITIONAL?
1)		JRST RELJF1		;[7206] YES, NO TEMP BLOCK TO RELEASE
1)		HRRZ B,FILTMP(JFN)
1)		SKIPE B
1)		CALL RELFRE		; Release temp block
1)		LOAD B,FLTSD,(JFN)	; RELEASE OTHER TEMP BLOCK
1)	ifn nicsw,<;temp kludge till bug is found
1)		cain b,1000		;if this value only (?8-bit pointer?)
1)		 setz b,		;then don't try to release it
1)	>;ifn nicsw
1)		SKIPE B			; IF ANY
LINE 44, PAGE 79
2)		HRRZ B,FILTMP(JFN)
2)		SKIPE B
2)		CALL RELFRE		; Release temp block
2)		HLRZ B,FILTMP(JFN)	; RELEASE OTHER TEMP BLOCK
2)		SKIPE B			; IF ANY


LINE 69, PAGE 85
1)		SETZRO FLDIR,(JFN)	;ZERO DIR NAME STRING AREA
1)		MOVE B,FILSTS(JFN)	;SAVE THIS IN CASE IT IS NEEDED
LINE 59, PAGE 79
2)		SETZRO FILDIR,(JFN)	;ZERO DIR NAME STRING AREA
2)		MOVE B,FILSTS(JFN)	;SAVE THIS IN CASE IT IS NEEDED


; GTJFN.MAC.3 & GTJFN.GXJFN.1 19-Apr-88 0111	PAGE 90



LINE 76, PAGE 85
1)	RELATR:	LOAD B,FLATL,(JFN)	;GET POINTER TO ATTRIBUTE LIST
1)		JUMPE B,R		;IF EMPTY, THEN DONE
1)		LOAD C,PRFXL,(B)	;GET POINTER TO NEXT ITEM ON LIST
1)		STOR C,FLATL,(JFN)	;REMOVE FIRST ITEM FROM CHAIN
1)		LOAD C,PRFXS,(B)	;GET SIZE OF BLOCK
LINE 66, PAGE 79
2)	RELATR:	LOAD B,FILATL,(JFN)	;GET POINTER TO ATTRIBUTE LIST
2)		JUMPE B,R		;IF EMPTY, THEN DONE
2)		LOAD C,PRFXL,(B)	;GET POINTER TO NEXT ITEM ON LIST
2)		STOR C,FILATL,(JFN)	;REMOVE FIRST ITEM FROM CHAIN
2)		LOAD C,PRFXS,(B)	;GET SIZE OF BLOCK


LINE 5, PAGE 87
1)	;	CALL ENDSTX
1)	; Returns with a null deposited on the end of the string and
LINE 5, PAGE 81
2)	;	CALL ENDSTR
2)	; Returns with a null deposited on the end of the string and


LINE 10, PAGE 87
1)	ENDSTX::MOVE A,FILOPT(JFN)
1)		MOVEI B,0
LINE 10, PAGE 81
2)	ENDSTR::MOVE A,FILOPT(JFN)
2)		MOVEI B,0


LINE 8, PAGE 89
1)	; Clobbers A,B,C
1)	;
1)	;Returns:	+1:	Always
1)	;
1)	;	CALL TSTRQC
1)	;
1)	;Accepts:	B/ Address of first byte of remainder of string to be typed
1)	;
1)	;This routine is used by DEFNAM, DEFEXT, RECNAM, and RECEXT to insure 
1)	;that the field which is being recognized is of a valid length.  This is
1)	;only of interest when G1%NLN is set in the GTJFN call (no long names).
1)	;Clobbers A,B,C.
1)	;
1)	;Return:	+1:	Error - field is too long (G1%NLN is in effect)
1)	;		+2:	Success
1)	
1)	TSTRQC:	CALL LENOK 		;(/A) Check on length of field
1)		 RETBAD()		;Invalid length - return error

; GTJFN.MAC.3 & GTJFN.GXJFN.1 19-Apr-88 0111	PAGE 91


1)		CALL TSTRQ		;(B) Length is ok - complete field
1)		RETSKP			;Return success
1)	
LINE 8, PAGE 83
2)	; Clobbers a,b
2)	


LINE 33, PAGE 89
1)	TSTR: 	MOVEI A,0		;NO QUOTEING
1)	TSTR0:	STKVAR <TSTRA>
LINE 14, PAGE 83
2)	TSTR:	MOVEI A,0		;NO QUOTEING
2)	TSTR0:	STKVAR <TSTRA>


LINE 66, PAGE 89
1)	;**;[7300] Add 1 line at TSTR1:+8L	MDR	23-MAY-86
1)		ERJMP IOERR		;[7300] Catch JSYS error
1)		RET
1)	^L
1)	;LENOK - Routine to check the length of the field being output.
1)	;It is needed for GTJFN calls with G1%NLN set and recognition is being
1)	;performed.  We must check the length of the field we are returning to 
1)	;insure that it is not "long".  This routine is only needed when
1)	;recognition is used on the filename or extension before the maximum
1)	;number of allowable characters is entered.  Otherwise, the 
1)	;code at DPST handles the invalid field length.
1)	;
1)	;Returns:	+1:	Invalid length - error code is in A
1)	;		+2:	Length is valid
1)	;
1)	;Uses registers A,C, and D.  Preserves B.
1)	
1)	LENOK:	CALL TSTLNG		;Are long names allowed?
1)		IFSKP.			;Yes
1)		  RETSKP		;Nothing more to do then
1)		ENDIF.
1)		LOAD C,FLNSB,(JFN)	;Get the pointer to the file name
1)		TQNE <EXTF>		;Parsing an extension?
1)		LOAD C,FLESB,(JFN)	;Yes, so get to pointer to the extension
1)		HRLI C,(<POINT 7,0,34>)	;Point to the first character
1)		SETZM D			;Init character counter
1)		DO.
1)	       	  ILDB A,C		;Get a character
1)		  JUMPE A,LENOK1	;No more to get
1)		  AOS D			;Count the character
1)		  JRST TOP.		;Get another one
1)		ENDDO.
1)	LENOK1:	MOVEI C,MAXSHT		;Get max size for a name
1)		MOVEI A,GJFX41		;Get correct error code

; GTJFN.MAC.3 & GTJFN.GXJFN.1 19-Apr-88 0111	PAGE 92


1)		TQNN <EXTF>		;Parsing an extension?
1)		IFSKP.			;Yes
1)		  MOVEI C,MAXEXT	;Use max size of an extension then
1)		  MOVEI A,GJFX42	;And get correct error code
1)		ENDIF.
1)	       	CAMLE D,C          	;Are we over the limit?
1)		RET			;Yes, return the error code
1)		RETSKP			;Not over the limit - return success
1)	^L
1)	;ROUTINE TO CHECK IF A CHARACTER NEEDS QUOTING
LINE 47, PAGE 83
2)		RET
2)	
2)	
2)	;ROUTINE TO CHECK IF A CHARACTER NEEDS QUOTING


LINE 35, PAGE 92
1)	;**;[7300] Add 1 line at OUTCH1:+7L	MDR	23-MAY-86
1)		ERJMP IOERR		;[7300] Catch JSYS error
1)		RET
1)	^L
1)	;TEST FOR INPUT STRING COMING FROM A FILE
1)	; RETURN +1: NOT COMING FROM FILE
1)	;	+2: COMING FROM FILE, A/ JFN
1)	
1)	INFTST:	HRRZ A,E
1)		XCTU [HLRZ A,.GJSRC(A)]
1)		TXNE E,-1B17		;FULL BLOCK?
1)		TXNE E,GJ%FNS		;NO, JFN'S SUPPLIED?
1)		CAIN A,.NULIO		;AND NULL?
1)		RET			;NOT FILE
1)		RETSKP			;FILE
1)	
1)	;SET MODES ON INPUT FILE IF THERE IS ONE
1)	
1)	SETINF:	CALL INFTST
1)		 JRST GTJFZ1
1)		RFCOC
1)		DMOVEM B,INFCOC
1)		RFMOD			;GET MODE BITS TOO
1)		TXZ B,TT%OSP		;FORGET OUTPUT SUPPRESS
1)		MOVEM B,INFMOD
1)		TRZ B,3B29		;CLEAR DATA MODE FIELD
1)		TRO B,17B23+1B29	;SET BREAK ON EVERYTHING
1)		SFMOD			;AND PUT IT IN EFFECT
1)		CALL SFCC0
1)	GTJFZ1:	RET
1)	
1)	;RESTORE INFILE MODES WHEN LEAVING GTJFN
1)	

; GTJFN.MAC.3 & GTJFN.GXJFN.1 19-Apr-88 0111	PAGE 93


1)	ENDINF:	CALL INFTST
1)		 JRST ENDL55		;NO INPUT FILE
1)		MOVE B,INFMOD
1)		SFMOD			;SET IT BACK
1)		DMOVE B,INFCOC
1)		SFCOC
1)	ENDL55:	RET
1)	
LINE 35, PAGE 84
2)		RET
2)	
2)	INFTST:	HRRZ A,E
2)		XCTU [HLRZ A,1(A)]
2)		TLNE E,777777
2)		TLNE E,2
2)		CAIN A,377777
2)		RET
2)		RETSKP
2)	
2)	;CS82 *** Begin ***
2)	OTFTST:	HRRZ A,E
2)		XCTU [HRRZ A,1(A)]
2)		TLNE E,777777
2)		TLNE E,2
2)		CAIN A,377777
2)		RET
2)		RETSKP
2)	;CS82 *** End ***
2)	


LINE 46, PAGE 93
1)		 RET
1)		SFCOC
LINE 62, PAGE 84
2)		RET
2)		SFCOC


LINE 30, PAGE 94
1)	;**;[7300] Replace 1 line at ANOUT:+7L	MDR	23-MAY-86
1)		ERJMP IOERR		;[7300] Catch JSYS error
1)		RET
LINE 30, PAGE 85
2)		RET
2)		RET


; GTJFN.MAC.3 & GTJFN.GXJFN.1 19-Apr-88 0111	PAGE 94



LINE 42, PAGE 94
1)	ERRDO2:	CALL ENDINF		;RESTORE TTY MODES
1)		POP P,A			;ERROR CODE
1)		RETERR ()		;AND GO TO ERROR EXIT
LINE 41, PAGE 85
2)	ERRDO2:	CALL INFTST
2)		 JRST ERRDO1		;ALL DONE
2)		MOVE D,0(P)		;ERROR CODE
2)		MOVE P,MPP
2)		ADD P,BHC+3		;POINT TO SAVED WORDS
2)		POP P,B			;RECOVER SAVED MODES
2)		SFMOD
2)		POP P,C
2)		POP P,B
2)		SFCOC
2)		SKIPA A,D		;SET UP ERROR
2)	ERRDO1:	POP P,A			;ERROR CODE
2)		RETERR ()		;AND GO TO ERROR EXIT


LINE 4, PAGE 95
1)	BACKIT:	
1)	IFE STANSW,<			; Partial recognition
1)		MOVE A,CURPNT(TXT)	;TAIL POINTER
1)		BKJFN			;MOVE OVER RECOGNITION CHARACYER
1)		 JFCL
1)	> ;IFE STANSW			; Partial recognition
1)	
1)	IFN STANSW,<			; Partial recognition
1)	; N.B. Beware of TRVARs Clobbering TXT 
1)		SETO T1,		;MOVE OVER RECOGNITION CHARACTER
1)		ADJBP T1,CURPNT(TXT)	;TAIL POINTER 
1)	> ;IFN STANSW			; Partial recognition
1)	
LINE 4, PAGE 86
2)	BACKIT:
2)	REPEAT 0,<			;CS82 [SMXGTJ] Partial recognition
2)		MOVE A,CURPNT(TXT)	;TAIL POINTER
2)		BKJFN			;MOVE OVER RECOGNITION CHARACYER
2)		 JFCL
2)	>;REPEAT 0			;CS82 [SMXGTJ] Partial recognition
2)	;CS82 [SMXGTJ] *** Begin *** (partial recognition)
2)	; N.B. Beware of TRVARs Clobbering TXT 
2)		SETO T1,		;MOVE OVER RECOGNITION CHARACTER
2)		ADJBP T1,CURPNT(TXT)	;TAIL POINTER
2)	;CS82 [SMXGTJ] *** End *** (partial recognition)
2)	


; GTJFN.MAC.3 & GTJFN.GXJFN.1 19-Apr-88 0111	PAGE 95



LINE 1, PAGE 96
1)	^L
1)	;ROUTINE TO STEP A LOGICAL NAME TO NEXT SET OF DEFAULTS
LINE 24, PAGE 86
2)	
2)	;ROUTINE TO STEP A LOGICAL NAME TO NEXT SET OF DEFAULTS


LINE 58, PAGE 98
1)		ENDTV.			;END TRVAR AT .GTJFN ENTRY
1)	^L
LINE 58, PAGE 87
2)	;CS82T-TL11 - Begin Addition
2)	;
2)	; GXJFN%: Support for fast cumulative-incremental dumps and disk scans.
2)	;
2)	; Get next Jfn matching special parameters:
2)	;
2)	; Call: 1/ Indexable File Handle
2)	;	2/ Flags,,Fdb Offset
2)	;	3/ Mask Word (1 => require matching bit, 0 => match not required)
2)	;	4/ Test Word
2)	;
2)	;	This Jsys has 3 cases:
2)	;
2)	;	GX%CUM set in 2:	Cumulative-Incremental Scan: only return
2)	;				Jfns where none of FB%NXF, FB%NEX, FB%DEL,
2)	;				FB%TMP, FB%DIR, FB%NOD is set and where
2)	;				.FBCNT<lh> neq .FBBK0<rh>.  Skip even looking
2)	;				at directories that haven't been marked as
2)	;				written into since the last full dump.
2)	;	GX%FUL set in 2:	Full-Incremental Scan: only returns files
2)	;				where none of the above bits is set, and
2)	;				flags directories scanned as not having
2)	;				been written into since last full dump.
2)	;	Otherwise:		Only return files where word 2<rh> of FDB
2)	;				satisfies the equation:
2)	;
2)	;			(.FDB[.2] and MaskWord) op (TestWord and MaskWord)
2)	;
2)	;				where op is apparent from which of the six
2)	;				other flags is set: GX%EQL, GX%NEQ, GX%LSS,
2)	;				GX%LEQ, GX%GTR, and GX%GEQ.
2)	
2)	.GXJFN::MCENT
2)		STKVAR <OFILUC,GXFLAG,GXFDB> ; OLD STR UNIQUE CODE, TL11
2)		SETOM GXFLAG		;TL11 Indicate came from GXJFN%
2)		JRST GNJFN0		;TL11 Join common code in GNJFN
2)	

; GTJFN.MAC.3 & GTJFN.GXJFN.1 19-Apr-88 0111	PAGE 96


2)	;CS82T-TL11 -End Addition
2)	^L


LINE 14, PAGE 99
1)		ACVAR <JQ1,JQ2>
1)		STKVAR <OFILUC>		; OLD STR UNIQUE CODE
1)		HRRZ JFN,1
1)		CALL CHKJFN
LINE 14, PAGE 88
2)		STKVAR <OFILUC,GXFLAG,GXFDB> ;CS82T-TL11 OLD STR UNIQUE CODE,
2)		SETZM GXFLAG		;CS82T-TL11 Indicate came from GNJFN
2)	GNJFN0:	HRRZ JFN,1		;CS82T-TL11
2)		CALL CHKJFN


LINE 25, PAGE 99
1)		LOAD JQ1,FLUC,(JFN)	;GET STRUCTURE UNIQUE CODE AT START
1)		MOVEM JQ1,OFILUC		; SAVE OLD STR UNIQUE CODE
1)		XCTU [HLLZ F1,1]
1)		AND F1,[GNJMSK]		;KEEP ONLY CERTAIN BITS FROM USER
1)		TXO F1,GNJFF		;REMEMBER THIS IS A GNJFN
1)		TXNN F1,NAMSF		;WANT TO STEP THE NAME?
1)		IFSKP.
1)		  HLRZ A,FILNEN(JFN) 	;YES. GET NAME STRING
1)		  CALL GNJFN3		;GO MAKE SURE IS BIG ENOUGH
1)		   RETERR (GJFX22,<CALL UNLCKF>) ;NOT, AND NO MORE SPACE
1)		  HRLM A,FILNEN(JFN) 	;NEW STRING POINTER
1)		ENDIF.
1)		TXNN F1,EXTSF		;WANT TO STEP THE EXTENSION?
1)		IFSKP.
1)		  HRRZ A,FILNEN(JFN) 	;YES. GET EXTENSION STRING
1)		  CALL GNJFN3		;GO MAKE SURE IS BIG ENOUGH
1)		   RETERR (GJFX22,<CALL UNLCKF>) ;NOT BIG ENOUGH AND NO SPACE
1)		  HRRM A,FILNEN(JFN) 	;NEW STRING
1)		ENDIF.
1)		TXO STS,ASGF!TRNSF	;MARK AS TRANSITIONAL
LINE 25, PAGE 88
2)		LOAD Q1,FILUC,(JFN)	;GET STRUCTURE UNIQUE CODE AT START
2)		MOVEM Q1,OFILUC		; SAVE OLD STR UNIQUE CODE
2)		XCTU [HLLZ F1,1]
2)		AND F1,[GNJMSK]		;KEEP ONLY CERTAIN BITS FROM USER
2)		TXO F1,GNJFF		;REMEMBER THIS IS A GNJFN
2)		TXNE F1,NAMSF		;WANT TO STEP THE NAME?
2)		JRST [	HLRZ A,FILNEN(JFN) ;YES. GET NAME STRING
2)			CALL GNJFN3	;GO MAKE SURE IS BIG ENOUGH
2)			 RETERR (GJFX22,<CALL UNLCKF>) ;NOT, AND NO MORE SPACE
2)			HRLM A,FILNEN(JFN) ;NEW STRING POINTER
2)			JRST .+1]	;AND DONE
2)		TXNE F1,EXTSF		;WANT TO STEP THE EXTENSION?
2)		JRST [	HRRZ A,FILNEN(JFN) ;YES. GET EXTENSION STRING

; GTJFN.MAC.3 & GTJFN.GXJFN.1 19-Apr-88 0111	PAGE 97


2)			CALL GNJFN3	;GO MAKE SURE IS BIG ENOUGH
2)			 RETERR (GJFX22,<CALL UNLCKF>) ;NOT BIG ENOUGH AND NO SPACE
2)			HRRM A,FILNEN(JFN) ;NEW STRING
2)			JRST .+1]	;DONE
2)		TXO STS,ASGF!TRNSF	;MARK AS TRANSITIONAL


LINE 53, PAGE 99
1)		UMOVE A,1		; GET USER FLAGS
1)		MOVX F,IGDLF+OLDNF	;Assume Ignore Deleted + Old Files Only
1)	;	TXNE A,GJ%GND		;Were deleted files considered? 
1)	;	MOVX F,OLDNF		;No, so do not allow them to be found
1)		HRRZ A,FILVER(JFN)	;GET CURRENT VERSION
LINE 51, PAGE 88
2)	;CS82T-TL11 *** Begin ***
2)		SKIPN GXFLAG		;TL11 Called from GXJFN%?
2)		IFSKP.			;TL11 Yes
2)		  MOVE B,CAPENB		;TL11 Enabled Capabilities
2)		  TXNN B,SC%WHL!SC%OPR	;TL11 Wheel or Operator?
2)		  IFSKP.		;TL11 Yes
2)		    UMOVE A,2		;TL11 Get User Flag Word
2)		    TXNE A,GX%CUM	;TL11 Cumulative-Incremental Flag?
2)		     TXO F1,TCONF	;TL11 Yes, set TCONF flag for MDDDIR
2)		    TXNE A,GX%FUL	;TL11 Full-Incremental Flag?
2)		     TXO F1,DFSTF	;TL11 Yes, set DFSTF flag for MDDDIR
2)		  ENDIF.		;TL11 End Wheel or Operator
2)		ENDIF.			;TL11
2)	;CS82T-TL11 *** End ***
2)		UMOVE A,1		; GET USER FLAGS
2)		MOVX F,IGDLF+OLDNF	;IGNORE DELETED + OLD FILES ONLY
2)		HRRZ A,FILVER(JFN)	;GET CURRENT VERSION


LINE 75, PAGE 99
1)		BLCAL. DSKOK,<DEV>	;SEE IF REAL FDB
1)		 JRST GNJFN2		;ISN'T
1)		CALL GETFDB
1)		 JRST GNJFN1
1)		PUSH P,A
1)		MOVX B,FC%DIR		;B/DIRECTORY-LIST ACCES
1)		CALL ACCCHK
1)		 JRST [	CALL USTDIR
LINE 85, PAGE 88
2)		HRRZ A,DEV
2)		HRRZ A,NLUKD(A)
2)		CAIE A,MDDNAM
2)		 JRST [	SETZ A,
2)			JRST GNJFN2]	; Not fdb for non-mdd devices
2)		CALL GETFDB
2)		 JRST GNJFN1
2)	^L

; GTJFN.MAC.3 & GTJFN.GXJFN.1 19-Apr-88 0111	PAGE 98


2)		MOVEM A,GXFDB		;CS82T-TL11 Save FDB
2)		PUSH P,A
2)		MOVX B,FC%DIR		;B/DIRECTORY-LIST ACCES
2)	;CM366	CALL ACCCHK
2)		CALL ACCOVR		;CM366 If ;A* given, try to override FC%DIR
2)		 JRST [	CALL USTDIR


LINE 98, PAGE 99
1)	GNJFN2:	UMOVE B,1
1)		TLNN B,(1B12)
1)		TXNN A,FB%DEL
1)		IFNSK.
1)		  TLNN B,(1B13)
1)		  TXNE A,FB%DEL
1)		   JRST GNJFN1
1)		ENDIF.
1)		TXNE B,GJ%GIV		; Ignore fact file invisible?
1)		TXNN A,FB%INV		; No, is it invisible?
1)		IFSKP. <		; Taking or file visible
1)		  JRST GNJFN1>		; Invisible & not taking
1)		NOINT			;PROTECT THINGS AGAIN
LINE 23, PAGE 89
2)	GNJFN2:				;CS82T-TL11 *** Begin ***
2)		SKIPN GXFLAG		;TL11 Called from GXJFN%?
2)		IFSKP.			;TL11 Yes
2)		  UMOVE C,2		;TL11 User Flags
2)		  TXNN C,GX%CUM!GX%FUL	;TL11 Cumulative or Full Incremental?
2)		  IFSKP.		;TL11 Yes
2)		    MOVE D,CAPENB	;TL11 Enabled Capabilities
2)		    TXNN D,SC%WHL!SC%OPR ;TL11 Wheel or Operator?
2)		    IFSKP.		;TL11 Yes
2)		      TXNE A,FB%NXF!FB%NEX!FB%DEL!FB%TMP!FB%DIR!FB%NOD ;TL11 Special?
2)		       JRST GNJFN1	;TL11 Yes, do not dump
2)		      TXNN C,GX%CUM	;TL11 Cumulative Incremental?
2)		      IFSKP.		;TL11 Yes
2)			MOVE B,GXFDB	;TL11 FDB address
2)			HLRZ C,.FBCNT(B) ;TL11 Write Count of File
2)			HRRZ D,.FBBK0(B) ;TL11 Backup Write Count of File
2)		        CAMN C,D	;TL11 File has Same Write Count?
2)		         JRST GNJFN1	;TL11 Yes, do not dump
2)		      ENDIF.		;TL11
2)		    ENDIF.		;TL11
2)		  ELSE.			;TL11 Special FDB Match
2)		    MOVE B,GXFDB	;TL11 FDB address
2)		    LOAD D,FBLEN,(B)	;TL11 Length of FDB
2)		    HRRZ C,C		;TL11 Keep just FDB Offset
2)		    CAML C,D		;TL11 FDB Offset too large?
2)		     JRST GNJFN1	;TL11 Can't possibly match then
2)		    ADD B,C		;TL11 Point into correct word of FDB
2)		    UMOVE C,3		;TL11 Mask Word

; GTJFN.MAC.3 & GTJFN.GXJFN.1 19-Apr-88 0111	PAGE 99


2)		    UMOVE D,4		;TL11 Test Word
2)		    AND	D,C		;TL11 And with Mask Word
2)		    MOVE B,0(B)		;TL11 Fetch Word from FDB
2)		    AND B,C		;TL11 And with Mask Word
2)		    UMOVE C,2		;TL11 Flag Word
2)		    TXNN C,GX%EQL	;TL11 Equal Test?
2)		    IFSKP.		;TL11 Yes
2)		      CAME B,D		;TL11 Test succeeded?
2)		       JRST GNJFN1	;TL11 No, skip this file
2)		      JRST GXJFN1	;TL11 Yes, include this file
2)		    ENDIF.		;TL11
2)		    TXNN C,GX%NEQ	;TL11 Not Equal Test?
2)		    IFSKP.		;TL11 Yes
2)		      CAMN B,D		;TL11 Test succeeded?
2)		       JRST GNJFN1	;TL11 No, skip this file
2)		      JRST GXJFN1	;TL11 Yes, include this file
2)		    ENDIF.		;TL11
2)		    TXNN C,GX%LSS	;TL11 Less Than Test?
2)		    IFSKP.		;TL11 Yes
2)		      CAML B,D		;TL11 Test succeeded?
2)		       JRST GNJFN1	;TL11 No, skip this file
2)		      JRST GXJFN1	;TL11 Yes, include this file
2)		    ENDIF.		;TL11
2)		    TXNN C,GX%LEQ	;TL11 Less Than or Equal Test?
2)		    IFSKP.		;TL11 Yes
2)		      CAMLE B,D		;TL11 Test succeeded?
2)		       JRST GNJFN1	;TL11 No, skip this file
2)		      JRST GXJFN1	;TL11 Yes, include this file
2)		    ENDIF.		;TL11
2)		    TXNN C,GX%GTR	;TL11 Greater Than Test?
2)		    IFSKP.		;TL11 Yes
2)		      CAMG B,D		;TL11 Test succeeded?
2)		       JRST GNJFN1	;TL11 No, skip this file
2)		      JRST GXJFN1	;TL11 Yes, include this file
2)		    ENDIF.		;TL11
2)		    TXNN C,GX%GEQ	;TL11 Greater Than or Equal Test?
2)		    IFSKP.		;TL11 Yes
2)		      CAMGE B,D		;TL11 Test succeeded?
2)		       JRST GNJFN1	;TL11 No, skip this file
2)		      JRST GXJFN1	;TL11 Yes, include this file
2)		    ENDIF.		;TL11
2)		    JRST GNJFN1		;TL11 No match specified
2)		  ENDIF.		;TL11
2)		ENDIF.			;TL11
2)	GXJFN1:				;CS82T-TL11 *** End ***
2)		UMOVE B,1
2)		TLNN B,(1B12)
2)		TXNN A,FB%DEL
2)		 JRST [	TLNN B,(1B13)
2)			TXNE A,FB%DEL
2)			 JRST GNJFN1

; GTJFN.MAC.3 & GTJFN.GXJFN.1 19-Apr-88 0111	PAGE 100


2)			JRST .+1]
2)		TXNE B,GJ%GIV		; Ignore fact file invisible?
2)		TXNN A,FB%INV		; No, is it invisible?
2)		 CAIA			; Taking or file visible
2)		  JRST GNJFN1		; Invisible & not taking
2)		NOINT			;PROTECT THINGS AGAIN


LINE 114, PAGE 99
1)		LOAD JQ2,FLUC,(JFN)	;GET THE CURRENT STRUCTURE UNIQUE CODE
1)		MOVE A,JQ2		;NOW LOCK THIS STRUCTURE
1)		CALL CNVSTR		;...
1)		 JFCL			;IF DISMOUNTED, ERROR WILL BE SEEN LATER
1)		HLRZ A,FILDDN(JFN)	;NOW UPDATE THE DEVICE NAME STRING
1)		CAMN JQ2,OFILUC		;DID IT GET CHANGED DURING THIS GNJFN?
1)		JRST GNJFN4		;NO (WILL NOT CHANGE FOR NON-STRUCTURE DEVICES)
LINE 111, PAGE 89
2)		LOAD Q2,FILUC,(JFN)	;GET THE CURRENT STRUCTURE UNIQUE CODE
2)		MOVE A,Q2		;NOW LOCK THIS STRUCTURE
2)		CALL CNVSTR		;...
2)		 JFCL			;IF DISMOUNTED, ERROR WILL BE SEEN LATER
2)		HLRZ A,FILDDN(JFN)	;NOW UPDATE THE DEVICE NAME STRING
2)		CAMN Q2,OFILUC		;DID IT GET CHANGED DURING THIS GNJFN?
2)		JRST GNJFN4		;NO (WILL NOT CHANGE FOR NON-STRUCTURE DEVICES)


LINE 129, PAGE 99
1)		CAME JQ1,JQ2		;DID THE STR CHANGE DURING THIS CALL?
1)		TXO T1,GN%STR		;YES, TELL THE USER OF THIS CHANGE
LINE 126, PAGE 89
2)		CAME Q1,Q2		;DID THE STR CHANGE DURING THIS CALL?
2)		TXO T1,GN%STR		;YES, TELL THE USER OF THIS CHANGE


LINE 33, PAGE 100
1)		ENDAV.
1)	
1)		TNXEND
1)		END
1)	^L
1)	LINE 33, PAGE 90
2)		TNXEND
2)		END
2)	^L
2)	
2)	