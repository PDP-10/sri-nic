;SRC:<6-1-MONITOR>SETSPD.MAC.2,  3-Jun-86 16:17:40, Edit by KNIGHT
;  Map 19200 to 134 for the DH hack
; UPD ID= 79, SNARK:<6.1.UTILITIES>SETSPD.MAC.9,  13-Feb-85 16:26:29 by GLINDELL
; Maximum-buffer in DCNTA0 should be maximum-bufferS
; UPD ID= 55, SNARK:<6.1.UTILITIES>SETSPD.MAC.8,   6-Dec-84 16:29:17 by GLINDELL
;Check for and suppress NODX16 errors from NODE% jsys in DECNET/NODE command
; UPD ID= 47, SNARK:<6.1.UTILITIES>SETSPD.MAC.7,  17-Nov-84 16:18:03 by MELOHN
;TCO 6.1.1055 - Add LAT-STATE ON or OFF command. Sets LASDEF via SMON%
; UPD ID= 37, SNARK:<6.1.UTILITIES>SETSPD.MAC.6,   6-Nov-84 19:50:42 by TBOYLE
;Fix the TCO number on the previous edit.
; UPD ID= 36, SNARK:<6.1.UTILITIES>SETSPD.MAC.5,   2-Nov-84 19:27:12 by TBOYLE
;TCO 6.1.1034 - Changes to DMPRED, DMPMAP, add MAPSEC for multisection support.
; UPD ID= 34, SNARK:<6.1.UTILITIES>SETSPD.MAC.4,   2-Nov-84 12:23:40 by GLINDELL
;Change VMINOR to 1 since this is now a 6.1 specific SETSPD
; UPD ID= 612, SNARK:<6.UTILITIES>SETSPD.MAC.63,  18-Oct-84 14:44:54 by TBOYLE
;TCO 6.2253 (QAR 706284) wait for CI disks during dump processing.
; UPD ID= 611, SNARK:<6.UTILITIES>SETSPD.MAC.62,  17-Oct-84 16:22:59 by GRANT
;In DCARE, pick up unit from correct offset before doing the SMON%
; UPD ID= 608, SNARK:<6.UTILITIES>SETSPD.MAC.61,  14-Oct-84 14:34:39 by GLINDELL
;TCO 6.1.1006 - Add DECNET DEFAULT-FLOW-CONTROL command
; UPD ID= 587, SNARK:<6.UTILITIES>SETSPD.MAC.60,  21-Aug-84 13:34:14 by TBOYLE
;TCO 6.2187 (QAR 706128) At NXTUNT, initialize structure name and alias.
; UPD ID= 586, SNARK:<6.UTILITIES>SETSPD.MAC.58,  20-Aug-84 16:28:18 by TBOYLE
;TCO 6.2183 (QAR 706085) At STRMOU, if no DMP: return. Check structure
; returned by JFNS with STDEV to see if mounting needed. Fix T3 for JFNS.
; UPD ID= 583, SNARK:<6.UTILITIES>SETSPD.MAC.56,  14-Aug-84 14:50:35 by TBOYLE
;New SYSERR - prepare QUELOP for extended addresses in SEBQOU, SEBCDR.
; UPD ID= 582, SNARK:<6.UTILITIES>SETSPD.MAC.55,  14-Aug-84 14:31:48 by TBOYLE
;New SYSERR - Be able to read the new SYSERR blocks. SEBHED, SEBSIZ different.
; UPD ID= 581, SNARK:<6.UTILITIES>SETSPD.MAC.53,  10-Aug-84 18:07:09 by GROSSMAN
;Set minor version number to 0.
; UPD ID= 580, SNARK:<6.UTILITIES>SETSPD.MAC.52,  10-Aug-84 17:59:05 by GROSSMAN
;TCO 6.2170 - Fix ETHERNET <chan> DECNET command to let the monitor figure
;out the correct Ethernet address for a DECnet channel.
; UPD ID= 554, SNARK:<6.UTILITIES>SETSPD.MAC.51,  19-Jun-84 17:18:29 by MCLEAN
;ADD DON'T CARE LOGIC
; UPD ID= 547, SNARK:<6.UTILITIES>SETSPD.MAC.50,   8-Jun-84 11:21:43 by GLINDELL
;TCO 6.1.1006 - Add DECNET commands to provide initial parameters for DECnet
; UPD ID= 535, SNARK:<6.UTILITIES>SETSPD.MAC.49,  24-May-84 20:01:15 by GLINDELL
;TCO 6.1.1005 - Accept area number in DECnet node number
; UPD ID= 531, SNARK:<6.UTILITIES>SETSPD.MAC.48,  15-May-84 13:08:56 by TBOYLE
;REMOVE  TCO 6.1637, SPEAR COUNTER STUFF. IT'S DONE IN SYSERR NOW.
; UPD ID= 519, SNARK:<6.UTILITIES>SETSPD.MAC.47,  17-Apr-84 10:37:43 by GROSSMAN
;TCO 6.2036 - Add ETHERNET command to set Ethernet address.
; UPD ID= 498, SNARK:<6.UTILITIES>SETSPD.MAC.45,   5-Mar-84 16:19:02 by MOSER
;MORE 6.1562  - READ SERIAL NUMBERS IN DECIMAL. FIX ERROR MESSAGE
; UPD ID= 492, SNARK:<6.UTILITIES>SETSPD.MAC.44,  29-Feb-84 17:59:09 by PRATT
;TCO 6.1956 - Add ENABLE/DISABLE FAST-LOGIN-OPTION
; UPD ID= 476, SNARK:<6.UTILITIES>SETSPD.MAC.43,   8-Feb-84 14:02:57 by TBOYLE
;More TCO 6.1934 Change 22 to ^D22 at SETCN1.
; UPD ID= 470, SNARK:<6.UTILITIES>SETSPD.MAC.42,   8-Feb-84 10:05:16 by EVANS
;Add flag to edit number so I VER will display it in decimal.
; UPD ID= 465, SNARK:<6.UTILITIES>SETSPD.MAC.41,   8-Feb-84 08:37:15 by MCINTEE
;Change NODNAM routine to set the node number first.
; UPD ID= 458, SNARK:<6.UTILITIES>SETSPD.MAC.40,  25-Jan-84 18:58:50 by MOSER
;STILL MORE 6.1562 - FIX A BUG
; UPD ID= 456, SNARK:<6.UTILITIES>SETSPD.MAC.39,  25-Jan-84 09:57:16 by MOSER
;FIX AN ERROR IN 6.1934 - SETSPD WON'T BUILD
; UPD ID= 449, SNARK:<6.UTILITIES>SETSPD.MAC.38,  23-Jan-84 17:27:13 by TBOYLE
;More TCO 6.1934 Cleanup GTJFN error messages.
; UPD ID= 446, SNARK:<6.UTILITIES>SETSPD.MAC.37   23-Jan-84 16:24:13 by TBOYLE
;TCO 6.1948 - Fix JSYER0 to output the actual error message
; UPD ID= 445, SNARK:<6.UTILITIES>SETSPD.MAC.36,  23-Jan-84 16:16:40 by MOSER
;TCO 6.1562 - CHANGE FORMAT OF ALLOW / RESTRICT
; UPD ID= 437, SNARK:<6.UTILITIES>SETSPD.MAC.34,  18-Jan-84 13:45:32 by PAETZOLD
;TCO 6.1941 - ENA/DIS HANGUP-IF-LOGGED-IN/OUT commands need alphabetical order.
;TCO 6.1938 - add support for ena/dir system-message-level-0/1 commands.
; UPD ID= 435, SNARK:<6.UTILITIES>SETSPD.MAC.33,  17-Jan-84 19:47:02 by TBOYLE
;TCO 6.1937 - ENA/DIS HANGUP-IF-LOGGED-IN/OUT code.
; UPD ID= 431, SNARK:<6.UTILITIES>SETSPD.MAC.32,  13-Jan-84 17:28:47 by TBOYLE
;TCO 6.1934 - At SETCNT determine a new SPRCNT from ERROR.SYS properly.
; UPD ID= 397, SNARK:<6.UTILITIES>SETSPD.MAC.31,   9-Dec-83 21:49:16 by MCLEAN
;WORK ON THE NEW INTERNAL ERROR FORMATS
;MISSING COUNTS SPEAR RUNNING COUNT
; UPD ID= 357, SNARK:<6.UTILITIES>SETSPD.MAC.30,   5-Oct-83 22:27:46 by MCLEAN
;TCO 6.1819 MAKE SEBHED 2 (NOTE THIS REALLY IS NOT A GOOD SYMBOL NAME)
; UPD ID= 352, SNARK:<6.UTILITIES>SETSPD.MAC.29,  21-Sep-83 14:28:11 by TGRADY
; TCO 6.1804.  Don't mount the DMP: structure exclusively...
; UPD ID= 351, SNARK:<6.UTILITIES>SETSPD.MAC.28,  16-Sep-83 15:49:51 by MCLEAN
;PUT SEBHED BACK TO 4 WORDS SINCE JSYS HASN'T CHANGED
; UPD ID= 297, SNARK:<6.UTILITIES>SETSPD.MAC.27,  20-Jun-83 13:14:40 by MOSER
;TCO 6.1562 SERVICE, ALLOW, RESTRICT COMMANDS FOR MSCP SERVER
; UPD ID= 284, SNARK:<6.UTILITIES>SETSPD.MAC.26,  17-May-83 14:18:11 by LOMARTIRE
;TCO 6.1634 - Allow SETSPD to timeout if a command takes more than 30 sec.
; UPD ID= 282, SNARK:<6.UTILITIES>SETSPD.MAC.25,  11-May-83 15:17:06 by COBB
;TCO 6.1637 - Teach SETSPD to read the SPEAR counter from the dump and SMON% it
; UPD ID= 261, SNARK:<6.UTILITIES>SETSPD.MAC.24,  16-Apr-83 17:10:42 by PAETZOLD
;TCO 6.1616 - TCP Changes.  Break the ARPANET HOST command.
; UPD ID= 206, SNARK:<6.UTILITIES>SETSPD.MAC.23,   9-Feb-83 14:02:18 by WEETON
; UPD ID= 135, SNARK:<6.UTILITIES>SETSPD.MAC.22,  23-Sep-82 16:01:00 by MOSER
;TCO 6.1278 - BLT CORRECT NUMBER OF WORDS AT SPEED:
; UPD ID= 123, SNARK:<6.UTILITIES>SETSPD.MAC.21,   1-Sep-82 14:34:02 by HAUDEL
;TCO 6.1241 - Close DUMP.CPY when error occurs so lost pages are not created.
; UPD ID= 110, SNARK:<6.UTILITIES>SETSPD.MAC.20,   4-Aug-82 13:43:19 by CDUNN
;TCO 6.1189 (Again) - Fix bug in STRMOU code. Now ERJMP to MSTR error routine
;so RET takes you back to CPYDMP instead of back into the MSTR routine.
;Makes not finding dump structure work.
; UPD ID= 102, SNARK:<6.UTILITIES>SETSPD.MAC.19,  26-Jul-82 00:27:32 by CDUNN
;Add a <CRLF> before the dismount of the dump structure. Makes CTY more
;readable...
; UPD ID= 101, SNARK:<6.UTILITIES>SETSPD.MAC.18,  19-Jul-82 22:29:56 by CDUNN
;TCO 6.1189 Teach CPYDMP to mount the structure implied by DMP:. Also
;dismount when done.
; UPD ID= 45, SNARK:<6.UTILITIES>SETSPD.MAC.17,  19-May-82 10:51:21 by MILLER
; UPD ID= 44, SNARK:<6.UTILITIES>SETSPD.MAC.16,  19-May-82 10:43:09 by MILLER
;TCO 6.1142. ADD ENABLE/DISABLE COMMANDS FOR SYSTEM ERROR MESSAGES
; UPD ID= 30, SNARK:<6.UTILITIES>SETSPD.MAC.15,  22-Feb-82 10:23:58 by MURPHY
;yet again
; UPD ID= 29, SNARK:<6.UTILITIES>SETSPD.MAC.14,  19-Feb-82 15:34:56 by MURPHY
;More of same.
; UPD ID= 28, SNARK:<6.UTILITIES>SETSPD.MAC.13,  18-Feb-82 17:24:52 by MURPHY
;TCO 6.1060 - Copy dumps to DMP: instead of PS:<SYSTEM>
; UPD ID= 21, SNARK:<6.UTILITIES>SETSPD.MAC.12,  17-Jan-82 19:13:45 by PAETZOLD
;TCO 5.1681 - fix the change command
; UPD ID= 9, SNARK:<6.UTILITIES>SETSPD.MAC.11,   2-Nov-81 09:58:21 by PAETZOLD
;TCO 6.1035 - Update version information for release 6
; UPD ID= 26, SNARK:<5.UTILITIES>SETSPD.MAC.10,  31-Aug-81 09:33:07 by PAETZOLD
;TCO 5.1461 - read and interpret MMAP when getting queued SYSERR blocks
; UPD ID= 18, SNARK:<5.UTILITIES>SETSPD.MAC.9,   3-Aug-81 12:51:24 by ZIMA
;TCO 5.1438 - Include Friday in "ALL" entry in day-of-week table.
; UPD ID= 8, SNARK:<5.UTILITIES>SETSPD.MAC.8,  20-Jul-81 15:54:57 by MOSER
;TCO 5.1424 CHANGE BACKGROUND COMMAND TO BATCH-BACKGROUND.
; UPD ID= 2311, SNARK:<5.UTILITIES>SETSPD.MAC.7,   8-Jul-81 15:23:12 by DONAHUE
;TCO 5.1401 - Add TU77 entry to SLAVT table
; UPD ID= 2100, SNARK:<5.UTILITIES>SETSPD.MAC.6,  28-May-81 11:55:31 by PAETZOLD
;TCO 5.1352 - Change error handler to not complain about invalid
;keywords when started at start4.  This will prevent J0NRUN BUGHLT's
; UPD ID= 2070, SNARK:<5.UTILITIES>SETSPD.MAC.5,  24-May-81 15:35:52 by ZIMA
;TCO 5.1346 - EDIT 21 - pass proper MO%LCP setting on all subsequent LPINI
; calls for a unit.
; UPD ID= 1769, SNARK:<5.UTILITIES>SETSPD.MAC.4,  25-Mar-81 17:49:49 by GRANT
;Update Copyright
; UPD ID= 1367, SNARK:<5.UTILITIES>SETSPD.MAC.3,  18-Dec-80 10:25:34 by WACHS
;TCO 5.16 - ADD TM78 DEFINITION
; UPD ID= 524, SNARK:<5.UTILITIES>SETSPD.MAC.2,  15-May-80 13:33:16 by LYONS
;tco 5.1040 - Make release 5 look for 5-CONFIG.CMD
; UPD ID= 325, SNARK:<4.1.UTILITIES>SETSPD.MAC.5,  12-Mar-80 14:16:04 by OSMAN
;tco 4.1.1107 - Make release 4.1 look for 4-1-CONFIG.CMD
; UPD ID= 299, SNARK:<4.1.UTILITIES>SETSPD.MAC.3,  29-Feb-80 13:22:36 by OSMAN
;tco 4.1.1096 - Use COMND instead of TEXTI so as to allow "POLICY-PROGRAM"
; UPD ID= 102, SNARK:<4.1.UTILITIES>SETSPD.MAC.2,   6-Dec-79 11:05:53 by BLOUNT
;<4.1.UTILITIES>SETSPD.MAC.2,  6-Dec-79 10:55:56, EDIT BY BLOUNT
;TCO #4.2590 -CHANGE AT QUEDN1+7 TO FIX KS HALT STATUS BLOCK BUG
;<4.UTILITIES>SETSPD.MAC.44,  9-Oct-79 15:26:55, EDIT BY GRANT
;<4.UTILITIES>SETSPD.MAC.43, 25-May-79 13:02:47, EDIT BY MILLER
;FIX QUEBLK. IT WAS COMPUTING # OF PAGES TO DUMP OFF-BY-ONE
;<4.UTILITIES>SETSPD.MAC.42, 11-Apr-79 15:57:49, Edit by LCAMPBELL
; Fix up addressing of SYERR block at QUEDN1
;<4.UTILITIES>SETSPD.MAC.41, 13-Mar-79 08:50:11, EDIT BY KONEN
;UPDATE COPYRIGHT FOR RELEASE 4
;<4.UTILITIES>SETSPD.MAC.40, 13-Mar-79 06:50:04, EDIT BY R.ACE
;TAKE OUT TAPE-MOUNT-DEFAULT COMMAND
;ADD TAPE-RECOGNITION-ERRORS COMMAND
;<4.UTILITIES>SETSPD.MAC.39, 21-Feb-79 11:36:40, EDIT BY MURPHY
;ENABLE/DISABLE WORKING SET PRELOADING - DLM
;<4.UTILITIES>SETSPD.MAC.38, 20-Feb-79 17:43:04, EDIT BY BLOUNT
;CHANGE CLASS-SCHEDULER TO CLASS-SCHEDULING
;<4.UTILITIES>SETSPD.MAC.37, 19-Feb-79 14:22:43, Edit by MCLEAN
;FIX IT SO ECSKED WITH ARGUMENTS GIVES ERROR
;<4.UTILITIES>SETSPD.MAC.36, 19-Feb-79 13:24:27, Edit by MCLEAN
;CORRECT SPELLING OF WITHHELD
;<4.UTILITIES>SETSPD.MAC.35, 24-Jan-79 10:51:08, EDIT BY R.ACE
;MOVE TAPE-RECYCLE-PERIOD TO RIGHT PLACE, UPDATE EDIT#
;<4.UTILITIES>SETSPD.MAC.34, 11-Dec-78 06:52:19, EDIT BY R.ACE
;PUT ERJMP'S AFTER SYERR CALLS
;<4.UTILITIES>SETSPD.MAC.33, 28-Nov-78 08:04:16, EDIT BY R.ACE
;TCO 4.2098 - ADD TAPE-MOUNT-DEFAULT COMMAND
;ADD COMND JSYS ROUTINES FOR PARSING NEW SETSPD COMMANDS
;<ARC-DEC>SETSPD.MAC.3,  3-Oct-78 09:50:04, EDIT BY CALVIN
; Cause GTKEY to eat all of hypenated command name
;<ARC-DEC>SETSPD.MAC.1, 29-Sep-78 15:58:56, EDIT BY CALVIN
; Add ARCHIVE-TAPE-RECYCLE-PERIOD and TAPE-RECYCLE-PERIOD
;<4.UTILITIES>SETSPD.MAC.31, 20-Oct-78 19:16:54, EDIT BY MILLER
;<4.UTILITIES>SETSPD.MAC.30, 20-Oct-78 19:13:31, EDIT BY MILLER
;<4.UTILITIES>SETSPD.MAC.29, 20-Oct-78 19:12:53, EDIT BY MILLER
;TCO 4.2011. ADD BATCH-CLASS COMMAND
;<4.UTILITIES>SETSPD.MAC.28, 19-Oct-78 17:49:03, Edit by MCLEAN
;MAKE SKED JSYS BE SKED%
;<2MCLEAN>SETSPD.MAC.27, 24-Sep-78 21:56:05, Edit by MCLEAN
;<2MCLEAN>SETSPD.MAC.26, 21-Sep-78 21:22:18, Edit by MCLEAN
;<4.UTILITIES>SETSPD.MAC.25, 20-Sep-78 11:35:08, EDIT BY MILLER
;<4.UTILITIES>SETSPD.MAC.24, 19-Sep-78 12:57:51, EDIT BY MILLER
;<4.UTILITIES>SETSPD.MAC.23, 19-Sep-78 12:56:37, EDIT BY MILLER
;MORE OF TCO 4.2011
;<4.UTILITIES>SETSPD.MAC.22, 19-Sep-78 12:12:05, EDIT BY MILLER
;<4.UTILITIES>SETSPD.MAC.21, 19-Sep-78 12:10:50, EDIT BY MILLER
;TCO 4.2011. ADD ENABLE OPTIONS FOR CLASS SCHEDULER
;<4.UTILITIES>SETSPD.MAC.20, 19-Sep-78 11:27:50, EDIT BY MILLER
;<4.UTILITIES>SETSPD.MAC.19, 19-Sep-78 11:25:05, EDIT BY MILLER
;TCO 4.2011 AGAIN. ADD CREATE COMMAND
;<4.UTILITIES>SETSPD.MAC.18, 17-Sep-78 14:05:21, EDIT BY MILLER
;TCO 4.2011. IMPLEMENT "BATCH-BACKGROUND" COMMAND
;<4.UTILITIES>SETSPD.MAC.17, 24-Aug-78 12:07:17, EDIT BY R.ACE
;TCO 4.1993 - ADD COMMAND: ENABLE TAPE-DRIVE-ALLOCATION
;ADDED COMMENTING TO BEGINNING OF MODULE
;<R.ACE.LT>SETSPD.MAC.4, 23-Aug-78 16:44:38, EDIT BY R.ACE
;<R.ACE.LT>SETSPD.MAC.3, 23-Aug-78 13:19:33, EDIT BY R.ACE
;<R.ACE.LT>SETSPD.MAC.2, 23-Aug-78 12:12:30, EDIT BY R.ACE
;<2MCLEAN>SETSPD.MAC.17, 28-Jul-78 15:36:32, Edit by MCLEAN
;<3A.UTILITIES>SETSPD.MAC.16, 26-Jul-78 15:00:29, Edit by MCLEAN
;<4.UTILITIES>SETSPD.MAC.13, 18-Jul-78 14:10:12, EDIT BY MILLER
;CHANGE VERSION NUMBER TO 4
;<4.UTILITIES>SETSPD.MAC.12, 16-May-78 09:23:45, EDIT BY MILLER
;ADD MINOR VERSION TO CONFIG FILE NAME
;<4.UTILITIES>SETSPD.MAC.11,  6-May-78 22:17:11, Edit by MCLEAN
;<3A.UTILITIES>SETSPD.MAC.21,  4-Aug-78 13:13:02, Edit by MCLEAN
;<3A.UTILITIES>SETSPD.MAC.20,  4-Aug-78 13:11:23, Edit by MCLEAN
;<3A.UTILITIES>SETSPD.MAC.19,  3-Aug-78 17:12:20, Edit by MCLEAN
;<3A.UTILITIES>SETSPD.MAC.18, 28-Jul-78 15:33:15, Edit by MCLEAN
;<3A.UTILITIES>SETSPD.MAC.17, 27-Jul-78 14:41:21, EDIT BY MILLER
;INCREMENT EDIT NUMBER
;<3A.UTILITIES>SETSPD.MAC.16, 26-Jul-78 15:00:29, Edit by MCLEAN
;<3A.UTILITIES>SETSPD.MAC.15, 16-May-78 09:21:33, EDIT BY MILLER
;<3A.UTILITIES>SETSPD.MAC.14, 16-May-78 09:19:58, EDIT BY MILLER
;<3A.UTILITIES>SETSPD.MAC.13, 16-May-78 09:17:32, EDIT BY MILLER
;AND CHANGE VERSION TO 3A
;<3A.UTILITIES>SETSPD.MAC.12, 16-May-78 09:16:35, EDIT BY MILLER
;ADD MINOR VERSION TO CONFIG NAME
;<1MCLEAN>SETSPD.MAC.17,  4-May-78 18:31:02, Edit by MCLEAN
;<1MCLEAN>SETSPD.MAC.16,  4-May-78 18:24:33, Edit by MCLEAN
;<1MCLEAN>SETSPD.MAC.15,  4-May-78 17:37:31, Edit by MCLEAN
;<1MCLEAN>SETSPD.MAC.14,  4-May-78 17:22:55, Edit by MCLEAN
;<1MCLEAN>SETSPD.MAC.13,  4-May-78 17:22:03, Edit by MCLEAN
;<1MCLEAN>SETSPD.MAC.12,  4-May-78 16:22:12, Edit by MCLEAN
;<1MCLEAN>SETSPD.MAC.11,  4-May-78 16:16:56, Edit by MCLEAN
;TCO 1880 ADD SLAVE TYPES TO MTALN JSYS
;<4.UTILITIES>SETSPD.MAC.9,  9-Apr-78 13:24:57, EDIT BY MILLER
;MERGE IN CHANGES TO NODE COMMAND FROM 3A SOURCE
;<4.UTILITIES>SETSPD.MAC.8,  7-Apr-78 00:40:43, Edit by MCLEAN
;<3A.UTILITIES>SETSPD.MAC.9,  7-Apr-78 00:15:05, Edit by MCLEAN
;<3A.UTILITIES>SETSPD.MAC.8,  7-Apr-78 00:13:21, Edit by MCLEAN
;<3A.UTILITIES>SETSPD.MAC.7,  7-Apr-78 00:07:24, Edit by MCLEAN
;ADD HSB (HALT STATUS BLOCK) FOR KS10
;<4.UTILITIES>SETSPD.MAC.5,  2-Mar-78 15:04:19, Edit by PORCHER
;<4.UTILITIES>SETSPD.MAC.4, 28-Feb-78 14:35:36, Edit by PORCHER
;<4.UTILITIES>SETSPD.MAC.3, 28-Feb-78 14:25:25, Edit by PORCHER
;ADD "CHANGE" COMMAND FOR ACCOUNTING SHIFT CHANGES
;<4.UTILITIES>SETSPD.MAC.2, 31-Jan-78 00:41:13, Edit by MCLEAN
;MAGTAPE ONLINE ENTRY VECTOR UPDATES
;<4.UTILITIES>SETSPD.MAC.2, 16-Dec-77 14:01:29, EDIT BY MILLER
;<4.UTILITIES>SETSPD.MAC.1, 16-Dec-77 13:56:02, EDIT BY MILLER
;TCO 1879. ADD NODE COMMAND

;THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY ONLY BE USED
;  OR COPIED IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
;COPYRIGHT (C) 1976,1977,1978,1979,1980,1981 BY DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.

	SEARCH MONSYM,MACSYM,SERCOD,CMD
	.REQUIRE SYS:MACREL,SYS:CMD
	TITLE SETSPD
	SALL
	.DIRECTIVE FLBLST	;SUPPRESS LENGTHY BINARY EXPANSIONS

; VERSION NUMBER DEFINITIONS

VMAJOR==6		;MAJOR VERSION OF SETSPD
VMINOR==1		;MINOR VERSION NUMBER
VEDIT==1VI%DEC+^D22	;EDIT NUMBER
VWHO==0			;GROUP WHO LAST EDITED PROGRAM (0=DEC DEVELOPMENT)

VSTSPD== <VWHO>B2+<VMAJOR>B11+<VMINOR>B17+VEDIT

; THIS PROGRAM IS RUN BY JOB 0 TO PERFORM VARIOUS USER-MODE
; FUNCTIONS THAT AFFECT THE OPERATION OF THE SYSTEM

; DEPENDING UPON THE DESIRED ACTION, THE PROGRAM IS STARTED AT
; ONE OF SEVERAL POSITIONS IN ITS ENTRY VECTOR.

; POS	DESCRIPTION
; ---	--------
;
;  0	CALLED ONCE DURING SYSTEM STARTUP BY RUNDD ROUTINE IN MEXEC.
;	READS FILE "SYSTEM:x-CONFIG.CMD" FOR COMMANDS:
;	  CHANGE - set accounting shift change times
;	  DEFINE - define system-wide logical names
;	  ENABLE/DISABLE account validation
;	  ENABLE/DISABLE directory-parameter setting by non-priv users
;	  ENABLE/DISABLE use of hardware disk optimization feature
;	  ENABLE/DISABLE magtape drive assignment by MTCON
;	  HOST - set ARPANET host number of this CPU
;	  MAGTAPE - logical magtape units (e.g. MTA3:) with
;		actual serial numbers
;	  NODE - set DECNET node name and number for this CPU
;	  PRINTER - load VFU and RAM files and set lowercase attribute
;	  TERMINAL - set auto-baud, nobell, remote, and speed
;		attributes of terminals
;	  TIMEZONE - set time zone for this site
;
;  1	THIS ENTRY IF FUNCTIONALLY EQUIVALENT TO POSITION 0,
;	BUT IT IS NOT USED BY THE MONITOR.
;
;  2 	CONTAINS PROGRAM VERSION NUMBER.
;
;  3	CALLED BY RUNDD ROUTINE IN MEXEC DURING SYSTEM
;	INITIALIZATION AFTER A CRASH TO:
;	1. Copy PS:<SYSTEM>DUMP.EXE to PS:<SYSTEM>DUMP.CPY
;	2. Extract unrecorded SPEAR entries from DUMP.EXE and
;	   log them using the SYERR JSYS
;
;  4	CALLED BY CHKR ROUTINE IN MEXEC WHILE SYSTEM IS RUNNING
;	WHENEVER PHYSIO DETECTS THAT A TAPE DRIVE HAS COME ONLINE
;	AND PHYSIO DIDN'T KNOW ABOUT THE DRIVE AT SYSTEM STARTUP.
;	THE CONFIG FILE IS READ AS IF ENTERED AT ENTRY VECTOR
;	POSITION 0, EXCEPT ONLY THE "MAGTAPE" COMMANDS IN THE
;	FILE ARE PROCESSED; ALL OTHER COMMANDS ARE IGNORED.
SUBTTL SETSPD DATA


DICT:	0			;FREE SPACE HEADER
CSBUFP:	0			;SCRATCH STRING POINTER
STRSIZ==100			;NUMBER OF SCRATCH STRING WORDS TO ALLOCATE

SPDTBL==560000			;SPEED TABLE
REMTBL==570000			;REMOTE TABLE
FREE==600000			;WHERE FREE SPACE STARTS
FRESIZ==50000			;SIZE OF FREE SPACE

JFN:	0			;JFN OF INPUT COMMAND FILE

DATBLK:	BLOCK 3			;FOR IDTNC STUFF FROM COMND (.CMTAD FUNCTION)

SMONBK:	BLOCK .SVDSN+1		;BLOCK FOR SMON FOR ALLOW / RESTRICT

LODLCP:	BLOCK <LPTN==2>		;FLAG NONZERO FOR LOWERCASE PRINTER
CLSBLK:	3			;COUNT
	BLOCK 2			;DATA ARE
MTBLK:	3			;SIZE OF BLOCK
	BLOCK 2			;FOR OTHER ARGS
EOLF:	BLOCK 1
PDLEN=500			;LENGTH OF PUSH-DOWN STACK
PDL:	BLOCK PDLEN		;PUSH-DOWN STACK
PAGMAX:	BLOCK 1			;WORD TO HOLD HIGHEST DUMP PAGE NUMBER
FILNAM:	BLOCK ^D28		;NAME OF RAM OR VFU FILE PUT HERE
LINES:	BLOCK 1			;WORD TO HOLD LINES
STRBLK:	BLOCK .MSSLN		;BLOCK FOR STRUCTURE COMMAND
HSBBUF:	BLOCK HS%LEN		;LENGTH OF HSB AND HEADER

DMPSTR:	BLOCK 2			;Hold the dump structure name here
ALISTR:	BLOCK 2			;Hold the structure alias of current str here
STRFLG:	BLOCK 1			;Flag whether we have a structure to dismount
NUMUNT:	BLOCK 1			;Number of units in the dump structure
UNTLFT:	BLOCK 1			;Number of units let unmounted in structure
CURSTR:	BLOCK 2			;Name of the structure currently being examined
TIMVAL:	BLOCK 1			;Timer value to retry for structure.
RTYTIM:	EXP ^D30000		;Amount of time for retry, 30 seconds.

ASCTBL:	BLOCK <ASCTBZ==^D100>+1	;ACCOUNTING SHIFT CHANGE TABLE

	CPYPGS==^D10		;# OF PAGES TO COPY WITH EACH PMAP
	CPYWDS==CPYPGS_PGSFT	;NUMBER OF WORDS TO COPY
	PGSFT==11		;PAGE SHIFT VALUE
PG0PG==30			;PAGE 0 OF DUMP.EXE
	PG0ADR=PG0PG_PGSFT
TMPPG==31			;2 PAGES FOR TEMPORARY MAPPING
	TMPADR=TMPPG_PGSFT
MMPPG==33			;PAGE FOR MAPPING MMAP PAGE
	MMPADR=MMPPG_PGSFT
DMPPG==40			;PAGE FOR MAPPING DUMP FILE
	DMPADR==DMPPG_PGSFT
CPYPG==DMPPG+CPYPGS		;PAGE FOR MAPPING COPY FILE
	CPYADR==CPYPG_PGSFT
MAPPG==CPYPG+CPYPGS		;PAGE FOR BUILDING DUMP FILE MAP
	MAPADR=MAPPG_PGSFT
ESYPG==MAPPG+CPYPGS		;PAGE FOR MAPPING ERROR.SYS
	ESYSAD==ESYPG_PGSFT

MSTRPG==700			;Page 700 is for building MSTR args
MSTRAD==700000			;Base address of MSTR page
MNTBLK==710000			;Where to build mount blocks within page

CMDSTG				;STORAGE FOR COMND JSYS

;PROGRAM ENTRY VECTOR

ENTVEC:	JRST START		;STARTING LOCATION
	JRST START		;REENTER LOCATION
	VSTSPD			;VERSION NUMBER
	JRST START3		;ALTERNATE STARTING LOCATION
	JRST START4		;MTA ONLINE ENTRY VECTOR

ENVLEN==.-ENTVEC		;ENTRY VECTOR LENGTH

;COMMAND TABLES:

;****************************************************************
;
;	WARNING!!!
;
;	THESE TABLES MUST BE KEPT IN ALPHABETICAL ORDER FOR TBLUK
;
;****************************************************************

ALTLVT:	ALTSIZ-1,,ALTSIZ-1	;COMMANDS ALLOWED WHEN A DEVICE COMES ONLINE
	T ALLOW,ALLOW
	T DONTCARE,DCARE
	T MAGTAPE,MAGTAP
	T RESTRICT,RESTRI
	ALTSIZ==.-ALTLVT

; TABLE OF DISK DRIVE TYPES FOR ALLOW AND RESTRICT COMMANDS

DSKTAB:	EDSKTB-.-1,,EDSKTB-.-1
	T RP04,.MSRP4		;RP04
	T RP05,.MSRP5		;RP05
	T RP06,.MSRP6		;RP06
	T RP07,.MSRP7		;RP07
	T RP20,.MSR20		;RP20
EDSKTB:

LEV1TB:	ELEVL1-.-1,,ELEVL1-.-1
	T ALLOW,ALLOW
	T ARCHIVE-TAPE-RECYCLE-PERIOD,ARCHIV
	T BATCH-BACKGROUND,BATBGD
	T BATCH-CLASS,BCHCLS
	T BIAS,BIAS
	T CHANGE,CHANGE
	T CREATE,CREATE
	T DAYLIGHT,DAYLIG
	T DECNET,DECNET
	T DEFINE,DEFINE
	T DISABLE,DISABL
	T DONTCARE,DCARE
	T ENABLE,ENABLE
	T ETHERNET,ETHERN
	T HOST,HOST
	T LAT-STATE,LAT
	T MAGTAPE,MAGTAP
	T NODE,NODNAM
	T PRINTER,LPTLOD
	T RESTRICT,RESTRI
	T TAPE-RECOGNITION-ERRORS,TRECER
	T TAPE-RECYCLE-PERIOD,TAPRCY
	T TERMINAL,TERM
	T TIMEZONE,TIMZON
ELEVL1:

;TABLE FOR TERMINAL CHARACTERISTICS

LEV2TB:	ELEVL2-.-1,,ELEVL2-.-1
	T AUTO-BAUD,AUTO
	T NOBELL,NOBELL
	T REMOTE,REMOTE
	T SPEED,SPEED
PMPPAG==CPYPG+CPYPGS		;PAGE MAP PAGES
ELEVL2:

MOREBT==1B0			;THERE'S MORE OF COMMAND

; TABLE OF OPTIONS FOR ENABLE COMMANDS

ENAOPT:	ENASIZ-1,,ENASIZ-1
	T ACCOUNT-VALIDATION,[ENACCT]
	T CLASS-SCHEDULING,[MOREBT!ECSKED]
	T DIRECTORY-PARAMETER-SETTING,[ENADIR]
	T FAST-LOGIN-OPTION,[ENAFST]
	T FULL-LATENCY-OPTIMIZATION,[ENAFLO]
	T HANGUP-IF-LOGGED-IN,[ENAHLI]
	T HANGUP-IF-LOGGED-OUT,[ENAHLO]
	T JOB0-CTY-OUTPUT,[J0OUTE]
	T SYSTEM-MESSAGE-LEVEL-0,[ENALV0]
	T SYSTEM-MESSAGE-LEVEL-1,[ENALV1]
	T TAPE-DRIVE-ALLOCATION,[ENATDA]
	T WORKING-SET-PRELOADING,[ENAWSP]

	ENASIZ==.-ENAOPT

; TABLE OF OPTIONS FOR DISBLE COMMANDS

DISOPT:	DISSIZ-1,,DISSIZ-1
	T ACCOUNT-VALIDATION,[DISACT]
	T DIRECTORY-PARAMETER-SETTING,[DISDIR]
	T FAST-LOGIN-OPTION,[DISFST]
	T FULL-LATENCY-OPTIMIZATION,[DISFLO]
	T HANGUP-IF-LOGGED-IN,[DISHLI]
	T HANGUP-IF-LOGGED-OUT,[DISHLO]
	T JOB0-CTY-OUTPUT,[J0OUTD]
	T SYSTEM-MESSAGE-LEVEL-0,[DISLV0]
	T SYSTEM-MESSAGE-LEVEL-1,[DISLV1]
	T WORKING-SET-PRELOADING,[DISWSP]
	DISSIZ==.-DISOPT

; TABLE OF OPTIONS FOR LOADING PRINTERS

LPTTAB:	LPTBSZ-1,,LPTBSZ-1
	T LOWERCASE, .MOSTS
	T RAM, .MOLTR
	T VFU, .MOLVF

	LPTBSZ==.-LPTTAB

SLAVT:	SLVBSZ-1,,SLVBSZ-1
	T TU45,.MTT45		;TU45
	T TU70,.MTT70		;TU70
	T TU71,.MTT71
	T TU72,.MTT72		;TU72
	T TU73,.MTT73
	T TU77,.MTT77		;TU77
	T TU78,.MTT78		;TU78
	SLVBSZ==.-SLAVT


;TABLE OF DAYS OF WEEK FOR "CHANGE" COMMAND

DOWTAB:	XWD DOWTBZ-1,DOWTBZ-1
	T ALL,<<1B0!1B1!1B2!1B3!1B4!1B5!1B6>_-^D18>
	T FRIDAY,<<1B4>_-^D18>
	T MONDAY,<<1B0>_-^D18>
	T SATURDAY,<<1B5>_-^D18>
	T SUNDAY,<<1B6>_-^D18>
	T THURSDAY,<<1B3>_-^D18>
	T TUESDAY,<<1B1>_-^D18>
	T WEDNESDAY,<<1B2>_-^D18>
	T WEEKDAYS,<<1B0!1B1!1B2!1B3!1B4>_-^D18>
	T WEEKENDS,<<1B5!1B6>_-^D18>
	DOWTBZ=.-DOWTAB

;TABLE FOR TYPE OF CLASS SCHEDULING DESIRED

SKDOPT:	SKDSIZ-1,,SKDSIZ-1
	T ACCOUNTS,0
	T POLICY-PROGRAM,1
SKDSIZ==.-SKDOPT

;TABLE FOR LAT-STATE ON AND OFF

LATSTA:	LATSIZ-1,,LATSIZ-1
	T OFF,LS.OFF
	T ON,LS.ON
LATSIZ==.-LATSTA

;TABLE FOR DAYLIGHT SAVING TIME HANDLING

DSTOPT:	DSTSIZ-1,,DSTSIZ-1
	T AUTOMATIC,.DSTAU
	T OFF,.DSTNV
	T ON,.DSTAL
DSTSIZ==.-DSTOPT

;TABLE FOR WINDFALL HANDLING

SKDOP0:	SKDSZ0-1,,SKDSZ0-1
	T ALLOCATED,0
	T WITHHELD,1
SKDSZ0==.-SKDOP0

;Table for DECNET parameters

DCNTA0:	DCNSZ0-1,,DCNSZ0-1
	T BUFFER-SIZE,[.NDBSZ,,DCNNUM]
	T DEFAULT-BUFFERS-PER-LINK,[.NDDBL,,DCNNUM]
	T DEFAULT-FLOW-CONTROL,[.NDFLO,,NSPFLO]
	T MAXIMUM-ADDRESS,[.NDMXA,,DCNNUM]
	T MAXIMUM-BUFFERS,[.NDMXB,,DCNNUM]
	T ROUTER-ENDNODE,[.NDRTR,,ROUEND]
	T ROUTER-LEVEL-1,[.NDRTR,,ROULV1]
DCNSZ0==.-DCNTA0

;Table for DECNET DEFAULT-FLOW-CONTROL

FLOTAB:	FLOSZ0-1,,FLOSZ0-1
	T NONE,[FCM.NO]
	T SEGMENT,[FCM.SG]
FLOSZ0==.-FLOTAB


;DEFINE REGISTERS USED

A==1				;OLD WAY...
B==2
C==3
D==4

	STDAC.			;AND THE NEW WAY...

;USEFUL DEFINITIONS

DEFSTR SEBSIZ,2,35,12		;POINTER TO SIZE FIELD IN SYSERR BLOCK
DEFSTR SEBERC,HSBBUF,8,9

STGADR==:<MASKB 12,35>		;MASK FOR STORAGE ADDRESSES (IMMEDIATE POINTERS
				; OR SPT ENTRIES)
PTRCOD==:<MASKB 0,2>		;CODE FIELD IN PAGE POINTER
SPTX==:<MASKB 18,35>		;MASK FOR SPT INDICES

   IFN 0,<
	SPRCNT=113		;ADDRESS OF RUNNING SPEAR ENTRY COUNT
   >	;REMOVAL OF SPRCNT CODE.
	SEBQOU=24		;ADDRESS OF POINTER TO SYSERR QUEUE
	MMAPWD=25		;ADDRESS OF POINTER TO MMAP PAGE
	SPTWD=237		;ADDRESS OF POINTER TO SPT
	MSECWD=240		;ADDRESS OF POINTER TO MSECTB
	SEBHED==3		;NUMBER OF HEADER WORDS IN SYSERR BLOCK
	ESYCNT==4		;OFFSET IN SYSERR HEADER FOR ENTRY COUNTER

MSCADR:	BLOCK 1			;ADDRESS OF MSECTB 
SPTADR:	BLOCK 1			;ADDRESS OF SPT
SECTN:	BLOCK 1			;SECTION NUMBER FOR MMPPG

TMPJFN:	BLOCK 1			;SAFETY STORAGE FOR JFNS

;DEFINE INTERRUPT SYSTEM TABLES

PCLEV1:	BLOCK 1
PCLEV2:	BLOCK 1
.ICLPO==0			;CHANNEL FOR LINE PRINTER OFFLINE
.ICHNG==1			;CHANNEL FOR TIMER INTERRUPT
HNGTIM==<^D30*^D1000>		;SETSPD IS HUNG IF COMMAND TAKES >30 SECONDS
TIMENA:	BLOCK 1			;FLAG WORD TO SPECIFY IF TIMER PSI ENABLED
UMODF==1B5			;USER MODE FLAG
LEVTAB:	PCLEV1
	PCLEV2
	0
CHNTAB:	XWD 1,LPTINT		;.ICLPO CHANNEL
	XWD 2,HUNG		;.ICHNG CHANNEL
	BLOCK ^D34

;ERROR macro prints error message and dies

DEFINE ERROR (MESS)
<	CALL [	PUSH P,A
		TMSG <
*****************
>
		HRROI A,[ASCIZ /SETSPD: MESS/]
		ESOUT
		TMSG <
*****************
>
		POP P,A
		HALTF
		RET]
>

;MACRO FOR CAUSING A COMMAND ERROR THAT WE DETECT, AS OPPOSED TO ONE THAT
;COMND JSYS DETECTS

DEFINE COMERR (TEXT)
<	CALL [	TMSG <
*****************
>
		HRROI A,[ASCIZ /SETSPD: TEXT/]
		ESOUT
		TMSG <
*****************
>
		JRST CMDER1]
>

DEFINE JSYERR ($TEXT,$INST) <
	ERJMP [	TMSG <
*****************
? SETSPD:>
		TMSG <$TEXT>			;OUTPUT OPTIONAL TEXT
		CALL JSYER0			;OUTPUT JSYS ERROR MSG
		TMSG <
*****************
>
	IFNB <$INST>, <XCT [$INST]>		;DO INSTRUCTION IF THERE
	JRST .+1]>				;AND GO ON


JSYER0::MOVEI .AC1,.PRIOU
	DOBE%			;WAIT FOR OUTPUT TO FINISH
	MOVEI .AC1,.PRIOU		;SET UP FOR ERSTR%
	HRLOI .AC2,.FHSLF
	SETZ .AC3,
	ERSTR%			;PRINT ERROR
	 NOP
	 NOP
	RET






DEFINE EMSG (ETXT) <		;;ERROR-MESSAGE MACRO
	HRROI T1,[ASCIZ/
*****************
? SETSPD: ETXT
*****************
/]
	PSOUT>

	DEFINE BCONFIG (R)  <
	IFE VMINOR,<ASCIZ /SYSTEM:'R'-CONFIG.CMD/>
	IFG VMINOR,<
	 DEFINE BSP (R1,LETT) <
		IRPC LETT,<
		IFE "1"-"'LETT'"+VMINOR-1,<
			ASCIZ /SYSTEM:R1-LETT-CONFIG.CMD/
			STOPI>
		>
		>
	BSP (\VMAJOR,"1234567")>
	>

RCONFG:	BCONFIG (\VMAJOR)
SUBTTL SETSPD PROCEDURE

;ENTRY POINTS FOR READING CONFIG.CMD FILE

START4:	TDZA P5,P5		;INDICATE MTA ONLINE ENTRY
START:	SETOM P5		;INDICATE NORMAL ENTRY
	MOVE P,[IOWD PDLEN,PDL]	;SET UP PUSH DOWN LIST
	CALL INIT		;SET UP PSI, CAPABILITIES, ETC.
	CALL FREINI		;INITIALIZE FREE SPACE
	CALL CMDINI		;INITIALIZE FOR COMND JSYS

;NOW FIND THE COMMAND FILE

	MOVX A,GJ%SHT!GJ%OLD!GJ%PHY
	HRROI B,RCONFG		;SYSTEM:X-CONFIG.CMD
	GTJFN			;FIND THE FILE
	 JRST FINISH		;NOT THERE. GO DEFAULT EVERYTHING
	MOVEM A,JFN		;REMEMBER THE JFN
	MOVE B,[070000,,200000]	;READ ONLY
	OPENF			;GET IT
	 JRST [	MOVEI A,.PRIOU	;THE CTY NO DOUBT
		HRLOI B,.FHSLF	;THIS FORK
		SETZ C,		;NO FLAGS
		ERSTR		;OUTPUT SOMETHING
		 JFCL
		 JFCL
		JRST FINISH]	;AND GO DEFAULT EVERYTHING
	HRL A,JFN		;GET JFN
	HRRI A,.NULIO		;DON'T LET COMND TRY TO TYPE CARRIAGE RETURN BEFORE PROMPT
	MOVEM A,.CMIOJ+SBK	;TELL COMND TO READ FROM FILE
CMND0:	MOVEI A,CMND0		;IF HUNG, CONTINUE AT CMND0
	MOVEM A,HNGCON		;SAVE IT
	MOVEM P,HNGSTK		;SAVE THE STACK
	CALL SETTIM		;SET THE TIME AT WHICH WE WILL BE HUNG
	HRROI A,[0]		;NO PROMPT WHEN READING FROM FILE
	CALL DPROMP		;INITIALIZE COMMAND LINE
	SKIPN P5		;CHECK FOR MAGTAPE ENTRY
	SKIPA A,[[FLDDB. .CMKEY,,ALTLVT]]	;ALTERNATE TABLE
	MOVEI A,[FLDDB. .CMKEY,,LEV1TB]	;THE TABLE
	CALL RFLDE		;READ KEYWORD
	 JRST [	CALL GETERR	;FAILED, SEE WHY
		CAIN A,IOX4	;END OF FILE?
		JRST FINISH	;YES, FINISH UP
		CAIN A,NPXNOM	;INVALID SWITCH OR KEYWORD?
		 SKIPE P5	;AND LOOKING FOR MAGTAPE KEYWORD?
		  JRST CMDERR	;NO SO COMPLAIN AND CONTINUE
		JRST CMND0]	;YES SO IGNORE AND GET NEXT COMMAND
	MOVE B,(B)		;GET TABLE WORD
	AOS NCMDS		;INCREMENT NUMBER OF COMMANDS SEEN
	CALL (B)		;EXECUTE THE COMMAND
	JRST CMND0		;DO REST OF COMMANDS

;GETERR asks monitor for last jsys error code.
;
;Returns+1:	A/	error code

GETERR:	MOVEI A,.FHSLF		;OURSELF
	GETER			;GET ERROR
	HRRZ A,B		;KEEP ONLY THE CODE
	RET

; INIT - RESET PROCESS, SET UP SOFTWARE INTERRUPT SYSTEM,
;	 ENABLE CAPABILITIES
; RETURNS +1: ALWAYS

INIT:	RESET			;GET TO A KNOWN STATE
	MOVEI A,.FHSLF		;GET OWN ID
	RPCAP			;READ CAPABILITES
	MOVE C,B
	EPCAP			;ENABLE ALL CAPABILITIES
	MOVE B,[LEVTAB,,CHNTAB]
	SIR			;SET INTERRUPT TABLE ADDRESSES
	EIR			;TURN ON INTERRUPT SYSTEM
	MOVX B,1B<.ICLPO>!1B<.ICHNG>  ;ACTIVATE LINE PRINTER OFFLINE
	AIC			;AND TIMER EXPIRED CHANNELS
	SETOM TIMENA		;SAY TIMER PSI ENABLED
	SETZM NCMDS		;INITIALIZE COMMAND COUNTER
	RET

; SETTIM - ROUTINE TO SET TIME AT WHICH THE COMMAND IS DETERMINED HUNG
; Returns +1:  ALWAYS

SETTIM:	SKIPN TIMENA		;IS TIMER PSI ENABLED?
	 RET			;NO, JUST RETURN
	MOVE T1,[.FHSLF,,.TIMAL];REMOVE ALL TIME LIMITS
	TIMER
	 ERJMP TIMERR		;ERROR, GIVE MESSAGE AND RETURN
	MOVEI T2,HNGTIM		;GET TIME LIMIT OF COMMAND
	MOVEI T3,.ICHNG		;SPECIFY HUNG PSI CHANNEL
	MOVE T1,[.FHSLF,,.TIMEL];ELAPSED TIME FUNCTION
	TIMER
	 ERJMP TIMERR		;ERROR, GIVE MESSAGE AND RETURN
	RET
TIMERR:	EMSG <Timer JSYS failed - PSI System for Hung SETSPD disabled>
	MOVEI T1,.FHSLF		;GET PROCESS HANDLE
	MOVE T2,[1B<.ICHNG>]	;CHANNEL FOR TIMER JSYS
	DIC			;DEACTIVATE THIS CHANNEL
	SETZM TIMENA		;SAY PSI DISABLED FOR TIMER JSYS
	RET			;AND RETURN


;COMMAND LEVEL ACTION ROUTINES.

;FIRST TERMINAL

TERM:	TRVAR <<DEFBLK,1+.CMDEF>,<DEFOUT,3>>
	MOVEI A,[FLDDB. .CMNUX,CM%SDH,8,<terminal line number>]
	CALL RFIELD		;GET LINE NUMBER, CMNUMX ALLOWS HYPHEN AFTER NUMBER
	HRLZM B,LINES		;SAVE LINE NUMBER
	MOVEI A,[FLDDB. .CMTOK,CM%SDH,<-1,,[ASCIZ /-/]>,<hyphen (-) if specifying range>]
	CALL RFLDE		;SEE IF HYPHEN
	 CAIA			;NO HYPHEN
	JRST GTRNGE		;YES. GET RANGE
	HLRS LINES		;EXTEND LINE NUMBER
	JRST LINKEY		;GO GET THE KEY

GTRNGE:	MOVEI A,[FLDDB. .CMNUM,CM%SDH,8,<terminal line number>]
	CALL RFIELD		;READ END OF RANGE
	HRRM B,LINES		;STASH LAST LINE NUMBER
	; ..

;NOW READ OUT THE KEY WORD

LINKEY:	SETZB P1,P2		;CLEAR FLAGS
	MOVEI A,[FLDDB. .CMCFM,,,,,[
		 FLDDB. .CMKEY,,LEV2TB]]
	CALL RFIELD		;GET CONFIRMATION OR KEYWORD
	LOAD D,CM%FNC,.CMFNP(C)
	CAIN D,.CMCFM		;END OF LINE YET?
	RET			;YES, DONE
	MOVE B,(B)		;NO, GET TABLE ENTRY
	JRST (B)		;DO FUNCTION, RETURNS TO LINKEY

;IF HERE, LINES ARE REMOTE

AUTO:	TXOA P2,MO%AUT		;SET THE AUTO BUAD BIT
REMOTE:	TXO P2,MO%RMT		;SET THE REMOTE BIT
	HRRZ A,LINES		;GET FIRST LINE
	HLRZ B,LINES		;GET LAST LINE
	SUBI B,1(A)		;GET # TO DO
	HRLI A,0(B)		;AN AOBJN WORD
	HLR A,LINES		;FIRST LINE AGAIN
DOLINE:	SKIPN P1		;SETTING SPEED?
	IORM P2,REMTBL(A)	;SAY IT IS REMOTE
	SKIPE P1		;SETTING REMOTE?
	MOVEM P1,SPDTBL(A)	;NO. SET SPEED
	SKIPN SPDTBL(A)		;HAVE A SPEED YET?
	JRST REMOT1		;NO
	PUSH P,A		;SAVE LINES
	CALL SPDSET		;GO SET THE SPEED
	POP P,A			;RESTORE AOBJN WORD
REMOT1:	AOBJN A,DOLINE		;GO DO ALL OF THEM
	JRST LINKEY		;GO BACK FOR MORE ATTRIBUTES OF THIS SET OF TERMINALS
; HERE TO SET THE "IGNORE INPUT" (NO BELLS) BIT

NOBELL:	HRRZ D,LINES		;GET LAST LINE NUMBER
	HLRZ B,LINES		;GET FIRST LINE NUMBER
	SUBI B,1(D)		;FORM - NUMBER IN RANGE
	HRLI D,(B)		;FORM AN AOBJN POINTER TO LOOP
	HLR D,LINES		; OVER ALL THE LINES IN THE RANGE

NOBEL1:	MOVEI A,400000(D)	;GET LINE DESIGNATOR
	MOVX B,.MOSIG		;SET "IGNORE INPUT" BIT
	MOVX C,1		;TURN THE BIT ON
	MTOPR			;SET THE LINE TO IGNORE CHARACTERS UNTIL OPENED
	 ERJMP .+1		;IGNORE FAILURE HERE
	AOBJN D,NOBEL1		;LOOP OVER ALL THE LINES IN THE INDICATED RANGE
	JRST LINKEY		;GO GET THE NEXT KEYWORD IN THE COMMAND

;SET LINE SPEEDS

SPEED:	MOVEI A,[FLDDB. .CMNUM,CM%SDH,5+5,<input speed>]
	CALL RFIELD		;READ THE INPUT SPEED
IFN NICSW,<
	CAIN B,^D19200		;Is it 19200?
	 MOVEI B,^D134		;Yes, then its really 134
>;IFN NICSW
	HRLI P1,400000(B)	;IN CASE NO MORE
	HRROI A,DEFOUT		;POINT TO BUFFER FOR DEFAULT OUTPUT SPEED
	MOVEM A,.CMDEF+DEFBLK	;STORE POINTER TO DEFAULT OUTPUT SPEED
	MOVEI C,5+5		;CREATE DEFAULT IN DECIMAL
	NOUT			;CREATE IT
	 JSHLT			;SHOULDN'T EVER FAIL
	HRLI A,[FLDDB. .CMNUM,CM%DPP!CM%SDH,5+5,<output speed>]
	HRRI A,DEFBLK		;MAKE BLT POINTER
	BLT A,.CMDEF-1+DEFBLK	;PUT WRITABLE COMND FUNCTION BLOCK
	MOVEI A,DEFBLK		;POINT AT THE CREATED BLOCK
	CALL RFIELD		;READ OUTPUT SPEED, DEFAULT TO INPUT
IFN NICSW,<
	CAIN B,^D19200		;Is it 19200?
	 MOVEI B,^D134		;Yes, then its really 134
>;IFN NICSW
	HRRI P1,0(B)		;SAVE OUTPUT SPEED
	JRST REMOTE		;GO SET SPEEDS

;ROUTINE TO SET SPEED OF A LINE.
;INPUT IS :	A/ LINE NUMBER

SPDSET:	MOVEI A,0(A)		;CLEAN UP ARG
	SKIPE REMTBL(A)		;THIS A REMOTE SETTING?
	JRST SPDST1		;YES. ALWAYS USE FILE SETTING
	MOVEI A,400000(A)	;GET TTY DESIGNATOR
	MOVEI B,.MORSP		;GET SPEED FROM MONITOR
	MTOPR			;GET IT
	ERJMP REMOT2		;?
	TRZ A,400000
	SKIPG C			;GET IT?
SPDST1:	MOVE C,SPDTBL(A)	;NO. USE FILE'S VALUE
	TLZ C,(1B0)		;GET RID OF SIGN BIT
	MOVEI B,.MOSPD		;SPEED SETTING
	IOR B,REMTBL(A)		;ADD IN THE REMOTE AND AUTO BITS (IF ANY)
	TRO A,400000		;TTY DESIGNATOR
	MTOPR			;DO IT
	 ERJMP REMOT2		;IGNORE ERROR
	MOVEI B,.MORNT		;REQ MSG SUPPRESS STATUS FROM
	MTOPR			;MONITOR FOR TTY (A/ TTY#)
	 ERJMP REMOT2		;IGNORE ERROR
	MOVEI B,.MOSNT		;SET MSG SUPPRESS BIT FOR TTY
	MTOPR			;SAME AS BEFORE
	 ERJMP REMOT2		;IGNORE ERROR
REMOT2:	RET			;ALL DONE

;ROUTINE TO APPLY DEFAULT SPEEDS AT EOF

FINISH:	JUMPE P5,QUIT		;QUIT IF MTA ONLINE
	MOVE A,[SIXBIT /TTYJOB/] ;FIRST FIND # OF TTY'S
	SYSGT			;GET IT
	HLLZ P3,B		;MAKE AOBJN POINTER
FIN1:	SKIPE SPDTBL(P3)	;THIS ONE SET YET?
	JRST FIN2		;YES. GO ON
	MOVEI A,0(P3)		;NO. GET LINE #
	MOVE B,[^D300,,^D300]	;DEFAULT SPEED
	MOVEM B,SPDTBL(A)	;STORE IT
	CALL SPDSET		;GO SET THE SPEED
FIN2:	AOBJN P3,FIN1		;DO ALL LINES
;;	CALL REFILL		;GO LOAD THE CACHE REFILL ALGORITHM
QUIT:	HALTF			;AND DONE
;THIS CODE ALLOWS AND RESTRICTS MSCP SERVER ACCESS TO DISK DRIVES
;FORMAT OF A COMMAND LINE IS:
;	ALLOW/RESTRICT "DRIVE TYPE" "LOW SERIAL #" or
;	ALLOW/RESTRICT "DRIVE TYPE" "HIGH SERIAL #" "LOW SERIAL #"
;
RESTRI: SKIPA T1,[SV%DDU]
ALLOW:	SETZ T1,
	MOVEM T1,SMONBK+.SVTYP	;SAVE FLAGS FOR NOW
	MOVEI T1,.SVDSN+1	;LENGTH
	MOVEM T1,SMONBK+.SVCNT	;SAVE IT
	MOVEI T1,[FLDDB. .CMKEY,,DSKTAB] ;PARSE THE DRIVE TYPE
	CALL RFIELD
	HRRZ T2,(T2)		;GET TABLE ENTRY
	IORM T2,SMONBK+.SVTYP	;SAVE IT WITH FLAGS
	IORI T2,400		;ASSUME NO HIGH ORDER WORD WILL BE GIVEN
	LSH T2,20		; SO CONSTRUCT IT
	MOVEM T2,SMONBK+.SVDSH	;AND SAVE IT
	MOVEI T1,[FLDDB. .CMNUM,,^D10] ;GET THE SERIAL NUMBER
	CALL RFIELD
	MOVEM T2,SMONBK+.SVDSN	;SAVE IT AS LOW ORDER
	MOVEI T1,[FLDDB. .CMCFM,,,,,[
		 FLDDB. .CMNUM,,^D10]]
	CALL RFIELD		;GET CONFIRMATION OR KEYWORD
	LOAD T4,CM%FNC,.CMFNP(T3)
	CAIE T4,.CMCFM		;END OF LINE YET?
	JRST [EXCH T2,SMONBK+.SVDSN ;NO, THIS IS LOW ORDER NUMBER
	      MOVEM T2,SMONBK+.SVDSH ;AND THE OTHER WAS THE HIGH ORDER
	      CONFRM		;NOW PARSE AN EOL
	      JRST .+1]		;AND CONTINUE
	MOVEI T1,.SFMSD		;GET FUNCTION
	MOVEI T2,SMONBK		;ADDRESS OF BLOCK
	SMON			;DO IT
	 ERJMP [ HRROI T1,[ASCIZ/
*****************
? SETSPD: UNABLE TO ALLOW MSCP ACCESS TO DISK DRIVE, SERIAL NUMBER /]
		MOVE T2,SMONBK+.SVTYP ;GET FLAGS WORD
		TXNE T2,SV%DDU	;WAS IT RESTRICT?
		HRROI T1,[ASCIZ/
*****************
? SETSPD: UNABLE TO RESTRICT MSCP ACCESS TO DISK DRIVE, SERIAL NUMBER /]
		PSOUT		;PRINT ERROR
		MOVE T2,SMONBK+.SVDSH ;HIGH ORDER SERIAL NUMBER
		MOVEI T1,.PRIOU	;TO CTY
		MOVEI T3,^D10	;IN DECIMAL
		NOUT		;PRINT ERROR
		 JFCL
		TMSG < >
		MOVEI T1,.PRIOU
		MOVE T2,SMONBK+.SVDSN ;LOW ORDER SERIAL NUMBER
		NOUT
		 JFCL
		TMSG < BECAUSE: >
		JRST GENERR]	;TELL WHY
	RET
;
;
;DONTCARE SMON JSYS CODE
;

DCARE:	MOVEI T1,[FLDDB. .CMNUM,,^D10] ;GET THE CHANNEL NUMBER
	CALL RFIELD
	MOVEM T2,SMONBK
	MOVEI T1,[FLDDB. .CMNUM,,^D10] ;GET CONTROLLER NUMBER
	CALL RFIELD
	MOVEM T2,SMONBK+1
	MOVEI T1,[FLDDB. .CMNUM,,^D10] ;GET UNIT NUMBER
	CALL RFIELD
	MOVEM T2,SMONBK+2
	MOVEI T1,[FLDDB. .CMCFM,,,,,[
		 FLDDB. .CMNUM,,^D10]]
	CALL RFIELD		;GET CONFIRMATION OR KEYWORD
	LOAD T4,CM%FNC,.CMFNP(T3)
	CAIE T4,.CMCFM		;END OF LINE YET?
      CONFRM			;NOW PARSE AN EOL
	MOVEI T1,.SFDCD		;GET FUNCTION
	MOVEI T2,SMONBK		;ADDRESS OF BLOCK
	MOVE T4,SMONBK		;PICK UP CHANNEL
	STOR T4,.SDF%C,T3	;STOR CHANNEL
	MOVE T4,SMONBK+1	;PICK UP CONTROLLER
	STOR T4,.SDF%K,T3
	MOVE T4,SMONBK+2	;PICK UP UNIT
	STOR T4,.SDF%U,T3
	SMON			;DO IT
	 ERJMP [ HRROI T1,[ASCIZ/
*****************
? SETSPD: UNABLE TO ALLOW DON'T CARE ACCESS TO DISK DRIVE, CHANNEL\CONTROLLER\UNIT /]
		PSOUT
		MOVE T2,SMONBK	;CHANNEL NUMBER
		MOVEI T1,.PRIOU	;TO CTY
		MOVEI T3,^D10	;IN DECIMAL
		NOUT		;PRINT ERROR
		 JFCL
		TMSG < >
		MOVEI T1,.PRIOU
		MOVE T2,SMONBK+1	;CONTROLLER
		NOUT
		 JFCL
		TMSG < >
		MOVEI T1,.PRIOU
		MOVE T2,SMONBK+2	;UNIT NUMBER
		NOUT
		JFCL
		TMSG < BECAUSE: >
		JRST GENERR]	;TELL WHY
	RET

;THIS CODE PROCESSES THE MAGTAPE CONFIGURATION COMMANDS. FORMAT
;OF A COMMAND LINE IS:
;	MAGTAPE "LUN" "SERIAL#" "SLAVE TYPE"

MAGTAP:	MOVEI A,[FLDDB. .CMNUM,CM%SDH,5+5,<unit number>]
	CALL RFIELD
	MOVE P1,B		;SAVE LUN
	MOVE D,P1		;RESOTRE LUN
	MOVEI A,[FLDDB. .CMNUM,CM%SDH,5+5,<serial number>]
	CALL RFIELD
	HRRZ P2,B		;SAVE SERIAL NUMBER
	MOVEI A,[FLDDB. .CMKEY,,SLAVT,<slave type,>]
	CALL CFIELD		;GET SLAVE TYPE AND CONFIRMATION
	HRL P1,(B)		;SAVE SLAVE TYPE IN LEFT HALF OF P1
	MOVE A,P1		;SET LUN
	MOVE B,P2		;SET SERIAL #
	MTALN			;DO IT
	ERJMP [	JUMPE P5,CMDER1	;NO MESSAGE IF MTA ONLINE
		HRROI A,[ASCIZ /
*****************
? SETSPD: Could not set MTA /]
		PSOUT
		MOVEI A,.PRIOU	;TO THE CTY
		EXCH B,D	;GET MTA, SAVE SERIAL #
		MOVEI C,10	;IN OCTAL
		NOUT		;DO IT
		 JFCL
		HRROI A,[ASCIZ / SERIAL # /]
		PSOUT
		MOVEI A,.PRIOU
		MOVE B,D
		MOVEI C,12
		NOUT		;OUPUT THE SERIAL # AS WELL
		 JFCL
		TMSG <
*****************
>
		JRST CMDER1]	;AND DONE
	RET

; TAPE-RECOGNITION-ERRORS COMMAND

TRECER:	MOVEI T1,[FLDDB. .CMKEY,,TRETB] ;GET FDB ADDRESS
	CALL CFIELD		;GET KEYWORD AND CONFIRMATION
	HRRZ T4,(T2)		;GET BIT SETTING
	MOVEI T1,.SFTDF		;GET TMON FUNCTION CODE
	TMON			;GET CURRENT MOUNTR CONTROLS
	STOR T4,MT%UUT,T2	;SET OR CLEAR UNLOAD-UNREADABLE-TAPES
	SMON			;RESTORE CONTROL WORD
	RET

; KEYWORD TABLE FOR TAPE-RECOGNITION-ERRORS

TRETB:	TRETBL,,TRETBL
	T REGARD-AS-UNLABELED,0
	T UNLOAD,1
TRETBL==.-TRETB-1

; ENABLE COMMAND

DISABL:	MOVEI A,[FLDDB. .CMKEY,,DISOPT]
	JRST ENA1

ENABLE:	MOVEI A,[FLDDB. .CMKEY,,ENAOPT]
ENA1:	CALL RFIELD		;GET OPTION
	MOVE A,(B)		;TABLE WORD
	MOVE A,(A)		;GET CONTROL BITS AND DISPATCH ADDRESS
	TXZN A,MOREBT		;IS THERE MORE OF THIS COMMAND?
	CONFRM			;NO, SO CONFIRM NOW
	CALLRET (A)		;GO PERFORM INDICATED FUNCTION

; HERE TO PERMIT CHANGING DIRECTORY PARAMETERS

DISDIR:	TDZA B,B		;TURN OFF THE PARAMETER
ENADIR:	MOVEI B,1		;TURN ON THE OPTION
	MOVEI A,.SFCRD		;GET FUNCTION CODE
	SMON			;TELL THE MONITOR
	RET			;RETURN

; HERE TO ENABLE ACCOUNT VALIDATION

DISACT:	TDZA B,B		;TURN OFF ACCOUNT VALIDATION
ENACCT:	MOVEI B,1		;TURN ON ACCOUNT VALIDATION
	MOVEI A,.SFAVR		;GET THE FUNCTION CODE
	SMON			;TELL THE MONITOR
	RET			;RETURN

; HERE TO ENABLE/DISABLE FULL LATENCY OPTIMIZATION

DISFLO:	TDZA B,B		;TURN OFF FULL LATENCY OPTIMIZATION
ENAFLO:	MOVEI B,1		;TURN ON FULL LATENCY OPTIMIZATION
	MOVEI A,.SFFLO		;GET THE SMON FUNCTION CODE
	SMON			;SET THE DESIRED STATE
	RET			;AND RETURN

;Here to disable CTY output of system error messages

J0OUTD:	TDZA B,B		;FOR THE DISABLE
J0OUTE:	MOVEI B,1		;FOR THE ENABLE
	MOVEI A,.SFBGS		;THE BIT TO DO
	SMON			;DO IT
	RET			;AND DONE

; HERE TO ENABLE TAPE-DRIVE-ALLOCATION

ENATDA:	MOVEI B,1		;TURN ON TAPE DRIVE ALLOCATION
	MOVEI A,.SFMTA		;GET SMON SUNCTION CODE
	SMON
	RET

; HERE TO ENABLE/DISABLE WORKING SET PRELOADING

DISWSP:	TDZA B,B
ENAWSP:	MOVEI B,1
	MOVEI A,.SFWSP
	SMON
	RET

; HERE TO DISABLE FAST LOGIN OPTION FOR THE EXEC
DISFST:	MOVEI A,.SFXEC		;GET EXEC FLAGS WORD
	TMON
	TXO B,XC%FST		;DON'T ALLOW FAST LOGINS
	SMON
	RET

; HERE TO ENABLE FAST LOGIN OPTION FOR THE EXEC
ENAFST:	MOVEI A,.SFXEC		;GET EXEC FLAGS WORD
	TMON
	TXZ B,XC%FST		;ALLOW FAST LOGINS
	SMON
	RET






; HERE TO ENABLE/DISABLE HANGUP IF NOT LOGGED IN

DISHLO: TDZA B,B
ENAHLO:	MOVEI B,1
	MOVEI A,.SFHU0
	SMON
	RET

; HERE TO ENABLE/DISABLE HANGUP IF LOGGED IN

DISHLI: TDZA B,B
ENAHLI:	MOVEI B,1
	MOVEI A,.SFHU1
	SMON
	RET

; HERE TO ENABLE/DISABLE SYSTEM MESSAGE LEVEL 0

DISLV0:	TDZA B,B		;TURN IT OFF
ENALV0:	MOVEI B,1		;TURN IT ON
	MOVEI A,.SFMS0		;GET THE FUNCTION CODE
	SMON%			;CHANGE IT
	RET			;AND RETURN

; HERE TO ENABLE/DISABLE SYSTEM MESSAGE LEVEL 1

DISLV1:	TDZA B,B		;TURN IT OFF
ENALV1:	MOVEI B,1		;TURN IT ON
	MOVEI A,.SFMS1		;GET THE FUNCTION CODE
	SMON%			;CHANGE IT
	RET			;AND RETURN

;TURN DAYLIGHT SAVING TIME ON/OFF/AUTO

DAYLIG:	NOISE	<MODE IS>
	MOVEI	A,[FLDDB. .CMKEY,,DSTOPT] ;setup function block
	CALL	RFIELD		;get option
	HRRZ	B,(B)		;RH of table word
	CONFRM			;get confirmation
	MOVEI	A,.SFDST	;set DST function
	SMON			;do it
	 ERJMP	DSTERR		;something went wrong, go write message
	RET			;ok, return

DSTERR:	TMSG	<
?Unable to set DST switch because: > ;write start of message
	MOVEI	A,.PRIOU	;to TTY:
	HRLOI	B,.FHSLF	;me
	SETZM	C		;no byte count
	ERSTR			;write error message
	 ERJMP	.+2		;error, continue
	 ERJMP	.+1		;error, continue
	RET			;return

; SET LAT-STATE ON OR OFF

LAT:	NOISE	<STATE IS>
	MOVEI	A,[FLDDB. .CMKEY,,LATSTA] ;setup function block
	CALL	RFIELD		;get option
	HRRZ	B,(B)		;RH of table word
	CONFRM			;get confirmation
	MOVEI	A,.SFLTS	;Set LAT-STATE
	SMON
	 ERJMP	LATERR		;Something went wrong - print msg
	RET			;Ok 

LATERR:	TMSG	<
?Unable to set LAT STATE because: > ;write start of message
	MOVEI	A,.PRIOU	;to TTY:
	HRLOI	B,.FHSLF	;me
	SETZM	C		;no byte count
	ERSTR			;write error message
	 ERJMP	.+2		;error, continue
	 ERJMP	.+1		;error, continue
	RET			;return


	RET			;ok, return

SYLVL0:













;DEFINE A LOGICAL NAME

DEFINE:	STKVAR <LNPTR>
	NOISE <SYSTEM LOGICAL NAME>
	MOVEI A,[FLDDB. .CMDEV,CM%PO!CM%SDH,,<global logical name being defined>]
	CALL RFIELD		;READ THE NAME
	CALL BUFFF		;GET POINTER TO NAME
	MOVEM A,LNPTR		;REMEMBER POINTER TO NAME
	NOISE <AS>
	MOVEI A,[FLDDB. .CMTXT,CM%SDH,,<logical name definition>]
	CALL CFIELD
	CALL BUFFF		;GET POINTER TO DEFINITION STRING
	MOVE C,A		;NEW NAME IN C
	MOVEI A,.CLNSY		;SAY GLOBAL
	MOVE B,LNPTR		;GET LOGICAL NAME
	CRLNM
	 JRST [	TMSG <
*****************
? SETSPD: Failed to define logical name >
		MOVE A,LNPTR	;GET POINTER TO NAME
		PSOUT		;OUTPUT IT
		TMSG <
*****************
>
		JRST CMDERR]	;GO SAY WHY AND GET MORE COMMANDS
	RET

;SET LOCAL TIME ZONE; IT MUST BE A NUMBER FROM -12 TO 12

TIMZON:	MOVEI A,[FLDDB. .CMNUM,CM%SDH,5+5,<timezone number>]
	CALL CFIELD		;GET NUMBER AND CONFIRMATION
	MOVM D,B		;CHECK IT FOR RANGE
	CAILE D,^D12		;MUST BE FROM -12 TO 12 DECIMAL
	 COMERR <Timezone must be -12 to 12 inclusive>
	MOVEI A,.SFTMZ		;SET TIME ZONE
	SMON			;ARGUMENT IN B
	 ERJMP TZERR
	RET			;DONE

;ATTEMPT TO SET TIME ZONE FAILED

TZERR:	TMSG <
*****************
? SETSPD: Unable to set time zone because:
	>
GENERR:	MOVEI A,.PRIOU		;TYPE OUT MONITOR ERROR
	HRLOI B,.FHSLF		; FOR THIS FORK
	ERSTR
	 JFCL
	 JFCL
	TMSG <
*****************
>
	JRST CMDER1		;ON TO NEXT LINE

;SET LOCAL HOST NUMBER OF AN ARPANET SITE

HOST:	MOVEI A,[FLDDB. .CMNUM,CM%SDH,8,<local ARPAnet host number>]
	CALL CFIELD		;READ NUMBER AND CONFRIMATION
	MOVEI A,.SFLHN		;SET LOCAL HOST NUMBER
	SMON
	 ERJMP HSTERR		;FAILED?
	RET			;DONE

HSTERR: TMSG <
*****************
? SETSPD: Unable to set ARPANET site address because:
	>
	JRST GENERR

ARCHIV:	MOVEI A,[FLDDB. .CMNUM,CM%SDH,5+5,<number of days for archive tape recycle period>]
	CALL CFIELD
	MOVEI A,.SFACY		; SET ARCHIVE TAPE RECYCLE PERIOD
	SMON
	 ERJMP ARCERR		;FAILED?
	RET

ARCERR:	TMSG <
*****************
? SETSPD: Unable to set archive tape recycle period because:
	>
	JRST GENERR

TAPRCY:	MOVEI A,[FLDDB. .CMNUM,CM%SDH,5+5,<number of days for tape recycle period>]
	CALL CFIELD
	MOVEI A,.SFMCY		; SET TAPE RECYCLE PERIOD
	SMON
	 ERJMP TAPERR		;FAILED?
	RET

TAPERR:	TMSG <
*****************
? SETSPD: Unable to set tape recycle period because:
	>
	JRST GENERR

;COMMAND TO DECLARE DECNET NODE NAME

NODNAM:	STKVAR <LNNAME,ARENUM>
	MOVEI A,[FLDDB. .CMFLD,CM%SDH,,<local node name>]
	CALL RFIELD		;READ NODE NAME
	CALL BUFFF		;GET POINTER TO ASCIZ STRING
	MOVEM A,LNNAME		;REMEMBER POINTER TO NAME
	MOVEI A,[	FLDDB. .CMCFM,,,,,[
			FLDDB. .CMNUM,CM%SDH,5+5,<area.node>]]
	CALL RFIELD		;GET CONFIRMATION OR NODE NUMBER
	MOVEI D,0		;FIRST ASSUME NO NUMBER
	LOAD C,CM%FNC,.CMFNP(C)	;SEE WHAT WAS TYPED
	CAIN C,.CMCFM		;CONFIRMATION ONLY?
	JRST NODNA2		;YES, NO NUMBER
	MOVEM B,ARENUM		;Save what we believe is the area number
	MOVEI A,[	FLDDB. .CMCFM,,,,,[
			FLDDB. .CMTOK,,<-1,,[ASCIZ /./]>]]
	CALL RFIELD		;Get confirmation or area dot
	LOAD C,CM%FNC,.CMFNP(C)	;See what we got
	CAIE C,.CMCFM		;Confirm?
	IFSKP.			; -yes,
	  MOVE D,ARENUM		;  Retrieve node number (no area specified)
	  JRST NODNA2		;   and go process
	ENDIF.			;Come here if a dot was given
	MOVEI A,[	FLDDB. .CMNUM,CM%SDH,5+5,<node number>]
	CALL RFIELD		;Get node number
	MOVE D,ARENUM		;Get area number
	LSH D,^D10		;Shift it into position
	IOR D,B			; and put in node number
	CONFRM			;Confirm
NODNA2:	IFN. D    		;IF NO NUMBER, GO ON
	  MOVEI A,.NDSNM	;SET NODE NUMBER
	  MOVEI B,D		;WHERE THE NUMBER IS
	  NODE			;SET IT
	   ERJMP [ MOVX T1,.FHSLF ;Fork handle
		   GETER%	;Get last error
		   HRRZS T2	;Keep error only
		   CAIN T2,NODX16 ;DECNET already initialized?
		   RET		; -yes, we're probably running because of CFE
				;  reload
		   TMSG <*****************
? SETSPD: couldn't set node number - >
			JSERR	;SAY WHY
		   TMSG <
*****************
>
		   RET]
	ENDIF.
 	MOVEI A,.NDSLN		;WANT TO SET NODE NAME
 	MOVEI B,C		;ARG BLOCK
 	MOVE C,LNNAME		;GET POINTER TO NODE NAME
	NODE			;DO IT
	   ERJMP [	TMSG <*****************
? SETSPD: couldn't set node name - >
			JSERR	;SAY WHY
			TMSG <
*****************
>
			RET]
	RET

;DECNET command - set initial DECnet parameters
;
; Command format:
;	DECNET BUFFER-SIZE <value>
;	DECNET DEFAULT-BUFFERS-PER-LINK <value>
;	DECNET DEFAULT-FLOW-CONTROL NONE | SEGMENT
;	DECNET MAXIMUM-ADDRESS <value>
;	DECNET MAXIMUM-BUFFER <value>
;	DECNET ROUTER-ENDNODE <value>
;	DECNET ROUTER-LEVEL-1 <value>

DECNET:	SAVEAC <P1,P2>
	MOVEI T1,[FLDDB. .CMKEY,,DCNTA0]
	CALL RFIELD		;Get DECNET option
	MOVE A,(B)		;Table word
	HLRZ P1,(A)		;Get parameter number
	HRRZ T1,(A)		;Get processing address
	CALL (A)		;Process, return value to set in T2
	CONFRM			;Confirm
	MOVE P2,T2		;Get value to set
	MOVEI T1,.NDSDP		;Set DECnet parameter
	MOVEI T2,P1		;Point to argument block (P1-P2)
	NODE%			;Do it
	ERJMP [	MOVX T1,.FHSLF		;Fork handle
		GETER%			;Get most recent error
		HRRZS T2		;Keep error code only
		CAIN T2,NODX16		;DECNET already initialized?
		RET			; -yes, probably CFE reload - ignore
		TMSG <
*****************
? SETSPD: Failed to set DECnet parameter because:
	>
		JRST GENERR]
	RET			;Done with command

;Read a decimal number, return value in T2
DCNNUM:	MOVEI T1,[FLDDB. .CMNUM,,5+5]
	CALL RFIELD
	RET

;ROULV1 - routing level 1
;ROUEND - routing endnode
ROULV1:	SKIPA T2,[RNT.L1]
ROUEND:	MOVEI T2,RNT.NR
	RET

;NSPFLO - read flow control option
NSPFLO:	MOVEI T1,[FLDDB. .CMKEY,,FLOTAB]
	CALL RFIELD
	MOVE A,(B)
	MOVE T2,(A)		;Get flow value (FCM.NO or FCM.SG)
	RET


; "ETHERNET" COMMAND -- SET ETHERNET ADDRESS FOR A GIVEN CHANNEL
;
; COMMAND FORMAT:
;	ETHERNET (CHANNEL NUMBER) <channel #> (ADDRESS) <Hex address string>
;   OR:	ETHERNET (CHANNEL NUMBER) <channel #> (ADDRESS) DECNET
;
; Where "Hex address string" is a string of six hexadecimal numbers seperated
; by dashes ('-').  If the keyword 'DECNET' is used (must be spelled out in
; full) the address generated will be the appropriate address for a DECnet
; node on the Ethernet.

ETHERN:	SAVEAC <P1,P2>
	MOVEI A,[FLDDB. .CMNUM,CM%SDH,^D10,<Channel number>]
	CALL RFIELD		; Read the channel number
	MOVE P1,B		; Put it in a safe place (I hope)
	MOVEI A,[FLDDB. .CMKEY,,DNTABL]
	CALL RFLDE		; Look for the keyword "DECNET"
	 JRST GETADR		;  No such luck, search for a normal address
	CONFRM			; Finish up the line
	MOVEI A,.NDGNM		; Get the current node number
	MOVEI B,C		; Put it in C
	SETZ C,			; Clear C in case of error
	NODE%
	 ERJMP .+1		; Ignore errors
	JUMPE C,[TMSG <
*****************
? SETSPD: Could not set DECnet address for Ethernet channel >
		MOVEI A,.PRIOU		; Prepare to
		MOVE B,P1		;  output
		MOVEI C,^D10		;  the channel number
		NOUT%
		 ERJMP .+1
		TMSG < because DECnet address is not set
*****************
>
		JRST CMDER1]
	MOVEI A,.SFSEA		; Function is "Set Ethernet Address"
	MOVE B,P1		; Get channel number into B
	SETO C,			; Indicate we want the DECnet address
	SMON%			; Set the DECnet Ethernet address
	RET

GETADR:	CALL RNIADR		; Read the NI address
	
SETADR:	MOVE C,P1		; Get channel number
	DMOVE P1,A		; Put address in a safe place
	MOVEI A,.SFSEA		; Function is "Set Ethernet Address"
	MOVE B,C		; Channel number must be in B
	MOVE C,[POINT 8,P1]	; Get pointer to address
	SMON%			; Set the Ethernet address
	RET

	DEFINE BADSTR (string)<[EXP CM%FW+CM%NOR+CM%INV,ASCIZ |string|],,0>

DNTABL:	DNTLEN,,DNTLEN
	BADSTR D		; Don't allow substrings which could
	BADSTR DE		;  be valid Ethernet addresses
	T DECNET,0
	DNTLEN==.-DNTABL-1

; Here to read an Ethernet address of the form xx-xx-xx-xx-xx-xx.  Where
; xx is a hex number in the range of 0 to FF inclusive.

RNIADR:	SAVEAC P1		; Allocate an AC for source byte pointer
	TRVAR <<ADDR,2>>	; Allocate space for address
	MOVEI A,[FLDDB. .CMFLD,CM%SDH,,<Hexadecimal Ethernet Address>]
	CALL CFIELD		; Read the text and confirmation
	MOVE P1,[POINT 7,ATMBUF]; Get pointer to parsed text

	MOVE C,[POINT 8,ADDR]	; Get pointer to destination
	MOVEI D,6		; We should go through here a max of 6 times

	JRST RNIAD2		; Enter loop at the right point
RNIAD1:	CAIE B,"-"		; Followed by a dash?
	 JRST BADADR		;  Nope, tell the user
RNIAD2:	CALL HEXIN		; Read a hex number
	JUMPL A,BADHEX		; If negative, probably overflowed
	CAILE A,^D255		; Is it more than 8 bits?
	 JRST BADHEX		;  Yes, bad hex byte
	IDPB A,C		; Accumulate the Ethernet address
	SOJG D,RNIAD1		; Loop for all six numbers

	DMOVE A,ADDR		; Get address into A and B
	RET

BADADR:	TMSG <
*****************
? SETSPD: Illegal character ">
	MOVE A,B		; Get naughty character
	PBOUT			; Throw it out
	TMSG <" in Ethernet address
*****************
>
	JRST CMDER1

BADHEX:	TMSG <
*****************
? SETSPD: Illegal Hexadecimal byte in Ethernet address
*****************
>
	JRST CMDER1

HEXIN:	SETZ A,			; Clear the number holder
HEXIN2:	ILDB B,P1		; Get a byte from the source string
	CAIL B,"a"		; Less than "a"?
	 CAILE B,"z"		;  Or greater than "z"?
	  SKIPA			;   Yes to either, not lowercase
	SUBI B,"a"-"A"		; Nope, upper caseify it
	CAIL B,"0"		; Less than "0"?
	 CAILE B,"9"		;  Or greater than "9"?
	  SKIPA			;   Yes to either, check further
	JRST HEXIN1		; Nope, we have a valid digit
	CAIL B,"A"		; Less than "A"?
	 CAILE B,"F"		;  Or greater than "F"?
	  RET			;   Yes to either, it's not hex

	SUBI B,"A"-"9"-1	; Hexamize the character
HEXIN1:	SUBI B,"0"		; Turn it into an integer
	LSH A,4			; Make room for the new digit
	IOR A,B			; Bring in the new digit
	JRST HEXIN2		; And look for more

; "CHANGE" COMMAND -- SET ACCOUNTING SHIFT TIMES
;
; COMMAND FORMAT:
;	CHANGE (ACCOUNT SHIFT AT) <TIME> (ON) <DAYS-OF-WEEK>

CHANGE:	MOVEI A,[FLDDB. .CMTAD,CM%SDH,CM%ITM!CM%NCI!DATBLK,<time of day at which accounting shift is to occur>]
	CALL RFIELD		;READ TIME
	HRRZ P1,DATBLK+2	;STORE TIME, INIT LEFT HALF TO NO DAYS
	MOVEI A,[FLDDB. .CMCFM,,,<confirm now to assume all days, or enter specific days of week>]
	CALL RFLDE		;END OF LINE NOW?
	 CAIA			;NO
	JRST CHANG7		;YES, ASSUME ALL DAYS
CHANG2:	MOVEI A,[FLDDB. .CMKEY,,DOWTAB,<day of the week on which accounting shift is to occur>]
	CALL RFIELD		;READ DAY OF THE WEEK
	HRLZ A,(B)		;GET DAY-OF-WEEK BITS FROM TABLE TO LH
	TDO P1,A		;SET SELECTED DAYS
	MOVEI A,[FLDDB. .CMCFM,,,,,[
		 FLDDB. .CMCMA]]
	CALL RFIELD		;GET CONFIRMATION OR COMMA
	LOAD D,CM%FNC,.CMFNP(C)	;SEE WHICH
	CAIN D,.CMCMA		;MORE DAYS FOLLOWING?
	JRST CHANG2		;YES, GO READ THEM
	JRST CHANG8		;NO, CONFIRMATION, SO WE'RE DONE

CHANG7:
	TXO P1,1B0!1B1!1B2!1B3!1B4!1B5!1B6 ;ASSUME ALL DAYS OF WEEK
CHANG8:
	MOVEI T1,ASCTBZ		;GET SIZE OF TABLE
	HRRZM T1,ASCTBL		;STORE AS MAX TABLE SIZE
	MOVX T1,.USRAS		;READ ACCOUNTING SHIFTS
	MOVEI T2,ASCTBL		; INTO ASCTBL
	USAGE			; . . .
	 ERCAL [JSERR
		RET]
	HLRZ T1,ASCTBL		;GET CURRENT SIZE OF TABLE
	ADDI T1,1		;BUMP BY ONE
	HRLM T1,ASCTBL		;STORE NEW SIZE
	MOVEM P1,ASCTBL(T1)	;STORE NEW ENTRY
	MOVX T1,.USSAS		;SET ACCOUNTING SHIFTS
	USAGE
	 ERCAL [JSERR
		RET]
	RET

; ROUTINE TO LOAD A RAM OR VFU

LPTLOD:	STKVAR <LODUNI,LODFNC,LODJFN,LPTJFN>
	SETZM LODJFN		;INIT THIS TO ZERO
	MOVEI A,[FLDDB. .CMNUM,CM%SDH,8,<lineprinter unit number>]
	CALL RFIELD		;READ UNIT NUMBER
	MOVEM B,LODUNI		;SAVE LPT UNIT NUMBER

; SEE IF RAM OR VFU IS TO BE LOADED

LPLD20:	MOVEI A,[FLDDB. .CMKEY,,LPTTAB]
	CALL RFIELD		;SEE WHICH IS BEING LOADED
	HRRZ A,(B)		;GET FUNCTION TO PERFORM
	CAIN A,.MOSTS		;SET STATUS FUNCTION (DECLARE LOWER CASE LPT) ?
	JRST [	MOVE T2,LODUNI	;YES, GET THE UNIT NUMBER
		SETOM LODLCP(T2) ;FLAG THAT PRINTER SHOULD BE LOWER CASE
		JRST LPLD20 ]	;GO GET NEXT ARGUMENT
	MOVEM A,LODFNC		;SAVE DESIRED FUNCTION (MTOPR CODE)

; READ FILENAME TO BE LOADED AND GET A JFN FOR IT

	MOVEI A,[FLDDB. .CMIFI,CM%SDH,,<name of ram or vfu file>]
	CALL CFIELD		;GET FILENAME AND CONFIRMATION
	MOVEM B,LODJFN		;SAVE JFN

; OPEN THE PRINTER AND VERIFY THAT NO RAM OR VFU IS NOW LOADED

	HRROI A,FILNAM		;GET POINTER TO WHERE DEVICE STRING GOES
	MOVSI B,600007		;GET LPT DEVICE DESIGNATOR
	HRR B,LODUNI		;GET UNIT NUMBER
	DEVST			;GET DEVICE NAME STRING
	 JRST LODERR		;FAILED
	MOVEI B,":"		;GET TERMINATOR FOR GTJFN
	IDPB B,A		;TERMINATE DEVICE NAME
	SETZ B,
	IDPB B,A		;TIE IT OFF
	MOVX A,GJ%SHT!GJ%FOU	;SHORT CALL, FOR OUTPUT USE
	HRROI B,FILNAM		;GET POINTER TO DEVICE NAME
	GTJFN			;GET A JFN FOR THE PRINTER
	 JRST ENDLPT		;ALREADY ASSIGNED
	MOVEM A,LPTJFN		;SAVE LPT JFN
	MOVX B,<FLD(7,OF%BSZ)+OF%WR> ;OPEN FOR WRITE
	OPENF			;OPEN THE PRINTER
	 JRST [	EXCH A,LPTJFN	;MUST BE OPEN ALREADY, GET BACK JFN
		RLJFN		;RELEASE THE JFN
		 JFCL		;IGNORE ERRORS HERE
		MOVE A,LPTJFN	;GET BACK ERROR CODE
		CAIE A,OPNX9	;ALREADY OPENED BY SOMEONE?
		JRST LODANY	;NO. LOAD ANYWAY
		JRST ENDLPT ]	;GO ON TO NEXT COMMAND
	MOVEI B,.MOPSI		;GET OFF-LINE INTS
	MOVEI C,P1		;SET UP ARGS IN REGISTERS
	MOVEI P1,3		;3 WORDS
	MOVEI P2,.ICLPO		;LINE PRINTER OFFLINE CHANNEL
	SETZ P3,		;NO FLAGS
	MTOPR			;DO IT
	ERJMP .+1		;IN CASE SOMETHING TERRIBLE HAPPENED
	GDSTS			;GET CURRENT STATUS
	TXZ B,MO%LVU!MO%LCP!MO%EOF ;TURN OFF CONDITION BITS
	JUMPN B,INERR		;IF AN ERROR, PUNT IT
	MOVEI B,14		;IF NO ERROR, ALIGN FORMS
	BOUT			;DO IT
	 ERJMP .+1		;IGNORE FAILURE
INERR:	DMOVE B,[-1,,FILNAM
		5*^D28]		;ARGS
	DMOVEM B,MTBLK+1	;TO ARG BLOCK
	MOVE C,LODFNC		;GET FUNCTION TO PERFORM
	MOVX B,.MORTR		;GET READ-RAM FUNCTION CODE
	CAIE C,.MOLTR		;ARE WE LOADING THE RAM ?
	MOVX B,.MORVF		;NO, GET READ-VFU FUNTION
	MOVEI C,MTBLK		;GET ADDRESS OF BLOCK
	SETZM FILNAM		;MAKE IT LOOK AS IF IT IS NOT LOADED
	MTOPR			;READ FILENAME ALREADY LOADED
	 ERJMP .+1		;UNEXPECTED ERROR. LOAD RAM ANYWAY
	MOVE A,LPTJFN		;GET JFN FOR PRINTER
	CLOSF			;CLOSE THE FILE
FCLOSE:	 JRST [	MOVE A,LPTJFN	;FAILED. GET JFN AGAIN
		TXO A,CZ%ABT	;DO IT NOW WITH ABORT
		CLOSF		;DO IT
		 JFCL		;HAS TO WORK
		JRST .+1]	;ALL DONE
	LDB A,[POINT 7,FILNAM,6] ;GET FIRST BYTE RETURNED
	JUMPN A,ENDLPT		;IF NOT-NULL, GO ON TO NEXT COMMAND

; GET JFN, FUNCTION, AND UNIT # AND LOAD THE RAM OR VFU

LODANY:	MOVE B,LODFNC		;GET FUNCTION TO BE PERFORMED
	MOVE A,LODJFN
	MOVE C,LODUNI		;GET UNIT NUMBER OF PRINTER
	SKIPE LODLCP(C)		;IS THIS PRINTER LOWER CASE ?
	TXO B,MO%LCP		;YES, MARK THAT PRINTER IS LOWER CASE
	LPINI			;LOAD RAM OR VFU
	 ERJMP LODERR		;ERROR - TELL SOMEONE

; HERE TO FINISH UP AND GO DO NEXT COMMAND

ENDLPT:	RET

; HERE ON AN ERROR LOADING THE RAM OR VFU

LODERR:	TMSG <
*****************
? SETSPD: Could not load the >
	HRROI A,[ASCIZ/VFU/]	;GET TEXT
	MOVE B,LODFNC		;GET FUNCTION BEING PERFORMED
	CAIE B,.MOLVF		;ARE WE LOADING THE VFU ?
	HRROI A,[ASCIZ/RAM/]	;NO, GET RAM TEXT
	PSOUT			;TELL USER WHAT WE ARE LOADING
	TMSG < for PLPT>	;GET UNIT NAME
	MOVEI A,.PRIOU		;GET PRIMARY OUTPUT JFN
	MOVE B,LODUNI		;GET UNIT NUMBER
	MOVEI C,^D8		;GET OCTAL RADIX
	NOUT			;OUTPUT THE UNIT NUMBER
	 JFCL			;IGNORE ERRORS HERE
	TMSG <
*****************
>				;END OF MESSAGE
	SKIPE A,LODJFN		;GET JFN FOR FILE TO HAVE BEEN LOADED
	CLOSF			;MAKE SURE IT IS REALLY CLOSED AND RELEASED
	 JFCL			;PROBABLY CLOSED BY MONITOR ALREADY ANYHOW
	JRST ENDLPT		;GO FINISH UP

;LPT OFF-LINE INTERRUPT ROUTINE

LPTINT:	MOVEI A,@FCLOSE		;REDIRECT CODE TO CLOSE AND ABORT DEVICE
	MOVEM A,PCLEV1		;ZAP THE OLD PC WORD
	DEBRK			;AND GO FINISH UP

;CHANNEL ONE INTERRUPT ROUTINE.  INVOKED WHEN TIMER HAS EXPIRED.

HNGCON:	BLOCK 1			;CONTINUATION ADDRESS IF HUNG
HNGSTK:	BLOCK 1			;STACK POINTER WHEN SETSPD HANGS
NCMDS:	BLOCK 1			;NUMBER OF COMMANDS PROCESSED
HUNG:	HRROI T1,[ASCIZ/%SETSPD Hung on command line /]
	PSOUT
	MOVEI T1,.PRIOU		;OUTPUT TO PRIMARY DESIGNATOR
	MOVE T2,NCMDS		;GET THE COMMAND LINE NUMBER THAT IS HUNG
	MOVEI T3,^D10		;OUTPUT IN DECIMAL
	NOUT
	 JSERR
	HRROI T1,[ASCIZ/ - Continuing with next command...
/]
	PSOUT			;OUTPUT MORE OF MESSAGE
	MOVE T2,HNGCON		;GET CONTINUATION ADDRESS
	TXO T2,UMODF		;SET USER FLAG OF PC
	MOVEM T2,PCLEV2		;AND CHANGE PROCESS PC TO CONTINUE
	MOVE P,HNGSTK		;GET BACK LAST PRESERVED STACK
	DEBRK


;ROUTINES FOR SCHEDULER CONTROLS

;SET BIAS-CONTROL VALUE

BIAS:	MOVEI A,[FLDDB. .CMNUM,CM%SDH,5+5,<value for bias control knob>]
	CALL CFIELD		;READ VALUE AND CONFIRMATION
	MOVE T4,T2		;COPY NUMBER
	MOVEI T1,.SKSBC		;SET BIAS CONTROL
	MOVEI T2,T3		;ARG BLOCK
	MOVEI T3,2		;LENGTH OF BLOCK
	SKED%			;SET IT
	 ERJMP [EMSG <Invalid value for bias control setting>
		JRST CMDER1]
	RET

;SET BATCH BACKGROUND

BATBGD:	CONFRM			;MAKE SURE HE MEANS IT
	MOVEI T1,.SKBBG		;GET PROPER FUNCTION
	SETZM T2		;NO ARGS
	SKED%			;SET IT
	ERCAL [	EMSG <Could not set BATCH-BACKGROUND>
		RET]
	RET

;SCHEDULER CONTROLS COMMANDS CONTINUED

;CREATE A CLASS. WILL DO NOTHING IF CLASS SCHEDULER NOW ON.

CREATE:	MOVX T1,.SKRCV		;READ CLASS PARAMETERS
	MOVEI T2,T3
	MOVEI T3,2
	SKED%			;READ OUT CLASS PARAMETERS
	ERJMP [	JSERR
		JRST CMDER1]	;ERROR OF SOME SORT
	TXNN T4,SK%STP		;NOW ON?
	JRST CMDER1		;YES. GO AWAY QUIETLY THEN

;CLASS SCHEDULING NOW OFF. SET THE CLASS SHARE

	MOVEI A,[FLDDB. .CMNUM,CM%SDH,5+5,<class number>]
	CALL RFIELD
	MOVEM T2,CLSBLK+1	;SAVE CLASS
	MOVEI A,[FLDDB. .CMFLT,CM%SDH,,<percentage of machine to allot to class>]
	CALL CFIELD
	MOVEM T2,CLSBLK+2	;SAVE %
	MOVEI T2,CLSBLK
	MOVEI T1,.SKSCS		;PROPER FUNCTION
	SKED%			;DO IT
	ERJMP [	TMSG <
*****************
? SETSPD: Could not CREATE class: >
		JSERR
	TMSG <
*****************
>
		RET]
	RET

;MORE SCHEDULER COMMANDS

;ENABLE CLASS-SCHEDULING. GOT TO HERE FROM ENABLE COMMAND

ECSKED:	MOVEI T1,.SKRCV		;READ CLASS VALUES
	MOVEI T2,T3
	MOVEI T3,2
	SKED%			;READ VALUES
	ERJMP CMDERR
	TXNN T4,SK%STP		;NOW ON?
	JRST CMDER1		;YES. SKIP IT THEN

;CLASS SCHEDULER NOW OFF.

	MOVEI A,[FLDDB. .CMKEY,,SKDOPT]
	CALL RFIELD		;GET OPTION
	HRRZ A,0(B)		;GET VALUE
	MOVX T4,SK%ACT		;ASSUME BY ACCOUNT
	SKIPE A			;IS IT?
	TXZ T4,SK%ACT		;NO
	MOVEI A,[FLDDB. .CMKEY,,SKDOP0,,<ALLOCATED>]
	CALL CFIELD		;DEFAULT TO ALLOCATED
	HRRZ A,0(B)		;GET VALUE
	SKIPE A			;WANT TO WITHHOLD?
	TXO T4,SK%WDF		;YES
	MOVEI T1,.SKICS
	MOVEI T2,T3
	MOVEI T3,2		;COUNT
	SKED%			;START UP CLASS SCHEDULER
	ERJMP [JSERR		;ERROR
		RET]
	RET

;SET BATCH CLASS

BCHCLS:	MOVEI A,[FLDDB. .CMNUM,CM%SDH,5+5,<class number for running all batch jobs in>]
	CALL CFIELD
	MOVE T4,T2		;COPY VALUE
	MOVEI T3,2		;ARG BLOCK
	MOVEI T1,.SKBCS		;SET BATCH CLASS
	MOVEI T2,T3		;POINT TO ARG BLOCK
	SKED%			;DO IT
	 ERJMP [EMSG <Could not set BATCH-CLASS>
		JSERR
		RET]
	RET

;ENTRY POINT FOR PROCESSING CRASH DUMPS

START3:	MOVE P,[IOWD PDLEN,PDL]	;SET UP PUSH DOWN LIST
	CALL INIT		;SET UP PSI, CAPABILITIES, ETC.
	CALL QUEBLK
	HALTF%
	HALTF%

; QUEBLK - COPY DUMP.EXE TO DUMP.CPY AND LOG ANY UNLOGGED SYSERR
;	   BLOCKS THAT WERE FOUND IN THE DUMP FILE
; RETURNS +1: ALWAYS

QUEBLK:	MOVE T1,[SIXBIT /DBUGSW/] ;CHECK ON STATE OF SYSTEM
	SYSGT			;READ DBUGSW
	SKIPE T2		;FOUND IT?
	CAIGE T1,2		;YES. IS IT STAND-ALONE?
	SKIPA			;NO. DO THE DUMP
   IFN 0,<
	 CALLRET SETCNT		;STILL TRY TO SET SPEAR COUNT
   >	;REMOVAL OF SPRCNT CODE.
	RET			;YES, DO NOT PROCESS DUMPS
	TRVAR <QUEJFN,QUEFRK,QUEPGS>
	SETZ T1,		;GET A FORK TO LOAD DUMP.EXE INTO
	CFORK
   IFN 0,<
	 JSYERR (<CFORK% failed on PS:<SYSTEM>DUMP.EXE - >,<CALLRET SETCNT>)
				;CFORK ERROR, TRY TO SET COUNT ANYWAY...
   >	;REMOVAL OF SPRCNT CODE.
	 JSYERR (<CFORK% failed on PS:<SYSTEM>DUMP.EXE - >,<RET>)
	MOVEM T1,QUEFRK		;SAVE FORK HANDLE
	MOVX T1,GJ%OLD!GJ%SHT	;GET A JFN FOR <SYSTEM>DUMP.EXE
	HRROI T2,[ASCIZ/PS:<SYSTEM>DUMP.EXE/]
	GTJFN
   IFN 0,<
	 IFNSK.
	 CALL SETCNT		;SET SPEAR COUNTER
	  NOP			;ERROR, OUR HANDS ARE TIED
   >	;REMOVAL OF SPRCNT CODE.
	 JRST QUEKFK
;	 ENDIF.			;REMOVAL OF SPRCNT CODE.
	MOVEM T1,QUEJFN		;SAVE JFN
	MOVE T2,[440000,,OF%RD!OF%WR!OF%THW]
	OPENF			;OPEN THE FILE FOR READ/WRITE THAWED
	 JRST [	MOVE T1,QUEJFN	;FAILED, CLEAN UP
		RLJFN
		 JFCL
   IFN 0,<
		CALL SETCNT	;TRY TO SET SPEAR COUNTER
		 NOP
   >	;REMOVAL OF SPRCNT CODE.
		JRST QUEKFK]
	HRLI T1,.FBPRT		;SET THE PROTECTION OF DUMP.EXE TO 770000
	MOVEI T2,-1		;RIGHT HALF PROTECTION BITS
	MOVEI T3,770000		;MUCHO PROTECTION
	CHFDB			;THIS FILE MUST BE PROTECTED FOR SECURITY
	 ERJMP .+1
	HRLZ T1,QUEJFN		;NOW MAP IN DIR PAGE
	MOVE T2,[.FHSLF,,PG0PG]
	MOVX T3,PM%RD!PM%WT	;READ AND WRITE
	PMAP
	HRRZ T1,PG0ADR		;GET LENGTH OF DIRECTORY BLOCK
	HRRZ T2,PG0ADR-2(T1)	;GET STARTING FILE PAGE # OF LAST GROUP
	HLRZ T3,PG0ADR-1(T1)	;GET HALFWORD CONTAINING REPEAT COUNT
	LSH T3,-9		;RIGHT JUSTIFY REPEAT COUNT
	ADDI T2,1(T3)		;COMPUTE # OF FILE PAGES TO MAP
	MOVEM T2,QUEPGS		;SAVE NUMBER FOR CPYDMP
	HRRZ T1,PG0ADR		;GET LENGTH OF HEADER BLOCK OF DIR
	HLRZ T2,PG0ADR(T1)	;GET CODE OF NEXT BLOCK
	CAIE T2,1775		;ENTRY VECTOR?
	JRST QUEROR		;NO, GIVE UP
	HRRZ T2,PG0ADR(T1)	;GET LENGTH
	CAIGE T2,4		;CORRECT LENGTH?
	JRST QUEROR		;NO, GIVE UP
	SKIPE PG0ADR+3(T1)	;ALREADY LOOKED AT THIS DUMP?
	JRST QUEROR		;YES, GIVE UP
	SETOM PG0ADR+3(T1)	;NO, MARK THAT WE HAVE NOW SEEN IT
	SETO T1,		;AND UNMAP THE PAGE
	MOVE T2,[.FHSLF,,PG0PG]
	SETZ T3,
	PMAP
	HRRZ T1,QUEJFN		;GET JFN OF ORIGINAL DUMP FILE
	MOVE T2,QUEPGS		;GET HIGHEST PAGE NUMBER TO COPY
	CALL CPYDMP		;GO COPY THE DUMP FILE
				;FALL THROUGH....

;THE COPY IS EITHER DONE OR HAS BEEN DELETED BECAUSE SYSTEM IS
;STAND-ALONE. PROCEED WITH QUEUEING UP THE SYSERR BLOCKS

DMPDON:				;HERE TO QUEUE UP SYSERR BLOCKS
	CALL DMPMAP		;MAP THE DUMP FILE
	 JRST QUEROR		;HANDLE ERRORS

	SETZ T1,		;WE WANT PAGE ZERO OF THE DUMP
	CALL DMPRED		;READ FROM THE DUMP
	 JRST QUEROR		;HANDLE ERRORS

   IFN 0,<
	SKIPE T3,TMPADR+SPRCNT	;GET RUNNING COUNT OF SPEAR ENTRIES
	IFSKP.			;IF ZERO, TRY GETTING COUNT FROM ERROR.SYS
	 TMSG <
*****************
% SETSPD: SPEAR entry count = 0 in SYSTEM:DUMP.EXE, resynching from ERROR.SYS
*****************
>
	 CALL SETCNT		
	  NOP			;FAILURE RETURN
	ELSE.

	MOVEI T2,(T3)		;GET COUNT 
	MOVEI T1,.SFSPR		;GET FUNCTION CODE FOR SMON%
	SMON%			;ADD OLD COUNT INTO CURRENT COPY OF MONITOR
	 JSYERR (<SMON% failed to set SPEAR error counter - >,<>)
	ENDIF.

   >;	REMOVAL OF SPRCNT CODE.

	SKIPG P1,TMPADR+SEBQOU	;IS THIS ANYTHING IN THE QUEUE
	 JRST QUEDN1		;NO
QUELOP:
	MOVE P2,P1		;GET ADDRESS OF NEXT BLOCK
	ANDI P2,777		;GET LOW ORDER BITS ONLY
	MOVE T1,P1		;NOW MAP IN THE PAGE WITH THE BLOCK
	LSH T1,-PGSFT		;CONVERT TO A PAGE NUMBER
	CALL DMPRED		;READ A PAGE FROM THE DUMP
	 JRST QUEDON		;HANDLER ERRORS
	MOVEI T1,TMPADR(P2)	;GET ADDRESS OF START OF BLOCK
	LOAD T2,SEBSIZ,(T1)	;GET SIZE OF BLOCK
	ADDI T1,SEBHED		;DONT STORE HEADER
	SUBI T2,SEBHED
	SOS T2
	DMOVE T3,0(T1)		;GET FIRST TWO WORDS
	DMOVEM T3,SYSERR
	DMOVE T3,2(T1)		;AND THE NEXT TWO WORDS
	DMOVEM T3,SYSERR+2
	MOVE T3,T1
	ADDI T3,5		;POINT PAST THE HEADER
	MOVSS T3,T3		;LEFT HALF FOR BLT
	HRRI T3,SYSERR+4	;SET RIGHT HALF
	BLT T3,SYSERR-5(T2)
	MOVEI T1,SYSERR
	SYERR			;PUT THIS BLOCK INTO ERROR LOG
	 ERJMP .+1		;IGNORE ERRORS
	MOVE P1,TMPADR(P2)	;GET ADDRESS OF NEXT BLOCK
	JUMPN P1,QUELOP		;IF ONE THERE, GO PROCESS IT
QUEDN1:
	MOVE T1,[SIXBIT /APRID/] ;GET APRID OF PROCESSOR
	SYSGT			;TO DETERMINE KS10
	CAIG T1,^D4096		;IF GT 4096. THEN KS12
	JRST QUEDON		;NO -- DON'T NEED HSB
	SETZ T1,		;PAGE ZERO
	CALL DMPRED		;READ IN A DUMP FILE
	 JRST QUEDON		;HANDLE ERRORS
	MOVEI T1,SEC%HS		;SET UP LOGGING CODE
	STOR T1,SEBERC
	DMOVE T1,TMPADR		;GET FIRST TWO WORDS OF DUMP (PHYSICAL 0,1
	DMOVEM T1,HS%COD+4+HSBBUF	;STORE IN BUFFER
	MOVE T1,[-HS%HSZ,,HS%HDZ]	;POINTER TO BUFFER
	MOVEM T1,HS%PTR+4+HSBBUF	;BUFFER
	MOVE T1,[PG0ADR+HSBADR,,HSBBUF+4+HS%HDZ] ;MOVE TO BUFFER
	BLT T1,HSBBUF+4+HS%HSZ	;BLT LOW CORE DATA
	MOVEI T1,HSBBUF		;SYSERR OUTPUT BUFFER
	MOVEI T2,HS%LEN
	SYERR			;OUTPUT ERROR
	 ERJMP QUEDON		;IGNORE ERRORS
QUEROR:
;	CALL SETCNT		;SET COUNT	;REMOVE SPRCNT CODE.
	JFCL			;IGNORE FAILURE
QUEDON:	SETO T1,		;FIRST UNMAP PAGES
	MOVE T2,[.FHSLF,,PG0PG]	;DO PAGE 0
	SETZ T3,
	PMAP
	MOVE T2,[.FHSLF,,TMPPG]	;AND TEMP PAGES
	MOVX T3,PM%CNT+2
	PMAP
	MOVX T2,<.FHSLF,,MMPPG>	;AND MMAP PAGE
	SETZ T3,
	PMAP
	HRRZ T1,QUEJFN		;SEE IF THERE IS A JFN STILL AROUND
	JUMPE T1,QUEKFK
	CLOSF			;YES, CLOSE IT
	 JFCL
QUEKFK:	MOVE T1,QUEFRK		;NOW KILL THE FORK
	KFORK
	RET			;ALL DONE

   IFN 0,<
	;;SETCNT - Called when the running count of SPEAR entries is not found
	;	   in DUMP.EXE, we didn't take a DUMP, or any one of numerous
	;	   JSYS errors which may of occurred.
	;RETURNS + 1:	SETCNT failed, CTY notified
	;	 + 2:	Success

SETCNT:	 MOVX T1,<GJ%OLD!GJ%DEL!GJ%SHT>
	 HRROI T2,[ASCIZ/SERR:ERROR.SYS/]
	 GTJFN%			
	  ERJMP [CAIE 1,GJFX24
		IFNSK.
		 TMSG <
*****************
? SETSPD: SETCNT: GTJFN% failed on SERR:ERROR.SYS because:
        >
		 CALL JSYER0
		 TMSG <
*****************
>
		 RET
		ELSE.
		 TMSG <
*****************
% SETSPD: Could not set SPEAR entry count from SERR:ERROR.SYS because
          file was not present. Resynching from zero.
*****************
>
	 	 SETZ T3,
		 JRST SPRSET
		ENDIF.]
	 HRRZS T1
	 MOVEM T1,TMPJFN	;SAVE JFN
	 MOVX T2,<OF%RD!OF%PLN>
	 OPENF%
	  JSYERR (<SETCNT: OPENF% failed on SERR:ERROR.SYS - >,<RET>)
	 MOVE T1,TMPJFN
	 FFFFP			;FIND FIRST FREE PAGE ON ERROR.SYS
	 SUBI T1,1		;T1 IS NOW THE LAST USED PAGE
	 MOVE T2,[.FHSLF,,ESYPG]
	 MOVX T3,<PM%RD!PM%PLD>
	 PMAP%			;MAP IT IN
	  JSYERR (<SETCNT: PMAP% failed from SERR:ERROR.SYS - >,<RET>)
	 HRRZ T1,ESYSAD		;GET FIRST RESYNC ENTRY ON THIS PAGE
	 SKIPE T3,ESYSAD+ESYCNT(T1) ;IS THE SPRCNT ZERO?
	 IFSKP.			;YES, TELL WORLD AND RESYNC
	  TMSG <
*****************
% SETSPD: SPEAR entry count = 0 in ERROR.SYS, resynching to 0
*****************
>
	 ELSE.			;NO, THEN SEE IF WE CAN GET A HIGHER VALUE
	  HRRZ T1,ESYSAD+200	;THIS IS THE SECOND ONE
	  JUMPE T1,SETCN1	;IF ZERO, USE WHAT WE HAVE
	  MOVE T3,ESYSAD+ESYCNT+200(T1) ;NOT ZERO, LOOK FOR HIGHER
	  HRRZ T1,ESYSAD+400	;THIS IS THE THIRD RESYNC ENTRY
	  JUMPE T1,SETCN1	; ..
	  MOVE T3,ESYSAD+ESYCNT+400(T1) ;KEEP LOOKING
	  HRRZ T1,ESYSAD+600
	  JUMPE T1,SETCN1
	  MOVE T3,ESYSAD+ESYCNT+600(T1) ;THIS IS THE LAST ONE
SETCN1:	  ADDI T3,^D22		;ADD IN ENOUGH ENTRIES THAT FIT IN 200 WORDS
	 ENDIF.
				;IF ANYONE WANTS TO FIND THE LAST POSSIBLE
				;VALUE, THEN BE MY GUEST.
	SETO T1,		;MUST CLOSE ERROR.SYS
	MOVE T2,[.FHSLF,,ESYPG]
	PMAP%			;UNMAP FILE...
	 JSYERR (<SETCNT: PMAP% unmap of SERR:ERROR.SYS failed - >,<RET>)
	MOVE T1,TMPJFN
	CLOSF%			;AND CLOSE IT!
	 JSYERR (<SETCNT: CLOSF% failed on SERR:ERROR.SYS - >,<RET>)

SPRSET:
	MOVEI T2,(T3)		;GET COUNT 
	MOVEI T1,.SFSPR		;GET FUNCTION CODE FOR SMON%
	SMON%			;ADD OLD COUNT INTO CURRENT COPY OF MONITOR
	 JSYERR (<SETCNT: SMON% failed to set SPEAR error counter - >,<RET>)
	RETSKP			;GOOD RETURN...
   >	;REMOVAL OF SPRCNT CODE.


;DMPMAP	IS THE ROUTINE TO BUILD DUMP FILE MAP, DETERMINE MMAP PAGE
;	AND READ IN MMAP PAGE

DMPMAP:
	HRRZ T1,QUEJFN		;GET THE DUMP FILE JFN
	SETZ T2,		;POINT TO THE FIRST BYTE IN THE FILE
	SFPTR			;SET FILE POINTER
	 ERJMP DMPMER		;HANDLE ERRORS
	HRRZ T1,QUEJFN		;GET THE JFN
	BIN			;GET A BYTE FROM THE FILE
	 ERJMP DMPMER		;HANDLE ERRORS
	HLRZS T2		;GET THE ENTRY CODE
	CAIE T2,1776		;IS THIS AN EXE FILE?
	 JRST DMPMBD		;NO SO THIS IS BAD
DMPMLP:				;THIS IS THE MAPPING LOOP
	HRRZ T1,QUEJFN		;GET THE JFN
	BIN			;GET THE NEXT WORD
	 ERJMP DMPMER		;HANDLE ERROR
	MOVE P1,T2		;SAVE THE FIRST WORD
	HLRZS T2		;ZERO THE LEFT HALF
	CAIE T2,1775		;ENTRY VECTOR?
	 CAIN T1,1777		;END OF DIRECTORY?
	  JRST DMPMDN		;YES SO MAPPING PROCESS IS DONE
	BIN			;NOT END SO GET SECOND WORD OF GROUP
	 ERJMP DMPMER		;HANDLE ERRORS
	MOVE P2,T2		;SAVE THE SECOND WORD
	LDB T1,[POINT 27,P1,35]	;GET THE FILE PAGE NUMBER
	LDB T2,[POINT 27,P2,35]	;GET THE CORE PAGE NUMBER
	LDB T3,[POINT 9,P2,8]	;GET THE REPEAT COUNT
DMPML2:				;INNER PAGE MAP LOOP
	MOVEM T1,MAPADR(T2)	;SAVE THE PAGE NUMBER IN MAP
	MOVEM T2,PAGMAX		;SAVE THE MAX PAGE NUMBER
	AOJ T1,			;BUMP FILE PAGE
	AOJ T2,			;BUMP CORE PAGE
	SOJGE T3,DMPML2		;LOOP FOR THE REPEAT COUNT
	JRST DMPMLP		;DONE WITH THIS GROUP SO GET NEXT
DMPMDN:				;HERE WHEN MAPPING IS DONE
	HRRZ T1,QUEJFN		;GET THE JFN
	MOVEI T2,MSECWD		;POINTER TO MSECTB
	CALL READIN		;GET FROM DUMP
	MOVEM T2,MSCADR		;SAVE ADDRESS OF MSECTB
	MOVEI T2,SPTWD		;POINTER TO SPT
	CALL READIN		;GET FROM DUMP
	MOVEM T2,SPTADR		;SAVE ADDRESS OF SPT
	SETOM T2		;ALL ONES
	MOVEM T2,SECTN		;CURRENTLY MAPPED SECTION (I.E. NONE YET)
	AOS (P)			;BUMP THE RETURN ADDRESS
DMPMER:				;HERE ON ERROR DURING MAPPING
DMPMBD:				;HERE ON BAD EXE FILEE DIRECTORY
	RET			;RETURN TO CALLER

; MAPSEC IS THE ROUTINE TO MAP A SECTION MAP FROM THE DUMP FILE

MAPSEC:				;T2/ SECTION NUMBER TO MAP
	STKVAR <SEC>
	MOVEM T2,SEC
	SETO T1,		;UNMAP FUNCTION
	MOVX T2,<.FHSLF,,MMPPG>	;SECTION MAP PAGE
	MOVX T3,<PM%CNT!<1>B35>	;UNMAP ONE PAGE
	PMAP
	 ERJMP .+1		;IGNORE ERRROS
	MOVE T2,SEC
	ADD T2,MSCADR		;SECTION POINTER FOR DESIRED SECTION
	CALL READIN		;GET FROM DUMP
	LOAD T4,PTRCOD,T2	;GET POINTER TYPE
	CAIE T4,2		;IS IT A SHARE POINTER?
	 JRST DMPMBD		;NO, BAD DUMP
	LOAD T4,SPTX,T2		;YES, GET SPT OFFSET
	MOVE T2,SPTADR		;ADDRESS OF SPT
	ADD T2,T4		;LOCATION OF STORAGE ADDRESS
	CALL READIN		;GET FROM DUMP
	LOAD T2,STGADR,T2	;HERE IS PAGE OF MMAP
	SKIPN T1,MAPADR(T2)	;GET THE FILE PAGE OF MMAP PAGE
	 JRST DMPMBD		;BAD EXE FILE IF NO PAGE
	HRL T1,QUEJFN		;GET THE JFN
	MOVX T2,<.FHSLF,,MMPPG>	;PUT THE PAGE AT THE MMAP PAGE
	MOVX T3,<PM%RD>		;WE ONLY WANT TO READ THIS PAGE
	PMAP			;MAP IN THE PAGE
	 ERJMP DMPMER		;HANDLE ERROR
	MOVE T2,SEC		;GET SECTION
	MOVEM T2,SECTN		;SET CURRENTLY MAPPED SECTION
	RETSKP

; READIT IS THE ROUTINE TO READ THE CONTENTS OF A PARTICULAR WORD
;	OUT OF THE DUMP FILE. 

READIN:				;T2/ ADDRESS OF WORD
	HRRZ T1,QUEJFN		;DUMP FILE JFN
	MOVE T4,T2		;GET COPY
	ANDI T4,777		;GET OFFSET
	LSH T2,-9		;GET PAGE NUMBER
	MOVE T3,MAPADR(T2)	;FIND CORRESPONDING PAGE IN DUMP
	LSH T3,PGSFT		;FORM ADDRESS
	ADD T3,T4		;ADD IN OFFSET
	RIN			;READ WORD
	 ERJMP DMPMER		;ERROR
	SKIPG T2		;ANYTHING RETURNED?
	 JRST DMPMBD		;NO, THEN BAD DUMP
	RET			;RETURN WORD IN T2

;DMPRED	IS THE ROUTINE TO MAP PAGES FROM CRASHED MONITOR VIRTUAL
;	ADDRESS SPACE

DMPRED:				;ROUTINE TO MAP DUMP PAGES
				;T1/ PAGE NUMBER OF MONITOR
	STKVAR <MPAGE>
	MOVEM T1,MPAGE		;SAVE THE MONITOR PAGE NUMBER
	SETO T1,		;UNMAP FUNCTION
	MOVX T2,<.FHSLF,,TMPPG>	;TEMP PAGE ONE
	MOVX T3,<PM%CNT!<2>B35>	;UNMAP TWO PAGES
	PMAP			;UNMAP IO PAGES
	 ERJMP .+1		;IGNORE ERRROS
	LDB T2,[<POINT 9,MPAGE,26>] ;GET SECTION NUMBER
	CAMN T2,SECTN		;SECTION MAPPED?
	IFSKP.
	 CALL MAPSEC		;NO, MAP SECTION FIRST
	  JRST DMPRDB		;BAD EXE FILE RETURN
	 ENDIF.
	MOVE T1,MPAGE
	ANDI T1,777		;GET PAGHE IN SECTION
	MOVEI T2,TMPPG		;GET THE PAGE TO TARGET PAGE
	CALL DMPRD2		;CALL THE WORKER ROUTINE
	 JRST DMPRDB		;BAD EXE FILE RETURN
	MOVE T1,MPAGE		;GET THE MONITOR PAGE AGAIN
	ADDI T1,1		;WE WANT THE NEXT PAGE
	MOVEI T2,TMPPG+1	;MAP THE PAGE TO THE NEXT TARGET PAGE
	CALL DMPRD2		;CALL THE WORKER ROUTINE
	 JFCL			;ERROR IS OK
	AOS (P)			;BUMP THE RETURN PC
DMPRDB:				;BAD EXE FILE RETURN
	RET			;RETURN TO CALLER

DMPRD2:				;WORKER ROUTINE FOR DMPRED
	LDB T3,[POINT 3,MMPADR(T1),2] ;GET THE POINTER TYPE FOR PAGE
	CAIE T3,1		;IMMEDIATE?
	 RET			;NO SO LOSE
	HRRZ T1,MMPADR(T1)	;GET THE PHYSICAL PAGE NUMBER
	CAMLE T1,PAGMAX		;IS IT A LEGAL PAGE?
	 RET			;NO SO ERROR RETURN
	SKIPN T1,MAPADR(T1)	;GET THE FILE PAGE NUMBER
	 RET			;IF ZERO THEN ERROR RETURN
	HRL T1,QUEJFN		;GET THE DUMP FILE JFN
	HRLI T2,.FHSLF		;THIS FORK
	PMAP			;MAP THE PAGE
	 ERJMP [RET]		;HANDLE ERROR
	AOS (P)			;BUMP THE RETURN PC
	RET			;RETURN TO CALLER WITH SUCCESS


;CPYDMP - ROUTINE TO COPY <SYSTEM>DUMP.EXE TO <SYSTEM>DUMP.CPY
;
;ACCEPTS IN T1/	JFN OF ORIGINAL DUMP FILE
;	    T2/	# OF FILE PAGES TO COPY
;		CALL CPYDMP
;RETURNS: +1 ALWAYS



CPYDMP:	STKVAR <DMPJFN,DMPCNT,CPYJFN,CPYSIZ>
	MOVEM T1,DMPJFN		;SAVE JFN OF ORIGINAL DUMP FILE
	MOVEM T2,DMPCNT		;SAVE # OF FILE PAGES TO COPY
	IMULI T2,1000		;COMPUTE # OF WORDS TO BE COPIED
	SUBI T2,1		;COMPUTE # OF LAST WORD IN COPY FILE
	MOVEM T2,CPYSIZ		;SAVE # OF WORDS IN FILE
	CALL STRMOU		;Mount the disk DMP: implies
	MOVX T1,GJ%FOU!GJ%SHT	;GET A JFN TO MAKE THE COPY
	HRROI T2,[ASCIZ /DMP:DUMP.CPY;P770000/]
	GTJFN
	IFNSK.
	  MOVX T1,GJ%FOU!GJ%SHT
	  HRROI T2,[ASCIZ /PS:<SYSTEM>DUMP.CPY;P770000/]
	  GTJFN			;TRY ALTERNATE DESTINATION
	  IFNSK.
DMPERR:    TMSG <

*****************
? SETSPD: Failed to copy dump file because: >

	    MOVEI T1,.PRIOU	;THE DESTINATION
	    HRLOI T2,.FHSLF	;US
	    ERSTR		;OUTPUT THE ERROR
	     JFCL
	     JFCL
	    TMSG <
*****************
>
	    CALL UMPPGS		;UNMAP DUMP PAGES
	     SKIPE CPYJFN	;CHECK FOR DUMP.CPY JFN (TCO 6.1241)
	     IFNSK.		;THERE IS A JFN
		MOVX T1,CZ%ABT	;GET THE ABORT BIT FOR CLOSF
		HRR T1,CPYJFN	;GET THE JFN FOR CLOSF
		CLOSF		;CLOSE THE DUMP.CPY FILE
		ERJMP .+1	;ERROR PROBABLY MEANS NOT OPEN
	     ENDIF.
	    CALL STRDIS		;Dismount a structure if need be
	    RET			;RETURN
	  ENDIF.
	ENDIF.
	MOVEM T1,CPYJFN		;SAVE JFN OF DUMP.CPY
	MOVE T2,[440000,,OF%RD+OF%WR]
	OPENF			;OPEN THE COPY FILE
	 JRST DMPERR		;FAILED
	HRLI T1,.FBBYV		;CHANGE PROPER WORD
	MOVX T2,FB%RET		;SET THE RETENTION COUNT
	SETZ T3,		; TO INFINITY
	CHFDB			;DO IT
	ERJMP .+1		;IGNORE ANY ERRORS
	HRROI T1,[ASCIZ /
COPYING PREVIOUS SYSTEM DUMP TO:
/]
	PSOUT
	MOVEI T1,.PRIOU
	MOVE T2,CPYJFN		;GET JFN OF DUMP.CPY FILE
	SETZ T3,		;USE DEFAULT
	JFNS			;OUTPUT THE THE FILE NAME
	; ..
	; ..

; SET UP TO COPY THE FILE

	SETZM T4		;START WITH FILE PAGE 0
CPYD10:	MOVE T1,DMPCNT		;GET # OF PAGES TO COPY
	JUMPLE T1,CPYD20	;IF DONE, GO UNMAP THE PAGES
	SUBI T1,CPYPGS		;COMPUTE # OF PAGES LEFT TO COPY
	MOVEM T1,DMPCNT		;SAVE NEW # OF PAGES TO COPY
	HRL T1,DMPJFN		;GET JFN OF ORIGINAL DUMP FILE
	HRR T1,T4		;GET FILE PAGE NUMBER
	MOVE T2,[.FHSLF,,DMPPG]	;THIS FORK, FIRST PAGE TO MAP DUMP FILE
	MOVEI T3,CPYPGS		;GET # OF PAGES TO MAP
	SKIPGE DMPCNT		;NEED TO MAP LESS THAN THIS MANY ?
	ADD T3,DMPCNT		;YES, COMPUTE # REMAINING TO BE MAPPED
	TXO T3,PM%RD+PM%WR+PM%PLD+PM%CNT
	PMAP			;MAP THE PAGES FROM THE ORIGINAL FILE
	 ERJMP DMPERR		;JUST IN CASE
	HRL T1,CPYJFN		;GET JFN OF COPY FILE
	HRR T1,T4		;GET FILE PAGE NUMBER
	MOVE T2,[.FHSLF,,CPYPG]	;THIS FORK, FIRST PAGE OF COPY FILE DATA
	TXZ T3,PM%PLD		;NO PRE-LOADING
	PMAP			;MAP THE COPY FILE
	 ERJMP DMPERR		;JUST IN CASE
	MOVE T1,[DMPADR,,CPYADR] ;SET UP TO COPY DATA
	BLT T1,CPYADR+CPYWDS-1	;COPY DATA
	ERJMP DMPERR		;IN CASE DISK IS FULL.
	ADDI T4,CPYPGS		;COMPUTE ADDRESS OF NEXT FILE PAGE
	JRST CPYD10		;LOOP OVER ALL PAGES TO COPY

; HERE WHEN COPY IS COMPLETE

CPYD20:	CALL UMPPGS		;UNMAP DUMP PAGES
	HRRZ T1,CPYJFN		;GET JFN OF NEW FILE
	HRLI T1,.FBSIZ		;GET OFFSET TO EOF POINTER
	SETOM T2		;CHANGE ALL BITS IN THE WORD
	MOVE T3,CPYSIZ		;GET # OF LAST WORD IN FILE
	CHFDB			;SET THE EOF POINTER
	HRRZ T1,CPYJFN		;GET JFN OF COPY FILE
	CLOSF			;CLOSE NEW FILE
	 JRST DMPERR		;FAILED, REPORT ERROR
	CALL STRDIS		;Get rid of the structure if need be
	RET			;RETURN

;Copy dump continued...

;Routine to mount the structure (all of it) that is implied by the expansion
;of DMP:.

STRMOU:	
	MOVE  T1,RTYTIM		;get the amount of time for retrying
	MOVEM T1,TIMVAL		;this is for CI disks
STRRTY:				;here is our retry entry point
	MOVX T1,.LNSSY		;Lookup a system-wide logical name 
	HRROI T2,[ASCIZ |DMP|]	;Logical name without colon
	SETZ T3,		;We don't want the translation
	LNMST			;See if a logical name DMP:
	 RET			;Return now if no DMP:
	MOVX T1,<GJ%SHT!GJ%OFG>	;This is the short form and parse only
	HRROI T2,[ASCIZ |DMP:|]	;Logical name for dump structure
	GTJFN			;Get a parse only JFN on DMP:
	 RET			;If it fails, leave now
	HRRZM T1,T2		;Set up the JDN in the right place
	HRROI T1,DMPSTR		;Loc for the name of the structure
	MOVX T3,FLD(.JSAOF,JS%DEV) ;Only output device field
	SETZ T4,		;No file attribute
	JFNS			;Get the device implied by DMP:
	 ERJMP [RET]		;Fail and try default
	HRROI T1,DMPSTR		;Point to that structure name
	STDEV			;String to device designator
	IFSKP.
	 RET			;No error, means no mounting needed.
	ENDIF.	

;Here when we have real work to do. Loop over all disks looking for all units
;in the dump structure.
;
	SETOM MSTRAD+.MSRCH	;Start with the first unit
	SETOM MSTRAD+.MSRCT	;  and the first controller
	SETOM MSTRAD+.MSRUN	;  and the first unit
DSKLOP:	MOVE T1,[XWD .MSRLN,.MSRNU] ;Length of args,,function code
	MOVEI T2,MSTRAD		;Address of the MSTR block
	HRROI T3,CURSTR		;Byte pointer to the name of current structure
	MOVEM T3,MSTRAD+.MSRSN	;Store in the arg block
	HRROI T3,ALISTR		;Byte pointer to current structure alias
	MOVEM T3,MSTRAD+.MSRSA	;Store it in the arg block
	MSTR			;Get disk info
	 ERJMP MSTRER		;Handle an MSTR failure
	HRROI T1,CURSTR		;Get the name of the current structure
	HRROI T2,DMPSTR		;Is this the one we seek (Sorry)
	STCMP			;Compare the strings
	SKIPN T1		;Are the strings the same???
	 JRST FNDSTR		;We have found the structure, go mount it
	JRST DSKLOP		;Loop for more disks


; Here when we have found the disk name we are looking for and are ready to
;mount the critter. But first we must loop to find the other units and build
;the mount block.
;
FNDSTR:	HRRZ T1,MSTRAD+.MSRNS	;Get the number of units in this structure
	MOVEM T1,NUMUNT		;Store
	MOVEM T1,UNTLFT		;Also store as the number of units left to find
UNTLOP:	SOS UNTLFT		;Show that we have touched this unit
	HLRZ T1,MSTRAD+.MSRNS	;Get the unit number within the structure
	IMULI T1,.MSTNO		;Multiply by the block size to get the offset
	ADDI T1,<MNTBLK+.MSTUI>	;Now make it the base addr of the unit block
	MOVE T2,MSTRAD+.MSRCH	;Get the channel number
	MOVEM T2,.MSTCH(T1)	;Store the channel number in the unit block
	MOVE T2,MSTRAD+.MSRCT	;Get the controller number
	MOVEM T2,.MSTCT(T1)	;Store in unit block
	MOVE T2,MSTRAD+.MSRUN	;Get the unit number
	MOVEM T2,.MSTUN(T1)	;Store in the unit block
	SKIPG UNTLFT		;Are there any more units left to be done???
	 JRST MNTDSK		;No, mount the disk
NXTUNT:	MOVE T1,[XWD .MSRLN,.MSRNU] ;Arg block len,,function code
	MOVEI T2,MSTRAD		;Point to the arg block
        HRROI T3,CURSTR         ; Re-initialize the string 
        MOVEM T3,MSTRAD+.MSRSN  ;   pointers for the structure name
        HRROI T3,ALISTR         ;     and alias
        MOVEM T3,MSTRAD+.MSRSA  ;       before comparing each unit
	MSTR			;Get the status of the next unit
	 ERJMP MSTRER		;handle an MSTR failure
	HRROI T1,DMPSTR		;Get the name of the dump structure
	HRROI T2,CURSTR		;Do they match???
	STCMP			;Compare the strings
	SKIPE T1		;Do they match???
	 JRST NXTUNT		;No, dont count this one in unit list
	JRST UNTLOP		;Loop to get all the units

; Here to mount the disk (at last)...
;
MNTDSK:	MOVEI T1,.MSTNO		;Get the length of the unit blocks
	IMUL T1,NUMUNT		;Multiply by the number of units
	ADDI T1,.MSTFL+1	;Add the overhead words
	HRLZS T1		;Move the length to the left half
	HRRI T1,.MSMNT		;Add the function code
	MOVEI T2,MNTBLK		;Point to the nase of the mount block
	HRROI T3,DMPSTR		;Byte pointer to structure name
	MOVEM T3,MNTBLK+.MSTNM	;Store in the arg block
	MOVEM T3,MNTBLK+.MSTAL	;Store as the alias as well
;	MOVX T3,<MS%XCL>	;Flag for making disk my very own, for me alone
	MOVE T3,NUMUNT		;Get the number of units in the structure
	MOVEM T3,MNTBLK+.MSTFL	;Store in the mount block
	MSTR			;Mount the structure
	 ERJMP MSTRER		;Handle MSTR errors
	SETOM STRFLG		;Set flag that we have a structure to dismount
	HRROI T1,DMPSTR		;Point to the structure name
	MOVEM T1,MSTRAD		;Store pointer in arg block
	MOVE T1,[XWD .MSDEV+1,.MSIMC] ;Setup MSTR AC, Arg len,arg block addr
	MSTR			;Increment structure mount count
	 ERJMP MSTRER		;Handle MSTR errors
	RET			;And return


; Here on MSTR errors. We expect to see no more units but
;others are fatal to copying the dump if this is the structure we are trying
;to copy to...
;
MSTRER:	MOVX T1,.FHSLF		;We want our own last error
	GETER			;Get the error
	HRRZS T2		;Get just the error number part
	CAIN T2,MSTX18		;Is it end of useful drives???
	 IFNSK.
	  MOVE T1,TIMVAL	;get our timer value
	  CAME T1,RTYTIM	;is this our first retry?
	   IFSKP.		;if so, warn of retry delays..
	    TMSG <
*****************
%SETSPD: Waiting to see if dump structure comes online...
*****************
>
	   ENDIF.
	  MOVE T1,TIMVAL	;Get our timer value again
	  SUBI T1,^D1000	;subtract 1 second
	  MOVEM T1,TIMVAL
	  SKIPG TIMVAL		;still got more time to retry?
	   IFSKP.
	    MOVEI T1,^D1000	;Yes, sleep for 1 second
	    DISMS
	    JRST STRRTY		;Go back and retry
	   ENDIF.
				;No more retry time, tell world.
	  TMSG <
*****************
?SETSPD: Could not find dump structure, trying default
*****************
>
	  RET			;And punt on mount attempt
	 ENDIF.
FATERR:	TMSG <
*****************
?SETSPD: Unexpected MSTR JSYS failure, >
	PSOUT			;Output the first part of the text
	MOVX T1,.PRIOU		;List primary output device for error string
	HRLOI T2,.FHSLF		;My last error please
	SETZ T3,		;No limit on the string please
	ERSTR			;Output the error string
	 JFCL
	 JFCL
	TMSG <
*****************
>
	RET			;All done, return now

;STRDIS

;Dismount a structure we copied a dump to.
;
STRDIS:	SKIPN STRFLG		;Is there a structure to dismount???
	 RET			;No, return no, nothing to do here
	HRROI T1,[ASCIZ \
\]
	PSOUT			;Add a <CRLF> such that CTY is readable
	MOVE T1,[XWD <.MSDNM+1>,.MSDIS]	;Length,,function code for MSTR
	MOVEI T2,MSTRAD		;Pointer to arg block
	HRROI T3,DMPSTR		;Point to structure to be dismounted
	MOVEM T3,MSTRAD		;Store in the arg block
	MSTR			;Dismount the structure
	 ERJMP MSTRER		;Handle MSTR errors
	SETZM STRFLG		;Say we dismounted the structure
	RET			;And return

;COPY DUMP CONTINUED....

;ROUTINE TO UNMAP DUMP PAGES ON NORMAL COMPLETION OR ERROR

UMPPGS:	SETOM T1		;UNMAP THE PAGES
	MOVE T2,[.FHSLF,,DMPPG]	;PAGES MAPPED TO ORIGINAL FILE
	MOVE T3,[PM%CNT+CPYPGS]	;NUMBER OF PAGES TO UNMAP
	PMAP			;UNMAP THE PAGES
	MOVE T2,[.FHSLF,,CPYPG]	;PAGES MAPPED TO COPY FILE
	PMAP			;UNMAP THE PAGES
	RET			;AND DONE

;ROUTINES TO BUFFER A STRING.  GIVE IT POINTER TO STRING IN A.
;ROUTINE RETURNS POINTER TO BUFFERED STRING IN A.
;THE STRING ALWAYS BEGINS ON A WORD BOUNDARY.  (SOME CALLERS ASSUME SO!)

BUFFS:	MOVEI B,DICT		;SAY WHERE POOL STARTS
	CALL READNM		;COPY STRING INTO FREE SPACE
	 COMERR <String space exhausted>
	RET

;BUFFF buffers the atom buffer
;
;Returns +1:	A/	pointer to buffered atom

BUFFF:	HRROI A,ATMBUF		;POINT TO THE ATOM
	CALLRET BUFFS		;BUFFER IT AND RETURN

;ROUTINE TAKING A STRING POINTER IN A.  IT COPIES THE STRING TO FREE SPACE
;AND TAKES A SKIP RETURN, YIELDING THE POINTER TO THE STRING IN
;A.  IF NO ROOM FOR THE STRING, A NON-SKIP RETURN IS TAKEN AND CONTENTS
;OF A IS INDETERMINATE
;GIVE IT FREE POOL HEADER ADDRESS IN B

READNM:	STKVAR <FPA,RPTR,NEWPTR>
	MOVEM A,RPTR		;REMEMBER POINTER
	MOVEM B,FPA		;REMEMBER FREE POOL ADDRESS
	CALL BCOUNT		;HOW MANY WORDS IN THIS STRING?
	MOVE B,FPA		;SAY WHICH FREE POOL TO USE
	CALL GETMEM		;GET THAT MANY
	 JRST NOREAD		;COULDN'T, SO TAKE NON-SKIP RETURN
	HRLI B,440700		;MAKE BYTE POINTER TO SPACE OBTAINED
	MOVEM B,NEWPTR		;REMEMBER NEW POINTER
	MOVE A,B
	MOVE B,RPTR		;GET POINTER TO STRING
	MOVEI C,0		;STORE NULL AT END OF STRING
	SOUT			;COPY THE STRING
	MOVE A,NEWPTR		;GET ADDRESS WHERE STRING GOT PUT
	RETSKP			;SUCCESFUL RETURN
NOREAD:	RET			;NO ROOM FOR STRING

;ROUTINE TO GET MEMORY BLOCK.  RETURNS +1 ALWAYS WITH ADDRESS OF BLOCK
;IN A.  GIVE IT NUMBER OF WORDS DESIRED IN A.

GETBUF:	MOVEI B,DICT	;USE CORRECT POOL
	CALL GETMEM	;GET THE MEMORY
	 ERROR <SETSPD: free space exhausted>
	MOVE A,B		;RETURN ADDRESS IN A
	RET

; /GETMEM/ - ROUTINE TO ASSIGN MEMORY AS REQUESTED
; INPUTS:	A - CONTAINS NUMBER OF WORDS WANTED
;		B - FREE SPACE HEADER ADDRESS
; OUTPUTS:	A - NUMBER OF WORDS OBTAINED
;		B - CONTAINS ADDRESS OF WORDS GOTTEN
; RETURNS:	SKIPS IF SUCCESSFUL, NON-SKIP IF NO ROOM

GETMEM:	STKVAR <<SAVSTF,2>,DADR>
	MOVEM B,DADR		;REMEMBER HEADER ADDRESS
GETM2:	MOVE C,B			;REMEMBER WHO POINTS TO CURRENT
	HRRZ B,0(C)		;B IS NOW CURRENT BLOCK
	JUMPE B,R			;IF 0, WE HAVE REACHED END OF THE ROAD
	HLRZ D,0(B)		;GET SIZE OF CURRENT BLOCK
	CAMGE D,A			;IS IT SUFFICIENT FOR REQUEST?
	JRST GETM2			;NO, SO TRY NEXT BLOCK
GETM3:	HRL B,0(B)		;GET LINK OF CURRENT BLOCK
	HLRM B,0(C)		;MAKE PREV LINK BE WHAT WAS OUR LINK
	HRRZS B			;ISOLATE CURRENT BLOCKS ADDRESS
	CAMN D,A			;IS THIS AN EXACT MATCH ON SIZE?
	RETSKP				;SUCCESS, SKIP RETURN
	DMOVEM A,SAVSTF		;SAVE NUMBER OF WORDS AND ADDRESS
	ADD B,A			;GET FIRST WORD TO RETURN
	SUBM D,A			;NUMBER OF WORDS TO RETURN
	MOVE C,DADR		;GET ADDRESS OF CONTROL WORD
	CALL RETMEM		;RETURN THE EXTRA WORDS
	DMOVE A,SAVSTF		;RESTORE NUMBER OF WORDS AND ADDRESS
	RETSKP				;SUCCESS, SKIP RETURN

;STREM ROUTINE TAKES POINTER TO STRING IN A, AND "REMOVES" THE STRING
;FROM THE STRING STORAGE SPACE.  THE SPACE WHERE THE STRING WAS IS
;RETURNED TO FREE SPACE

STREM:	SAVEAC <A,B,C,D>	; NEED TO BE TRANSPARENT
	STKVAR <SPT000>
	MOVEM A,SPT000		;REMEMBER POINTER
	CALL BCOUNT		;COUNT NUMBER OF WORDS IN THE STRING
	HRRZ B,SPT000		;GET RID OF BYTE POINTER P AND S
	CALLRET RETBUF		;RETURN THE BUFFER

;RETBUF RETURNS A BUFFER TO FREE STORAGE
;	A/	SIZE BEING RETURNED
;	B/	ADDRESS OF BLOCK BEING RETURNED

RETBUF:	MOVEI C,DICT		;SAY WHERE FREE SPACE IS
	CALLRET RETMEM		;RETURN THE SPACE TO THE FREE POOL

; /RETMEM/ - ROUTINE TO DE-ALLOCATE MEMORY WHEN WE ARE THROUGH WITH IT
; INPUT:	A - CONTAINS SIZE OF BLOCK TO RETURN
;		B - CONTAINS ADDRESS OF BLOCK BEING RETURNED
;		C - FREE SPACE HEADER ADDRESS
; OUTPUT:	NONE
; RETURNS: ALWAYS CPOPJ
;

RETMEM:	HRRZ D,0(C)		;GET PREV'S LINK
	SKIPE	D			;IF CURRENT IS 0 OR
	CAIL D,0(B)		;  ITS ADDRESS IS PAST ADDR OF RETURN BLK
	JRST RETM4			; THEN RETURN BLOCK HERE
	MOVE C,D			;MAKE PREV=CURRENT
	JRST RETMEM			;CONTINUE

RETM4:	HRRM D,0(B)		;FORWARD PTR OF RETURNED BLOCK
	HRRM B,0(C)		;FORWARD PTR OF PREV BLOCK
	HRLM A,0(B)		;STORE SIZE OF THIS BLOCK
	ADD A,B			;ADD ADDR+SIZE
	CAIE A,0(D)		;ARE WE RIGHT UP AGAINST NEXT BLOCK?
	JRST RETM5			;NO, CANT COMBINE
	HRRZ A,0(D)		;GET NEXT GUYS FORWARD LINK
	HRRM A,0(B)		;MAKE IT OURS. IE POINT PAST HIM
	HLRZ A,0(B)		;GET OUR SIZE
	HLRZ D,0(D)		;GET HIS SIZE
	ADD A,D			;GET OUR NEW COMBINED SIZE
	HRLM A,0(B)		;STORE INTO RETURNED BLOCK
	HRRZ D,0(B)		;GET LINK OF CURRENT BLOCK
RETM5:	HLRZ A,0(C)		;GET PREV BLOCKS SIZE
	ADDI A,0(C)		;ADD HIS ADDRESS AND SIZE
	CAIE A,0(B)		;DOES HE BUTT RIGHT UP AGAINST US?
	RET			;NO, RETURN WITH NO COMBINATION
	HRRM D,0(C)		;MAKE PREV POINT TO OUR NEXT
	HLRZ A,0(C)		;GET HIS SIZE
	HLRZ B,0(B)		;AND OUR SIZE
	ADD A,B			;COMBINE THE SIZES
	HRLM A,0(C)		;STORE COMBINED SIZE
	RET			;RETURN

;ROUTINE TO INITIALIZE FREE SPACE STORAGE.

FREINI:	SETZM DICT		;INITIALIZE FREE SPACE SYSTEM
	MOVEI A,FRESIZ		;FREE UP THIS MUCH FREE SPACE (ALL OF IT!)
	MOVEI B,FREE		;STARTS AT ADDRESS IN B
	CALL RETBUF		;FREE IT UP IN STANDARD WAY
	MOVEI A,STRSIZ		;ALLOCATE SOME SPACE FOR STRINGS
	CALL GETBUF
	HRLI A,440700		;MAKE POINTER TO STRING STORAGE
	MOVEM A,CSBUFP		;REMEMBER POINTER TO STRING STORAGE
	RET

;FIXPT changes byte pointer with -1 in left half to have 440700 in left half.
;
;Accepts:	A/	pointer
;
;Returns+1:	A/	converted pointer

FIXPT:	TLC A,-1		;CHANGE -1 TO 0
	TLCN A,-1		;RESTORE BITS AND SKIP IF ANY ARE NOW ON
	HRLI A,440700		;THEY WERE ALL OFF SO MUST HAVE BEEN ALL ON
	RET

;BCOUNT MEASURES AN ASCIZ STRING.
;
;ACCEPTS:	A/	POINTER (-1,,FOO O.K.!)
;
;RETURNS+1:	A/	NUMBER OF WORDS NEEDED IN A
;		B/	NUMBER OF CHARACTERS

BCOUNT:	CALL FIXPT		;CHANGE -1 TO 440700
	MOVEI B,0		;B WILL ACCUMULATE COUNT OF BYTES
BC1:	ILDB C,A		;READ NEXT BYTE
	CAIE C,0		;DONE COUNTING IF NULL SEEN
	AOJA B,BC1		;NOT DONE, KEEP COUNTING
	MOVE D,B		;REMEMBER EXACT COUNT IN D
	AOJ B,			;LEAVE ROOM FOR NULL
	IDIVI B,5		;GET NUMBER OF WORDS
	CAIE C,0		;EXTRA CHARACTERS?
	AOJ B,			;YES, THEY TAKE A WHOLE WORD
	MOVE A,B
	MOVE B,D		;RETURN BYTE COUNT IN B
	RET
SYSERR:	BLOCK ^D512

; CACHE REFILL ALGORITHM RAM LOADING INSTRUCTIONS
; *** CURRENTLY PERFORMS NO FUNCTION ***

	REPEAT 0,<		;DISABLE THIS CODE
REFILL:
	USRIO			;TURN ON USER IOT
	 RET			;FAILED
	BLKO APR,0
	BLKO APR,100004
	BLKO APR,200010
	BLKO APR,300014
	BLKO APR,400020
	BLKO APR,500024
	BLKO APR,600030
	BLKO APR,700034
	BLKO APR,300040
	BLKO APR,100044
	BLKO APR,200050
	BLKO APR,300054
	BLKO APR,200060
	BLKO APR,100064
	BLKO APR,200070
	BLKO APR,300074
	BLKO APR,700100
	BLKO APR,100104
	BLKO APR,200110
	BLKO APR,700114
	BLKO APR,100120
	BLKO APR,100124
	BLKO APR,200130
	BLKO APR,700134
	BLKO APR,600140
	BLKO APR,500144
	BLKO APR,600150
	BLKO APR,700154
	BLKO APR,500160
	BLKO APR,500164
	BLKO APR,600170
	BLKO APR,700174
	BLKO APR,000200
	BLKO APR,300204
	BLKO APR,200210
	BLKO APR,300214
	BLKO APR,000220
	BLKO APR,200224
	BLKO APR,200230
	BLKO APR,300234
	BLKO APR,000240
	BLKO APR,100244
	BLKO APR,200250
	BLKO APR,300254
	BLKO APR,400260
	BLKO APR,500264
	BLKO APR,600270
	BLKO APR,700274
	BLKO APR,000300
	BLKO APR,700304
	BLKO APR,700310
	BLKO APR,700314
	BLKO APR,000320
	BLKO APR,000324
	BLKO APR,000330
	BLKO APR,700334
	BLKO APR,400340
	BLKO APR,600344
	BLKO APR,600350
	BLKO APR,600354
	BLKO APR,400360
	BLKO APR,400364
	BLKO APR,600370
	BLKO APR,400374
	BLKO APR,300400
	BLKO APR,100404
	BLKO APR,300410
	BLKO APR,300414
	BLKO APR,100420
	BLKO APR,100424
	BLKO APR,100430
	BLKO APR,300434
	BLKO APR,000440
	BLKO APR,700444
	BLKO APR,700450
	BLKO APR,700454
	BLKO APR,000460
	BLKO APR,000464
	BLKO APR,000470
	BLKO APR,700474
	BLKO APR,000500
	BLKO APR,100504
	BLKO APR,200510
	BLKO APR,300514
	BLKO APR,400520
	BLKO APR,500524
	BLKO APR,600530
	BLKO APR,700534
	BLKO APR,400540
	BLKO APR,500544
	BLKO APR,500550
	BLKO APR,700554
	BLKO APR,400560
	BLKO APR,500564
	BLKO APR,400570
	BLKO APR,700574
	BLKO APR,000600
	BLKO APR,100604
	BLKO APR,200610
	BLKO APR,200614
	BLKO APR,000620
	BLKO APR,100624
	BLKO APR,200630
	BLKO APR,100634
	BLKO APR,000640
	BLKO APR,500644
	BLKO APR,600650
	BLKO APR,600654
	BLKO APR,000660
	BLKO APR,500664
	BLKO APR,600670
	BLKO APR,000674
	BLKO APR,400700
	BLKO APR,500704
	BLKO APR,600710
	BLKO APR,500714
	BLKO APR,400720
	BLKO APR,500724
	BLKO APR,600730
	BLKO APR,400734
	BLKO APR,000740
	BLKO APR,100744
	BLKO APR,200750
	BLKO APR,300754
	BLKO APR,400760
	BLKO APR,500764
	BLKO APR,600770
	BLKO APR,700774
	RET			;AND DONE
>				;END OF REPEAT ZERO
	END <ENVLEN,,ENTVEC>
